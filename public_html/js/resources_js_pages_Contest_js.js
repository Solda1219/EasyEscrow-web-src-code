(self["webpackChunk"] = self["webpackChunk"] || []).push([["resources_js_pages_Contest_js"],{

/***/ "./node_modules/@bloks/constants/dist/constants.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bloks/constants/dist/constants.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ANCHOR": () => (/* binding */ ANCHOR),
/* harmony export */   "CLEOS": () => (/* binding */ CLEOS),
/* harmony export */   "CLIO": () => (/* binding */ CLIO),
/* harmony export */   "Constants": () => (/* binding */ Constants),
/* harmony export */   "DEFAULT_CHAIN": () => (/* binding */ DEFAULT_CHAIN),
/* harmony export */   "DEFAULT_SYMBOL": () => (/* binding */ DEFAULT_SYMBOL),
/* harmony export */   "DEFAULT_SYSTEM_DOMAIN": () => (/* binding */ DEFAULT_SYSTEM_DOMAIN),
/* harmony export */   "EOSAUTH": () => (/* binding */ EOSAUTH),
/* harmony export */   "EOSC": () => (/* binding */ EOSC),
/* harmony export */   "KEYCAT": () => (/* binding */ KEYCAT),
/* harmony export */   "LEDGER": () => (/* binding */ LEDGER),
/* harmony export */   "LEDGER_BLE": () => (/* binding */ LEDGER_BLE),
/* harmony export */   "LEDGER_USB": () => (/* binding */ LEDGER_USB),
/* harmony export */   "LEDGER_WEBHID": () => (/* binding */ LEDGER_WEBHID),
/* harmony export */   "LEDGER_WEBUSB": () => (/* binding */ LEDGER_WEBUSB),
/* harmony export */   "LYNX": () => (/* binding */ LYNX),
/* harmony export */   "PROTON": () => (/* binding */ PROTON),
/* harmony export */   "PROTON_WEB": () => (/* binding */ PROTON_WEB),
/* harmony export */   "SCATTER_DESKTOP": () => (/* binding */ SCATTER_DESKTOP),
/* harmony export */   "SCATTER_DESKTOP_MANUAL": () => (/* binding */ SCATTER_DESKTOP_MANUAL),
/* harmony export */   "SCATTER_EXTENSION": () => (/* binding */ SCATTER_EXTENSION),
/* harmony export */   "SIMPLEOS": () => (/* binding */ SIMPLEOS),
/* harmony export */   "SQRL": () => (/* binding */ SQRL),
/* harmony export */   "TREZOR": () => (/* binding */ TREZOR),
/* harmony export */   "WAX_CLOUD_WALLET": () => (/* binding */ WAX_CLOUD_WALLET),
/* harmony export */   "WOMBAT": () => (/* binding */ WOMBAT),
/* harmony export */   "chainInfo": () => (/* binding */ chainInfo),
/* harmony export */   "chainToNetworkConstantsMap": () => (/* binding */ chainToNetworkConstantsMap),
/* harmony export */   "constants": () => (/* binding */ constants$c),
/* harmony export */   "dapps": () => (/* binding */ dapps),
/* harmony export */   "exchanges": () => (/* binding */ exchanges),
/* harmony export */   "getContractConstants": () => (/* binding */ getContractConstants),
/* harmony export */   "historyTypesFeatures": () => (/* binding */ historyTypesFeatures)
/* harmony export */ });
var DEFAULT_SYMBOL = 'EOS';
var DEFAULT_SYSTEM_DOMAIN = 'eosio';
var DEFAULT_CHAIN = 'eos';

var getContractConstants = function getContractConstants(chain, systemDomain) {
  if (chain === void 0) {
    chain = DEFAULT_CHAIN;
  }

  if (systemDomain === void 0) {
    systemDomain = DEFAULT_SYSTEM_DOMAIN;
  }

  // Proxy Information Account
  var proxyInfo;

  if (['eos', 'bos', 'wax'].includes(chain)) {
    proxyInfo = 'regproxyinfo';
  } else if (chain === 'telos') {
    proxyInfo = 'tlsproxyinfo';
  }

  return {
    // Accounts
    EOSIO: systemDomain,
    EOSIO_TOKEN: !['fio', 'fio-test'].includes(chain) ? systemDomain + ".token" : 'fio.token',
    ACCOUNT_INFO: 'account.info',
    PROXY_INFO_ACCOUNT: proxyInfo,
    EOSIO_MSIG: systemDomain + ".msig",
    EOSIO_RAM: systemDomain + ".ram",
    EOSIO_STAKE: systemDomain + ".stake",
    EOSIO_PRODS: systemDomain + ".prods",
    EOSIO_NULL: systemDomain + ".null",
    EOSIO_RAMFEE: systemDomain + ".ramfee",
    EOSIO_VPAY: systemDomain + ".vpay",
    EOSIO_BPAY: systemDomain + ".bpay",
    EOSIO_REX: systemDomain + ".rex",
    // Params
    NEWACCOUNT_NAME_PARAM: chain.indexOf('bos') === -1 ? 'name' : 'newact',
    // Tables
    EOSIO_MSIG_APPROVALS_TABLE: 'approvals2',
    EOSIO_MSIG_PROPOSALS_TABLE: 'proposal',
    // Actions
    TRANSFER_ACTION: 'transfer',
    DELEGATE_BW_ACTION: 'delegatebw',
    UNDELEGATE_BW_ACTION: 'undelegatebw',
    VOTE_PRODUCER_ACTION: 'voteproducer',
    BUY_RAM_ACTION: 'buyram',
    BUY_RAM_BYTES_ACTION: 'buyrambyes',
    SELL_RAM_ACTION: 'sellram'
  };
};

var dapps = [{
  name: 'Alcor.exchange',
  description: 'The first self-listing DEX. With Alcor you can trade any EOS.IO tokens for system EOS tokens, atomically, without the participation of third parties! Create markets in one click, list your dapp token for one click, trade whatever you want.',
  shortDescription: 'The first self-listing DEX. With Alcor you can trade any EOS.IO tokens for system EOS tokens.',
  symbol: '',
  statistics: true,
  accounts: ['eostokensdex'],
  logo: 'https://i.ibb.co/dKDYDMc/vectorpaint.png',
  website: 'https://alcor.exchange/',
  app: 'https://alcor.exchange/',
  telegram: 'https://t.me/alcorexchange',
  medium: 'https://medium.com/@avral',
  twitter: 'https://twitter.com/avral_pro',
  github: 'https://github.com/avral/alcor-ui',
  chains: ['eos', 'wax', 'telos']
}, {
  name: 'SX',
  description: 'Building secure & reliable financial blockchain instruments',
  shortDescription: 'DeFi Swap & Flashloan',
  symbol: 'SX',
  accounts: ['swap.sx', 'vigor.sx', 'stable.sx', 'flash.sx', 'push.sx', 'network.sx', 'registry.sx', 'miner.sx', 'cross.sx', 'nav.sx', 'fee.sx', 'trade.sx', 'vaults.sx', 'proxy.sx', 'dust.sx', 'curve.sx'],
  logo: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/sx.png',
  website: 'https://github.com/stableex',
  app: 'https://xnation.io',
  telegram: 'https://t.me/xnationio',
  medium: '',
  twitter: '',
  github: 'https://github.com/stableex',
  chains: ['eos']
}, {
  name: 'EOSNameService',
  description: 'EOS Name Service is the most comprehensive platform to register premium/base EOS/WAX account names.',
  shortDescription: 'EOS/WAX Name Service',
  symbol: '',
  partner: false,
  accounts: ['names'],
  logo: 'https://avatars1.githubusercontent.com/u/73891041',
  website: 'http://eosnameservice.io',
  app: 'http://eosnameservice.io',
  telegram: 'https://t.me/eosnameservice',
  medium: '',
  twitter: 'https://twitter.com/eosnameservice',
  github: 'https://github.com/eosnameservice',
  chains: ['eos', 'wax']
}, {
  name: 'Prospectors',
  description: 'Massive Multiplayer Online Real-Time Economic Strategy Game  MINE GOLD - BUILD YOUR WORLD',
  shortDescription: 'Massive Multiplayer Online Real-Time Economic Strategy Game',
  symbol: '',
  accounts: ['prospectorsc'],
  logo: 'https://bloks.io/img/dapps/prospectors.png',
  website: 'https://prospectors.io',
  app: 'https://prospectors.io',
  telegram: 'https://t.me/prospectorsgame',
  medium: 'https://medium.com/@prospectorsgame',
  twitter: 'https://twitter.com/prospectorsgame',
  github: 'https://github.com/prospectors/public/issues',
  chains: ['eos']
}, {
  name: 'APPICS',
  description: 'APPICS is the most engaged social media dApp that makes it easy to get rewarded with cryptocurrency for your social media activity like creating & curating content. The mobile interface is intuitive to use without any prior blockchain knowledge. Get rewarded for your passion!',
  shortDescription: 'APPICS is the most engaged social media dApp - earn APX Tokens for posting, commenting, and up-voting photos & videos!',
  symbol: 'APX',
  statistics: true,
  accounts: ['appicsappics'],
  logo: 'https://i.imgur.com/Ts9CNN5.png',
  website: 'https://appics.com',
  app: 'https://appics.com',
  telegram: 'https://t.me/appics_official',
  medium: 'https://medium.com/@appics',
  twitter: 'https://twitter.com/appics_official',
  github: 'https://github.com/phenom-company/appics_eos_token',
  chains: ['eos']
}, {
  name: 'Boid',
  description: 'Contribute your excess computing resources towards important causes while earning rewards. Join a team and rank up on the social leaderboards.',
  shortDescription: 'The Social Supercomputer. Contribute your excess computing resources towards important causes.',
  symbol: '',
  accounts: ['boidcomtoken', 'boidcompower', 'boidcommint1', 'boidcompromo'],
  logo: 'https://raw.githubusercontent.com/boid-com/assets/master/boidLogo-lg.png',
  website: 'https://boid.com',
  app: 'https://app.boid.com',
  telegram: 'https://t.me/Boidcom_official',
  medium: 'https://medium.com/@boidcom',
  twitter: 'https://twitter.com/boidcom',
  github: 'https://github.com/boid-com',
  chains: ['eos']
}, {
  name: 'The Billionaire Token',
  description: 'Most other coins or tokens have some sort of mining system. Billionaire Token has the exact opposite: It features a deflationary mechanism that destroys 30% of the gambled coins. Thus the tokens become more and more rare as more and more people gamble.',
  shortDescription: 'Billionaire Token has the opposite of a mining system: It features a deflationary mechanism that destroys 30% of the gambled coins.',
  symbol: 'XBL',
  accounts: ['billionairet', 'billionraffl', 'billionburnr', 'billionbot11', 'billionbot12', 'billionbot13', 'billionbot14'],
  app: 'https://BillionaireToken.com/',
  logo: 'https://BillionaireToken.com/images/logo_big.png',
  website: 'https://BillionaireToken.com/',
  telegram: 'https://t.me/BillionaireToken',
  medium: 'https://medium.com/@billionaire_3373',
  twitter: 'https://twitter.com/BillionaireTkn',
  github: 'https://github.com/BillionaireToken',
  chains: ['eos']
}, {
  name: 'Crypto Sword & Magic',
  description: 'Crypto Sword & Magic is the first blockbuster RPG on EOS blockchain, traditional turn-based RPG raising heroes to challenge new dungeons. Game assets are recorded on Blockchain and transactions run on smart contracts',
  shortDescription: 'Crypto Sword & Magic is the first blockbuster RPG on EOS blockchain.',
  symbol: 'CSM',
  accounts: ['swordnmagicm'],
  app: 'https://www.cryptoswordandmagic.com',
  logo: 'https://bloks.io/img/dapps/cryptosnm.png',
  website: 'https://www.cryptoswordandmagic.com',
  telegram: 'https://t.me/cryptosnm_comm_en',
  medium: 'https://medium.com/@cryptoswordandmagic',
  twitter: 'https://twitter.com/sword_and_magic',
  github: '',
  chains: ['eos']
}, {
  name: 'dmail',
  description: 'Welcome to dmail Beta! We are so excited to have you participate as we launch our Beta platform. In the early stages we are covering the simplest of functionality, which is sending and receiving messages. In the very near future, we will be adding a bunch of new features which we know the community is going to ask for.',
  shortDescription: 'dmail is the first decentralized email on the blockchain',
  symbol: 'MAIL',
  statistics: true,
  accounts: ['dmaildotcobp'],
  logo: 'https://www.dmail.co/logosym_256.png',
  website: 'https://dmail.co',
  app: '',
  telegram: 'https://t.me/dmailcommunity',
  medium: 'https://medium.com/@dmail',
  twitter: 'https://twitter.com/dmaildotco',
  github: '',
  chains: ['eos', 'telos']
}, {
  name: 'Murmur',
  description: 'Murmur is a new age decentralized microblogging platform on EOS that is censorship-resistant, spam-proof and rewarding to use.',
  shortDescription: 'Murmur is a new age decentralized microblogging platform on EOS that is censorship-resistant, spam-proof and rewarding to use.',
  symbol: 'MUR',
  partner: true,
  accounts: ['murmurdappco', 'murmurtokens', 'murmurfreeac'],
  app: 'https://play.google.com/store/apps/details?id=com.murmurdapp',
  logo: 'https://bloks.io/img/dapps/murmur.png',
  website: 'http://murmurdapp.com',
  telegram: 'http://t.me/murmurdapp',
  medium: '',
  twitter: 'http://twitter.com/murmurdapp',
  github: '',
  chains: ['eos']
}, {
  name: 'Emanate',
  description: 'Emanate is EOS for the music industry. An automated, realtime music collaboration and monetisation platform.',
  shortDescription: 'Emanate is decentralised technology for the future of music',
  symbol: 'EMT',
  partner: true,
  accounts: ['emanateoneos', 'emanateissue'],
  app: 'https://emanate.live/',
  logo: 'https://bloks.io/img/dapps/emanate.png',
  website: 'https://emanate.live',
  telegram: 'https://t.me/emanateofficial',
  medium: '',
  twitter: 'https://twitter.com/emanateofficial',
  github: '',
  chains: ['eos']
}, {
  name: 'pixEOS',
  description: 'pixEOS is the first tokenized smart economy for gamers, artists and art enthusiasts.',
  shortDescription: 'pixEOS is the first tokenized smart economy for gamers, artists and art enthusiasts.',
  symbol: 'PIXEOS',
  partner: true,
  accounts: ['pixeos1token', 'pixeos1admin', 'pixeos1start'],
  app: 'https://pixeos.io',
  logo: 'https://bloks.io/img/dapps/pixeos.png',
  website: 'https://pixeos.io',
  telegram: 'https://t.me/PIXEOS',
  medium: '',
  twitter: 'https://twitter.com/eos_pix',
  github: '',
  chains: ['eos']
}, {
  name: 'Everipedia',
  description: 'The Everipedia team plans to build a modern, convenient and decentralized new encyclopedia website, and this goal will be realized with the development of blockchain technology. The new version of Everipedia under development will be based on the EOS network, which will have features such as community autonomy, shielding preventation, and contribution incentives compared to the current version of Everipedia. Founded in 2014, the business network encyclopedia Everipedia, whose name derives from the English words Everything and Encyclopedia, is owned by Everipedia.Inc and has not yet adopted blockchain technology. As of December 2017, Everipedia is the largest English encyclopedia with more than six million entries, including all English entries of Wikipedia. Everipedias requirements for attention are more relaxed, so it has more entries than Wikipedia.',
  shortDescription: 'The Everipedia team plans to build a modern, convenient and decentralized new encyclopedia.',
  symbol: 'IQ',
  partner: true,
  statistics: false,
  accounts: ['everipediaiq', 'eparticlectr'],
  logo: 'https://bloks.io/img/dapps/everipedia.jpg',
  website: '',
  app: 'https://everipedia.org',
  telegram: 'https://t.me/everipedia',
  medium: '',
  twitter: '',
  github: '',
  chains: ['eos']
}, {
  name: 'eosDAC',
  description: 'eosDAC is a Community Owned Blockproducer and a DAC enabler, born out of Dan Larimers concept of Decentralized Autonomous Communities or DACs, around which Block.one developed EOS software.  The vision of eosDAC is that EOS.IO block production should be open for everyone to contribute and benefit. To realize this vision, eosDAC is an evolving Decentralised Autonomous Community (DAC) focused on EOS.IO Block Production serving the EOS communities worldwide. In doing this, eosDAC is creating the tools and smart contracts it needs to function. It will share these with the EOS communities to help other DACs thrive on the EOS.IO blockchains.  In order to function as a DAC, eosDAC is creating open source tools and will be sharing them as a DAC Toolkit, that anyone can use, modify to setup and run a DAC.',
  shortDescription: 'eosDAC is creating open source tools and will be sharing them as a DAC Toolkit to enable DACs',
  symbol: 'EOSDAC',
  partner: false,
  statistics: false,
  accounts: ['eosdactokens', 'eosdacserver', 'eosdacthedac', 'daccustodian'],
  logo: 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/eosdac.png',
  website: '',
  app: 'members.eosdac.io',
  discord: 'https://discord.io/eosdac',
  telegram: 'https://t.me/eosdacio',
  medium: '',
  twitter: '',
  github: 'https://github.com/eosdac',
  chains: ['eos']
}, {
  name: 'DEOS Games',
  description: 'Deos Games are casino games built on EOS blockchain. Play zero edge games with our DEOS token and participate in bankroll staking.',
  shortDescription: 'Deos Games are casino games built on the EOS blockchain. Play zero edge games with DEOS token.',
  symbol: 'DEOS',
  statistics: false,
  accounts: ['thedeosgames', 'deosgameissu'],
  logo: 'https://bloks.io/img/dapps/deosgames.png',
  website: 'https://deosgames.com',
  app: 'https://app.deosgames.com',
  telegram: 'https://t.me/deosgameschat',
  medium: 'https://medium.com/deos-games',
  twitter: '',
  github: '',
  chains: ['eos']
}, {
  name: 'Chintai',
  description: 'Chintai is a community-owned, feeless, 100% on-chain, multisig decentralized token leasing platform where users can lend their EOS on the market to earn interest from other users to borrow who need access to CPU/NET bandwidth.',
  shortDescription: 'Chintai is a community-owned, feeless, 100% on-chain, multisig decentralized token leasing platform.',
  symbol: '',
  statistics: false,
  accounts: ['chintailease', 'chintaiproxy', 'bidchextoken', 'chexchexchex'],
  logo: 'https://bloks.io/img/dapps/chintai.png',
  website: 'http://chintai.io',
  app: 'https://eos.chintai.io/exchange/EOS28D',
  telegram: 'https://t.me/ChintaiEOS',
  medium: 'https://medium.com/@ChintaiEOS',
  twitter: 'https://twitter.com/chintaieos',
  github: 'https://github.com/chintai-platform',
  chains: ['eos']
}, {
  name: 'Newdex',
  description: 'Newdex is the first EOS based decentralized exchange in the world, upholding the characteristics of safe, fast and transparent, devoting to create a new-generation platform for digital assets exchange, leading the industry into an ideal new era.',
  shortDescription: 'Newdex is the first EOS based decentralized exchange in the world.',
  symbol: '',
  accounts: ['newdexpocket'],
  logo: 'https://bloks.io/img/dapps/newdex.png',
  website: 'https://newdex.io',
  app: 'https://newdex.io',
  telegram: '',
  medium: '',
  twitter: 'https://twitter.com/NewdexOfficial',
  github: '',
  chains: ['eos']
}, {
  name: 'EOS Name Swaps',
  description: 'An open-source EOS account exchange that puts the security of its users first.',
  shortDescription: 'An open-source EOS account exchange that puts the security of its users first.',
  symbol: '',
  statistics: false,
  accounts: ['eosnameswaps'],
  logo: 'https://bloks.io/img/dapps/eosnameswaps.png',
  website: 'https://www.eosnameswaps.com/',
  app: 'https://www.eosnameswaps.com/',
  telegram: 'https://t.me/eosnameswaps',
  medium: '',
  twitter: 'https://twitter.com/Starry3017Night',
  github: 'https://github.com/StarryJapanNight/eosnameswaps',
  chains: ['eos']
}];

var exchanges = {
  'Bithumb': {
    'name': 'Bithumb',
    'description': '비트코인, 이더리움, 비트코인캐시, 리플, 라이트코인, 대시, 모네로, 비트코인골드, 이오스, 이더리움클래식, 퀀텀, 제트캐시, 실시간 시세, 쉽고 안전한 거래.',
    'accounts': ['bithumbshiny'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.bithumb.com/'
  },
  'OKEx': {
    'name': 'OKEx',
    'description': 'OKEx is the leading global bitcoin exchange. Secured with bank-level SSL encryption and cold storage.',
    'accounts': ['okexoffiline'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.okex.com/'
  },
  'Bitfinex': {
    'name': 'Bitfinex',
    'description': 'Bitfinex is a full-featured spot trading platform for major digital assets & cryptocurrencies, including Bitcoin, Ethereum, EOS, Litecoin, Ripple, NEO, Monero and many more.',
    'accounts': ['bitfinexcw55', 'bitfinexcw13', 'bitfinexcw11', 'bitfinexcw24', 'bitfinexcw15', 'bitfinexcw32', 'bitfinexcw21', 'bitfinexcw31', 'bitfinexcw25', 'bitfinexcw23', 'bitfinexcw33', 'bitfinexcw22', 'bitfinexcw12', 'bitfinexcw14'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://bitfinex.com/'
  },
  'Gate.io': {
    'name': 'Gate.io',
    'description': 'Gate.io is a bitcoin exchange platform which supports BTC, LTC, Ethereum, Qtum and more blockchain assets trading.',
    'accounts': ['gateiowallet'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.gate.io/'
  },
  'Kraken': {
    'name': 'Kraken',
    'description': 'Buy, sell and margin trade Bitcoin (BTC) and Etherum (ETH) in exchange with EUR, USD, CAD, GBP, and JPY.',
    'accounts': ['krakenkraken'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.kraken.com/'
  },
  'Newdex': {
    'name': 'Newdex',
    'description': 'The first EOS based decentralized exchange in the world.',
    'accounts': ['newdexpocket'],
    'logo': '/img/exchanges/newdex.png',
    'website': 'https://newdex.io/',
    linkGenerator: function linkGenerator(token, pair) {
      return "https://newdex.io/trade/" + token.account + "-" + pair.pair_base.toLowerCase() + "-" + pair.pair_quote.toLowerCase();
    }
  },
  'DefiBox': {
    'name': 'DefiBox',
    'description': 'One-stop DeFi application platform on EOS..',
    'accounts': ['token.defi', 'swap.defi'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/token.defi-box.png',
    'website': 'https://defibox.io/',
    linkGenerator: function linkGenerator(_, __) {
      return "https://defibox.io/";
    }
  },
  'Chaince': {
    'name': 'Chaince',
    'description': 'A Superior Blockchain Asset Trading Platform Focusing on EOS Projects',
    'accounts': ['chainceoneos'],
    'logo': '/img/exchanges/chaince.png',
    'website': 'https://chaince.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://chaince.com/trade/" + pair.pair_base.toLowerCase() + pair.pair_quote.toLowerCase();
    }
  },
  'Dexeos': {
    'name': 'Dexeos',
    'description': 'The World\'s First EOS-based Decentralized Exchange',
    'accounts': ['dexeoswallet'],
    'logo': '/img/exchanges/dexeos.svg',
    'website': 'https://dexeos.io/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://dexeos.io/trade/" + pair.pair_base.toUpperCase();
    }
  },
  'Hoo': {
    'name': 'Hoo',
    'description': 'One-stop blockchain asset service platform',
    'accounts': ['hoo.com'],
    'logo': '/img/exchanges/hoo.jpg',
    'website': 'https://hoo.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://hoo.com/trade/" + pair.pair_base.toLowerCase() + "-" + pair.pair_quote.toLowerCase();
    }
  },
  'Whaleex': {
    'name': 'Whaleex',
    'description': '#1 Decentralized Exchange in the World',
    'accounts': ['whaleextrust'],
    'logo': '/img/exchanges/whaleex.png',
    'website': 'https://www.whaleex.com',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://www.whaleex.com/trade/" + pair.pair_base + "_" + pair.pair_quote;
    }
  },
  'Chainrift': {
    'name': 'Chainrift',
    'description': 'A marketplace for digital currencies',
    'accounts': [],
    'logo': '/img/exchanges/chainrift.png',
    'website': 'https://www.chainrift.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://www.chainrift.com/trading?coinpair=" + pair.pair_base + "/" + pair.pair_quote;
    }
  },
  'Eosdaq': {
    'name': 'EOSDAQ',
    'description': 'A Standard of On-Chain DEX',
    'accounts': [],
    'logo': '/img/exchanges/eosdaq.png',
    'website': 'https://www.eosdaq.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://eosdaq.com/exchange/" + pair.pair_base + "_" + pair.pair_quote;
    }
  },
  'BigONE': {
    'name': 'BigONE',
    'description': 'A Standard of On-Chain DEX',
    'accounts': [],
    'logo': '/img/exchanges/bigONE.jpg',
    'website': 'https://big.one',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://big.one/trade/" + pair.pair_base + "-" + pair.pair_quote;
    }
  },
  'YOLO': {
    'name': 'YOLO',
    'description': 'Instant Token Swaps on EOS',
    'accounts': [],
    'logo': '/img/exchanges/yolo.png',
    'website': 'https://yoloswap.com',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://yoloswap.com/swap/" + pair.pair_quote.toLowerCase() + "-" + pair.pair_base.toLowerCase();
    }
  },
  'Bancor': {
    'name': 'Bancor',
    'description': 'Instant Liquidity.',
    'accounts': [],
    'logo': '/img/exchanges/bancor.png',
    'website': 'https://bancor.network',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://www.bancor.network/token/" + pair.pair_base;
    }
  },
  'Alcor': {
    'name': 'Alcor',
    'description': 'The first self-listing decentralized exchange',
    'accounts': [],
    'logo': '/img/exchanges/alcor.png',
    'website': 'https://alcor.exchange',
    linkGenerator: function linkGenerator(_, __) {
      return "https://www.alcor.exchange/markets";
    }
  },
  'Defis.Network': {
    'name': 'Defis.Network',
    'description': 'An open finance network that integrates a series of DeFi protocols',
    'accounts': [],
    'logo': '/img/exchanges/defis-uncache.png',
    'website': 'https://defis.network',
    linkGenerator: function linkGenerator(_, __) {
      return "https://apps.defis.network/";
    }
  },
  'DolphinSwap': {
    'name': 'DolphinSwap',
    'description': 'DolphinSwap',
    'accounts': [],
    'logo': '/img/exchanges/dolphinswap.png',
    'website': 'https://dolphinswap.io/exchange',
    linkGenerator: function linkGenerator(_, __) {
      return 'https://dolphinswap.io/exchange';
    }
  },
  'Proton': {
    'name': 'ProtonSwap',
    'description': 'ProtonSwap',
    'accounts': [],
    'logo': '/img/exchanges/protonswap.png',
    'website': 'https://protonswap.com',
    linkGenerator: function linkGenerator(_, __) {
      return 'https://protonswap.com';
    }
  },
  'Coingecko': {
    'name': 'CoinGecko',
    'description': 'CoinGecko',
    'accounts': [],
    'logo': '/img/exchanges/coingecko.png',
    'website': 'https://coingecko.com',
    linkGenerator: function linkGenerator(_, __) {
      return 'https://coingecko.com';
    }
  }
};

var SCATTER_DESKTOP = 'ScatterSockets';
var SCATTER_DESKTOP_MANUAL = 'ScatterSocketsManual';
var SCATTER_EXTENSION = 'ScatterExtension';
var LEDGER = 'ledger';
var LEDGER_USB = 'TransportU2F';
var LEDGER_BLE = 'TransportWebBLE';
var LEDGER_WEBUSB = 'TransportWebusb';
var LEDGER_WEBHID = 'TransportWebHID';
var LYNX = 'lynx';
var PROTON = 'proton';
var PROTON_WEB = 'protonweb';
var ANCHOR = 'anchor';
var SIMPLEOS = 'simpleos';
var EOSAUTH = 'eosauth';
var CLEOS = 'cleos';
var EOSC = 'eosc';
var CLIO = 'clio';
var KEYCAT = 'keycat';
var TREZOR = 'trezor';
var SQRL = 'sqrl';
var WOMBAT = 'wombat';
var WAX_CLOUD_WALLET = 'WaxCW';

var historyTypesFeatures = {
  "native": {
    name: 'native',
    actionFilter: false,
    tokenFilter: false,
    dateFilter: false,
    contractActionFilter: false,
    total: 0
  },
  dfuse: {
    name: 'dfuse',
    actionFilter: true,
    tokenFilter: true,
    dateFilter: true,
    contractActionFilter: true,
    total: 4
  },
  hyperion: {
    name: 'hyperion',
    actionFilter: true,
    tokenFilter: true,
    dateFilter: true,
    contractActionFilter: true,
    total: 3
  }
};

var _chainInfo;

var chainInfo = (_chainInfo = {}, _chainInfo['proton-test'] = {
  key: 'proton-test',
  text: 'Proton Testnet',
  value: 'https://testnet.protonscan.io',
  image: '/img/chains/proton.png',
  testnet: true
}, _chainInfo.local = {
  key: 'local',
  text: 'Local Testnet',
  value: 'https://local.bloks.io',
  image: '/img/chains/local.png',
  testnet: true
}, _chainInfo['wax-test'] = {
  key: 'wax-test',
  text: 'WAX Testnet',
  value: 'https://wax-test.bloks.io',
  image: '/img/chains/wax.png',
  testnet: true
}, _chainInfo['fio-test'] = {
  key: 'fio-test',
  text: 'FIO Testnet',
  value: 'https://fio-test.bloks.io',
  image: '/img/chains/fio.png',
  testnet: true
}, _chainInfo.jungle3 = {
  key: 'jungle3',
  text: 'Jungle3 Testnet',
  value: 'https://jungle3.bloks.io',
  image: '/img/chains/jungle.png',
  testnet: true
}, _chainInfo.kylin = {
  key: 'kylin',
  text: 'Kylin Testnet',
  value: 'https://kylin.bloks.io',
  image: '/img/chains/kylin.png',
  testnet: true
}, _chainInfo.proton = {
  key: 'proton',
  text: 'Proton',
  value: 'https://protonscan.io',
  image: '/img/chains/proton.png'
}, _chainInfo.eos = {
  key: 'eos',
  text: 'EOS',
  value: 'https://bloks.io',
  image: '/img/chains/eos.png'
}, _chainInfo.wax = {
  key: 'wax',
  text: 'WAX',
  value: 'https://wax.bloks.io',
  image: '/img/chains/wax.png'
}, _chainInfo.fio = {
  key: 'fio',
  text: 'FIO',
  value: 'https://fio.bloks.io',
  image: '/img/chains/fio.png'
}, _chainInfo);

var getCommonConstants = function getCommonConstants(chain) {
  return {
    MAX_RPC_SYNC_SECONDS_BEHIND: 20,
    IMAGE_PROXY: 'https://www.api.bloks.io/image-proxy',
    WRAP_CONTRACT: 'proton.wrap',
    BLOKS_API: 'https://www.api.bloks.io',
    ESR_PROTOCOL: chain === 'proton' ? 'proton' : 'proton-dev',
    METAL_PROTON_ENDPOINT: chain === 'proton' ? 'https://api.protonchain.com' : 'https://api-dev.protonchain.com',
    SWAP_URL: chain === 'proton' ? 'https://otc.protonswap.com' : 'https://otc-test.protonswap.com',
    WRAP_SERVER_URL: chain === 'proton' ? 'https://www.api.bloks.io/proton-wrap-public2' : 'https://www.api.bloks.io/proton-wrap-testnet-public2'
  };
};

var generateProviderEndpoints = function generateProviderEndpoints(chainId, actionEndpoints) {
  return [{
    chainId: chainId,
    port: 443,
    protocol: 'https',
    host: actionEndpoints[0].substr(8),
    httpEndpoint: actionEndpoints[0],
    blockchain: 'eos'
  }];
};

var DEFAULT_ENDPOINTS = ['https://eos.greymass.com', 'https://eos.eoscafeblock.com', 'https://api.main.alohaeos.com', 'https://api.eossweden.org'];
var ACTIONS_ENDPOINTS = ['https://eos.greymass.com'];
var TRANSACTIONS_ENDPOINTS = ['https://eos.greymass.com', 'https://api.eossweden.org'];
var ALOHA_PROXY_URL = 'https://www.alohaeos.com/vote/proxy';
var API_URL = 'https://www.api.bloks.io';
var ATOMICASSETS_API = 'https://eos.api.atomicassets.io';
var BLOKS_PROXY = 'bloksioproxy';
var CHAIN = 'eos';
var CHAIN_ID = 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906';
var CHAIN_START_DATE = /*#__PURE__*/new Date('2018-06-08');
var CORE_PRECISION = 4;
var CORE_SYMBOL = 'EOS';
var DISPLAY_CHAIN = 'EOS';
var DOMAIN_TITLE = 'EOS Bloks.io';
var HISTORY_TYPES = ['native', 'hyperion'];
var HYPERION_URL = 'https://eos.hyperion.eosrio.io';
var KEY_PREFIX = 'EOS';
var LIGHT_API = 'https://api.light.xeos.me';
var NFTS_ENABLED = true;
var PROVIDER_ENDPOINTS = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID, ACTIONS_ENDPOINTS);
var REX_ENABLED = true;
var SIMPLEASSETS_API = 'https://eos.api.simpleassets.io';
var SUPPORTS_FREE_CPU = true;
var SUPPORTS_RENTBW = true;
var VOTING_ENABLED = true;
var constants = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS,
  ALOHA_PROXY_URL: ALOHA_PROXY_URL,
  API_URL: API_URL,
  ATOMICASSETS_API: ATOMICASSETS_API,
  BLOKS_PROXY: BLOKS_PROXY,
  CHAIN: CHAIN,
  CHAIN_ID: CHAIN_ID,
  CHAIN_START_DATE: CHAIN_START_DATE,
  CORE_PRECISION: CORE_PRECISION,
  CORE_SYMBOL: CORE_SYMBOL,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS,
  DISPLAY_CHAIN: DISPLAY_CHAIN,
  DOMAIN_TITLE: DOMAIN_TITLE,
  HISTORY_TYPES: HISTORY_TYPES,
  HYPERION_URL: HYPERION_URL,
  KEY_PREFIX: KEY_PREFIX,
  LIGHT_API: LIGHT_API,
  NFTS_ENABLED: NFTS_ENABLED,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS,
  REX_ENABLED: REX_ENABLED,
  SIMPLEASSETS_API: SIMPLEASSETS_API,
  SUPPORTS_FREE_CPU: SUPPORTS_FREE_CPU,
  SUPPORTS_RENTBW: SUPPORTS_RENTBW,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS,
  VOTING_ENABLED: VOTING_ENABLED
};

var DEFAULT_ENDPOINTS$1 = ['https://wax.greymass.com', 'https://wax.eoscafeblock.com', 'https://api.waxsweden.org', 'https://chain.wax.io', 'https://wax.eosrio.io'];
var ACTIONS_ENDPOINTS$1 = ['https://wax.greymass.com', 'https://api.waxsweden.org', 'https://wax.eosrio.io', 'https://chain.wax.io'];
var TRANSACTIONS_ENDPOINTS$1 = ['https://wax.greymass.com', 'https://api.waxsweden.org', 'https://wax.eosrio.io', 'https://chain.wax.io'];
var ALOHA_PROXY_URL$1 = 'https://www.alohaeos.com/vote/proxy/waxmain';
var API_URL$1 = 'https://www.api.bloks.io/wax';
var ATOMICASSETS_API$1 = 'https://wax.api.atomicassets.io';
var BLOKS_PROXY$1 = 'bloksioproxy';
var CHAIN$1 = 'wax';
var CHAIN_ID$1 = '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4';
var CHAIN_START_DATE$1 = /*#__PURE__*/new Date('2019-06-24');
var CORE_PRECISION$1 = 8;
var CORE_SYMBOL$1 = 'WAX';
var DISPLAY_CHAIN$1 = 'WAX';
var DOMAIN_TITLE$1 = 'WAX | Bloks.io';
var HISTORY_TYPES$1 = ['native', 'hyperion'];
var HYPERION_URL$1 = 'https://wax.eosrio.io';
var KEY_PREFIX$1 = 'EOS';
var LIGHT_API$1 = 'https://lightapi.eosamsterdam.net';
var NFTS_ENABLED$1 = true;
var PROVIDER_ENDPOINTS$1 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$1, ACTIONS_ENDPOINTS$1);
var SIMPLEASSETS_API$1 = 'https://wax.api.simpleassets.io';
var VOTING_ENABLED$1 = true;
var constants$1 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$1,
  ALOHA_PROXY_URL: ALOHA_PROXY_URL$1,
  API_URL: API_URL$1,
  ATOMICASSETS_API: ATOMICASSETS_API$1,
  BLOKS_PROXY: BLOKS_PROXY$1,
  CHAIN: CHAIN$1,
  CHAIN_ID: CHAIN_ID$1,
  CHAIN_START_DATE: CHAIN_START_DATE$1,
  CORE_PRECISION: CORE_PRECISION$1,
  CORE_SYMBOL: CORE_SYMBOL$1,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$1,
  DISPLAY_CHAIN: DISPLAY_CHAIN$1,
  DOMAIN_TITLE: DOMAIN_TITLE$1,
  HISTORY_TYPES: HISTORY_TYPES$1,
  HYPERION_URL: HYPERION_URL$1,
  KEY_PREFIX: KEY_PREFIX$1,
  LIGHT_API: LIGHT_API$1,
  NFTS_ENABLED: NFTS_ENABLED$1,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$1,
  SIMPLEASSETS_API: SIMPLEASSETS_API$1,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$1,
  VOTING_ENABLED: VOTING_ENABLED$1
};

var DEFAULT_ENDPOINTS$2 = ['https://proton.greymass.com', 'https://proton.cryptolions.io', 'https://proton.eosusa.news', "https://frankfurt.protondata.net"];
var TRANSACTIONS_ENDPOINTS$2 = ['https://proton.greymass.com', 'https://proton.cryptolions.io'];
var ACTIONS_ENDPOINTS$2 = ['https://proton.greymass.com'];
var API_URL$2 = 'https://www.api.bloks.io/proton';
var ATOMICASSETS_API$2 = 'https://proton.api.atomicassets.io';
var CHAIN$2 = 'proton';
var CHAIN_ID$2 = '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0';
var CHAIN_START_DATE$2 = /*#__PURE__*/new Date('Apr 22, 2020');
var CORE_PRECISION$2 = 4;
var CORE_SYMBOL$2 = 'XPR';
var DISPLAY_CHAIN$2 = 'Proton';
var DOMAIN_TITLE$2 = 'ProtonScan';
var HISTORY_TYPES$2 = ['native', 'hyperion'];
var HYPERION_URL$2 = 'http://proton.pink.gg';
var KEY_PREFIX$2 = 'EOS';
var LIGHT_API$2 = 'https://lightapi.eosamsterdam.net';
var MAX_VOTES = 4;
var NFTS_ENABLED$2 = true;
var PROVIDER_ENDPOINTS$2 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$2, ACTIONS_ENDPOINTS$2);
var VOTING_ENABLED$2 = true;
var constants$2 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$2,
  API_URL: API_URL$2,
  ATOMICASSETS_API: ATOMICASSETS_API$2,
  CHAIN: CHAIN$2,
  CHAIN_ID: CHAIN_ID$2,
  CHAIN_START_DATE: CHAIN_START_DATE$2,
  CORE_PRECISION: CORE_PRECISION$2,
  CORE_SYMBOL: CORE_SYMBOL$2,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$2,
  DISPLAY_CHAIN: DISPLAY_CHAIN$2,
  DOMAIN_TITLE: DOMAIN_TITLE$2,
  HISTORY_TYPES: HISTORY_TYPES$2,
  HYPERION_URL: HYPERION_URL$2,
  KEY_PREFIX: KEY_PREFIX$2,
  LIGHT_API: LIGHT_API$2,
  MAX_VOTES: MAX_VOTES,
  NFTS_ENABLED: NFTS_ENABLED$2,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$2,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$2,
  VOTING_ENABLED: VOTING_ENABLED$2
};

var DEFAULT_ENDPOINTS$3 = ['https://fio.greymass.com', 'https://fio.eossweden.org', 'https://fio.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$3 = ['https://fio.greymass.com', 'https://fio.eossweden.org', 'https://fio.eosusa.news'];
var ACTIONS_ENDPOINTS$3 = ['https://fio.greymass.com', 'https://fio.eossweden.org', 'https://fio.eosusa.news'];
var ALOHA_PROXY_URL$2 = 'https://www.alohaeos.com/vote/proxy/fiomain';
var API_URL$3 = 'https://www.api.bloks.io/fio';
var CHAIN$3 = 'fio';
var CHAIN_ID$3 = '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c';
var CHAIN_START_DATE$3 = /*#__PURE__*/new Date('Mar 24, 2020');
var CORE_PRECISION$3 = 9;
var CORE_SYMBOL$3 = 'FIO';
var DISABLE_MEMO = true;
var DISPLAY_CHAIN$3 = 'FIO';
var DOMAIN_TITLE$3 = 'FIO Bloks.io';
var FIO_FEES_ACCOUNT = 'fees@bloks';
var HISTORY_TYPES$3 = ['native', 'hyperion'];
var HYPERION_URL$3 = 'https://fio.eossweden.org';
var KEY_PREFIX$3 = 'FIO';
var PROVIDER_ENDPOINTS$3 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$3, ACTIONS_ENDPOINTS$3);
var VOTING_ENABLED$3 = true;
var constants$3 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$3,
  ALOHA_PROXY_URL: ALOHA_PROXY_URL$2,
  API_URL: API_URL$3,
  CHAIN: CHAIN$3,
  CHAIN_ID: CHAIN_ID$3,
  CHAIN_START_DATE: CHAIN_START_DATE$3,
  CORE_PRECISION: CORE_PRECISION$3,
  CORE_SYMBOL: CORE_SYMBOL$3,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$3,
  DISABLE_MEMO: DISABLE_MEMO,
  DISPLAY_CHAIN: DISPLAY_CHAIN$3,
  DOMAIN_TITLE: DOMAIN_TITLE$3,
  FIO_FEES_ACCOUNT: FIO_FEES_ACCOUNT,
  HISTORY_TYPES: HISTORY_TYPES$3,
  HYPERION_URL: HYPERION_URL$3,
  KEY_PREFIX: KEY_PREFIX$3,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$3,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$3,
  VOTING_ENABLED: VOTING_ENABLED$3
};

var DEFAULT_ENDPOINTS$4 = [];
var ACTIONS_ENDPOINTS$4 = [];
var TRANSACTIONS_ENDPOINTS$4 = [];
var API_URL$4 = '';
var CHAIN$4 = 'local';
var CHAIN_ID$4 = '';
var CHAIN_START_DATE$4 = undefined;
var CORE_PRECISION$4 = 4;
var CORE_SYMBOL$4 = 'EOS';
var DISPLAY_CHAIN$4 = 'Local';
var DOMAIN_TITLE$4 = 'Local Bloks.io';
var HISTORY_TYPES$4 = ['native'];
var KEY_PREFIX$4 = 'EOS';
var PROVIDER_ENDPOINTS$4 = [];
var VOTING_ENABLED$4 = true;
var constants$4 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$4,
  API_URL: API_URL$4,
  CHAIN: CHAIN$4,
  CHAIN_ID: CHAIN_ID$4,
  CHAIN_START_DATE: CHAIN_START_DATE$4,
  CORE_PRECISION: CORE_PRECISION$4,
  CORE_SYMBOL: CORE_SYMBOL$4,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$4,
  DISPLAY_CHAIN: DISPLAY_CHAIN$4,
  DOMAIN_TITLE: DOMAIN_TITLE$4,
  HISTORY_TYPES: HISTORY_TYPES$4,
  KEY_PREFIX: KEY_PREFIX$4,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$4,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$4,
  VOTING_ENABLED: VOTING_ENABLED$4
};

var DEFAULT_ENDPOINTS$5 = [// 'https://jungleapi.eossweden.org',
'https://api.jungle.alohaeos.com', 'https://jungle2.cryptolions.io', 'https://jungle.eosphere.io', 'https://eos-jungle.eosblocksmith.io'];
var ACTIONS_ENDPOINTS$5 = ['https://jungle.eossweden.org'];
var TRANSACTIONS_ENDPOINTS$5 = ['https://jungle.eossweden.org'];
var API_URL$5 = 'https://www.api.bloks.io/jungle';
var BLOKS_PROXY$2 = 'blokspartner';
var CHAIN$5 = 'jungle';
var CHAIN_ID$5 = 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473';
var CHAIN_START_DATE$5 = /*#__PURE__*/new Date('Nov 23, 2018');
var CORE_PRECISION$5 = 4;
var CORE_SYMBOL$5 = 'EOS';
var DISPLAY_CHAIN$5 = 'Jungle';
var DOMAIN_TITLE$5 = 'Jungle Bloks.io';
var HISTORY_TYPES$5 = ['hyperion', 'native'];
var HYPERION_URL$4 = 'https://jungle2.cryptolions.io';
var KEY_PREFIX$5 = 'EOS';
var LIGHT_API$3 = 'https://lightapi.eosgeneva.io';
var NFTS_ENABLED$3 = true;
var PROVIDER_ENDPOINTS$5 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$5, ACTIONS_ENDPOINTS$5);
var REX_ENABLED$1 = true;
var VOTING_ENABLED$5 = true;
var constants$5 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$5,
  API_URL: API_URL$5,
  BLOKS_PROXY: BLOKS_PROXY$2,
  CHAIN: CHAIN$5,
  CHAIN_ID: CHAIN_ID$5,
  CHAIN_START_DATE: CHAIN_START_DATE$5,
  CORE_PRECISION: CORE_PRECISION$5,
  CORE_SYMBOL: CORE_SYMBOL$5,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$5,
  DISPLAY_CHAIN: DISPLAY_CHAIN$5,
  DOMAIN_TITLE: DOMAIN_TITLE$5,
  HISTORY_TYPES: HISTORY_TYPES$5,
  HYPERION_URL: HYPERION_URL$4,
  KEY_PREFIX: KEY_PREFIX$5,
  LIGHT_API: LIGHT_API$3,
  NFTS_ENABLED: NFTS_ENABLED$3,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$5,
  REX_ENABLED: REX_ENABLED$1,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$5,
  VOTING_ENABLED: VOTING_ENABLED$5
};

var DEFAULT_ENDPOINTS$6 = ['https://jungle3.cryptolions.io', 'https://api.jungle3.alohaeos.com', 'https://jungle3.eosusa.news'];
var ACTIONS_ENDPOINTS$6 = ['https://jungle3.cryptolions.io', 'https://jungle3.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$6 = ['https://jungle3.cryptolions.io', 'https://jungle3.eosusa.news'];
var API_URL$6 = 'https://www.api.bloks.io/jungle3';
var CHAIN$6 = 'jungle3';
var CHAIN_ID$6 = '2a02a0053e5a8cf73a56ba0fda11e4d92e0238a4a2aa74fccf46d5a910746840';
var CHAIN_START_DATE$6 = /*#__PURE__*/new Date('Feb 19, 2020');
var CORE_PRECISION$6 = 4;
var CORE_SYMBOL$6 = 'EOS';
var DISPLAY_CHAIN$6 = 'Jungle 3';
var DOMAIN_TITLE$6 = 'Jungle 3 Bloks.io';
var HISTORY_TYPES$6 = ['hyperion'];
var HYPERION_URL$5 = 'https://jungle3.cryptolions.io';
var KEY_PREFIX$6 = 'EOS';
var PROVIDER_ENDPOINTS$6 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$6, ACTIONS_ENDPOINTS$6);
var REX_ENABLED$2 = true;
var SUPPORTS_RENTBW$1 = true;
var VOTING_ENABLED$6 = true;
var constants$6 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$6,
  API_URL: API_URL$6,
  CHAIN: CHAIN$6,
  CHAIN_ID: CHAIN_ID$6,
  CHAIN_START_DATE: CHAIN_START_DATE$6,
  CORE_PRECISION: CORE_PRECISION$6,
  CORE_SYMBOL: CORE_SYMBOL$6,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$6,
  DISPLAY_CHAIN: DISPLAY_CHAIN$6,
  DOMAIN_TITLE: DOMAIN_TITLE$6,
  HISTORY_TYPES: HISTORY_TYPES$6,
  HYPERION_URL: HYPERION_URL$5,
  KEY_PREFIX: KEY_PREFIX$6,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$6,
  REX_ENABLED: REX_ENABLED$2,
  SUPPORTS_RENTBW: SUPPORTS_RENTBW$1,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$6,
  VOTING_ENABLED: VOTING_ENABLED$6
};

var DEFAULT_ENDPOINTS$7 = ['https://kylin.eosn.io'];
var ACTIONS_ENDPOINTS$7 = ['https://kylin.eosn.io'];
var TRANSACTIONS_ENDPOINTS$7 = ['https://kylin.eosn.io'];
var API_URL$7 = 'https://www.api.bloks.io/kylin';
var BLOKS_PROXY$3 = 'blokspartner';
var CHAIN$7 = 'kylin';
var CHAIN_ID$7 = '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191';
var CHAIN_START_DATE$7 = /*#__PURE__*/new Date('Jul 10, 2018');
var CORE_PRECISION$7 = 4;
var CORE_SYMBOL$7 = 'EOS';
var DISPLAY_CHAIN$7 = 'Kylin';
var DOMAIN_TITLE$7 = 'Kylin Bloks.io';
var HISTORY_TYPES$7 = ['hyperion', 'native'];
var HYPERION_URL$6 = 'https://kylin.eosusa.news';
var KEY_PREFIX$7 = 'EOS';
var PROVIDER_ENDPOINTS$7 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$7, ACTIONS_ENDPOINTS$7);
var VOTING_ENABLED$7 = true;
var constants$7 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$7,
  API_URL: API_URL$7,
  BLOKS_PROXY: BLOKS_PROXY$3,
  CHAIN: CHAIN$7,
  CHAIN_ID: CHAIN_ID$7,
  CHAIN_START_DATE: CHAIN_START_DATE$7,
  CORE_PRECISION: CORE_PRECISION$7,
  CORE_SYMBOL: CORE_SYMBOL$7,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$7,
  DISPLAY_CHAIN: DISPLAY_CHAIN$7,
  DOMAIN_TITLE: DOMAIN_TITLE$7,
  HISTORY_TYPES: HISTORY_TYPES$7,
  HYPERION_URL: HYPERION_URL$6,
  KEY_PREFIX: KEY_PREFIX$7,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$7,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$7,
  VOTING_ENABLED: VOTING_ENABLED$7
};

var DEFAULT_ENDPOINTS$8 = ['https://www.api.bloks.io/eos-test-node'];
var ACTIONS_ENDPOINTS$8 = ['https://www.api.bloks.io/eos-test-node'];
var TRANSACTIONS_ENDPOINTS$8 = ['https://www.api.bloks.io/eos-test-node'];
var API_URL$8 = 'https://www.api.bloks.io/eos-test';
var CHAIN$8 = 'eos-test';
var CHAIN_ID$8 = '0db13ab9b321c37c0ba8481cb4681c2788b622c3abfd1f12f0e5353d44ba6e72';
var CHAIN_START_DATE$8 = /*#__PURE__*/new Date('2020-01-14');
var CORE_PRECISION$8 = 4;
var CORE_SYMBOL$8 = 'TNT';
var DISPLAY_CHAIN$8 = 'EOSIO Test';
var DOMAIN_TITLE$8 = 'Bloks.io';
var HISTORY_TYPES$8 = ['native'];
var KEY_PREFIX$8 = 'EOS';
var PROVIDER_ENDPOINTS$8 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$8, ACTIONS_ENDPOINTS$8);
var constants$8 = {
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$8,
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$8,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$8,
  API_URL: API_URL$8,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$8,
  CORE_SYMBOL: CORE_SYMBOL$8,
  CHAIN: CHAIN$8,
  DISPLAY_CHAIN: DISPLAY_CHAIN$8,
  HISTORY_TYPES: HISTORY_TYPES$8,
  CHAIN_ID: CHAIN_ID$8,
  DOMAIN_TITLE: DOMAIN_TITLE$8,
  CHAIN_START_DATE: CHAIN_START_DATE$8,
  KEY_PREFIX: KEY_PREFIX$8,
  CORE_PRECISION: CORE_PRECISION$8
};

var DEFAULT_ENDPOINTS$9 = ['https://protontestnet.greymass.com', 'https://proton-testnet.eoscafeblock.com', 'https://testnet.protonchain.com', 'https://test.proton.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$9 = ['https://protontestnet.greymass.com', 'https://testnet.protonchain.com', 'https://test.proton.eosusa.news'];
var ACTIONS_ENDPOINTS$9 = ['https://protontestnet.greymass.com', 'https://testnet.protonchain.com', 'https://test.proton.eosusa.news'];
var API_URL$9 = 'https://www.api.bloks.io/proton-test';
var ATOMICASSETS_API$3 = 'https://test.proton.api.atomicassets.io';
var CHAIN$9 = 'proton-test';
var CHAIN_ID$9 = '71ee83bcf52142d61019d95f9cc5427ba6a0d7ff8accd9e2088ae2abeaf3d3dd';
var CHAIN_START_DATE$9 = /*#__PURE__*/new Date('April 3, 2020');
var CORE_PRECISION$9 = 4;
var CORE_SYMBOL$9 = 'XPR';
var DISPLAY_CHAIN$9 = 'Proton-T';
var DOMAIN_TITLE$9 = 'Proton Testnet';
var HISTORY_TYPES$9 = ['hyperion', 'native'];
var HYPERION_URL$7 = 'https://testnet.proton.pink.gg';
var KEY_PREFIX$9 = 'EOS';
var MAX_VOTES$1 = 4;
var PROVIDER_ENDPOINTS$9 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$9, ACTIONS_ENDPOINTS$9);
var VOTING_ENABLED$8 = true;
var constants$9 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$9,
  API_URL: API_URL$9,
  ATOMICASSETS_API: ATOMICASSETS_API$3,
  CHAIN: CHAIN$9,
  CHAIN_ID: CHAIN_ID$9,
  CHAIN_START_DATE: CHAIN_START_DATE$9,
  CORE_PRECISION: CORE_PRECISION$9,
  CORE_SYMBOL: CORE_SYMBOL$9,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$9,
  DISPLAY_CHAIN: DISPLAY_CHAIN$9,
  DOMAIN_TITLE: DOMAIN_TITLE$9,
  HISTORY_TYPES: HISTORY_TYPES$9,
  HYPERION_URL: HYPERION_URL$7,
  KEY_PREFIX: KEY_PREFIX$9,
  MAX_VOTES: MAX_VOTES$1,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$9,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$9,
  VOTING_ENABLED: VOTING_ENABLED$8
};

var DEFAULT_ENDPOINTS$a = ['https://testnet.wax.eosdetroit.io', 'https://testnet.wax.pink.gg', 'https://testnet.waxsweden.org'];
var TRANSACTIONS_ENDPOINTS$a = ['https://testnet.wax.eosdetroit.io', 'https://testnet.wax.pink.gg', 'https://testnet.waxsweden.org'];
var ACTIONS_ENDPOINTS$a = ['https://testnet.wax.eosdetroit.io', 'https://testnet.wax.pink.gg', 'https://testnet.waxsweden.org'];
var API_URL$a = 'https://www.api.bloks.io/wax-test';
var ATOMICASSETS_API$4 = 'https://test.wax.api.atomicassets.io';
var CHAIN$a = 'wax-test';
var CHAIN_ID$a = 'f16b1833c747c43682f4386fca9cbb327929334a762755ebec17f6f23c9b8a12';
var CHAIN_START_DATE$a = /*#__PURE__*/new Date('Dec 5, 2019');
var CORE_PRECISION$a = 8;
var CORE_SYMBOL$a = 'WAX';
var DISPLAY_CHAIN$a = 'WAX-T';
var DOMAIN_TITLE$a = 'WAX Testnet Bloks.io';
var HISTORY_TYPES$a = ['native', 'hyperion'];
var HYPERION_URL$8 = 'https://testnet.waxsweden.org';
var KEY_PREFIX$a = 'EOS';
var LIGHT_API$4 = 'https://testnet-lightapi.eosams.xeos.me';
var PROVIDER_ENDPOINTS$a = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$a, ACTIONS_ENDPOINTS$a);
var constants$a = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$a,
  API_URL: API_URL$a,
  ATOMICASSETS_API: ATOMICASSETS_API$4,
  CHAIN: CHAIN$a,
  CHAIN_ID: CHAIN_ID$a,
  CHAIN_START_DATE: CHAIN_START_DATE$a,
  CORE_PRECISION: CORE_PRECISION$a,
  CORE_SYMBOL: CORE_SYMBOL$a,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$a,
  DISPLAY_CHAIN: DISPLAY_CHAIN$a,
  DOMAIN_TITLE: DOMAIN_TITLE$a,
  HISTORY_TYPES: HISTORY_TYPES$a,
  HYPERION_URL: HYPERION_URL$8,
  KEY_PREFIX: KEY_PREFIX$a,
  LIGHT_API: LIGHT_API$4,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$a,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$a
};

var DEFAULT_ENDPOINTS$b = ['https://fiotestnet.greymass.com', 'https://test.fio.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$b = ['https://fiotestnet.greymass.com', 'https://test.fio.eosusa.news'];
var ACTIONS_ENDPOINTS$b = ['https://fiotestnet.greymass.com', 'https://test.fio.eosusa.news'];
var API_URL$b = 'https://www.api.bloks.io/fio-test';
var CHAIN$b = 'fio-test';
var CHAIN_ID$b = 'b20901380af44ef59c5918439a1f9a41d83669020319a80574b804a5f95cbd7e';
var CHAIN_START_DATE$b = /*#__PURE__*/new Date('Mar 10, 2020');
var CORE_PRECISION$b = 9;
var CORE_SYMBOL$b = 'FIO';
var DISABLE_MEMO$1 = true;
var DISPLAY_CHAIN$b = 'FIO Test';
var DOMAIN_TITLE$b = 'FIO Test Bloks.io';
var HISTORY_TYPES$b = ['native', 'hyperion'];
var HYPERION_URL$9 = 'https://test.fio.eosusa.news';
var KEY_PREFIX$b = 'FIO';
var PROVIDER_ENDPOINTS$b = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$b, ACTIONS_ENDPOINTS$b);
var VOTING_ENABLED$9 = true;
var constants$b = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$b,
  API_URL: API_URL$b,
  CHAIN: CHAIN$b,
  CHAIN_ID: CHAIN_ID$b,
  CHAIN_START_DATE: CHAIN_START_DATE$b,
  CORE_PRECISION: CORE_PRECISION$b,
  CORE_SYMBOL: CORE_SYMBOL$b,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$b,
  DISABLE_MEMO: DISABLE_MEMO$1,
  DISPLAY_CHAIN: DISPLAY_CHAIN$b,
  DOMAIN_TITLE: DOMAIN_TITLE$b,
  HISTORY_TYPES: HISTORY_TYPES$b,
  HYPERION_URL: HYPERION_URL$9,
  KEY_PREFIX: KEY_PREFIX$b,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$b,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$b,
  VOTING_ENABLED: VOTING_ENABLED$9
};

var _chainToNetworkConsta;

var chainToNetworkConstantsMap = (_chainToNetworkConsta = {
  eos: constants,
  wax: constants$1,
  proton: constants$2,
  local: constants$4,
  jungle: constants$5,
  jungle3: constants$6,
  kylin: constants$7,
  fio: constants$3
}, _chainToNetworkConsta['eos-test'] = constants$8, _chainToNetworkConsta['proton-test'] = constants$9, _chainToNetworkConsta['wax-test'] = constants$a, _chainToNetworkConsta['fio-test'] = constants$b, _chainToNetworkConsta);
var Constants = /*#__PURE__*/function () {
  function Constants() {
    if (!!Constants.instance) {
      return Constants.instance;
    }
  }

  var _proto = Constants.prototype;

  _proto.initialize = function initialize(chain) {
    if (!chain || !chainToNetworkConstantsMap[chain]) {
      chain = DEFAULT_CHAIN;
    }

    this.setNetwork(chain);
    this.setCommon(chain);
  };

  _proto.setNetwork = function setNetwork(chain) {
    // const networkConstants = await import(`'./networks/${chain}`)
    var networkConstants = chainToNetworkConstantsMap[chain];
    this.setConstants(networkConstants);
    this.setContract(chain, networkConstants.SYSTEM_DOMAIN);
  };

  _proto.setCommon = function setCommon(chain) {
    var commonConstants = getCommonConstants(chain);
    this.setConstants(commonConstants);
  };

  _proto.setContract = function setContract(chain, systemDomain) {
    if (systemDomain === void 0) {
      systemDomain = DEFAULT_SYSTEM_DOMAIN;
    }

    var contractConstants = getContractConstants(chain, systemDomain);
    this.setConstants(contractConstants);
  };

  _proto.setConstants = function setConstants(newConstants) {
    for (var _i = 0, _Object$entries = Object.entries(newConstants); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];
      this[key] = value;
    }
  };

  return Constants;
}();
var constants$c = /*#__PURE__*/new Constants();


//# sourceMappingURL=constants.esm.js.map


/***/ }),

/***/ "./node_modules/@bloks/numbers/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@bloks/numbers/dist/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



if (false) {} else {
  module.exports = __webpack_require__(/*! ./numbers.cjs.development.js */ "./node_modules/@bloks/numbers/dist/numbers.cjs.development.js")
}


/***/ }),

/***/ "./node_modules/@bloks/numbers/dist/numbers.cjs.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bloks/numbers/dist/numbers.cjs.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bignumber_js = __webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js");
var numbro = _interopDefault(__webpack_require__(/*! @jafri/numbro */ "./node_modules/@jafri/numbro/dist/numbro.min.js"));
var dayjs = _interopDefault(__webpack_require__(/*! dayjs */ "./node_modules/dayjs/dayjs.min.js"));
var relativeTimePlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/relativeTime */ "./node_modules/dayjs/plugin/relativeTime.js"));
var utcPlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/utc */ "./node_modules/dayjs/plugin/utc.js"));
var timezonePlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/timezone */ "./node_modules/dayjs/plugin/timezone.js"));
var advancedFormatPlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/advancedFormat */ "./node_modules/dayjs/plugin/advancedFormat.js"));

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var assert = function assert(isTrue, error) {
  if (isTrue) {
    return;
  } else {
    throw new Error(error);
  }
};

(function (Maths) {
  var Operations;

  (function (Operations) {
    Operations["PLUS"] = "plus";
    Operations["MULTIPLY"] = "multipliedBy";
    Operations["DIVIDE"] = "dividedBy";
    Operations["MINUS"] = "minus";
  })(Operations = Maths.Operations || (Maths.Operations = {}));
})(exports.Maths || (exports.Maths = {}));

var Asset = /*#__PURE__*/function () {
  function Asset(asset) {
    this.symbol = new Symbol$1({
      code: asset.code,
      precision: asset.precision
    });
    this.amount = new bignumber_js.BigNumber(asset.amount);
  }

  Asset.fromString = function fromString(asset) {
    var _asset$split = asset.split(' '),
        amount = _asset$split[0],
        code = _asset$split[1];

    var precision = (amount.split('.')[1] || []).length;
    return new Asset({
      code: code,
      precision: precision,
      amount: new bignumber_js.BigNumber(amount)
    });
  };

  Asset.fromSymbol = function fromSymbol(_ref) {
    var symbol = _ref.symbol,
        amount = _ref.amount;

    if (!(symbol instanceof Symbol$1)) {
      throw new Error('Invalid symbol');
    }

    return new Asset({
      code: symbol.code,
      precision: symbol.precision,
      amount: amount
    });
  };

  var _proto = Asset.prototype;

  _proto.isEqualTo = function isEqualTo(asset) {
    return this.isLooselyEqualTo(asset) && this.amount == asset.amount;
  };

  _proto.isLooselyEqualTo = function isLooselyEqualTo(asset) {
    return this.symbol.isEqualTo(asset.symbol);
  };

  _proto.toString = function toString() {
    return new bignumber_js.BigNumber(this.amount).toFixed(this.symbol.precision, bignumber_js.BigNumber.ROUND_DOWN) + " " + this.symbol.code;
  };

  _proto.modifyAmount = function modifyAmount(x, method) {
    var amount = new bignumber_js.BigNumber(0);

    if (typeof x === "number" || bignumber_js.BigNumber.isBigNumber(x)) {
      amount = new bignumber_js.BigNumber(x);
    }

    if (x instanceof Asset) {
      assert(this.isLooselyEqualTo(x), "invalid symbol");
      amount = new bignumber_js.BigNumber(x.amount);
    }

    return Asset.fromSymbol({
      symbol: this.symbol,
      amount: this.amount[method](amount)
    });
  };

  _proto.plus = function plus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.PLUS);
  };

  _proto.minus = function minus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MINUS);
  };

  _proto.multipliedBy = function multipliedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MULTIPLY);
  };

  _proto.dividedBy = function dividedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.DIVIDE);
  };

  _createClass(Asset, [{
    key: "integerAmount",
    get: function get() {
      var factor = Math.pow(10, this.symbol.precision);
      return this.amount.multipliedBy(factor);
    }
  }]);

  return Asset;
}();
var ExtendedAsset = /*#__PURE__*/function () {
  function ExtendedAsset(extendedAsset) {
    if (!(extendedAsset.quantity instanceof Asset)) {
      throw new Error('Invalid quantity');
    }

    this.quantity = extendedAsset.quantity;
    this.contract = extendedAsset.contract;
  }

  ExtendedAsset.fromRaw = function fromRaw(_ref2) {
    var quantity = _ref2.quantity,
        contract = _ref2.contract;
    return new ExtendedAsset({
      quantity: Asset.fromString(quantity),
      contract: contract
    });
  };

  ExtendedAsset.fromExtendedSymbol = function fromExtendedSymbol(symbol, amount) {
    if (!(symbol instanceof ExtendedSymbol)) {
      throw new Error('Invalid extended symbol');
    }

    return new ExtendedAsset({
      quantity: Asset.fromSymbol({
        symbol: symbol.sym,
        amount: amount
      }),
      contract: symbol.contract
    });
  };

  var _proto2 = ExtendedAsset.prototype;

  _proto2.isEqualTo = function isEqualTo(extendedAsset) {
    return this.contract === extendedAsset.contract && this.quantity.isEqualTo(extendedAsset.quantity);
  };

  _proto2.isLooselyEqualTo = function isLooselyEqualTo(extendedAsset) {
    return this.contract === extendedAsset.contract && this.quantity.isLooselyEqualTo(extendedAsset.quantity);
  };

  _proto2.toString = function toString() {
    return this.quantity.toString() + "@" + this.contract;
  };

  _proto2.toExtendedSymbol = function toExtendedSymbol() {
    return new ExtendedSymbol(this.quantity.symbol, this.contract);
  };

  _proto2.modifyAmount = function modifyAmount(x, method) {
    var amount = new bignumber_js.BigNumber(0);

    if (x instanceof ExtendedAsset) {
      assert(this.isLooselyEqualTo(x), "invalid contract or symbol");
      amount = x.quantity;
    } else {
      amount = x;
    }

    return new ExtendedAsset({
      contract: this.contract,
      quantity: this.quantity.modifyAmount(amount, method)
    });
  };

  _proto2.plus = function plus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.PLUS);
  };

  _proto2.minus = function minus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MINUS);
  };

  _proto2.multipliedBy = function multipliedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MULTIPLY);
  };

  _proto2.dividedBy = function dividedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.DIVIDE);
  };

  return ExtendedAsset;
}();
var Symbol$1 = /*#__PURE__*/function () {
  function Symbol(symbol) {
    this.precision = symbol.precision;
    this.code = symbol.code;
  }

  Symbol.fromString = function fromString(symbol) {
    var _symbol$split = symbol.split(','),
        precision = _symbol$split[0],
        code = _symbol$split[1];

    return new Symbol({
      precision: +precision,
      code: code
    });
  };

  var _proto3 = Symbol.prototype;

  _proto3.isEqualTo = function isEqualTo(symbol) {
    return this.code === symbol.code && this.precision === symbol.precision;
  };

  _proto3.toString = function toString() {
    return this.precision + "," + this.code;
  };

  return Symbol;
}();
var ExtendedSymbol = /*#__PURE__*/function () {
  function ExtendedSymbol(sym, contract) {
    this.sym = sym;
    this.contract = contract;
  }

  ExtendedSymbol.fromRaw = function fromRaw(_ref3) {
    var sym = _ref3.sym,
        contract = _ref3.contract;
    return new ExtendedSymbol(Symbol$1.fromString(sym), contract);
  };

  var _proto4 = ExtendedSymbol.prototype;

  _proto4.isEqualTo = function isEqualTo(extendedSymbol) {
    return this.sym.isEqualTo(extendedSymbol.sym) && this.contract === extendedSymbol.contract;
  };

  _proto4.toString = function toString() {
    return this.sym.toString() + "@" + this.contract;
  };

  return ExtendedSymbol;
}();

var currencyMap = {
  // Fiat
  GBP: {
    symbol: '£',
    precision: 2
  },
  EUR: {
    symbol: '€',
    precision: 2
  },
  JPY: {
    symbol: '¥',
    precision: 0
  },
  CAD: {
    symbol: 'CA$',
    precision: 2
  },
  USD: {
    symbol: '$',
    precision: 2
  },
  INR: {
    symbol: '₹',
    precision: 2
  },
  CNY: {
    symbol: 'CN¥',
    precision: 2
  },
  HKD: {
    symbol: 'HK$',
    precision: 2
  },
  KRW: {
    symbol: '₩',
    precision: 0
  },
  AUD: {
    symbol: 'AUD$',
    precision: 2
  },
  SAR: {
    symbol: 'SR',
    precision: 2
  },
  // Crypto
  ETH: {
    symbol: 'Ξ',
    precision: 4
  },
  BTC: {
    symbol: '₿',
    precision: 8
  },
  EOS: {
    symbol: 'EOS',
    precision: 4
  }
};
var assetFormat = {
  decimalSeparator: '.',
  groupSeparator: ',',
  groupSize: 3
};

function toBN(number) {
  return new bignumber_js.BigNumber(number);
}
function numberToAmount(number, precision, round) {
  if (round === void 0) {
    round = bignumber_js.BigNumber.ROUND_DOWN;
  }

  if (number === undefined || typeof number === "number" && isNaN(number)) {
    number = 0;
  }

  return new bignumber_js.BigNumber(number).toFixed(precision, round);
}
function numberToAmountFormatted(number, precision, round) {
  if (round === void 0) {
    round = bignumber_js.BigNumber.ROUND_DOWN;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  return new bignumber_js.BigNumber(number).toFormat(precision, round, assetFormat);
}
function calculatePercentage(balance, percentage, precision) {
  var _final = new bignumber_js.BigNumber(balance).multipliedBy(percentage);

  return numberToAmount(_final, precision, bignumber_js.BigNumber.ROUND_DOWN);
}
function eosDisplayFormatting(value, symbol, precision) {
  return numberToAmountFormatted(value, precision) + " " + symbol;
}
function numberToEos(number, symbol, precision) {
  return numberToAmount(number, precision) + " " + symbol;
}
function numberToEosRoundUp(number, symbol, precision) {
  return numberToAmount(number, precision, bignumber_js.BigNumber.ROUND_UP) + " " + symbol;
}
function parseRex(rex) {
  return new bignumber_js.BigNumber(rex).dividedBy(10000);
}
/**
 * Converts USD to { symbol: "USD", precision: 4 }
 * @param {*} currency
 */

function currencyToSymbol(currency) {
  return currencyMap[currency];
}
/**
 * Converts "1000.0000 EOS" to { amount: 1000, symbol: { code: "EOS", precision: 4 }}
 * @param {*} quantity
 */

function split(quantity) {
  var _quantity$split = quantity.split(' '),
      amount = _quantity$split[0],
      code = _quantity$split[1];

  var precision = (amount.split('.')[1] || []).length;
  return {
    amount: +amount,
    symbol: {
      code: code,
      precision: precision
    }
  };
}
function toNumbro(number) {
  return numbro(number);
}
/**
 * Converts 1000 to "1000.0000 EOS"
 * @param {*} asset
 */

function numberToAsset(number, symbol, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  var amount = numbro(number).format({
    thousandSeparated: false,
    mantissa: precision,
    trimMantissa: trimMantissa
  });
  return amount + " " + symbol;
}
/**
 * DISPLAY FUNCTIONS
 */

/**
 * Converts 1000 to 1,000
 * @param {*} number
 */

function displayNumber(number, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  return numbro(number).format({
    thousandSeparated: true,
    trimMantissa: trimMantissa
  });
}
/**
 * Converts 1000 to $1,000 USD
 * @param {*} number
 */

function displayNumberAsCurrency(_ref) {
  var number = _ref.number,
      precision = _ref.precision,
      _ref$average = _ref.average,
      average = _ref$average === void 0 ? false : _ref$average,
      _ref$lowPrecision = _ref.lowPrecision,
      lowPrecision = _ref$lowPrecision === void 0 ? true : _ref$lowPrecision,
      _ref$trimMantissa = _ref.trimMantissa,
      trimMantissa = _ref$trimMantissa === void 0 ? false : _ref$trimMantissa,
      _ref$currency = _ref.currency,
      currency = _ref$currency === void 0 ? 'USD' : _ref$currency;

  if (!currencyMap[currency]) {
    throw new Error('Unsupported currency');
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  var _currencyMap$currency = currencyMap[currency],
      symbol = _currencyMap$currency.symbol,
      defaultPrecision = _currencyMap$currency.precision;
  var format = {
    thousandSeparated: true,
    mantissa: precision !== undefined ? precision : defaultPrecision,
    trimMantissa: trimMantissa,
    average: average
  };

  if (average) {
    format.lowPrecision = lowPrecision;
  }

  var formattedNumber = numbro(number).format(format);
  return "" + symbol + formattedNumber;
}
/**
 * Converts "1000.0000 EOS" to "1,000.0000 EOS"
 * @param {*} asset
 */

function displayAsset(asset) {
  var _split = split(asset),
      amount = _split.amount,
      code = _split.symbol.code;

  return displayNumber(amount) + " " + code;
}
/**
 * Converts 1000 to 1,000.0000
 * @param {*} number
 */

function displayNumberAsAmount(number, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  return numbro(number).format({
    thousandSeparated: true,
    mantissa: precision,
    trimMantissa: trimMantissa
  });
}
/**
 * Converts 1000 to "1,000.0000 EOS"
 * @param {*} number
 */

function displayNumberAsAsset(number, symbol, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  var amount = numbro(number).format({
    thousandSeparated: true,
    mantissa: precision,
    trimMantissa: trimMantissa
  });
  return amount + " " + symbol;
}
/**
 * Converts 10000000 to "1,000.0000 EOS"
 * @param {*} number
 */

function displayRawNumberAsAsset(number, symbol, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  return displayNumberAsAsset(number / Math.pow(10, precision), symbol, precision, trimMantissa);
}

bignumber_js.BigNumber.set({
  ROUNDING_MODE: 1
});
function add() {
  var start = new bignumber_js.BigNumber(0);

  for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
    numbers[_key] = arguments[_key];
  }

  if (numbers.length) {
    for (var _iterator = _createForOfIteratorHelperLoose(numbers), _step; !(_step = _iterator()).done;) {
      var number = _step.value;
      start = start.plus(number);
    }
  }

  return start;
}
function substract(a, b) {
  return new bignumber_js.BigNumber(a).minus(b);
}
function multiply(a, b) {
  return new bignumber_js.BigNumber(a).multipliedBy(b);
}
function divide(a, b) {
  return new bignumber_js.BigNumber(a).dividedBy(b);
}

function bytesToKB(bytes) {
  if (bytes === void 0) {
    bytes = 0;
  }

  return numbro(bytes / 1024).format({
    thousandSeparated: false,
    mantissa: 2
  });
}
function parseNetAndRam(bytes) {
  var parsedValue = 0;
  var parsedText = '';

  if (bytes < 1024) {
    parsedValue = bytes;
    parsedText = 'Bytes';
  } else if (bytes < 1048576) {
    parsedValue = bytes / 1024;
    parsedText = 'KB';
  } else if (bytes < 1073741824) {
    parsedValue = bytes / 1048576;
    parsedText = 'MB';
  } else if (bytes < 1099511627776) {
    parsedValue = bytes / 1073741824;
    parsedText = 'GB';
  } else if (bytes < 1125899906842624) {
    parsedValue = bytes / 1099511627776;
    parsedText = 'TB';
  }

  return displayNumberAsAmount(parsedValue, 2, true) + " " + parsedText;
}
function parseCpu(us) {
  var parsedValue = 0;
  var parsedText = '';

  if (us < 1000) {
    parsedValue = us;
    parsedText = 'µs';
  } else if (us < 1000000) {
    parsedValue = us / 1000;
    parsedText = 'ms';
  } else if (us < 60000000) {
    parsedValue = us / 1000000;
    parsedText = 's';
  } else if (us < 3600000000) {
    parsedValue = us / 60000000;
    parsedText = 'min';
  } else if (us < 3600000000000) {
    parsedValue = us / 3600000000;
    parsedText = 'hours';
  } else {
    parsedValue = us / 86400000000;
    parsedText = 'days';
  }

  return displayNumberAsAmount(parsedValue, 2, true) + " " + parsedText;
}

dayjs.extend(relativeTimePlugin);
dayjs.extend(utcPlugin);
dayjs.extend(timezonePlugin);
dayjs.extend(advancedFormatPlugin);
var COMMON_DATE_FORMAT = 'MMM-DD-YYYY, hh:mm:ss A';
/**
 * Time utilities
 */

function time(date) {
  return dayjs(date);
}
function utcTime(date) {
  return dayjs(date).utc();
}
function utcTimeToLocal(date) {
  return dayjs(date).local();
}
function unixTime(unixTimestamp) {
  return dayjs.unix(unixTimestamp);
}
function formatDate(date, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return dayjs(date).format(format);
}
function formatDateLocal(date, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return dayjs(date).utc().format(format);
}
function timestampToDate(timestamp) {
  return new Date(timestamp);
}
function utcTimestampToDate(timestamp) {
  timestamp = timestamp.slice(-1) === 'Z' ? timestamp : timestamp + 'Z';
  return new Date(timestamp);
}
function timestampFromNow(timestamp) {
  return time(timestamp).fromNow();
}
function utcTimestampFromNow(timestamp) {
  timestamp = timestamp.slice(-1) === 'Z' ? timestamp : timestamp + 'Z';
  return time(timestamp).fromNow();
}
function parseTimestamp(timestamp, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return formatDate(timestampToDate(timestamp), format);
}
function parseUtcTimestamp(timestamp, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return formatDate(utcTimestampToDate(timestamp), format);
}
function inFuture(date, utc) {
  if (utc === void 0) {
    utc = false;
  }

  return utc ? utcTime(date).isAfter(utcTime()) : time(date).isAfter(time());
}
function inPast(date, utc) {
  if (utc === void 0) {
    utc = false;
  }

  return utc ? utcTime(date).isBefore(utcTime()) : time(date).isBefore(time());
}
function isSameDay(start, end) {
  if (end === void 0) {
    end = time();
  }

  return dayjs(start).isSame(dayjs(end), 'day');
} // Seconds till now if second param empty

function secondsFrom(start, end) {
  if (end === void 0) {
    end = time();
  }

  return dayjs(start).diff(dayjs(end), 'second');
}
function millisecondsFrom(start, end) {
  if (end === void 0) {
    end = time();
  }

  return dayjs(start).diff(dayjs(end));
}
/**
 * Specific to EOS
 */

function startDate(startDate, days) {
  if (days === void 0) {
    days = 3;
  }

  return dayjs(startDate).clone().subtract(days, 'days');
}
function formatStartDate(startTimestamp) {
  return startDate(startTimestamp).format('MMM-DD-YYYY, hh:mm:ss A');
}
function endDate(endDate, days) {
  if (days === void 0) {
    days = 3;
  }

  return dayjs(endDate).clone().add(days, 'days');
}
function formatEndDate(endTimestamp) {
  return endDate(endTimestamp).format('MMM-DD-YYYY, hh:mm:ss A');
}
function dateToUtcTimePoint(date) {
  if (date === void 0) {
    date = time();
  }

  return dayjs(date).utc().format('YYYY-MM-DDTHH:mm:ss.SSS');
}
var emptyTimePoint = '1970-01-01T00:00:00.000';
function parseSeconds(seconds) {
  var days = 0;
  var hours = 0;
  var minutes = 0;
  var parsedDate = ''; // Days

  if (seconds > 86400) {
    days += Math.floor(seconds / 86400);
    seconds -= days * 86400;
    parsedDate += days.toFixed(0) + " " + (days === 1 ? 'Day' : 'Days') + " ";
  } // Hours


  if (seconds > 3600) {
    hours += Math.floor(seconds / 3600);
    seconds -= hours * 3600;
    parsedDate += hours.toFixed(0) + " " + (hours === 1 ? 'Hour' : 'Hours') + " ";
  } // Minutes


  if (seconds > 60) {
    minutes += Math.floor(seconds / 60);
    seconds -= minutes * 60;
    parsedDate += minutes.toFixed(0) + " " + (minutes === 1 ? 'Minute' : 'Minutes') + " ";
  } // Seconds


  if (seconds > 0) {
    parsedDate += seconds.toFixed(0) + " Seconds ";
  }

  return parsedDate;
}

exports.Asset = Asset;
exports.ExtendedAsset = ExtendedAsset;
exports.ExtendedSymbol = ExtendedSymbol;
exports.Symbol = Symbol$1;
exports.add = add;
exports.bytesToKB = bytesToKB;
exports.calculatePercentage = calculatePercentage;
exports.currencyToSymbol = currencyToSymbol;
exports.dateToUtcTimePoint = dateToUtcTimePoint;
exports.displayAsset = displayAsset;
exports.displayNumber = displayNumber;
exports.displayNumberAsAmount = displayNumberAsAmount;
exports.displayNumberAsAsset = displayNumberAsAsset;
exports.displayNumberAsCurrency = displayNumberAsCurrency;
exports.displayRawNumberAsAsset = displayRawNumberAsAsset;
exports.divide = divide;
exports.emptyTimePoint = emptyTimePoint;
exports.endDate = endDate;
exports.eosDisplayFormatting = eosDisplayFormatting;
exports.formatDate = formatDate;
exports.formatDateLocal = formatDateLocal;
exports.formatEndDate = formatEndDate;
exports.formatStartDate = formatStartDate;
exports.inFuture = inFuture;
exports.inPast = inPast;
exports.isSameDay = isSameDay;
exports.millisecondsFrom = millisecondsFrom;
exports.multiply = multiply;
exports.numberToAmount = numberToAmount;
exports.numberToAmountFormatted = numberToAmountFormatted;
exports.numberToAsset = numberToAsset;
exports.numberToEos = numberToEos;
exports.numberToEosRoundUp = numberToEosRoundUp;
exports.parseCpu = parseCpu;
exports.parseNetAndRam = parseNetAndRam;
exports.parseRex = parseRex;
exports.parseSeconds = parseSeconds;
exports.parseTimestamp = parseTimestamp;
exports.parseUtcTimestamp = parseUtcTimestamp;
exports.secondsFrom = secondsFrom;
exports.split = split;
exports.startDate = startDate;
exports.substract = substract;
exports.time = time;
exports.timestampFromNow = timestampFromNow;
exports.timestampToDate = timestampToDate;
exports.toBN = toBN;
exports.toNumbro = toNumbro;
exports.unixTime = unixTime;
exports.utcTime = utcTime;
exports.utcTimeToLocal = utcTimeToLocal;
exports.utcTimestampFromNow = utcTimestampFromNow;
exports.utcTimestampToDate = utcTimestampToDate;
//# sourceMappingURL=numbers.cjs.development.js.map


/***/ }),

/***/ "./node_modules/@bloks/utils/dist/utils.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/@bloks/utils/dist/utils.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DbopOp": () => (/* binding */ DbopOp),
/* harmony export */   "Nft": () => (/* binding */ Nft),
/* harmony export */   "bytesToString": () => (/* binding */ bytesToString),
/* harmony export */   "charidx": () => (/* binding */ charidx),
/* harmony export */   "cloneDeepArrayOfObj": () => (/* binding */ cloneDeepArrayOfObj),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "decodeName": () => (/* binding */ decodeName),
/* harmony export */   "dfuseDepthFirstExtract": () => (/* binding */ dfuseDepthFirstExtract),
/* harmony export */   "dfuseTransformDeferredAction": () => (/* binding */ dfuseTransformDeferredAction),
/* harmony export */   "dfuseTransformDeferredTransaction": () => (/* binding */ dfuseTransformDeferredTransaction),
/* harmony export */   "dfuseTransformGetActions": () => (/* binding */ dfuseTransformGetActions),
/* harmony export */   "dfuseTransformTrace": () => (/* binding */ dfuseTransformTrace),
/* harmony export */   "dfuseTransformTransaction": () => (/* binding */ dfuseTransformTransaction),
/* harmony export */   "dfuseTransformTransactionResult": () => (/* binding */ dfuseTransformTransactionResult),
/* harmony export */   "encodeName": () => (/* binding */ encodeName),
/* harmony export */   "fioKeyToActor": () => (/* binding */ fioKeyToActor),
/* harmony export */   "hexToUint8Array": () => (/* binding */ hexToUint8Array),
/* harmony export */   "historyTransformDeferredAction": () => (/* binding */ historyTransformDeferredAction),
/* harmony export */   "historyTransformDeferredTransaction": () => (/* binding */ historyTransformDeferredTransaction),
/* harmony export */   "historyTransformFlatTraces": () => (/* binding */ historyTransformFlatTraces),
/* harmony export */   "historyTransformRecursiveTrace": () => (/* binding */ historyTransformRecursiveTrace),
/* harmony export */   "historyTransformTransaction": () => (/* binding */ historyTransformTransaction),
/* harmony export */   "hyperionTransformFlatTraces": () => (/* binding */ hyperionTransformFlatTraces),
/* harmony export */   "hyperionTransformGetActions": () => (/* binding */ hyperionTransformGetActions),
/* harmony export */   "hyperionTransformTransaction": () => (/* binding */ hyperionTransformTransaction),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "nativeTransformGetActions": () => (/* binding */ nativeTransformGetActions),
/* harmony export */   "parseAaNft": () => (/* binding */ parseAaNft),
/* harmony export */   "parseSaNft": () => (/* binding */ parseSaNft),
/* harmony export */   "sha": () => (/* binding */ sha),
/* harmony export */   "string_to_uint128_hash": () => (/* binding */ string_to_uint128_hash),
/* harmony export */   "urlBuilder": () => (/* binding */ urlBuilder),
/* harmony export */   "wait": () => (/* binding */ wait)
/* harmony export */ });
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fast_text_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-text-encoding */ "./node_modules/fast-text-encoding/text.min.js");
/* harmony import */ var fast_text_encoding__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_text_encoding__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(qs__WEBPACK_IMPORTED_MODULE_2__);




function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function cloneDeepArrayOfObj(array) {
  return [].concat(array).map(function (i) {
    return _extends({}, i);
  });
}

var charmap = '.12345abcdefghijklmnopqrstuvwxyz';
function charidx(ch) {
  var idx = charmap.indexOf(ch);

  if (idx === -1) {
    throw new TypeError("Invalid character: '" + ch + "'");
  }

  return idx;
}
function encodeName(name, littleEndian) {
  if (littleEndian === void 0) {
    littleEndian = false;
  }

  if (typeof name !== 'string') {
    throw new TypeError('name parameter is a required string');
  }

  if (name.length > 12) {
    throw new TypeError('A name can be up to 12 characters long');
  }

  var bitstr = '';

  for (var i = 0; i <= 12; i++) {
    // process all 64 bits (even if name is short)
    var c = i < name.length ? charidx(name[i]) : 0;
    var bitlen = i < 12 ? 5 : 4;
    var bits = Number(c).toString(2);

    if (bits.length > bitlen) {
      throw new TypeError('Invalid name ' + name);
    }

    bits = '0'.repeat(bitlen - bits.length) + bits;
    bitstr += bits;
  }

  var value = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(bitstr, true, 2); // convert to LITTLE_ENDIAN

  var leHex = '';
  var bytes = littleEndian ? value.toBytesLE() : value.toBytesBE();

  for (var _iterator = _createForOfIteratorHelperLoose(bytes), _step; !(_step = _iterator()).done;) {
    var b = _step.value;
    var n = Number(b).toString(16);
    leHex += (n.length === 1 ? '0' : '') + n;
  }

  var ulName = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(leHex, true, 16).toString(); // console.log('encodeName', name, value.toString(), ulName.toString(), JSON.stringify(bitstr.split(/(.....)/).slice(1)))

  return ulName.toString();
}
function decodeName(encodedName, littleEndian) {
  if (littleEndian === void 0) {
    littleEndian = true;
  }

  var value = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(encodedName); // convert from LITTLE_ENDIAN

  var beHex = '';
  var bytes = littleEndian ? value.toBytesLE() : value.toBytesBE();

  for (var _iterator2 = _createForOfIteratorHelperLoose(bytes), _step2; !(_step2 = _iterator2()).done;) {
    var b = _step2.value;
    var n = Number(b).toString(16);
    beHex += (n.length === 1 ? '0' : '') + n;
  }

  beHex += '0'.repeat(16 - beHex.length);
  var fiveBits = long__WEBPACK_IMPORTED_MODULE_0___default().fromNumber(0x1f, true);
  var fourBits = long__WEBPACK_IMPORTED_MODULE_0___default().fromNumber(0x0f, true);
  var beValue = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(beHex, true, 16);
  var str = '';
  var tmp = beValue;

  for (var i = 0; i <= 12; i++) {
    var c = charmap[tmp.and(i === 0 ? fourBits : fiveBits)];
    str = c + str;
    tmp = tmp.shiftRight(i === 0 ? 4 : 5);
  }

  str = str.replace(/\.+$/, ''); // remove trailing dots (all of them)
  // console.log('decodeName', str, beValue.toString(), value.toString(), JSON.stringify(beValue.toString(2).split(/(.....)/).slice(1)))

  return str;
}
/**
 * FIO SPECIFIC
 * @param key FIO
 */

var shorten_key = function shorten_key(key) {
  var res = new (long__WEBPACK_IMPORTED_MODULE_0___default())(0, 0, true);
  var i = 1; // Ignore key head

  var len = 0;

  while (len <= 12) {
    if (i >= 33) throw new Error('FIO: i too large');
    var trimmed_char = key[i] & (len == 12 ? 0x0f : 0x1f);

    if (trimmed_char == 0) {
      i++;
      continue;
    } // Skip a zero and move to next


    var shuffle = len == 12 ? 0 : 5 * (12 - len) - 1;
    res = res.or(long__WEBPACK_IMPORTED_MODULE_0___default().fromNumber(shift(trimmed_char, shuffle), true));
    len++;
    i++;
  }

  return res;
};

function shift(number, shift) {
  return number * Math.pow(2, shift);
}

var fioKeyToActor = function fioKeyToActor(key, stringToPublicKey) {
  var pubKey = stringToPublicKey(key, 'FIO').data;
  var shortenedPubKey = shorten_key(pubKey);
  var decodedName = decodeName(shortenedPubKey.toString(), false);
  return decodedName.substr(0, 12);
}; // convert bytes to a String

function bytesToString(bytes) {
  if (typeof bytes === 'string') {
    return bytes;
  }

  return bytes.reduce(function (acc, _byte) {
    return acc + String.fromCharCode(_byte);
  }, '');
}
/**
 * Checks if string
 */

function isString(string) {
  return Object.prototype.toString.call(string) === '[object String]';
}
/**
 *
 * @param message Sha256
 */

function sha(_x, _x2, _x3) {
  return _sha.apply(this, arguments);
}
/**
 * FIO function
 *
 * @param str example: coinomi
 * @returns returns: 968ba84617b73b8e2a73b59170976f41
 */

function _sha() {
  _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(message, binaryRepresentationOfHex, type) {
    var encodedMessage, matched, mapped, hashBuffer, hashArray, hashHex;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (binaryRepresentationOfHex === void 0) {
              binaryRepresentationOfHex = false;
            }

            if (type === void 0) {
              type = 'SHA-256';
            }

            if (!binaryRepresentationOfHex) {
              _context.next = 10;
              break;
            }

            matched = message.match(/[\da-f]{2}/gi);

            if (matched) {
              _context.next = 6;
              break;
            }

            throw Error('Empty message');

          case 6:
            mapped = matched.map(function (h) {
              return parseInt(h, 16);
            });
            encodedMessage = new Uint8Array(mapped);
            _context.next = 11;
            break;

          case 10:
            encodedMessage = new TextEncoder().encode(message);

          case 11:
            _context.next = 13;
            return crypto.subtle.digest(type, encodedMessage);

          case 13:
            hashBuffer = _context.sent;
            // hash the message
            hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array

            hashHex = hashArray.map(function (b) {
              return b.toString(16).padStart(2, '0');
            }).join(''); // convert bytes to hex string

            return _context.abrupt("return", hashHex);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _sha.apply(this, arguments);
}

function string_to_uint128_hash(_x4) {
  return _string_to_uint128_hash.apply(this, arguments);
}

function _string_to_uint128_hash() {
  _string_to_uint128_hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(str) {
    var hexBytes;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return sha(str, false, 'SHA-1');

          case 2:
            hexBytes = _context2.sent.match(/../g);

            if (!hexBytes) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", hexBytes.slice(0, -4).reverse().join(''));

          case 7:
            return _context2.abrupt("return", 0);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _string_to_uint128_hash.apply(this, arguments);
}

function nativeTransformGetActions(result, constants) {
  result.actions = result.actions.map(function (action) {
    if (action['action_trace']['act']['account'] === constants.EOSIO && action['action_trace']['act']['name'] === 'claimrewards' && action['action_trace']['inline_traces']) {
      var totalAmount = 0;
      var totalSymbol = '';

      for (var _iterator = _createForOfIteratorHelperLoose(action['action_trace']['inline_traces']), _step; !(_step = _iterator()).done;) {
        var inline_trace = _step.value;

        if (inline_trace['act']['data']['from'] === constants.EOSIO_VPAY || inline_trace['act']['data']['from'] === constants.EOSIO_BPAY) {
          var _inline_trace$act$dat = inline_trace['act']['data']['quantity'].split(' '),
              amount = _inline_trace$act$dat[0],
              symbol = _inline_trace$act$dat[1];

          totalAmount += Number(amount);
          totalSymbol = symbol;
        }
      }

      action['action_trace']['act']['data']['quantity'] = totalAmount.toFixed(constants.CORE_PRECISION) + " " + totalSymbol;
    }

    return action;
  }).reverse();
  result.numOfTxLoaded = result.actions.length;
  return result;
}
function hyperionTransformGetActions(_ref) {
  var query_time = _ref.query_time,
      lib = _ref.lib,
      actions = _ref.actions,
      _ref$total = _ref.total,
      relation = _ref$total.relation,
      value = _ref$total.value;
  var transformedActions = [];
  var act_digest = 0;

  for (var _iterator2 = _createForOfIteratorHelperLoose(actions), _step2; !(_step2 = _iterator2()).done;) {
    var action = _step2.value;
    action.receipt = {
      act_digest: act_digest++
    };
    action.block_time = action['@timestamp']; // Set quantity

    if (action.act.data && action.act.data.amount && action.act.data.symbol) {
      action.act.data.quantity = action.act.data.amount + " " + action.act.data.symbol;
    }

    transformedActions.push({
      action_trace: action
    });
  }

  return {
    lib: lib,
    actions: transformedActions,
    query_time: query_time,
    numOfTxLoaded: actions.length,
    total: {
      relation: relation,
      value: value
    }
  };
}
function dfuseTransformGetActions(_ref2, accountName, constants) {
  var transactions = _ref2.transactions,
      cursor = _ref2.cursor;

  // Error checking
  if (!transactions) {
    return {
      cursor: cursor,
      actions: [],
      numOfTxLoaded: 0
    };
  }

  var actions = [];

  for (var _iterator3 = _createForOfIteratorHelperLoose(transactions), _step3; !(_step3 = _iterator3()).done;) {
    var transaction = _step3.value;
    var lifecycle = transaction.lifecycle,
        action_idx = transaction.action_idx; // GRAPHQL -> DOesnt give action_idx since its match

    if (!action_idx) {
      actions = actions.concat(lifecycle['execution_trace']['action_traces'].map(function (action) {
        return {
          action_trace: action
        };
      }).reverse());
      continue;
    }

    var current_idx = 0;

    for (var _iterator4 = _createForOfIteratorHelperLoose(lifecycle['execution_trace']['action_traces']), _step4; !(_step4 = _iterator4()).done;) {
      var action_trace = _step4.value;
      // Fix holes
      if (!action_trace['inline_traces']) action_trace['inline_traces'] = []; // BP CLAIM REWARDS

      if (action_trace['act']['account'] === constants.EOSIO && action_trace['act']['name'] === 'claimrewards') {
        var totalAmount = 0;
        var totalSymbol = '';

        for (var _iterator5 = _createForOfIteratorHelperLoose(action_trace['inline_traces']), _step5; !(_step5 = _iterator5()).done;) {
          var inline_trace = _step5.value;

          if (inline_trace['act']['data']['from'] === constants.EOSIO_VPAY || inline_trace['act']['data']['from'] === constants.EOSIO_BPAY) {
            actions.push({
              action_trace: inline_trace
            });

            var _inline_trace$act$dat2 = inline_trace['act']['data']['quantity'].split(' '),
                amount = _inline_trace$act$dat2[0],
                symbol = _inline_trace$act$dat2[1];

            totalAmount += Number(amount);
            totalSymbol = symbol;
          }
        }

        action_trace['act']['data']['quantity'] = totalAmount.toFixed(constants.CORE_PRECISION) + " " + totalSymbol;
        delete action_trace.inline_traces;
        actions.push({
          action_trace: action_trace
        }); // REX sell
      } else if (action_trace['act']['account'] === constants.EOSIO && action_trace['act']['name'] === 'sellrex') {
        for (var _iterator6 = _createForOfIteratorHelperLoose(action_trace['inline_traces']), _step6; !(_step6 = _iterator6()).done;) {
          var _inline_trace = _step6.value;

          if (_inline_trace['act']['account'] === constants.EOSIO_REX || _inline_trace['act']['name'] === 'sellresult') {
            actions.push({
              action_trace: _inline_trace
            });
          }
        }

        delete action_trace.inline_traces;
        actions.push({
          action_trace: action_trace
        });
      } else {
        // This is done for ordering of TX
        var local_actions = [];
        current_idx = dfuseExtractActions(accountName, action_trace, local_actions, action_idx, current_idx);
        actions = actions.concat(local_actions.reverse());
      }

      current_idx++;
    }
  }

  return {
    cursor: cursor,
    actions: actions,
    numOfTxLoaded: transactions.length
  };
}

function dfuseExtractActions(accountName, action, traces, action_idx, current_idx) {
  if (action_idx.includes(current_idx)) {
    traces.push({
      action_trace: action
    });
  }

  if (action['inline_traces']) {
    for (var _iterator7 = _createForOfIteratorHelperLoose(action['inline_traces']), _step7; !(_step7 = _iterator7()).done;) {
      var inline_trace = _step7.value;
      current_idx++;
      current_idx = dfuseExtractActions(accountName, inline_trace, traces, action_idx, current_idx);
    }

    delete action['inline_traces'];
  }

  return current_idx;
}

function dfuseDepthFirstExtract(result) {
  var transactions = result.transactions,
      cursor = result.cursor;
  var actions = [];

  if (transactions) {
    for (var _iterator8 = _createForOfIteratorHelperLoose(transactions), _step8; !(_step8 = _iterator8()).done;) {
      var transaction = _step8.value;
      var lifecycle = transaction.lifecycle,
          action_idx = transaction.action_idx;
      var traces = lifecycle['execution_trace']['action_traces'];
      var current_idx = 0;

      for (var _iterator9 = _createForOfIteratorHelperLoose(traces), _step9; !(_step9 = _iterator9()).done;) {
        var trace = _step9.value;
        current_idx = dfuseDepthFirstExtractHelper(trace, lifecycle['dbops'], actions, action_idx, current_idx);
        current_idx++;
      }
    }
  }

  return {
    actions: actions,
    cursor: cursor
  };
}

function dfuseDepthFirstExtractHelper(action, dbops, allActions, action_idx, currentIdx) {
  if (action_idx && action_idx.includes(currentIdx)) {
    allActions.push({
      action_trace: action,
      dbops: dbops.filter(function (op) {
        return op.action_idx === currentIdx;
      })
    });
  }

  if (action['inline_traces']) {
    for (var _iterator10 = _createForOfIteratorHelperLoose(action['inline_traces']), _step10; !(_step10 = _iterator10()).done;) {
      var trace = _step10.value;
      currentIdx = dfuseDepthFirstExtractHelper(trace, dbops, allActions, action_idx, ++currentIdx);
    }
  }

  return currentIdx;
}

function hyperionTransformFlatTraces(traces) {
  var tracesByOrdinal = traces.reduce(function (acc, trace) {
    acc[trace.action_ordinal] = _extends({}, trace, {
      traces: [],
      account_ram_deltas: trace.account_ram_deltas,
      receivers: trace.notified
    });
    return acc;
  }, {});

  for (var _iterator11 = _createForOfIteratorHelperLoose(traces.sort(function (a, b) {
    return b.action_ordinal - a.action_ordinal;
  })), _step11; !(_step11 = _iterator11()).done;) {
    var trace = _step11.value;

    // Skip top level actions
    if (trace.creator_action_ordinal === 0 || !tracesByOrdinal[trace.creator_action_ordinal]) {
      continue;
    }

    var currentInlineTraces = tracesByOrdinal[trace.creator_action_ordinal].traces || [];
    var newInlineTraces = [tracesByOrdinal[trace.action_ordinal]];
    delete tracesByOrdinal[trace.action_ordinal];
    tracesByOrdinal[trace.creator_action_ordinal].traces = newInlineTraces.concat(currentInlineTraces);
  }

  var result = Object.values(tracesByOrdinal);
  return result;
}
function hyperionTransformTransaction(transaction) {
  var actions = transaction.actions,
      lib = transaction.lib,
      trx_id = transaction.trx_id;
  var firstAction = actions[0]; // Parent only on < 1.8

  var transformedActions = firstAction.parent ? actions.filter(function (trace) {
    return trace.parent === 0;
  }) : actions;
  var traces = hyperionTransformFlatTraces(actions);
  return {
    status: 'Executed',
    cpu_usage: firstAction.cpu_usage_us,
    net_usage: firstAction.net_usage_words * 8,
    id: trx_id,
    block_time: firstAction['@timestamp'],
    block_num: firstAction['block_num'],
    delay_sec: 'N/A',
    expiration: 'N/A',
    lib: lib,
    actions: transformedActions,
    traces: traces
  };
}
function dfuseTransformTrace(_ref3) {
  var trace = _ref3.trace,
      _ref3$dbops = _ref3.dbops,
      dbops = _ref3$dbops === void 0 ? [] : _ref3$dbops,
      _ref3$ramops = _ref3.ramops,
      ramops = _ref3$ramops === void 0 ? [] : _ref3$ramops,
      _ref3$index = _ref3.index,
      index = _ref3$index === void 0 ? 0 : _ref3$index;
  var transformed = {
    act: trace.act,
    account_ram_deltas: trace.account_ram_deltas,
    receivers: [trace.receipt.receiver],
    act_digest: trace.receipt.act_digest,
    dbops: (dbops || []).filter(function (op) {
      return op.action_idx === index;
    }),
    ramops: (ramops || []).filter(function (op) {
      return op.action_idx === index;
    }),
    traces: []
  };

  if (trace.inline_traces && trace.inline_traces.length) {
    trace.inline_traces.map(function (itrace) {
      index++; // If TX data is different

      if (itrace.act.hex_data !== transformed.act.hex_data || itrace.act.name !== transformed.act.name || itrace.act.account !== transformed.act.account) {
        transformed.traces.push(dfuseTransformTrace({
          trace: itrace,
          index: index,
          ramops: ramops,
          dbops: dbops
        })); // Hex data is same, but still add in inline
      } else {
        if (itrace.inline_traces && itrace.inline_traces.length) {
          for (var _iterator12 = _createForOfIteratorHelperLoose(itrace.inline_traces), _step12; !(_step12 = _iterator12()).done;) {
            var iitrace = _step12.value;
            index++;
            transformed.traces.push(dfuseTransformTrace({
              trace: iitrace,
              index: index,
              ramops: ramops,
              dbops: dbops
            }));
          }
        } // Add Receivers even if not different


        if (!transformed.receivers.includes(itrace.receipt.receiver)) {
          transformed.receivers.push(itrace.receipt.receiver);
        } // Add db ops and ram ops even if not different


        transformed.dbops = transformed.dbops.concat((dbops || []).filter(function (op) {
          return op.action_idx === index;
        }));
        transformed.ramops = transformed.ramops.concat((ramops || []).filter(function (op) {
          return op.action_idx === index;
        }));
      }
    });
  }

  return transformed;
}
function dfuseTransformTransaction(result) {
  var execution_trace = result.execution_trace,
      transaction = result.transaction,
      ramops = result.ramops,
      dbops = result.dbops,
      created_by = result.created_by;
  var count = 0;
  var actions = (execution_trace['action_traces'] || []).map(function (trace) {
    var transformedTrace = dfuseTransformTrace({
      trace: trace,
      ramops: ramops,
      dbops: dbops,
      index: count
    }); // Increment counts

    var traceCount = inlineTraceCountHelper([trace]);
    count += traceCount;
    return transformedTrace;
  });
  return {
    status: execution_trace.receipt.status,
    cpu_usage: execution_trace.receipt.cpu_usage_us,
    net_usage: execution_trace.receipt.net_usage_words * 8,
    id: execution_trace.id,
    block_time: execution_trace.block_time,
    block_num: execution_trace.block_num,
    delay_sec: transaction.delay_sec,
    expiration: transaction.expiration,
    created_by: created_by,
    actions: actions,
    traces: actions
  };
}
function dfuseTransformDeferredAction(action) {
  return {
    act: _extends({}, action),
    account_ram_deltas: [],
    receivers: [],
    act_digest: '',
    traces: []
  };
}
function dfuseTransformDeferredTransaction(result) {
  var actions = result.transaction.actions.map(dfuseTransformDeferredAction);
  return {
    id: result.id,
    status: 'deferred',
    dfuse_status: result.transaction_status,
    sender: result.created_by.sender,
    payer: result.created_by.payer,
    published: result.created_by.published_at,
    delay_until: result.created_by.delay_until,
    expiration: result.transaction.expiration,
    delay_sec: result.transaction.delay_sec,
    actions: actions,
    traces: actions
  };
}
function dfuseTransformTransactionResult(result) {
  return result.execution_trace ? dfuseTransformTransaction(result) : dfuseTransformDeferredTransaction(result);
}
function historyTransformDeferredAction(action) {
  return _extends({}, action, {
    account_ram_deltas: [],
    receiver: '',
    act_digest: '',
    traces: []
  });
}
function historyTransformDeferredTransaction(transaction) {
  return {
    id: transaction.trx_id,
    status: 'deferred',
    sender: transaction.sender,
    payer: transaction.payer,
    published: transaction.published,
    expiration: transaction.expiration,
    delay_until: transaction.delay_until,
    delay_sec: transaction.transaction.delay_sec,
    actions: transaction.transaction.actions,
    traces: transaction.transaction.actions.map(function (action) {
      return historyTransformDeferredAction(action);
    })
  };
}
function historyTransformRecursiveTrace(action) {
  var transformed = {
    act: action.act,
    account_ram_deltas: action.account_ram_deltas || [],
    receivers: [action.receipt.receiver],
    act_digest: action.receipt.act_digest,
    traces: []
  };

  if (action.inline_traces && action.inline_traces.length) {
    action.inline_traces.forEach(function (trace) {
      var sameAsParent = trace.receipt.act_digest === action.receipt.act_digest; // Actions done in response to notification -> Add in inline traces

      if (sameAsParent && trace.inline_traces && trace.inline_traces.length) {
        transformed.traces = transformed.traces.concat(trace.inline_traces.map(historyTransformRecursiveTrace));

        if (!transformed.receivers.includes(trace.receipt.receiver)) {
          transformed.receivers.push(trace.receipt.receiver);
        } // Normal action

      } else if (!sameAsParent) {
        transformed.traces.push(historyTransformRecursiveTrace(trace)); // Normal notification
      } else {
        if (!transformed.receivers.includes(trace.receipt.receiver)) {
          transformed.receivers.push(trace.receipt.receiver);
        }
      }
    });
  }

  return transformed;
}
function historyTransformFlatTraces(traces) {
  var tracesByOrdinal = traces.reduce(function (acc, trace) {
    acc[trace.action_ordinal] = trace;
    return acc;
  }, {});

  for (var _iterator13 = _createForOfIteratorHelperLoose(traces.sort(function (a, b) {
    return b.action_ordinal - a.action_ordinal;
  })), _step13; !(_step13 = _iterator13()).done;) {
    var trace = _step13.value;

    // Skip top level actions
    if (trace.creator_action_ordinal === 0) {
      continue;
    }

    var currentInlineTraces = tracesByOrdinal[trace.creator_action_ordinal].inline_traces || [];
    var newInlineTraces = [tracesByOrdinal[trace.action_ordinal]];
    tracesByOrdinal[trace.creator_action_ordinal].inline_traces = newInlineTraces.concat(currentInlineTraces);
  }

  var result = Object.values(tracesByOrdinal).filter(function (trace) {
    return trace.creator_action_ordinal === 0;
  }).map(function (trace) {
    return _extends({}, trace, {
      receivers: [trace.receipt.receiver],
      act_digest: trace.receipt.act_digest
    });
  });
  return result;
}

function findIfSameTx(inline_traces, act) {
  var match = false;

  for (var _iterator14 = _createForOfIteratorHelperLoose(inline_traces), _step14; !(_step14 = _iterator14()).done;) {
    var trace = _step14.value;

    if (trace.act.hex_data === act.hex_data && trace.act.name === act.name && trace.act.account === act.account || findIfSameTx(trace.inline_traces, act)) {
      return true;
    }
  }

  return match;
}

function inlineTraceCountHelper(traces) {
  return traces.reduce(function (acc, trace) {
    return acc + 1 + inlineTraceCountHelper(trace.inline_traces || []);
  }, 0);
}

function historyTransformTransaction(transaction) {
  if (transaction.trx) {
    var actions = [];
    var delay_sec;
    var expiration;
    var traces; // >= 1.8 traces

    if (transaction.traces && transaction.traces.length && 'creator_action_ordinal' in transaction.traces[0]) {
      traces = historyTransformFlatTraces(transaction.traces).map(historyTransformRecursiveTrace);
      actions = transaction.traces.filter(function (trace) {
        return trace.creator_action_ordinal === 0;
      }); // 1.7 and under nodeos
    } else {
      var _loop = function _loop() {
        var _step15$value = _step15.value,
            i = _step15$value[0],
            action = _step15$value[1];
        var tempTraces = transaction.traces.slice();
        tempTraces.splice(i, i + 1);
        var foundSameHex = tempTraces.find(function (trace) {
          return findIfSameTx(trace.inline_traces.slice(), action.act);
        });

        if (!foundSameHex) {
          actions.push(action);
        }
      };

      for (var _iterator15 = _createForOfIteratorHelperLoose(transaction.traces.entries()), _step15; !(_step15 = _iterator15()).done;) {
        _loop();
      }

      traces = actions.map(function (action) {
        return historyTransformRecursiveTrace(action);
      }); // Normal not deferred TX

      if (transaction.trx.trx) {
        delay_sec = transaction.trx.trx.delay_sec;
        expiration = transaction.trx.trx.expiration; // Deferred TX
      } else {
        delay_sec = 'N/A';
        expiration = 'N/A';
      } // Fix for empty array (hex data fucked up) WTF?


      if (transaction.traces.length > 0 && actions.length === 0) {
        actions = [];
        var counter = 0;
        var i = 0;

        for (var _iterator16 = _createForOfIteratorHelperLoose(transaction.traces), _step16; !(_step16 = _iterator16()).done;) {
          var _tx = _step16.value;

          if (i >= counter) {
            actions.push(_tx);
          }

          counter += inlineTraceCountHelper(_tx.inline_traces);
          i++;
        }

        traces = actions.map(function (action) {
          return historyTransformRecursiveTrace(action);
        });
      } // Fix for empty trace (block hint used?)


      if (transaction.traces.length === 0 && actions.length === 0 && transaction.trx.trx && transaction.trx.trx.actions && transaction.trx.trx.actions.length) {
        traces = transaction.trx.trx.actions.map(function (action) {
          return {
            act: action,
            account_ram_deltas: [],
            receivers: action.authorization.map(function (auth) {
              return auth.actor;
            }),
            act_digest: '',
            traces: []
          };
        });
        actions = traces;
      }
    } // For display


    var extraFields = _extends({}, transaction, transaction.trx.receipt, transaction.trx.trx || {});

    var tx = _extends({}, extraFields, {
      status: transaction.trx.receipt.status,
      cpu_usage: transaction.trx.receipt.cpu_usage_us,
      net_usage: transaction.trx.receipt.net_usage_words * 8,
      id: transaction.id,
      block_time: transaction.block_time,
      block_num: transaction.block_num,
      delay_sec: delay_sec,
      expiration: expiration,
      actions: actions,
      traces: traces
    });

    return tx; // MEETONE history
  } else if (transaction.action_traces) {
    return dfuseTransformTransaction(transaction); // On block
  } else {
    var _traces = transaction.traces.map(function (trace) {
      return historyTransformRecursiveTrace(trace);
    });

    return {
      status: 'executed',
      cpu_usage: 0,
      net_usage: 0,
      id: transaction.id,
      block_time: transaction.block_time,
      block_num: transaction.block_num,
      delay_sec: 0,
      expiration: 0,
      actions: _traces,
      traces: _traces
    };
  }
}

function hexToUint8Array(hex) {
  if (typeof hex !== 'string') {
    throw new Error('Expected string containing hex digits');
  }

  if (hex.length % 2) {
    throw new Error('Odd number of hex digits');
  }

  var l = hex.length / 2;
  var result = new Uint8Array(l);

  for (var i = 0; i < l; ++i) {
    var x = parseInt(hex.substr(i * 2, 2), 16);

    if (Number.isNaN(x)) {
      throw new Error('Expected hex string');
    }

    result[i] = x;
  }

  return result;
}

function urlBuilder(url, id, params) {
  params = params || {};

  if (typeof id !== 'undefined' && id !== null) {
    url += "/" + encodeURIComponent(id);
  }

  if (Object.keys(params).length !== 0) {
    var queryString = qs__WEBPACK_IMPORTED_MODULE_2___default().stringify(params);
    url += "?" + queryString;
  }

  return url;
}

function copy(text) {
  var selected = false;
  var el = document.createElement('textarea');
  el.value = text;
  el.setAttribute('readonly', '');
  el.style.position = 'absolute';
  el.style.left = '-9999px';
  document.body.appendChild(el);
  var selection = document.getSelection();

  if (selection && selection.rangeCount > 0) {
    selected = selection.getRangeAt(0);
  }

  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);

  if (selection && selected) {
    selection.removeAllRanges();
    selection.addRange(selected);
  }
}

var Nft = function Nft(_ref) {
  var idata = _ref.idata,
      mdata = _ref.mdata,
      name = _ref.name,
      image = _ref.image,
      video = _ref.video,
      model = _ref.model,
      audio = _ref.audio,
      stage = _ref.stage,
      skybox = _ref.skybox,
      pdf = _ref.pdf,
      id = _ref.id,
      contract = _ref.contract,
      link = _ref.link,
      owner = _ref.owner,
      author = _ref.author,
      collection = _ref.collection,
      mint = _ref.mint,
      edition_size = _ref.edition_size;
  this.idata = idata;
  this.mdata = mdata;
  this.name = name;
  this.image = image;
  this.video = video;
  this.model = model;
  this.audio = audio;
  this.stage = stage;
  this.skybox = skybox;
  this.pdf = pdf;
  this.id = id;
  this.contract = contract;
  this.link = link;
  this.owner = owner;
  this.author = author;
  this.collection = collection;
  this.mint = mint;
  this.edition_size = edition_size;
};

function parseIpfs(imageUrl) {
  if (!imageUrl) {
    return imageUrl;
  }

  if (imageUrl.substring(0, 2) === 'Qm') {
    imageUrl = "https://cloudflare-ipfs.com/ipfs/" + imageUrl;
  }

  return imageUrl;
}

function parseSaNft(nft) {
  var name = nft.idata && nft.idata.name || nft.mdata && nft.mdata.name;
  var imageUrl = parseIpfs(nft.idata && (nft.idata.img || nft.idata.image) || nft.mdata && (nft.mdata.img || nft.mdata.img));
  var videoUrl = parseIpfs(nft.idata && nft.idata.video || nft.mdata && nft.mdata.video);
  var audioUrl = parseIpfs(nft.idata && nft.idata.audio || nft.mdata && nft.mdata.audio);
  var modelUrl = parseIpfs(nft.idata && nft.idata.model || nft.mdata && nft.mdata.model);
  var stageUrl = parseIpfs(nft.idata && nft.idata.stage || nft.mdata && nft.mdata.stage);
  var pdfUrl = parseIpfs(nft.idata && nft.idata.pdf || nft.mdata && nft.mdata.pdf);
  var skyboxUrl = parseIpfs(nft.idata && nft.idata.skybox || nft.mdata && nft.mdata.skybox);
  var nftObj = new Nft({
    idata: nft.idata,
    mdata: nft.mdata,
    name: name,
    image: imageUrl,
    video: videoUrl,
    model: modelUrl,
    audio: audioUrl,
    stage: stageUrl,
    skybox: skyboxUrl,
    pdf: pdfUrl,
    id: nft.assetId,
    contract: 'simpleassets',
    link: "/nft/" + nft.assetId,
    owner: nft.owner,
    author: nft.author,
    mint: nft.extra && nft.extra.mintNumber,
    collection: nft.category,
    edition_size: nft.extra && nft.extra.totalMinted
  });
  return nftObj;
}
function parseAaNft(nft) {
  var imageUrl = parseIpfs(nft.data.img || nft.data.image);
  var videoUrl = parseIpfs(nft.data.video);
  var audioUrl = parseIpfs(nft.data.audio);
  var modelUrl = parseIpfs(nft.data.model);
  var stageUrl = parseIpfs(nft.data.stage);
  var skyboxUrl = parseIpfs(nft.data.skybox);
  var pdfUrl = parseIpfs(nft.data.pdf);
  var idata = nft.immutable_data;

  if (nft.template && nft.template.immutable_data) {
    idata = _extends({}, idata, nft.template.immutable_data);
  }

  var nftObj = new Nft({
    idata: idata,
    mdata: nft.mutable_data,
    name: nft.name || nft.data.name || nft.asset_id,
    image: imageUrl,
    video: videoUrl,
    model: modelUrl,
    audio: audioUrl,
    stage: stageUrl,
    skybox: skyboxUrl,
    pdf: pdfUrl,
    id: nft.asset_id,
    contract: 'atomicassets',
    link: "/nft/" + nft.asset_id,
    owner: nft.owner,
    author: nft.collection.author,
    collection: nft.collection.collection_name,
    mint: nft.template_mint ? +nft.template_mint : undefined,
    edition_size: nft.template ? +nft.template.max_supply || +nft.template.issued_supply : undefined
  });
  return nftObj;
}

function wait(_x) {
  return _wait.apply(this, arguments);
}

function _wait() {
  _wait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ms) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new Promise(function (resolve) {
              setTimeout(resolve, ms);
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _wait.apply(this, arguments);
}

/**
 * Native
 */
var DbopOp;

(function (DbopOp) {
  DbopOp["Ins"] = "INS";
  DbopOp["Rem"] = "REM";
  DbopOp["Upd"] = "UPD";
})(DbopOp || (DbopOp = {}));


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./node_modules/@jafri/numbro/dist/numbro.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jafri/numbro/dist/numbro.min.js ***!
  \*******************************************************/
/***/ ((module) => {

!function(e){if(true)module.exports=e();else {}}(function(){return function a(o,u,c){function s(t,e){if(!u[t]){if(!o[t]){var r=undefined;if(!e&&r)return require(t,!0);if(l)return l(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=u[t]={exports:{}};o[t][0].call(i.exports,function(e){return s(o[t][1][e]||e)},i,i.exports,a,o,u,c)}return u[t].exports}for(var l=undefined,e=0;e<c.length;e++)s(c[e]);return s}({1:[function(e,r,t){!function(e){"use strict";var t,C=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,T=Math.ceil,U=Math.floor,R="[BigNumber Error] ",I=R+"Number primitive has more than 15 significant digits: ",$=1e14,G=14,V=9007199254740991,q=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],Z=1e7,z=1e9;function W(e){var t=0|e;return 0<e||e===t?t:t-1}function H(e){for(var t,r,n=1,i=e.length,a=e[0]+"";n<i;){for(t=e[n++]+"",r=G-t.length;r--;t="0"+t);a+=t}for(i=a.length;48===a.charCodeAt(--i););return a.slice(0,i+1||1)}function Y(e,t){var r,n,i=e.c,a=t.c,o=e.s,u=t.s,c=e.e,s=t.e;if(!o||!u)return null;if(r=i&&!i[0],n=a&&!a[0],r||n)return r?n?0:-u:o;if(o!=u)return o;if(r=o<0,n=c==s,!i||!a)return n?0:!i^r?1:-1;if(!n)return s<c^r?1:-1;for(u=(c=i.length)<(s=a.length)?c:s,o=0;o<u;o++)if(i[o]!=a[o])return i[o]>a[o]^r?1:-1;return c==s?0:s<c^r?1:-1}function K(e,t,r,n){if(e<t||r<e||e!==U(e))throw Error(R+(n||"Argument")+("number"==typeof e?e<t||r<e?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function J(e){var t=e.c.length-1;return W(e.e/G)==t&&e.c[t]%2!=0}function X(e,t){return(1<e.length?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function Q(e,t,r){var n,i;if(t<0){for(i=r+".";++t;i+=r);e=i+e}else if(++t>(n=e.length)){for(i=r,t-=n;--t;i+=r);e+=i}else t<n&&(e=e.slice(0,t)+"."+e.slice(t));return e}(t=function e(t){var v,f,p,r,s,m,o,u,c,l,g,n=A.prototype={constructor:A,toString:null,valueOf:null},h=new A(1),y=20,b=4,d=-7,w=21,S=-1e7,x=1e7,O=!1,a=1,N=0,B={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:" ",suffix:""},M="0123456789abcdefghijklmnopqrstuvwxyz";function A(e,t){var r,n,i,a,o,u,c,s,l=this;if(!(l instanceof A))return new A(e,t);if(null==t){if(e&&!0===e._isBigNumber)return l.s=e.s,void(!e.c||e.e>x?l.c=l.e=null:e.e<S?l.c=[l.e=0]:(l.e=e.e,l.c=e.c.slice()));if((u="number"==typeof e)&&0*e==0){if(l.s=1/e<0?(e=-e,-1):1,e===~~e){for(a=0,o=e;10<=o;o/=10,a++);return void(x<a?l.c=l.e=null:(l.e=a,l.c=[e]))}s=String(e)}else{if(!C.test(s=String(e)))return p(l,s,u);l.s=45==s.charCodeAt(0)?(s=s.slice(1),-1):1}-1<(a=s.indexOf("."))&&(s=s.replace(".","")),0<(o=s.search(/e/i))?(a<0&&(a=o),a+=+s.slice(o+1),s=s.substring(0,o)):a<0&&(a=s.length)}else{if(K(t,2,M.length,"Base"),10==t)return P(l=new A(e),y+l.e+1,b);if(s=String(e),u="number"==typeof e){if(0*e!=0)return p(l,s,u,t);if(l.s=1/e<0?(s=s.slice(1),-1):1,A.DEBUG&&15<s.replace(/^0\.0*|\./,"").length)throw Error(I+e)}else l.s=45===s.charCodeAt(0)?(s=s.slice(1),-1):1;for(r=M.slice(0,t),a=o=0,c=s.length;o<c;o++)if(r.indexOf(n=s.charAt(o))<0){if("."==n){if(a<o){a=c;continue}}else if(!i&&(s==s.toUpperCase()&&(s=s.toLowerCase())||s==s.toLowerCase()&&(s=s.toUpperCase()))){i=!0,o=-1,a=0;continue}return p(l,String(e),u,t)}u=!1,-1<(a=(s=f(s,t,10,l.s)).indexOf("."))?s=s.replace(".",""):a=s.length}for(o=0;48===s.charCodeAt(o);o++);for(c=s.length;48===s.charCodeAt(--c););if(s=s.slice(o,++c)){if(c-=o,u&&A.DEBUG&&15<c&&(V<e||e!==U(e)))throw Error(I+l.s*e);if((a=a-o-1)>x)l.c=l.e=null;else if(a<S)l.c=[l.e=0];else{if(l.e=a,l.c=[],o=(a+1)%G,a<0&&(o+=G),o<c){for(o&&l.c.push(+s.slice(0,o)),c-=G;o<c;)l.c.push(+s.slice(o,o+=G));o=G-(s=s.slice(o)).length}else o-=c;for(;o--;s+="0");l.c.push(+s)}}else l.c=[l.e=0]}function D(e,t,r,n){for(var i,a,o=[0],u=0,c=e.length;u<c;){for(a=o.length;a--;o[a]*=t);for(o[0]+=n.indexOf(e.charAt(u++)),i=0;i<o.length;i++)o[i]>r-1&&(null==o[i+1]&&(o[i+1]=0),o[i+1]+=o[i]/r|0,o[i]%=r)}return o.reverse()}function E(e,t,r){var n,i,a,o,u=0,c=e.length,s=t%Z,l=t/Z|0;for(e=e.slice();c--;)u=((i=s*(a=e[c]%Z)+(n=l*a+(o=e[c]/Z|0)*s)%Z*Z+u)/r|0)+(n/Z|0)+l*o,e[c]=i%r;return u&&(e=[u].concat(e)),e}function F(e,t,r,n){var i,a;if(r!=n)a=n<r?1:-1;else for(i=a=0;i<r;i++)if(e[i]!=t[i]){a=e[i]>t[i]?1:-1;break}return a}function k(e,t,r,n){for(var i=0;r--;)e[r]-=i,i=e[r]<t[r]?1:0,e[r]=i*n+e[r]-t[r];for(;!e[0]&&1<e.length;e.splice(0,1));}function i(e,t,r,n){var i,a,o,u,c;if(null==r?r=b:K(r,0,8),!e.c)return e.toString();if(i=e.c[0],o=e.e,null==t)c=H(e.c),c=1==n||2==n&&(o<=d||w<=o)?X(c,o):Q(c,o,"0");else if(a=(e=P(new A(e),t,r)).e,u=(c=H(e.c)).length,1==n||2==n&&(t<=a||a<=d)){for(;u<t;c+="0",u++);c=X(c,a)}else if(t-=o,c=Q(c,a,"0"),u<a+1){if(0<--t)for(c+=".";t--;c+="0");}else if(0<(t+=a-u))for(a+1==u&&(c+=".");t--;c+="0");return e.s<0&&i?"-"+c:c}function _(e,t){for(var r,n=1,i=new A(e[0]);n<e.length;n++){if(!(r=new A(e[n])).s){i=r;break}t.call(i,r)&&(i=r)}return i}function L(e,t,r){for(var n=1,i=t.length;!t[--i];t.pop());for(i=t[0];10<=i;i/=10,n++);return(r=n+r*G-1)>x?e.c=e.e=null:r<S?e.c=[e.e=0]:(e.e=r,e.c=t),e}function P(e,t,r,n){var i,a,o,u,c,s,l,f=e.c,p=q;if(f){e:{for(i=1,u=f[0];10<=u;u/=10,i++);if((a=t-i)<0)a+=G,o=t,l=(c=f[s=0])/p[i-o-1]%10|0;else if((s=T((a+1)/G))>=f.length){if(!n)break e;for(;f.length<=s;f.push(0));c=l=0,o=(a%=G)-G+(i=1)}else{for(c=u=f[s],i=1;10<=u;u/=10,i++);l=(o=(a%=G)-G+i)<0?0:c/p[i-o-1]%10|0}if(n=n||t<0||null!=f[s+1]||(o<0?c:c%p[i-o-1]),n=r<4?(l||n)&&(0==r||r==(e.s<0?3:2)):5<l||5==l&&(4==r||n||6==r&&(0<a?0<o?c/p[i-o]:0:f[s-1])%10&1||r==(e.s<0?8:7)),t<1||!f[0])return f.length=0,n?(t-=e.e+1,f[0]=p[(G-t%G)%G],e.e=-t||0):f[0]=e.e=0,e;if(0==a?(f.length=s,u=1,s--):(f.length=s+1,u=p[G-a],f[s]=0<o?U(c/p[i-o]%p[o])*u:0),n)for(;;){if(0==s){for(a=1,o=f[0];10<=o;o/=10,a++);for(o=f[0]+=u,u=1;10<=o;o/=10,u++);a!=u&&(e.e++,f[0]==$&&(f[0]=1));break}if(f[s]+=u,f[s]!=$)break;f[s--]=0,u=1}for(a=f.length;0===f[--a];f.pop());}e.e>x?e.c=e.e=null:e.e<S&&(e.c=[e.e=0])}return e}function j(e){var t,r=e.e;return null===r?e.toString():(t=H(e.c),t=r<=d||w<=r?X(t,r):Q(t,r,"0"),e.s<0?"-"+t:t)}return A.clone=e,A.ROUND_UP=0,A.ROUND_DOWN=1,A.ROUND_CEIL=2,A.ROUND_FLOOR=3,A.ROUND_HALF_UP=4,A.ROUND_HALF_DOWN=5,A.ROUND_HALF_EVEN=6,A.ROUND_HALF_CEIL=7,A.ROUND_HALF_FLOOR=8,A.EUCLID=9,A.config=A.set=function(e){var t,r;if(null!=e){if("object"!=typeof e)throw Error(R+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(K(r=e[t],0,z,t),y=r),e.hasOwnProperty(t="ROUNDING_MODE")&&(K(r=e[t],0,8,t),b=r),e.hasOwnProperty(t="EXPONENTIAL_AT")&&((r=e[t])&&r.pop?(K(r[0],-z,0,t),K(r[1],0,z,t),d=r[0],w=r[1]):(K(r,-z,z,t),d=-(w=r<0?-r:r))),e.hasOwnProperty(t="RANGE"))if((r=e[t])&&r.pop)K(r[0],-z,-1,t),K(r[1],1,z,t),S=r[0],x=r[1];else{if(K(r,-z,z,t),!r)throw Error(R+t+" cannot be zero: "+r);S=-(x=r<0?-r:r)}if(e.hasOwnProperty(t="CRYPTO")){if((r=e[t])!==!!r)throw Error(R+t+" not true or false: "+r);if(r){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw O=!r,Error(R+"crypto unavailable");O=r}else O=r}if(e.hasOwnProperty(t="MODULO_MODE")&&(K(r=e[t],0,9,t),a=r),e.hasOwnProperty(t="POW_PRECISION")&&(K(r=e[t],0,z,t),N=r),e.hasOwnProperty(t="FORMAT")){if("object"!=typeof(r=e[t]))throw Error(R+t+" not an object: "+r);B=r}if(e.hasOwnProperty(t="ALPHABET")){if("string"!=typeof(r=e[t])||/^.?$|[+\-.\s]|(.).*\1/.test(r))throw Error(R+t+" invalid: "+r);M=r}}return{DECIMAL_PLACES:y,ROUNDING_MODE:b,EXPONENTIAL_AT:[d,w],RANGE:[S,x],CRYPTO:O,MODULO_MODE:a,POW_PRECISION:N,FORMAT:B,ALPHABET:M}},A.isBigNumber=function(e){if(!e||!0!==e._isBigNumber)return!1;if(!A.DEBUG)return!0;var t,r,n=e.c,i=e.e,a=e.s;e:if("[object Array]"=={}.toString.call(n)){if((1===a||-1===a)&&-z<=i&&i<=z&&i===U(i)){if(0===n[0]){if(0===i&&1===n.length)return!0;break e}if((t=(i+1)%G)<1&&(t+=G),String(n[0]).length==t){for(t=0;t<n.length;t++)if((r=n[t])<0||$<=r||r!==U(r))break e;if(0!==r)return!0}}}else if(null===n&&null===i&&(null===a||1===a||-1===a))return!0;throw Error(R+"Invalid BigNumber: "+e)},A.maximum=A.max=function(){return _(arguments,n.lt)},A.minimum=A.min=function(){return _(arguments,n.gt)},A.random=(r=9007199254740992,s=Math.random()*r&2097151?function(){return U(Math.random()*r)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var t,r,n,i,a,o=0,u=[],c=new A(h);if(null==e?e=y:K(e,0,z),i=T(e/G),O)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(i*=2));o<i;)9e15<=(a=131072*t[o]+(t[o+1]>>>11))?(r=crypto.getRandomValues(new Uint32Array(2)),t[o]=r[0],t[o+1]=r[1]):(u.push(a%1e14),o+=2);o=i/2}else{if(!crypto.randomBytes)throw O=!1,Error(R+"crypto unavailable");for(t=crypto.randomBytes(i*=7);o<i;)9e15<=(a=281474976710656*(31&t[o])+1099511627776*t[o+1]+4294967296*t[o+2]+16777216*t[o+3]+(t[o+4]<<16)+(t[o+5]<<8)+t[o+6])?crypto.randomBytes(7).copy(t,o):(u.push(a%1e14),o+=7);o=i/7}if(!O)for(;o<i;)(a=s())<9e15&&(u[o++]=a%1e14);for(i=u[--o],e%=G,i&&e&&(a=q[G-e],u[o]=U(i/a)*a);0===u[o];u.pop(),o--);if(o<0)u=[n=0];else{for(n=-1;0===u[0];u.splice(0,1),n-=G);for(o=1,a=u[0];10<=a;a/=10,o++);o<G&&(n-=G-o)}return c.e=n,c.c=u,c}),A.sum=function(){for(var e=1,t=arguments,r=new A(t[0]);e<t.length;)r=r.plus(t[e++]);return r},m="0123456789",f=function(e,t,r,n,i){var a,o,u,c,s,l,f,p,g=e.indexOf("."),d=y,h=b;for(0<=g&&(c=N,N=0,e=e.replace(".",""),l=(p=new A(t)).pow(e.length-g),N=c,p.c=D(Q(H(l.c),l.e,"0"),10,r,m),p.e=p.c.length),u=c=(f=D(e,t,r,i?(a=M,m):(a=m,M))).length;0==f[--c];f.pop());if(!f[0])return a.charAt(0);if(g<0?--u:(l.c=f,l.e=u,l.s=n,f=(l=v(l,p,d,h,r)).c,s=l.r,u=l.e),g=f[o=u+d+1],c=r/2,s=s||o<0||null!=f[o+1],s=h<4?(null!=g||s)&&(0==h||h==(l.s<0?3:2)):c<g||g==c&&(4==h||s||6==h&&1&f[o-1]||h==(l.s<0?8:7)),o<1||!f[0])e=s?Q(a.charAt(1),-d,a.charAt(0)):a.charAt(0);else{if(f.length=o,s)for(--r;++f[--o]>r;)f[o]=0,o||(++u,f=[1].concat(f));for(c=f.length;!f[--c];);for(g=0,e="";g<=c;e+=a.charAt(f[g++]));e=Q(e,u,a.charAt(0))}return e},v=function(e,t,r,n,i){var a,o,u,c,s,l,f,p,g,d,h,v,m,y,b,w,S,x=e.s==t.s?1:-1,O=e.c,N=t.c;if(!(O&&O[0]&&N&&N[0]))return new A(e.s&&t.s&&(O?!N||O[0]!=N[0]:N)?O&&0==O[0]||!N?0*x:x/0:NaN);for(g=(p=new A(x)).c=[],x=r+(o=e.e-t.e)+1,i||(i=$,o=W(e.e/G)-W(t.e/G),x=x/G|0),u=0;N[u]==(O[u]||0);u++);if(N[u]>(O[u]||0)&&o--,x<0)g.push(1),c=!0;else{for(y=O.length,w=N.length,x+=2,1<(s=U(i/(N[u=0]+1)))&&(N=E(N,s,i),O=E(O,s,i),w=N.length,y=O.length),m=w,h=(d=O.slice(0,w)).length;h<w;d[h++]=0);S=N.slice(),S=[0].concat(S),b=N[0],N[1]>=i/2&&b++;do{if(s=0,(a=F(N,d,w,h))<0){if(v=d[0],w!=h&&(v=v*i+(d[1]||0)),1<(s=U(v/b)))for(i<=s&&(s=i-1),f=(l=E(N,s,i)).length,h=d.length;1==F(l,d,f,h);)s--,k(l,w<f?S:N,f,i),f=l.length,a=1;else 0==s&&(a=s=1),f=(l=N.slice()).length;if(f<h&&(l=[0].concat(l)),k(d,l,h,i),h=d.length,-1==a)for(;F(N,d,w,h)<1;)s++,k(d,w<h?S:N,h,i),h=d.length}else 0===a&&(s++,d=[0]);g[u++]=s,d[0]?d[h++]=O[m]||0:(d=[O[m]],h=1)}while((m++<y||null!=d[0])&&x--);c=null!=d[0],g[0]||g.splice(0,1)}if(i==$){for(u=1,x=g[0];10<=x;x/=10,u++);P(p,r+(p.e=u+o*G-1)+1,n,c)}else p.e=o,p.r=+c;return p},o=/^(-?)0([xbo])(?=\w[\w.]*$)/i,u=/^([^.]+)\.$/,c=/^\.([^.]+)$/,l=/^-?(Infinity|NaN)$/,g=/^\s*\+(?=[\w.])|^\s+|\s+$/g,p=function(e,t,r,n){var i,a=r?t:t.replace(g,"");if(l.test(a))e.s=isNaN(a)?null:a<0?-1:1;else{if(!r&&(a=a.replace(o,function(e,t,r){return i="x"==(r=r.toLowerCase())?16:"b"==r?2:8,n&&n!=i?e:t}),n&&(i=n,a=a.replace(u,"$1").replace(c,"0.$1")),t!=a))return new A(a,i);if(A.DEBUG)throw Error(R+"Not a"+(n?" base "+n:"")+" number: "+t);e.s=null}e.c=e.e=null},n.absoluteValue=n.abs=function(){var e=new A(this);return e.s<0&&(e.s=1),e},n.comparedTo=function(e,t){return Y(this,new A(e,t))},n.decimalPlaces=n.dp=function(e,t){var r,n,i;if(null!=e)return K(e,0,z),null==t?t=b:K(t,0,8),P(new A(this),e+this.e+1,t);if(!(r=this.c))return null;if(n=((i=r.length-1)-W(this.e/G))*G,i=r[i])for(;i%10==0;i/=10,n--);return n<0&&(n=0),n},n.dividedBy=n.div=function(e,t){return v(this,new A(e,t),y,b)},n.dividedToIntegerBy=n.idiv=function(e,t){return v(this,new A(e,t),0,1)},n.exponentiatedBy=n.pow=function(e,t){var r,n,i,a,o,u,c,s,l=this;if((e=new A(e)).c&&!e.isInteger())throw Error(R+"Exponent not an integer: "+j(e));if(null!=t&&(t=new A(t)),o=14<e.e,!l.c||!l.c[0]||1==l.c[0]&&!l.e&&1==l.c.length||!e.c||!e.c[0])return s=new A(Math.pow(+j(l),o?2-J(e):+j(e))),t?s.mod(t):s;if(u=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new A(NaN);(n=!u&&l.isInteger()&&t.isInteger())&&(l=l.mod(t))}else{if(9<e.e&&(0<l.e||l.e<-1||(0==l.e?1<l.c[0]||o&&24e7<=l.c[1]:l.c[0]<8e13||o&&l.c[0]<=9999975e7)))return a=l.s<0&&J(e)?-0:0,-1<l.e&&(a=1/a),new A(u?1/a:a);N&&(a=T(N/G+2))}for(c=o?(r=new A(.5),u&&(e.s=1),J(e)):(i=Math.abs(+j(e)))%2,s=new A(h);;){if(c){if(!(s=s.times(l)).c)break;a?s.c.length>a&&(s.c.length=a):n&&(s=s.mod(t))}if(i){if(0===(i=U(i/2)))break;c=i%2}else if(P(e=e.times(r),e.e+1,1),14<e.e)c=J(e);else{if(0==(i=+j(e)))break;c=i%2}l=l.times(l),a?l.c&&l.c.length>a&&(l.c.length=a):n&&(l=l.mod(t))}return n?s:(u&&(s=h.div(s)),t?s.mod(t):a?P(s,N,b,void 0):s)},n.integerValue=function(e){var t=new A(this);return null==e?e=b:K(e,0,8),P(t,t.e+1,e)},n.isEqualTo=n.eq=function(e,t){return 0===Y(this,new A(e,t))},n.isFinite=function(){return!!this.c},n.isGreaterThan=n.gt=function(e,t){return 0<Y(this,new A(e,t))},n.isGreaterThanOrEqualTo=n.gte=function(e,t){return 1===(t=Y(this,new A(e,t)))||0===t},n.isInteger=function(){return!!this.c&&W(this.e/G)>this.c.length-2},n.isLessThan=n.lt=function(e,t){return Y(this,new A(e,t))<0},n.isLessThanOrEqualTo=n.lte=function(e,t){return-1===(t=Y(this,new A(e,t)))||0===t},n.isNaN=function(){return!this.s},n.isNegative=function(){return this.s<0},n.isPositive=function(){return 0<this.s},n.isZero=function(){return!!this.c&&0==this.c[0]},n.minus=function(e,t){var r,n,i,a,o=this,u=o.s;if(t=(e=new A(e,t)).s,!u||!t)return new A(NaN);if(u!=t)return e.s=-t,o.plus(e);var c=o.e/G,s=e.e/G,l=o.c,f=e.c;if(!c||!s){if(!l||!f)return l?(e.s=-t,e):new A(f?o:NaN);if(!l[0]||!f[0])return f[0]?(e.s=-t,e):new A(l[0]?o:3==b?-0:0)}if(c=W(c),s=W(s),l=l.slice(),u=c-s){for((i=(a=u<0)?(u=-u,l):(s=c,f)).reverse(),t=u;t--;i.push(0));i.reverse()}else for(n=(a=(u=l.length)<(t=f.length))?u:t,u=t=0;t<n;t++)if(l[t]!=f[t]){a=l[t]<f[t];break}if(a&&(i=l,l=f,f=i,e.s=-e.s),0<(t=(n=f.length)-(r=l.length)))for(;t--;l[r++]=0);for(t=$-1;u<n;){if(l[--n]<f[n]){for(r=n;r&&!l[--r];l[r]=t);--l[r],l[n]+=$}l[n]-=f[n]}for(;0==l[0];l.splice(0,1),--s);return l[0]?L(e,l,s):(e.s=3==b?-1:1,e.c=[e.e=0],e)},n.modulo=n.mod=function(e,t){var r,n,i=this;return e=new A(e,t),!i.c||!e.s||e.c&&!e.c[0]?new A(NaN):!e.c||i.c&&!i.c[0]?new A(i):(9==a?(n=e.s,e.s=1,r=v(i,e,0,3),e.s=n,r.s*=n):r=v(i,e,0,a),(e=i.minus(r.times(e))).c[0]||1!=a||(e.s=i.s),e)},n.multipliedBy=n.times=function(e,t){var r,n,i,a,o,u,c,s,l,f,p,g,d,h,v,m=this,y=m.c,b=(e=new A(e,t)).c;if(!(y&&b&&y[0]&&b[0]))return!m.s||!e.s||y&&!y[0]&&!b||b&&!b[0]&&!y?e.c=e.e=e.s=null:(e.s*=m.s,y&&b?(e.c=[0],e.e=0):e.c=e.e=null),e;for(n=W(m.e/G)+W(e.e/G),e.s*=m.s,(c=y.length)<(f=b.length)&&(d=y,y=b,b=d,i=c,c=f,f=i),i=c+f,d=[];i--;d.push(0));for(h=$,v=Z,i=f;0<=--i;){for(r=0,p=b[i]%v,g=b[i]/v|0,a=i+(o=c);i<a;)r=((s=p*(s=y[--o]%v)+(u=g*s+(l=y[o]/v|0)*p)%v*v+d[a]+r)/h|0)+(u/v|0)+g*l,d[a--]=s%h;d[a]=r}return r?++n:d.splice(0,1),L(e,d,n)},n.negated=function(){var e=new A(this);return e.s=-e.s||null,e},n.plus=function(e,t){var r,n=this,i=n.s;if(t=(e=new A(e,t)).s,!i||!t)return new A(NaN);if(i!=t)return e.s=-t,n.minus(e);var a=n.e/G,o=e.e/G,u=n.c,c=e.c;if(!a||!o){if(!u||!c)return new A(i/0);if(!u[0]||!c[0])return c[0]?e:new A(u[0]?n:0*i)}if(a=W(a),o=W(o),u=u.slice(),i=a-o){for((r=0<i?(o=a,c):(i=-i,u)).reverse();i--;r.push(0));r.reverse()}for((i=u.length)-(t=c.length)<0&&(r=c,c=u,u=r,t=i),i=0;t;)i=(u[--t]=u[t]+c[t]+i)/$|0,u[t]=$===u[t]?0:u[t]%$;return i&&(u=[i].concat(u),++o),L(e,u,o)},n.precision=n.sd=function(e,t){var r,n,i;if(null!=e&&e!==!!e)return K(e,1,z),null==t?t=b:K(t,0,8),P(new A(this),e,t);if(!(r=this.c))return null;if(n=(i=r.length-1)*G+1,i=r[i]){for(;i%10==0;i/=10,n--);for(i=r[0];10<=i;i/=10,n++);}return e&&this.e+1>n&&(n=this.e+1),n},n.shiftedBy=function(e){return K(e,-V,V),this.times("1e"+e)},n.squareRoot=n.sqrt=function(){var e,t,r,n,i,a=this,o=a.c,u=a.s,c=a.e,s=y+4,l=new A("0.5");if(1!==u||!o||!o[0])return new A(!u||u<0&&(!o||o[0])?NaN:o?a:1/0);if((r=0==(u=Math.sqrt(+j(a)))||u==1/0?(((t=H(o)).length+c)%2==0&&(t+="0"),u=Math.sqrt(+t),c=W((c+1)/2)-(c<0||c%2),new A(t=u==1/0?"5e"+c:(t=u.toExponential()).slice(0,t.indexOf("e")+1)+c)):new A(u+"")).c[0])for((u=(c=r.e)+s)<3&&(u=0);;)if(i=r,r=l.times(i.plus(v(a,i,s,1))),H(i.c).slice(0,u)===(t=H(r.c)).slice(0,u)){if(r.e<c&&--u,"9999"!=(t=t.slice(u-3,u+1))&&(n||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(P(r,r.e+y+2,1),e=!r.times(r).eq(a));break}if(!n&&(P(i,i.e+y+2,0),i.times(i).eq(a))){r=i;break}s+=4,u+=4,n=1}return P(r,r.e+y+1,b,e)},n.toExponential=function(e,t){return null!=e&&(K(e,0,z),e++),i(this,e,t,1)},n.toFixed=function(e,t){return null!=e&&(K(e,0,z),e=e+this.e+1),i(this,e,t)},n.toFormat=function(e,t,r){var n;if(null==r)null!=e&&t&&"object"==typeof t?(r=t,t=null):e&&"object"==typeof e?(r=e,e=t=null):r=B;else if("object"!=typeof r)throw Error(R+"Argument not an object: "+r);if(n=this.toFixed(e,t),this.c){var i,a=n.split("."),o=+r.groupSize,u=+r.secondaryGroupSize,c=r.groupSeparator||"",s=a[0],l=a[1],f=this.s<0,p=f?s.slice(1):s,g=p.length;if(u&&(i=o,o=u,g-=u=i),0<o&&0<g){for(i=g%o||o,s=p.substr(0,i);i<g;i+=o)s+=c+p.substr(i,o);0<u&&(s+=c+p.slice(i)),f&&(s="-"+s)}n=l?s+(r.decimalSeparator||"")+((u=+r.fractionGroupSize)?l.replace(new RegExp("\\d{"+u+"}\\B","g"),"$&"+(r.fractionGroupSeparator||"")):l):s}return(r.prefix||"")+n+(r.suffix||"")},n.toFraction=function(e){var t,r,n,i,a,o,u,c,s,l,f,p,g=this,d=g.c;if(null!=e&&(!(u=new A(e)).isInteger()&&(u.c||1!==u.s)||u.lt(h)))throw Error(R+"Argument "+(u.isInteger()?"out of range: ":"not an integer: ")+j(u));if(!d)return new A(g);for(t=new A(h),s=r=new A(h),n=c=new A(h),p=H(d),a=t.e=p.length-g.e-1,t.c[0]=q[(o=a%G)<0?G+o:o],e=!e||0<u.comparedTo(t)?0<a?t:s:u,o=x,x=1/0,u=new A(p),c.c[0]=0;l=v(u,t,0,1),1!=(i=r.plus(l.times(n))).comparedTo(e);)r=n,n=i,s=c.plus(l.times(i=s)),c=i,t=u.minus(l.times(i=t)),u=i;return i=v(e.minus(r),n,0,1),c=c.plus(i.times(s)),r=r.plus(i.times(n)),c.s=s.s=g.s,f=v(s,n,a*=2,b).minus(g).abs().comparedTo(v(c,r,a,b).minus(g).abs())<1?[s,n]:[c,r],x=o,f},n.toNumber=function(){return+j(this)},n.toPrecision=function(e,t){return null!=e&&K(e,1,z),i(this,e,t,2)},n.toString=function(e){var t,r=this,n=r.s,i=r.e;return null===i?n?(t="Infinity",n<0&&(t="-"+t)):t="NaN":(t=null==e?i<=d||w<=i?X(H(r.c),i):Q(H(r.c),i,"0"):10===e?Q(H((r=P(new A(r),y+i+1,b)).c),r.e,"0"):(K(e,2,M.length,"Base"),f(Q(H(r.c),i,"0"),10,e,n,!0)),n<0&&r.c[0]&&(t="-"+t)),t},n.valueOf=n.toJSON=function(){return j(this)},n._isBigNumber=!0,null!=t&&A.set(t),A}()).default=t.BigNumber=t,void 0!==r&&r.exports?r.exports=t:(e=e||("undefined"!=typeof self&&self?self:window)).BigNumber=t}(this)},{}],2:[function(e,t,r){"use strict";t.exports={languageTag:"en-US",delimiters:{thousands:",",decimal:"."},abbreviations:{thousand:"k",million:"m",billion:"b",trillion:"t"},spaceSeparated:!1,ordinal:function(e){var t=e%10;return 1==~~(e%100/10)?"th":1==t?"st":2==t?"nd":3==t?"rd":"th"},bytes:{binarySuffixes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],decimalSuffixes:["B","KB","MB","GB","TB","PB","EB","ZB","YB"]},currency:{symbol:"$",position:"prefix",code:"USD"},currencyFormat:{thousandSeparated:!0,totalLength:4,spaceSeparated:!0,spaceSeparatedCurrency:!0},formats:{fourDigits:{totalLength:4,spaceSeparated:!0},fullWithTwoDecimals:{output:"currency",thousandSeparated:!0,mantissa:2},fullWithTwoDecimalsNoCurrency:{thousandSeparated:!0,mantissa:2},fullWithNoDecimals:{output:"currency",thousandSeparated:!0,mantissa:0}}}},{}],3:[function(e,t,r){"use strict";function I(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var r=[],n=!0,i=!1,a=void 0;try{for(var o,u=e[Symbol.iterator]();!(n=(o=u.next()).done)&&(r.push(o.value),!t||r.length!==t);n=!0);}catch(e){i=!0,a=e}finally{try{n||null==u.return||u.return()}finally{if(i)throw a}}return r}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var $=e("./globalState"),o=e("./validating"),u=e("./parsing"),G={trillion:Math.pow(10,12),billion:Math.pow(10,9),million:Math.pow(10,6),thousand:Math.pow(10,3)},V={totalLength:0,characteristic:0,forceAverage:!1,average:!1,mantissa:-1,optionalMantissa:!0,thousandSeparated:!1,spaceSeparated:!1,negative:"sign",forceSign:!1,roundingFunction:Math.round,spaceSeparatedAbbreviation:!1},n=$.currentBytes(),d=n.binarySuffixes,h=n.decimalSuffixes,i={general:{scale:1024,suffixes:h,marker:"bd"},binary:{scale:1024,suffixes:d,marker:"b"},decimal:{scale:1e3,suffixes:h,marker:"d"}};function a(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=2<arguments.length?arguments[2]:void 0;if("string"==typeof t&&(t=u.parseFormat(t)),!o.validateFormat(t))return"ERROR: invalid format";var n=t.prefix||"",i=t.postfix||"",a=function(e,t,r){switch(t.output){case"currency":return t=c(t,$.currentCurrencyDefaultFormat()),function(e,t,r){var n=r.currentCurrency(),i=Object.assign({},V,t),a=void 0,o="",u=!!i.totalLength||!!i.forceAverage||i.average,c=t.currencyPosition||n.position,s=t.currencySymbol||n.symbol,l=void 0!==i.spaceSeparatedCurrency?i.spaceSeparatedCurrency:i.spaceSeparated;void 0===t.lowPrecision&&(t.lowPrecision=!1);l&&(o=" ");"infix"===c&&(a=o+s+o);var f=m({instance:e,providedFormat:t,state:r,decimalSeparator:a});"prefix"===c&&(f=e._value<0&&"sign"===i.negative?"-".concat(o).concat(s).concat(f.slice(1)):0<e._value&&i.forceSign?"+".concat(o).concat(s).concat(f.slice(1)):s+o+f);c&&"postfix"!==c||(o=!i.spaceSeparatedAbbreviation&&u?"":o,f=f+o+s);return f}(e,t,$);case"percent":return t=c(t,$.currentPercentageDefaultFormat()),function(e,t,r,n){var i=t.prefixSymbol,a=m({instance:n(100*e._value),providedFormat:t,state:r}),o=Object.assign({},V,t);if(i)return"%".concat(o.spaceSeparated?" ":"").concat(a);return"".concat(a).concat(o.spaceSeparated?" ":"","%")}(e,t,$,r);case"byte":return t=c(t,$.currentByteDefaultFormat()),function(e,t,r,n){var i=t.base||"binary",a=Object.assign({},V,t),o=r.currentBytes(),u=o.binarySuffixes,c=o.decimalSuffixes,s={general:{scale:1024,suffixes:c||h,marker:"bd"},binary:{scale:1024,suffixes:u||d,marker:"b"},decimal:{scale:1e3,suffixes:c||h,marker:"d"}}[i],l=v(e._value,s.suffixes,s.scale),f=l.value,p=l.suffix,g=m({instance:n(f),providedFormat:t,state:r,defaults:r.currentByteDefaultFormat()});return"".concat(g).concat(a.spaceSeparated?" ":"").concat(p)}(e,t,$,r);case"time":return t=c(t,$.currentTimeDefaultFormat()),function(e){var t=Math.floor(e._value/60/60),r=Math.floor((e._value-60*t*60)/60),n=Math.round(e._value-60*t*60-60*r);return"".concat(t,":").concat(r<10?"0":"").concat(r,":").concat(n<10?"0":"").concat(n)}(e);case"ordinal":return t=c(t,$.currentOrdinalDefaultFormat()),function(e,t,r){var n=r.currentOrdinal(),i=Object.assign({},V,t),a=m({instance:e,providedFormat:t,state:r}),o=n(e._value);return"".concat(a).concat(i.spaceSeparated?" ":"").concat(o)}(e,t,$);case"number":default:return m({instance:e,providedFormat:t,numbro:r})}}(e,t,r);return a=(a=n+a)+i}function v(e,t,r){var n=t[0],i=Math.abs(e);if(r<=i){for(var a=1;a<t.length;++a){var o=Math.pow(r,a),u=Math.pow(r,a+1);if(o<=i&&i<u){n=t[a],e/=o;break}}n===t[0]&&(e/=Math.pow(r,t.length-1),n=t[t.length-1])}return{value:e,suffix:n}}function p(e){for(var t="",r=0;r<e;r++)t+="0";return t}function q(e,t,r){var n=2<arguments.length&&void 0!==r?r:Math.round;return-1!==e.toString().indexOf("e")?function(e,t){var r=e.toString(),n=I(r.split("e"),2),i=n[0],a=n[1],o=I(i.split("."),2),u=o[0],c=o[1],s=void 0===c?"":c;if(0<+a)r=u+s+p(a-s.length);else{var l=".";l=+u<0?"-0".concat(l):"0".concat(l);var f=(p(-a-1)+Math.abs(u)+s).substr(0,t);f.length<t&&(f+=p(t-f.length)),r=l+f}return 0<+a&&0<t&&(r+=".".concat(p(t))),r}(e,t):(n(+"".concat(e,"e+").concat(t))/Math.pow(10,t)).toFixed(t)}function Z(e,t,r,n,i){var a=n.currentDelimiters(),o=a.thousands;i=i||a.decimal;var u=a.thousandsSize||3,c=e.toString(),s=c.split(".")[0],l=c.split(".")[1],f=t<0&&0===s.indexOf("-");r&&(f&&(s=s.slice(1)),function(e,t){for(var r=[],n=0,i=e;0<i;i--)n===t&&(r.unshift(i),n=0),n++;return r}(s.length,u).forEach(function(e,t){s=s.slice(0,e+t)+o+s.slice(e+t)}),f&&(s="-".concat(s)));return c=l?s+i+l:s}function m(e){var t=e.instance,r=e.providedFormat,n=e.state,i=void 0===n?$:n,a=e.decimalSeparator,o=e.defaults,u=void 0===o?i.currentDefaults():o,c=t._value;if(0===c&&i.hasZeroFormat())return i.getZeroFormat();if(!isFinite(c))return c.toString();var s,l,f,p,g,d,h,v,m=Object.assign({},V,u,r),y=m.totalLength,b=y?0:m.characteristic,w=m.optionalCharacteristic,S=m.forceAverage,x=m.lowPrecision,O=!!y||!!S||m.average,N=y?-1:O&&void 0===r.mantissa?0:m.mantissa,B=!y&&(void 0===r.optionalMantissa?-1===N:m.optionalMantissa),M=m.trimMantissa,A=m.thousandSeparated,D=m.spaceSeparated,E=m.negative,F=m.forceSign,k=m.exponential,_=m.roundingFunction,L="";if(O){var P=function(e){var t=e.value,r=e.forceAverage,n=e.lowPrecision,i=void 0===n||n,a=e.abbreviations,o=e.spaceSeparated,u=void 0!==o&&o,c=e.totalLength,s=void 0===c?0:c,l=e.roundingFunction,f=void 0===l?Math.round:l,p="",g=Math.abs(t),d=-1;if(r&&a[r]&&G[r]?(p=a[r],t/=G[r]):g>=G.trillion||i&&1===f(g/G.trillion)?(p=a.trillion,t/=G.trillion):g<G.trillion&&g>=G.billion||i&&1===f(g/G.billion)?(p=a.billion,t/=G.billion):g<G.billion&&g>=G.million||i&&1===f(g/G.million)?(p=a.million,t/=G.million):(g<G.million&&g>=G.thousand||i&&1===f(g/G.thousand))&&(p=a.thousand,t/=G.thousand),p=p&&(u?" ":"")+p,s){var h=t<0,v=t.toString().split(".")[0],m=h?v.length-1:v.length;d=Math.max(s-m,0)}return{value:t,abbreviation:p,mantissaPrecision:d}}({value:c,forceAverage:S,lowPrecision:x,abbreviations:i.currentAbbreviations(),spaceSeparated:D,roundingFunction:_,totalLength:y});c=P.value,L+=P.abbreviation,y&&(N=P.mantissaPrecision)}if(k){var j=(l=(s={value:c,characteristicPrecision:b}).value,f=s.characteristicPrecision,p=void 0===f?0:f,g=I(l.toExponential().split("e"),2),d=g[0],h=g[1],v=+d,p&&1<p&&(v*=Math.pow(10,p-1),h=0<=(h-=p-1)?"+".concat(h):h),{value:v,abbreviation:"e".concat(h)});c=j.value,L=j.abbreviation+L}var C,T,U,R=function(e,t,r,n,i,a){if(-1===n)return e;var o=q(t,n,a),u=I(o.toString().split("."),2),c=u[0],s=u[1],l=void 0===s?"":s;if(l.match(/^0+$/)&&(r||i))return c;var f=l.match(/0+$/);return i&&f?"".concat(c,".").concat(l.toString().slice(0,f.index)):o.toString()}(c.toString(),c,B,N,M,_);return R=Z(R=function(e,t,r,n){var i=e,a=I(i.toString().split("."),2),o=a[0],u=a[1];if(o.match(/^-?0$/)&&r)return u?"".concat(o.replace("0",""),".").concat(u):o.replace("0","");var c=t<0&&0===o.indexOf("-");if(c&&(o=o.slice(1),i=i.slice(1)),o.length<n)for(var s=n-o.length,l=0;l<s;l++)i="0".concat(i);return c&&(i="-".concat(i)),i.toString()}(R,c,w,b),c,A,i,a),(O||k)&&(R=R+L),(F||c<0)&&(C=R,U=E,R=0===(T=c)?C:0==+C?C.replace("-",""):0<T?"+".concat(C):"sign"===U?C:"(".concat(C.replace("-",""),")")),R}function c(e,t){if(!e)return t;var r=Object.keys(e);return 1===r.length&&"output"===r[0]?t:e}t.exports=function(n){return{format:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return a.apply(void 0,t.concat([n]))},getByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=i.general;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getBinaryByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=i.binary;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getDecimalByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=i.decimal;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},formatOrDefault:c}}},{"./globalState":4,"./parsing":8,"./validating":10}],4:[function(e,t,r){"use strict";var i=e("./en-US"),n=e("./validating"),a=e("./parsing"),o={},u=void 0,c={},s=null,l={};function f(e){u=e}function p(){return c[u]}o.languages=function(){return Object.assign({},c)},o.currentLanguage=function(){return u},o.currentBytes=function(){return p().bytes||{}},o.currentCurrency=function(){return p().currency},o.currentAbbreviations=function(){return p().abbreviations},o.currentDelimiters=function(){return p().delimiters},o.currentOrdinal=function(){return p().ordinal},o.currentDefaults=function(){return Object.assign({},p().defaults,l)},o.currentOrdinalDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().ordinalFormat)},o.currentByteDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().byteFormat)},o.currentPercentageDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().percentageFormat)},o.currentCurrencyDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().currencyFormat)},o.currentTimeDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().timeFormat)},o.setDefaults=function(e){e=a.parseFormat(e),n.validateFormat(e)&&(l=e)},o.getZeroFormat=function(){return s},o.setZeroFormat=function(e){return s="string"==typeof e?e:null},o.hasZeroFormat=function(){return null!==s},o.languageData=function(e){if(e){if(c[e])return c[e];throw new Error('Unknown tag "'.concat(e,'"'))}return p()},o.registerLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1];if(!n.validateLanguage(e))throw new Error("Invalid language data");c[e.languageTag]=e,t&&f(e.languageTag)},o.setLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:i.languageTag;if(!c[e]){var r=e.split("-")[0],n=Object.keys(c).find(function(e){return e.split("-")[0]===r});return c[n]?void f(n):void f(t)}f(e)},o.registerLanguage(i),u=i.languageTag,t.exports=o},{"./en-US":2,"./parsing":8,"./validating":10}],5:[function(n,e,t){"use strict";e.exports=function(t){return{loadLanguagesInNode:function(e){return r=t,void e.forEach(function(t){var e=void 0;try{e=n("../languages/".concat(t))}catch(e){console.error('Unable to load "'.concat(t,'". No matching language file found.'))}e&&r.registerLanguage(e)});var r}}}},{}],6:[function(e,t,r){"use strict";var c=e("bignumber.js");function a(e,t,r){var n=new c(e._value),i=t;return r.isNumbro(t)&&(i=t._value),i=new c(i),e._value=n.minus(i).toNumber(),e}t.exports=function(u){return{add:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.plus(o).toNumber(),r;var r,n,i,a,o},subtract:function(e,t){return a(e,t,u)},multiply:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.times(o).toNumber(),r;var r,n,i,a,o},divide:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.dividedBy(o).toNumber(),r;var r,n,i,a,o},set:function(e,t){return r=e,i=n=t,u.isNumbro(n)&&(i=n._value),r._value=i,r;var r,n,i},difference:function(e,t){return r=t,a(i=(n=u)(e._value),r,n),Math.abs(i._value);var r,n,i},BigNumber:c}}},{"bignumber.js":1}],7:[function(e,t,r){"use strict";function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var a=e("./globalState"),n=e("./validating"),o=e("./loading")(g),u=e("./unformatting"),c=e("./formatting")(g),s=e("./manipulating")(g),l=e("./parsing"),f=function(){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._value=e}var e,r,n;return e=t,(r=[{key:"clone",value:function(){return g(this._value)}},{key:"format",value:function(e){var t=0<arguments.length&&void 0!==e?e:{};return c.format(this,t)}},{key:"formatCurrency",value:function(e){return"string"==typeof e&&(e=l.parseFormat(e)),(e=c.formatOrDefault(e,a.currentCurrencyDefaultFormat())).output="currency",c.format(this,e)}},{key:"formatTime",value:function(e){var t=0<arguments.length&&void 0!==e?e:{};return t.output="time",c.format(this,t)}},{key:"binaryByteUnits",value:function(){return c.getBinaryByteUnit(this)}},{key:"decimalByteUnits",value:function(){return c.getDecimalByteUnit(this)}},{key:"byteUnits",value:function(){return c.getByteUnit(this)}},{key:"difference",value:function(e){return s.difference(this,e)}},{key:"add",value:function(e){return s.add(this,e)}},{key:"subtract",value:function(e){return s.subtract(this,e)}},{key:"multiply",value:function(e){return s.multiply(this,e)}},{key:"divide",value:function(e){return s.divide(this,e)}},{key:"set",value:function(e){return s.set(this,p(e))}},{key:"value",value:function(){return this._value}},{key:"valueOf",value:function(){return this._value}}])&&i(e.prototype,r),n&&i(e,n),t}();function p(e){var t=e;return g.isNumbro(e)?t=e._value:"string"==typeof e?t=g.unformat(e):isNaN(e)&&(t=NaN),t}function g(e){return new f(p(e))}g.version="2.3.2",g.isNumbro=function(e){return e instanceof f},g.language=a.currentLanguage,g.registerLanguage=a.registerLanguage,g.setLanguage=a.setLanguage,g.languages=a.languages,g.languageData=a.languageData,g.zeroFormat=a.setZeroFormat,g.defaultFormat=a.currentDefaults,g.setDefaults=a.setDefaults,g.defaultCurrencyFormat=a.currentCurrencyDefaultFormat,g.validate=n.validate,g.loadLanguagesInNode=o.loadLanguagesInNode,g.unformat=u.unformat,g.BigNumber=s.BigNumber,t.exports=g},{"./formatting":3,"./globalState":4,"./loading":5,"./manipulating":6,"./parsing":8,"./unformatting":9,"./validating":10}],8:[function(e,t,r){"use strict";t.exports={parseFormat:function(e){var t,r,n,i,a,o,u,c,s,l,f,p,g,d,h,v,m,y,b,w,S,x,O=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return"string"!=typeof e?e:(r=O,e=(n=(t=e).match(/^{([^}]*)}/))?(r.prefix=n[1],t.slice(n[0].length)):t,a=O,function(e,t){if(-1===e.indexOf("$")){if(-1===e.indexOf("%"))return-1!==e.indexOf("bd")?(t.output="byte",t.base="general"):-1!==e.indexOf("b")?(t.output="byte",t.base="binary"):-1!==e.indexOf("d")?(t.output="byte",t.base="decimal"):-1===e.indexOf(":")?-1!==e.indexOf("o")&&(t.output="ordinal"):t.output="time";t.output="percent"}else t.output="currency"}(e=(o=(i=e).match(/{([^}]*)}$/))?(a.postfix=o[1],i.slice(0,-o[0].length)):i,O),u=O,(c=e.match(/[1-9]+[0-9]*/))&&(u.totalLength=+c[0]),s=O,(l=e.split(".")[0].match(/0+/))&&(s.characteristic=l[0].length),function(e,t){if(-1!==e.indexOf(".")){var r=e.split(".")[0];t.optionalCharacteristic=-1===r.indexOf("0")}}(e,O),f=O,-1!==e.indexOf("a")&&(f.average=!0),g=O,-1!==(p=e).indexOf("K")?g.forceAverage="thousand":-1!==p.indexOf("M")?g.forceAverage="million":-1!==p.indexOf("B")?g.forceAverage="billion":-1!==p.indexOf("T")&&(g.forceAverage="trillion"),function(e,t){var r=e.split(".")[1];if(r){var n=r.match(/0+/);n&&(t.mantissa=n[0].length)}}(e,O),h=O,(d=e).match(/\[\.]/)?h.optionalMantissa=!0:d.match(/\./)&&(h.optionalMantissa=!1),v=O,(m=e.split(".")[1])&&(v.trimMantissa=-1!==m.indexOf("[")),y=O,-1!==e.indexOf(",")&&(y.thousandSeparated=!0),b=O,-1!==e.indexOf(" ")&&(b.spaceSeparated=!0,b.spaceSeparatedCurrency=!0,(b.average||b.forceAverage)&&(b.spaceSeparatedAbbreviation=!0)),S=O,(w=e).match(/^\+?\([^)]*\)$/)&&(S.negative="parenthesis"),w.match(/^\+?-/)&&(S.negative="sign"),x=O,e.match(/^\+/)&&(x.forceSign=!0),O)}}},{}],9:[function(p,e,t){"use strict";var M=[{key:"ZiB",factor:Math.pow(1024,7)},{key:"ZB",factor:Math.pow(1e3,7)},{key:"YiB",factor:Math.pow(1024,8)},{key:"YB",factor:Math.pow(1e3,8)},{key:"TiB",factor:Math.pow(1024,4)},{key:"TB",factor:Math.pow(1e3,4)},{key:"PiB",factor:Math.pow(1024,5)},{key:"PB",factor:Math.pow(1e3,5)},{key:"MiB",factor:Math.pow(1024,2)},{key:"MB",factor:Math.pow(1e3,2)},{key:"KiB",factor:Math.pow(1024,1)},{key:"KB",factor:Math.pow(1e3,1)},{key:"GiB",factor:Math.pow(1024,3)},{key:"GB",factor:Math.pow(1e3,3)},{key:"EiB",factor:Math.pow(1024,6)},{key:"EB",factor:Math.pow(1e3,6)},{key:"B",factor:1}];function A(e){return e.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function g(e,t,r,n,i,a,o){var u=2<arguments.length&&void 0!==r?r:"",c=3<arguments.length?n:void 0,s=4<arguments.length?i:void 0,l=5<arguments.length?a:void 0,f=6<arguments.length?o:void 0;if(""!==e)return e===s?0:function e(t,r,n,i,a,o,u){var c=2<arguments.length&&void 0!==n?n:"",s=3<arguments.length?i:void 0,l=4<arguments.length?a:void 0,f=5<arguments.length?o:void 0,p=6<arguments.length?u:void 0;if(!isNaN(+t))return+t;var g="",d=t.replace(/(^[^(]*)\((.*)\)([^)]*$)/,"$1$2$3");if(d!==t)return-1*e(d,r,c,s,l,f,p);for(var h=0;h<M.length;h++){var v=M[h];if((g=t.replace(RegExp("([0-9 ])(".concat(v.key,")$")),"$1"))!==t)return e(g,r,c,s,l,f,p)*v.factor}if((g=t.replace("%",""))!==t)return e(g,r,c,s,l,f,p)/100;var m=parseFloat(t);if(!isNaN(m)){var y=s(m);if(y&&"."!==y&&(g=t.replace(new RegExp("".concat(A(y),"$")),""))!==t)return e(g,r,c,s,l,f,p);var b={};Object.keys(f).forEach(function(e){b[f[e]]=e});for(var w=Object.keys(b).sort().reverse(),S=w.length,x=0;x<S;x++){var O=w[x],N=b[O];if((g=t.replace(O,""))!==t){var B=void 0;switch(N){case"thousand":B=Math.pow(10,3);break;case"million":B=Math.pow(10,6);break;case"billion":B=Math.pow(10,9);break;case"trillion":B=Math.pow(10,12)}return e(g,r,c,s,l,f,p)*B}}}}(function(e,t,r){var n=2<arguments.length&&void 0!==r?r:"",i=e.replace(n,"");return i=(i=i.replace(new RegExp("([0-9])".concat(A(t.thousands),"([0-9])"),"g"),"$1$2")).replace(t.decimal,".")}(e,t,u),t,u,c,s,l,f)}e.exports={unformat:function(e,t){var r,n,i,a=p("./globalState"),o=a.currentDelimiters(),u=a.currentCurrency().symbol,c=a.currentOrdinal(),s=a.getZeroFormat(),l=a.currentAbbreviations(),f=void 0;if("string"==typeof e)f=function(e,t){if(e.indexOf(":")&&":"!==t.thousands){var r=e.split(":");if(3===r.length){var n=+r[0],i=+r[1],a=+r[2];return!isNaN(n)&&!isNaN(i)&&!isNaN(a)}}}(e,o)?(r=e.split(":"),n=+r[0],i=+r[1],+r[2]+60*i+3600*n):g(e,o,u,c,s,l,t);else{if("number"!=typeof e)return;f=e}if(void 0!==f)return f}}},{"./globalState":4}],10:[function(e,t,r){"use strict";function n(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function f(e){return(f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var i=e("./unformatting"),a=/^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/,p={output:{type:"string",validValues:["currency","percent","byte","time","ordinal","number"]},base:{type:"string",validValues:["decimal","binary","general"],restriction:function(e,t){return"byte"===t.output},message:"`base` must be provided only when the output is `byte`",mandatory:function(e){return"byte"===e.output}},characteristic:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},prefix:"string",postfix:"string",forceAverage:{type:"string",validValues:["trillion","billion","million","thousand"]},average:"boolean",lowPrecision:{type:"boolean",restriction:function(e,t){return!0===t.average},message:"`lowPrecision` must be provided only when the option `average` is set"},currencyPosition:{type:"string",validValues:["prefix","infix","postfix"]},currencySymbol:"string",totalLength:{type:"number",restrictions:[{restriction:function(e){return 0<=e},message:"value must be positive"},{restriction:function(e,t){return!t.exponential},message:"`totalLength` is incompatible with `exponential`"}]},mantissa:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},optionalMantissa:"boolean",trimMantissa:"boolean",roundingFunction:"function",optionalCharacteristic:"boolean",thousandSeparated:"boolean",spaceSeparated:"boolean",spaceSeparatedCurrency:"boolean",spaceSeparatedAbbreviation:"boolean",abbreviations:{type:"object",children:{thousand:"string",million:"string",billion:"string",trillion:"string"}},negative:{type:"string",validValues:["sign","parenthesis"]},forceSign:"boolean",exponential:{type:"boolean"},prefixSymbol:{type:"boolean",restriction:function(e,t){return"percent"===t.output},message:"`prefixSymbol` can be provided only when the output is `percent`"}},o={languageTag:{type:"string",mandatory:!0,restriction:function(e){return e.match(a)},message:"the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)"},delimiters:{type:"object",children:{thousands:"string",decimal:"string",thousandsSize:"number"},mandatory:!0},abbreviations:{type:"object",children:{thousand:{type:"string",mandatory:!0},million:{type:"string",mandatory:!0},billion:{type:"string",mandatory:!0},trillion:{type:"string",mandatory:!0}},mandatory:!0},spaceSeparated:"boolean",spaceSeparatedCurrency:"boolean",ordinal:{type:"function",mandatory:!0},bytes:{type:"object",children:{binarySuffixes:"object",decimalSuffixes:"object"}},currency:{type:"object",children:{symbol:"string",position:"string",code:"string"},mandatory:!0},defaults:"format",ordinalFormat:"format",byteFormat:"format",percentageFormat:"format",currencyFormat:"format",timeDefaults:"format",formats:{type:"object",children:{fourDigits:{type:"format",mandatory:!0},fullWithTwoDecimals:{type:"format",mandatory:!0},fullWithTwoDecimalsNoCurrency:{type:"format",mandatory:!0},fullWithNoDecimals:{type:"format",mandatory:!0}}}};function u(e){return void 0!==i.unformat(e)}function g(c,s,l,e){var t=3<arguments.length&&void 0!==e&&e,r=Object.keys(c).map(function(e){if(!s[e])return console.error("".concat(l," Invalid key: ").concat(e)),!1;var t=c[e],r=s[e];if("string"==typeof r&&(r={type:r}),"format"===r.type){if(!g(t,p,"[Validate ".concat(e,"]"),!0))return!1}else if(f(t)!==r.type)return console.error("".concat(l," ").concat(e,' type mismatched: "').concat(r.type,'" expected, "').concat(f(t),'" provided')),!1;if(r.restrictions&&r.restrictions.length)for(var n=r.restrictions.length,i=0;i<n;i++){var a=r.restrictions[i],o=a.restriction,u=a.message;if(!o(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(u)),!1}if(r.restriction&&!r.restriction(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(r.message)),!1;if(r.validValues&&-1===r.validValues.indexOf(t))return console.error("".concat(l," ").concat(e," invalid value: must be among ").concat(JSON.stringify(r.validValues),', "').concat(t,'" provided')),!1;if(r.children&&!g(t,r.children,"[Validate ".concat(e,"]")))return!1;return!0});return t||r.push.apply(r,n(Object.keys(s).map(function(e){var t=s[e];if("string"==typeof t&&(t={type:t}),t.mandatory){var r=t.mandatory;if("function"==typeof r&&(r=r(c)),r&&void 0===c[e])return console.error("".concat(l,' Missing mandatory key "').concat(e,'"')),!1}return!0}))),r.reduce(function(e,t){return e&&t},!0)}function c(e){return g(e,p,"[Validate format]")}t.exports={validate:function(e,t){var r=u(e),n=c(t);return r&&n},validateFormat:c,validateInput:u,validateLanguage:function(e){return g(e,o,"[Validate language]")}}},{"./unformatting":9}]},{},[7])(7)});
//# sourceMappingURL=numbro.min.js.map


/***/ }),

/***/ "./node_modules/@proton/api/dist/api.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/@proton/api/dist/api.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiClass": () => (/* binding */ ApiClass),
/* harmony export */   "KycStatus": () => (/* binding */ KycStatus)
/* harmony export */ });
/* harmony import */ var _proton_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @proton/js */ "./node_modules/@proton/js/dist/index.js");
/* harmony import */ var _bloks_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bloks/constants */ "./node_modules/@bloks/constants/dist/constants.esm.js");
/* harmony import */ var _proton_hyperion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @proton/hyperion */ "./node_modules/@proton/hyperion/dist/index.js");
/* harmony import */ var _proton_hyperion__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_proton_hyperion__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _proton_light_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @proton/light-api */ "./node_modules/@proton/light-api/dist/index.js");
/* harmony import */ var _proton_light_api__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_proton_light_api__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _bloks_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @bloks/utils */ "./node_modules/@bloks/utils/dist/utils.esm.js");
/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js");
/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js");
/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _proton_wrap_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @proton/wrap-constants */ "./node_modules/@proton/wrap-constants/dist/wrap-constants.esm.js");
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! zod */ "./node_modules/zod/lib/index.mjs");
/* harmony import */ var _bloks_numbers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @bloks/numbers */ "./node_modules/@bloks/numbers/dist/index.js");











function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function getAccount(_x) {
  return _getAccount.apply(this, arguments);
}

function _getAccount() {
  _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName) {
    var _this = this;

    var account;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_account(accountName);

          case 3:
            account = _context.sent;
            account.permissions = account.permissions.map(function (permission) {
              permission.required_auth.keys = permission.required_auth.keys.map(function (key) {
                if (key.key.indexOf(_this.constants.KEY_PREFIX) !== -1) {
                  key.key = _proton_js__WEBPACK_IMPORTED_MODULE_0__.Numeric.convertLegacyPublicKey(key.key, _this.constants.KEY_PREFIX);
                }

                return key;
              });
              return permission;
            });
            return _context.abrupt("return", account);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getAccount.apply(this, arguments);
}

function searchAccount(_x2, _x3) {
  return _searchAccount.apply(this, arguments);
}

function _searchAccount() {
  _searchAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(query, limit) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(!query || !/(^[a-zA-Z12345.]+$)/.test(query))) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt("return", []);

          case 2:
            if (!(query.indexOf('.') === 0)) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", []);

          case 4:
            _context2.prev = 4;
            query = query.trim().toLowerCase();
            _context2.next = 8;
            return this.rpc.get_table_by_scope({
              json: true,
              code: this.constants.EOSIO,
              limit: limit,
              lower_bound: query,
              table: 'userres',
              upper_bound: "" + query + (query.length < 12 ? 'z'.repeat(12 - query.length) : '')
            });

          case 8:
            _yield$this$rpc$get_t = _context2.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context2.abrupt("return", rows.map(function (row) {
              return row.scope;
            }));

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](4);
            console.log(_context2.t0);
            return _context2.abrupt("return", []);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[4, 13]]);
  }));
  return _searchAccount.apply(this, arguments);
}

function getGravatar(_x4) {
  return _getGravatar.apply(this, arguments);
}

function _getGravatar() {
  _getGravatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!(this.constants.CHAIN === 'eos')) {
              _context3.next = 7;
              break;
            }

            _context3.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.ACCOUNT_INFO,
              scope: this.constants.ACCOUNT_INFO,
              table: 'accounts',
              table_key: '',
              key_type: 'name',
              lower_bound: account,
              index_position: 1,
              limit: 1
            });

          case 3:
            result = _context3.sent;
            return _context3.abrupt("return", result.rows.length > 0 && result.rows[0].account_name === account ? result.rows[0] : undefined);

          case 7:
            return _context3.abrupt("return", undefined);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getGravatar.apply(this, arguments);
}

function getParent(_x5) {
  return _getParent.apply(this, arguments);
}

function _getParent() {
  _getParent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!this.constants.HISTORY_TYPES.includes('hyperion')) {
              _context4.next = 8;
              break;
            }

            if (!this.constants.HYPERION_URL) {
              _context4.next = 5;
              break;
            }

            return _context4.abrupt("return", this.hyperion.get_creator(account));

          case 5:
            return _context4.abrupt("return", this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'hyperion', {
              type: 'get_creator',
              account: account
            })));

          case 6:
            _context4.next = 9;
            break;

          case 8:
            return _context4.abrupt("return", null);

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getParent.apply(this, arguments);
}

function getAccountLightData(_x6) {
  return _getAccountLightData.apply(this, arguments);
}

function _getAccountLightData() {
  _getAccountLightData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(accountName) {
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (this.lightApi) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return", undefined);

          case 2:
            _context5.prev = 2;
            _context5.next = 5;
            return this.lightApi.get_account_info(accountName);

          case 5:
            return _context5.abrupt("return", _context5.sent);

          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](2);
            console.log(_context5.t0);
            return _context5.abrupt("return", undefined);

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[2, 8]]);
  }));
  return _getAccountLightData.apply(this, arguments);
}

function getActionsFromNative(_x, _x2, _x3, _x4) {
  return _getActionsFromNative.apply(this, arguments);
}

function _getActionsFromNative() {
  _getActionsFromNative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName, actionSkip, actionsPerPage, historyType) {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (historyType === void 0) {
              historyType = 'native';
            }

            console.log('Fetching actions from:', historyType);
            console.log('Fetch Params:', 'actionSkip', actionSkip, 'actionsPerPage', actionsPerPage); // Request

            _context.next = 5;
            return this.actionsRpc.history_get_actions(accountName, actionSkip, actionsPerPage);

          case 5:
            result = _context.sent;

            if (result) {
              _context.next = 8;
              break;
            }

            throw new Error('Could not retrieve actions');

          case 8:
            if (!(historyType === 'native')) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.nativeTransformGetActions)(result, this.constants));

          case 10:
            return _context.abrupt("return", []);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getActionsFromNative.apply(this, arguments);
}

function getActions(_x5, _x6, _x7) {
  return _getActions.apply(this, arguments);
}

function _getActions() {
  _getActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(accountName, historyType, _temp) {
    var _ref, _ref$actionsPerPage, actionsPerPage, _ref$actionSkip, actionSkip, _ref$sortDirection, sortDirection, _ref$dfuseCursorStack, dfuseCursorStack, tokenFilter, actionFilters, contractFilter, actionFilter, start, end, result, inputCursor;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref = _temp === void 0 ? {} : _temp, _ref$actionsPerPage = _ref.actionsPerPage, actionsPerPage = _ref$actionsPerPage === void 0 ? 100 : _ref$actionsPerPage, _ref$actionSkip = _ref.actionSkip, actionSkip = _ref$actionSkip === void 0 ? 0 : _ref$actionSkip, _ref$sortDirection = _ref.sortDirection, sortDirection = _ref$sortDirection === void 0 ? 'desc' : _ref$sortDirection, _ref$dfuseCursorStack = _ref.dfuseCursorStack, dfuseCursorStack = _ref$dfuseCursorStack === void 0 ? [] : _ref$dfuseCursorStack, tokenFilter = _ref.tokenFilter, actionFilters = _ref.actionFilters, contractFilter = _ref.contractFilter, actionFilter = _ref.actionFilter, start = _ref.start, end = _ref.end;

            if (!start) {
              start = this.constants.CHAIN_START_DATE;
            } // Fallback for history type


            console.log(this.constants.HISTORY_TYPES);

            if (!historyType && this.constants.HISTORY_TYPES.length) {
              historyType = this.constants.HISTORY_TYPES[0];
            } // Fix for firefox and IE and safari


            if (start && end) {
              start = start || this.constants.CHAIN_START_DATE ? new Date(start || this.constants.CHAIN_START_DATE).toISOString() : undefined;
              end = new Date(end || new Date()).toISOString();
            } else {
              start = undefined;
              end = undefined;
            }

            if (!(historyType === 'dfuse')) {
              _context2.next = 12;
              break;
            }

            inputCursor = dfuseCursorStack.length > 0 ? dfuseCursorStack[dfuseCursorStack.length - 1] : '';
            _context2.next = 9;
            return this.getActionsFromDfuse(accountName, {
              limit: actionsPerPage,
              cursor: inputCursor,
              direction: sortDirection,
              query: '',
              after: start,
              before: end,
              tokenFilter: tokenFilter,
              actionFilters: actionFilters,
              contractFilter: contractFilter,
              actionFilter: actionFilter
            });

          case 9:
            result = _context2.sent;
            _context2.next = 21;
            break;

          case 12:
            if (!(historyType === 'hyperion')) {
              _context2.next = 18;
              break;
            }

            _context2.next = 15;
            return this.getActionsFromHyperion(accountName, {
              skip: Math.abs(actionSkip) - 1,
              limit: actionsPerPage,
              sort: sortDirection,
              after: start,
              before: end,
              tokenFilter: tokenFilter,
              actionFilters: actionFilters,
              contractFilter: contractFilter,
              actionFilter: actionFilter
            });

          case 15:
            result = _context2.sent;
            _context2.next = 21;
            break;

          case 18:
            _context2.next = 20;
            return this.getActionsFromNative(accountName, actionSkip, -actionsPerPage, 'native');

          case 20:
            result = _context2.sent;

          case 21:
            return _context2.abrupt("return", result);

          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getActions.apply(this, arguments);
}

function getActionsFromDfuse(_x8, _x9) {
  return _getActionsFromDfuse.apply(this, arguments);
}

function _getActionsFromDfuse() {
  _getActionsFromDfuse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(accountName, _temp2) {
    var _ref2, before, after, _ref2$limit, limit, cursor, query, _ref2$direction, direction, tokenFilter, actionFilters, contractFilter, actionFilter, _ref2$type, type, q, _tokenFilter$split, tokenContract, tokenfilter, actionFiltersLocal, actionFiltersQuery, result;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _ref2 = _temp2 === void 0 ? {} : _temp2, before = _ref2.before, after = _ref2.after, _ref2$limit = _ref2.limit, limit = _ref2$limit === void 0 ? 25 : _ref2$limit, cursor = _ref2.cursor, query = _ref2.query, _ref2$direction = _ref2.direction, direction = _ref2$direction === void 0 ? 'desc' : _ref2$direction, tokenFilter = _ref2.tokenFilter, actionFilters = _ref2.actionFilters, contractFilter = _ref2.contractFilter, actionFilter = _ref2.actionFilter, _ref2$type = _ref2.type, type = _ref2$type === void 0 ? 'search_transactions_graphql' : _ref2$type;
            q = query || "(auth:" + accountName + " OR\n                    receiver:" + accountName + " OR\n                    data.to:" + accountName + " OR\n                    data.from:" + accountName + " OR\n                    data.receiver:" + accountName + ")";

            if (tokenFilter) {
              _tokenFilter$split = tokenFilter.split(' '), tokenContract = _tokenFilter$split[1];
              tokenfilter = "account:" + tokenContract;
              q = q + " " + tokenfilter;
            }

            if (actionFilters) {
              actionFiltersLocal = Object.entries(actionFilters).reduce(function (filters, _ref4) {
                var value = _ref4[1];
                return value.isActive ? filters.concat(value) : filters;
              }, []);

              if (actionFiltersLocal.length) {
                actionFiltersQuery = actionFiltersLocal.map(function (filter) {
                  return filter.dfuseQuery(accountName);
                }).join(' OR '); // Wrap around the action filters

                if (actionFiltersQuery.search('OR') !== -1) {
                  actionFiltersQuery = "(" + actionFiltersQuery + ")";
                } // Set the action filters


                q = q + " " + actionFiltersQuery;
              }

              if (contractFilter) {
                q = q + " account:" + contractFilter;
              }

              if (actionFilter) {
                q = q + " action:" + actionFilter;
              }
            }

            _context3.next = 6;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'dfuse', {
              type: type,
              q: q,
              options: Object.assign({}, {
                sort: direction,
                cursor: cursor,
                limit: limit,
                withReversible: true,
                before: before,
                after: after,
                code: 1
              })
            }));

          case 6:
            result = _context3.sent;

            if (result) {
              _context3.next = 9;
              break;
            }

            throw new Error('Could not retrieve actions');

          case 9:
            return _context3.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.dfuseTransformGetActions)(result, accountName, this.constants));

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getActionsFromDfuse.apply(this, arguments);
}

function getActionsFromHyperion(_x10, _x11) {
  return _getActionsFromHyperion.apply(this, arguments);
}

function _getActionsFromHyperion() {
  _getActionsFromHyperion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account, _temp3) {
    var _ref3, skip, limit, sort, after, before, filter, tokenFilter, actionFilters, contractFilter, actionFilter, params, result, _tokenFilter$split2, tokenContract, actionFiltersLocal, _iterator, _step, eachFilter, uniqueContracts;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _ref3 = _temp3 === void 0 ? {} : _temp3, skip = _ref3.skip, limit = _ref3.limit, sort = _ref3.sort, after = _ref3.after, before = _ref3.before, filter = _ref3.filter, tokenFilter = _ref3.tokenFilter, actionFilters = _ref3.actionFilters, contractFilter = _ref3.contractFilter, actionFilter = _ref3.actionFilter;
            // Initialize
            params = {
              filter: filter,
              skip: skip,
              limit: limit,
              sort: sort,
              after: after,
              before: before
            };
            console.log('Fetching actions from Hyperion');

            // Token filter, we would only receive undefined or *:action
            if (tokenFilter) {
              _tokenFilter$split2 = tokenFilter.split(' '), tokenContract = _tokenFilter$split2[1];

              if (params.filter) {
                params.filter = params.filter.replace('*', tokenContract);
              } else {
                params.filter = tokenContract + ":*";
              }
            }

            if (actionFilters) {
              actionFiltersLocal = Object.entries(actionFilters).reduce(function (filters, _ref5) {
                var value = _ref5[1];
                return value.isActive ? filters.concat(value) : filters;
              }, []);

              if (actionFiltersLocal.length) {
                for (_iterator = _createForOfIteratorHelperLoose(actionFiltersLocal); !(_step = _iterator()).done;) {
                  eachFilter = _step.value;
                  eachFilter.hyperionQuery(account, params);
                }

                console.log(params);
              }
            } // Actions contract filters


            if (contractFilter) {
              if (params.filter) {
                params.filter = params.filter.split(',').map(function (filter) {
                  return contractFilter + ":" + filter.split(':')[1];
                }).join(',');
              } else {
                params.filter = contractFilter + ":*";
              }
            }

            if (actionFilter) {
              if (params.filter) {
                uniqueContracts = Array.from(new Set(params.filter.split(',').map(function (filter) {
                  return filter.split(':')[0];
                })));
                params.filter = uniqueContracts.map(function (contract) {
                  return contract + ":" + actionFilter;
                }).join(',');
              } else {
                params.filter = "*:" + actionFilter;
              }
            } // If hyperion URL provided, do it client side


            if (!this.constants.HYPERION_URL) {
              _context4.next = 13;
              break;
            }

            _context4.next = 10;
            return this.hyperion.get_actions(account, Object.assign({}, params));

          case 10:
            result = _context4.sent;
            _context4.next = 16;
            break;

          case 13:
            _context4.next = 15;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'hyperion', {
              type: 'get_actions',
              account: account,
              options: Object.assign({}, params)
            }));

          case 15:
            result = _context4.sent;

          case 16:
            if (result) {
              _context4.next = 18;
              break;
            }

            throw new Error('Could not retrieve actions');

          case 18:
            return _context4.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.hyperionTransformGetActions)(result));

          case 19:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getActionsFromHyperion.apply(this, arguments);
}

function getDappStats() {
  return _getDappStats.apply(this, arguments);
}

function _getDappStats() {
  _getDappStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1,
              scope: '......2ke1.o4',
              table: 'statext'
            });

          case 3:
            result = _context.sent;

            if (!(!result || !result.rows || !result.rows.length)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", {});

          case 8:
            return _context.abrupt("return", result.rows[0]);

          case 9:
            _context.next = 15;
            break;

          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", {});

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 11]]);
  }));
  return _getDappStats.apply(this, arguments);
}

function getDspPackages() {
  return _getDspPackages.apply(this, arguments);
}

function _getDspPackages() {
  _getDspPackages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var result;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 500,
              scope: 'dappservices',
              table: 'package'
            });

          case 3:
            result = _context2.sent;
            return _context2.abrupt("return", result && result.rows && result.rows.length ? result.rows : []);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            console.log(_context2.t0);
            return _context2.abrupt("return", []);

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 7]]);
  }));
  return _getDspPackages.apply(this, arguments);
}

function getDapphodlBalance(_x) {
  return _getDapphodlBalance.apply(this, arguments);
}

function _getDapphodlBalance() {
  _getDapphodlBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappairhodl1',
              json: true,
              limit: 1,
              scope: account,
              table: 'accounts'
            });

          case 3:
            result = _context3.sent;
            return _context3.abrupt("return", result && result.rows && result.rows.length ? result.rows[0] : {});

          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](0);
            return _context3.abrupt("return", {});

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 7]]);
  }));
  return _getDapphodlBalance.apply(this, arguments);
}

function getDappBalance(_x2) {
  return _getDappBalance.apply(this, arguments);
}

function _getDappBalance() {
  _getDappBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1,
              scope: account,
              table: 'accounts'
            });

          case 3:
            result = _context4.sent;
            return _context4.abrupt("return", result && result.rows && result.rows.length ? result.rows[0] : {});

          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](0);
            return _context4.abrupt("return", {});

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 7]]);
  }));
  return _getDappBalance.apply(this, arguments);
}

function getDappStakes(_x3) {
  return _getDappStakes.apply(this, arguments);
}

function _getDappStakes() {
  _getDappStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 100,
              scope: account,
              table: 'staking'
            });

          case 3:
            result = _context5.sent;
            return _context5.abrupt("return", result && result.rows && result.rows.length ? result.rows.map(function (row) {
              row.scope = account;
              return row;
            }) : []);

          case 7:
            _context5.prev = 7;
            _context5.t0 = _context5["catch"](0);
            return _context5.abrupt("return", []);

          case 10:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 7]]);
  }));
  return _getDappStakes.apply(this, arguments);
}

function getDapphodlStakes(_x4, _x5) {
  return _getDapphodlStakes.apply(this, arguments);
}

function _getDapphodlStakes() {
  _getDapphodlStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(account, lower_bound) {
    var result, rows;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (lower_bound === void 0) {
              lower_bound = '';
            }

            _context6.prev = 1;
            _context6.next = 4;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1000,
              scope: 'dappairhodl1',
              table: 'staking',
              lower_bound: lower_bound
            });

          case 4:
            result = _context6.sent;

            if (result) {
              _context6.next = 7;
              break;
            }

            return _context6.abrupt("return", []);

          case 7:
            rows = result.rows;

            if (!result.more) {
              _context6.next = 14;
              break;
            }

            _context6.t0 = rows;
            _context6.next = 12;
            return this.getDapphodlStakes(account, +rows[rows.length - 1].id + 1);

          case 12:
            _context6.t1 = _context6.sent;
            rows = _context6.t0.concat.call(_context6.t0, _context6.t1);

          case 14:
            return _context6.abrupt("return", rows.filter(function (row) {
              return row.account === account;
            }).map(function (row) {
              row.scope = 'dappairhodl1';
              return row;
            }));

          case 17:
            _context6.prev = 17;
            _context6.t2 = _context6["catch"](1);
            return _context6.abrupt("return", []);

          case 20:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[1, 17]]);
  }));
  return _getDapphodlStakes.apply(this, arguments);
}

function getDappUnstakes(_x6) {
  return _getDappUnstakes.apply(this, arguments);
}

function _getDappUnstakes() {
  _getDappUnstakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 100,
              scope: account,
              table: 'refunds'
            });

          case 3:
            result = _context7.sent;
            return _context7.abrupt("return", result && result.rows && result.rows.length ? result.rows.map(function (row) {
              row.scope = account;
              return row;
            }) : []);

          case 7:
            _context7.prev = 7;
            _context7.t0 = _context7["catch"](0);
            return _context7.abrupt("return", []);

          case 10:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 7]]);
  }));
  return _getDappUnstakes.apply(this, arguments);
}

function getDapphodlUnstakes(_x7) {
  return _getDapphodlUnstakes.apply(this, arguments);
}

function _getDapphodlUnstakes() {
  _getDapphodlUnstakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(account) {
    var result, rows;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1000,
              scope: 'dappairhodl1',
              table: 'refunds'
            });

          case 3:
            result = _context8.sent;

            if (result) {
              _context8.next = 6;
              break;
            }

            return _context8.abrupt("return", []);

          case 6:
            rows = result.rows;

            if (!result.more) {
              _context8.next = 13;
              break;
            }

            _context8.t0 = rows;
            _context8.next = 11;
            return this.getDapphodlUnstakes(account);

          case 11:
            _context8.t1 = _context8.sent;
            rows = _context8.t0.concat.call(_context8.t0, _context8.t1);

          case 13:
            return _context8.abrupt("return", rows.filter(function (row) {
              return row.account === account;
            }).map(function (row) {
              row.scope = 'dappairhodl1';
              return row;
            }));

          case 16:
            _context8.prev = 16;
            _context8.t2 = _context8["catch"](0);
            return _context8.abrupt("return", []);

          case 19:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[0, 16]]);
  }));
  return _getDapphodlUnstakes.apply(this, arguments);
}

var http = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var path, method, body, headers, data, response;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            path = _ref.path, method = _ref.method, body = _ref.body, headers = _ref.headers;
            _context.prev = 1;
            _context.next = 4;
            return cross_fetch__WEBPACK_IMPORTED_MODULE_5___default()(path, {
              method: method,
              body: body,
              headers: headers || {
                'Content-Type': 'application/json'
              }
            });

          case 4:
            response = _context.sent;
            _context.next = 7;
            return response.json();

          case 7:
            data = _context.sent;
            _context.next = 13;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);

          case 13:
            if (response && response.ok) {
              _context.next = 15;
              break;
            }

            throw new _proton_js__WEBPACK_IMPORTED_MODULE_0__.RpcError(data || 'Error');

          case 15:
            return _context.abrupt("return", data);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 10]]);
  }));

  return function http(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var get = /*#__PURE__*/function () {
  var _ref3 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, headers) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return http({
              path: path,
              method: 'GET',
              headers: headers
            });

          case 2:
            return _context2.abrupt("return", _context2.sent);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function get(_x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}();
var post = /*#__PURE__*/function () {
  var _ref4 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path, body) {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return http({
              path: path,
              method: 'POST',
              body: JSON.stringify(body)
            });

          case 2:
            return _context3.abrupt("return", _context3.sent);

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function post(_x4, _x5) {
    return _ref4.apply(this, arguments);
  };
}();

function getFIOVoter(_x) {
  return _getFIOVoter.apply(this, arguments);
}

function _getFIOVoter() {
  _getFIOVoter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              upper_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'voters',
              key_type: 'i64',
              index_position: 3,
              limit: 1
            });

          case 3:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context.abrupt("return", rows.length ? rows[0] : undefined);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getFIOVoter.apply(this, arguments);
}

function getFIOAddressByName(_x2) {
  return _getFIOAddressByName.apply(this, arguments);
}

function _getFIOAddressByName() {
  _getFIOAddressByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name) {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.t0 = this.rpc;
            _context2.next = 4;
            return (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.string_to_uint128_hash)(name);

          case 4:
            _context2.t1 = _context2.sent;
            _context2.t2 = '0x' + _context2.t1;
            _context2.t3 = {
              code: 'fio.address',
              scope: 'fio.address',
              table: 'fionames',
              lower_bound: _context2.t2,
              limit: 1,
              key_type: 'i128',
              index_position: 5
            };
            _context2.next = 9;
            return _context2.t0.get_table_rows.call(_context2.t0, _context2.t3);

          case 9:
            _yield$this$rpc$get_t2 = _context2.sent;
            rows = _yield$this$rpc$get_t2.rows;

            if (!(rows && rows.length && rows[0].name === name)) {
              _context2.next = 15;
              break;
            }

            return _context2.abrupt("return", rows[0]);

          case 15:
            return _context2.abrupt("return", undefined);

          case 16:
            _context2.next = 22;
            break;

          case 18:
            _context2.prev = 18;
            _context2.t4 = _context2["catch"](0);
            console.log(_context2.t4);
            return _context2.abrupt("return", undefined);

          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 18]]);
  }));
  return _getFIOAddressByName.apply(this, arguments);
}

function getNFTsByFioAddress(_x3) {
  return _getNFTsByFioAddress.apply(this, arguments);
}

function _getNFTsByFioAddress() {
  _getNFTsByFioAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(name) {
    var _yield$this$rpc$get_n, nfts;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return this.rpc.get_nfts_fio_address(name);

          case 3:
            _yield$this$rpc$get_n = _context3.sent;
            nfts = _yield$this$rpc$get_n.nfts;

            if (!(nfts && nfts.length)) {
              _context3.next = 9;
              break;
            }

            return _context3.abrupt("return", nfts);

          case 9:
            return _context3.abrupt("return", []);

          case 10:
            _context3.next = 16;
            break;

          case 12:
            _context3.prev = 12;
            _context3.t0 = _context3["catch"](0);
            console.log(_context3.t0);
            return _context3.abrupt("return", []);

          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 12]]);
  }));
  return _getNFTsByFioAddress.apply(this, arguments);
}

function getFIODomainByName(_x4) {
  return _getFIODomainByName.apply(this, arguments);
}

function _getFIODomainByName() {
  _getFIODomainByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(name) {
    var _yield$this$rpc$get_t3, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.t0 = this.rpc;
            _context4.next = 4;
            return (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.string_to_uint128_hash)(name);

          case 4:
            _context4.t1 = _context4.sent;
            _context4.t2 = '0x' + _context4.t1;
            _context4.t3 = {
              code: 'fio.address',
              scope: 'fio.address',
              table: 'domains',
              lower_bound: _context4.t2,
              limit: 1,
              key_type: 'i128',
              index_position: 4
            };
            _context4.next = 9;
            return _context4.t0.get_table_rows.call(_context4.t0, _context4.t3);

          case 9:
            _yield$this$rpc$get_t3 = _context4.sent;
            rows = _yield$this$rpc$get_t3.rows;

            if (!(rows && rows.length && rows[0].name === name)) {
              _context4.next = 15;
              break;
            }

            return _context4.abrupt("return", rows[0]);

          case 15:
            return _context4.abrupt("return", undefined);

          case 16:
            _context4.next = 22;
            break;

          case 18:
            _context4.prev = 18;
            _context4.t4 = _context4["catch"](0);
            console.log(_context4.t4);
            return _context4.abrupt("return", undefined);

          case 22:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 18]]);
  }));
  return _getFIODomainByName.apply(this, arguments);
}

function getDomains(_x5, _x6) {
  return _getDomains.apply(this, arguments);
}

function _getDomains() {
  _getDomains = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(limit, upper_bound) {
    var _yield$this$rpc$get_t4, rows;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (limit === void 0) {
              limit = -1;
            }

            _context5.prev = 1;
            _context5.next = 4;
            return this.rpc.get_table_rows({
              code: 'fio.address',
              scope: 'fio.address',
              table: 'domains',
              reverse: true,
              upper_bound: upper_bound,
              limit: limit
            });

          case 4:
            _yield$this$rpc$get_t4 = _context5.sent;
            rows = _yield$this$rpc$get_t4.rows;

            if (!(rows && rows.length)) {
              _context5.next = 10;
              break;
            }

            return _context5.abrupt("return", rows);

          case 10:
            return _context5.abrupt("return", []);

          case 11:
            _context5.next = 17;
            break;

          case 13:
            _context5.prev = 13;
            _context5.t0 = _context5["catch"](1);
            console.log(_context5.t0);
            return _context5.abrupt("return", []);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[1, 13]]);
  }));
  return _getDomains.apply(this, arguments);
}

function getAddresses(_x7, _x8) {
  return _getAddresses.apply(this, arguments);
}

function _getAddresses() {
  _getAddresses = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(limit, upper_bound) {
    var _yield$this$rpc$get_t5, rows;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (limit === void 0) {
              limit = -1;
            }

            _context6.prev = 1;
            _context6.next = 4;
            return this.rpc.get_table_rows({
              code: 'fio.address',
              scope: 'fio.address',
              table: 'fionames',
              reverse: true,
              upper_bound: upper_bound,
              limit: limit
            });

          case 4:
            _yield$this$rpc$get_t5 = _context6.sent;
            rows = _yield$this$rpc$get_t5.rows;

            if (!(rows && rows.length)) {
              _context6.next = 10;
              break;
            }

            return _context6.abrupt("return", rows);

          case 10:
            return _context6.abrupt("return", []);

          case 11:
            _context6.next = 17;
            break;

          case 13:
            _context6.prev = 13;
            _context6.t0 = _context6["catch"](1);
            console.log(_context6.t0);
            return _context6.abrupt("return", []);

          case 17:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[1, 13]]);
  }));
  return _getAddresses.apply(this, arguments);
}

function getFIOProducers(_x9) {
  return _getFIOProducers.apply(this, arguments);
}

function _getFIOProducers() {
  _getFIOProducers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(limit) {
    var _yield$this$rpc$get_t6, rows;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'producers',
              reverse: true,
              limit: limit
            });

          case 3:
            _yield$this$rpc$get_t6 = _context7.sent;
            rows = _yield$this$rpc$get_t6.rows;

            if (!(rows && rows.length)) {
              _context7.next = 9;
              break;
            }

            return _context7.abrupt("return", rows);

          case 9:
            return _context7.abrupt("return", []);

          case 10:
            _context7.next = 16;
            break;

          case 12:
            _context7.prev = 12;
            _context7.t0 = _context7["catch"](0);
            console.log(_context7.t0);
            return _context7.abrupt("return", []);

          case 16:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 12]]);
  }));
  return _getFIOProducers.apply(this, arguments);
}

function getFIOBalance(_x10) {
  return _getFIOBalance.apply(this, arguments);
}

function _getFIOBalance() {
  _getFIOBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(fio_public_key) {
    var balance;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return this.rpc.fetch('/v1/chain/get_fio_balance', {
              fio_public_key: fio_public_key
            });

          case 3:
            balance = _context8.sent;

            if (!balance) {
              _context8.next = 8;
              break;
            }

            return _context8.abrupt("return", balance);

          case 8:
            return _context8.abrupt("return", null);

          case 9:
            _context8.next = 15;
            break;

          case 11:
            _context8.prev = 11;
            _context8.t0 = _context8["catch"](0);
            console.log(_context8.t0);
            return _context8.abrupt("return", null);

          case 15:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[0, 11]]);
  }));
  return _getFIOBalance.apply(this, arguments);
}

function getFIOSupplyBreakdown() {
  return _getFIOSupplyBreakdown.apply(this, arguments);
}

function _getFIOSupplyBreakdown() {
  _getFIOSupplyBreakdown = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
    var tokenRes, supply, bpRewardRes, bpRewards, bpBucketRes, bpBucket, totalBp, circulating, totalLocked;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.rpc.get_table_rows({
              code: "fio.token",
              scope: "FIO",
              table: "stat"
            });

          case 2:
            tokenRes = _context9.sent;
            supply = +tokenRes.rows[0].supply.split(' ')[0];
            _context9.next = 6;
            return this.rpc.get_table_rows({
              code: "fio.treasury",
              scope: "fio.treasury",
              table: "bprewards"
            });

          case 6:
            bpRewardRes = _context9.sent;
            bpRewards = bpRewardRes.rows[0].rewards / Math.pow(10, this.constants.CORE_PRECISION);
            _context9.next = 10;
            return this.rpc.get_table_rows({
              code: "fio.treasury",
              scope: "fio.treasury",
              table: "bpbucketpool"
            });

          case 10:
            bpBucketRes = _context9.sent;
            bpBucket = bpBucketRes.rows[0].rewards / Math.pow(10, this.constants.CORE_PRECISION);
            totalBp = bpRewards + bpBucket; // const totalLocked = baseLocked + totalBp
            // const circulating = supply - totalLocked

            _context9.next = 15;
            return this.get('https://fioprotocol.io/circulating');

          case 15:
            circulating = _context9.sent;
            totalLocked = supply - +circulating;
            return _context9.abrupt("return", {
              supply: supply,
              totalLocked: totalLocked,
              bpRewards: bpRewards,
              bpBucket: bpBucket,
              totalBp: totalBp,
              circulating: circulating
            });

          case 18:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this);
  }));
  return _getFIOSupplyBreakdown.apply(this, arguments);
}

function getFIOFees() {
  return _getFIOFees.apply(this, arguments);
}

function _getFIOFees() {
  _getFIOFees = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            return _context10.abrupt("return", this.rpc.get_table_rows({
              code: 'fio.fee',
              scope: 'fio.fee',
              table: 'fiofees',
              limit: -1
            }).then(function (result) {
              return result.rows;
            })["catch"](function (_) {
              return [];
            }));

          case 1:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, this);
  }));
  return _getFIOFees.apply(this, arguments);
}

function addFIOFeeToActions(_x11, _x12) {
  return _addFIOFeeToActions.apply(this, arguments);
}

function _addFIOFeeToActions() {
  _addFIOFeeToActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(actions, actor) {
    var _this = this;

    var fioFeesMap, fees, modifiedActions, _loop, _iterator, _step;

    return _regeneratorRuntime().wrap(function _callee11$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            fioFeesMap = {
              'eosio::deleteauth': 'auth_delete',
              'eosio::linkauth': 'auth_link',
              'eosio::regproducer': 'register_producer',
              'eosio::regproxy': 'register_proxy',
              'eosio::unregprod': 'unregister_producer',
              'eosio::unregproxy': 'unregister_proxy',
              'eosio::updateauth': 'auth_update',
              'eosio::voteproducer': 'vote_producer',
              'eosio::voteproxy': 'proxy_vote',
              'fio.token::trnsfiopubky': 'transfer_tokens_pub_key',
              'fio.address::addaddress': 'add_pub_address',
              'fio.address::regaddress': 'register_fio_address',
              'fio.address::regdomain': 'register_fio_domain',
              'fio.address::renewaddress': 'renew_fio_address',
              'fio.address::renewdomain': 'renew_fio_domain',
              'fio.address::setdomainpub': 'set_fio_domain_public',
              'eosio.msig::approve': 'msig_approve',
              'eosio.msig::cancel': 'msig_cancel',
              'eosio.msig::exec': 'msig_exec',
              'eosio.msig::invalidate': 'msig_invalidate',
              'eosio.msig::propose': 'msig_propose',
              'eosio.msig::unapprove': 'msig_approve',
              'fio.reqobt::newfundsreq': 'new_funds_request',
              'fio.reqobt::rejectfndreq': 'reject_funds_request',
              'fio.reqobt::cancelfndreq': 'cancelfndreq',
              'fio.reqobt::recordobt': 'record_obt_data',
              'fio.reqobt::newpubaddreq': 'new_pub_address_request',
              'fio.reqobt::relpubadd': 'release_pub_address',
              'fio.reqobt::rejectaddreq': 'reject_pub_address_request',
              'fio.reqobt::canceladdreq': 'cancel_pub_address_request',
              'fio.lock::trnsloctoks': 'transfer_locked_tokens',
              'fio.lock::locktokens': 'lock_tokens',
              'fio.address::remaddress': 'remove_pub_address',
              'fio.address::remalladdr': 'remove_all_pub_addresses',
              'fio.address::burnaddress': 'burn_fio_address',
              'fio.address::xferdomain': 'transfer_fio_domain',
              'fio.address::xferaddress': 'transfer_fio_address'
            };
            _context12.next = 3;
            return this.getFIOFees();

          case 3:
            fees = _context12.sent;
            modifiedActions = [];
            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
              var action, _yield$_this$api$getC, _yield$_this$api$getC2, abiActions, abiStructs, relevantAction, relevantStruct, maxFeeField, endpoint, relevantFee, actorField, tpidField, addressField, addresses;

              return _regeneratorRuntime().wrap(function _loop$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      action = _step.value;
                      _context11.next = 3;
                      return _this.api.getCachedAbi(action.account);

                    case 3:
                      _yield$_this$api$getC = _context11.sent;
                      _yield$_this$api$getC2 = _yield$_this$api$getC.abi;
                      abiActions = _yield$_this$api$getC2.actions;
                      abiStructs = _yield$_this$api$getC2.structs;
                      relevantAction = abiActions.find(function (abiAction) {
                        return abiAction.name === action.name;
                      });

                      if (!relevantAction) {
                        _context11.next = 23;
                        break;
                      }

                      relevantStruct = abiStructs.find(function (abiStruct) {
                        return abiStruct.name === relevantAction.type;
                      });

                      if (!relevantStruct) {
                        _context11.next = 23;
                        break;
                      }

                      maxFeeField = relevantStruct.fields.find(function (field) {
                        return field.name === "max_fee";
                      });

                      if (maxFeeField && action.data.max_fee === undefined) {
                        endpoint = fioFeesMap[action.account + "::" + action.name];

                        if (endpoint) {
                          relevantFee = fees.find(function (fee) {
                            return fee.end_point === endpoint;
                          });

                          if (relevantFee) {
                            action.data.max_fee = relevantFee.suf_amount;
                          } else {
                            action.data.max_fee = 0;
                          }
                        }
                      }

                      actorField = relevantStruct.fields.find(function (field) {
                        return field.name === "actor";
                      });

                      if (actorField && action.data.actor === undefined) {
                        action.data.actor = actor;
                      }

                      tpidField = relevantStruct.fields.find(function (field) {
                        return field.name === "tpid";
                      });

                      if (tpidField && action.data.tpid === undefined) {
                        action.data.tpid = _this.constants.FIO_FEES_ACCOUNT;
                      }

                      addressField = relevantStruct.fields.find(function (field) {
                        return field.name === "fio_address";
                      });

                      if (!(addressField && action.data.fio_address === undefined)) {
                        _context11.next = 23;
                        break;
                      }

                      _context11.next = 21;
                      return _this.getFIOAddresses(actor);

                    case 21:
                      addresses = _context11.sent;

                      if (addresses.length) {
                        action.data.fio_address = addresses[0].name;
                      }

                    case 23:
                      modifiedActions.push(action);

                    case 24:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _loop);
            });
            _iterator = _createForOfIteratorHelperLoose(actions);

          case 7:
            if ((_step = _iterator()).done) {
              _context12.next = 11;
              break;
            }

            return _context12.delegateYield(_loop(), "t0", 9);

          case 9:
            _context12.next = 7;
            break;

          case 11:
            return _context12.abrupt("return", modifiedActions);

          case 12:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee11, this);
  }));
  return _addFIOFeeToActions.apply(this, arguments);
}

function getFIOAddresses(account) {
  return this.rpc.get_table_rows({
    code: 'fio.address',
    scope: 'fio.address',
    table: 'fionames',
    key_type: 'i64',
    limit: -1,
    lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
    upper_bound: new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)).plus(1).toString(),
    index_position: 4
  }).then(function (result) {
    if (result.rows.length > 0) {
      return result.rows.filter(function (row) {
        return row.owner_account === account;
      });
    } else {
      return [];
    }
  })["catch"](function (_) {
    return [];
  });
}
function getFIODomains(account) {
  return this.rpc.get_table_rows({
    code: 'fio.address',
    scope: 'fio.address',
    table: 'domains',
    key_type: 'i64',
    limit: -1,
    lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
    upper_bound: new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)).plus(1).toString(),
    index_position: 2
  }).then(function (result) {
    if (result.rows.length > 0) {
      return result.rows.filter(function (row) {
        return row.account === account;
      });
    } else {
      return [];
    }
  })["catch"](function (_) {
    return [];
  });
}
function getFIOAddressesAndDomains(fio_public_key) {
  return post(this.constants.DEFAULT_ENDPOINTS[0] + "/v1/get_fio_names", {
    fio_public_key: fio_public_key
  });
}

function getAllMsigs() {
  return _getAllMsigs.apply(this, arguments);
}

function _getAllMsigs() {
  _getAllMsigs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$this$get, tables, rows, lower_bound, result;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!this.constants.HISTORY_TYPES.includes('dfuse')) {
              _context.next = 9;
              break;
            }

            _context.next = 3;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'dfuse', {
              type: 'state_scope_pipeline',
              account: this.constants.EOSIO_MSIG,
              table: this.constants.EOSIO_MSIG_PROPOSALS_TABLE,
              options: {}
            }));

          case 3:
            _yield$this$get = _context.sent;
            tables = _yield$this$get.tables;
            tables = tables.map(function (table) {
              table.rows = table.rows.sort(function (a, b) {
                return b.block - a.block;
              });
              table.highestBlock = table.rows[0].block;
              return table;
            }).sort(function (a, b) {
              return b.highestBlock - a.highestBlock;
            });
            return _context.abrupt("return", tables);

          case 9:
            rows = [];
            lower_bound = '';

          case 11:
            _context.next = 13;
            return this.rpc.get_table_by_scope({
              json: true,
              code: 'eosio.msig',
              limit: 100,
              lower_bound: lower_bound,
              table: 'proposal',
              upper_bound: ''
            });

          case 13:
            result = _context.sent;
            lower_bound = result.more;
            rows = rows.concat(result.rows);

          case 16:
            if (lower_bound) {
              _context.next = 11;
              break;
            }

          case 17:
            return _context.abrupt("return", rows.map(function (row) {
              return {
                scope: row.scope,
                rows: Array(row.count).fill({
                  key: ''
                })
              };
            }));

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getAllMsigs.apply(this, arguments);
}

function getMsigProposal(_x, _x2) {
  return _getMsigProposal.apply(this, arguments);
}

function _getMsigProposal() {
  _getMsigProposal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(accountName, proposalName) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: 'eosio.msig',
              scope: accountName,
              limit: 1,
              lower_bound: proposalName,
              table: 'proposal'
            });

          case 2:
            _yield$this$rpc$get_t = _context2.sent;
            rows = _yield$this$rpc$get_t.rows;

            if (!(rows && rows.length && rows[0].proposal_name === proposalName)) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return", rows[0]);

          case 8:
            return _context2.abrupt("return", undefined);

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getMsigProposal.apply(this, arguments);
}

function parsePackedMsigActions(_x3) {
  return _parsePackedMsigActions.apply(this, arguments);
}

function _parsePackedMsigActions() {
  _parsePackedMsigActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(packedActions) {
    var actions, _iterator, _step, action;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            actions = [];
            _iterator = _createForOfIteratorHelperLoose(packedActions);

          case 2:
            if ((_step = _iterator()).done) {
              _context3.next = 15;
              break;
            }

            action = _step.value;

            if (!(action.account === this.constants.EOSIO_MSIG && action.name === 'propose')) {
              _context3.next = 8;
              break;
            }

            _context3.next = 7;
            return this.api.deserializeActionsSync(action.data.trx.actions);

          case 7:
            action.data.trx.actions = _context3.sent;

          case 8:
            if (!(action.account === this.constants.EOSIO && action.name === 'setabi')) {
              _context3.next = 12;
              break;
            }

            _context3.next = 11;
            return this.api.rawAbiToJson((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.hexToUint8Array)(action.data.abi));

          case 11:
            action.data.abi = _context3.sent;

          case 12:
            actions.push(action);

          case 13:
            _context3.next = 2;
            break;

          case 15:
            actions = actions.map(function (action) {
              return {
                action_trace: {
                  act: action
                }
              };
            });
            return _context3.abrupt("return", actions);

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _parsePackedMsigActions.apply(this, arguments);
}

function parsePackedMsig(_x4) {
  return _parsePackedMsig.apply(this, arguments);
}

function _parsePackedMsig() {
  _parsePackedMsig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(packed_transaction) {
    var tx;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.api.deserializeTransactionWithActions(packed_transaction);

          case 3:
            tx = _context4.sent;
            _context4.next = 6;
            return this.parsePackedMsigActions(tx.actions);

          case 6:
            tx.actions = _context4.sent;
            return _context4.abrupt("return", tx);

          case 10:
            _context4.prev = 10;
            _context4.t0 = _context4["catch"](0);
            console.log('Error parsing packed msig');
            console.log(_context4.t0);

          case 14:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 10]]);
  }));
  return _parsePackedMsig.apply(this, arguments);
}

function getFullMsigProposal(_x5, _x6) {
  return _getFullMsigProposal.apply(this, arguments);
}

function _getFullMsigProposal() {
  _getFullMsigProposal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account_name, proposal_name) {
    var result;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO_MSIG,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account_name, false),
              table: this.constants.EOSIO_MSIG_PROPOSALS_TABLE,
              table_key: '',
              key_type: 'name',
              lower_bound: proposal_name,
              index_position: 1,
              limit: 1
            });

          case 3:
            result = _context5.sent;

            if (!(result && result.rows && result.rows.length)) {
              _context5.next = 8;
              break;
            }

            _context5.next = 7;
            return this.parsePackedMsig(result.rows[0].packed_transaction);

          case 7:
            return _context5.abrupt("return", _context5.sent);

          case 8:
            _context5.next = 13;
            break;

          case 10:
            _context5.prev = 10;
            _context5.t0 = _context5["catch"](0);
            console.log(_context5.t0);

          case 13:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 10]]);
  }));
  return _getFullMsigProposal.apply(this, arguments);
}

function getMsigApprovals(_x7, _x8) {
  return _getMsigApprovals.apply(this, arguments);
}

function _getMsigApprovals() {
  _getMsigApprovals = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(account, table) {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            _context6.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO_MSIG,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: table,
              limit: -1
            });

          case 3:
            _yield$this$rpc$get_t2 = _context6.sent;
            rows = _yield$this$rpc$get_t2.rows;
            return _context6.abrupt("return", rows);

          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](0);
            console.log(_context6.t0);
            return _context6.abrupt("return", []);

          case 12:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[0, 8]]);
  }));
  return _getMsigApprovals.apply(this, arguments);
}

function getAccountsMsigProposals(_x9) {
  return _getAccountsMsigProposals.apply(this, arguments);
}

function _getAccountsMsigProposals() {
  _getAccountsMsigProposals = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(account) {
    var promises, _yield$Promise$all, rows2, rows1;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            promises = [this.getMsigApprovals(account, this.constants.EOSIO_MSIG_APPROVALS_TABLE)];

            if (this.constants.EOSIO_MSIG_APPROVALS_TABLE === 'approvals2') {
              promises.push(this.getMsigApprovals(account, 'approvals'));
            }

            _context7.next = 5;
            return Promise.all(promises);

          case 5:
            _yield$Promise$all = _context7.sent;
            rows2 = _yield$Promise$all[0];
            rows1 = _yield$Promise$all[1];
            return _context7.abrupt("return", rows2.concat(rows1));

          case 11:
            _context7.prev = 11;
            _context7.t0 = _context7["catch"](0);
            console.log(_context7.t0);
            return _context7.abrupt("return", []);

          case 15:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 11]]);
  }));
  return _getAccountsMsigProposals.apply(this, arguments);
}

function hyperionGetMsig(_x10) {
  return _hyperionGetMsig.apply(this, arguments);
}

function _hyperionGetMsig() {
  _hyperionGetMsig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(msigFilters) {
    var res, executionTransaction, transaction, proposal, _yield$Promise$all2, actionsRes, actionsRes2, relevantAction, tx;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (this.hyperion) {
              _context8.next = 2;
              break;
            }

            return _context8.abrupt("return", undefined);

          case 2:
            _context8.next = 4;
            return this.hyperion.get_proposals(msigFilters);

          case 4:
            res = _context8.sent;

            if (!(res && res.proposals && res.proposals.length)) {
              _context8.next = 22;
              break;
            }

            proposal = res.proposals[0];
            _context8.next = 9;
            return Promise.all([this.hyperion.get_actions(this.constants.EOSIO_MSIG, {
              block_num: proposal.block_num,
              limit: 1
            }), this.hyperion.get_deltas(this.constants.EOSIO_MSIG, msigFilters.proposer, 'proposal', undefined, {
              block_num: proposal.block_num
            })]);

          case 9:
            _yield$Promise$all2 = _context8.sent;
            actionsRes = _yield$Promise$all2[0];
            actionsRes2 = _yield$Promise$all2[1];

            if (actionsRes && actionsRes.actions && actionsRes.actions.length) {
              relevantAction = actionsRes.actions.find(function (action) {
                return action.act.data.proposal_name === msigFilters.proposal;
              });

              if (relevantAction) {
                executionTransaction = {
                  payer: relevantAction.act.data.executer || relevantAction.act.data.canceler,
                  trx_id: relevantAction.trx_id,
                  published_at: relevantAction.timestamp,
                  cancelled: relevantAction.act.name === 'cancel'
                };
              }
            }

            if (!(actionsRes2 && actionsRes2.deltas && actionsRes2.deltas.length)) {
              _context8.next = 19;
              break;
            }

            tx = actionsRes2.deltas[0].data.transaction;
            _context8.next = 17;
            return this.parsePackedMsigActions(tx.actions);

          case 17:
            tx.actions = _context8.sent;
            transaction = tx;

          case 19:
            return _context8.abrupt("return", {
              approvals: proposal,
              transaction: transaction,
              executionTransaction: executionTransaction
            });

          case 22:
            return _context8.abrupt("return", undefined);

          case 23:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));
  return _hyperionGetMsig.apply(this, arguments);
}

function getVoter(_x) {
  return _getVoter.apply(this, arguments);
}

function _getVoter() {
  _getVoter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              upper_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'voters',
              limit: 1
            });

          case 3:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context.abrupt("return", rows.length ? rows[0] : undefined);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getVoter.apply(this, arguments);
}

function getProxies() {
  return _getProxies.apply(this, arguments);
}

function _getProxies() {
  _getProxies = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var _this = this;

    var _yield$this$get, proxies, _yield$this$hyperion$, voters;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(this.constants.ALOHA_PROXY_URL !== '')) {
              _context2.next = 8;
              break;
            }

            _context2.next = 3;
            return this.get(this.constants.ALOHA_PROXY_URL + "?output=json");

          case 3:
            _yield$this$get = _context2.sent;
            proxies = _yield$this$get.proxies;
            return _context2.abrupt("return", proxies);

          case 8:
            _context2.next = 10;
            return this.hyperion.get_voters({
              proxy: true,
              limit: 1000
            });

          case 10:
            _yield$this$hyperion$ = _context2.sent;
            voters = _yield$this$hyperion$.voters;
            return _context2.abrupt("return", voters.map(function (voter, index) {
              return _extends({}, voter, {
                weight: voter.weight / Math.pow(10, _this.constants.CORE_PRECISION),
                rank: index + 1
              });
            }));

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getProxies.apply(this, arguments);
}

function getVoters(_x2) {
  return _getVoters.apply(this, arguments);
}

function _getVoters() {
  _getVoters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(producer) {
    var _this2 = this;

    var _yield$this$hyperion$2, voters, voteWeight;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!this.hyperion) {
              _context3.next = 9;
              break;
            }

            _context3.next = 3;
            return this.hyperion.get_voters({
              producer: producer,
              limit: 100
            });

          case 3:
            _yield$this$hyperion$2 = _context3.sent;
            voters = _yield$this$hyperion$2.voters;
            voteWeight = this.calculateVoteWeight();
            return _context3.abrupt("return", voters.map(function (voter) {
              return _extends({}, voter, {
                vote: _this2.weightedVoteToNumber(voter.weight, voteWeight)
              });
            }));

          case 9:
            return _context3.abrupt("return", undefined);

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getVoters.apply(this, arguments);
}

function calculateVoteWeight() {
  var decayWeeks = this.constants.CHAIN === 'wax' ? 13 : 52;
  var timestamp_epoch = 946684800000;
  var dates = Date.now() / 1000 - timestamp_epoch / 1000;
  var weight = Math.floor(dates / (86400 * 7)) / decayWeeks;
  return Math.pow(2, weight);
}
function weightedVoteToNumber(weightedVote, voteWeight) {
  if (!voteWeight) {
    voteWeight = this.calculateVoteWeight();
  }

  return +weightedVote / voteWeight / Math.pow(10, this.constants.CORE_PRECISION);
}
function getProxyData(_x3) {
  return _getProxyData.apply(this, arguments);
}

function _getProxyData() {
  _getProxyData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(accountName) {
    var _yield$this$get2, proxy;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(this.constants.ALOHA_PROXY_URL !== '')) {
              _context4.next = 8;
              break;
            }

            _context4.next = 3;
            return this.get(this.constants.ALOHA_PROXY_URL + "/" + accountName + "?output=json");

          case 3:
            _yield$this$get2 = _context4.sent;
            proxy = _yield$this$get2.proxy;
            return _context4.abrupt("return", proxy);

          case 8:
            return _context4.abrupt("return", undefined);

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getProxyData.apply(this, arguments);
}

function getProducersLocal() {
  return _getProducersLocal.apply(this, arguments);
}

function _getProducersLocal() {
  _getProducersLocal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var more, rows, result, lower_bound;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            more = true;
            rows = [];
            result = null;
            lower_bound = null;

          case 4:
            _context5.next = 6;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'producers',
              lower_bound: lower_bound,
              index_position: 1,
              key_type: 'i64',
              limit: 100
            });

          case 6:
            result = _context5.sent;
            more = result.more;
            rows = rows.concat(result.rows);
            lower_bound = new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(rows[rows.length - 1].owner, false)).plus(1).toString();

          case 10:
            if (more) {
              _context5.next = 4;
              break;
            }

          case 11:
            return _context5.abrupt("return", rows);

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _getProducersLocal.apply(this, arguments);
}

function getProducers(_x4, _x5, _x6) {
  return _getProducers.apply(this, arguments);
}

function _getProducers() {
  _getProducers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(pageNum, perPage, local) {
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (pageNum === void 0) {
              pageNum = 1;
            }

            if (perPage === void 0) {
              perPage = 50;
            }

            if (local === void 0) {
              local = false;
            }

            if (!(this.constants.API_URL !== '' && !local)) {
              _context6.next = 9;
              break;
            }

            _context6.next = 6;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'producers', {
              pageNum: pageNum,
              perPage: perPage
            }));

          case 6:
            return _context6.abrupt("return", _context6.sent);

          case 9:
            return _context6.abrupt("return", this.getProducersLocal());

          case 10:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _getProducers.apply(this, arguments);
}

function getChainTable() {
  return _getChainTable.apply(this, arguments);
}

function _getChainTable() {
  _getChainTable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'global',
              limit: 1
            });

          case 2:
            _yield$this$rpc$get_t2 = _context7.sent;
            rows = _yield$this$rpc$get_t2.rows;
            return _context7.abrupt("return", rows[0]);

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _getChainTable.apply(this, arguments);
}

var KycStatus;

(function (KycStatus) {
  KycStatus["FAILED"] = "FAILED";
  KycStatus["UNSUBMITTED"] = "UNSUBMITTED";
  KycStatus["PENDING"] = "PENDING";
  KycStatus["PASSED"] = "PASSED";
})(KycStatus || (KycStatus = {}));

var countryOptions = [{
  key: 'AF',
  value: 'AF',
  flag: 'af',
  text: 'Afghanistan'
}, {
  key: 'AX',
  value: 'AX',
  flag: 'ax',
  text: 'Aland Islands'
}, {
  key: 'AL',
  value: 'AL',
  flag: 'al',
  text: 'Albania'
}, {
  key: 'DZ',
  value: 'DZ',
  flag: 'dz',
  text: 'Algeria'
}, {
  key: 'AS',
  value: 'AS',
  flag: 'as',
  text: 'American Samoa'
}, {
  key: 'AD',
  value: 'AD',
  flag: 'ad',
  text: 'Andorra'
}, {
  key: 'AO',
  value: 'AO',
  flag: 'ao',
  text: 'Angola'
}, {
  key: 'AI',
  value: 'AI',
  flag: 'ai',
  text: 'Anguilla'
}, {
  key: 'AG',
  value: 'AG',
  flag: 'ag',
  text: 'Antigua'
}, {
  key: 'AR',
  value: 'AR',
  flag: 'ar',
  text: 'Argentina'
}, {
  key: 'AM',
  value: 'AM',
  flag: 'am',
  text: 'Armenia'
}, {
  key: 'AW',
  value: 'AW',
  flag: 'aw',
  text: 'Aruba'
}, {
  key: 'AU',
  value: 'AU',
  flag: 'au',
  text: 'Australia'
}, {
  key: 'AT',
  value: 'AT',
  flag: 'at',
  text: 'Austria'
}, {
  key: 'AZ',
  value: 'AZ',
  flag: 'az',
  text: 'Azerbaijan'
}, {
  key: 'BS',
  value: 'BS',
  flag: 'bs',
  text: 'Bahamas'
}, {
  key: 'BH',
  value: 'BH',
  flag: 'bh',
  text: 'Bahrain'
}, {
  key: 'BD',
  value: 'BD',
  flag: 'bd',
  text: 'Bangladesh'
}, {
  key: 'BB',
  value: 'BB',
  flag: 'bb',
  text: 'Barbados'
}, {
  key: 'BY',
  value: 'BY',
  flag: 'by',
  text: 'Belarus'
}, {
  key: 'BE',
  value: 'BE',
  flag: 'be',
  text: 'Belgium'
}, {
  key: 'BZ',
  value: 'BZ',
  flag: 'bz',
  text: 'Belize'
}, {
  key: 'BJ',
  value: 'BJ',
  flag: 'bj',
  text: 'Benin'
}, {
  key: 'BM',
  value: 'BM',
  flag: 'bm',
  text: 'Bermuda'
}, {
  key: 'BT',
  value: 'BT',
  flag: 'bt',
  text: 'Bhutan'
}, {
  key: 'BO',
  value: 'BO',
  flag: 'bo',
  text: 'Bolivia'
}, {
  key: 'BA',
  value: 'BA',
  flag: 'ba',
  text: 'Bosnia'
}, {
  key: 'BW',
  value: 'BW',
  flag: 'bw',
  text: 'Botswana'
}, {
  key: 'BV',
  value: 'BV',
  flag: 'bv',
  text: 'Bouvet Island'
}, {
  key: 'BR',
  value: 'BR',
  flag: 'br',
  text: 'Brazil'
}, {
  key: 'VG',
  value: 'VG',
  flag: 'vg',
  text: 'British Virgin Islands'
}, {
  key: 'BN',
  value: 'BN',
  flag: 'bn',
  text: 'Brunei'
}, {
  key: 'BG',
  value: 'BG',
  flag: 'bg',
  text: 'Bulgaria'
}, {
  key: 'BF',
  value: 'BF',
  flag: 'bf',
  text: 'Burkina Faso'
}, {
  key: 'BI',
  value: 'BI',
  flag: 'bi',
  text: 'Burundi'
}, {
  key: 'TC',
  value: 'TC',
  flag: 'tc',
  text: 'Caicos Islands'
}, {
  key: 'KH',
  value: 'KH',
  flag: 'kh',
  text: 'Cambodia'
}, {
  key: 'CM',
  value: 'CM',
  flag: 'cm',
  text: 'Cameroon'
}, {
  key: 'CA',
  value: 'CA',
  flag: 'ca',
  text: 'Canada'
}, {
  key: 'CV',
  value: 'CV',
  flag: 'cv',
  text: 'Cape Verde'
}, {
  key: 'KY',
  value: 'KY',
  flag: 'ky',
  text: 'Cayman Islands'
}, {
  key: 'CF',
  value: 'CF',
  flag: 'cf',
  text: 'Central African Republic'
}, {
  key: 'TD',
  value: 'TD',
  flag: 'td',
  text: 'Chad'
}, {
  key: 'CL',
  value: 'CL',
  flag: 'cl',
  text: 'Chile'
}, {
  key: 'CN',
  value: 'CN',
  flag: 'cn',
  text: 'China'
}, {
  key: 'CX',
  value: 'CX',
  flag: 'cx',
  text: 'Christmas Island'
}, {
  key: 'CC',
  value: 'CC',
  flag: 'cc',
  text: 'Cocos Islands'
}, {
  key: 'CO',
  value: 'CO',
  flag: 'co',
  text: 'Colombia'
}, {
  key: 'KM',
  value: 'KM',
  flag: 'km',
  text: 'Comoros'
}, {
  key: 'CG',
  value: 'CG',
  flag: 'cg',
  text: 'Congo Brazzaville'
}, {
  key: 'CD',
  value: 'CD',
  flag: 'cd',
  text: 'Congo'
}, {
  key: 'CK',
  value: 'CK',
  flag: 'ck',
  text: 'Cook Islands'
}, {
  key: 'CR',
  value: 'CR',
  flag: 'cr',
  text: 'Costa Rica'
}, {
  key: 'CI',
  value: 'CI',
  flag: 'ci',
  text: 'Cote Divoire'
}, {
  key: 'HR',
  value: 'HR',
  flag: 'hr',
  text: 'Croatia'
}, {
  key: 'CU',
  value: 'CU',
  flag: 'cu',
  text: 'Cuba'
}, {
  key: 'CY',
  value: 'CY',
  flag: 'cy',
  text: 'Cyprus'
}, {
  key: 'CZ',
  value: 'CZ',
  flag: 'cz',
  text: 'Czech Republic'
}, {
  key: 'DK',
  value: 'DK',
  flag: 'dk',
  text: 'Denmark'
}, {
  key: 'DJ',
  value: 'DJ',
  flag: 'dj',
  text: 'Djibouti'
}, {
  key: 'DM',
  value: 'DM',
  flag: 'dm',
  text: 'Dominica'
}, {
  key: 'DO',
  value: 'DO',
  flag: 'do',
  text: 'Dominican Republic'
}, {
  key: 'EC',
  value: 'EC',
  flag: 'ec',
  text: 'Ecuador'
}, {
  key: 'EG',
  value: 'EG',
  flag: 'eg',
  text: 'Egypt'
}, {
  key: 'SV',
  value: 'SV',
  flag: 'sv',
  text: 'El Salvador'
}, {
  key: 'GB',
  value: 'GB',
  flag: 'gb',
  text: 'England'
}, {
  key: 'GQ',
  value: 'GQ',
  flag: 'gq',
  text: 'Equatorial Guinea'
}, {
  key: 'ER',
  value: 'ER',
  flag: 'er',
  text: 'Eritrea'
}, {
  key: 'EE',
  value: 'EE',
  flag: 'ee',
  text: 'Estonia'
}, {
  key: 'ET',
  value: 'ET',
  flag: 'et',
  text: 'Ethiopia'
}, {
  key: 'EU',
  value: 'EU',
  flag: 'eu',
  text: 'European Union'
}, {
  key: 'FK',
  value: 'FK',
  flag: 'fk',
  text: 'Falkland Islands'
}, {
  key: 'FO',
  value: 'FO',
  flag: 'fo',
  text: 'Faroe Islands'
}, {
  key: 'FJ',
  value: 'FJ',
  flag: 'fj',
  text: 'Fiji'
}, {
  key: 'FI',
  value: 'FI',
  flag: 'fi',
  text: 'Finland'
}, {
  key: 'FR',
  value: 'FR',
  flag: 'fr',
  text: 'France'
}, {
  key: 'GF',
  value: 'GF',
  flag: 'gf',
  text: 'French Guiana'
}, {
  key: 'PF',
  value: 'PF',
  flag: 'pf',
  text: 'French Polynesia'
}, {
  key: 'TF',
  value: 'TF',
  flag: 'tf',
  text: 'French Territories'
}, {
  key: 'GA',
  value: 'GA',
  flag: 'ga',
  text: 'Gabon'
}, {
  key: 'GM',
  value: 'GM',
  flag: 'gm',
  text: 'Gambia'
}, {
  key: 'GE',
  value: 'GE',
  flag: 'ge',
  text: 'Georgia'
}, {
  key: 'DE',
  value: 'DE',
  flag: 'de',
  text: 'Germany'
}, {
  key: 'GH',
  value: 'GH',
  flag: 'gh',
  text: 'Ghana'
}, {
  key: 'GI',
  value: 'GI',
  flag: 'gi',
  text: 'Gibraltar'
}, {
  key: 'GR',
  value: 'GR',
  flag: 'gr',
  text: 'Greece'
}, {
  key: 'GL',
  value: 'GL',
  flag: 'gl',
  text: 'Greenland'
}, {
  key: 'GD',
  value: 'GD',
  flag: 'gd',
  text: 'Grenada'
}, {
  key: 'GP',
  value: 'GP',
  flag: 'gp',
  text: 'Guadeloupe'
}, {
  key: 'GU',
  value: 'GU',
  flag: 'gu',
  text: 'Guam'
}, {
  key: 'GT',
  value: 'GT',
  flag: 'gt',
  text: 'Guatemala'
}, {
  key: 'GW',
  value: 'GW',
  flag: 'gw',
  text: 'Guinea-Bissau'
}, {
  key: 'GN',
  value: 'GN',
  flag: 'gn',
  text: 'Guinea'
}, {
  key: 'GY',
  value: 'GY',
  flag: 'gy',
  text: 'Guyana'
}, {
  key: 'HT',
  value: 'HT',
  flag: 'ht',
  text: 'Haiti'
}, {
  key: 'HM',
  value: 'HM',
  flag: 'hm',
  text: 'Heard Island'
}, {
  key: 'HN',
  value: 'HN',
  flag: 'hn',
  text: 'Honduras'
}, {
  key: 'HK',
  value: 'HK',
  flag: 'hk',
  text: 'Hong Kong'
}, {
  key: 'HU',
  value: 'HU',
  flag: 'hu',
  text: 'Hungary'
}, {
  key: 'IS',
  value: 'IS',
  flag: 'is',
  text: 'Iceland'
}, {
  key: 'IN',
  value: 'IN',
  flag: 'in',
  text: 'India'
}, {
  key: 'IO',
  value: 'IO',
  flag: 'io',
  text: 'Indian Ocean Territory'
}, {
  key: 'ID',
  value: 'ID',
  flag: 'id',
  text: 'Indonesia'
}, {
  key: 'IR',
  value: 'IR',
  flag: 'ir',
  text: 'Iran'
}, {
  key: 'IQ',
  value: 'IQ',
  flag: 'iq',
  text: 'Iraq'
}, {
  key: 'IE',
  value: 'IE',
  flag: 'ie',
  text: 'Ireland'
}, {
  key: 'IL',
  value: 'IL',
  flag: 'il',
  text: 'Israel'
}, {
  key: 'IT',
  value: 'IT',
  flag: 'it',
  text: 'Italy'
}, {
  key: 'JM',
  value: 'JM',
  flag: 'jm',
  text: 'Jamaica'
}, {
  key: 'JP',
  value: 'JP',
  flag: 'jp',
  text: 'Japan'
}, {
  key: 'JO',
  value: 'JO',
  flag: 'jo',
  text: 'Jordan'
}, {
  key: 'KZ',
  value: 'KZ',
  flag: 'kz',
  text: 'Kazakhstan'
}, {
  key: 'KE',
  value: 'KE',
  flag: 'ke',
  text: 'Kenya'
}, {
  key: 'KI',
  value: 'KI',
  flag: 'ki',
  text: 'Kiribati'
}, {
  key: 'KW',
  value: 'KW',
  flag: 'kw',
  text: 'Kuwait'
}, {
  key: 'KG',
  value: 'KG',
  flag: 'kg',
  text: 'Kyrgyzstan'
}, {
  key: 'LA',
  value: 'LA',
  flag: 'la',
  text: 'Laos'
}, {
  key: 'LV',
  value: 'LV',
  flag: 'lv',
  text: 'Latvia'
}, {
  key: 'LB',
  value: 'LB',
  flag: 'lb',
  text: 'Lebanon'
}, {
  key: 'LS',
  value: 'LS',
  flag: 'ls',
  text: 'Lesotho'
}, {
  key: 'LR',
  value: 'LR',
  flag: 'lr',
  text: 'Liberia'
}, {
  key: 'LY',
  value: 'LY',
  flag: 'ly',
  text: 'Libya'
}, {
  key: 'LI',
  value: 'LI',
  flag: 'li',
  text: 'Liechtenstein'
}, {
  key: 'LT',
  value: 'LT',
  flag: 'lt',
  text: 'Lithuania'
}, {
  key: 'LU',
  value: 'LU',
  flag: 'lu',
  text: 'Luxembourg'
}, {
  key: 'MO',
  value: 'MO',
  flag: 'mo',
  text: 'Macau'
}, {
  key: 'MK',
  value: 'MK',
  flag: 'mk',
  text: 'Macedonia'
}, {
  key: 'MG',
  value: 'MG',
  flag: 'mg',
  text: 'Madagascar'
}, {
  key: 'MW',
  value: 'MW',
  flag: 'mw',
  text: 'Malawi'
}, {
  key: 'MY',
  value: 'MY',
  flag: 'my',
  text: 'Malaysia'
}, {
  key: 'MV',
  value: 'MV',
  flag: 'mv',
  text: 'Maldives'
}, {
  key: 'ML',
  value: 'ML',
  flag: 'ml',
  text: 'Mali'
}, {
  key: 'MT',
  value: 'MT',
  flag: 'mt',
  text: 'Malta'
}, {
  key: 'MH',
  value: 'MH',
  flag: 'mh',
  text: 'Marshall Islands'
}, {
  key: 'MQ',
  value: 'MQ',
  flag: 'mq',
  text: 'Martinique'
}, {
  key: 'MR',
  value: 'MR',
  flag: 'mr',
  text: 'Mauritania'
}, {
  key: 'MU',
  value: 'MU',
  flag: 'mu',
  text: 'Mauritius'
}, {
  key: 'YT',
  value: 'YT',
  flag: 'yt',
  text: 'Mayotte'
}, {
  key: 'MX',
  value: 'MX',
  flag: 'mx',
  text: 'Mexico'
}, {
  key: 'FM',
  value: 'FM',
  flag: 'fm',
  text: 'Micronesia'
}, {
  key: 'MD',
  value: 'MD',
  flag: 'md',
  text: 'Moldova'
}, {
  key: 'MC',
  value: 'MC',
  flag: 'mc',
  text: 'Monaco'
}, {
  key: 'MN',
  value: 'MN',
  flag: 'mn',
  text: 'Mongolia'
}, {
  key: 'ME',
  value: 'ME',
  flag: 'me',
  text: 'Montenegro'
}, {
  key: 'MS',
  value: 'MS',
  flag: 'ms',
  text: 'Montserrat'
}, {
  key: 'MA',
  value: 'MA',
  flag: 'ma',
  text: 'Morocco'
}, {
  key: 'MZ',
  value: 'MZ',
  flag: 'mz',
  text: 'Mozambique'
}, {
  key: 'NA',
  value: 'NA',
  flag: 'na',
  text: 'Namibia'
}, {
  key: 'NR',
  value: 'NR',
  flag: 'nr',
  text: 'Nauru'
}, {
  key: 'NP',
  value: 'NP',
  flag: 'np',
  text: 'Nepal'
}, {
  key: 'AN',
  value: 'AN',
  flag: 'an',
  text: 'Netherlands Antilles'
}, {
  key: 'NL',
  value: 'NL',
  flag: 'nl',
  text: 'Netherlands'
}, {
  key: 'NC',
  value: 'NC',
  flag: 'nc',
  text: 'New Caledonia'
}, {
  key: 'PG',
  value: 'PG',
  flag: 'pg',
  text: 'New Guinea'
}, {
  key: 'NZ',
  value: 'NZ',
  flag: 'nz',
  text: 'New Zealand'
}, {
  key: 'NI',
  value: 'NI',
  flag: 'ni',
  text: 'Nicaragua'
}, {
  key: 'NE',
  value: 'NE',
  flag: 'ne',
  text: 'Niger'
}, {
  key: 'NG',
  value: 'NG',
  flag: 'ng',
  text: 'Nigeria'
}, {
  key: 'NU',
  value: 'NU',
  flag: 'nu',
  text: 'Niue'
}, {
  key: 'NF',
  value: 'NF',
  flag: 'nf',
  text: 'Norfolk Island'
}, {
  key: 'KP',
  value: 'KP',
  flag: 'kp',
  text: 'North Korea'
}, {
  key: 'MP',
  value: 'MP',
  flag: 'mp',
  text: 'Northern Mariana Islands'
}, {
  key: 'NO',
  value: 'NO',
  flag: 'no',
  text: 'Norway'
}, {
  key: 'OM',
  value: 'OM',
  flag: 'om',
  text: 'Oman'
}, {
  key: 'PK',
  value: 'PK',
  flag: 'pk',
  text: 'Pakistan'
}, {
  key: 'PW',
  value: 'PW',
  flag: 'pw',
  text: 'Palau'
}, {
  key: 'PS',
  value: 'PS',
  flag: 'ps',
  text: 'Palestine'
}, {
  key: 'PA',
  value: 'PA',
  flag: 'pa',
  text: 'Panama'
}, {
  key: 'PY',
  value: 'PY',
  flag: 'py',
  text: 'Paraguay'
}, {
  key: 'PE',
  value: 'PE',
  flag: 'pe',
  text: 'Peru'
}, {
  key: 'PH',
  value: 'PH',
  flag: 'ph',
  text: 'Philippines'
}, {
  key: 'PN',
  value: 'PN',
  flag: 'pn',
  text: 'Pitcairn Islands'
}, {
  key: 'PL',
  value: 'PL',
  flag: 'pl',
  text: 'Poland'
}, {
  key: 'PT',
  value: 'PT',
  flag: 'pt',
  text: 'Portugal'
}, {
  key: 'PR',
  value: 'PR',
  flag: 'pr',
  text: 'Puerto Rico'
}, {
  key: 'QA',
  value: 'QA',
  flag: 'qa',
  text: 'Qatar'
}, {
  key: 'RE',
  value: 'RE',
  flag: 're',
  text: 'Reunion'
}, {
  key: 'RO',
  value: 'RO',
  flag: 'ro',
  text: 'Romania'
}, {
  key: 'RU',
  value: 'RU',
  flag: 'ru',
  text: 'Russia'
}, {
  key: 'RW',
  value: 'RW',
  flag: 'rw',
  text: 'Rwanda'
}, {
  key: 'SH',
  value: 'SH',
  flag: 'sh',
  text: 'Saint Helena'
}, {
  key: 'KN',
  value: 'KN',
  flag: 'kn',
  text: 'Saint Kitts and Nevis'
}, {
  key: 'LC',
  value: 'LC',
  flag: 'lc',
  text: 'Saint Lucia'
}, {
  key: 'PM',
  value: 'PM',
  flag: 'pm',
  text: 'Saint Pierre'
}, {
  key: 'VC',
  value: 'VC',
  flag: 'vc',
  text: 'Saint Vincent'
}, {
  key: 'WS',
  value: 'WS',
  flag: 'ws',
  text: 'Samoa'
}, {
  key: 'SM',
  value: 'SM',
  flag: 'sm',
  text: 'San Marino'
}, {
  key: 'GS',
  value: 'GS',
  flag: 'gs',
  text: 'Sandwich Islands'
}, {
  key: 'ST',
  value: 'ST',
  flag: 'st',
  text: 'Sao Tome'
}, {
  key: 'SA',
  value: 'SA',
  flag: 'sa',
  text: 'Saudi Arabia'
}, {
  key: 'SN',
  value: 'SN',
  flag: 'sn',
  text: 'Senegal'
}, {
  key: 'CS',
  value: 'CS',
  flag: 'cs',
  text: 'Serbia'
}, {
  key: 'RS',
  value: 'RS',
  flag: 'rs',
  text: 'Serbia'
}, {
  key: 'SC',
  value: 'SC',
  flag: 'sc',
  text: 'Seychelles'
}, {
  key: 'SL',
  value: 'SL',
  flag: 'sl',
  text: 'Sierra Leone'
}, {
  key: 'SG',
  value: 'SG',
  flag: 'sg',
  text: 'Singapore'
}, {
  key: 'SK',
  value: 'SK',
  flag: 'sk',
  text: 'Slovakia'
}, {
  key: 'SI',
  value: 'SI',
  flag: 'si',
  text: 'Slovenia'
}, {
  key: 'SB',
  value: 'SB',
  flag: 'sb',
  text: 'Solomon Islands'
}, {
  key: 'SO',
  value: 'SO',
  flag: 'so',
  text: 'Somalia'
}, {
  key: 'ZA',
  value: 'ZA',
  flag: 'za',
  text: 'South Africa'
}, {
  key: 'KR',
  value: 'KR',
  flag: 'kr',
  text: 'South Korea'
}, {
  key: 'ES',
  value: 'ES',
  flag: 'es',
  text: 'Spain'
}, {
  key: 'LK',
  value: 'LK',
  flag: 'lk',
  text: 'Sri Lanka'
}, {
  key: 'SD',
  value: 'SD',
  flag: 'sd',
  text: 'Sudan'
}, {
  key: 'SR',
  value: 'SR',
  flag: 'sr',
  text: 'Suriname'
}, {
  key: 'SJ',
  value: 'SJ',
  flag: 'sj',
  text: 'Svalbard'
}, {
  key: 'SZ',
  value: 'SZ',
  flag: 'sz',
  text: 'Swaziland'
}, {
  key: 'SE',
  value: 'SE',
  flag: 'se',
  text: 'Sweden'
}, {
  key: 'CH',
  value: 'CH',
  flag: 'ch',
  text: 'Switzerland'
}, {
  key: 'SY',
  value: 'SY',
  flag: 'sy',
  text: 'Syria'
}, {
  key: 'TW',
  value: 'TW',
  flag: 'tw',
  text: 'Taiwan'
}, {
  key: 'TJ',
  value: 'TJ',
  flag: 'tj',
  text: 'Tajikistan'
}, {
  key: 'TZ',
  value: 'TZ',
  flag: 'tz',
  text: 'Tanzania'
}, {
  key: 'TH',
  value: 'TH',
  flag: 'th',
  text: 'Thailand'
}, {
  key: 'TL',
  value: 'TL',
  flag: 'tl',
  text: 'Timorleste'
}, {
  key: 'TG',
  value: 'TG',
  flag: 'tg',
  text: 'Togo'
}, {
  key: 'TK',
  value: 'TK',
  flag: 'tk',
  text: 'Tokelau'
}, {
  key: 'TO',
  value: 'TO',
  flag: 'to',
  text: 'Tonga'
}, {
  key: 'TT',
  value: 'TT',
  flag: 'tt',
  text: 'Trinidad'
}, {
  key: 'TN',
  value: 'TN',
  flag: 'tn',
  text: 'Tunisia'
}, {
  key: 'TR',
  value: 'TR',
  flag: 'tr',
  text: 'Turkey'
}, {
  key: 'TM',
  value: 'TM',
  flag: 'tm',
  text: 'Turkmenistan'
}, {
  key: 'TV',
  value: 'TV',
  flag: 'tv',
  text: 'Tuvalu'
}, {
  key: 'UG',
  value: 'UG',
  flag: 'ug',
  text: 'Uganda'
}, {
  key: 'UA',
  value: 'UA',
  flag: 'ua',
  text: 'Ukraine'
}, {
  key: 'AE',
  value: 'AE',
  flag: 'ae',
  text: 'United Arab Emirates'
}, {
  key: 'US',
  value: 'US',
  flag: 'us',
  text: 'United States'
}, {
  key: 'UY',
  value: 'UY',
  flag: 'uy',
  text: 'Uruguay'
}, {
  key: 'UM',
  value: 'UM',
  flag: 'um',
  text: 'Us Minor Islands'
}, {
  key: 'VI',
  value: 'VI',
  flag: 'vi',
  text: 'Us Virgin Islands'
}, {
  key: 'UZ',
  value: 'UZ',
  flag: 'uz',
  text: 'Uzbekistan'
}, {
  key: 'VU',
  value: 'VU',
  flag: 'vu',
  text: 'Vanuatu'
}, {
  key: 'VA',
  value: 'VA',
  flag: 'va',
  text: 'Vatican City'
}, {
  key: 'VE',
  value: 'VE',
  flag: 've',
  text: 'Venezuela'
}, {
  key: 'VN',
  value: 'VN',
  flag: 'vn',
  text: 'Vietnam'
}, {
  key: 'WF',
  value: 'WF',
  flag: 'wf',
  text: 'Wallis and Futuna'
}, {
  key: 'EH',
  value: 'EH',
  flag: 'eh',
  text: 'Western Sahara'
}, {
  key: 'YE',
  value: 'YE',
  flag: 'ye',
  text: 'Yemen'
}, {
  key: 'ZM',
  value: 'ZM',
  flag: 'zm',
  text: 'Zambia'
}, {
  key: 'ZW',
  value: 'ZW',
  flag: 'zw',
  text: 'Zimbabwe'
}];

function fetchKycCountries(_x) {
  return _fetchKycCountries.apply(this, arguments);
}
/**
 * FAILED
 * UNSUBMITTED
 * PENDING
 * PASSED
 */

function _fetchKycCountries() {
  _fetchKycCountries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var chain, url, _yield$this$get, countries, countriesById;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            chain = _ref.chain;
            url = this.constants.BLOKS_API + "/" + chain + "/kyc?type=countries&chain=" + chain;
            _context.next = 4;
            return this.get(url);

          case 4:
            _yield$this$get = _context.sent;
            countries = _yield$this$get.content;
            countriesById = countries.reduce(function (acc, country) {
              acc[country.id] = country;
              return acc;
            }, {});
            return _context.abrupt("return", countryOptions.filter(function (countryOption) {
              return countriesById[countryOption.key];
            }));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _fetchKycCountries.apply(this, arguments);
}

function checkUserKycStatus(_x2) {
  return _checkUserKycStatus.apply(this, arguments);
}

function _checkUserKycStatus() {
  _checkUserKycStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref2) {
    var _this = this;

    var chain, actor, expectedTier;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            chain = _ref2.chain, actor = _ref2.actor, expectedTier = _ref2.expectedTier;

            if (!(!chain || !actor || !expectedTier)) {
              _context4.next = 3;
              break;
            }

            throw new Error('Invalid parameters');

          case 3:
            return _context4.abrupt("return", new Promise( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject) {
                var getStatus;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        // Get all KYC records for user
                        getStatus = /*#__PURE__*/function () {
                          var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                            var _yield$_this$rpc$isLi, userInfo, url, kyc, matchedTier, status;

                            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                              while (1) {
                                switch (_context2.prev = _context2.next) {
                                  case 0:
                                    _context2.next = 2;
                                    return _this.rpc.isLightKYCVerified(actor);

                                  case 2:
                                    _yield$_this$rpc$isLi = _context2.sent;
                                    userInfo = _yield$_this$rpc$isLi[0];

                                    if (!(userInfo && userInfo.isLightKYCVerified)) {
                                      _context2.next = 6;
                                      break;
                                    }

                                    return _context2.abrupt("return", resolve(KycStatus.PASSED));

                                  case 6:
                                    url = _this.constants.BLOKS_API + "/" + chain + "/kyc?type=status&chain=" + chain + "&actor=" + actor;
                                    _context2.next = 9;
                                    return _this.get(url);

                                  case 9:
                                    kyc = _context2.sent;

                                    if (!(!kyc || !kyc.length)) {
                                      _context2.next = 12;
                                      break;
                                    }

                                    return _context2.abrupt("return", reject(new Error('Could not fetch KYC record')));

                                  case 12:
                                    // Find relevant KYC record
                                    matchedTier = kyc.find(function (_ref5) {
                                      var tier = _ref5.tier;
                                      return tier === String(expectedTier);
                                    });

                                    if (matchedTier) {
                                      _context2.next = 15;
                                      break;
                                    }

                                    return _context2.abrupt("return", reject(new Error('No kyc data matching tier found')));

                                  case 15:
                                    // Unwrap kyc data
                                    status = matchedTier.status;

                                    if (matchedTier.status) {
                                      _context2.next = 18;
                                      break;
                                    }

                                    return _context2.abrupt("return", reject(new Error('KYC Status not found')));

                                  case 18:
                                    if (!(status === KycStatus.PENDING)) {
                                      _context2.next = 22;
                                      break;
                                    }

                                    setTimeout(function () {
                                      return getStatus();
                                    }, 1000 * 2);
                                    _context2.next = 23;
                                    break;

                                  case 22:
                                    return _context2.abrupt("return", resolve(status));

                                  case 23:
                                  case "end":
                                    return _context2.stop();
                                }
                              }
                            }, _callee2);
                          }));

                          return function getStatus() {
                            return _ref4.apply(this, arguments);
                          };
                        }();

                        getStatus();

                      case 2:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x4, _x5) {
                return _ref3.apply(this, arguments);
              };
            }()));

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _checkUserKycStatus.apply(this, arguments);
}

function applyForKyc(_x3) {
  return _applyForKyc.apply(this, arguments);
}

function _applyForKyc() {
  _applyForKyc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(params) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            url = this.constants.BLOKS_API + "/" + params.chain + "/kyc";
            _context5.next = 3;
            return this.post(url, _extends({
              type: 'apply'
            }, params));

          case 3:
            data = _context5.sent;

            if (!data) {
              _context5.next = 8;
              break;
            }

            return _context5.abrupt("return", data);

          case 8:
            throw new Error('Could not apply for KYC');

          case 9:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _applyForKyc.apply(this, arguments);
}

var chainInfoParser = /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.object({
  chainId: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  explorerUrl: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  explorerName: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  resourceTokenSymbol: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  resourceTokenContract: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  systemTokenSymbol: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  systemTokenContract: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  rpcEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string()),
  actionsRpcEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string()),
  hyperionEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string()),
  lightEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string())
});

function getChainInfo() {
  return _getChainInfo.apply(this, arguments);
}

function _getChainInfo() {
  _getChainInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = this.constants.CHAIN === 'proton-test' ? 'https://raw.githubusercontent.com/ProtonProtocol/chain-info/main/testnet.json' : 'https://raw.githubusercontent.com/ProtonProtocol/chain-info/main/mainnet.json';
            _context.prev = 1;
            _context.next = 4;
            return this.get(url, {});

          case 4:
            data = _context.sent;
            return _context.abrupt("return", chainInfoParser.parse(data));

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 8]]);
  }));
  return _getChainInfo.apply(this, arguments);
}

function getTokenPrices() {
  return _getTokenPrices.apply(this, arguments);
}

function _getTokenPrices() {
  _getTokenPrices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v1/chain/exchange-rates/info";
            _context2.prev = 1;
            _context2.next = 4;
            return this.get(url);

          case 4:
            data = _context2.sent;
            return _context2.abrupt("return", _proton_wrap_constants__WEBPACK_IMPORTED_MODULE_7__.exchangeRatesParser.parse(data));

          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](1);
            throw new Error("Could not fetch exchange rates");

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[1, 8]]);
  }));
  return _getTokenPrices.apply(this, arguments);
}

function getWithdrawalFee(_x) {
  return _getWithdrawalFee.apply(this, arguments);
}

function _getWithdrawalFee() {
  _getWithdrawalFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref) {
    var currency, network, url, data;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            currency = _ref.currency, network = _ref.network;
            url = this.constants.METAL_PROTON_ENDPOINT + "/v1/swaps/calculate-estimated-fee";
            _context3.prev = 2;
            _context3.next = 5;
            return this.post(url, {
              currency: currency,
              network: network
            });

          case 5:
            data = _context3.sent;
            return _context3.abrupt("return", _proton_wrap_constants__WEBPACK_IMPORTED_MODULE_7__.withdrawalFeeQuoteParser.parse(data));

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            console.log(_context3.t0);
            return _context3.abrupt("return", undefined);

          case 13:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[2, 9]]);
  }));
  return _getWithdrawalFee.apply(this, arguments);
}

function currentLocation() {
  return _currentLocation.apply(this, arguments);
}

function _currentLocation() {
  _currentLocation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    var url;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v1/kyc/ip-info";
            _context4.next = 3;
            return this.get(url);

          case 3:
            return _context4.abrupt("return", _context4.sent);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _currentLocation.apply(this, arguments);
}

function getAvailableFeatures(_x2) {
  return _getAvailableFeatures.apply(this, arguments);
}

function _getAvailableFeatures() {
  _getAvailableFeatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var url;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + ("/v2/kyc/by-chain-account/" + account + "/available-features");
            _context5.next = 3;
            return this.get(url);

          case 3:
            return _context5.abrupt("return", _context5.sent);

          case 4:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _getAvailableFeatures.apply(this, arguments);
}

function createAccount(_x3) {
  return _createAccount.apply(this, arguments);
}

function _createAccount() {
  _createAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v2/users/create";
            _context6.next = 3;
            return this.post(url, params);

          case 3:
            data = _context6.sent;
            return _context6.abrupt("return", data);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _createAccount.apply(this, arguments);
}

function loginAccount(_x4) {
  return _loginAccount.apply(this, arguments);
}

function _loginAccount() {
  _loginAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(params) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v2/users/login";
            _context7.next = 3;
            return this.post(url, params);

          case 3:
            data = _context7.sent;
            return _context7.abrupt("return", data);

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _loginAccount.apply(this, arguments);
}

function otcQuote(_x) {
  return _otcQuote.apply(this, arguments);
}

function _otcQuote() {
  _otcQuote = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = this.constants.SWAP_URL + ("/v1/quote/" + body.baseSymbol + "/" + body.baseAmount + "/" + body.quoteSymbol);
            _context.next = 3;
            return this.get(url);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _otcQuote.apply(this, arguments);
}

function otcOrder(_x2) {
  return _otcOrder.apply(this, arguments);
}

function _otcOrder() {
  _otcOrder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id) {
    var url;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = this.constants.SWAP_URL + ("/v1/order/" + id);
            _context2.next = 3;
            return this.get(url);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _otcOrder.apply(this, arguments);
}

function generateAddress(_x) {
  return _generateAddress.apply(this, arguments);
}

function _generateAddress() {
  _generateAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + '/address/generate';
            _context.next = 3;
            return this.post(url, body);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _generateAddress.apply(this, arguments);
}

function deleteAddress(_x2) {
  return _deleteAddress.apply(this, arguments);
}

function _deleteAddress() {
  _deleteAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + '/address/delete';
            _context2.next = 3;
            return this.post(url, body);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _deleteAddress.apply(this, arguments);
}

function withdrawMetal(_x3) {
  return _withdrawMetal.apply(this, arguments);
}

function _withdrawMetal() {
  _withdrawMetal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + '/withdraw';
            _context3.next = 3;
            return this.post(url, body);

          case 3:
            return _context3.abrupt("return", _context3.sent);

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _withdrawMetal.apply(this, arguments);
}

function withdrawalHistoryMetal(_x4) {
  return _withdrawalHistoryMetal.apply(this, arguments);
}

function _withdrawalHistoryMetal() {
  _withdrawalHistoryMetal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var url;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + ("/withdrawals/" + account);
            _context4.next = 3;
            return this.get(url);

          case 3:
            return _context4.abrupt("return", _context4.sent);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _withdrawalHistoryMetal.apply(this, arguments);
}

function getXprTotalStakedAndApr() {
  return _getXprTotalStakedAndApr.apply(this, arguments);
}

function _getXprTotalStakedAndApr() {
  _getXprTotalStakedAndApr = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$Promise$all, supply, totalStakedUnparsed, _yield$Promise$all$, continuous_rate, inflation_pay_factor, votepay_factor, additionalInflation, new_tokens, to_yieldfarms, bpandsavings, to_producers, to_producers_block, to_producers_vote, savings, to_savings, to_consortium, totalStaked, apr;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return Promise.all([this.getTokenSupply(this.constants.EOSIO_TOKEN, this.constants.CORE_SYMBOL), this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'globalsd',
              limit: 1
            }).then(function (res) {
              return res.rows[0];
            }), this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'global4',
              limit: 1
            }).then(function (res) {
              return res.rows[0];
            })]);

          case 3:
            _yield$Promise$all = _context.sent;
            supply = _yield$Promise$all[0].supply;
            totalStakedUnparsed = _yield$Promise$all[1].totalrstaked;
            _yield$Promise$all$ = _yield$Promise$all[2];
            continuous_rate = _yield$Promise$all$.continuous_rate;
            inflation_pay_factor = _yield$Promise$all$.inflation_pay_factor;
            votepay_factor = _yield$Promise$all$.votepay_factor;
            additionalInflation = +continuous_rate * supply;
            new_tokens = additionalInflation;
            to_yieldfarms = new_tokens / 4;
            bpandsavings = new_tokens - to_yieldfarms;
            to_producers = bpandsavings * (10000 / inflation_pay_factor);
            to_producers_block = to_producers * (10000 / votepay_factor);
            to_producers_vote = to_producers - to_producers_block;
            savings = bpandsavings - to_producers;
            to_savings = 2 * savings / 3;
            to_consortium = savings - to_savings;
            totalStaked = +totalStakedUnparsed / Math.pow(10, this.constants.CORE_PRECISION);
            apr = to_savings / totalStaked * 100;
            return _context.abrupt("return", {
              supply: supply,
              yieldFarming: to_yieldfarms,
              producers: to_producers,
              producersBlock: to_producers_block,
              producersVote: to_producers_vote,
              consortium: to_consortium,
              staking: to_savings,
              totalStaked: totalStaked,
              apr: apr
            });

          case 25:
            _context.prev = 25;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", 0);

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 25]]);
  }));
  return _getXprTotalStakedAndApr.apply(this, arguments);
}

function getXprVoter(_x) {
  return _getXprVoter.apply(this, arguments);
}

function _getXprVoter() {
  _getXprVoter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'votersxpr',
              limit: 1
            });

          case 3:
            _yield$this$rpc$get_t = _context2.sent;
            rows = _yield$this$rpc$get_t.rows;

            if (!(rows && rows.length && rows[0].owner === account)) {
              _context2.next = 9;
              break;
            }

            return _context2.abrupt("return", rows[0]);

          case 9:
            return _context2.abrupt("return", undefined);

          case 10:
            _context2.next = 16;
            break;

          case 12:
            _context2.prev = 12;
            _context2.t0 = _context2["catch"](0);
            console.log(_context2.t0);
            return _context2.abrupt("return", undefined);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 12]]);
  }));
  return _getXprVoter.apply(this, arguments);
}

function getXprAccountStakes(_x2) {
  return _getXprAccountStakes.apply(this, arguments);
}

function _getXprAccountStakes() {
  _getXprAccountStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var stakes, _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            stakes = [];
            _context3.prev = 1;
            _context3.next = 4;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'delxpr',
              limit: -1
            });

          case 4:
            _yield$this$rpc$get_t2 = _context3.sent;
            rows = _yield$this$rpc$get_t2.rows;

            if (rows && rows.length) {
              stakes = rows;
            }

            _context3.next = 12;
            break;

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](1);
            console.log(_context3.t0);

          case 12:
            return _context3.abrupt("return", stakes);

          case 13:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[1, 9]]);
  }));
  return _getXprAccountStakes.apply(this, arguments);
}

function getXprAccountRefund(_x3) {
  return _getXprAccountRefund.apply(this, arguments);
}

function _getXprAccountRefund() {
  _getXprAccountRefund = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var refund, _yield$this$rpc$get_t3, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'refundsxpr',
              limit: -1
            });

          case 3:
            _yield$this$rpc$get_t3 = _context4.sent;
            rows = _yield$this$rpc$get_t3.rows;

            if (rows && rows.length) {
              refund = rows[0];
              refund.quantity = +refund.quantity.split(' ')[0];
            }

            _context4.next = 11;
            break;

          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](0);
            console.log(_context4.t0);

          case 11:
            return _context4.abrupt("return", refund);

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 8]]);
  }));
  return _getXprAccountRefund.apply(this, arguments);
}

function getXprOracleData(_x4) {
  return _getXprOracleData.apply(this, arguments);
}

function _getXprOracleData() {
  _getXprOracleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(oracleIndex) {
    var _yield$this$rpc$get_t4, rows;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'data',
              limit: 1,
              lower_bound: oracleIndex,
              upper_bound: oracleIndex
            });

          case 3:
            _yield$this$rpc$get_t4 = _context5.sent;
            rows = _yield$this$rpc$get_t4.rows;

            if (!(rows && rows.length)) {
              _context5.next = 9;
              break;
            }

            return _context5.abrupt("return", rows[0]);

          case 9:
            return _context5.abrupt("return", undefined);

          case 10:
            _context5.next = 16;
            break;

          case 12:
            _context5.prev = 12;
            _context5.t0 = _context5["catch"](0);
            console.log(_context5.t0);
            return _context5.abrupt("return", undefined);

          case 16:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 12]]);
  }));
  return _getXprOracleData.apply(this, arguments);
}

function getAllOracleFeeds(_x5) {
  return _getAllOracleFeeds.apply(this, arguments);
}

function _getAllOracleFeeds() {
  _getAllOracleFeeds = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(lower_bound) {
    var _yield$this$rpc$get_t5, rows, more, next_key, restOfRows;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (lower_bound === void 0) {
              lower_bound = undefined;
            }

            _context6.prev = 1;
            _context6.next = 4;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'feeds',
              limit: -1,
              lower_bound: lower_bound
            });

          case 4:
            _yield$this$rpc$get_t5 = _context6.sent;
            rows = _yield$this$rpc$get_t5.rows;
            more = _yield$this$rpc$get_t5.more;
            next_key = _yield$this$rpc$get_t5.next_key;

            if (!more) {
              _context6.next = 15;
              break;
            }

            _context6.next = 11;
            return this.getAllOracleFeeds(next_key);

          case 11:
            restOfRows = _context6.sent;
            return _context6.abrupt("return", rows.concat(restOfRows));

          case 15:
            return _context6.abrupt("return", rows);

          case 16:
            _context6.next = 22;
            break;

          case 18:
            _context6.prev = 18;
            _context6.t0 = _context6["catch"](1);
            console.log(_context6.t0);
            return _context6.abrupt("return", []);

          case 22:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[1, 18]]);
  }));
  return _getAllOracleFeeds.apply(this, arguments);
}

function getSpecificOracleData(_x6) {
  return _getSpecificOracleData.apply(this, arguments);
} // pub

function _getSpecificOracleData() {
  _getSpecificOracleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(feed_index) {
    var _yield$this$rpc$get_t6, rows;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'data',
              limit: -1,
              lower_bound: feed_index,
              upper_bound: feed_index
            });

          case 3:
            _yield$this$rpc$get_t6 = _context7.sent;
            rows = _yield$this$rpc$get_t6.rows;

            if (!(rows && rows.length && rows[0].feed_index === feed_index)) {
              _context7.next = 7;
              break;
            }

            return _context7.abrupt("return", rows[0]);

          case 7:
            _context7.next = 12;
            break;

          case 9:
            _context7.prev = 9;
            _context7.t0 = _context7["catch"](0);
            console.log(_context7.t0);

          case 12:
            return _context7.abrupt("return", undefined);

          case 13:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 9]]);
  }));
  return _getSpecificOracleData.apply(this, arguments);
}

function getAllOracleData(_x7) {
  return _getAllOracleData.apply(this, arguments);
}

function _getAllOracleData() {
  _getAllOracleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(lower_bound) {
    var _yield$this$rpc$get_t7, rows, more, next_key;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'data',
              limit: -1,
              lower_bound: lower_bound
            });

          case 3:
            _yield$this$rpc$get_t7 = _context8.sent;
            rows = _yield$this$rpc$get_t7.rows;
            more = _yield$this$rpc$get_t7.more;
            next_key = _yield$this$rpc$get_t7.next_key;

            if (!more) {
              _context8.next = 13;
              break;
            }

            _context8.t0 = rows;
            _context8.next = 11;
            return this.getAllOracleData(next_key);

          case 11:
            _context8.t1 = _context8.sent;
            rows = _context8.t0.concat.call(_context8.t0, _context8.t1);

          case 13:
            return _context8.abrupt("return", rows);

          case 16:
            _context8.prev = 16;
            _context8.t2 = _context8["catch"](0);
            console.log(_context8.t2);
            return _context8.abrupt("return", []);

          case 20:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[0, 16]]);
  }));
  return _getAllOracleData.apply(this, arguments);
}

function getProtonAvatars(_x8, _x9) {
  return _getProtonAvatars.apply(this, arguments);
}

function _getProtonAvatars() {
  _getProtonAvatars = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(account, limit) {
    var result;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (limit === void 0) {
              limit = 10;
            }

            if (!(this.constants.CHAIN.indexOf('proton') !== -1)) {
              _context9.next = 12;
              break;
            }

            _context9.prev = 2;
            _context9.next = 5;
            return this.rpc.get_table_rows({
              json: true,
              code: 'eosio.proton',
              scope: 'eosio.proton',
              table: 'usersinfo',
              table_key: '',
              key_type: 'i64',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 1,
              limit: limit
            });

          case 5:
            result = _context9.sent;
            return _context9.abrupt("return", result.rows);

          case 9:
            _context9.prev = 9;
            _context9.t0 = _context9["catch"](2);
            console.log('getProtonAvatar error', _context9.t0);

          case 12:
            return _context9.abrupt("return", []);

          case 13:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this, [[2, 9]]);
  }));
  return _getProtonAvatars.apply(this, arguments);
}

function getProtonAvatar(_x10) {
  return _getProtonAvatar.apply(this, arguments);
}

function _getProtonAvatar() {
  _getProtonAvatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            if (!(this.constants.CHAIN.indexOf('proton') !== -1)) {
              _context10.next = 11;
              break;
            }

            _context10.prev = 1;
            _context10.next = 4;
            return this.rpc.get_table_rows({
              json: true,
              code: 'eosio.proton',
              scope: 'eosio.proton',
              table: 'usersinfo',
              table_key: '',
              key_type: 'i64',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 1,
              limit: 1
            });

          case 4:
            result = _context10.sent;
            return _context10.abrupt("return", result.rows.length > 0 && result.rows[0].acc === account ? result.rows[0] : undefined);

          case 8:
            _context10.prev = 8;
            _context10.t0 = _context10["catch"](1);
            console.log('getProtonAvatar error', _context10.t0);

          case 11:
            return _context10.abrupt("return", undefined);

          case 12:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, this, [[1, 8]]);
  }));
  return _getProtonAvatar.apply(this, arguments);
}

function getRentbwState() {
  return _getRentbwState.apply(this, arguments);
}

function _getRentbwState() {
  _getRentbwState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: 0,
              table: 'powup.state',
              limit: 1
            });

          case 2:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context.abrupt("return", rows[0]);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getRentbwState.apply(this, arguments);
}

function delegatedBandwidth(_x, _x2) {
  return _delegatedBandwidth.apply(this, arguments);
}

function _delegatedBandwidth() {
  _delegatedBandwidth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account, lower_bound) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'delband',
              table_key: '',
              limit: -1,
              lower_bound: lower_bound,
              key_type: 'i64',
              index_position: 1
            }));

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _delegatedBandwidth.apply(this, arguments);
}

function getAccountDelegatedBandwidth(_x3) {
  return _getAccountDelegatedBandwidth.apply(this, arguments);
}

function _getAccountDelegatedBandwidth() {
  _getAccountDelegatedBandwidth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var more, rows, result, lower_bound;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            more = true;
            rows = [];
            result = null;
            lower_bound = '';
            _context3.prev = 4;

          case 5:
            _context3.next = 7;
            return this.delegatedBandwidth(account, lower_bound);

          case 7:
            result = _context3.sent;
            more = result.more;
            rows = rows.concat(result.rows);

            if (more) {
              lower_bound = new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(rows[rows.length - 1].to, false)).plus(1).toString();
            }

          case 11:
            if (more) {
              _context3.next = 5;
              break;
            }

          case 12:
            _context3.next = 17;
            break;

          case 14:
            _context3.prev = 14;
            _context3.t0 = _context3["catch"](4);
            console.log(_context3.t0);

          case 17:
            return _context3.abrupt("return", rows);

          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[4, 14]]);
  }));
  return _getAccountDelegatedBandwidth.apply(this, arguments);
}

function getAccountResources(_x4) {
  return _getAccountResources.apply(this, arguments);
}

function _getAccountResources() {
  _getAccountResources = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'userres',
              table_key: '',
              limit: 1
            });

          case 2:
            _yield$this$rpc$get_t2 = _context4.sent;
            rows = _yield$this$rpc$get_t2.rows;
            return _context4.abrupt("return", rows[0]);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getAccountResources.apply(this, arguments);
}

function getRamPriceInEos() {
  return _getRamPriceInEos.apply(this, arguments);
}

function _getRamPriceInEos() {
  _getRamPriceInEos = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var ram, baseString, base, quoteString, quote, price, ramPriceEos;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rammarket',
              table_key: '',
              limit: 10
            });

          case 3:
            ram = _context5.sent;
            // Amount of RAM bytes in use
            baseString = ram.rows[0].base.balance;
            base = +baseString.substr(0, baseString.indexOf(' ')); // Amount of EOS in the RAM collector

            quoteString = ram.rows[0].quote.balance;
            quote = quoteString.substr(0, quoteString.indexOf(' ')); // Price in kb

            price = quote / base;
            ramPriceEos = Number(price.toFixed(8)) * 1024;
            return _context5.abrupt("return", ramPriceEos);

          case 13:
            _context5.prev = 13;
            _context5.t0 = _context5["catch"](0);
            console.log(_context5.t0);

          case 16:
            return _context5.abrupt("return", 0);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 13]]);
  }));
  return _getRamPriceInEos.apply(this, arguments);
}

function getEosTopStakes(_x) {
  return _getEosTopStakes.apply(this, arguments);
}

function _getEosTopStakes() {
  _getEosTopStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(limit) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (limit === void 0) {
              limit = 500;
            }

            return _context.abrupt("return", this.lightApi.get_topstake(limit));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getEosTopStakes.apply(this, arguments);
}

function getEosTopRams(_x2) {
  return _getEosTopRams.apply(this, arguments);
}

function _getEosTopRams() {
  _getEosTopRams = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(limit) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (limit === void 0) {
              limit = 500;
            }

            return _context2.abrupt("return", this.lightApi.get_topram(limit));

          case 2:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getEosTopRams.apply(this, arguments);
}

function getCurrentNameBids(_x3, _x4) {
  return _getCurrentNameBids.apply(this, arguments);
}

function _getCurrentNameBids() {
  _getCurrentNameBids = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(lower_bound, upper_bound) {
    var _yield$this$rpc$get_t, rows, more, next_key;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (lower_bound === void 0) {
              lower_bound = '';
            }

            if (upper_bound === void 0) {
              upper_bound = '';
            }

            _context3.next = 4;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'namebids',
              key_type: 'i64',
              lower_bound: lower_bound && lower_bound.length <= 12 ? (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(lower_bound, true) : lower_bound,
              upper_bound: upper_bound && upper_bound.length <= 12 ? (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(upper_bound, true) : upper_bound,
              index_position: 1,
              limit: -1
            });

          case 4:
            _yield$this$rpc$get_t = _context3.sent;
            rows = _yield$this$rpc$get_t.rows;
            more = _yield$this$rpc$get_t.more;
            next_key = _yield$this$rpc$get_t.next_key;

            if (!more) {
              _context3.next = 14;
              break;
            }

            _context3.t0 = rows;
            _context3.next = 12;
            return this.getCurrentNameBids(next_key, upper_bound);

          case 12:
            _context3.t1 = _context3.sent;
            rows = _context3.t0.concat.call(_context3.t0, _context3.t1);

          case 14:
            return _context3.abrupt("return", rows);

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getCurrentNameBids.apply(this, arguments);
}

var chainToRexMap = {
  jungle: 'jungle',
  bos: 'bos',
  eos: 'mainnet',
  telos: 'telos'
};
function getRexQueued(_x) {
  return _getRexQueued.apply(this, arguments);
}

function _getRexQueued() {
  _getRexQueued = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexqueue',
              limit: 1,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)
            });

          case 3:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;

            if (!(rows && rows.length && rows[0].owner === account)) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return", rows[0]);

          case 7:
            _context.next = 12;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);

          case 12:
            return _context.abrupt("return", undefined);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 9]]);
  }));
  return _getRexQueued.apply(this, arguments);
}

function getRexPool() {
  return _getRexPool.apply(this, arguments);
}

function _getRexPool() {
  _getRexPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var _yield$this$rpc$get_t2, rows, pool, assetToNumber, total_lent, total_lendable, total_unlent, total_rex, total_rent, lent_percent, rex_price, resource_price;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexpool'
            });

          case 2:
            _yield$this$rpc$get_t2 = _context2.sent;
            rows = _yield$this$rpc$get_t2.rows;
            pool = rows[0];

            assetToNumber = function assetToNumber(asset) {
              return Number(asset.split(' ')[0]);
            };

            total_lent = assetToNumber(pool.total_lent);
            total_lendable = assetToNumber(pool.total_lendable);
            total_unlent = assetToNumber(pool.total_unlent);
            total_rex = assetToNumber(pool.total_rex);
            total_rent = assetToNumber(pool.total_rent);
            lent_percent = (0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.multiply)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.divide)(total_lent, total_lendable), 100);
            rex_price = +(0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.divide)(total_lendable, total_rex);
            resource_price = +(0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.divide)(total_unlent, total_rent + 1);
            return _context2.abrupt("return", {
              version: pool.version,
              namebid_proceeds: assetToNumber(pool.namebid_proceeds),
              loan_num: pool.loan_num,
              total_lent: total_lent,
              total_unlent: total_unlent,
              total_rent: total_rent,
              total_lendable: total_lendable,
              total_rex: total_rex,
              lent_percent: lent_percent,
              rex_price: rex_price,
              resource_price: resource_price
            });

          case 15:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getRexPool.apply(this, arguments);
}

function getRexBalance(_x2) {
  return _getRexBalance.apply(this, arguments);
}

function _getRexBalance() {
  _getRexBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var _yield$this$rpc$get_t3, rows, bal;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexbal',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)
            });

          case 2:
            _yield$this$rpc$get_t3 = _context3.sent;
            rows = _yield$this$rpc$get_t3.rows;
            bal = rows[0];
            return _context3.abrupt("return", bal.owner === account ? bal : undefined);

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getRexBalance.apply(this, arguments);
}

function getRexCpuLoans(_x3) {
  return _getRexCpuLoans.apply(this, arguments);
}

function _getRexCpuLoans() {
  _getRexCpuLoans = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var _yield$this$rpc$get_t4, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'cpuloan',
              table_key: 'byowner',
              key_type: 'i64',
              limit: 100,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 3
            });

          case 2:
            _yield$this$rpc$get_t4 = _context4.sent;
            rows = _yield$this$rpc$get_t4.rows;
            return _context4.abrupt("return", rows.filter(function (row) {
              return row.from === account;
            }));

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getRexCpuLoans.apply(this, arguments);
}

function getRexNetLoans(_x4) {
  return _getRexNetLoans.apply(this, arguments);
}

function _getRexNetLoans() {
  _getRexNetLoans = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var _yield$this$rpc$get_t5, rows;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'netloan',
              table_key: 'byowner',
              key_type: 'i64',
              limit: 100,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 3
            });

          case 2:
            _yield$this$rpc$get_t5 = _context5.sent;
            rows = _yield$this$rpc$get_t5.rows;
            return _context5.abrupt("return", rows.filter(function (row) {
              return row.from === account;
            }));

          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _getRexNetLoans.apply(this, arguments);
}

function getEosDepositedIntoRex(_x5) {
  return _getEosDepositedIntoRex.apply(this, arguments);
}

function _getEosDepositedIntoRex() {
  _getEosDepositedIntoRex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(account) {
    var _yield$this$rpc$get_t6, rows, row;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexfund',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)
            });

          case 2:
            _yield$this$rpc$get_t6 = _context6.sent;
            rows = _yield$this$rpc$get_t6.rows;
            row = rows[0];
            return _context6.abrupt("return", row.owner === account ? Number(row.balance.split(' ')[0]) : 0);

          case 6:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _getEosDepositedIntoRex.apply(this, arguments);
}

function getRexReturnRate(_x6) {
  return _getRexReturnRate.apply(this, arguments);
}

function _getRexReturnRate() {
  _getRexReturnRate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(type) {
    var chain, _yield$this$post, data;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (type === void 0) {
              type = 'mpr';
            }

            chain = chainToRexMap[this.constants.CHAIN];

            if (!chain) {
              _context7.next = 14;
              break;
            }

            _context7.next = 5;
            return this.post('https://www.api.bloks.io/graphql/v1alpha1/graphql', {
              query: "query {\n        " + chain + "_" + type + " {\n          " + type + "\n        }\n      }",
              variables: null
            });

          case 5:
            _yield$this$post = _context7.sent;
            data = _yield$this$post.data;

            if (!data) {
              _context7.next = 11;
              break;
            }

            return _context7.abrupt("return", Math.abs(data[chain + "_" + type][0][type]));

          case 11:
            return _context7.abrupt("return", 0);

          case 12:
            _context7.next = 15;
            break;

          case 14:
            return _context7.abrupt("return", 0);

          case 15:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _getRexReturnRate.apply(this, arguments);
}

function getRexPriceChart() {
  return _getRexPriceChart.apply(this, arguments);
}

function _getRexPriceChart() {
  _getRexPriceChart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
    var chain, current_time, seven_days_ago, _yield$this$post2, data;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            chain = chainToRexMap[this.constants.CHAIN];

            if (!chain) {
              _context8.next = 15;
              break;
            }

            current_time = (0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.formatDate)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.utcTime)());
            seven_days_ago = (0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.formatDate)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.utcTime)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.startDate)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.time)(), 7)));
            _context8.next = 6;
            return this.post('https://www.api.bloks.io/graphql/v1alpha1/graphql', {
              query: "query {\n        " + chain + "_pricechart(args: {\n          from_time: \"" + seven_days_ago + "\",\n          to_time: \"" + current_time + "\"\n        }) {\n          t\n          o\n          h\n          l\n          c\n        }\n      }",
              variables: null
            });

          case 6:
            _yield$this$post2 = _context8.sent;
            data = _yield$this$post2.data;

            if (!data) {
              _context8.next = 12;
              break;
            }

            return _context8.abrupt("return", data[chain + "_pricechart"]);

          case 12:
            return _context8.abrupt("return", []);

          case 13:
            _context8.next = 16;
            break;

          case 15:
            return _context8.abrupt("return", {
              actions: []
            });

          case 16:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));
  return _getRexPriceChart.apply(this, arguments);
}

function getEosBalance(_x) {
  return _getEosBalance.apply(this, arguments);
}

function _getEosBalance() {
  _getEosBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName) {
    var _yield$this$rpc$get_c, balance;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.rpc.get_currency_balance(this.constants.EOSIO_TOKEN, accountName, this.constants.CORE_SYMBOL);

          case 2:
            _yield$this$rpc$get_c = _context.sent;
            balance = _yield$this$rpc$get_c[0];
            return _context.abrupt("return", balance);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getEosBalance.apply(this, arguments);
}

function getTokenBalance(_x2, _x3, _x4) {
  return _getTokenBalance.apply(this, arguments);
} // Get Account Tokens

function _getTokenBalance() {
  _getTokenBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(contract, accountName, symbol) {
    var result;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_currency_balance(contract, accountName, symbol)["catch"](function (err) {
              return console.log(err);
            });

          case 2:
            result = _context2.sent;

            if (!(result && result.length)) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", result[0]);

          case 7:
            return _context2.abrupt("return", null);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getTokenBalance.apply(this, arguments);
}

function getAccountTokens(_x5) {
  return _getAccountTokens.apply(this, arguments);
}

function _getAccountTokens() {
  _getAccountTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(accountName) {
    var accountBalances;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (accountBalances) {
              _context3.next = 4;
              break;
            }

            _context3.next = 3;
            return this.lightGetTokens(accountName);

          case 3:
            accountBalances = _context3.sent;

          case 4:
            if (accountBalances) {
              _context3.next = 8;
              break;
            }

            _context3.next = 7;
            return this.hyperionGetTokensForAccount(accountName);

          case 7:
            accountBalances = _context3.sent;

          case 8:
            return _context3.abrupt("return", accountBalances || []);

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getAccountTokens.apply(this, arguments);
}

function lightGetTokens(_x6) {
  return _lightGetTokens.apply(this, arguments);
}

function _lightGetTokens() {
  _lightGetTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var _yield$this$lightApi$, balances;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.lightApi.get_balances(account);

          case 3:
            _yield$this$lightApi$ = _context4.sent;
            balances = _yield$this$lightApi$.balances;
            return _context4.abrupt("return", balances.map(function (balance) {
              return {
                currency: balance.currency,
                amount: Number(balance.amount),
                contract: balance.contract,
                decimals: Number(balance.decimals)
              };
            }));

          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](0);
            console.log('lightGetTokens error', _context4.t0);
            return _context4.abrupt("return", undefined);

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 8]]);
  }));
  return _lightGetTokens.apply(this, arguments);
}

function hyperionGetTokensForAccount(_x7) {
  return _hyperionGetTokensForAccount.apply(this, arguments);
}

function _hyperionGetTokensForAccount() {
  _hyperionGetTokensForAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var _yield$this$hyperion$, tokens;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.hyperion.get_tokens(account);

          case 3:
            _yield$this$hyperion$ = _context5.sent;
            tokens = _yield$this$hyperion$.tokens;
            return _context5.abrupt("return", tokens.map(function (token) {
              return {
                currency: token.symbol,
                amount: Number(token.amount),
                contract: token.contract,
                decimals: Number(token.precision)
              };
            }));

          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](0);
            console.log('hyperionGetTokensForAccount error', _context5.t0);
            return _context5.abrupt("return", undefined);

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 8]]);
  }));
  return _hyperionGetTokensForAccount.apply(this, arguments);
}

function getTokenSupply(_x8, _x9) {
  return _getTokenSupply.apply(this, arguments);
}

function _getTokenSupply() {
  _getTokenSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(contract, symbol) {
    var stats, _stats$symbol, supply, max_supply;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            _context6.next = 3;
            return this.rpc.get_currency_stats(contract, symbol);

          case 3:
            stats = _context6.sent;
            _stats$symbol = stats[symbol], supply = _stats$symbol.supply, max_supply = _stats$symbol.max_supply;
            return _context6.abrupt("return", {
              supply: supply ? +supply.split(' ')[0] : 0,
              max_supply: max_supply ? +max_supply.split(' ')[0] : 0
            });

          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](0);
            console.log(_context6.t0);
            return _context6.abrupt("return", {
              supply: 0,
              max_supply: 0
            });

          case 12:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[0, 8]]);
  }));
  return _getTokenSupply.apply(this, arguments);
}

function getHistoryTransaction(_x, _x2) {
  return _getHistoryTransaction.apply(this, arguments);
}

function _getHistoryTransaction() {
  _getHistoryTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(txId, blockHint) {
    var eosTransactions, tx;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (blockHint === void 0) {
              blockHint = 0;
            }

            eosTransactions = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc(this.constants.TRANSACTIONS_ENDPOINTS);
            _context.next = 4;
            return eosTransactions.history_get_transaction(txId, blockHint);

          case 4:
            tx = _context.sent;

            if (tx) {
              _context.next = 7;
              break;
            }

            throw new Error('TX not found');

          case 7:
            return _context.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.historyTransformTransaction)(tx));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getHistoryTransaction.apply(this, arguments);
}

function getDeferredTransaction(_x3) {
  return _getDeferredTransaction.apply(this, arguments);
}

function _getDeferredTransaction() {
  _getDeferredTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(txId) {
    var _yield$this$rpc$get_s, transactions;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_scheduled_transactions(true, txId, 1);

          case 2:
            _yield$this$rpc$get_s = _context2.sent;
            transactions = _yield$this$rpc$get_s.transactions;

            if (!(transactions.length > 0 && transactions[0].trx_id.substring(0, 6) === txId.substring(0, 6))) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.historyTransformDeferredTransaction)(transactions[0]));

          case 6:
            return _context2.abrupt("return", {});

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getDeferredTransaction.apply(this, arguments);
}

function getHyperionTransaction(_x4) {
  return _getHyperionTransaction.apply(this, arguments);
}

function _getHyperionTransaction() {
  _getHyperionTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id) {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!this.constants.HYPERION_URL) {
              _context3.next = 6;
              break;
            }

            _context3.next = 3;
            return this.hyperion.get_transaction(id);

          case 3:
            result = _context3.sent;
            _context3.next = 9;
            break;

          case 6:
            _context3.next = 8;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'hyperion', {
              type: 'get_transaction',
              id: id,
              options: {}
            }));

          case 8:
            result = _context3.sent;

          case 9:
            if (!(!result || !result.actions || !result.actions.length)) {
              _context3.next = 11;
              break;
            }

            throw new Error('TX not found');

          case 11:
            return _context3.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.hyperionTransformTransaction)(result));

          case 12:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getHyperionTransaction.apply(this, arguments);
}

function generateTransactionSettings(_x5, _x6, _x7) {
  return _generateTransactionSettings.apply(this, arguments);
}

function _generateTransactionSettings() {
  _generateTransactionSettings = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(expireSeconds, blocksBehind, delaySec) {
    var info, refBlock, result;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (expireSeconds === void 0) {
              expireSeconds = 3000;
            }

            if (blocksBehind === void 0) {
              blocksBehind = 12;
            }

            if (delaySec === void 0) {
              delaySec = 0;
            }

            _context4.next = 5;
            return this.rpc.get_info();

          case 5:
            info = _context4.sent;
            result = {};

            if (!info) {
              _context4.next = 12;
              break;
            }

            _context4.next = 10;
            return this.rpc.get_block(info.head_block_num - blocksBehind);

          case 10:
            refBlock = _context4.sent;
            result = _proton_js__WEBPACK_IMPORTED_MODULE_0__.Serialize.transactionHeader(refBlock, expireSeconds);

          case 12:
            return _context4.abrupt("return", _extends({
              max_net_usage_words: 0,
              max_cpu_usage_ms: 0,
              delay_sec: delaySec,
              context_free_actions: [],
              actions: [],
              transaction_extensions: []
            }, result));

          case 13:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _generateTransactionSettings.apply(this, arguments);
}

function getControlledAccounts(accountName) {
  if (this.constants.HISTORY_TYPES.includes('native')) {
    return this.actionsRpc.history_get_controlled_accounts(accountName);
  } else if (this.constants.HISTORY_TYPES.includes('hyperion')) {
    var actionsRpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc([this.constants.HYPERION_URL]);
    return actionsRpc.history_get_controlled_accounts(accountName);
  } else {
    return [];
  }
}
function getPermissionLinks(_x) {
  return _getPermissionLinks.apply(this, arguments);
}

function _getPermissionLinks() {
  _getPermissionLinks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var lightAccount, _yield$this$get, linked_permissions, _yield$this$hyperion$, links;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!this.constants.LIGHT_API) {
              _context.next = 12;
              break;
            }

            _context.prev = 1;
            _context.next = 4;
            return this.getAccountLightData(account);

          case 4:
            lightAccount = _context.sent;

            if (!lightAccount) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return", lightAccount.linkauth.map(function (auth) {
              return {
                action: auth.type,
                contract: auth.code,
                permission_name: auth.requirement
              };
            }));

          case 7:
            _context.next = 12;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);

          case 12:
            if (!this.constants.HISTORY_TYPES.includes('dfuse')) {
              _context.next = 25;
              break;
            }

            _context.prev = 13;
            _context.next = 16;
            return this.get(this.constants.API_URL + "/dfuse?type=state_permission_links&account=" + account);

          case 16:
            _yield$this$get = _context.sent;
            linked_permissions = _yield$this$get.linked_permissions;

            if (!linked_permissions) {
              _context.next = 20;
              break;
            }

            return _context.abrupt("return", linked_permissions);

          case 20:
            _context.next = 25;
            break;

          case 22:
            _context.prev = 22;
            _context.t1 = _context["catch"](13);
            console.log(_context.t1);

          case 25:
            if (!this.constants.HISTORY_TYPES.includes('hyperion')) {
              _context.next = 37;
              break;
            }

            _context.prev = 26;
            _context.next = 29;
            return this.hyperion.get_links(account);

          case 29:
            _yield$this$hyperion$ = _context.sent;
            links = _yield$this$hyperion$.links;
            return _context.abrupt("return", links.map(function (link) {
              return {
                action: link.action,
                contract: link.code,
                permission_name: link.permission
              };
            }));

          case 34:
            _context.prev = 34;
            _context.t2 = _context["catch"](26);
            console.log(_context.t2);

          case 37:
            console.log('Permission links not available on chain');
            return _context.abrupt("return", []);

          case 39:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 9], [13, 22], [26, 34]]);
  }));
  return _getPermissionLinks.apply(this, arguments);
}

function dfuseGetKeyAccounts(_x2) {
  return _dfuseGetKeyAccounts.apply(this, arguments);
}

function _dfuseGetKeyAccounts() {
  _dfuseGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {
    var _yield$this$get2, account_names;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.get(this.constants.API_URL + "/dfuse?type=state_key_accounts&publicKey=" + key);

          case 3:
            _yield$this$get2 = _context2.sent;
            account_names = _yield$this$get2.account_names;
            return _context2.abrupt("return", account_names && account_names.length ? account_names : []);

          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](0);
            console.log(_context2.t0);
            console.log('No dfuse accounts found associated with key:', key);
            return _context2.abrupt("return", []);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 8]]);
  }));
  return _dfuseGetKeyAccounts.apply(this, arguments);
}

function nativeGetKeyAccounts(_x3) {
  return _nativeGetKeyAccounts.apply(this, arguments);
}

function _nativeGetKeyAccounts() {
  _nativeGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {
    var keyAccounts, fioAccount, _yield$this$rpc$get_a, accounts;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            keyAccounts = [];

            if (!['fio', 'fio-test'].includes(this.constants.CHAIN)) {
              _context3.next = 7;
              break;
            }

            fioAccount = (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.fioKeyToActor)(key.replace('EOS', 'FIO'), _proton_js__WEBPACK_IMPORTED_MODULE_0__.Numeric.stringToPublicKey);

            if (keyAccounts.indexOf(fioAccount) === -1) {
              keyAccounts.push(fioAccount);
            }

            _context3.next = 12;
            break;

          case 7:
            _context3.next = 9;
            return this.rpc.get_accounts_by_authorizers([], [key]);

          case 9:
            _yield$this$rpc$get_a = _context3.sent;
            accounts = _yield$this$rpc$get_a.accounts;
            keyAccounts = Array.from(new Set(accounts.map(function (account) {
              return account.account_name;
            })));

          case 12:
            return _context3.abrupt("return", keyAccounts);

          case 15:
            _context3.prev = 15;
            _context3.t0 = _context3["catch"](0);
            console.log(_context3.t0);
            throw _context3.t0;

          case 19:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 15]]);
  }));
  return _nativeGetKeyAccounts.apply(this, arguments);
}

function hyperionGetKeyAccounts(_x4) {
  return _hyperionGetKeyAccounts.apply(this, arguments);
}

function _hyperionGetKeyAccounts() {
  _hyperionGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key) {
    var legacyPublicKey, _yield$this$hyperion$2, account_names;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (this.hyperion) {
              _context4.next = 2;
              break;
            }

            throw new Error('Hyperion API not supported');

          case 2:
            legacyPublicKey = _proton_js__WEBPACK_IMPORTED_MODULE_0__.Key.PublicKey.fromString(key).toLegacyString();
            _context4.next = 5;
            return this.hyperion.get_key_accounts(legacyPublicKey);

          case 5:
            _yield$this$hyperion$2 = _context4.sent;
            account_names = _yield$this$hyperion$2.account_names;

            if (!(account_names && account_names.length)) {
              _context4.next = 11;
              break;
            }

            return _context4.abrupt("return", account_names);

          case 11:
            throw new Error('No keys found');

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _hyperionGetKeyAccounts.apply(this, arguments);
}

function lightGetKeyAccounts(_x5) {
  return _lightGetKeyAccounts.apply(this, arguments);
}

function _lightGetKeyAccounts() {
  _lightGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {
    var lightChain, accountsByChain, accounts;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (this.lightApi) {
              _context5.next = 2;
              break;
            }

            throw new Error('Light API not supported');

          case 2:
            lightChain = this.constants.CHAIN.toLowerCase().replace('-', '');
            _context5.next = 5;
            return this.lightApi.get_key_accounts(key);

          case 5:
            accountsByChain = _context5.sent;
            accounts = accountsByChain[lightChain].accounts;
            return _context5.abrupt("return", Array.from(new Set(Object.keys(accounts))));

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _lightGetKeyAccounts.apply(this, arguments);
}

function getKeyAccountsByType(_x6, _x7) {
  return _getKeyAccountsByType.apply(this, arguments);
}
/**
 * Tries all histories to get keys.
 * @param {*} key
 */

function _getKeyAccountsByType() {
  _getKeyAccountsByType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key, type) {
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.t0 = type;
            _context6.next = _context6.t0 === 'dfuse' ? 3 : _context6.t0 === 'native' ? 6 : _context6.t0 === 'hyperion' ? 9 : _context6.t0 === 'light' ? 12 : 12;
            break;

          case 3:
            _context6.next = 5;
            return this.dfuseGetKeyAccounts(key);

          case 5:
            return _context6.abrupt("return", _context6.sent);

          case 6:
            _context6.next = 8;
            return this.nativeGetKeyAccounts(key);

          case 8:
            return _context6.abrupt("return", _context6.sent);

          case 9:
            _context6.next = 11;
            return this.hyperionGetKeyAccounts(key);

          case 11:
            return _context6.abrupt("return", _context6.sent);

          case 12:
            _context6.next = 14;
            return this.lightGetKeyAccounts(key);

          case 14:
            return _context6.abrupt("return", _context6.sent);

          case 15:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _getKeyAccountsByType.apply(this, arguments);
}

function getKeyAccounts(_x8) {
  return _getKeyAccounts.apply(this, arguments);
}

function _getKeyAccounts() {
  _getKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(key) {
    var _i, _arr, historyType, res;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (key.startsWith('FIO')) {
              key = key.replace('FIO', 'EOS');
            }

            _i = 0, _arr = [this.constants.HISTORY_TYPES[0], 'light'].concat(this.constants.HISTORY_TYPES.slice(1));

          case 2:
            if (!(_i < _arr.length)) {
              _context7.next = 19;
              break;
            }

            historyType = _arr[_i];
            _context7.prev = 4;
            _context7.next = 7;
            return this.getKeyAccountsByType(key, historyType);

          case 7:
            res = _context7.sent;

            if (!res) {
              _context7.next = 10;
              break;
            }

            return _context7.abrupt("return", res);

          case 10:
            _context7.next = 16;
            break;

          case 12:
            _context7.prev = 12;
            _context7.t0 = _context7["catch"](4);
            console.log(_context7.t0);
            return _context7.abrupt("continue", 16);

          case 16:
            _i++;
            _context7.next = 2;
            break;

          case 19:
            return _context7.abrupt("return", []);

          case 20:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[4, 12]]);
  }));
  return _getKeyAccounts.apply(this, arguments);
}

function getKeyAccountsForAllChains(_x9) {
  return _getKeyAccountsForAllChains.apply(this, arguments);
}
/**
 * Recursively resolves all required permissions
 * @param accountName
 * @param permission
 */

function _getKeyAccountsForAllChains() {
  _getKeyAccountsForAllChains = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(key) {
    var keyAccounts, combined;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (this.lightApi) {
              _context8.next = 2;
              break;
            }

            throw new Error('Light API not supported');

          case 2:
            _context8.prev = 2;
            _context8.next = 5;
            return this.lightApi.get_all_key_accounts(key);

          case 5:
            keyAccounts = _context8.sent;
            combined = keyAccounts.reduce(function (acc, obj) {
              return _extends({}, acc, obj);
            }, {});
            return _context8.abrupt("return", Object.entries(combined).reduce(function (acc, _ref) {
              var chain = _ref[0],
                  accountsByName = _ref[1].accounts;
              var accounts = Object.keys(accountsByName);

              if (accounts.length) {
                acc.push({
                  chain: chain,
                  accounts: accounts
                });
              }

              return acc;
            }, []));

          case 10:
            _context8.prev = 10;
            _context8.t0 = _context8["catch"](2);
            console.log(_context8.t0);
            return _context8.abrupt("return", []);

          case 14:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[2, 10]]);
  }));
  return _getKeyAccountsForAllChains.apply(this, arguments);
}

function getRequiredAccounts(_x10, _x11, _x12, _x13, _x14) {
  return _getRequiredAccounts.apply(this, arguments);
}

function _getRequiredAccounts() {
  _getRequiredAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(accountName, permissionName, allPermissions, currentLevel, maxLevel) {
    var accountInfo, _iterator, _step, permission, accounts, producers, _iterator2, _step2, account;

    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (allPermissions === void 0) {
              allPermissions = [];
            }

            if (currentLevel === void 0) {
              currentLevel = 1;
            }

            if (maxLevel === void 0) {
              maxLevel = 2;
            }

            _context9.next = 5;
            return this.getAccount(accountName);

          case 5:
            accountInfo = _context9.sent;
            _iterator = _createForOfIteratorHelperLoose(accountInfo.permissions);

          case 7:
            if ((_step = _iterator()).done) {
              _context9.next = 31;
              break;
            }

            permission = _step.value;

            if (!(permission.perm_name === permissionName)) {
              _context9.next = 29;
              break;
            }

            // Get all account (e.g. gyy, hartono, thompson)
            accounts = [];

            if (!(accountName === 'eosio' && ['owner', 'active'].includes(permission.perm_name))) {
              _context9.next = 16;
              break;
            }

            _context9.next = 14;
            return this.getProducersLocal();

          case 14:
            producers = _context9.sent;
            accounts = producers.map(function (producer) {
              return {
                actor: producer.owner,
                permission: 'active'
              };
            });

          case 16:
            if (!accounts.length) {
              accounts = permission.required_auth.accounts.map(function (account) {
                return account.permission;
              });
            }

            if (!accounts.length) {
              allPermissions.push({
                actor: accountName,
                permission: permissionName
              });
            } // For each account (e.g. hartono)


            _iterator2 = _createForOfIteratorHelperLoose(accounts);

          case 19:
            if ((_step2 = _iterator2()).done) {
              _context9.next = 29;
              break;
            }

            account = _step2.value;

            if (!(currentLevel < maxLevel)) {
              _context9.next = 26;
              break;
            }

            _context9.next = 24;
            return this.getRequiredAccounts(account.actor, account.permission, allPermissions, ++currentLevel, maxLevel);

          case 24:
            _context9.next = 27;
            break;

          case 26:
            allPermissions.push({
              actor: account.actor,
              permission: account.permission
            });

          case 27:
            _context9.next = 19;
            break;

          case 29:
            _context9.next = 7;
            break;

          case 31:
            return _context9.abrupt("return", allPermissions);

          case 32:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this);
  }));
  return _getRequiredAccounts.apply(this, arguments);
}

function getUsersFromKeys(_x15) {
  return _getUsersFromKeys.apply(this, arguments);
}

function _getUsersFromKeys() {
  _getUsersFromKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(keys) {
    var _this = this;

    var users, promises;
    return _regeneratorRuntime().wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            users = [];
            promises = keys.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(key) {
                var account_names, promises2;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        _context11.next = 2;
                        return _this.getKeyAccounts(key);

                      case 2:
                        account_names = _context11.sent;
                        promises2 = account_names.map( /*#__PURE__*/function () {
                          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(account) {
                            var accountInfo, _iterator3, _step3, permission;

                            return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                              while (1) {
                                switch (_context10.prev = _context10.next) {
                                  case 0:
                                    _context10.next = 2;
                                    return _this.getAccount(account);

                                  case 2:
                                    accountInfo = _context10.sent;

                                    // For every permission, add to array
                                    for (_iterator3 = _createForOfIteratorHelperLoose(accountInfo.permissions); !(_step3 = _iterator3()).done;) {
                                      permission = _step3.value;

                                      // If key exists
                                      if (permission.required_auth.keys.find(function (permKey) {
                                        return permKey.key === key;
                                      })) {
                                        users.push({
                                          actor: account,
                                          permission: permission.perm_name,
                                          publicKey: key
                                        });
                                      }
                                    }

                                  case 4:
                                  case "end":
                                    return _context10.stop();
                                }
                              }
                            }, _callee10);
                          }));

                          return function (_x17) {
                            return _ref3.apply(this, arguments);
                          };
                        }());
                        _context11.next = 6;
                        return Promise.all(promises2);

                      case 6:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee11);
              }));

              return function (_x16) {
                return _ref2.apply(this, arguments);
              };
            }());
            _context12.next = 4;
            return Promise.all(promises);

          case 4:
            return _context12.abrupt("return", users);

          case 5:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));
  return _getUsersFromKeys.apply(this, arguments);
}

var ApiClass = /*#__PURE__*/function () {
  function ApiClass(chain) {
    this.rpc = undefined;
    this.actionsRpc = undefined;
    this.api = undefined;
    this.hyperion = undefined;
    this.lightApi = undefined;
    this.isInitialized = false;
    this.constants = undefined;
    this.http = http;
    this.get = get;
    this.post = post;
    this.getAccount = getAccount;
    this.getGravatar = getGravatar;
    this.searchAccount = searchAccount;
    this.getParent = getParent;
    this.getAccountLightData = getAccountLightData;
    this.getActionsFromNative = getActionsFromNative;
    this.getActions = getActions;
    this.getActionsFromDfuse = getActionsFromDfuse;
    this.getActionsFromHyperion = getActionsFromHyperion;
    this.getDappStats = getDappStats;
    this.getDspPackages = getDspPackages;
    this.getDapphodlBalance = getDapphodlBalance;
    this.getDappBalance = getDappBalance;
    this.getDappStakes = getDappStakes;
    this.getDapphodlStakes = getDapphodlStakes;
    this.getDappUnstakes = getDappUnstakes;
    this.getDapphodlUnstakes = getDapphodlUnstakes;
    this.getFIOVoter = getFIOVoter;
    this.getFIOAddressByName = getFIOAddressByName;
    this.getFIODomainByName = getFIODomainByName;
    this.getNFTsByFioAddress = getNFTsByFioAddress;
    this.getDomains = getDomains;
    this.getAddresses = getAddresses;
    this.getFIOProducers = getFIOProducers;
    this.getFIOSupplyBreakdown = getFIOSupplyBreakdown;
    this.getFIOFees = getFIOFees;
    this.addFIOFeeToActions = addFIOFeeToActions;
    this.getFIOAddresses = getFIOAddresses;
    this.getFIODomains = getFIODomains;
    this.getFIOAddressesAndDomains = getFIOAddressesAndDomains;
    this.getFIOBalance = getFIOBalance;
    this.getControlledAccounts = getControlledAccounts;
    this.getPermissionLinks = getPermissionLinks;
    this.dfuseGetKeyAccounts = dfuseGetKeyAccounts;
    this.nativeGetKeyAccounts = nativeGetKeyAccounts;
    this.hyperionGetKeyAccounts = hyperionGetKeyAccounts;
    this.lightGetKeyAccounts = lightGetKeyAccounts;
    this.getKeyAccountsByType = getKeyAccountsByType;
    this.getKeyAccounts = getKeyAccounts;
    this.getKeyAccountsForAllChains = getKeyAccountsForAllChains;
    this.getRequiredAccounts = getRequiredAccounts;
    this.getUsersFromKeys = getUsersFromKeys;
    this.getAllMsigs = getAllMsigs;
    this.parsePackedMsigActions = parsePackedMsigActions;
    this.parsePackedMsig = parsePackedMsig;
    this.getFullMsigProposal = getFullMsigProposal;
    this.getMsigApprovals = getMsigApprovals;
    this.getAccountsMsigProposals = getAccountsMsigProposals;
    this.hyperionGetMsig = hyperionGetMsig;
    this.getMsigProposal = getMsigProposal;
    this.getRentbwState = getRentbwState;
    this.delegatedBandwidth = delegatedBandwidth;
    this.getAccountDelegatedBandwidth = getAccountDelegatedBandwidth;
    this.getAccountResources = getAccountResources;
    this.getRamPriceInEos = getRamPriceInEos;
    this.getRexQueued = getRexQueued;
    this.getRexPool = getRexPool;
    this.getRexBalance = getRexBalance;
    this.getRexCpuLoans = getRexCpuLoans;
    this.getRexNetLoans = getRexNetLoans;
    this.getEosDepositedIntoRex = getEosDepositedIntoRex;
    this.getRexReturnRate = getRexReturnRate;
    this.getRexPriceChart = getRexPriceChart;
    this.getEosTopStakes = getEosTopStakes;
    this.getEosTopRams = getEosTopRams;
    this.getCurrentNameBids = getCurrentNameBids;
    this.getEosBalance = getEosBalance;
    this.getTokenBalance = getTokenBalance;
    this.hyperionGetTokensForAccount = hyperionGetTokensForAccount;
    this.getTokenSupply = getTokenSupply;
    this.lightGetTokens = lightGetTokens;
    this.getAccountTokens = getAccountTokens;
    this.getHistoryTransaction = getHistoryTransaction;
    this.getDeferredTransaction = getDeferredTransaction;
    this.getHyperionTransaction = getHyperionTransaction;
    this.generateTransactionSettings = generateTransactionSettings;
    this.getProxies = getProxies;
    this.getVoters = getVoters;
    this.calculateVoteWeight = calculateVoteWeight;
    this.weightedVoteToNumber = weightedVoteToNumber;
    this.getProxyData = getProxyData;
    this.getVoter = getVoter;
    this.getProducers = getProducers;
    this.getProducersLocal = getProducersLocal;
    this.getChainTable = getChainTable;
    this.fetchKycCountries = fetchKycCountries;
    this.checkUserKycStatus = checkUserKycStatus;
    this.applyForKyc = applyForKyc;
    this.currentLocation = currentLocation;
    this.getAvailableFeatures = getAvailableFeatures;
    this.otcQuote = otcQuote;
    this.otcOrder = otcOrder;
    this.generateAddress = generateAddress;
    this.deleteAddress = deleteAddress;
    this.withdrawMetal = withdrawMetal;
    this.withdrawalHistoryMetal = withdrawalHistoryMetal;
    this.getTokenPrices = getTokenPrices;
    this.getWithdrawalFee = getWithdrawalFee;
    this.getChainInfo = getChainInfo;
    this.createAccount = createAccount;
    this.loginAccount = loginAccount;
    this.getXprTotalStakedAndApr = getXprTotalStakedAndApr;
    this.getXprVoter = getXprVoter;
    this.getXprAccountStakes = getXprAccountStakes;
    this.getXprAccountRefund = getXprAccountRefund;
    this.getXprOracleData = getXprOracleData;
    this.getAllOracleFeeds = getAllOracleFeeds;
    this.getAllOracleData = getAllOracleData;
    this.getSpecificOracleData = getSpecificOracleData;
    this.getProtonAvatar = getProtonAvatar;
    this.getProtonAvatars = getProtonAvatars;

    if (chain) {
      _bloks_constants__WEBPACK_IMPORTED_MODULE_1__.constants.initialize(chain);
      this.initialize(_bloks_constants__WEBPACK_IMPORTED_MODULE_1__.constants);
    }
  }

  var _proto = ApiClass.prototype;

  _proto.initialize = function initialize(constants, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        rpcEndpoints = _ref.rpcEndpoints,
        actionsRpcEndpoints = _ref.actionsRpcEndpoints,
        lightEndpoint = _ref.lightEndpoint,
        hyperionEndpoint = _ref.hyperionEndpoint;

    this.constants = constants;
    this.rpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc(rpcEndpoints || this.constants.DEFAULT_ENDPOINTS);
    this.actionsRpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc(actionsRpcEndpoints || this.constants.ACTIONS_ENDPOINTS);
    this.api = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.Api({
      rpc: this.rpc
    });
    var lightUrl = lightEndpoint || this.constants.LIGHT_API;

    if (lightUrl) {
      this.lightApi = new _proton_light_api__WEBPACK_IMPORTED_MODULE_3__.JsonRpc(this.constants.CHAIN.toLowerCase().replace('-', ''), {
        endpoint: lightUrl
      });
    }

    var hyperionUrl = hyperionEndpoint || this.constants.HYPERION_URL;

    if (hyperionUrl) {
      this.hyperion = new _proton_hyperion__WEBPACK_IMPORTED_MODULE_2__.JsonRpc(hyperionUrl);
    }

    this.isInitialized = true;
  };

  return ApiClass;
}();


//# sourceMappingURL=api.esm.js.map


/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TypeScript Definitions
__exportStar(__webpack_require__(/*! ./src/types/action_trace */ "./node_modules/@proton/hyperion/dist/src/types/action_trace.js"), exports);
__exportStar(__webpack_require__(/*! ./src/types/api */ "./node_modules/@proton/hyperion/dist/src/types/api.js"), exports);
// Hyperion API
__exportStar(__webpack_require__(/*! ./src/jsonrpc */ "./node_modules/@proton/hyperion/dist/src/jsonrpc.js"), exports);
__exportStar(__webpack_require__(/*! ./src/endpoints */ "./node_modules/@proton/hyperion/dist/src/endpoints.js"), exports);
__exportStar(__webpack_require__(/*! ./src/rpcerror */ "./node_modules/@proton/hyperion/dist/src/rpcerror.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/endpoints.js":
/*!*************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/endpoints.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.V2_GET_TRANSFERS = exports.V2_GET_TRANSACTION = exports.V2_GET_TRANSACTED_ACCOUNTS = exports.V2_GET_DELTAS = exports.V2_GET_CREATOR = exports.V2_GET_CREATED_ACCOUNTS = exports.V2_GET_ACTIONS = exports.V2_GET_ABI_SNAPSHOT = exports.V2_GET_PROPOSALS = exports.V2_GET_LINKS = exports.V2_GET_VOTERS = exports.V2_GET_TOKENS = exports.V2_GET_KEY_ACCOUNTS = exports.V2_ALIVE = void 0;
// State
exports.V2_ALIVE = "/v2/state/alive";
exports.V2_GET_KEY_ACCOUNTS = "/v2/state/get_key_accounts";
exports.V2_GET_TOKENS = "/v2/state/get_tokens";
exports.V2_GET_VOTERS = "/v2/state/get_voters";
exports.V2_GET_LINKS = "/v2/state/get_links";
exports.V2_GET_PROPOSALS = "/v2/state/get_proposals";
// History
exports.V2_GET_ABI_SNAPSHOT = "/v2/history/get_abi_snapshot";
exports.V2_GET_ACTIONS = "/v2/history/get_actions";
exports.V2_GET_CREATED_ACCOUNTS = "/v2/history/get_created_accounts";
exports.V2_GET_CREATOR = "/v2/history/get_creator";
exports.V2_GET_DELTAS = "/v2/history/get_deltas";
exports.V2_GET_TRANSACTED_ACCOUNTS = "/v2/history/get_transacted_accounts";
exports.V2_GET_TRANSACTION = "/v2/history/get_transaction";
exports.V2_GET_TRANSFERS = "/v2/history/get_transfers";
//# sourceMappingURL=endpoints.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/jsonrpc.js":
/*!***********************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/jsonrpc.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpc = void 0;
var endpoints_1 = __webpack_require__(/*! ./endpoints */ "./node_modules/@proton/hyperion/dist/src/endpoints.js");
var rpcerror_1 = __webpack_require__(/*! ./rpcerror */ "./node_modules/@proton/hyperion/dist/src/rpcerror.js");
var cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
function queryParams(params) {
    var entries = [];
    for (var _i = 0, _a = Object.keys(params); _i < _a.length; _i++) {
        var key = _a[_i];
        var value = params[key];
        if (value !== undefined) {
            entries.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
        }
    }
    return entries.join("&");
}
function fetchWithTimeout(resource, options) {
    return __awaiter(this, void 0, void 0, function () {
        var timeout, controller, id, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    timeout = options.timeout;
                    controller = new AbortController();
                    id = setTimeout(function () { return controller.abort(); }, timeout);
                    return [4 /*yield*/, (0, cross_fetch_1.default)(resource, __assign(__assign({}, (options || {})), { signal: controller.signal }))];
                case 1:
                    response = _a.sent();
                    clearTimeout(id);
                    return [2 /*return*/, response];
            }
        });
    });
}
/**
 * JsonRpc
 *
 * @param {string} endpoint hyperion endpoint
 * @example
 *
 * const endpoint = "https://br.eosrio.io"
 * const rpc = new JsonRpc(endpoint, { fetch })
 */
var JsonRpc = /** @class */ (function () {
    function JsonRpc(endpoint, args) {
        if (args === void 0) { args = {}; }
        this.timeout = 8000;
        this.endpoint = endpoint;
        if (args.timeout) {
            this.timeout = args.timeout;
        }
    }
    /**
     * post
     *
     * POST `body` to `endpoint + path`.
     * Throws detailed error information in `RpcError` when available.
     *
     * @private
     */
    JsonRpc.prototype.post = function (path, body) {
        return __awaiter(this, void 0, void 0, function () {
            var response, json, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, fetchWithTimeout(this.endpoint + path, {
                                body: JSON.stringify(body),
                                method: "POST",
                                timeout: this.timeout
                            })];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.json()];
                    case 2:
                        json = _a.sent();
                        if (json.processed && json.processed.except) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        e_1.isFetchError = true;
                        throw e_1;
                    case 4:
                        if (!response.ok) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * get
     *
     * GET `params` to `endpoint + path`.
     * Throws detailed error information in `RpcError` when available.
     *
     * @private
     */
    JsonRpc.prototype.get = function (path, params) {
        return __awaiter(this, void 0, void 0, function () {
            var response, json, url, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endpoint + path + "?" + queryParams(params);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, fetchWithTimeout(url, {
                                method: "GET",
                                timeout: this.timeout
                            })];
                    case 2:
                        response = _a.sent();
                        if (response.status !== 200) {
                            throw new rpcerror_1.RpcStatusError(response);
                        }
                        return [4 /*yield*/, response.json()];
                    case 3:
                        json = _a.sent();
                        if (json.processed && json.processed.except) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_2 = _a.sent();
                        e_2.isFetchError = true;
                        throw e_2;
                    case 5:
                        if (!response.ok) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * [GET /v2/state/alive](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_alive)
     *
     * simple server healthcheck
     *
     * @returns {Promise<Alive>} alive
     * @example
     *
     * const response = await rpc.alive();
     * console.log(response);
     * // => {"status": "OK"}
     */
    JsonRpc.prototype.alive = function () {
        return this.get(endpoints_1.V2_ALIVE, {});
    };
    /**
     * [GET /v2/history/get_abi_snapshot](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_abi_snapshot)
     *
     * fetch contract abi at specific block
     *
     * @param {string} contract contract account
     * @param {number} number target block
     * @returns {Promise<GetAbiSnapshot>} abi snapshot
     * @example
     *
     * const response = await rpc.get_abi_snapshot("eosio", 200);
     * console.log(response.version);
     * // => "eosio::abi/1.0"
     *
     * for (const table of response.tables) {
     *     console.log(table);
     *     // => { name: 'producers', index_type: 'i64', key_names: [ 'owner' ], key_types: [ 'uint64' ], type: 'producer_info' }
     * }
     */
    JsonRpc.prototype.get_abi_snapshot = function (contract, block) {
        var params = {
            contract: contract,
            block: block,
        };
        return this.get(endpoints_1.V2_GET_ABI_SNAPSHOT, params);
    };
    /**
     * [GET /v2/state/get_voters](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_voters)
     *
     * get voters
     *
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.producer] filter by voted producer (comma separated)
     * @param {boolean} [options.proxy] true or false
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @returns {Promise<GetVoters>} voters
     * @example
     *
     * const response = await rpc.get_voters({ producer: "eoscafeblock", limit: 100 });
     * console.log(response.voters);
     * // => "[{
     * //   "account": "guzdkmrtgage",
     * //   "weight": 78434695236505280,
     * //   "last_vote": 64804768
     * // }]"
     */
    JsonRpc.prototype.get_voters = function (options) {
        return this.get(endpoints_1.V2_GET_VOTERS, options);
    };
    /**
     * [GET /v2/state/get_links](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_links)
     *
     * get voters
     *
     * @param {string} [account] account to get links for
     * @returns {Promise<GetLinks>} links
     * @example
     *
     * const response = await rpc.get_links("eoscafeblock");
     * console.log(response.links);
     * // => "[{
     * "block_num":26088072,
     * "timestamp":"2019-11-22T23:17:42.000",
     * "account":"eosriobrazil",
     * "permission":"claim2",
     * "code":"eosio",
     * "action":"voteproducer"
     * }]"
     */
    JsonRpc.prototype.get_links = function (account) {
        return this.get(endpoints_1.V2_GET_LINKS, { account: account });
    };
    /**
     * [GET /v2/state/get_proposals](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_proposals)
     *
     * get proposals
     *
     * @param {string} [account] account to get proposals for
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.proposer] filter by proposer
     * @param {string} [options.proposal] filter by proposal name
     * @param {string} [options.account] filter by either requested or provided account
     * @param {string} [options.requested] filter by requested account
     * @param {string} [options.provided] filter by provided account
     * @param {string} [options.track] total results to track (count) [number or true]
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @returns {Promise<GetProposals>} proposals
     */
    JsonRpc.prototype.get_proposals = function (options) {
        return this.get(endpoints_1.V2_GET_PROPOSALS, options);
    };
    /**
     * [GET /v2/history/get_actions](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_actions)
     *
     * get actions based on notified account
     *
     * @param {string} account notified account
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.filter] code::name filter
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @param {string} [options.sort] sort direction
     * @param {string} [options.after] filter after specified date (ISO8601)
     * @param {string} [options.before] filter before specified date (ISO8601)
     * @param {string} [options.transfer_to] transfer filter to
     * @param {string} [options.transfer_from]  transfer filter from
     * @param {string} [options.transfer_symbol]  transfer filter symbol
     * @param {string} [options.act_name]  act name
     * @param {string} [options.act_account]  act account
     * @returns {Promise<GetActions>} get actions
     * @example
     *
     * const response = await rpc.get_actions("eoscafeblock", {
     *     filter: "eosio.token:*",
     *     skip: 100,
     *     limit: 100,
     * });
     *
     * for (const action of response.actions) {
     *     console.log(action);
     *     // => { act: { account: 'eosio.token', name: 'transfer', ... } }
     * }
     */
    JsonRpc.prototype.get_actions = function (account, options) {
        if (options === void 0) { options = {}; }
        var params = Object.assign({}, { account: account }, options);
        return this.get(endpoints_1.V2_GET_ACTIONS, params);
    };
    /**
     * [GET /v2/history/get_created_accounts](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_created_accounts)
     *
     * get created accounts
     *
     * @param {string} account created account
     * @returns {Promise<GetCreatedAccounts>} get creator
     * @example
     *
     * const response = await rpc.get_created_accounts("eosnationftw");
     * console.log(response);
     * // => {"accounts": [{"name":"eosnationdsp","trx_id":"728d4a4da36a98d9048080461dacaf975ad083e8158ef84edea60cc755ab2c1a","timestamp":"2019-02-28T22:36:45.000"}, ... ]}
     */
    JsonRpc.prototype.get_created_accounts = function (account) {
        var params = {
            account: account,
        };
        return this.get(endpoints_1.V2_GET_CREATED_ACCOUNTS, params);
    };
    /**
     * [GET /v2/history/get_creator](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_creator)
     *
     * get creator
     *
     * @param {string} account created account
     * @returns {Promise<GetCreator>} get creator
     * @example
     *
     * const response = await rpc.get_creator("eosnationftw");
     * console.log(response);
     * // => { account: 'eosnationftw', creator: 'gyztcmrvgqge', timestamp: '2018-06-10T13:06:43.500', ... }
     */
    JsonRpc.prototype.get_creator = function (account) {
        var params = {
            account: account,
        };
        return this.get(endpoints_1.V2_GET_CREATOR, params);
    };
    /**
     * [GET /v2/history/get_deltas](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_deltas)
     *
     * get deltas
     *
     * @param {string} code contract account
     * @param {string} scope table scope
     * @param {string} table table name
     * @param {string} payer payer account
     * @returns {Promise<GetDeltas>} get deltas
     * @example
     *
     * const response = await rpc.get_deltas("eosio.token", "eosnationftw", "accounts", "eosnationftw");
     * console.log(response);
     * // => { "query_time": 19, "total": { "value": 486, "relation": "eq" }, "deltas": [ ... ] }
     */
    JsonRpc.prototype.get_deltas = function (code, scope, table, payer, options) {
        var params = Object.assign({}, options, {
            code: code,
            scope: scope,
            table: table,
            payer: payer,
        });
        return this.get(endpoints_1.V2_GET_DELTAS, params);
    };
    /**
     * [GET/v2/state/get_key_accounts](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_key_accounts)
     *
     * get account by public key
     *
     * @param {string} public_key Contract account targeted by the action.
     * @returns {Promise<GetKeyAccounts>} key accounts
     * @example
     *
     * const response = await rpc.get_key_accounts("EOS5Mto3Km6BCVxowb6LkkFaT9oaUwLVgswgcxvY4Qgc4rhHry4Tv");
     * console.log(response.account_names);
     * // => [ 'eoscafeblock' ]
     */
    JsonRpc.prototype.get_key_accounts = function (public_key) {
        var params = {
            public_key: public_key,
        };
        return this.get(endpoints_1.V2_GET_KEY_ACCOUNTS, params);
    };
    /**
     * [GET /v2/state/get_tokens](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_tokens)
     *
     * get tokens
     *
     * @param {string} account account
     * @returns {Promise<GetTokens>} get tokens
     * @example
     *
     * const response = await rpc.get_tokens("eosnationftw");
     * for (const token of response.tokens) {
     *     console.log(token);
     *     // => { symbol: 'ZOS', precision: 4, amount: 140, contract: 'zosdiscounts' }
     * }
     */
    JsonRpc.prototype.get_tokens = function (account) {
        var params = {
            account: account,
        };
        return this.get(endpoints_1.V2_GET_TOKENS, params);
    };
    /**
     * [GET /v2/history/get_transacted_accounts](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_transacted_accounts)
     *
     * get all account that interacted with the source account provided
     *
     * @param {string} account source account
     * @param {string} direction search direction (in, out or both)
     * @returns {Promise<GetTransactedAccounts>} transacted accounts
     * @example
     *
     * const response = await rpc.get_transacted_accounts("eoscafeblock", "in");
     * console.log(response);
     * // => { query_time: 268, account: 'eoscafeblock', total_in: 1092369.1827, inputs: [ ... ] }
     */
    JsonRpc.prototype.get_transacted_accounts = function (account, direction, options) {
        if (options === void 0) { options = {}; }
        var params = Object.assign({}, { account: account, direction: direction }, options);
        return this.get(endpoints_1.V2_GET_TRANSACTED_ACCOUNTS, params);
    };
    /**
     * [GET /v2/history/get_transaction](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_transaction)
     *
     * get all actions belonging to the same transaction
     *
     * @param {string} id transaction id
     * @returns {Promise<GetTransaction>} transaction
     * @example
     *
     * const response = await rpc.get_transaction("42dacd5722001b734be46a2140917e06cd21d42425f927f506c07b4388b07f62");
     * for (const action of response.actions) {
     *     console.log(action);
     *     // => { act: { account: 'eosio', name: 'buyrambytes', ... }}
     * }
     */
    JsonRpc.prototype.get_transaction = function (id) {
        var params = {
            id: id,
        };
        return this.get(endpoints_1.V2_GET_TRANSACTION, params);
    };
    /**
     * [GET /v2/history/get_transfers](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_transfers)
     *
     * get token transfers utilizing the eosio.token standard
     *
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.from] source account
     * @param {string} [options.to] destination account
     * @param {string} [options.symbol] token symbol
     * @param {string} [options.contract] token contract
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @param {string} [options.after] filter after specified date (ISO8601)
     * @param {string} [options.before] filter before specified date (ISO8601)
     * @returns {Promise<GetTransfers>} transfers
     * @example
     *
     * const response = await rpc.get_transfers({to: "eosnewyorkio"});
     * for (const action of response.actions) {
     *     console.log(action.act.data);
     *     // => { from: 'eosio.bpay', to: 'eosnewyorkio', amount: 326.524, symbol: 'EOS', memo: 'producer block pay' }
     * }
     */
    JsonRpc.prototype.get_transfers = function (options) {
        if (options === void 0) { options = {}; }
        var params = Object.assign({}, options);
        return this.get(endpoints_1.V2_GET_TRANSFERS, params);
    };
    return JsonRpc;
}());
exports.JsonRpc = JsonRpc;
//# sourceMappingURL=jsonrpc.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/rpcerror.js":
/*!************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/rpcerror.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcStatusError = exports.RpcError = void 0;
/**
 * @private
 * @module RPC-Error
 *
 * copyright defined in eosjs/LICENSE.txt
 */
var RpcError = /** @class */ (function (_super) {
    __extends(RpcError, _super);
    function RpcError(json) {
        var _this = this;
        if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
        }
        else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
        }
        else {
            _this = _super.call(this, json.message) || this;
        }
        Object.setPrototypeOf(_this, RpcError.prototype);
        _this.json = json;
        return _this;
    }
    return RpcError;
}(Error));
exports.RpcError = RpcError;
/**
 * @private
 */
var RpcStatusError = /** @class */ (function (_super) {
    __extends(RpcStatusError, _super);
    function RpcStatusError(response) {
        var _this = this;
        if (response.status === 405) {
            _this = _super.call(this, response.statusText) || this;
        }
        else {
            _this = _super.call(this) || this;
        }
        Object.setPrototypeOf(_this, RpcStatusError.prototype);
        _this.response = response;
        return _this;
    }
    return RpcStatusError;
}(Error));
exports.RpcStatusError = RpcStatusError;
//# sourceMappingURL=rpcerror.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/types/action_trace.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/types/action_trace.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=action_trace.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/types/api.js":
/*!*************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/types/api.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TypeScript Definitions
__exportStar(__webpack_require__(/*! ./src/types/api */ "./node_modules/@proton/light-api/dist/src/types/api.js"), exports);
// Light API
__exportStar(__webpack_require__(/*! ./src/jsonrpc */ "./node_modules/@proton/light-api/dist/src/jsonrpc.js"), exports);
__exportStar(__webpack_require__(/*! ./src/endpoints */ "./node_modules/@proton/light-api/dist/src/endpoints.js"), exports);
__exportStar(__webpack_require__(/*! ./src/rpcerror */ "./node_modules/@proton/light-api/dist/src/rpcerror.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/endpoints.js":
/*!**************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/endpoints.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GET_ACCOUNTS_FROM_KEYS = exports.GET_TOKEN_HOLDERS = exports.GET_TOKEN_HOLDER_COUNT = exports.GET_CODEHASH = exports.GET_TOPSTAKE = exports.GET_TOPRAM = exports.GET_USERCOUNT = exports.GET_TOPHOLDERS = exports.GET_TOKEN_BALANCE = exports.GET_SYNC_INFO = exports.GET_NETWORKS = exports.GET_KEY_ACCOUNTS = exports.GET_BALANCES = exports.GET_ACCOUNT_INFO = exports.GET_ACCOUNT = void 0;
exports.GET_ACCOUNT = "/api/account";
exports.GET_ACCOUNT_INFO = "/api/accinfo";
exports.GET_BALANCES = "/api/balances";
exports.GET_KEY_ACCOUNTS = "/api/key";
exports.GET_NETWORKS = "/api/networks";
exports.GET_SYNC_INFO = "/api/sync";
exports.GET_TOKEN_BALANCE = "/api/tokenbalance";
exports.GET_TOPHOLDERS = "/api/topholders";
exports.GET_USERCOUNT = "/api/usercount";
exports.GET_TOPRAM = "/api/topram";
exports.GET_TOPSTAKE = "/api/topstake";
exports.GET_CODEHASH = "/api/codehash";
exports.GET_TOKEN_HOLDER_COUNT = "/api/holdercount";
exports.GET_TOKEN_HOLDERS = "get_token_holders";
exports.GET_ACCOUNTS_FROM_KEYS = "get_accounts_from_keys";
//# sourceMappingURL=endpoints.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/jsonrpc.js":
/*!************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/jsonrpc.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpc = void 0;
var endpoints_1 = __webpack_require__(/*! ./endpoints */ "./node_modules/@proton/light-api/dist/src/endpoints.js");
var rpcerror_1 = __webpack_require__(/*! ./rpcerror */ "./node_modules/@proton/light-api/dist/src/rpcerror.js");
var cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
var jsonrpc2_ws_1 = __webpack_require__(/*! jsonrpc2-ws */ "./node_modules/jsonrpc2-ws/lib/index.js");
var chainToEndpoint = {
    eos: "https://api.light.xeos.me",
    telos: "https://api.light.xeos.me",
    jungle: "https://lightapi.eosgeneva.io",
    bos: "https://lightapi.eosamsterdam.net",
    instar: "https://lightapi.eosamsterdam.net",
    proton: "https://proton.light-api.net",
    wax: "https://lightapi.eosamsterdam.net",
    worbli: "https://lightapi.eosamsterdam.net",
    xec: "https://lightapi.eosamsterdam.net",
    protontest: "https://testnet-lightapi.eosams.xeos.me",
    telostest: "https://testnet-lightapi.eosams.xeos.me",
    waxtest: "https://testnet-lightapi.eosams.xeos.me",
    coffe: "https://hyperion.coffe.io",
};
function fetchWithTimeout(resource, options) {
    return __awaiter(this, void 0, void 0, function () {
        var timeout, controller, id, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    timeout = options.timeout;
                    controller = new AbortController();
                    id = setTimeout(function () { return controller.abort(); }, timeout);
                    return [4 /*yield*/, (0, cross_fetch_1.default)(resource, __assign(__assign({}, (options || {})), { signal: controller.signal }))];
                case 1:
                    response = _a.sent();
                    clearTimeout(id);
                    return [2 /*return*/, response];
            }
        });
    });
}
/**
 * JsonRpc
 *
 * @param {string} endpoint LIGHT API endpoint
 * @example
 *
 * const rpc = new JsonRpc("proton")
 */
var JsonRpc = /** @class */ (function () {
    function JsonRpc(chain, args) {
        if (args === void 0) { args = {}; }
        this.timeout = 5000;
        this.wsRequestId = 100;
        this.chain = chain;
        this.endpoint = args.endpoint || chainToEndpoint[chain];
        this.wsClient = new jsonrpc2_ws_1.Client(this.endpoint.replace('https:', 'wss:') + '/wsapi');
        if (!this.endpoint) {
            throw new Error("Chain ".concat(chain, " does not have a default endpoint, provide one in args"));
        }
        if (args.timeout) {
            this.timeout = args.timeout;
        }
    }
    /**
     * get
     *
     * GET `params` to `endpoint + path`.
     * Throws detailed error information in `RpcError` when available.
     *
     * @private
     */
    JsonRpc.prototype.get = function (path, endpoint) {
        if (endpoint === void 0) { endpoint = this.endpoint; }
        return __awaiter(this, void 0, void 0, function () {
            var response, json, url, text, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = endpoint + path;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, fetchWithTimeout(url, {
                                method: "GET",
                                timeout: this.timeout,
                            })];
                    case 2:
                        response = _a.sent();
                        if (response.status !== 200) {
                            throw new rpcerror_1.RpcStatusError(response);
                        }
                        return [4 /*yield*/, response.text()];
                    case 3:
                        text = _a.sent();
                        try {
                            json = JSON.parse(text);
                            if (json.processed && json.processed.except) {
                                throw new rpcerror_1.RpcError(json);
                            }
                        }
                        catch (_b) {
                            json = text;
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        e_1.isFetchError = true;
                        throw e_1;
                    case 5:
                        if (!response.ok) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * [GET /api/account]
     *
     * Retrieve all token balances, resources and authorization information for an account:
     *
     * @param {string} accountName name of account
     * @returns {Promise<GetAccount>} account
     */
    JsonRpc.prototype.get_account = function (accountName) {
        var url = "".concat(endpoints_1.GET_ACCOUNT, "/").concat(this.chain, "/").concat(accountName);
        return this.get(url);
    };
    /**
     * [GET /api/accinfo]
     *
     * Retrieve all resources and authorization information for an account:
     *
     * @param {string} accountName name of account
     * @returns {Promise<GetAccountInfo>} account
     */
    JsonRpc.prototype.get_account_info = function (accountName) {
        var url = "".concat(endpoints_1.GET_ACCOUNT_INFO, "/").concat(this.chain, "/").concat(accountName);
        return this.get(url);
    };
    /**
     * [GET /api/balances]
     *
     * Retrieve only token balances for an account
     *
     * @param {string} accountName name of account
     * @returns {Promise<GetBalances>} balances
     */
    JsonRpc.prototype.get_balances = function (accountName) {
        var url = "".concat(endpoints_1.GET_BALANCES, "/").concat(this.chain, "/").concat(accountName);
        return this.get(url);
    };
    /**
     * [GET /api/key]
     *
     * Retrieve all accounts in all known EOS networks dependent on a public key:
     *
     * @param {string} key public key
     * @returns {Promise<GetKeyAccounts[]>} accounts per network
     */
    JsonRpc.prototype.get_all_key_accounts = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = __spreadArray([], __read(new Set(Object.values(chainToEndpoint))), false).map(function (endpoint) {
                            var url = "".concat(endpoints_1.GET_KEY_ACCOUNTS, "/").concat(key);
                            return _this.get(url, endpoint);
                        });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * [GET /api/key]
     *
     * Retrieve all accounts in network
     *
     * @param {string} key public key
     * @returns {Promise<GetKeyAccounts>} accounts
     */
    JsonRpc.prototype.get_key_accounts = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                url = "".concat(endpoints_1.GET_KEY_ACCOUNTS, "/").concat(key);
                return [2 /*return*/, this.get(url)];
            });
        });
    };
    /**
     * [GET /api/networks]
     *
     * Retrieve all accounts in all known EOS networks dependent on a public key:
     *
     * @returns {Promise<GetNetworks>} accounts
     */
    JsonRpc.prototype.get_networks = function () {
        return this.get(endpoints_1.GET_NETWORKS);
    };
    /**
     * [GET /api/sync]
     *
     * returns a plain text with delay in seconds that this server's blockchain database is behind the real time, and a status: OK if the delay is within 180 seconds, or 'OUT_OF_SYNC' otherwise.
     *
     * @returns {Promise<string>} get sync
     */
    JsonRpc.prototype.get_sync_info = function () {
        var url = "".concat(endpoints_1.GET_SYNC_INFO, "/").concat(this.chain);
        return this.get(url);
    };
    /**
     * [GET /api/tokenbalance]
     *
     *  returns a plain text with numeric output indicating the token balance. Zero is returned if the token is not present or does not exist.
     *
     * @param {string} account owner of token
     * @param {string} contract token contract
     * @param {string} token token symbol
     * @returns {Promise<string>} token balance
     */
    JsonRpc.prototype.get_token_balance = function (account, contract, token) {
        var url = "".concat(endpoints_1.GET_TOKEN_BALANCE, "/").concat(this.chain, "/").concat(account, "/").concat(contract, "/").concat(token);
        return this.get(url);
    };
    /**
     * [GET /api/topholders]
     *
     * returns top NUM holders of a specified token in a JSON array containing arrays of (account, amount) pairs. NUM must not be less than 10 or more than 1000.
     *
     * @param {string} contract token contract
     * @param {string} token token symbol
     * @param {string} num number of top holders (min 10, max 1000)
     *
     * @returns {Promise<string>} token balance
     */
    JsonRpc.prototype.get_topholders = function (contract, token, num) {
        var url = "".concat(endpoints_1.GET_TOPHOLDERS, "/").concat(this.chain, "/").concat(contract, "/").concat(token, "/").concat(num);
        return this.get(url);
    };
    /**
     * [GET /api/usercount]
     *
     * returns a plain text with total number of accounts in the network.
     *
     * @returns {Promise<string>} token balance
     */
    JsonRpc.prototype.get_usercount = function () {
        var url = "".concat(endpoints_1.GET_USERCOUNT, "/").concat(this.chain);
        return this.get(url);
    };
    /**
     * [GET /api/topram]
     *
     * returns top NUM RAM buyers in a JSON array containing arrays of (account, bytes) pairs. NUM must not be less than 10 or more than 1000.
     *
     * @param {string} num number of top holders (min 10, max 1000)
     *
     * @returns {Promise<GetTopRam>} top ram holders
     */
    JsonRpc.prototype.get_topram = function (num) {
        var url = "".concat(endpoints_1.GET_TOPRAM, "/").concat(this.chain, "/").concat(num);
        return this.get(url);
    };
    /**
     * [GET /api/topstake]
     *
     * returns top NUM RAM buyers in a JSON array containing arrays of (account, bytes) pairs. NUM must not be less than 10 or more than 1000.
     *
     * @param {string} num returns top NUM stake holders by sum of CPU and Net stakes, in a JSON array containing arrays of (account, cpu_weight, net_weight) tuples. NUM must not be less than 10 or more than 1000.
     *
     * @returns {Promise<GetTopStake>} top stake holders
     */
    JsonRpc.prototype.get_topstake = function (num) {
        var url = "".concat(endpoints_1.GET_TOPSTAKE, "/").concat(this.chain, "/").concat(num);
        return this.get(url);
    };
    /**
     * [GET /api/codehash]
     *
     * retrieves all accounts in all known EOS networks by contract hash.
     *
     * @param {string} num returns top NUM stake holders by sum of CPU and Net stakes, in a JSON array containing arrays of (account, cpu_weight, net_weight) tuples. NUM must not be less than 10 or more than 1000.
     *
     * @returns {Promise<GetCodehash>} accounts
     */
    JsonRpc.prototype.get_codehash = function (hash) {
        var url = "".concat(endpoints_1.GET_CODEHASH, "/").concat(hash);
        return this.get(url);
    };
    /**
     * [GET /api/holdercount]
     *
     * returns a plaintext integer indicating the number of accounts with positive balance for a specified token.
     *
     * @param {string} contract token contract
     * @param {string} token token symbol
     *
     * @returns {Promise<number>} count
     */
    JsonRpc.prototype.get_tokenholder_count = function (contract, token) {
        var url = "".concat(endpoints_1.GET_TOKEN_HOLDER_COUNT, "/").concat(this.chain, "/").concat(contract, "/").concat(token);
        return this.get(url);
    };
    /**
     * [WS get_token_holders]
     *
     * Get all token holders of a contract and symbol
     *
     * @param contract token contract
     * @param token token symbol
     * @returns
     */
    JsonRpc.prototype.get_token_holders = function (contract, token) {
        var _this = this;
        var reqId = ++this.wsRequestId;
        var balances = [];
        return new Promise(function (resolve, reject) {
            _this.wsClient.on('error', function (err) { return reject(err); });
            _this.wsClient.methods.set('reqdata', function (_, params) {
                if (params.end) {
                    resolve(balances);
                }
                balances.push({
                    account: params.data.account,
                    amount: +params.data.amount,
                });
            });
            try {
                _this.wsClient.call(endpoints_1.GET_TOKEN_HOLDERS, {
                    reqid: reqId,
                    network: _this.chain,
                    contract: contract,
                    currency: token,
                });
            }
            catch (err) {
                reject(err);
                return;
            }
        });
    };
    /**
     * [WS get_accounts_from_keys]
     *
     * Get all token holders of a contract and symbol
     *
     * @param keys[] array of keys
     * @returns
     */
    JsonRpc.prototype.get_accounts_from_keys = function (keys) {
        var _this = this;
        var reqId = ++this.wsRequestId;
        var accounts = [];
        return new Promise(function (resolve, reject) {
            _this.wsClient.on('error', function (err) { return reject(err); });
            _this.wsClient.methods.set('reqdata', function (_, params) {
                if (params.end) {
                    resolve(accounts);
                }
                accounts.push({
                    account_name: params.data.account_name,
                    perm: params.data.perm,
                    weight: +params.data.weight,
                    pubkey: params.data.pubkey,
                });
            });
            try {
                _this.wsClient.call(endpoints_1.GET_ACCOUNTS_FROM_KEYS, {
                    reqid: reqId,
                    network: _this.chain,
                    keys: keys,
                });
            }
            catch (err) {
                reject(err);
                return;
            }
        });
    };
    return JsonRpc;
}());
exports.JsonRpc = JsonRpc;
//# sourceMappingURL=jsonrpc.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/rpcerror.js":
/*!*************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/rpcerror.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcStatusError = exports.RpcError = void 0;
/**
 * @private
 * @module RPC-Error
 *
 * copyright defined in eosjs/LICENSE.txt
 */
var RpcError = /** @class */ (function (_super) {
    __extends(RpcError, _super);
    function RpcError(json) {
        var _this = this;
        if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
        }
        else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
        }
        else {
            _this = _super.call(this, json.message) || this;
        }
        Object.setPrototypeOf(_this, RpcError.prototype);
        _this.json = json;
        return _this;
    }
    return RpcError;
}(Error));
exports.RpcError = RpcError;
/**
 * @private
 */
var RpcStatusError = /** @class */ (function (_super) {
    __extends(RpcStatusError, _super);
    function RpcStatusError(response) {
        var _this = this;
        if (response.status === 405) {
            _this = _super.call(this, response.statusText) || this;
        }
        else {
            _this = _super.call(this) || this;
        }
        Object.setPrototypeOf(_this, RpcStatusError.prototype);
        _this.response = response;
        return _this;
    }
    return RpcStatusError;
}(Error));
exports.RpcStatusError = RpcStatusError;
//# sourceMappingURL=rpcerror.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/types/api.js":
/*!**************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/types/api.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/dist/wrap-constants.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/dist/wrap-constants.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Chains": () => (/* binding */ Chains),
/* harmony export */   "ExtendedAssetParser": () => (/* binding */ ExtendedAssetParser),
/* harmony export */   "Networks": () => (/* binding */ Networks),
/* harmony export */   "Status": () => (/* binding */ Status),
/* harmony export */   "Type": () => (/* binding */ Type),
/* harmony export */   "WRAP_AUTH_ACTION": () => (/* binding */ WRAP_AUTH_ACTION),
/* harmony export */   "WRAP_CONTRACT": () => (/* binding */ WRAP_CONTRACT),
/* harmony export */   "accountParser": () => (/* binding */ accountParser),
/* harmony export */   "addressParser": () => (/* binding */ addressParser),
/* harmony export */   "authorizationParser": () => (/* binding */ authorizationParser),
/* harmony export */   "authorizationsParser": () => (/* binding */ authorizationsParser),
/* harmony export */   "baseActionParser": () => (/* binding */ baseActionParser),
/* harmony export */   "baseActionSerializedParser": () => (/* binding */ baseActionSerializedParser),
/* harmony export */   "createAbstractAuthParser": () => (/* binding */ createAbstractAuthParser),
/* harmony export */   "depositBodyParser": () => (/* binding */ depositBodyParser),
/* harmony export */   "exchangeRateParser": () => (/* binding */ exchangeRateParser),
/* harmony export */   "exchangeRatesParser": () => (/* binding */ exchangeRatesParser),
/* harmony export */   "explorerLinkByChain": () => (/* binding */ explorerLinkByChain),
/* harmony export */   "generateAddressBodyParser": () => (/* binding */ generateAddressBodyParser),
/* harmony export */   "generateAddressResponse": () => (/* binding */ generateAddressResponse),
/* harmony export */   "generateAuthParser": () => (/* binding */ generateAuthParser),
/* harmony export */   "initializeCoins": () => (/* binding */ initializeCoins),
/* harmony export */   "initializeConstants": () => (/* binding */ initializeConstants),
/* harmony export */   "isSameToken": () => (/* binding */ isSameToken),
/* harmony export */   "otcOrderResponseParser": () => (/* binding */ otcOrderResponseParser),
/* harmony export */   "otcQuoteBodyParser": () => (/* binding */ otcQuoteBodyParser),
/* harmony export */   "otcQuoteResponseParser": () => (/* binding */ otcQuoteResponseParser),
/* harmony export */   "rateParser": () => (/* binding */ rateParser),
/* harmony export */   "similarChains": () => (/* binding */ similarChains),
/* harmony export */   "singleActionTransactionParser": () => (/* binding */ singleActionTransactionParser),
/* harmony export */   "transactionParser": () => (/* binding */ transactionParser),
/* harmony export */   "webauthActionParser": () => (/* binding */ webauthActionParser),
/* harmony export */   "withdrawBodyParser": () => (/* binding */ withdrawBodyParser),
/* harmony export */   "withdrawHistoryMetalResponseParser": () => (/* binding */ withdrawHistoryMetalResponseParser),
/* harmony export */   "withdrawHistoryMetalSwapParser": () => (/* binding */ withdrawHistoryMetalSwapParser),
/* harmony export */   "withdrawMetalResponseParser": () => (/* binding */ withdrawMetalResponseParser),
/* harmony export */   "withdrawalFeeQuoteParser": () => (/* binding */ withdrawalFeeQuoteParser),
/* harmony export */   "wrapParser": () => (/* binding */ wrapParser),
/* harmony export */   "wrapSetConfParser": () => (/* binding */ wrapSetConfParser),
/* harmony export */   "wrapStartParser": () => (/* binding */ wrapStartParser)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js");
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zod__WEBPACK_IMPORTED_MODULE_0__);


var _similarChains, _explorerLinkByChain;

var Chains;

(function (Chains) {
  Chains["BitcoinMainnet"] = "Bitcoin";
  Chains["BitcoinTestnet"] = "Bitcoin (Testnet)";
  Chains["EthereumMainnet"] = "Ethereum";
  Chains["EthereumRopsten"] = "Ethereum (Ropsten)";
  Chains["LitecoinMainnet"] = "Litecoin";
  Chains["LitecoinTestnet"] = "Litecoin (Testnet)";
  Chains["BitcoinCashMainnet"] = "Bitcoin Cash";
  Chains["BitcoinCashTestnet"] = "Bitcoin Cash (Testnet)";
  Chains["StellarMainnet"] = "Stellar";
  Chains["StellarTestnet"] = "Stellar (Testnet)";
  Chains["ProtonMainnet"] = "Proton";
  Chains["ProtonTestnet"] = "Proton (Testnet)";
  Chains["PolkadotMainnet"] = "Polkadot";
  Chains["BinanceBEP2"] = "Binance (BEP2)";
  Chains["BinanceBEP20"] = "Binance (BEP20)";
  Chains["EosMainnet"] = "EOS";
  Chains["EosTestnet"] = "EOS (Jungle Testnet)";
  Chains["HederaMainnet"] = "Hedera (Mainnet)";
  Chains["HederaTestnet"] = "Hedera (Testnet)";
  Chains["DogeMainnet"] = "Dogecoin";
  Chains["CardanoMainnet"] = "Cardano";
  Chains["AvalancheXChain"] = "Avalanche X-Chain";
  Chains["AvalancheCChain"] = "Avalanche C-Chain";
  Chains["PolygonMainnet"] = "Polygon";
  Chains["TerraMainnet"] = "Terra";
})(Chains || (Chains = {}));

var Networks;

(function (Networks) {
  Networks["Mainnet"] = "mainnet";
  Networks["Testnet"] = "testnet";
  Networks["Ropsten"] = "ropsten";
  Networks["ERC20"] = "erc20";
  Networks["BEP20"] = "bep20";
  Networks["XLM"] = "xlm";
})(Networks || (Networks = {}));

var similarChains = (_similarChains = {}, _similarChains[Chains.EthereumMainnet] = [Chains.BinanceBEP20], _similarChains[Chains.BinanceBEP20] = [Chains.EthereumMainnet], _similarChains);
var explorerLinkByChain = (_explorerLinkByChain = {}, _explorerLinkByChain[Chains.BitcoinMainnet] = function (txid) {
  return "https://blockchain.com/btc/tx/" + txid;
}, _explorerLinkByChain[Chains.BitcoinTestnet] = function (txid) {
  return "https://blockstream.info/testnet/tx/" + txid;
}, _explorerLinkByChain[Chains.EthereumMainnet] = function (txid) {
  return "https://etherscan.io/tx/" + txid;
}, _explorerLinkByChain[Chains.EthereumRopsten] = function (txid) {
  return "https://ropsten.etherscan.io/tx/" + txid;
}, _explorerLinkByChain[Chains.LitecoinMainnet] = function (txid) {
  return "https://blockchair.com/litecoin/transaction/" + txid;
}, _explorerLinkByChain[Chains.LitecoinTestnet] = function (txid) {
  return "https://blockexplorer.one/litecoin/testnet/blockHash/" + txid;
}, _explorerLinkByChain[Chains.BitcoinCashMainnet] = function (txid) {
  return "https://blockchair.com/bitcoin-cash/transaction/" + txid;
}, _explorerLinkByChain[Chains.BitcoinCashTestnet] = function (txid) {
  return "https://blockexplorer.one/bitcoin-cash/testnet/blockHash/" + txid;
}, _explorerLinkByChain[Chains.StellarMainnet] = function (txid) {
  return "https://blockchair.com/stellar/transaction/" + txid;
}, _explorerLinkByChain[Chains.StellarTestnet] = function (txid) {
  return "https://testnet.steexp.com/tx/" + txid;
}, _explorerLinkByChain[Chains.ProtonMainnet] = function (txid) {
  return "https://proton.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.ProtonTestnet] = function (txid) {
  return "https://proton-test.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.PolkadotMainnet] = function (txid) {
  return "https://polkadot.subscan.io/extrinsic/" + txid;
}, _explorerLinkByChain[Chains.BinanceBEP2] = function (txid) {
  return "https://binance.mintscan.io/txs/" + txid;
}, _explorerLinkByChain[Chains.BinanceBEP20] = function (txid) {
  return "https://bscscan.com/tx/" + txid;
}, _explorerLinkByChain[Chains.EosMainnet] = function (txid) {
  return "https://bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.EosTestnet] = function (txid) {
  return "https://jungle.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.HederaMainnet] = function (txid) {
  return "https://app.dragonglass.me/transactions/" + txid;
}, _explorerLinkByChain[Chains.HederaTestnet] = function (txid) {
  return "https://testnet.dragonglass.me/transactions/" + txid;
}, _explorerLinkByChain[Chains.DogeMainnet] = function (txid) {
  return "https://blockchair.com/dogecoin/transaction/" + txid;
}, _explorerLinkByChain[Chains.CardanoMainnet] = function (txid) {
  return "https://explorer.cardano.org/en/transaction?id=" + txid;
}, _explorerLinkByChain[Chains.AvalancheXChain] = function (txid) {
  return "https://avascan.info/blockchain/x/tx/" + txid;
}, _explorerLinkByChain[Chains.AvalancheCChain] = function (txid) {
  return "https://snowtrace.io/tx/" + txid;
}, _explorerLinkByChain[Chains.PolygonMainnet] = function (txid) {
  return "https://polygonscan.com/tx/" + txid;
}, _explorerLinkByChain[Chains.TerraMainnet] = function (txid) {
  return "https://terra.stake.id/?#/tx/" + txid;
}, _explorerLinkByChain);
var initializeCoins = function initializeCoins(protonChain) {
  var IS_MAINNET = protonChain === 'proton';
  var IS_TESTNET = protonChain === 'proton-test';
  var coins = [{
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Proton',
    coin: 'XPR',
    xtokenSymbol: 'XPR',
    xtokenPrecision: 4,
    xtokenContract: 'eosio.token',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'XPR-ERC20',
      symbol: 'XPR',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 4,
      contract: '0xD7EFB00D12C2C13131FD319336FDF952525DA2AF',
      hasWithdrawMemo: false
    }, {
      wallet: 'XPR-BEP20',
      symbol: 'XPR',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 4,
      contract: '0x5DE3939B2F811A61D830E6F52D13B066881412AB',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/eosio-tokenXPR.png',
    coingeckoId: 'proton'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'USD Coin',
    coin: 'USDC',
    xtokenSymbol: 'XUSDC',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'USDC',
      symbol: 'USDC',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 6,
      contract: '0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48',
      hasWithdrawMemo: false
    }, {
      wallet: 'USDC-BEP20',
      symbol: 'USDC',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: '0x8AC76A51CC950D9822D68B83FE1AD97B32CD580D',
      hasWithdrawMemo: false
    }, {
      wallet: 'USDC-XLM',
      symbol: 'USDC',
      chain: Chains.StellarMainnet,
      network: Networks.XLM,
      precision: 7,
      contract: undefined,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'USDC',
      symbol: 'USDC',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 6,
      contract: '0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUSDC.png',
    coingeckoId: 'usd-coin'
  }, {
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Metal',
    coin: 'MTL',
    xtokenSymbol: 'XMT',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'MTL',
      symbol: 'MTL',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 8,
      contract: '0xF433089366899D83A9F26A773D59EC7ECF30355E',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXMT.png',
    coingeckoId: 'metal'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'Bitcoin',
    coin: 'BTC',
    xtokenSymbol: 'XBTC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BTC',
      symbol: 'BTC',
      chain: Chains.BitcoinMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'BTC',
      symbol: 'BTC',
      chain: Chains.BitcoinTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXBTC.png',
    coingeckoId: 'bitcoin'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'Ethereum',
    coin: 'ETH',
    xtokenSymbol: 'XETH',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'ETH',
      symbol: 'ETH',
      chain: Chains.EthereumMainnet,
      network: Networks.Mainnet,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'ETH',
      symbol: 'ETH',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXETH.png',
    coingeckoId: 'ethereum'
  }, {
    allowSwap: true,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Loan',
    coin: 'LOAN',
    xtokenSymbol: 'LOAN',
    xtokenPrecision: 4,
    xtokenContract: 'loan.token',
    wallets: [],
    image: 'https://www.protonchain.com/images/tokens/loan.tokenLOAN.png',
    coingeckoId: 'proton-loan'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Tether',
    coin: 'USDT',
    xtokenSymbol: 'XUSDT',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'USDT',
      symbol: 'USDT',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 6,
      contract: '0xDAC17F958D2EE523A2206206994597C13D831EC7',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'USDT',
      symbol: 'USDT',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 6,
      contract: '0xDAC17F958D2EE523A2206206994597C13D831EC7',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUSDT.png',
    coingeckoId: 'tether'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'TrueUSD',
    coin: 'TUSD',
    xtokenSymbol: 'XTUSD',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'TUSD',
      symbol: 'TUSD',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x0000000000085D4780B73119B644AE5ECD22B376',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXTUSD.png',
    coingeckoId: 'true-usd'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Paxos Standard',
    coin: 'PAX',
    xtokenSymbol: 'XPAX',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'PAX',
      symbol: 'PAX',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x8E870D67F660D95D5BE530380D0EC0BD388289E1',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXPAX.png',
    coingeckoId: 'usdp'
  }, {
    allowSwap: false,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Paxos Gold',
    coin: 'PAXG',
    xtokenSymbol: 'XPAXG',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'PAXG',
      symbol: 'PAXG',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x45804880DE22913DAFE09F4980848ECE6ECBAF78',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'PAXG',
      symbol: 'PAXG',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x45804880DE22913DAFE09F4980848ECE6ECBAF78',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXPAXG.png',
    coingeckoId: 'pax-gold'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Uniswap',
    coin: 'UNI',
    xtokenSymbol: 'XUNI',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'UNI',
      symbol: 'UNI',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x1F9840A85D5AF5BF1D1762F925BDADDC4201F984',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'UNI',
      symbol: 'UNI',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x1F9840A85D5AF5BF1D1762F925BDADDC4201F984',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUNI.png',
    coingeckoId: 'uniswap'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: '1INCH',
    coin: '1INCH',
    xtokenSymbol: 'XINCH',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: '1INCH',
      symbol: '1INCH',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x111111111117DC0AA78B770FA6A738034120C302',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXINCH.png',
    coingeckoId: '1inch'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Chainlink',
    coin: 'LINK',
    xtokenSymbol: 'XLINK',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LINK',
      symbol: 'LINK',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x514910771AF9CA656AF840DFF83E8264ECF986CA',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXLINK.png',
    coingeckoId: 'chainlink'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Litecoin',
    coin: 'LTC',
    xtokenSymbol: 'XLTC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LTC',
      symbol: 'LTC',
      chain: Chains.LitecoinMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'LTC',
      symbol: 'LTC',
      chain: Chains.LitecoinTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXLTC.png',
    coingeckoId: 'litecoin'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Bitcoin Cash',
    coin: 'BCH',
    xtokenSymbol: 'XBCH',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BCH',
      symbol: 'BCH',
      chain: Chains.BitcoinCashMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'BCH',
      symbol: 'BCH',
      chain: Chains.BitcoinCashTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXBCH.png',
    coingeckoId: 'bitcoin-cash'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Stellar',
    coin: 'XLM',
    xtokenSymbol: 'XXLM',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'XLM',
      symbol: 'XLM',
      chain: Chains.StellarMainnet,
      network: Networks.Mainnet,
      precision: 7,
      contract: undefined,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'XLM',
      symbol: 'XLM',
      chain: Chains.StellarTestnet,
      network: Networks.Testnet,
      precision: 7,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXXLM.png',
    coingeckoId: 'stellar'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Sense',
    coin: 'SENSE',
    xtokenSymbol: 'XSENSE',
    xtokenPrecision: 4,
    xtokenContract: 'sense',
    wallets: [],
    image: 'https://www.protonchain.com/images/tokens/senseXSENSE.png',
    coingeckoId: 'sense'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Polkadot',
    coin: 'DOT',
    xtokenSymbol: 'XDOT',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'DOT',
      symbol: 'DOT',
      chain: Chains.PolkadotMainnet,
      network: Networks.Mainnet,
      precision: 10,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXDOT.png',
    coingeckoId: 'polkadot'
  }, {
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Binance Coin',
    coin: 'BNB',
    xtokenSymbol: 'XBNB',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BNB',
      symbol: 'BNB',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXBNB.png',
    coingeckoId: 'binancecoin'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'EOS',
    coin: 'EOS',
    xtokenSymbol: 'XEOS',
    xtokenPrecision: 4,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'EOS',
      symbol: 'EOS',
      chain: Chains.EosMainnet,
      network: Networks.Mainnet,
      precision: 4,
      contract: undefined,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'EOS',
      symbol: 'EOS',
      chain: Chains.EosTestnet,
      network: Networks.Testnet,
      precision: 4,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXEOS.png',
    coingeckoId: 'eos'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Dogecoin',
    coin: 'DOGE',
    xtokenSymbol: 'XDOGE',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'DOGE',
      symbol: 'DOGE',
      chain: Chains.DogeMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXDOGE.png',
    coingeckoId: 'dogecoin'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Cardano',
    coin: 'ADA',
    xtokenSymbol: 'XADA',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'ADA',
      symbol: 'ADA',
      chain: Chains.CardanoMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXADA.png',
    coingeckoId: 'cardano'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Avalanche',
    coin: 'AVAX',
    xtokenSymbol: 'XAVAX',
    xtokenPrecision: 9,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'AVAX',
      symbol: 'AVAX',
      chain: Chains.AvalancheXChain,
      network: Networks.Mainnet,
      precision: 9,
      contract: undefined,
      hasWithdrawMemo: false
    }, {
      wallet: 'AVAX',
      symbol: 'AVAX',
      chain: Chains.AvalancheCChain,
      network: Networks.Mainnet,
      precision: 9,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXAVAX.png',
    coingeckoId: 'avalanche-2'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Polygon',
    coin: 'MATIC',
    xtokenSymbol: 'XMATIC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'MATIC',
      symbol: 'MATIC',
      chain: Chains.PolygonMainnet,
      network: Networks.Mainnet,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXMATIC.png',
    coingeckoId: 'matic-network'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Luna',
    coin: 'LUNA',
    xtokenSymbol: 'XLUNA',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LUNA',
      symbol: 'LUNA',
      chain: Chains.TerraMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXLUNA.png',
    coingeckoId: 'terra-luna'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'TerraUSD',
    coin: 'UST',
    xtokenSymbol: 'XUST',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'UST',
      symbol: 'UST',
      chain: Chains.TerraMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUST.png',
    coingeckoId: 'terrausd'
  }, {
    allowSwap: false,
    allowBridge: IS_TESTNET,
    allowLend: false,
    allowBorrow: false,
    name: 'HBAR',
    coin: 'HBAR',
    xtokenSymbol: 'XHBAR',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_TESTNET ? [{
      wallet: 'HBAR',
      symbol: 'HBAR',
      chain: Chains.HederaTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXHBAR.png',
    coingeckoId: 'hedera-hashgraph'
  }]; // Validation

  var walletWithDuplicateChains = coins.find(function (coin) {
    var chains = coin.wallets.map(function (wallet) {
      return wallet.chain;
    });
    return new Set(chains).size !== chains.length;
  });

  if (walletWithDuplicateChains) {
    throw new Error("Coin " + walletWithDuplicateChains.coin + " has duplicate chains in wallet");
  }

  return {
    allCoins: coins,
    swapCoins: coins.filter(function (coin) {
      return coin.allowSwap;
    }),
    bridgeCoins: coins.filter(function (coin) {
      return coin.allowBridge;
    }),
    lendCoins: coins.filter(function (coin) {
      return coin.allowLend;
    }),
    borrowCoins: coins.filter(function (coin) {
      return coin.allowBorrow;
    }),
    loanCoins: coins.filter(function (coin) {
      return coin.allowLend || coin.allowBorrow;
    }),
    allEnabledCoins: coins.filter(function (coin) {
      return coin.allowSwap || coin.allowBridge;
    })
  };
};

var accountParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().regex(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
var authorizationParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  actor: accountParser,
  permission: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var authorizationsParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(authorizationParser).min(1);
var ExtendedAssetParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  quantity: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  contract: accountParser
});

var rawTransactionParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  expiration: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  ref_block_num: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  ref_block_prefix: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  max_net_usage_words: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  max_cpu_usage_ms: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  delay_sec: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  context_free_actions: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)( /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.any)()),
  transaction_extensions: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)( /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.any)())
});
var baseActionParser = function baseActionParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    account: contract === '*' ? accountParser : (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(contract),
    name: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(action),
    data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)(data),
    authorization: authorizationsParser
  });
};
var baseActionSerializedParser = function baseActionSerializedParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    account: contract === '*' ? accountParser : (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(contract),
    name: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(action),
    data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().or((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)(data)),
    authorization: authorizationsParser
  });
};
var webauthActionParser = function webauthActionParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    account: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)('webauthn'),
    name: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)('exec'),
    data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
      account: accountParser,
      key: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
        key: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)((0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().or((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
          modulus: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
          exponent: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
        }))),
        user_presence: (0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
        rpid: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
      }),
      nonce: (0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
      permissions: authorizationsParser,
      signature: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
        auth_data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
        client_json: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
        signature: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
      }),
      trx: rawTransactionParser.merge((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
        actions: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(baseActionSerializedParser(contract, action, data)).length(1)
      }))
    }),
    authorization: authorizationsParser
  });
};
var singleActionTransactionParser = function singleActionTransactionParser(contract, action, data) {
  var baseAction = baseActionParser(contract, action, data);
  var webauthAction = webauthActionParser(contract, action, data);
  return rawTransactionParser.merge((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    actions: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(baseAction.or(webauthAction)).length(1)
  }));
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var WRAP_CONTRACT = 'proton.wrap';
var WRAP_AUTH_ACTION = 'generateauth';
var initializeConstants = function initializeConstants(chain) {
  var _initializeCoins = initializeCoins(chain),
      swapCoins = _initializeCoins.swapCoins,
      bridgeCoins = _initializeCoins.bridgeCoins,
      allEnabledCoins = _initializeCoins.allEnabledCoins,
      allCoins = _initializeCoins.allCoins,
      lendCoins = _initializeCoins.lendCoins,
      borrowCoins = _initializeCoins.borrowCoins,
      loanCoins = _initializeCoins.loanCoins;

  var constants = {
    SWAP_CONTRACT: 'proton.swaps',
    FEE_FACTOR: 10000,
    GOOGLE_MAPS_KEY: 'AIzaSyDb2_CrK032kSIqBXbkdwmaLKWELl0SxVs',
    SWAP_URL: chain === 'proton' ? 'https://otc.protonswap.com' : 'https://otc-test.protonswap.com',
    WRAP_SERVER_URL: chain === 'proton' ? 'https://www.api.bloks.io/proton-wrap-public2' : 'https://www.api.bloks.io/proton-wrap-testnet-public2',
    WRAP_CONTRACT: WRAP_CONTRACT,
    WRAP_ACTIONS: {
      SAVE_ADDRESS: 'saveaddress2',
      DELETE_ADDRESS: 'deladdress2',
      WRAP_START: 'wrapstart2',
      WRAP_FINISH: 'wrapfinish2',
      WRAP_PROCESS: 'wrapprocess2',
      WRAP_SET_CONF: 'wrapsetconf2'
    },
    WRAP_TABLES: {
      ADDRESSES: 'addresses2',
      WRAPS: 'wraps2'
    },
    ADDRESSES_INDEXES: {
      BY_ACCOUNT: 2,
      BY_ADDR_HASH: 3
    },
    WRAPS_INDEXES: {
      BY_ACCOUNT: 2,
      BY_STATUS: 3,
      BY_WRAP_HASH: 4
    },
    WRAP_PROCESS_TIMER: 5000,
    FARM_CONTRACT: 'yield.farms',
    WEBHOOK_PERMISSION: 'webhook',
    PUBLIC_PERMISSION: 'public',
    LIGHT_PERMISSION: 'light',
    WRAP_AUTH_ACTION: WRAP_AUTH_ACTION,
    METAL_ENDPOINT: chain === 'proton' ? 'https://cirrus.metalpay.com' : 'https://cirrus-dev.metalpay.com',
    METAL_PROTON_ENDPOINT: chain === 'proton' ? 'https://api.protonchain.com' : 'https://api-dev.protonchain.com',
    PROTON_ENDPOINTS: chain === 'proton' ? ['https://proton.greymass.com', 'https://proton.eoscafeblock.com', 'https://proton.cryptolions.io', 'https://proton.eosusa.news'] : ['https://testnet.protonchain.com'],
    CHAIN_ID: chain === 'proton' ? '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0' : '71ee83bcf52142d61019d95f9cc5427ba6a0d7ff8accd9e2088ae2abeaf3d3dd',
    CHAIN: chain,
    SWAP_COINS: swapCoins,
    BRIDGE_COINS: bridgeCoins,
    ALL_ENABLED_COINS: allEnabledCoins,
    LEND_COINS: lendCoins,
    BORROW_COINS: borrowCoins,
    LOAN_COINS: loanCoins,
    ALL_COINS: allCoins,
    findBridgeCoinWalletByXtokenAndChain: function findBridgeCoinWalletByXtokenAndChain(xtokenSymbol, chain) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.xtokenSymbol === xtokenSymbol;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.chain === chain;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    },
    findBridgeCoinWallet: function findBridgeCoinWallet(coin, wallet) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.coin === coin;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.wallet === wallet;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    },
    findBridgeCoinNetwork: function findBridgeCoinNetwork(coin, network) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.coin === coin;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.network === network;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    }
  };
  return constants;
};

var createAbstractAuthParser = function createAbstractAuthParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    signer: authorizationParser,
    signatures: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)((0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()).length(1),
    transaction: singleActionTransactionParser(contract, action, data)
  });
};
var generateAuthData = {
  time: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  protonAccount: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
};
var generateAuthParser = /*#__PURE__*/createAbstractAuthParser(WRAP_CONTRACT, WRAP_AUTH_ACTION, generateAuthData);

var addressParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  index: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  account: accountParser,
  chain: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address_hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var generateAddressBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  coin: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
}).merge(generateAuthParser);
var generateAddressResponse = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  coin: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  memo: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});

var rateParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  counterCurrency: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  price: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  priceChangePercent: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  marketCap: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  volume: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  timestamp: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});
var exchangeRateParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  contract: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  symbol: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  rank: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  rates: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(rateParser)
});
var exchangeRatesParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(exchangeRateParser);

var Type;

(function (Type) {
  Type["RECEIVE"] = "receive";
  Type["SEND"] = "send";
})(Type || (Type = {}));

var depositBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  type: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.nativeEnum)(Type),
  hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  coin: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var transactionParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  value: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  valueString: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  type: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.nativeEnum)(Type),
  state: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  blockHash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional().nullable(),
  blockHeight: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)().optional().nullable()
});

var otcOrderResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  success: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.boolean)(),
  transaction_id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  errormsg: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});
var otcQuoteBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  baseAmount: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  baseSymbol: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  quoteSymbol: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var otcQuoteResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  success: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.boolean)(),
  token: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  qty: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  errormsg: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});

var withdrawData = {
  from: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().refine(function (val) {
    return val !== WRAP_CONTRACT;
  }, {
    message: WRAP_CONTRACT + " must be receiver"
  }),
  to: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(WRAP_CONTRACT),
  quantity: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  memo: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
};
var withdrawBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  signer: authorizationParser,
  signatures: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)((0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()).length(1),
  transaction: /*#__PURE__*/singleActionTransactionParser('*', 'transfer', withdrawData),
  quoteId: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  provider: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});
var withdrawMetalResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  success: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.boolean)(),
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var withdrawalFeeQuoteParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  quoteId: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  estimatedFee: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  currency: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  network: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});

var withdrawHistoryMetalSwapParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  status: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  amount: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  currency: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  network: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  created: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  withdrawalAddress: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  withdrawalHash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});
var withdrawHistoryMetalResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  swaps: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(withdrawHistoryMetalSwapParser),
  page: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  pageSize: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  numberOfElements: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  totalPages: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  totalElements: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});

var Status;

(function (Status) {
  Status["PENDING"] = "pending";
  Status["SUCCESS"] = "success";
  Status["FAIL"] = "fail";
  Status["PROCESSING"] = "processing";
})(Status || (Status = {}));

var wrapStartParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  balance: ExtendedAssetParser,
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  txid: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  chain: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  deposit_address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});
var wrapSetConfParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  wrap_hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});
var wrapParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  index: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  proton_account: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  balance: ExtendedAssetParser,
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  txid: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  chain: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  deposit_address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  status: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.nativeEnum)(Status),
  finish_txid: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wrap_hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});

var isSameToken = function isSameToken(token1, token2) {
  return token1.xtokenSymbol === token2.xtokenSymbol && token1.xtokenPrecision === token2.xtokenPrecision && token1.xtokenContract === token2.xtokenContract;
};


//# sourceMappingURL=wrap-constants.esm.js.map


/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
exports.ZodErrorCode = util_1.util.arrayToEnum([
    'invalid_type',
    'nonempty_array_is_empty',
    'custom_error',
    'invalid_union',
    'invalid_literal_value',
    'invalid_enum_value',
    'unrecognized_keys',
    'invalid_arguments',
    'invalid_return_type',
    'invalid_date',
    'invalid_string',
    'too_small',
    'too_big',
]);
exports.quotelessJson = function (obj) {
    var json = JSON.stringify(obj, null, 2); // {"name":"John Smith"}
    return json.replace(/"([^"]+)":/g, '$1:');
};
var ZodError = /** @class */ (function (_super) {
    __extends(ZodError, _super);
    function ZodError(errors) {
        var _newTarget = this.constructor;
        var _this = _super.call(this) || this;
        _this.errors = [];
        _this.addError = function (sub) {
            _this.errors = _this.errors.concat([sub]);
        };
        _this.addErrors = function (subs) {
            if (subs === void 0) { subs = []; }
            _this.errors = _this.errors.concat(subs);
        };
        _this.flatten = function () {
            var fieldErrors = {};
            var formErrors = [];
            for (var _i = 0, _a = _this.errors; _i < _a.length; _i++) {
                var sub = _a[_i];
                if (sub.path.length > 0) {
                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                    fieldErrors[sub.path[0]].push(sub.message);
                }
                else {
                    formErrors.push(sub.message);
                }
            }
            return { formErrors: formErrors, fieldErrors: fieldErrors };
        };
        // restore prototype chain
        var actualProto = _newTarget.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(_this, actualProto);
        }
        else {
            _this.__proto__ = actualProto;
        }
        _this.errors = errors;
        return _this;
    }
    Object.defineProperty(ZodError.prototype, "message", {
        get: function () {
            // return JSON.stringify(this.errors, null, 2);
            var errorMessage = [
                this.errors.length + " validation issue(s)",
                '',
            ];
            for (var _i = 0, _a = this.errors; _i < _a.length; _i++) {
                var err = _a[_i];
                var pathString = err.path.join('.') || '[[root]]';
                errorMessage.push("  Issue #" + this.errors.indexOf(err) + ": " + err.code + " at " + pathString);
                errorMessage.push("  " + err.message);
                errorMessage.push('');
            }
            return errorMessage.join('\n');
            // return quotelessJson(this);
            // .map(({ path, message }) => {
            //   return path.length ? `${path.join('./index')}: ${message}` : `${message}`;
            // })
            // .join('\n');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodError.prototype, "isEmpty", {
        get: function () {
            return this.errors.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodError.prototype, "formErrors", {
        get: function () {
            return this.flatten();
        },
        enumerable: true,
        configurable: true
    });
    ZodError.create = function (errors) {
        var error = new ZodError(errors);
        return error;
    };
    return ZodError;
}(Error));
exports.ZodError = ZodError;
//# sourceMappingURL=ZodError.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/codegen.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/codegen.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./index */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js"));
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
var isOptional = function (schema) {
    var def = schema._def;
    if (def.t === z.ZodTypes.undefined)
        return true;
    else if (def.t === z.ZodTypes.intersection) {
        return isOptional(def.right) && isOptional(def.left);
    }
    else if (def.t === z.ZodTypes.union) {
        return def.options.map(isOptional).some(function (x) { return x === true; });
    }
    return false;
};
var ZodCodeGenerator = /** @class */ (function () {
    function ZodCodeGenerator() {
        var _this = this;
        this.seen = [];
        this.serial = 0;
        this.randomId = function () {
            return "IZod" + _this.serial++;
        };
        this.findBySchema = function (schema) {
            return _this.seen.find(function (s) { return s.schema === schema; });
        };
        this.findById = function (id) {
            var found = _this.seen.find(function (s) { return s.id === id; });
            if (!found)
                throw new Error("Unfound ID: " + id);
            return found;
        };
        this.dump = function () {
            return "\ntype Identity<T> = T;\n\n" + _this.seen
                .map(function (item) { return "type " + item.id + " = Identity<" + item.type + ">;"; })
                .join('\n\n') + "\n";
        };
        this.setType = function (id, type) {
            var found = _this.findById(id);
            found.type = type;
            return found;
        };
        this.generate = function (schema) {
            var found = _this.findBySchema(schema);
            if (found)
                return found;
            var def = schema._def;
            var id = _this.randomId();
            var ty = {
                schema: schema,
                id: id,
                type: "__INCOMPLETE__",
            };
            _this.seen.push(ty);
            switch (def.t) {
                case z.ZodTypes.string:
                    return _this.setType(id, "string");
                case z.ZodTypes.number:
                    return _this.setType(id, "number");
                case z.ZodTypes.bigint:
                    return _this.setType(id, "bigint");
                case z.ZodTypes.boolean:
                    return _this.setType(id, "boolean");
                case z.ZodTypes.date:
                    return _this.setType(id, "Date");
                case z.ZodTypes.undefined:
                    return _this.setType(id, "undefined");
                case z.ZodTypes.null:
                    return _this.setType(id, "null");
                case z.ZodTypes.any:
                    return _this.setType(id, "any");
                case z.ZodTypes.unknown:
                    return _this.setType(id, "unknown");
                case z.ZodTypes.void:
                    return _this.setType(id, "void");
                case z.ZodTypes.literal:
                    var val = def.value;
                    var literalType = typeof val === 'string' ? "\"" + val + "\"" : "" + val;
                    return _this.setType(id, literalType);
                case z.ZodTypes.enum:
                    return _this.setType(id, def.values.map(function (v) { return "\"" + v + "\""; }).join(' | '));
                case z.ZodTypes.object:
                    var objectLines = [];
                    var shape = def.shape();
                    for (var key in shape) {
                        var childSchema = shape[key];
                        var childType = _this.generate(childSchema);
                        var OPTKEY = isOptional(childSchema) ? '?' : '';
                        objectLines.push("" + key + OPTKEY + ": " + childType.id);
                    }
                    var baseStruct = "{\n" + objectLines
                        .map(function (line) { return "  " + line + ";"; })
                        .join('\n') + "\n}";
                    _this.setType(id, "" + baseStruct);
                    break;
                case z.ZodTypes.tuple:
                    var tupleLines = [];
                    for (var _i = 0, _a = def.items; _i < _a.length; _i++) {
                        var elSchema = _a[_i];
                        var elType = _this.generate(elSchema);
                        tupleLines.push(elType.id);
                    }
                    var baseTuple = "[\n" + tupleLines
                        .map(function (line) { return "  " + line + ","; })
                        .join('\n') + "\n]";
                    return _this.setType(id, "" + baseTuple);
                case z.ZodTypes.array:
                    return _this.setType(id, _this.generate(def.type).id + "[]");
                case z.ZodTypes.function:
                    var args = _this.generate(def.args);
                    var returns = _this.generate(def.returns);
                    return _this.setType(id, "(...args: " + args.id + ")=>" + returns.id);
                case z.ZodTypes.promise:
                    var promValue = _this.generate(def.type);
                    return _this.setType(id, "Promise<" + promValue.id + ">");
                case z.ZodTypes.union:
                    var unionLines = [];
                    for (var _b = 0, _c = def.options; _b < _c.length; _b++) {
                        var elSchema = _c[_b];
                        var elType = _this.generate(elSchema);
                        unionLines.push(elType.id);
                    }
                    return _this.setType(id, unionLines.join(" | "));
                case z.ZodTypes.intersection:
                    return _this.setType(id, _this.generate(def.left).id + " & " + _this.generate(def.right).id);
                case z.ZodTypes.record:
                    return _this.setType(id, "{[k:string]: " + _this.generate(def.valueType).id + "}");
                case z.ZodTypes.lazy:
                    var lazyType = def.getter();
                    return _this.setType(id, _this.generate(lazyType).id);
                case z.ZodTypes.nativeEnum:
                    // const lazyType = def.getter();
                    return _this.setType(id, 'asdf');
                case z.ZodTypes.keyof:
                    // const lazyType = def.getter();
                    return _this.setType(id, "keyof [" + def.values
                        .map(function (val) { return (typeof val === 'string' ? "\"" + val + "\"" : val); })
                        .join(', ') + "]");
                default:
                    util_1.util.assertNever(def);
            }
            return _this.findById(id);
        };
    }
    ZodCodeGenerator.create = function () { return new ZodCodeGenerator(); };
    return ZodCodeGenerator;
}());
exports.ZodCodeGenerator = ZodCodeGenerator;
//# sourceMappingURL=codegen.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/defaultErrorMap.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/defaultErrorMap.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ZodError_1 = __webpack_require__(/*! ./ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
exports.defaultErrorMap = function (error, _ctx) {
    var message;
    switch (error.code) {
        case ZodError_1.ZodErrorCode.invalid_type:
            if (error.received === 'undefined') {
                message = 'Required';
            }
            else {
                message = "Expected " + error.expected + ", received " + error.received;
            }
            break;
        case ZodError_1.ZodErrorCode.nonempty_array_is_empty:
            message = "List must contain at least one item";
            break;
        case ZodError_1.ZodErrorCode.unrecognized_keys:
            message = "Unrecognized key(s) in object: " + error.keys.map(function (k) { return "'" + k + "'"; }).join(', ');
            break;
        case ZodError_1.ZodErrorCode.invalid_union:
            message = "Invalid input";
            break;
        // case ZodErrorCode.invalid_tuple_length:
        //   message = `Expected list of ${error.expected} items, received ${error.received} items`;
        //   break;
        case ZodError_1.ZodErrorCode.invalid_literal_value:
            message = "Input must be \"" + error.expected + "\"";
            break;
        case ZodError_1.ZodErrorCode.invalid_enum_value:
            message = "Input must be one of these values: " + error.options.join(', ');
            break;
        case ZodError_1.ZodErrorCode.invalid_arguments:
            message = "Invalid function arguments";
            break;
        case ZodError_1.ZodErrorCode.invalid_return_type:
            message = "Invalid function return type";
            break;
        case ZodError_1.ZodErrorCode.invalid_date:
            message = "Invalid date";
            break;
        // case ZodErrorCode.too_small:
        //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
        //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
        //   break;
        // case ZodErrorCode.too_big:
        //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
        //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
        //   break;
        case ZodError_1.ZodErrorCode.invalid_string:
            if (error.validation !== 'regex')
                message = "Invalid " + error.validation;
            else
                message = 'Invalid';
            break;
        // case ZodErrorCode.invalid_url:
        //   message = 'Invalid URL.';
        //   break;
        // case ZodErrorCode.invalid_uuid:
        //   message = 'Invalid UUID.';
        //   break;
        case ZodError_1.ZodErrorCode.too_small:
            if (error.type === 'array')
                message = "Should have " + (error.inclusive ? "at least" : "more than") + " " + error.minimum + " items";
            else if (error.type === 'string')
                message = "Should be " + (error.inclusive ? "at least" : "over") + " " + error.minimum + " characters";
            else if (error.type === 'number')
                message = "Value should be greater than " + (error.inclusive ? "or equal to " : "") + error.minimum;
            else
                message = 'Invalid input';
            break;
        case ZodError_1.ZodErrorCode.too_big:
            if (error.type === 'array')
                message = "Should have " + (error.inclusive ? "at most" : "less than") + " " + error.maximum + " items";
            else if (error.type === 'string')
                message = "Should be " + (error.inclusive ? "at most" : "under") + " " + error.maximum + " characters long";
            else if (error.type === 'number')
                message = "Value should be less than " + (error.inclusive ? "or equal to " : "") + error.maximum;
            else
                message = 'Invalid input';
            break;
        case ZodError_1.ZodErrorCode.custom_error:
            message = "Invalid input.";
            break;
        default:
            message = "Invalid input.";
            util_1.util.assertNever(error);
    }
    return { message: message };
    // return `Invalid input.`;
};
//# sourceMappingURL=defaultErrorMap.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = function (message) { return (typeof message === 'string' ? { message: message } : message || {}); };
})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));
//# sourceMappingURL=errorUtil.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/objectUtil.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/objectUtil.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_1 = __webpack_require__(/*! ../types/base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js");
var intersection_1 = __webpack_require__(/*! ../types/intersection */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js");
var object_1 = __webpack_require__(/*! ../types/object */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js");
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = function (first, second) {
        var firstKeys = Object.keys(first);
        var secondKeys = Object.keys(second);
        var sharedKeys = firstKeys.filter(function (k) { return secondKeys.indexOf(k) !== -1; });
        var sharedShape = {};
        for (var _i = 0, sharedKeys_1 = sharedKeys; _i < sharedKeys_1.length; _i++) {
            var k = sharedKeys_1[_i];
            sharedShape[k] = intersection_1.ZodIntersection.create(first[k], second[k]);
        }
        return __assign({}, first, second, sharedShape);
    };
    objectUtil.mergeObjects = function (first) { return function (second) {
        var mergedShape = objectUtil.mergeShapes(first._def.shape(), second._def.shape());
        var merged = new object_1.ZodObject({
            t: base_1.ZodTypes.object,
            checks: (first._def.checks || []).concat((second._def.checks || [])),
            params: {
                strict: first.params.strict && second.params.strict,
            },
            shape: function () { return mergedShape; },
        });
        return merged;
    }; };
})(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
//# sourceMappingURL=objectUtil.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var util;
(function (util) {
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = function (items) {
        var obj = {};
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = function (obj) {
        var validKeys = Object.keys(obj).filter(function (k) { return typeof obj[obj[k]] !== 'number'; });
        var filtered = {};
        for (var _i = 0, validKeys_1 = validKeys; _i < validKeys_1.length; _i++) {
            var k = validKeys_1[_i];
            filtered[k] = obj[k];
        }
        return util.getValues(filtered);
    };
    util.getValues = function (obj) {
        return Object.keys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectValues = function (obj) {
        return Object.keys(obj).map(function (e) {
            return obj[e];
        });
    };
})(util = exports.util || (exports.util = {}));
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* ZOD */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
var string_1 = __webpack_require__(/*! ./types/string */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/string.js");
exports.ZodString = string_1.ZodString;
var number_1 = __webpack_require__(/*! ./types/number */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/number.js");
exports.ZodNumber = number_1.ZodNumber;
var bigint_1 = __webpack_require__(/*! ./types/bigint */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/bigint.js");
exports.ZodBigInt = bigint_1.ZodBigInt;
var boolean_1 = __webpack_require__(/*! ./types/boolean */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/boolean.js");
exports.ZodBoolean = boolean_1.ZodBoolean;
var date_1 = __webpack_require__(/*! ./types/date */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/date.js");
exports.ZodDate = date_1.ZodDate;
var undefined_1 = __webpack_require__(/*! ./types/undefined */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/undefined.js");
exports.ZodUndefined = undefined_1.ZodUndefined;
var null_1 = __webpack_require__(/*! ./types/null */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/null.js");
exports.ZodNull = null_1.ZodNull;
var any_1 = __webpack_require__(/*! ./types/any */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/any.js");
exports.ZodAny = any_1.ZodAny;
var unknown_1 = __webpack_require__(/*! ./types/unknown */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js");
exports.ZodUnknown = unknown_1.ZodUnknown;
var void_1 = __webpack_require__(/*! ./types/void */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/void.js");
exports.ZodVoid = void_1.ZodVoid;
var array_1 = __webpack_require__(/*! ./types/array */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/array.js");
exports.ZodArray = array_1.ZodArray;
var object_1 = __webpack_require__(/*! ./types/object */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js");
exports.ZodObject = object_1.ZodObject;
var union_1 = __webpack_require__(/*! ./types/union */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/union.js");
exports.ZodUnion = union_1.ZodUnion;
var intersection_1 = __webpack_require__(/*! ./types/intersection */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js");
exports.ZodIntersection = intersection_1.ZodIntersection;
var tuple_1 = __webpack_require__(/*! ./types/tuple */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js");
exports.ZodTuple = tuple_1.ZodTuple;
var record_1 = __webpack_require__(/*! ./types/record */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/record.js");
exports.ZodRecord = record_1.ZodRecord;
var function_1 = __webpack_require__(/*! ./types/function */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/function.js");
exports.ZodFunction = function_1.ZodFunction;
var lazy_1 = __webpack_require__(/*! ./types/lazy */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/lazy.js");
exports.ZodLazy = lazy_1.ZodLazy;
var literal_1 = __webpack_require__(/*! ./types/literal */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/literal.js");
exports.ZodLiteral = literal_1.ZodLiteral;
var enum_1 = __webpack_require__(/*! ./types/enum */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/enum.js");
exports.ZodEnum = enum_1.ZodEnum;
var nativeEnum_1 = __webpack_require__(/*! ./types/nativeEnum */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/nativeEnum.js");
exports.ZodNativeEnum = nativeEnum_1.ZodNativeEnum;
var keyof_1 = __webpack_require__(/*! ./types/keyof */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/keyof.js");
var promise_1 = __webpack_require__(/*! ./types/promise */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/promise.js");
exports.ZodPromise = promise_1.ZodPromise;
var base_1 = __webpack_require__(/*! ./types/base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js");
exports.ZodType = base_1.ZodType;
exports.Schema = base_1.ZodType;
exports.ZodSchema = base_1.ZodType;
exports.ZodTypes = base_1.ZodTypes;
// import { ZodError, ZodErrorCode, ZodInvalidTypeError,
// ZodNonEmptyArrayIsEmptyError,
// ZodUnrecognizedKeysError,
// ZodInvalidUnionError,
// ZodInvalidLiteralValueError,
// ZodInvalidEnumValueError,
// ZodInvalidArgumentsError,
// ZodInvalidReturnTypeError,
// ZodInvalidDateError,
// ZodInvalidStringError,
// ZodTooSmallError,
// ZodTooBigError,
// ZodCustomError } from './ZodError';
var parser_1 = __webpack_require__(/*! ./parser */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js");
exports.ZodParsedType = parser_1.ZodParsedType;
var codegen_1 = __webpack_require__(/*! ./codegen */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/codegen.js");
exports.ZodCodeGenerator = codegen_1.ZodCodeGenerator;
var stringType = string_1.ZodString.create;
exports.string = stringType;
var numberType = number_1.ZodNumber.create;
exports.number = numberType;
var bigIntType = bigint_1.ZodBigInt.create;
exports.bigint = bigIntType;
var booleanType = boolean_1.ZodBoolean.create;
exports.boolean = booleanType;
var dateType = date_1.ZodDate.create;
exports.date = dateType;
var undefinedType = undefined_1.ZodUndefined.create;
exports.undefined = undefinedType;
var nullType = null_1.ZodNull.create;
exports["null"] = nullType;
var anyType = any_1.ZodAny.create;
exports.any = anyType;
var unknownType = unknown_1.ZodUnknown.create;
exports.unknown = unknownType;
var voidType = void_1.ZodVoid.create;
exports["void"] = voidType;
var arrayType = array_1.ZodArray.create;
exports.array = arrayType;
var objectType = object_1.ZodObject.create;
exports.object = objectType;
var unionType = union_1.ZodUnion.create;
exports.union = unionType;
var intersectionType = intersection_1.ZodIntersection.create;
exports.intersection = intersectionType;
var tupleType = tuple_1.ZodTuple.create;
exports.tuple = tupleType;
var recordType = record_1.ZodRecord.create;
exports.record = recordType;
var functionType = function_1.ZodFunction.create;
exports["function"] = functionType;
var lazyType = lazy_1.ZodLazy.create;
exports.lazy = lazyType;
var literalType = literal_1.ZodLiteral.create;
exports.literal = literalType;
var enumType = enum_1.ZodEnum.create;
exports["enum"] = enumType;
var nativeEnumType = nativeEnum_1.ZodNativeEnum.create;
exports.nativeEnum = nativeEnumType;
var promiseType = promise_1.ZodPromise.create;
exports.promise = promiseType;
var keyofType = keyof_1.ZodKeyof.create;
exports.keyof = keyofType;
var ostring = function () { return stringType().optional(); };
exports.ostring = ostring;
var onumber = function () { return numberType().optional(); };
exports.onumber = onumber;
var oboolean = function () { return booleanType().optional(); };
exports.oboolean = oboolean;
var codegen = codegen_1.ZodCodeGenerator.create;
exports.codegen = codegen;
exports.custom = function (check, params) { return anyType().refine(check, params); };
var instanceOfType = function (cls, params) {
    if (params === void 0) { params = {
        message: "Input not instance of " + cls.name,
    }; }
    return exports.custom(function (data) { return data instanceof cls; }, params);
};
exports["instanceof"] = instanceOfType;
exports.late = {
    object: object_1.ZodObject.lazycreate,
};
__export(__webpack_require__(/*! ./ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/isScalar.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/isScalar.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./index */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js"));
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
exports.isScalar = function (schema, params) {
    if (params === void 0) { params = { root: true }; }
    var def = schema._def;
    var returnValue = false;
    switch (def.t) {
        case z.ZodTypes.string:
            returnValue = true;
            break;
        case z.ZodTypes.number:
            returnValue = true;
            break;
        case z.ZodTypes.bigint:
            returnValue = true;
            break;
        case z.ZodTypes.boolean:
            returnValue = true;
            break;
        case z.ZodTypes.undefined:
            returnValue = true;
            break;
        case z.ZodTypes.null:
            returnValue = true;
            break;
        case z.ZodTypes.any:
            returnValue = false;
            break;
        case z.ZodTypes.unknown:
            returnValue = false;
            break;
        case z.ZodTypes.void:
            returnValue = false;
            break;
        case z.ZodTypes.array:
            if (params.root === false)
                return false;
            returnValue = exports.isScalar(def.type, { root: false });
            break;
        case z.ZodTypes.object:
            returnValue = false;
            break;
        case z.ZodTypes.union:
            returnValue = def.options.every(function (x) { return exports.isScalar(x); });
            break;
        case z.ZodTypes.intersection:
            returnValue = exports.isScalar(def.left) && exports.isScalar(def.right);
            break;
        case z.ZodTypes.tuple:
            returnValue = false;
            break;
        case z.ZodTypes.lazy:
            returnValue = exports.isScalar(def.getter());
            break;
        case z.ZodTypes.literal:
            returnValue = true;
            break;
        case z.ZodTypes.enum:
            returnValue = true;
            break;
        case z.ZodTypes.nativeEnum:
            returnValue = true;
            break;
        case z.ZodTypes.function:
            returnValue = false;
            break;
        case z.ZodTypes.record:
            returnValue = false;
            break;
        case z.ZodTypes.date:
            returnValue = true;
            break;
        case z.ZodTypes.promise:
            returnValue = false;
            break;
        case z.ZodTypes.keyof:
            returnValue = true;
            break;
        default:
            util_1.util.assertNever(def);
        // returnValue = false; break;
    }
    return returnValue;
};
//# sourceMappingURL=isScalar.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var _this = this;
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./types/base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodError_1 = __webpack_require__(/*! ./ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
var defaultErrorMap_1 = __webpack_require__(/*! ./defaultErrorMap */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/defaultErrorMap.js");
exports.getParsedType = function (data) {
    if (typeof data === 'string')
        return 'string';
    if (typeof data === 'number') {
        if (Number.isNaN(data))
            return 'nan';
        return 'number';
    }
    if (typeof data === 'boolean')
        return 'boolean';
    if (typeof data === 'bigint')
        return 'bigint';
    if (typeof data === 'symbol')
        return 'symbol';
    if (data instanceof Date)
        return 'date';
    if (typeof data === 'function')
        return 'function';
    if (data === undefined)
        return 'undefined';
    if (typeof data === 'undefined')
        return 'undefined';
    if (typeof data === 'object') {
        if (Array.isArray(data))
            return 'array';
        if (!data)
            return 'null';
        if (data.then &&
            typeof data.then === 'function' &&
            data.catch &&
            typeof data.catch === 'function') {
            return 'promise';
        }
        return 'object';
    }
    return 'unknown';
};
exports.ZodParsedType = util_1.util.arrayToEnum([
    'string',
    'nan',
    'number',
    'integer',
    'boolean',
    'date',
    'bigint',
    'symbol',
    'function',
    'undefined',
    'null',
    'array',
    'object',
    'unknown',
    'promise',
    'void',
]);
exports.find = function (arr, checker) {
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var item = arr_1[_i];
        if (checker(item))
            return item;
    }
    return undefined;
};
var makeError = function (params, obj, errorData) {
    var errorArg = __assign({}, errorData, { path: params.path.concat((errorData.path || [])) });
    var ctxArg = { data: obj };
    var defaultError = defaultErrorMap_1.defaultErrorMap === params.errorMap
        ? { message: "Invalid value." }
        : defaultErrorMap_1.defaultErrorMap(errorArg, __assign({}, ctxArg, { defaultError: "Invalid value." }));
    return __assign({}, errorData, { path: params.path.concat((errorData.path || [])), message: errorData.message ||
            params.errorMap(errorArg, __assign({}, ctxArg, { defaultError: defaultError.message })).message });
};
exports.ZodParser = function (schemaDef) { return function (obj, baseParams) {
    if (baseParams === void 0) { baseParams = { seen: [], errorMap: defaultErrorMap_1.defaultErrorMap, path: [] }; }
    var params = {
        seen: baseParams.seen || [],
        path: baseParams.path || [],
        errorMap: baseParams.errorMap || defaultErrorMap_1.defaultErrorMap,
    };
    var def = schemaDef;
    var parsedType = exports.getParsedType(obj);
    var schemaSeen = exports.find(params.seen, function (x) { return x.schema === schemaDef; });
    var isNonprimitive = ['array', 'object'].indexOf(parsedType) !== -1;
    if (isNonprimitive) {
        if (schemaSeen) {
            var found = exports.find(schemaSeen.objects, function (x) { return x.data === obj; });
            if (found) {
                if (found.error) {
                    throw found.error;
                }
                found.times = found.times + 1;
                if (found.times > 5 && isNonprimitive) {
                    return Symbol('recursion depth exceeded.');
                }
                else if (found.times > 2) {
                }
            }
            else {
                //
                schemaSeen.objects.push(obj);
            }
        }
        else {
            params.seen.push({
                schema: schemaDef,
                objects: [{ data: obj, error: undefined, times: 1 }],
            });
        }
    }
    // const setError = (error: Error) => {
    //   const schemaSeen = params.seen.find(x => x.schema === schemaDef);
    //   if (schemaSeen) {
    //     const found = schemaSeen.objects.find(x => x.data === obj);
    //     if (found) {
    //       found.error = error;
    //     }
    //   }
    // };
    var error = new ZodError_1.ZodError([]);
    var returnValue = obj;
    switch (def.t) {
        case z.ZodTypes.string:
            if (parsedType !== exports.ZodParsedType.string) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.string,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.number:
            if (parsedType !== exports.ZodParsedType.number) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.number,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            if (Number.isNaN(obj)) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.number,
                    received: exports.ZodParsedType.nan,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.bigint:
            if (parsedType !== exports.ZodParsedType.bigint) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.number,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.boolean:
            if (parsedType !== exports.ZodParsedType.boolean) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.boolean,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.undefined:
            if (parsedType !== exports.ZodParsedType.undefined) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.undefined,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.null:
            if (parsedType !== exports.ZodParsedType.null) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.null,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.any:
            break;
        case z.ZodTypes.unknown:
            break;
        case z.ZodTypes.void:
            if (parsedType !== exports.ZodParsedType.undefined &&
                parsedType !== exports.ZodParsedType.null) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.void,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.array:
            if (parsedType !== exports.ZodParsedType.array) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.array,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            var data = obj;
            if (def.nonempty === true && obj.length === 0) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.nonempty_array_is_empty,
                }));
                // setError(error);
                throw error;
            }
            data.map(function (item, i) {
                try {
                    var parsedItem = def.type.parse(item, __assign({}, params, { path: params.path.concat([i]) }));
                    return parsedItem;
                }
                catch (err) {
                    var zerr = err;
                    error.addErrors(zerr.errors);
                }
            });
            if (!error.isEmpty) {
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.object:
            if (parsedType !== exports.ZodParsedType.object) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.object,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            var shape = def.shape();
            if (def.params.strict) {
                var shapeKeys_1 = Object.keys(shape);
                var objKeys = Object.keys(obj);
                var extraKeys = objKeys.filter(function (k) { return shapeKeys_1.indexOf(k) === -1; });
                if (extraKeys.length) {
                    error.addError(makeError(params, obj, {
                        code: ZodError_1.ZodErrorCode.unrecognized_keys,
                        keys: extraKeys,
                    }));
                }
            }
            for (var key in shape) {
                try {
                    def
                        .shape()[key].parse(obj[key], __assign({}, params, { path: params.path.concat([key]) }));
                }
                catch (err) {
                    var zerr = err;
                    error.addErrors(zerr.errors);
                }
            }
            break;
        case z.ZodTypes.union:
            var isValid = false;
            var unionErrors = [];
            for (var _i = 0, _a = def.options; _i < _a.length; _i++) {
                var option = _a[_i];
                try {
                    option.parse(obj, params);
                    isValid = true;
                }
                catch (err) {
                    unionErrors.push(err);
                }
            }
            if (!isValid) {
                var filteredErrors = unionErrors.filter(function (err) {
                    return err.errors[0].code !== 'invalid_type';
                });
                if (filteredErrors.length === 1) {
                    error.addErrors(filteredErrors[0].errors);
                }
                else {
                    error.addError(makeError(params, obj, {
                        code: ZodError_1.ZodErrorCode.invalid_union,
                        unionErrors: unionErrors,
                    }));
                }
            }
            break;
        case z.ZodTypes.intersection:
            try {
                def.left.parse(obj, params);
            }
            catch (err) {
                error.addErrors(err.errors);
            }
            try {
                def.right.parse(obj, params);
            }
            catch (err) {
                error.addErrors(err.errors);
            }
            break;
        case z.ZodTypes.tuple:
            if (parsedType !== exports.ZodParsedType.array) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.array,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            if (obj.length > def.items.length) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.too_big,
                    maximum: def.items.length,
                    inclusive: true,
                    type: 'array',
                }));
            }
            else if (obj.length < def.items.length) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.too_small,
                    minimum: def.items.length,
                    inclusive: true,
                    type: 'array',
                }));
            }
            var parsedTuple = [];
            var tupleData = obj;
            for (var index in tupleData) {
                var item = tupleData[index];
                var itemParser = def.items[index];
                try {
                    parsedTuple.push(itemParser.parse(item, __assign({}, params, { path: params.path.concat([index]) })));
                }
                catch (err) {
                    error.addErrors(err.errors);
                }
            }
            break;
        case z.ZodTypes.lazy:
            var lazySchema = def.getter();
            lazySchema.parse(obj, params);
            break;
        case z.ZodTypes.literal:
            if (obj !== def.value) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_literal_value,
                    expected: def.value,
                }));
            }
            break;
        case z.ZodTypes.enum:
            if (def.values.indexOf(obj) === -1) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_enum_value,
                    options: def.values,
                }));
            }
            break;
        case z.ZodTypes.nativeEnum:
            if (util_1.util.getValidEnumValues(def.values).indexOf(obj) === -1) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_enum_value,
                    options: util_1.util.getValues(def.values),
                }));
            }
            break;
        case z.ZodTypes.keyof:
            if (util_1.util.getValidEnumValues(def.values).indexOf(obj) === -1) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_enum_value,
                    options: util_1.util.getValues(def.values),
                }));
            }
            break;
        case z.ZodTypes.function:
            if (parsedType !== exports.ZodParsedType.function) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.function,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            var validatedFunc = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    def.args.parse(args);
                }
                catch (err) {
                    if (err instanceof ZodError_1.ZodError) {
                        var argsError = new ZodError_1.ZodError([]);
                        argsError.addError(makeError(params, obj, {
                            code: ZodError_1.ZodErrorCode.invalid_arguments,
                            argumentsError: err,
                        }));
                        throw argsError;
                    }
                    throw err;
                }
                var result = obj.apply(void 0, args);
                try {
                    return def.returns.parse(result);
                }
                catch (err) {
                    if (err instanceof ZodError_1.ZodError) {
                        var returnsError = new ZodError_1.ZodError([]);
                        returnsError.addError(makeError(params, obj, {
                            code: ZodError_1.ZodErrorCode.invalid_return_type,
                            returnTypeError: err,
                        }));
                        throw returnsError;
                    }
                    throw err;
                }
            };
            return validatedFunc;
        case z.ZodTypes.record:
            if (parsedType !== exports.ZodParsedType.object) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.object,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            for (var key in obj) {
                try {
                    def.valueType.parse(obj[key], __assign({}, params, { path: params.path.concat([key]) }));
                }
                catch (err) {
                    error.addErrors(err.errors);
                }
            }
            break;
        case z.ZodTypes.date:
            if (!(obj instanceof Date)) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.date,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            if (isNaN(obj.getTime())) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_date,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.promise:
            if (parsedType !== exports.ZodParsedType.promise) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.promise,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            return new Promise(function (res, rej) { return __awaiter(_this, void 0, void 0, function () {
                var objValue, parsed;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, obj];
                        case 1:
                            objValue = _a.sent();
                            try {
                                parsed = def.type.parse(objValue, params);
                                res(parsed);
                            }
                            catch (err) {
                                rej(err);
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
        default:
            util_1.util.assertNever(def);
    }
    var customChecks = def.checks || [];
    for (var _b = 0, customChecks_1 = customChecks; _b < customChecks_1.length; _b++) {
        var check = customChecks_1[_b];
        if (!check.check(returnValue)) {
            var checkMethod = check.check, noMethodCheck = __rest(check, ["check"]);
            error.addError(makeError(params, obj, noMethodCheck));
        }
    }
    if (!error.isEmpty) {
        // setError(error);
        throw error;
    }
    return returnValue;
}; };
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/any.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/any.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodAny = /** @class */ (function (_super) {
    __extends(ZodAny, _super);
    function ZodAny() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodAny.create = function () {
        return new ZodAny({
            t: z.ZodTypes.any,
        });
    };
    return ZodAny;
}(z.ZodType));
exports.ZodAny = ZodAny;
//# sourceMappingURL=any.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/array.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/array.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
// import { ZodUndefined } from './undefined';
// import { ZodNull } from './null';
// import { ZodUnion } from './union';
var ZodError_1 = __webpack_require__(/*! ../ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var ZodArray = /** @class */ (function (_super) {
    __extends(ZodArray, _super);
    function ZodArray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                nonempty: _this._def.nonempty,
                type: _this._def.type.toJSON(),
            };
        };
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.min = function (minLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: ZodError_1.ZodErrorCode.too_small, type: 'array', inclusive: true, minimum: minLength }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.max = function (maxLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: ZodError_1.ZodErrorCode.too_big, type: 'array', inclusive: true, maximum: maxLength }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.length = function (len, message) { return _this.min(len, { message: message }).max(len, { message: message }); };
        _this.nonempty = function () {
            return new ZodNonEmptyArray(__assign({}, _this._def, { nonempty: true }));
        };
        return _this;
    }
    Object.defineProperty(ZodArray.prototype, "element", {
        get: function () {
            return this._def.type;
        },
        enumerable: true,
        configurable: true
    });
    ZodArray.create = function (schema) {
        return new ZodArray({
            t: z.ZodTypes.array,
            type: schema,
            nonempty: false,
        });
    };
    return ZodArray;
}(z.ZodType));
exports.ZodArray = ZodArray;
var ZodNonEmptyArray = /** @class */ (function (_super) {
    __extends(ZodNonEmptyArray, _super);
    function ZodNonEmptyArray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                type: _this._def.type.toJSON(),
            };
        };
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.min = function (minLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: ZodError_1.ZodErrorCode.too_small, minimum: minLength, type: 'array', inclusive: true }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.max = function (maxLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: ZodError_1.ZodErrorCode.too_big, maximum: maxLength, type: 'array', inclusive: true }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.length = function (len, message) { return _this.min(len, { message: message }).max(len, { message: message }); };
        return _this;
    }
    return ZodNonEmptyArray;
}(z.ZodType));
exports.ZodNonEmptyArray = ZodNonEmptyArray;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var parser_1 = __webpack_require__(/*! ../parser */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js");
var index_1 = __webpack_require__(/*! ../index */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js");
var ZodTypes;
(function (ZodTypes) {
    ZodTypes["string"] = "string";
    ZodTypes["number"] = "number";
    ZodTypes["bigint"] = "bigint";
    ZodTypes["boolean"] = "boolean";
    ZodTypes["date"] = "date";
    ZodTypes["undefined"] = "undefined";
    ZodTypes["null"] = "null";
    ZodTypes["array"] = "array";
    ZodTypes["object"] = "object";
    ZodTypes["union"] = "union";
    ZodTypes["intersection"] = "intersection";
    ZodTypes["tuple"] = "tuple";
    ZodTypes["record"] = "record";
    ZodTypes["function"] = "function";
    ZodTypes["lazy"] = "lazy";
    ZodTypes["literal"] = "literal";
    ZodTypes["enum"] = "enum";
    ZodTypes["nativeEnum"] = "nativeEnum";
    ZodTypes["promise"] = "promise";
    ZodTypes["any"] = "any";
    ZodTypes["unknown"] = "unknown";
    ZodTypes["void"] = "void";
    ZodTypes["keyof"] = "keyof";
})(ZodTypes = exports.ZodTypes || (exports.ZodTypes = {}));
var ZodType = /** @class */ (function () {
    function ZodType(def) {
        var _this = this;
        this.safeParse = function (data, params) {
            try {
                var parsed = _this.parse(data, params);
                return {
                    success: true,
                    data: parsed,
                };
            }
            catch (err) {
                if (err instanceof index_1.ZodError) {
                    return {
                        success: false,
                        error: err,
                    };
                }
                throw err;
            }
        };
        this.parseAsync = function (value, params) {
            return new Promise(function (res, rej) {
                try {
                    var parsed = _this.parse(value, params);
                    return res(parsed);
                }
                catch (err) {
                    return rej(err);
                }
            });
        };
        this.refine = function (check, message) {
            if (message === void 0) { message = 'Invalid value.'; }
            if (typeof message === 'string') {
                return _this.refinement({ check: check, message: message });
            }
            return _this.refinement(__assign({ check: check }, message));
        };
        this.refinement = function (refinement) {
            return _this._refinement(__assign({ code: index_1.ZodErrorCode.custom_error }, refinement));
        };
        this._refinement = function (refinement) {
            return new _this.constructor(__assign({}, _this._def, { checks: (_this._def.checks || []).concat([refinement]) }));
        };
        //  abstract // opt optional: () => any;
        this.optional = function () {
            return index_1.ZodUnion.create([_this, index_1.ZodUndefined.create()]);
        };
        this.nullable = function () {
            return index_1.ZodUnion.create([_this, index_1.ZodNull.create()]);
        };
        this.array = function () { return index_1.ZodArray.create(_this); };
        this.or = function (arg) {
            return index_1.ZodUnion.create([_this, arg]);
        };
        this._def = def;
        this.parse = parser_1.ZodParser(def);
    }
    ZodType.prototype.is = function (u) {
        try {
            this.parse(u);
            return true;
        }
        catch (err) {
            return false;
        }
    };
    ZodType.prototype.check = function (u) {
        try {
            this.parse(u);
            return true;
        }
        catch (err) {
            return false;
        }
    };
    return ZodType;
}());
exports.ZodType = ZodType;
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/bigint.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/bigint.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodBigInt = /** @class */ (function (_super) {
    __extends(ZodBigInt, _super);
    function ZodBigInt() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodBigInt.create = function () {
        return new ZodBigInt({
            t: z.ZodTypes.bigint,
        });
    };
    return ZodBigInt;
}(z.ZodType));
exports.ZodBigInt = ZodBigInt;
//# sourceMappingURL=bigint.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/boolean.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/boolean.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodBoolean = /** @class */ (function (_super) {
    __extends(ZodBoolean, _super);
    function ZodBoolean() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodBoolean.create = function () {
        return new ZodBoolean({
            t: z.ZodTypes.boolean,
        });
    };
    return ZodBoolean;
}(z.ZodType));
exports.ZodBoolean = ZodBoolean;
//# sourceMappingURL=boolean.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/date.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/date.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodDate = /** @class */ (function (_super) {
    __extends(ZodDate, _super);
    function ZodDate() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodDate.create = function () {
        return new ZodDate({
            t: z.ZodTypes.date,
        });
    };
    return ZodDate;
}(z.ZodType));
exports.ZodDate = ZodDate;
//# sourceMappingURL=date.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/enum.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/enum.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodEnum = /** @class */ (function (_super) {
    __extends(ZodEnum, _super);
    function ZodEnum() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    Object.defineProperty(ZodEnum.prototype, "options", {
        get: function () {
            return this._def.values;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodEnum.prototype, "enum", {
        get: function () {
            var enumValues = {};
            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {
                var val = _a[_i];
                enumValues[val] = val;
            }
            return enumValues;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodEnum.prototype, "Values", {
        get: function () {
            var enumValues = {};
            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {
                var val = _a[_i];
                enumValues[val] = val;
            }
            return enumValues;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodEnum.prototype, "Enum", {
        get: function () {
            var enumValues = {};
            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {
                var val = _a[_i];
                enumValues[val] = val;
            }
            return enumValues;
        },
        enumerable: true,
        configurable: true
    });
    ZodEnum.create = function (values) {
        return new ZodEnum({
            t: z.ZodTypes.enum,
            values: values,
        });
    };
    return ZodEnum;
}(z.ZodType));
exports.ZodEnum = ZodEnum;
//# sourceMappingURL=enum.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/function.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/function.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js");
var unknown_1 = __webpack_require__(/*! ./unknown */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js");
var ZodFunction = /** @class */ (function (_super) {
    __extends(ZodFunction, _super);
    function ZodFunction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.args = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return new ZodFunction(__assign({}, _this._def, { args: tuple_1.ZodTuple.create(items) }));
        };
        _this.returns = function (returnType) {
            return new ZodFunction(__assign({}, _this._def, { returns: returnType }));
        };
        _this.implement = function (func) {
            var validatedFunc = _this.parse(func);
            return validatedFunc;
        };
        _this.validate = _this.implement;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                args: _this._def.args.toJSON(),
                returns: _this._def.returns.toJSON(),
            };
        };
        return _this;
    }
    ZodFunction.create = function (args, returns) {
        return new ZodFunction({
            t: z.ZodTypes.function,
            args: args || tuple_1.ZodTuple.create([]),
            returns: returns || unknown_1.ZodUnknown.create(),
        });
    };
    return ZodFunction;
}(z.ZodType));
exports.ZodFunction = ZodFunction;
//# sourceMappingURL=function.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodIntersection = /** @class */ (function (_super) {
    __extends(ZodIntersection, _super);
    function ZodIntersection() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return ({
            t: _this._def.t,
            left: _this._def.left.toJSON(),
            right: _this._def.right.toJSON(),
        }); };
        return _this;
    }
    ZodIntersection.create = function (left, right) {
        return new ZodIntersection({
            t: z.ZodTypes.intersection,
            left: left,
            right: right,
        });
    };
    return ZodIntersection;
}(z.ZodType));
exports.ZodIntersection = ZodIntersection;
//# sourceMappingURL=intersection.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/keyof.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/keyof.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodKeyof = /** @class */ (function (_super) {
    __extends(ZodKeyof, _super);
    function ZodKeyof() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return ({
            t: _this._def.t,
            values: _this._def.values.map(function (x) { return x.toString(); }),
        }); };
        return _this;
    }
    ZodKeyof.create = function (object) {
        return new ZodKeyof({
            t: z.ZodTypes.keyof,
            // Note that this cast is not correct in the general case
            // See e.g. https://github.com/Microsoft/TypeScript/issues/12870
            values: Object.keys(object),
        });
    };
    return ZodKeyof;
}(z.ZodType));
exports.ZodKeyof = ZodKeyof;
//# sourceMappingURL=keyof.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/lazy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/lazy.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodLazy = /** @class */ (function (_super) {
    __extends(ZodLazy, _super);
    function ZodLazy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () {
            throw new Error("Can't JSONify recursive structure");
        };
        return _this;
    }
    Object.defineProperty(ZodLazy.prototype, "schema", {
        get: function () {
            return this._def.getter();
        },
        enumerable: true,
        configurable: true
    });
    ZodLazy.create = function (getter) {
        return new ZodLazy({
            t: z.ZodTypes.lazy,
            getter: getter,
        });
    };
    return ZodLazy;
}(z.ZodType));
exports.ZodLazy = ZodLazy;
//# sourceMappingURL=lazy.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/literal.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/literal.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodLiteral = /** @class */ (function (_super) {
    __extends(ZodLiteral, _super);
    function ZodLiteral() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodLiteral.create = function (value) {
        return new ZodLiteral({
            t: z.ZodTypes.literal,
            value: value,
        });
    };
    return ZodLiteral;
}(z.ZodType));
exports.ZodLiteral = ZodLiteral;
//# sourceMappingURL=literal.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/nativeEnum.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/nativeEnum.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodNativeEnum = /** @class */ (function (_super) {
    __extends(ZodNativeEnum, _super);
    function ZodNativeEnum() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodNativeEnum.create = function (values) {
        return new ZodNativeEnum({
            t: z.ZodTypes.nativeEnum,
            values: values,
        });
    };
    return ZodNativeEnum;
}(z.ZodType));
exports.ZodNativeEnum = ZodNativeEnum;
//# sourceMappingURL=nativeEnum.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/null.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/null.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodNull = /** @class */ (function (_super) {
    __extends(ZodNull, _super);
    function ZodNull() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodNull.create = function () {
        return new ZodNull({
            t: z.ZodTypes.null,
        });
    };
    return ZodNull;
}(z.ZodType));
exports.ZodNull = ZodNull;
//# sourceMappingURL=null.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/number.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/number.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
// import { ZodUndefined } from './undefined';
// import { ZodNull } from './null';
// import { ZodUnion } from './union';
var ZodError_1 = __webpack_require__(/*! ../ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var errorUtil_1 = __webpack_require__(/*! ../helpers/errorUtil */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js");
var ZodNumber = /** @class */ (function (_super) {
    __extends(ZodNumber, _super);
    function ZodNumber() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        _this.min = function (minimum, message) {
            return _this._refinement(__assign({ check: function (data) { return data >= minimum; }, code: ZodError_1.ZodErrorCode.too_small, minimum: minimum, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.max = function (maximum, message) {
            return _this._refinement(__assign({ check: function (data) { return data <= maximum; }, code: ZodError_1.ZodErrorCode.too_big, maximum: maximum, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.int = function (message) {
            return _this._refinement(__assign({ check: function (data) { return Number.isInteger(data); }, code: ZodError_1.ZodErrorCode.invalid_type, expected: 'integer', received: 'number' }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.positive = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data > 0; }, code: ZodError_1.ZodErrorCode.too_small, minimum: 0, type: 'number', inclusive: false }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.negative = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data < 0; }, code: ZodError_1.ZodErrorCode.too_big, maximum: 0, type: 'number', inclusive: false }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.nonpositive = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data <= 0; }, code: ZodError_1.ZodErrorCode.too_big, maximum: 0, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.nonnegative = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data >= 0; }, code: ZodError_1.ZodErrorCode.too_small, minimum: 0, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        return _this;
    }
    ZodNumber.create = function () {
        return new ZodNumber({
            t: z.ZodTypes.number,
        });
    };
    return ZodNumber;
}(z.ZodType));
exports.ZodNumber = ZodNumber;
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var objectUtil_1 = __webpack_require__(/*! ../helpers/objectUtil */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/objectUtil.js");
var isScalar_1 = __webpack_require__(/*! ../isScalar */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/isScalar.js");
var AugmentFactory = function (def) { return function (augmentation) {
    return new ZodObject(__assign({}, def, { shape: function () { return (__assign({}, def.shape(), augmentation)); } }));
}; };
var objectDefToJson = function (def) { return ({
    t: def.t,
    shape: Object.assign({}, Object.keys(def.shape()).map(function (k) {
        var _a;
        return (_a = {},
            _a[k] = def.shape()[k].toJSON(),
            _a);
    })),
}); };
var ZodObject = /** @class */ (function (_super) {
    __extends(ZodObject, _super);
    function ZodObject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return objectDefToJson(_this._def); };
        _this.nonstrict = function () {
            return new ZodObject({
                shape: _this._def.shape,
                t: z.ZodTypes.object,
                params: __assign({}, _this._params, { strict: false }),
            });
        };
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.augment = AugmentFactory(_this._def);
        _this.extend = AugmentFactory(_this._def);
        /**
         * Prior to zod@1.0.12 there was a bug in the
         * inferred type of merged objects. Please
         * upgrade if you are experiencing issues.
         */
        _this.merge = objectUtil_1.objectUtil.mergeObjects(_this);
        _this.pick = function (mask) {
            var shape = {};
            Object.keys(mask).map(function (key) {
                shape[key] = _this.shape[key];
            });
            return new ZodObject(__assign({}, _this._def, { shape: function () { return shape; } }));
        };
        _this.omit = function (mask) {
            var shape = {};
            Object.keys(_this.shape).map(function (key) {
                if (Object.keys(mask).indexOf(key) === -1) {
                    shape[key] = _this.shape[key];
                }
            });
            return new ZodObject(__assign({}, _this._def, { shape: function () { return shape; } }));
        };
        _this.partial = function () {
            var newShape = {};
            for (var key in _this.shape) {
                newShape[key] = _this.shape[key].optional();
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        _this.primitives = function () {
            var newShape = {};
            for (var key in _this.shape) {
                if (isScalar_1.isScalar(_this.shape[key])) {
                    newShape[key] = _this.shape[key];
                }
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        _this.nonprimitives = function () {
            var newShape = {};
            for (var key in _this.shape) {
                if (!isScalar_1.isScalar(_this.shape[key])) {
                    newShape[key] = _this.shape[key];
                }
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        _this.deepPartial = function () {
            var newShape = {};
            for (var key in _this.shape) {
                var fieldSchema = _this.shape[key];
                if (fieldSchema instanceof ZodObject) {
                    newShape[key] = fieldSchema.deepPartial().optional();
                }
                else {
                    newShape[key] = _this.shape[key].optional();
                }
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        return _this;
    }
    Object.defineProperty(ZodObject.prototype, "shape", {
        get: function () {
            return this._def.shape();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodObject.prototype, "params", {
        get: function () {
            return this._def.params;
        },
        enumerable: true,
        configurable: true
    });
    ZodObject.create = function (shape) {
        return new ZodObject({
            t: z.ZodTypes.object,
            shape: function () { return shape; },
            params: {
                strict: true,
            },
        });
    };
    ZodObject.lazycreate = function (shape) {
        return new ZodObject({
            t: z.ZodTypes.object,
            shape: shape,
            params: {
                strict: true,
            },
        });
    };
    return ZodObject;
}(z.ZodType));
exports.ZodObject = ZodObject;
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/promise.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/promise.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodPromise = /** @class */ (function (_super) {
    __extends(ZodPromise, _super);
    function ZodPromise() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                type: _this._def.type.toJSON(),
            };
        };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodPromise.create = function (schema) {
        return new ZodPromise({
            t: z.ZodTypes.promise,
            type: schema,
        });
    };
    return ZodPromise;
}(z.ZodType));
exports.ZodPromise = ZodPromise;
//# sourceMappingURL=promise.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/record.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/record.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodRecord = /** @class */ (function (_super) {
    __extends(ZodRecord, _super);
    function ZodRecord() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return ({
            t: _this._def.t,
            valueType: _this._def.valueType.toJSON(),
        }); };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodRecord.create = function (valueType) {
        return new ZodRecord({
            t: z.ZodTypes.record,
            valueType: valueType,
        });
    };
    return ZodRecord;
}(z.ZodType));
exports.ZodRecord = ZodRecord;
//# sourceMappingURL=record.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/string.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/string.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
// import { ZodUndefined } from './undefined';
// import { ZodNull } from './null';
// import { ZodUnion } from './union';
var ZodError_1 = __webpack_require__(/*! ../ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var errorUtil_1 = __webpack_require__(/*! ../helpers/errorUtil */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js");
var emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
var uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/i;
var ZodString = /** @class */ (function (_super) {
    __extends(ZodString, _super);
    function ZodString() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        _this.min = function (minLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: ZodError_1.ZodErrorCode.too_small, minimum: minLength, type: 'string', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.max = function (maxLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: ZodError_1.ZodErrorCode.too_big, maximum: maxLength, type: 'string', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this._regex = function (regex, validation, message) {
            return _this._refinement(__assign({ validation: validation, code: ZodError_1.ZodErrorCode.invalid_string, check: function (data) { return regex.test(data); } }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.email = function (message) {
            return _this._regex(emailRegex, 'email', message);
        };
        _this.url = function (message) {
            return _this._refinement(__assign({ check: function (data) {
                    try {
                        new URL(data);
                        return true;
                    }
                    catch (_a) {
                        return false;
                    }
                }, code: ZodError_1.ZodErrorCode.invalid_string, validation: 'url' }, errorUtil_1.errorUtil.errToObj(message)));
        };
        // url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
        _this.uuid = function (message) {
            return _this._regex(uuidRegex, 'uuid', message);
        };
        _this.regex = function (regexp, message) {
            return _this._regex(regexp, 'regex', message);
        };
        _this.nonempty = function (message) {
            return _this.min(1, errorUtil_1.errorUtil.errToObj(message));
        };
        return _this;
    }
    ZodString.prototype.length = function (len, message) {
        return this.min(len, message).max(len, message);
    };
    ZodString.create = function () {
        return new ZodString({
            t: z.ZodTypes.string,
            validation: {},
        });
    };
    return ZodString;
}(z.ZodType));
exports.ZodString = ZodString;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodTuple = /** @class */ (function (_super) {
    __extends(ZodTuple, _super);
    function ZodTuple() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return ({
            t: _this._def.t,
            items: _this._def.items.map(function (item) { return item.toJSON(); }),
        }); };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodTuple.create = function (schemas) {
        return new ZodTuple({
            t: z.ZodTypes.tuple,
            items: schemas,
        });
    };
    return ZodTuple;
}(z.ZodType));
exports.ZodTuple = ZodTuple;
//# sourceMappingURL=tuple.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/undefined.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/undefined.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodUndefined = /** @class */ (function (_super) {
    __extends(ZodUndefined, _super);
    function ZodUndefined() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodUndefined.create = function () {
        return new ZodUndefined({
            t: z.ZodTypes.undefined,
        });
    };
    return ZodUndefined;
}(z.ZodType));
exports.ZodUndefined = ZodUndefined;
//# sourceMappingURL=undefined.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/union.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/union.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodUnion = /** @class */ (function (_super) {
    __extends(ZodUnion, _super);
    function ZodUnion() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return ({
            t: _this._def.t,
            options: _this._def.options.map(function (x) { return x.toJSON(); }),
        }); };
        return _this;
    }
    // distribute = <F extends (arg: T[number]) => z.ZodTypeAny>(f: F): ZodUnion<{ [k in keyof T]: ReturnType<F> }> => {
    //   return ZodUnion.create(this._def.options.map(f) as any);
    // };
    ZodUnion.create = function (types) {
        return new ZodUnion({
            t: z.ZodTypes.union,
            options: types,
        });
    };
    return ZodUnion;
}(z.ZodType));
exports.ZodUnion = ZodUnion;
//# sourceMappingURL=union.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodUnknown = /** @class */ (function (_super) {
    __extends(ZodUnknown, _super);
    function ZodUnknown() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodUnknown.create = function () {
        return new ZodUnknown({
            t: z.ZodTypes.unknown,
        });
    };
    return ZodUnknown;
}(z.ZodType));
exports.ZodUnknown = ZodUnknown;
//# sourceMappingURL=unknown.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/void.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/void.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodVoid = /** @class */ (function (_super) {
    __extends(ZodVoid, _super);
    function ZodVoid() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodVoid.create = function () {
        return new ZodVoid({
            t: z.ZodTypes.void,
        });
    };
    return ZodVoid;
}(z.ZodType));
exports.ZodVoid = ZodVoid;
//# sourceMappingURL=void.js.map

/***/ }),

/***/ "./resources/js/components/ui/CurrencyDropdown.js":
/*!********************************************************!*\
  !*** ./resources/js/components/ui/CurrencyDropdown.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





var Dropdown = function Dropdown(_ref) {
  var _options$find;

  var options = _ref.options,
      selectedOption = _ref.selectedOption,
      setSelectedOption = _ref.setSelectedOption;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState2 = _slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setOpen = _useState2[1];

  var dropdown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null); // Open/Close on click of dropdown header

  var toggleDropdown = function toggleDropdown() {
    return setOpen(!isOpen);
  }; // Update selected option, close dropdown


  var handleItemClick = function handleItemClick(currency) {
    setSelectedOption(currency);
    setOpen(false);
  }; // Close dropdown when clicked outside


  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    function handleClickOutside(event) {
      if (dropdown.current && !dropdown.current.contains(event.target)) {
        setOpen(false);
      }
    }

    document.addEventListener("mousedown", handleClickOutside);
    return function () {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [dropdown]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
    className: "dropdown",
    ref: dropdown,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "dropdown-header",
      onClick: toggleDropdown,
      children: selectedOption ? (_options$find = options.find(function (option) {
        return option.currency === selectedOption.currency;
      })) === null || _options$find === void 0 ? void 0 : _options$find.currency : "select a token"
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "dropdown-body ".concat(isOpen && "open"),
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("ul", {
        children: (options || []).map(function (item, index) {
          return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("li", {
            className: "dropdown-item",
            id: item.currency,
            onClick: function onClick(e) {
              handleItemClick(item);
            },
            children: item.currency
          }, item.currency);
        })
      })
    })]
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dropdown);

/***/ }),

/***/ "./resources/js/constants/CurrencyList.js":
/*!************************************************!*\
  !*** ./resources/js/constants/CurrencyList.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "currencies": () => (/* binding */ currencies)
/* harmony export */ });
// Options list for dropdown
var currencies = [{
  currency: "XPR",
  contract: "eosio.token",
  decimals: "4"
}, {
  decimals: "4",
  contract: "loan.token",
  currency: "LOAN"
}, {
  currency: "FOOBAR",
  contract: "xtokens",
  decimals: "6"
}, {
  decimals: "4",
  contract: "storex",
  currency: "STRX"
}, {
  currency: "BTCL",
  contract: "wrapper",
  decimals: "8"
}, {
  currency: "XADA",
  decimals: "6",
  contract: "xtokens"
}, {
  currency: "XBCH",
  contract: "xtokens",
  decimals: "8"
}, {
  contract: "xtokens",
  decimals: "8",
  currency: "XBNB"
}, {
  currency: "XBTC",
  contract: "xtokens",
  decimals: "8"
}, {
  currency: "XBUSD",
  contract: "xtokens",
  decimals: "6"
}, {
  currency: "XDOGE",
  contract: "xtokens",
  decimals: "6"
}, {
  contract: "xtokens",
  decimals: "8",
  currency: "XDOT"
}, {
  decimals: "4",
  contract: "xtokens",
  currency: "XEOS"
}, {
  contract: "xtokens",
  decimals: "8",
  currency: "XETH"
}, {
  currency: "XLTC",
  contract: "xtokens",
  decimals: "8"
}, {
  decimals: "6",
  contract: "xtokens",
  currency: "XLUNA"
}, {
  contract: "xtokens",
  decimals: "6",
  currency: "XMDA"
}, {
  currency: "XMT",
  decimals: "8",
  contract: "xtokens"
}, {
  currency: "XPAX",
  contract: "xtokens",
  decimals: "6"
}, {
  currency: "XPAXG",
  contract: "xtokens",
  decimals: "8"
}, {
  currency: "XSOL",
  contract: "xtokens",
  decimals: "6"
}, {
  currency: "XTUSD",
  contract: "xtokens",
  decimals: "6"
}, {
  contract: "xtokens",
  decimals: "6",
  currency: "XUNI"
}, {
  currency: "XUSDC",
  contract: "xtokens",
  decimals: "6"
}, {
  contract: "xtokens",
  decimals: "6",
  currency: "XUSDT"
}, {
  contract: "xtokens",
  decimals: "6",
  currency: "XUST"
}, {
  currency: "XXRP",
  contract: "xtokens",
  decimals: "6"
}, {
  contract: "realestatese",
  currency: "MESSAGE",
  decimals: "4"
}];

/***/ }),

/***/ "./resources/js/pages/Contest.js":
/*!***************************************!*\
  !*** ./resources/js/pages/Contest.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _components_ui_Modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/ui/Modal */ "./resources/js/components/ui/Modal.js");
/* harmony import */ var _components_ui_Button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/ui/Button */ "./resources/js/components/ui/Button.js");
/* harmony import */ var _store_auth_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/auth-context */ "./resources/js/store/auth-context.js");
/* harmony import */ var _components_ui_CurrencyDropdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/ui/CurrencyDropdown */ "./resources/js/components/ui/CurrencyDropdown.js");
/* harmony import */ var _constants_CurrencyList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/CurrencyList */ "./resources/js/constants/CurrencyList.js");
/* harmony import */ var _store_wallet_context__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../store/wallet-context */ "./resources/js/store/wallet-context.js");
/* harmony import */ var _sdk_easypoolSDK__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../sdk/easypoolSDK */ "./resources/js/sdk/easypoolSDK.js");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }













var Contest = function Contest() {
  var navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_9__.useNavigate)();
  var ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_store_auth_context__WEBPACK_IMPORTED_MODULE_3__["default"]);
  var walletCtx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_store_wallet_context__WEBPACK_IMPORTED_MODULE_6__["default"]);

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState2 = _slicedToArray(_useState, 2),
      successPopup = _useState2[0],
      setSuccessPopup = _useState2[1];

  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState4 = _slicedToArray(_useState3, 2),
      error = _useState4[0],
      setError = _useState4[1];

  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState6 = _slicedToArray(_useState5, 2),
      success = _useState6[0],
      setSuccess = _useState6[1];

  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState8 = _slicedToArray(_useState7, 2),
      checkError = _useState8[0],
      setCheckError = _useState8[1];

  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState10 = _slicedToArray(_useState9, 2),
      loading = _useState10[0],
      setLoading = _useState10[1];

  var closeSuccessPopup = function closeSuccessPopup() {
    setSuccessPopup(false);
    navigate("/transactions");
  };

  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState12 = _slicedToArray(_useState11, 2),
      title = _useState12[0],
      setTitle = _useState12[1];

  var _useState13 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState14 = _slicedToArray(_useState13, 2),
      description = _useState14[0],
      setDescription = _useState14[1];

  var _useState15 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("date"),
      _useState16 = _slicedToArray(_useState15, 2),
      poolType = _useState16[0],
      setPoolType = _useState16[1];

  var _useState17 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState18 = _slicedToArray(_useState17, 2),
      amount = _useState18[0],
      setAmount = _useState18[1];

  var _useState19 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    currency: "Select a token",
    amount: "0"
  }),
      _useState20 = _slicedToArray(_useState19, 2),
      token = _useState20[0],
      setToken = _useState20[1];

  var _useState21 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([{
    currency: "Select a token",
    amount: "0"
  }]),
      _useState22 = _slicedToArray(_useState21, 2),
      tokens = _useState22[0],
      setTokens = _useState22[1];

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (walletCtx.balances != [] && walletCtx.balances.length > 0) {
      setToken(walletCtx.balances[0]);
      setTokens(walletCtx.balances);
    }
  }, [walletCtx.balances]);

  var _useState23 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState24 = _slicedToArray(_useState23, 2),
      checkExchange = _useState24[0],
      setCheckExchange = _useState24[1];

  var validateForm = function validateForm() {
    if (title == "" || description == "" || amount == "" || token == "") {
      setError("All fields are required.");
      return false;
    } else if (!checkExchange) {
      setError("");
      setCheckError("Please tick the checkbox to confirm exchange");
      return false;
    } else {
      setError("");
      return true;
    }
  };

  var handleContestFormSubmit = function handleContestFormSubmit(event) {
    event.preventDefault();
    if (validateForm()) handleTransaction();
  };

  var sleep = function sleep(milliseconds) {
    var date = Date.now();
    var currentDate = null;

    do {
      currentDate = Date.now();
    } while (currentDate - date < milliseconds);
  }; //U


  var handleTransaction = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var expiry, authorization, contesters, fromNfts, escrows, myEscrows, loopId, escrowId;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              setLoading(true);
              expiry = 0;
              authorization = [{
                actor: ctx.auth.actor,
                permission: ctx.auth.permission
              }];
              contesters = [];
              fromNfts = [];
              _context.next = 8;
              return (0,_sdk_easypoolSDK__WEBPACK_IMPORTED_MODULE_7__.startPool)(ctx.auth.actor, contesters, token, amount, fromNfts, expiry, authorization, walletCtx.session);

            case 8:
              sleep(2000);
              _context.next = 11;
              return (0,_sdk_easypoolSDK__WEBPACK_IMPORTED_MODULE_7__.fetchEscrows)(ctx.auth.actor);

            case 11:
              escrows = _context.sent;
              myEscrows = escrows.filter(function (escrow) {
                return escrow.from == ctx.auth.actor;
              });
              loopId = 2;

              if (myEscrows.length) {
                _context.next = 23;
                break;
              }

            case 15:
              if (!(!myEscrows.length && loopId)) {
                _context.next = 23;
                break;
              }

              sleep(2000);
              _context.next = 19;
              return (0,_sdk_easypoolSDK__WEBPACK_IMPORTED_MODULE_7__.fetchEscrows)(ctx.auth.actor);

            case 19:
              myEscrows = escrows.filter(function (escrow) {
                return escrow.from == ctx.auth.actor;
              });
              loopId--;
              _context.next = 15;
              break;

            case 23:
              escrowId = "0";

              if (!myEscrows.length) {
                _context.next = 28;
                break;
              }

              escrowId = myEscrows[myEscrows.length - 1].id.toString();
              _context.next = 30;
              break;

            case 28:
              setLoading(false);
              return _context.abrupt("return");

            case 30:
              // await cancelPool(
              //     ctx.auth.actor,
              //     myEscrows[myEscrows.length - 1].id,
              //     authorization,
              //     walletCtx.session
              // );
              // await partakePool(
              //     ctx.auth.actor,
              //     myEscrows[myEscrows.length - 1].id,
              //     myEscrows[myEscrows.length - 1].fromTokens[0],
              //     authorization,
              //     walletCtx.session
              // );
              // await fillPool(
              //     ctx.auth.actor,
              //     myEscrows[myEscrows.length - 1].id,
              //     [ctx.auth.actor, "escrowuser2"],
              //     authorization,
              //     walletCtx.session
              // );
              console.log("MyEscrows", myEscrows);
              fetch("".concat("https://easyescrow.io/api", "/user/addescrow"), {
                method: "POST",
                body: JSON.stringify({
                  type_id: 5,
                  escrow_id: Number(escrowId),
                  escrow_status: "ready",
                  amount: amount,
                  token: token.currency,
                  title: title,
                  description: description,
                  pool_type: poolType
                }),
                headers: {
                  Authorization: "Bearer " + ctx.auth.actor,
                  "Content-Type": "application/json"
                }
              }).then(function (response) {
                return response.json();
              }).then(function (data) {
                //console.log(data);
                if (data.valid) {
                  // setConfirmationPopup(false);
                  setSuccessPopup(true);
                  setSuccess(data.message);
                } else {
                  setError(data.message);
                }

                setLoading(false);
              })["catch"](function (error) {
                setError(error);
                setLoading(false);
              });
              _context.next = 37;
              break;

            case 34:
              _context.prev = 34;
              _context.t0 = _context["catch"](0);
              console.error(_context.t0);

            case 37:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 34]]);
    }));

    return function handleTransaction() {
      return _ref.apply(this, arguments);
    };
  }();

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("main", {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: "container banner-inner",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("h1", {
          children: "Pool / Contest"
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: "container block",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("form", {
          onSubmit: handleContestFormSubmit,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("label", {
              htmlFor: "contest-title",
              children: "Add a title for the Pool / Contest"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("input", {
              type: "text",
              id: "contest-title",
              value: title,
              onChange: function onChange(event) {
                return setTitle(event.target.value);
              }
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("label", {
              htmlFor: "contest-desc",
              children: "Description of Pool / Contest"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("textarea", {
              id: "contest-desc",
              value: description,
              onChange: function onChange(event) {
                return setDescription(event.target.value);
              }
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("label", {
              children: "Pool is for:"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
              className: "radio",
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("input", {
                type: "radio",
                id: "cal-date",
                name: "pool-for",
                value: "Calendar date",
                checked: poolType == "date",
                onChange: function onChange() {
                  return setPoolType("date");
                }
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("label", {
                htmlFor: "cal-date",
                children: "A Calendar date"
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
              className: "radio",
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("input", {
                type: "radio",
                id: "numerical",
                name: "pool-for",
                value: "Numerical value",
                checked: poolType == "integer",
                onChange: function onChange() {
                  return setPoolType("integer");
                }
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("label", {
                htmlFor: "numerical",
                children: "A Numerical value"
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("small", {
              children: "a numerical value can be assigned to any item as its representation and placed in the description box. Such as 1 for red, 2 for blue, 3 for green, etc."
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("label", {
              htmlFor: "contest_token",
              children: "Select a token that you wish to use for this pool / contest:"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_components_ui_CurrencyDropdown__WEBPACK_IMPORTED_MODULE_4__["default"], {
              options: tokens,
              selectedOption: token,
              setSelectedOption: setToken
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("label", {
              htmlFor: "contest-amount",
              children: "Enter a numerical amount that each user will contribute to the pool / contest:"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("input", {
              type: "number",
              step: "0.01",
              id: "contest-amount",
              value: amount,
              onChange: function onChange(event) {
                return setAmount(event.target.value);
              }
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
            className: "form-row confirm-check",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("input", {
              type: "checkbox",
              id: "contest-item",
              name: "contest-item"
            })
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
            className: "form-row",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("p", {
              children: "Please confirm the following proposed purchase"
            })
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
            className: "form-row confirm-check",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("input", {
              type: "checkbox",
              id: "crypto_exchange",
              name: "crypto_exchange",
              value: checkExchange,
              onChange: function onChange(event) {
                return setCheckExchange(event.target.checked);
              }
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("label", {
              htmlFor: "crypto_exchange",
              children: "Please confirm to add ".concat(amount || "(token numerical amount)", " ").concat(token.currency || "(token name)", " to the pool/contest.")
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
            className: "form-row",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("p", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("small", {
                children: "If this is correct please confirm and your crypto will be moved out of your Proton wallet into the EasyEscrow Smart Contract."
              })
            })
          }), checkError !== "" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
            className: "form-row error",
            children: checkError
          }), error !== "" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
            className: "form-row error",
            children: error
          }), ctx.isLoggedIn && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
            className: "form-row",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_components_ui_Button__WEBPACK_IMPORTED_MODULE_2__["default"], {
              label: "Confirm",
              type: "submit",
              loading: loading
            })
          }), !ctx.isLoggedIn && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
            className: "form-row",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_components_ui_Button__WEBPACK_IMPORTED_MODULE_2__["default"], {
              label: "Login",
              onClick: /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return walletCtx.protonConnection();

                      case 2:
                        return _context2.abrupt("return", _context2.sent);

                      case 3:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              })),
              loading: loading
            })
          })]
        })
      })]
    }), successPopup && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_components_ui_Modal__WEBPACK_IMPORTED_MODULE_1__["default"], {
      hidePopup: function hidePopup() {
        return setSuccessPopup(false);
      },
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("h3", {
          className: "modal-header",
          children: "Pool / Contest"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
          className: "form-row success",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("p", {
            children: success
          })
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
          className: "modal-confirm",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_components_ui_Button__WEBPACK_IMPORTED_MODULE_2__["default"], {
            label: "Continue",
            onClick: closeSuccessPopup
          })
        })]
      })
    })]
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Contest);

/***/ }),

/***/ "./resources/js/sdk/easypoolSDK.js":
/*!*****************************************!*\
  !*** ./resources/js/sdk/easypoolSDK.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cancelPool": () => (/* binding */ cancelPool),
/* harmony export */   "fetchEscrowAll": () => (/* binding */ fetchEscrowAll),
/* harmony export */   "fetchEscrows": () => (/* binding */ fetchEscrows),
/* harmony export */   "fillPool": () => (/* binding */ fillPool),
/* harmony export */   "partakePool": () => (/* binding */ partakePool),
/* harmony export */   "startPool": () => (/* binding */ startPool)
/* harmony export */ });
/* harmony import */ var _proton_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @proton/api */ "./node_modules/@proton/api/dist/api.esm.js");
/* harmony import */ var _constants_networks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/networks */ "./resources/js/constants/networks.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

//Use API to save transaction details


var api = new _proton_api__WEBPACK_IMPORTED_MODULE_0__.ApiClass(_constants_networks__WEBPACK_IMPORTED_MODULE_1__.current_network.chain);
var contract = "easyescrowpl";
var feeContract = "xtokens";
var feeQuantity = "0.250000 XUSDC";
function fetchEscrowAll() {
  return _fetchEscrowAll.apply(this, arguments);
}

function _fetchEscrowAll() {
  _fetchEscrowAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$api$rpc$get_ta, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return api.rpc.get_table_rows({
              code: contract,
              scope: contract,
              table: "escrows",
              index_position: 2,
              key_type: "i64",
              limit: -1
            });

          case 2:
            _yield$api$rpc$get_ta = _context.sent;
            rows = _yield$api$rpc$get_ta.rows;
            return _context.abrupt("return", rows);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchEscrowAll.apply(this, arguments);
}

function fetchEscrows(_x) {
  return _fetchEscrows.apply(this, arguments);
}

function _fetchEscrows() {
  _fetchEscrows = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(accountName) {
    var _yield$api$rpc$get_ta2, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return api.rpc.get_table_rows({
              code: contract,
              scope: contract,
              table: "escrows",
              index_position: 2,
              key_type: "i64",
              lower_bound: accountName,
              upper_bound: accountName,
              limit: -1
            });

          case 2:
            _yield$api$rpc$get_ta2 = _context2.sent;
            rows = _yield$api$rpc$get_ta2.rows;
            return _context2.abrupt("return", rows);

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchEscrows.apply(this, arguments);
}

function startPool(_x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9) {
  return _startPool.apply(this, arguments);
}

function _startPool() {
  _startPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(from, contesters, fromToken, fromAmount, fromNfts, expiry, authorization, session) {
    var amountIn, fromQuantity, actions;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            amountIn = parseFloat(fromAmount).toFixed(Number(fromToken.decimals)).toString();
            fromQuantity = amountIn + " " + fromToken.currency;
            actions = [{
              account: feeContract,
              name: "transfer",
              data: {
                from: from,
                to: contract,
                quantity: feeQuantity,
                memo: "".concat(from, " deposit a fee for a pool.")
              },
              authorization: authorization
            }, {
              account: fromToken.contract,
              name: "transfer",
              data: {
                from: from,
                to: contract,
                quantity: fromQuantity,
                memo: "".concat(from, " deposit for a pool")
              },
              authorization: authorization
            }, {
              account: contract,
              name: "startpool",
              data: {
                from: from,
                contesters: contesters,
                fromTokens: [{
                  contract: fromToken.contract,
                  quantity: fromQuantity
                }],
                fromNfts: fromNfts,
                expiry: expiry
              },
              authorization: authorization
            }];
            _context3.next = 5;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _startPool.apply(this, arguments);
}

function partakePool(_x10, _x11, _x12, _x13, _x14) {
  return _partakePool.apply(this, arguments);
}

function _partakePool() {
  _partakePool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(actor, escrowId, fromToken, authorization, session) {
    var actions;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            actions = [{
              account: feeContract,
              name: "transfer",
              data: {
                from: actor,
                to: contract,
                quantity: feeQuantity,
                memo: "".concat(actor, " deposit a fee for a purchase.")
              },
              authorization: authorization
            }, {
              account: fromToken.contract,
              name: "transfer",
              data: {
                from: actor,
                to: contract,
                quantity: fromToken.quantity,
                memo: "".concat(actor, " deposit for a pool")
              },
              authorization: authorization
            }, {
              account: contract,
              name: "partakepool",
              data: {
                actor: actor,
                id: escrowId.toString()
              },
              authorization: authorization
            }];
            _context4.next = 3;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 3:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _partakePool.apply(this, arguments);
}

function cancelPool(_x15, _x16, _x17, _x18) {
  return _cancelPool.apply(this, arguments);
}

function _cancelPool() {
  _cancelPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(actor, escrowId, authorization, session) {
    var actions;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            actions = [{
              account: contract,
              name: "cancelpool",
              data: {
                actor: actor,
                id: escrowId.toString()
              },
              authorization: authorization
            }];
            _context5.next = 3;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 3:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _cancelPool.apply(this, arguments);
}

function fillPool(_x19, _x20, _x21, _x22, _x23) {
  return _fillPool.apply(this, arguments);
} // const history = await api.getActionsFromHyperion(ctx.auth.actor, {
//     limit: 10,
//     skip: 0,
//     sort: "desc",
//     filter: contract*",
// });
// console.log("History", history);

function _fillPool() {
  _fillPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(actor, escrowId, winners, authorization, session) {
    var actions;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            actions = [{
              account: contract,
              name: "fillpool",
              data: {
                from: actor,
                id: escrowId.toString(),
                winners: winners
              },
              authorization: authorization
            }];
            _context6.next = 3;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 3:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _fillPool.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/***/ ((module) => {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  // Node.js and other environments that support module.exports.
  } else {}
})(this);


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/dayjs/dayjs.min.js":
/*!*****************************************!*\
  !*** ./node_modules/dayjs/dayjs.min.js ***!
  \*****************************************/
/***/ (function(module) {

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},v="en",D={};D[v]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return v;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(v=i),i||!r&&v},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var v=this.$locale().weekStart||0,D=(y<v?y+7:y)-v;return $(r?m-D:m+(6-D),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,v=O.m(this,M);return v=(l={},l[c]=v/12,l[f]=v,l[h]=v/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?v:O.a(v)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[v],w.Ls=D,w.p={},w}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/advancedFormat.js":
/*!*****************************************************!*\
  !*** ./node_modules/dayjs/plugin/advancedFormat.js ***!
  \*****************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(function(){"use strict";return function(e,t,r){var n=t.prototype,s=n.format;r.en.ordinal=function(e){var t=["th","st","nd","rd"],r=e%100;return"["+e+(t[(r-20)%10]||t[r]||t[0])+"]"},n.format=function(e){var t=this,r=this.$locale();if(!this.isValid())return s.bind(this)(e);var n=this.$utils(),a=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return r.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return r.ordinal(t.week(),"W");case"w":case"ww":return n.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return n.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return n.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return"["+t.offsetName()+"]";case"zzz":return"["+t.offsetName("long")+"]";default:return e}}));return s.bind(this)(a)}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/relativeTime.js":
/*!***************************************************!*\
  !*** ./node_modules/dayjs/plugin/relativeTime.js ***!
  \***************************************************/
/***/ (function(module) {

!function(r,e){ true?module.exports=e():0}(this,(function(){"use strict";return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return"function"==typeof M?M(a):M.replace("%s",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/timezone.js":
/*!***********************************************!*\
  !*** ./node_modules/dayjs/plugin/timezone.js ***!
  \***********************************************/
/***/ (function(module) {

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||"short",o=t+"|"+i,r=e[o];return r||(r=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:t,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],l=24===d?0:d,v=r[0]+"-"+r[1]+"-"+r[2]+" "+l+":"+r[4]+":"+r[5]+":000",h=+e;return(o.utc(v).valueOf()-(h-=h%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n=this.utcOffset(),i=this.toDate(),a=i.toLocaleString("en-US",{timeZone:t}),u=Math.round((i-new Date(a))/1e3/60),f=o(a).$set("millisecond",this.$ms).utcOffset(15*-Math.round(i.getTimezoneOffset()/15)-u,!0);if(e){var s=f.utcOffset();f=f.add(n-s,"minute")}return f.$x.$timezone=t,f},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return"timezonename"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format("YYYY-MM-DD HH:mm:ss:SSS"));return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if("string"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/utc.js":
/*!******************************************!*\
  !*** ./node_modules/dayjs/plugin/utc.js ***!
  \******************************************/
/***/ (function(module) {

!function(t,i){ true?module.exports=i():0}(this,(function(){"use strict";var t="minute",i=/[+-]\d\d(?::?\d\d)?/g,e=/([+-]|\d\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t)};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else r.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if("string"==typeof s&&(s=function(t){void 0===t&&(t="");var s=t.match(i);if(!s)return null;var f=(""+s[0]).match(e)||["-",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:"+"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return"s"===t&&this.$offset?n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/g, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/MapLike.js":
/*!*************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/MapLike.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class MapLike {
    constructor() {
        this._map = {};
    }
    get size() {
        return this.keys().length;
    }
    clear() {
        for (const key in this._map) {
            delete this._map[key];
        }
    }
    delete(key) {
        if (this.has(key)) {
            return delete this._map[key];
        }
        return false;
    }
    get(key) {
        return this._map[key];
    }
    has(key) {
        return this._map[key] !== undefined;
    }
    keys() {
        return Object.keys(this._map);
    }
    set(key, value) {
        this._map[key] = value;
        return this;
    }
    values() {
        const values = [];
        for (const key in this._map) {
            values.push(this._map[key]);
        }
        return values;
    }
}
exports["default"] = MapLike;
//# sourceMappingURL=MapLike.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/MessageHandler.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/MessageHandler.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/jsonrpc2-ws/lib/common.js");
const EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
class MessageHandler extends EventEmitter {
    constructor(options) {
        super();
        this.options = options;
        this.methods = new Map();
    }
    async handleMessage(socket, data) {
        const calls = [];
        const responses = [];
        let isBinary = false;
        let isArray = false;
        if (data instanceof ArrayBuffer) {
            isBinary = true;
            data = Buffer.from(data).toString();
        }
        else if (data instanceof Buffer) {
            isBinary = true;
            data = data.toString();
        }
        else if (Array.isArray(data)) {
            isBinary = true;
            data = "[" + data.map(buf => buf.toString()).join(",") + "]";
        }
        try {
            const obj = JSON.parse(data);
            if (Array.isArray(obj)) {
                isArray = true;
                if (obj.length === 0) {
                    const res = {
                        jsonrpc: "2.0",
                        error: common_1.createError(-32600 /* InvalidRequest */, null, "Empty Array"),
                        id: null
                    };
                    socket.send(JSON.stringify(res), isBinary);
                    return;
                }
                calls.push(...obj);
            }
            else {
                calls.push(obj);
            }
        }
        catch (e) {
            const res = {
                jsonrpc: "2.0",
                error: common_1.createError(-32700 /* ParseError */, null, "Invalid JSON"),
                id: null
            };
            socket.send(JSON.stringify(res), isBinary);
            return;
        }
        for (const call of calls) {
            const res = await this._processCall(socket, call);
            if (res) {
                responses.push(res);
            }
        }
        if (responses.length === 0) {
            return;
        }
        socket.send(JSON.stringify(isArray ? responses : responses[0]), isBinary);
    }
    async _processCall(socket, call) {
        const reqId = call.id;
        const res = {
            jsonrpc: "2.0",
            id: reqId === undefined ? null : reqId
        };
        if (typeof call !== "object") {
            res.error = common_1.createError(-32600 /* InvalidRequest */);
            return res;
        }
        if (call.jsonrpc !== "2.0" && (this.options.jsonrpcVersionCheck === 0 /* STRICT */ ||
            (this.options.jsonrpcVersionCheck === 1 /* LOOSE */ && call.jsonrpc !== undefined))) {
            res.error = common_1.createError(-32600 /* InvalidRequest */, null, "Invalid JSON-RPC Version");
            return res;
        }
        if (common_1.isResponse(call)) {
            this.emit("response", socket, call);
            if (call.id !== null) {
                this.emit("method_response", socket, call);
                return;
            }
            if (!call.error) {
                res.error = common_1.createError(-32600 /* InvalidRequest */);
                return res;
            }
            this.emit("error_response", socket, call);
            if (call.error.code === -32700 /* ParseError */ || call.error.code === -32600 /* InvalidRequest */) {
                return;
            }
            this.emit("notification_error", socket, call.error);
            return;
        }
        if (!call.method) {
            res.error = common_1.createError(-32601 /* MethodNotFound */, null, "Method not specified");
            return res;
        }
        if (typeof call.method !== "string") {
            res.error = common_1.createError(-32600 /* InvalidRequest */, null, "Invalid type of method name");
            return res;
        }
        if ("params" in call && (typeof call.params !== "object" || call.params === null)) {
            res.error = common_1.createError(-32600 /* InvalidRequest */);
            return res;
        }
        if (this.methods.has(call.method) === false) {
            res.error = common_1.createError(-32601 /* MethodNotFound */);
            return res;
        }
        try {
            res.result = await this.methods.get(call.method)(socket, call.params) || null;
            if (reqId === undefined) {
                return;
            }
            return res;
        }
        catch (e) {
            if (reqId === undefined) {
                return;
            }
            if (e instanceof Error) {
                res.error = common_1.createError(-32000 /* ServerError */, e.name, e.message);
            }
            else {
                res.error = e;
            }
            return res;
        }
    }
}
exports["default"] = MessageHandler;
//# sourceMappingURL=MessageHandler.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/client.js":
/*!************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/client.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigDefaults = void 0;
const WebSocket = __webpack_require__(/*! isomorphic-ws */ "./node_modules/isomorphic-ws/browser.js");
const Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");
const EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/jsonrpc2-ws/lib/common.js");
const MessageHandler_1 = __webpack_require__(/*! ./MessageHandler */ "./node_modules/jsonrpc2-ws/lib/MessageHandler.js");
exports.ConfigDefaults = Object.freeze({
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    reconnectionJitter: 0.5,
    methodCallTimeout: 20000,
    autoConnect: true,
    bufferSendingMessages: true,
    query: {},
    protocols: ""
});
/**
 * JSON-RPC 2.0 Client
 */
class Client extends EventEmitter {
    /**
     * Create an instance
     * @param uri The URI to connect.
     * @param options Options
     */
    constructor(uri, options = {}) {
        super();
        this.uri = uri;
        this.sendingMessageBuffer = [];
        this._reconnecting = false;
        this._responseHandlers = new Map();
        this._skipReconnection = false;
        this._currentRequestId = 0;
        this.config = {
            ...exports.ConfigDefaults,
            ...options
        };
        this._backoff = new Backoff({
            min: this.config.reconnectionDelay,
            max: this.config.reconnectionDelayMax,
            jitter: this.config.reconnectionJitter
        });
        this._messageHandler = new MessageHandler_1.default(this.config);
        this._messageHandler.on("method_response", (socket, response) => this._handleMethodResponse(response));
        this._messageHandler.on("error_response", (socket, response) => this.emit("error_response", response));
        this._messageHandler.on("notification_error", (socket, error) => this.emit("notification_error", error));
        if (this.config.autoConnect) {
            this.connect().catch(() => void 0);
        }
    }
    get methods() { return this._messageHandler.methods; }
    /**
     * Connect to the server
     */
    async connect() {
        if (this._ws) {
            return;
        }
        this.emit("connecting");
        const ws = this._ws = new WebSocket(this.uri, this.config.protocols, this.config);
        if (ws.addEventListener) {
            ws.addEventListener("error", error => this.emit("error", error));
            ws.addEventListener("close", ({ code, reason }) => {
                this.emit("close");
                this.emit("disconnect", code, reason);
                this._ws = null;
            });
            ws.addEventListener("message", ({ data }) => this._messageHandler.handleMessage(this, data).catch(e => this.emit("error", e)));
        }
        else {
            ws.on("error", error => this.emit("error", error));
            ws.on("close", (code, reason) => {
                this.emit("close");
                this.emit("disconnect", code, reason);
                this._ws = null;
            });
            ws.on("message", data => this._messageHandler.handleMessage(this, data).catch(e => this.emit("error", e)));
        }
        if (this.config.reconnection) {
            this._skipReconnection = false;
            if (ws.addEventListener) {
                ws.addEventListener("close", () => this.reconnect());
            }
            else {
                ws.on("close", () => this.reconnect());
            }
        }
        await new Promise((resolve, reject) => {
            if (ws.addEventListener) {
                ws.addEventListener("open", () => {
                    ws.removeEventListener("error", reject);
                    resolve();
                }, { once: true });
                ws.addEventListener("error", reject, { once: true });
            }
            else {
                ws.once("open", () => {
                    ws.off("error", reject);
                    resolve();
                });
                ws.once("error", reject);
            }
        });
        await this._sendBufferedMessages();
        this.emit("connected");
    }
    /**
     * Disconnect the connection if it exists
     */
    async disconnect() {
        this._skipReconnection = true;
        this._reconnecting = false;
        this._backoff.reset();
        // clear method call timeout.
        for (const [timer] of this._responseHandlers) {
            clearTimeout(timer);
        }
        this._responseHandlers.clear();
        // clear reconnection timer.
        if (this._reconnectionSleepTimer) {
            clearTimeout(this._reconnectionSleepTimer);
            this._reconnectionSleepTimer = null;
        }
        const ws = this._ws;
        if (!ws) {
            return Promise.resolve();
        }
        let promise;
        if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            promise = new Promise(resolve => {
                if (ws.addEventListener) {
                    ws.addEventListener("close", () => resolve(), { once: true });
                }
                else {
                    ws.once("close", () => resolve());
                }
            });
            ws.close();
        }
        else {
            promise = Promise.resolve();
        }
        this._ws = null;
        await promise;
        if (ws.removeAllListeners) {
            // for node
            ws.removeAllListeners();
        }
        else {
            // for browser
            // not necessary at this time.
        }
    }
    send(data, binary = false) {
        if (binary && typeof data === "string") {
            data = Buffer.from(data).buffer;
        }
        if (!this.isConnected()) {
            this._bufferSendingMessage(data);
            return;
        }
        this._ws.send(data, e => e ? this._bufferSendingMessage(data) : null);
    }
    clearSendingMessageBuffer() {
        this.sendingMessageBuffer.length = 0;
    }
    notify(method, params) {
        const data = {
            jsonrpc: "2.0",
            method,
            params
        };
        this.send(JSON.stringify(data));
    }
    call(method, params = {}) {
        const id = this._currentRequestId++;
        const data = {
            jsonrpc: "2.0",
            method,
            params,
            id
        };
        this.send(JSON.stringify(data));
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this._responseHandlers.delete(id);
                reject(new Error("JSON-RPC: method call timeout"));
            }, this.config.methodCallTimeout);
            this._responseHandlers.set(id, [timeout, resolve, reject]);
        });
    }
    isConnected() {
        return this._ws !== null && this._ws.readyState === WebSocket.OPEN;
    }
    async reconnect() {
        if (this._reconnecting || this._skipReconnection) {
            return;
        }
        const backoff = this._backoff;
        if (backoff.attempts > this.config.reconnectionAttempts) {
            this.emit("reconnect_failed");
            this.disconnect();
            return;
        }
        const delay = backoff.duration();
        this._reconnecting = true;
        await new Promise(resolve => this._reconnectionSleepTimer = setTimeout(resolve, delay));
        this._reconnectionSleepTimer = null;
        if (this._skipReconnection) {
            return;
        }
        this.emit("reconnecting", backoff.attempts);
        if (this._skipReconnection) {
            return;
        }
        try {
            await this.connect();
        }
        catch (err) {
            this._reconnecting = false;
            this.reconnect();
            this.emit("reconnect_error", err);
            return;
        }
        const attempts = backoff.attempts;
        backoff.reset();
        this._reconnecting = false;
        this.emit("reconnected", attempts);
    }
    _handleMethodResponse(response) {
        if (typeof response.id === "string") {
            this.emit("unkown_response", response);
            return;
        }
        const handler = this._responseHandlers.get(response.id);
        if (!handler) {
            this.emit("unkown_response", response);
            return;
        }
        this._responseHandlers.delete(response.id);
        const [timer, resolve, reject] = handler;
        clearTimeout(timer);
        if (common_1.isSuccessResponse(response)) {
            resolve(response.result);
        }
        else {
            reject(response.error);
        }
    }
    _bufferSendingMessage(data) {
        if (this.config.bufferSendingMessages) {
            this.sendingMessageBuffer.push(data);
        }
        else {
            throw new Error("Message is rejected:  The socket is close without message buffering.");
        }
    }
    async _sendBufferedMessages() {
        const buffer = this.sendingMessageBuffer;
        const ws = this._ws;
        for (let data = buffer.shift(); data; data = buffer.shift()) {
            try {
                await new Promise((resolve, reject) => ws.send(data, e => e ? reject(e) : resolve()));
            }
            catch (e) {
                buffer.unshift(data);
                this.emit("buffer_sending_error", e);
                break;
            }
        }
    }
}
exports["default"] = Client;
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/common.js":
/*!************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/common.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createError = exports.errorCodeMap = exports.isSuccessResponse = exports.isResponse = void 0;
/**
 * Check type of call is an Reponse or not
 * @param call an Call object which will be checked.
 */
function isResponse(call) {
    return "id" in call && ("result" in call || "error" in call);
}
exports.isResponse = isResponse;
/**
 * Check type of response is SuccessResponse or not
 *
 * @param response an Response object which will be checked.
 */
function isSuccessResponse(response) {
    return "result" in response && response.id !== null;
}
exports.isSuccessResponse = isSuccessResponse;
/**
 * JSON-RPC 2.0 Error Codes
 */
exports.errorCodeMap = new Map([
    [-32700, "Parse error"],
    [-32600, "Invalid Request"],
    [-32601, "Method not found"],
    [-32602, "Invalid params"],
    [-32603, "Internal error"],
    [-32000, "Server error"]
]);
/**
 * Creates a JSON-RPC 2.0 compliant Error Object
 * @param code A Number that indicates the error type that occurred. (Integer)
 * @param data A Primitive or Structured value that contains additional information about the error.
 */
function createError(code, message, data) {
    const error = {
        code: code,
        message: message || exports.errorCodeMap.get(code) || "Server error"
    };
    if (data !== undefined) {
        error.data = data;
    }
    return error;
}
exports.createError = createError;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = exports.Server = void 0;
var server_1 = __webpack_require__(/*! ./server */ "./node_modules/jsonrpc2-ws/lib/server.js");
Object.defineProperty(exports, "Server", ({ enumerable: true, get: function () { return server_1.default; } }));
var client_1 = __webpack_require__(/*! ./client */ "./node_modules/jsonrpc2-ws/lib/client.js");
Object.defineProperty(exports, "Client", ({ enumerable: true, get: function () { return client_1.default; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/server.js":
/*!************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Socket = void 0;
const EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
const ws_1 = __webpack_require__(/*! ws */ "./node_modules/ws/browser.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const MessageHandler_1 = __webpack_require__(/*! ./MessageHandler */ "./node_modules/jsonrpc2-ws/lib/MessageHandler.js");
const MapLike_1 = __webpack_require__(/*! ./MapLike */ "./node_modules/jsonrpc2-ws/lib/MapLike.js");
/**
 * JSON-RPC 2.0 WebSocket Server
 */
class Server extends EventEmitter {
    /**
     * Create a instance.
     * @param options
     * @param callback callback A listener for the `listening` event (ws).
     */
    constructor(options, callback) {
        super();
        this.sockets = new Map();
        this._lastPingAt = 0;
        this.options = Object.assign({
            pingTimeout: 5000,
            pingInterval: 25000,
            open: true,
            jsonrpcVersionCheck: 0 /* STRICT */,
            uws: false
        }, options);
        this._messageHandler = new MessageHandler_1.default(this.options);
        this._messageHandler.on("error_response", (socket, response) => {
            this.emit("error_response", socket, response);
            socket.emit("error_response", response);
        });
        this._messageHandler.on("notification_error", (socket, error) => {
            this.emit("notification_error", socket, error);
            socket.emit("notification_error", error);
        });
        if (this.options.open) {
            this.open(callback);
        }
    }
    get methods() { return this._messageHandler.methods; }
    /**
     * Create
     * @param callback callback A listener for the `listening` event (ws).
     */
    open(callback) {
        const self = this;
        if (this.wss) {
            throw new Error("`ws` has already been created");
        }
        if (this.options.wsEngine) {
            this.wss = new this.options.wsEngine(this.options.wss, callback);
        }
        else {
            this.wss = new ws_1.Server(this.options.wss, callback);
        }
        this.wss.once("listening", function _onListeningWSS() {
            self.emit("listening");
        });
        this.wss.on("connection", function _onConnectionWSS(ws, req) {
            let socket = new Socket(ws);
            self.sockets.set(socket.id, socket);
            ws.once("close", function _onCloseWS() {
                self.sockets.delete(socket.id);
                socket.emit("close");
                socket.removeAllListeners();
                socket.ws = null;
                socket.rooms.clear();
                socket.data.clear();
                socket = null;
                ws.removeAllListeners();
                ws = null;
            });
            ws.on("message", function _onMessageWS(data) {
                self._messageHandler.handleMessage(socket, data)
                    .catch(function _onErrorHandleMessage(e) {
                    self.emit("error", e);
                });
            });
            ws.on("pong", function _onPongWS() {
                socket._pongAt = Date.now();
            });
            self.emit("connection", socket, req);
        });
        this.wss.on("error", function _onErrorWSS(e) {
            self.emit("error", e);
        });
        this._pingTimer = setInterval(this._ping.bind(this), this.options.pingInterval);
        return this;
    }
    /**
     * Closes the server and terminates all sockets.
     */
    async close() {
        clearInterval(this._pingTimer);
        for (const socket of this.sockets.values()) {
            socket.terminate();
        }
        await new Promise((resolve, reject) => {
            this.wss.close(err => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
        this.wss.removeAllListeners();
        delete this.wss;
        this.sockets.clear();
    }
    /**
     * Broadcasts a notification.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    broadcast(method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        const json = JSON.stringify(data);
        for (const socket of this.sockets.values()) {
            socket.send(json);
        }
    }
    /**
     * Broadcasts a notification to the room.
     * @param room The name of the room.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notifyTo(room, method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        const json = JSON.stringify(data);
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                socket.send(json);
            }
        }
    }
    /**
     * Broadcasts a (raw) message to the room.
     * @param room The name of the room.
     * @param data (raw) message.
     */
    sendTo(room, data) {
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                socket.send(data);
            }
        }
    }
    /**
     * Get all sockets in the room.
     * @param room The name of the room.
     */
    in(room) {
        const sockets = new Map();
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                sockets.set(socket.id, socket);
            }
        }
        return sockets;
    }
    /**
     * Server is open or not
     */
    isOpen() {
        return this.wss !== undefined;
    }
    /**
     * Ping to all sockets.
     */
    _ping() {
        const deadline = this._lastPingAt + this.options.pingTimeout;
        for (const socket of this.sockets.values()) {
            if (socket._pongAt === -1 || socket._pongAt > deadline) {
                socket.terminate();
                continue;
            }
            socket._pongAt = -1;
            if (socket.isOpen()) {
                socket.ws.ping();
            }
        }
        this._lastPingAt = Date.now();
    }
}
exports["default"] = Server;
class Socket extends EventEmitter {
    constructor(ws) {
        super();
        this.ws = ws;
        this.id = uuid_1.v4();
        this.rooms = new Set();
        /** custom data store */
        this.data = new MapLike_1.default();
        /** (internal using for heartbeat) */
        this._pongAt = 0;
    }
    /**
     * Sends a notification to the socket.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notify(method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        this.send(JSON.stringify(data));
    }
    /**
     * Sends a (raw) message to the socket.
     * @param data (raw) message.
     * @param binary binary flag.
     */
    send(data, binary = false) {
        if (this.isOpen()) {
            this.ws.send(data, { binary });
        }
    }
    /**
     * Joins a room. You can join multiple rooms.
     * @param room The name of the room that we want to join.
     */
    joinTo(room) {
        if (this.rooms.has(room) === false) {
            this.rooms.add(room);
            return true;
        }
        return false;
    }
    /**
     * Leaves a room.
     * @param room The name of the room to leave.
     */
    leaveFrom(room) {
        if (this.rooms.has(room) === true) {
            this.rooms.delete(room);
            return true;
        }
        return false;
    }
    /**
     * Leaves all the rooms that we've joined.
     */
    leaveFromAll() {
        this.rooms.clear();
    }
    /**
     * Initiate a closing handshake.
     * @param code A numeric value indicating the status code explaining why the connection is being closed.
     * @param reason A human-readable string explaining why the connection is closing.
     */
    close(code, reason) {
        this.ws.close(code, reason);
    }
    /**
     * Forcibly close the connection.
     */
    terminate() {
        this.ws.terminate();
    }
    /**
     * Get the connection is open or not
     */
    isOpen() {
        return this.ws !== undefined && this.ws.readyState === ws_1.OPEN;
    }
}
exports.Socket = Socket;
//# sourceMappingURL=server.js.map

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(/*! ./util.inspect */ "?2128");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== '__proto__') {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var split = String.prototype.split;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            if (generateArrayPrefix === 'comma' && encodeValuesOnly) {
                var valuesArray = split.call(String(obj), ',');
                var valuesJoined = '';
                for (var i = 0; i < valuesArray.length; ++i) {
                    valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults.encoder, charset, 'value', format));
                }
                return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? '[]' : '') + '=' + valuesJoined];
            }
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        /* eslint operator-linebreak: [2, "before"] */
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NIL": () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "parse": () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "stringify": () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "v1": () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "v3": () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "v4": () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "v5": () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "validate": () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "version": () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/esm-browser/v1.js");
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/esm-browser/v3.js");
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/esm-browser/nil.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/esm-browser/version.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");










/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/esm-browser/md5.js");


var v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ ((module) => {

"use strict";


module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ }),

/***/ "?2128":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DIRTY": () => (/* binding */ DIRTY),
/* harmony export */   "EMPTY_PATH": () => (/* binding */ EMPTY_PATH),
/* harmony export */   "INVALID": () => (/* binding */ INVALID),
/* harmony export */   "OK": () => (/* binding */ OK),
/* harmony export */   "ParseStatus": () => (/* binding */ ParseStatus),
/* harmony export */   "Schema": () => (/* binding */ ZodType),
/* harmony export */   "ZodAny": () => (/* binding */ ZodAny),
/* harmony export */   "ZodArray": () => (/* binding */ ZodArray),
/* harmony export */   "ZodBigInt": () => (/* binding */ ZodBigInt),
/* harmony export */   "ZodBoolean": () => (/* binding */ ZodBoolean),
/* harmony export */   "ZodDate": () => (/* binding */ ZodDate),
/* harmony export */   "ZodDefault": () => (/* binding */ ZodDefault),
/* harmony export */   "ZodDiscriminatedUnion": () => (/* binding */ ZodDiscriminatedUnion),
/* harmony export */   "ZodEffects": () => (/* binding */ ZodEffects),
/* harmony export */   "ZodEnum": () => (/* binding */ ZodEnum),
/* harmony export */   "ZodError": () => (/* binding */ ZodError),
/* harmony export */   "ZodFirstPartyTypeKind": () => (/* binding */ ZodFirstPartyTypeKind),
/* harmony export */   "ZodFunction": () => (/* binding */ ZodFunction),
/* harmony export */   "ZodIntersection": () => (/* binding */ ZodIntersection),
/* harmony export */   "ZodIssueCode": () => (/* binding */ ZodIssueCode),
/* harmony export */   "ZodLazy": () => (/* binding */ ZodLazy),
/* harmony export */   "ZodLiteral": () => (/* binding */ ZodLiteral),
/* harmony export */   "ZodMap": () => (/* binding */ ZodMap),
/* harmony export */   "ZodNaN": () => (/* binding */ ZodNaN),
/* harmony export */   "ZodNativeEnum": () => (/* binding */ ZodNativeEnum),
/* harmony export */   "ZodNever": () => (/* binding */ ZodNever),
/* harmony export */   "ZodNull": () => (/* binding */ ZodNull),
/* harmony export */   "ZodNullable": () => (/* binding */ ZodNullable),
/* harmony export */   "ZodNumber": () => (/* binding */ ZodNumber),
/* harmony export */   "ZodObject": () => (/* binding */ ZodObject),
/* harmony export */   "ZodOptional": () => (/* binding */ ZodOptional),
/* harmony export */   "ZodParsedType": () => (/* binding */ ZodParsedType),
/* harmony export */   "ZodPromise": () => (/* binding */ ZodPromise),
/* harmony export */   "ZodRecord": () => (/* binding */ ZodRecord),
/* harmony export */   "ZodSchema": () => (/* binding */ ZodType),
/* harmony export */   "ZodSet": () => (/* binding */ ZodSet),
/* harmony export */   "ZodString": () => (/* binding */ ZodString),
/* harmony export */   "ZodTransformer": () => (/* binding */ ZodEffects),
/* harmony export */   "ZodTuple": () => (/* binding */ ZodTuple),
/* harmony export */   "ZodType": () => (/* binding */ ZodType),
/* harmony export */   "ZodUndefined": () => (/* binding */ ZodUndefined),
/* harmony export */   "ZodUnion": () => (/* binding */ ZodUnion),
/* harmony export */   "ZodUnknown": () => (/* binding */ ZodUnknown),
/* harmony export */   "ZodVoid": () => (/* binding */ ZodVoid),
/* harmony export */   "addIssueToContext": () => (/* binding */ addIssueToContext),
/* harmony export */   "any": () => (/* binding */ anyType),
/* harmony export */   "array": () => (/* binding */ arrayType),
/* harmony export */   "bigint": () => (/* binding */ bigIntType),
/* harmony export */   "boolean": () => (/* binding */ booleanType),
/* harmony export */   "custom": () => (/* binding */ custom),
/* harmony export */   "date": () => (/* binding */ dateType),
/* harmony export */   "default": () => (/* binding */ mod),
/* harmony export */   "defaultErrorMap": () => (/* binding */ defaultErrorMap),
/* harmony export */   "discriminatedUnion": () => (/* binding */ discriminatedUnionType),
/* harmony export */   "effect": () => (/* binding */ effectsType),
/* harmony export */   "enum": () => (/* binding */ enumType),
/* harmony export */   "function": () => (/* binding */ functionType),
/* harmony export */   "getParsedType": () => (/* binding */ getParsedType),
/* harmony export */   "instanceof": () => (/* binding */ instanceOfType),
/* harmony export */   "intersection": () => (/* binding */ intersectionType),
/* harmony export */   "isAborted": () => (/* binding */ isAborted),
/* harmony export */   "isAsync": () => (/* binding */ isAsync),
/* harmony export */   "isDirty": () => (/* binding */ isDirty),
/* harmony export */   "isValid": () => (/* binding */ isValid),
/* harmony export */   "late": () => (/* binding */ late),
/* harmony export */   "lazy": () => (/* binding */ lazyType),
/* harmony export */   "literal": () => (/* binding */ literalType),
/* harmony export */   "makeIssue": () => (/* binding */ makeIssue),
/* harmony export */   "map": () => (/* binding */ mapType),
/* harmony export */   "nan": () => (/* binding */ nanType),
/* harmony export */   "nativeEnum": () => (/* binding */ nativeEnumType),
/* harmony export */   "never": () => (/* binding */ neverType),
/* harmony export */   "null": () => (/* binding */ nullType),
/* harmony export */   "nullable": () => (/* binding */ nullableType),
/* harmony export */   "number": () => (/* binding */ numberType),
/* harmony export */   "object": () => (/* binding */ objectType),
/* harmony export */   "objectUtil": () => (/* binding */ objectUtil),
/* harmony export */   "oboolean": () => (/* binding */ oboolean),
/* harmony export */   "onumber": () => (/* binding */ onumber),
/* harmony export */   "optional": () => (/* binding */ optionalType),
/* harmony export */   "ostring": () => (/* binding */ ostring),
/* harmony export */   "overrideErrorMap": () => (/* binding */ overrideErrorMap),
/* harmony export */   "preprocess": () => (/* binding */ preprocessType),
/* harmony export */   "promise": () => (/* binding */ promiseType),
/* harmony export */   "quotelessJson": () => (/* binding */ quotelessJson),
/* harmony export */   "record": () => (/* binding */ recordType),
/* harmony export */   "set": () => (/* binding */ setType),
/* harmony export */   "setErrorMap": () => (/* binding */ setErrorMap),
/* harmony export */   "strictObject": () => (/* binding */ strictObjectType),
/* harmony export */   "string": () => (/* binding */ stringType),
/* harmony export */   "transformer": () => (/* binding */ effectsType),
/* harmony export */   "tuple": () => (/* binding */ tupleType),
/* harmony export */   "undefined": () => (/* binding */ undefinedType),
/* harmony export */   "union": () => (/* binding */ unionType),
/* harmony export */   "unknown": () => (/* binding */ unknownType),
/* harmony export */   "void": () => (/* binding */ voidType),
/* harmony export */   "z": () => (/* binding */ mod)
/* harmony export */ });
var util;
(function (util) {
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
})(util || (util = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, null, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};
const defaultErrorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (issue.validation !== "regex")
                message = `Invalid ${issue.validation}`;
            else
                message = "Invalid";
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return { message };
};
let overrideErrorMap = defaultErrorMap;
const setErrorMap = (map) => {
    overrideErrorMap = map;
};

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideErrorMap,
            defaultErrorMap,
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== undefined && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        return this._path.concat(this._key);
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        const error = new ZodError(ctx.common.issues);
        return { success: false, error };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined" && required_error)
            return { message: required_error };
        if (params.invalid_type_error)
            return { message: params.invalid_type_error };
        return { message: ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this.superRefine = this._refinement;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.default = this.default.bind(this);
        this.describe = this.describe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    optional() {
        return ZodOptional.create(this);
    }
    nullable() {
        return ZodNullable.create(this);
    }
    nullish() {
        return this.optional().nullable();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this);
    }
    or(option) {
        return ZodUnion.create([this, option]);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming);
    }
    transform(transform) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
// eslint-disable-next-line
const emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class ZodString extends ZodType {
    constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this.min(len, message).max(len, message);
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get minLength() {
        let min = -Infinity;
        this._def.checks.map((ch) => {
            if (ch.kind === "min") {
                if (min === null || ch.value > min) {
                    min = ch.value;
                }
            }
        });
        return min;
    }
    get maxLength() {
        let max = null;
        this._def.checks.map((ch) => {
            if (ch.kind === "max") {
                if (max === null || ch.value < max) {
                    max = ch.value;
                }
            }
        });
        return max;
    }
}
ZodString.create = (params) => {
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int");
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBigInt.create = (params) => {
    return new ZodBigInt({
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        return {
            status: "valid",
            value: new Date(input.data.getTime()),
        };
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all(ctx.data.map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = ctx.data.map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return this.min(len, message).max(len, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodObject      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second,
        };
    };
})(objectUtil || (objectUtil = {}));
const AugmentFactory = (def) => (augmentation) => {
    return new ZodObject({
        ...def,
        shape: () => ({
            ...def.shape(),
            ...augmentation,
        }),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return ZodArray.create(deepPartialify(schema.element));
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        this.augment = AugmentFactory(this._def);
        this.extend = AugmentFactory(this._def);
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        // const mergedShape = objectUtil.mergeShapes(
        //   this._def.shape(),
        //   merging._def.shape()
        // );
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).map((key) => {
            // only add to shape if key corresponds to an element of the current shape
            if (this.shape[key])
                shape[key] = this.shape[key];
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).map((key) => {
            if (util.objectKeys(mask).indexOf(key) === -1) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        if (mask) {
            util.objectKeys(this.shape).map((key) => {
                if (util.objectKeys(mask).indexOf(key) === -1) {
                    newShape[key] = this.shape[key];
                }
                else {
                    newShape[key] = this.shape[key].optional();
                }
            });
            return new ZodObject({
                ...this._def,
                shape: () => newShape,
            });
        }
        else {
            for (const key in this.shape) {
                const fieldSchema = this.shape[key];
                newShape[key] = fieldSchema.optional();
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required() {
        const newShape = {};
        for (const key in this.shape) {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
            }
            newShape[key] = newField;
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.options.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: this.validDiscriminatorValues,
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get validDiscriminatorValues() {
        return Array.from(this.options.keys());
    }
    get options() {
        return this._def.options;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, types, params) {
        // Get all the valid discriminator values
        const options = new Map();
        try {
            types.forEach((type) => {
                const discriminatorValue = type.shape[discriminator].value;
                options.set(discriminatorValue, type);
            });
        }
        catch (e) {
            throw new Error("The discriminator value could not be extracted from all the provided schemas");
        }
        // Assert that all the discriminator values are unique
        if (options.size !== types.length) {
            throw new Error("Some of the discriminator values are not unique");
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                type: "array",
            });
            status.dirty();
        }
        const items = ctx.data
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    overrideErrorMap,
                    defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    overrideErrorMap,
                    defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            return OK(async (...args) => {
                const error = new ZodError([]);
                const parsedArgs = await this._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await fn(...parsedArgs);
                const parsedReturns = await this._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            return OK((...args) => {
                const parsedArgs = this._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = fn(...parsedArgs.data);
                const parsedReturns = this._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
}
ZodFunction.create = (args, returns, params) => {
    return new ZodFunction({
        args: (args
            ? args.rest(ZodUnknown.create())
            : ZodTuple.create([]).rest(ZodUnknown.create())),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params),
    });
};
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                // if (base.status === "aborted") return INVALID;
                // if (base.status === "dirty") {
                //   return { status: "dirty", value: base.value };
                // }
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    // if (base.status === "aborted") return INVALID;
                    // if (base.status === "dirty") {
                    //   return { status: "dirty", value: base.value };
                    // }
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const custom = (check, params = {}, fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            if (!check(data)) {
                const p = typeof params === "function" ? params(data) : params;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal });
            }
        });
    return ZodAny.create();
};
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params, true);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();

var mod = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getParsedType: getParsedType,
    ZodParsedType: ZodParsedType,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    ZodType: ZodType,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    get objectUtil () { return objectUtil; },
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodNaN: ZodNaN,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError,
    defaultErrorMap: defaultErrorMap,
    get overrideErrorMap () { return overrideErrorMap; },
    setErrorMap: setErrorMap
});




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvcmVzb3VyY2VzX2pzX3BhZ2VzX0NvbnRlc3RfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLDZCQUE2QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRTRiO0FBQzViOzs7Ozs7Ozs7Ozs7O0FDL3FDWTs7QUFFWixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUseUlBQXdEO0FBQzFEOzs7Ozs7Ozs7Ozs7QUNQYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGdDQUFnQzs7QUFFaEMsbUJBQW1CLG1CQUFPLENBQUMsOERBQWM7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsc0VBQWU7QUFDcEQsNEJBQTRCLG1CQUFPLENBQUMsZ0RBQU87QUFDM0MseUNBQXlDLG1CQUFPLENBQUMsOEVBQTJCO0FBQzVFLGdDQUFnQyxtQkFBTyxDQUFDLDREQUFrQjtBQUMxRCxxQ0FBcUMsbUJBQU8sQ0FBQyxzRUFBdUI7QUFDcEUsMkNBQTJDLG1CQUFPLENBQUMsa0ZBQTZCOztBQUVoRjtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcseURBQXlEO0FBQzVELENBQUMsb0JBQW9CLGFBQWEsS0FBSzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3QkFBd0I7QUFDekQsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLDRCQUE0QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qjs7QUFFK29C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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdURBQXVELHdEQUFVO0FBQ2pFO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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LEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsK0dBQStHOztBQUUvRztBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLCtHQUErRzs7QUFFL0c7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnREFBUTs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckMsMkJBQTJCLHdEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvRUFBc0I7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvRUFBc0I7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsNkRBQWU7O0FBRXhEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDLDJCQUEyQix3REFBVTtBQUNyQztBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsZUFBZTtBQUNmLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtREFBUyxDQUFDLHdEQUFVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsd0RBQVU7QUFDdEM7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBLG1DQUFtQyx5Q0FBUTtBQUMzQyx3QkFBd0IseUNBQVE7QUFDaEMsNEJBQTRCLHlDQUFRO0FBQ3BDLDZCQUE2Qix5Q0FBUTtBQUNyQyxvQ0FBb0MseUNBQVE7QUFDNUMsc0NBQXNDLHlDQUFRO0FBQzlDLGtDQUFrQyx5Q0FBUTtBQUMxQyxvQ0FBb0MseUNBQVE7QUFDNUMsNkJBQTZCLHdDQUFPLGVBQWUseUNBQVE7QUFDM0Qsb0NBQW9DLHdDQUFPLGVBQWUseUNBQVE7QUFDbEUsa0NBQWtDLHdDQUFPLGVBQWUseUNBQVE7QUFDaEUsK0JBQStCLHdDQUFPLGVBQWUseUNBQVE7QUFDN0QsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4Qyw2RUFBeUI7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSw4Q0FBOEMsa0ZBQThCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQztBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckM7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckM7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckMsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQztBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixzQ0FBc0MsbUNBQW1DLFNBQVM7QUFDL0c7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiwwREFBVSxDQUFDLHVEQUFPO0FBQzdDLDZCQUE2QiwwREFBVSxDQUFDLHVEQUFPLENBQUMseURBQVMsQ0FBQyxvREFBSTtBQUM5RDtBQUNBO0FBQ0EsNkJBQTZCLDBDQUEwQywwR0FBMEcsR0FBRyw0RUFBNEUsU0FBUztBQUN6UTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRCw0Q0FBNEMsR0FBRyxTQUFTLEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esb0NBQW9DLG1EQUFtRCxHQUFHLE1BQU07QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQyxZQUFZLHlCQUF5QjtBQUNyQztBQUNBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLG9DQUFvQyxtREFBbUQsR0FBRyxHQUFHO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsTUFBTTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsNERBQWU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDRDQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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YjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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VTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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N0I7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxL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QUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFzRDtBQUM3RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQXNEO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQSxtQ0FBbUMsNkNBQTZDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZDQUE2QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZDQUE2QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsdUdBQXVHLHFDQUFxQztBQUM1SSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRSwrQkFBK0IsOEJBQThCO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0JBQStCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0EsQ0FBQzs7QUFFdWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BibG9rcy9jb25zdGFudHMvZGlzdC9jb25zdGFudHMuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmxva3MvbnVtYmVycy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmxva3MvbnVtYmVycy9kaXN0L251bWJlcnMuY2pzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmxva3MvdXRpbHMvZGlzdC91dGlscy5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqYWZyaS9udW1icm8vZGlzdC9udW1icm8ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2FwaS9kaXN0L2FwaS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vaHlwZXJpb24vZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9oeXBlcmlvbi9kaXN0L3NyYy9lbmRwb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vaHlwZXJpb24vZGlzdC9zcmMvanNvbnJwYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9oeXBlcmlvbi9kaXN0L3NyYy9ycGNlcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9oeXBlcmlvbi9kaXN0L3NyYy90eXBlcy9hY3Rpb25fdHJhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vaHlwZXJpb24vZGlzdC9zcmMvdHlwZXMvYXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2xpZ2h0LWFwaS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2xpZ2h0LWFwaS9kaXN0L3NyYy9lbmRwb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vbGlnaHQtYXBpL2Rpc3Qvc3JjL2pzb25ycGMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vbGlnaHQtYXBpL2Rpc3Qvc3JjL3JwY2Vycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2xpZ2h0LWFwaS9kaXN0L3NyYy90eXBlcy9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvZGlzdC93cmFwLWNvbnN0YW50cy5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL1pvZEVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy9jb2RlZ2VuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy9kZWZhdWx0RXJyb3JNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy9oZWxwZXJzL29iamVjdFV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL2hlbHBlcnMvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL2lzU2NhbGFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2FueS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2JpZ2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvYm9vbGVhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvZW51bS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2ludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMva2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2xhenkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2xpdGVyYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL25hdGl2ZUVudW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL251bGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9yZWNvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvdHVwbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3VuZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvdW5pb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3Vua25vd24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3ZvaWQuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvdWkvQ3VycmVuY3lEcm9wZG93bi5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29uc3RhbnRzL0N1cnJlbmN5TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvcGFnZXMvQ29udGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc2RrL2Vhc3lwb29sU0RLLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWNrbzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF5anMvZGF5anMubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXlqcy9wbHVnaW4vYWR2YW5jZWRGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RheWpzL3BsdWdpbi9yZWxhdGl2ZVRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RheWpzL3BsdWdpbi90aW1lem9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL3V0Yy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc29ucnBjMi13cy9saWIvTWFwTGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbnJwYzItd3MvbGliL01lc3NhZ2VIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc29ucnBjMi13cy9saWIvY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc29ucnBjMi13cy9saWIvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc29ucnBjMi13cy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25ycGMyLXdzL2xpYi9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pbnNwZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2lkZS1jaGFubmVsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9tZDUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9uaWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3NoYTEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjM1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9icm93c2VyLmpzIiwid2VicGFjazovLy9pZ25vcmVkfEY6XFxOZXdfY2xpZW50c1xcV2FkZS1Qcm90b25cXEVhc3lFc2Nyb3dcXG5vZGVfbW9kdWxlc1xcb2JqZWN0LWluc3BlY3R8Li91dGlsLmluc3BlY3QiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pvZC9saWIvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBERUZBVUxUX1NZTUJPTCA9ICdFT1MnO1xudmFyIERFRkFVTFRfU1lTVEVNX0RPTUFJTiA9ICdlb3Npbyc7XG52YXIgREVGQVVMVF9DSEFJTiA9ICdlb3MnO1xuXG52YXIgZ2V0Q29udHJhY3RDb25zdGFudHMgPSBmdW5jdGlvbiBnZXRDb250cmFjdENvbnN0YW50cyhjaGFpbiwgc3lzdGVtRG9tYWluKSB7XG4gIGlmIChjaGFpbiA9PT0gdm9pZCAwKSB7XG4gICAgY2hhaW4gPSBERUZBVUxUX0NIQUlOO1xuICB9XG5cbiAgaWYgKHN5c3RlbURvbWFpbiA9PT0gdm9pZCAwKSB7XG4gICAgc3lzdGVtRG9tYWluID0gREVGQVVMVF9TWVNURU1fRE9NQUlOO1xuICB9XG5cbiAgLy8gUHJveHkgSW5mb3JtYXRpb24gQWNjb3VudFxuICB2YXIgcHJveHlJbmZvO1xuXG4gIGlmIChbJ2VvcycsICdib3MnLCAnd2F4J10uaW5jbHVkZXMoY2hhaW4pKSB7XG4gICAgcHJveHlJbmZvID0gJ3JlZ3Byb3h5aW5mbyc7XG4gIH0gZWxzZSBpZiAoY2hhaW4gPT09ICd0ZWxvcycpIHtcbiAgICBwcm94eUluZm8gPSAndGxzcHJveHlpbmZvJztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gQWNjb3VudHNcbiAgICBFT1NJTzogc3lzdGVtRG9tYWluLFxuICAgIEVPU0lPX1RPS0VOOiAhWydmaW8nLCAnZmlvLXRlc3QnXS5pbmNsdWRlcyhjaGFpbikgPyBzeXN0ZW1Eb21haW4gKyBcIi50b2tlblwiIDogJ2Zpby50b2tlbicsXG4gICAgQUNDT1VOVF9JTkZPOiAnYWNjb3VudC5pbmZvJyxcbiAgICBQUk9YWV9JTkZPX0FDQ09VTlQ6IHByb3h5SW5mbyxcbiAgICBFT1NJT19NU0lHOiBzeXN0ZW1Eb21haW4gKyBcIi5tc2lnXCIsXG4gICAgRU9TSU9fUkFNOiBzeXN0ZW1Eb21haW4gKyBcIi5yYW1cIixcbiAgICBFT1NJT19TVEFLRTogc3lzdGVtRG9tYWluICsgXCIuc3Rha2VcIixcbiAgICBFT1NJT19QUk9EUzogc3lzdGVtRG9tYWluICsgXCIucHJvZHNcIixcbiAgICBFT1NJT19OVUxMOiBzeXN0ZW1Eb21haW4gKyBcIi5udWxsXCIsXG4gICAgRU9TSU9fUkFNRkVFOiBzeXN0ZW1Eb21haW4gKyBcIi5yYW1mZWVcIixcbiAgICBFT1NJT19WUEFZOiBzeXN0ZW1Eb21haW4gKyBcIi52cGF5XCIsXG4gICAgRU9TSU9fQlBBWTogc3lzdGVtRG9tYWluICsgXCIuYnBheVwiLFxuICAgIEVPU0lPX1JFWDogc3lzdGVtRG9tYWluICsgXCIucmV4XCIsXG4gICAgLy8gUGFyYW1zXG4gICAgTkVXQUNDT1VOVF9OQU1FX1BBUkFNOiBjaGFpbi5pbmRleE9mKCdib3MnKSA9PT0gLTEgPyAnbmFtZScgOiAnbmV3YWN0JyxcbiAgICAvLyBUYWJsZXNcbiAgICBFT1NJT19NU0lHX0FQUFJPVkFMU19UQUJMRTogJ2FwcHJvdmFsczInLFxuICAgIEVPU0lPX01TSUdfUFJPUE9TQUxTX1RBQkxFOiAncHJvcG9zYWwnLFxuICAgIC8vIEFjdGlvbnNcbiAgICBUUkFOU0ZFUl9BQ1RJT046ICd0cmFuc2ZlcicsXG4gICAgREVMRUdBVEVfQldfQUNUSU9OOiAnZGVsZWdhdGVidycsXG4gICAgVU5ERUxFR0FURV9CV19BQ1RJT046ICd1bmRlbGVnYXRlYncnLFxuICAgIFZPVEVfUFJPRFVDRVJfQUNUSU9OOiAndm90ZXByb2R1Y2VyJyxcbiAgICBCVVlfUkFNX0FDVElPTjogJ2J1eXJhbScsXG4gICAgQlVZX1JBTV9CWVRFU19BQ1RJT046ICdidXlyYW1ieWVzJyxcbiAgICBTRUxMX1JBTV9BQ1RJT046ICdzZWxscmFtJ1xuICB9O1xufTtcblxudmFyIGRhcHBzID0gW3tcbiAgbmFtZTogJ0FsY29yLmV4Y2hhbmdlJyxcbiAgZGVzY3JpcHRpb246ICdUaGUgZmlyc3Qgc2VsZi1saXN0aW5nIERFWC4gV2l0aCBBbGNvciB5b3UgY2FuIHRyYWRlIGFueSBFT1MuSU8gdG9rZW5zIGZvciBzeXN0ZW0gRU9TIHRva2VucywgYXRvbWljYWxseSwgd2l0aG91dCB0aGUgcGFydGljaXBhdGlvbiBvZiB0aGlyZCBwYXJ0aWVzISBDcmVhdGUgbWFya2V0cyBpbiBvbmUgY2xpY2ssIGxpc3QgeW91ciBkYXBwIHRva2VuIGZvciBvbmUgY2xpY2ssIHRyYWRlIHdoYXRldmVyIHlvdSB3YW50LicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdUaGUgZmlyc3Qgc2VsZi1saXN0aW5nIERFWC4gV2l0aCBBbGNvciB5b3UgY2FuIHRyYWRlIGFueSBFT1MuSU8gdG9rZW5zIGZvciBzeXN0ZW0gRU9TIHRva2Vucy4nLFxuICBzeW1ib2w6ICcnLFxuICBzdGF0aXN0aWNzOiB0cnVlLFxuICBhY2NvdW50czogWydlb3N0b2tlbnNkZXgnXSxcbiAgbG9nbzogJ2h0dHBzOi8vaS5pYmIuY28vZEtEWURNYy92ZWN0b3JwYWludC5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9hbGNvci5leGNoYW5nZS8nLFxuICBhcHA6ICdodHRwczovL2FsY29yLmV4Y2hhbmdlLycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2FsY29yZXhjaGFuZ2UnLFxuICBtZWRpdW06ICdodHRwczovL21lZGl1bS5jb20vQGF2cmFsJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vYXZyYWxfcHJvJyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL2F2cmFsL2FsY29yLXVpJyxcbiAgY2hhaW5zOiBbJ2VvcycsICd3YXgnLCAndGVsb3MnXVxufSwge1xuICBuYW1lOiAnU1gnLFxuICBkZXNjcmlwdGlvbjogJ0J1aWxkaW5nIHNlY3VyZSAmIHJlbGlhYmxlIGZpbmFuY2lhbCBibG9ja2NoYWluIGluc3RydW1lbnRzJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ0RlRmkgU3dhcCAmIEZsYXNobG9hbicsXG4gIHN5bWJvbDogJ1NYJyxcbiAgYWNjb3VudHM6IFsnc3dhcC5zeCcsICd2aWdvci5zeCcsICdzdGFibGUuc3gnLCAnZmxhc2guc3gnLCAncHVzaC5zeCcsICduZXR3b3JrLnN4JywgJ3JlZ2lzdHJ5LnN4JywgJ21pbmVyLnN4JywgJ2Nyb3NzLnN4JywgJ25hdi5zeCcsICdmZWUuc3gnLCAndHJhZGUuc3gnLCAndmF1bHRzLnN4JywgJ3Byb3h5LnN4JywgJ2R1c3Quc3gnLCAnY3VydmUuc3gnXSxcbiAgbG9nbzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lb3NjYWZlL2Vvcy1haXJkcm9wcy9tYXN0ZXIvbG9nb3Mvc3gucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS9zdGFibGVleCcsXG4gIGFwcDogJ2h0dHBzOi8veG5hdGlvbi5pbycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL3huYXRpb25pbycsXG4gIG1lZGl1bTogJycsXG4gIHR3aXR0ZXI6ICcnLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vc3RhYmxlZXgnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ0VPU05hbWVTZXJ2aWNlJyxcbiAgZGVzY3JpcHRpb246ICdFT1MgTmFtZSBTZXJ2aWNlIGlzIHRoZSBtb3N0IGNvbXByZWhlbnNpdmUgcGxhdGZvcm0gdG8gcmVnaXN0ZXIgcHJlbWl1bS9iYXNlIEVPUy9XQVggYWNjb3VudCBuYW1lcy4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnRU9TL1dBWCBOYW1lIFNlcnZpY2UnLFxuICBzeW1ib2w6ICcnLFxuICBwYXJ0bmVyOiBmYWxzZSxcbiAgYWNjb3VudHM6IFsnbmFtZXMnXSxcbiAgbG9nbzogJ2h0dHBzOi8vYXZhdGFyczEuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3UvNzM4OTEwNDEnLFxuICB3ZWJzaXRlOiAnaHR0cDovL2Vvc25hbWVzZXJ2aWNlLmlvJyxcbiAgYXBwOiAnaHR0cDovL2Vvc25hbWVzZXJ2aWNlLmlvJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvZW9zbmFtZXNlcnZpY2UnLFxuICBtZWRpdW06ICcnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9lb3NuYW1lc2VydmljZScsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9lb3NuYW1lc2VydmljZScsXG4gIGNoYWluczogWydlb3MnLCAnd2F4J11cbn0sIHtcbiAgbmFtZTogJ1Byb3NwZWN0b3JzJyxcbiAgZGVzY3JpcHRpb246ICdNYXNzaXZlIE11bHRpcGxheWVyIE9ubGluZSBSZWFsLVRpbWUgRWNvbm9taWMgU3RyYXRlZ3kgR2FtZSAgTUlORSBHT0xEIC0gQlVJTEQgWU9VUiBXT1JMRCcsXG4gIHNob3J0RGVzY3JpcHRpb246ICdNYXNzaXZlIE11bHRpcGxheWVyIE9ubGluZSBSZWFsLVRpbWUgRWNvbm9taWMgU3RyYXRlZ3kgR2FtZScsXG4gIHN5bWJvbDogJycsXG4gIGFjY291bnRzOiBbJ3Byb3NwZWN0b3JzYyddLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvcHJvc3BlY3RvcnMucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vcHJvc3BlY3RvcnMuaW8nLFxuICBhcHA6ICdodHRwczovL3Byb3NwZWN0b3JzLmlvJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvcHJvc3BlY3RvcnNnYW1lJyxcbiAgbWVkaXVtOiAnaHR0cHM6Ly9tZWRpdW0uY29tL0Bwcm9zcGVjdG9yc2dhbWUnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9wcm9zcGVjdG9yc2dhbWUnLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vcHJvc3BlY3RvcnMvcHVibGljL2lzc3VlcycsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnQVBQSUNTJyxcbiAgZGVzY3JpcHRpb246ICdBUFBJQ1MgaXMgdGhlIG1vc3QgZW5nYWdlZCBzb2NpYWwgbWVkaWEgZEFwcCB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gZ2V0IHJld2FyZGVkIHdpdGggY3J5cHRvY3VycmVuY3kgZm9yIHlvdXIgc29jaWFsIG1lZGlhIGFjdGl2aXR5IGxpa2UgY3JlYXRpbmcgJiBjdXJhdGluZyBjb250ZW50LiBUaGUgbW9iaWxlIGludGVyZmFjZSBpcyBpbnR1aXRpdmUgdG8gdXNlIHdpdGhvdXQgYW55IHByaW9yIGJsb2NrY2hhaW4ga25vd2xlZGdlLiBHZXQgcmV3YXJkZWQgZm9yIHlvdXIgcGFzc2lvbiEnLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnQVBQSUNTIGlzIHRoZSBtb3N0IGVuZ2FnZWQgc29jaWFsIG1lZGlhIGRBcHAgLSBlYXJuIEFQWCBUb2tlbnMgZm9yIHBvc3RpbmcsIGNvbW1lbnRpbmcsIGFuZCB1cC12b3RpbmcgcGhvdG9zICYgdmlkZW9zIScsXG4gIHN5bWJvbDogJ0FQWCcsXG4gIHN0YXRpc3RpY3M6IHRydWUsXG4gIGFjY291bnRzOiBbJ2FwcGljc2FwcGljcyddLFxuICBsb2dvOiAnaHR0cHM6Ly9pLmltZ3VyLmNvbS9UczlDTk41LnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL2FwcGljcy5jb20nLFxuICBhcHA6ICdodHRwczovL2FwcGljcy5jb20nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9hcHBpY3Nfb2ZmaWNpYWwnLFxuICBtZWRpdW06ICdodHRwczovL21lZGl1bS5jb20vQGFwcGljcycsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL2FwcGljc19vZmZpY2lhbCcsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9waGVub20tY29tcGFueS9hcHBpY3NfZW9zX3Rva2VuJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdCb2lkJyxcbiAgZGVzY3JpcHRpb246ICdDb250cmlidXRlIHlvdXIgZXhjZXNzIGNvbXB1dGluZyByZXNvdXJjZXMgdG93YXJkcyBpbXBvcnRhbnQgY2F1c2VzIHdoaWxlIGVhcm5pbmcgcmV3YXJkcy4gSm9pbiBhIHRlYW0gYW5kIHJhbmsgdXAgb24gdGhlIHNvY2lhbCBsZWFkZXJib2FyZHMuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ1RoZSBTb2NpYWwgU3VwZXJjb21wdXRlci4gQ29udHJpYnV0ZSB5b3VyIGV4Y2VzcyBjb21wdXRpbmcgcmVzb3VyY2VzIHRvd2FyZHMgaW1wb3J0YW50IGNhdXNlcy4nLFxuICBzeW1ib2w6ICcnLFxuICBhY2NvdW50czogWydib2lkY29tdG9rZW4nLCAnYm9pZGNvbXBvd2VyJywgJ2JvaWRjb21taW50MScsICdib2lkY29tcHJvbW8nXSxcbiAgbG9nbzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ib2lkLWNvbS9hc3NldHMvbWFzdGVyL2JvaWRMb2dvLWxnLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL2JvaWQuY29tJyxcbiAgYXBwOiAnaHR0cHM6Ly9hcHAuYm9pZC5jb20nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9Cb2lkY29tX29mZmljaWFsJyxcbiAgbWVkaXVtOiAnaHR0cHM6Ly9tZWRpdW0uY29tL0Bib2lkY29tJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vYm9pZGNvbScsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9ib2lkLWNvbScsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnVGhlIEJpbGxpb25haXJlIFRva2VuJyxcbiAgZGVzY3JpcHRpb246ICdNb3N0IG90aGVyIGNvaW5zIG9yIHRva2VucyBoYXZlIHNvbWUgc29ydCBvZiBtaW5pbmcgc3lzdGVtLiBCaWxsaW9uYWlyZSBUb2tlbiBoYXMgdGhlIGV4YWN0IG9wcG9zaXRlOiBJdCBmZWF0dXJlcyBhIGRlZmxhdGlvbmFyeSBtZWNoYW5pc20gdGhhdCBkZXN0cm95cyAzMCUgb2YgdGhlIGdhbWJsZWQgY29pbnMuIFRodXMgdGhlIHRva2VucyBiZWNvbWUgbW9yZSBhbmQgbW9yZSByYXJlIGFzIG1vcmUgYW5kIG1vcmUgcGVvcGxlIGdhbWJsZS4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnQmlsbGlvbmFpcmUgVG9rZW4gaGFzIHRoZSBvcHBvc2l0ZSBvZiBhIG1pbmluZyBzeXN0ZW06IEl0IGZlYXR1cmVzIGEgZGVmbGF0aW9uYXJ5IG1lY2hhbmlzbSB0aGF0IGRlc3Ryb3lzIDMwJSBvZiB0aGUgZ2FtYmxlZCBjb2lucy4nLFxuICBzeW1ib2w6ICdYQkwnLFxuICBhY2NvdW50czogWydiaWxsaW9uYWlyZXQnLCAnYmlsbGlvbnJhZmZsJywgJ2JpbGxpb25idXJucicsICdiaWxsaW9uYm90MTEnLCAnYmlsbGlvbmJvdDEyJywgJ2JpbGxpb25ib3QxMycsICdiaWxsaW9uYm90MTQnXSxcbiAgYXBwOiAnaHR0cHM6Ly9CaWxsaW9uYWlyZVRva2VuLmNvbS8nLFxuICBsb2dvOiAnaHR0cHM6Ly9CaWxsaW9uYWlyZVRva2VuLmNvbS9pbWFnZXMvbG9nb19iaWcucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vQmlsbGlvbmFpcmVUb2tlbi5jb20vJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvQmlsbGlvbmFpcmVUb2tlbicsXG4gIG1lZGl1bTogJ2h0dHBzOi8vbWVkaXVtLmNvbS9AYmlsbGlvbmFpcmVfMzM3MycsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL0JpbGxpb25haXJlVGtuJyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL0JpbGxpb25haXJlVG9rZW4nLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ0NyeXB0byBTd29yZCAmIE1hZ2ljJyxcbiAgZGVzY3JpcHRpb246ICdDcnlwdG8gU3dvcmQgJiBNYWdpYyBpcyB0aGUgZmlyc3QgYmxvY2tidXN0ZXIgUlBHIG9uIEVPUyBibG9ja2NoYWluLCB0cmFkaXRpb25hbCB0dXJuLWJhc2VkIFJQRyByYWlzaW5nIGhlcm9lcyB0byBjaGFsbGVuZ2UgbmV3IGR1bmdlb25zLiBHYW1lIGFzc2V0cyBhcmUgcmVjb3JkZWQgb24gQmxvY2tjaGFpbiBhbmQgdHJhbnNhY3Rpb25zIHJ1biBvbiBzbWFydCBjb250cmFjdHMnLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnQ3J5cHRvIFN3b3JkICYgTWFnaWMgaXMgdGhlIGZpcnN0IGJsb2NrYnVzdGVyIFJQRyBvbiBFT1MgYmxvY2tjaGFpbi4nLFxuICBzeW1ib2w6ICdDU00nLFxuICBhY2NvdW50czogWydzd29yZG5tYWdpY20nXSxcbiAgYXBwOiAnaHR0cHM6Ly93d3cuY3J5cHRvc3dvcmRhbmRtYWdpYy5jb20nLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvY3J5cHRvc25tLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL3d3dy5jcnlwdG9zd29yZGFuZG1hZ2ljLmNvbScsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2NyeXB0b3NubV9jb21tX2VuJyxcbiAgbWVkaXVtOiAnaHR0cHM6Ly9tZWRpdW0uY29tL0BjcnlwdG9zd29yZGFuZG1hZ2ljJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vc3dvcmRfYW5kX21hZ2ljJyxcbiAgZ2l0aHViOiAnJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdkbWFpbCcsXG4gIGRlc2NyaXB0aW9uOiAnV2VsY29tZSB0byBkbWFpbCBCZXRhISBXZSBhcmUgc28gZXhjaXRlZCB0byBoYXZlIHlvdSBwYXJ0aWNpcGF0ZSBhcyB3ZSBsYXVuY2ggb3VyIEJldGEgcGxhdGZvcm0uIEluIHRoZSBlYXJseSBzdGFnZXMgd2UgYXJlIGNvdmVyaW5nIHRoZSBzaW1wbGVzdCBvZiBmdW5jdGlvbmFsaXR5LCB3aGljaCBpcyBzZW5kaW5nIGFuZCByZWNlaXZpbmcgbWVzc2FnZXMuIEluIHRoZSB2ZXJ5IG5lYXIgZnV0dXJlLCB3ZSB3aWxsIGJlIGFkZGluZyBhIGJ1bmNoIG9mIG5ldyBmZWF0dXJlcyB3aGljaCB3ZSBrbm93IHRoZSBjb21tdW5pdHkgaXMgZ29pbmcgdG8gYXNrIGZvci4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnZG1haWwgaXMgdGhlIGZpcnN0IGRlY2VudHJhbGl6ZWQgZW1haWwgb24gdGhlIGJsb2NrY2hhaW4nLFxuICBzeW1ib2w6ICdNQUlMJyxcbiAgc3RhdGlzdGljczogdHJ1ZSxcbiAgYWNjb3VudHM6IFsnZG1haWxkb3Rjb2JwJ10sXG4gIGxvZ286ICdodHRwczovL3d3dy5kbWFpbC5jby9sb2dvc3ltXzI1Ni5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9kbWFpbC5jbycsXG4gIGFwcDogJycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2RtYWlsY29tbXVuaXR5JyxcbiAgbWVkaXVtOiAnaHR0cHM6Ly9tZWRpdW0uY29tL0BkbWFpbCcsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL2RtYWlsZG90Y28nLFxuICBnaXRodWI6ICcnLFxuICBjaGFpbnM6IFsnZW9zJywgJ3RlbG9zJ11cbn0sIHtcbiAgbmFtZTogJ011cm11cicsXG4gIGRlc2NyaXB0aW9uOiAnTXVybXVyIGlzIGEgbmV3IGFnZSBkZWNlbnRyYWxpemVkIG1pY3JvYmxvZ2dpbmcgcGxhdGZvcm0gb24gRU9TIHRoYXQgaXMgY2Vuc29yc2hpcC1yZXNpc3RhbnQsIHNwYW0tcHJvb2YgYW5kIHJld2FyZGluZyB0byB1c2UuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ011cm11ciBpcyBhIG5ldyBhZ2UgZGVjZW50cmFsaXplZCBtaWNyb2Jsb2dnaW5nIHBsYXRmb3JtIG9uIEVPUyB0aGF0IGlzIGNlbnNvcnNoaXAtcmVzaXN0YW50LCBzcGFtLXByb29mIGFuZCByZXdhcmRpbmcgdG8gdXNlLicsXG4gIHN5bWJvbDogJ01VUicsXG4gIHBhcnRuZXI6IHRydWUsXG4gIGFjY291bnRzOiBbJ211cm11cmRhcHBjbycsICdtdXJtdXJ0b2tlbnMnLCAnbXVybXVyZnJlZWFjJ10sXG4gIGFwcDogJ2h0dHBzOi8vcGxheS5nb29nbGUuY29tL3N0b3JlL2FwcHMvZGV0YWlscz9pZD1jb20ubXVybXVyZGFwcCcsXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9tdXJtdXIucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHA6Ly9tdXJtdXJkYXBwLmNvbScsXG4gIHRlbGVncmFtOiAnaHR0cDovL3QubWUvbXVybXVyZGFwcCcsXG4gIG1lZGl1bTogJycsXG4gIHR3aXR0ZXI6ICdodHRwOi8vdHdpdHRlci5jb20vbXVybXVyZGFwcCcsXG4gIGdpdGh1YjogJycsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnRW1hbmF0ZScsXG4gIGRlc2NyaXB0aW9uOiAnRW1hbmF0ZSBpcyBFT1MgZm9yIHRoZSBtdXNpYyBpbmR1c3RyeS4gQW4gYXV0b21hdGVkLCByZWFsdGltZSBtdXNpYyBjb2xsYWJvcmF0aW9uIGFuZCBtb25ldGlzYXRpb24gcGxhdGZvcm0uJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ0VtYW5hdGUgaXMgZGVjZW50cmFsaXNlZCB0ZWNobm9sb2d5IGZvciB0aGUgZnV0dXJlIG9mIG11c2ljJyxcbiAgc3ltYm9sOiAnRU1UJyxcbiAgcGFydG5lcjogdHJ1ZSxcbiAgYWNjb3VudHM6IFsnZW1hbmF0ZW9uZW9zJywgJ2VtYW5hdGVpc3N1ZSddLFxuICBhcHA6ICdodHRwczovL2VtYW5hdGUubGl2ZS8nLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvZW1hbmF0ZS5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9lbWFuYXRlLmxpdmUnLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9lbWFuYXRlb2ZmaWNpYWwnLFxuICBtZWRpdW06ICcnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9lbWFuYXRlb2ZmaWNpYWwnLFxuICBnaXRodWI6ICcnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ3BpeEVPUycsXG4gIGRlc2NyaXB0aW9uOiAncGl4RU9TIGlzIHRoZSBmaXJzdCB0b2tlbml6ZWQgc21hcnQgZWNvbm9teSBmb3IgZ2FtZXJzLCBhcnRpc3RzIGFuZCBhcnQgZW50aHVzaWFzdHMuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ3BpeEVPUyBpcyB0aGUgZmlyc3QgdG9rZW5pemVkIHNtYXJ0IGVjb25vbXkgZm9yIGdhbWVycywgYXJ0aXN0cyBhbmQgYXJ0IGVudGh1c2lhc3RzLicsXG4gIHN5bWJvbDogJ1BJWEVPUycsXG4gIHBhcnRuZXI6IHRydWUsXG4gIGFjY291bnRzOiBbJ3BpeGVvczF0b2tlbicsICdwaXhlb3MxYWRtaW4nLCAncGl4ZW9zMXN0YXJ0J10sXG4gIGFwcDogJ2h0dHBzOi8vcGl4ZW9zLmlvJyxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL3BpeGVvcy5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9waXhlb3MuaW8nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9QSVhFT1MnLFxuICBtZWRpdW06ICcnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9lb3NfcGl4JyxcbiAgZ2l0aHViOiAnJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdFdmVyaXBlZGlhJyxcbiAgZGVzY3JpcHRpb246ICdUaGUgRXZlcmlwZWRpYSB0ZWFtIHBsYW5zIHRvIGJ1aWxkIGEgbW9kZXJuLCBjb252ZW5pZW50IGFuZCBkZWNlbnRyYWxpemVkIG5ldyBlbmN5Y2xvcGVkaWEgd2Vic2l0ZSwgYW5kIHRoaXMgZ29hbCB3aWxsIGJlIHJlYWxpemVkIHdpdGggdGhlIGRldmVsb3BtZW50IG9mIGJsb2NrY2hhaW4gdGVjaG5vbG9neS4gVGhlIG5ldyB2ZXJzaW9uIG9mIEV2ZXJpcGVkaWEgdW5kZXIgZGV2ZWxvcG1lbnQgd2lsbCBiZSBiYXNlZCBvbiB0aGUgRU9TIG5ldHdvcmssIHdoaWNoIHdpbGwgaGF2ZSBmZWF0dXJlcyBzdWNoIGFzIGNvbW11bml0eSBhdXRvbm9teSwgc2hpZWxkaW5nIHByZXZlbnRhdGlvbiwgYW5kIGNvbnRyaWJ1dGlvbiBpbmNlbnRpdmVzIGNvbXBhcmVkIHRvIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXZlcmlwZWRpYS4gRm91bmRlZCBpbiAyMDE0LCB0aGUgYnVzaW5lc3MgbmV0d29yayBlbmN5Y2xvcGVkaWEgRXZlcmlwZWRpYSwgd2hvc2UgbmFtZSBkZXJpdmVzIGZyb20gdGhlIEVuZ2xpc2ggd29yZHMgRXZlcnl0aGluZyBhbmQgRW5jeWNsb3BlZGlhLCBpcyBvd25lZCBieSBFdmVyaXBlZGlhLkluYyBhbmQgaGFzIG5vdCB5ZXQgYWRvcHRlZCBibG9ja2NoYWluIHRlY2hub2xvZ3kuIEFzIG9mIERlY2VtYmVyIDIwMTcsIEV2ZXJpcGVkaWEgaXMgdGhlIGxhcmdlc3QgRW5nbGlzaCBlbmN5Y2xvcGVkaWEgd2l0aCBtb3JlIHRoYW4gc2l4IG1pbGxpb24gZW50cmllcywgaW5jbHVkaW5nIGFsbCBFbmdsaXNoIGVudHJpZXMgb2YgV2lraXBlZGlhLiBFdmVyaXBlZGlhcyByZXF1aXJlbWVudHMgZm9yIGF0dGVudGlvbiBhcmUgbW9yZSByZWxheGVkLCBzbyBpdCBoYXMgbW9yZSBlbnRyaWVzIHRoYW4gV2lraXBlZGlhLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdUaGUgRXZlcmlwZWRpYSB0ZWFtIHBsYW5zIHRvIGJ1aWxkIGEgbW9kZXJuLCBjb252ZW5pZW50IGFuZCBkZWNlbnRyYWxpemVkIG5ldyBlbmN5Y2xvcGVkaWEuJyxcbiAgc3ltYm9sOiAnSVEnLFxuICBwYXJ0bmVyOiB0cnVlLFxuICBzdGF0aXN0aWNzOiBmYWxzZSxcbiAgYWNjb3VudHM6IFsnZXZlcmlwZWRpYWlxJywgJ2VwYXJ0aWNsZWN0ciddLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvZXZlcmlwZWRpYS5qcGcnLFxuICB3ZWJzaXRlOiAnJyxcbiAgYXBwOiAnaHR0cHM6Ly9ldmVyaXBlZGlhLm9yZycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2V2ZXJpcGVkaWEnLFxuICBtZWRpdW06ICcnLFxuICB0d2l0dGVyOiAnJyxcbiAgZ2l0aHViOiAnJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdlb3NEQUMnLFxuICBkZXNjcmlwdGlvbjogJ2Vvc0RBQyBpcyBhIENvbW11bml0eSBPd25lZCBCbG9ja3Byb2R1Y2VyIGFuZCBhIERBQyBlbmFibGVyLCBib3JuIG91dCBvZiBEYW4gTGFyaW1lcnMgY29uY2VwdCBvZiBEZWNlbnRyYWxpemVkIEF1dG9ub21vdXMgQ29tbXVuaXRpZXMgb3IgREFDcywgYXJvdW5kIHdoaWNoIEJsb2NrLm9uZSBkZXZlbG9wZWQgRU9TIHNvZnR3YXJlLiAgVGhlIHZpc2lvbiBvZiBlb3NEQUMgaXMgdGhhdCBFT1MuSU8gYmxvY2sgcHJvZHVjdGlvbiBzaG91bGQgYmUgb3BlbiBmb3IgZXZlcnlvbmUgdG8gY29udHJpYnV0ZSBhbmQgYmVuZWZpdC4gVG8gcmVhbGl6ZSB0aGlzIHZpc2lvbiwgZW9zREFDIGlzIGFuIGV2b2x2aW5nIERlY2VudHJhbGlzZWQgQXV0b25vbW91cyBDb21tdW5pdHkgKERBQykgZm9jdXNlZCBvbiBFT1MuSU8gQmxvY2sgUHJvZHVjdGlvbiBzZXJ2aW5nIHRoZSBFT1MgY29tbXVuaXRpZXMgd29ybGR3aWRlLiBJbiBkb2luZyB0aGlzLCBlb3NEQUMgaXMgY3JlYXRpbmcgdGhlIHRvb2xzIGFuZCBzbWFydCBjb250cmFjdHMgaXQgbmVlZHMgdG8gZnVuY3Rpb24uIEl0IHdpbGwgc2hhcmUgdGhlc2Ugd2l0aCB0aGUgRU9TIGNvbW11bml0aWVzIHRvIGhlbHAgb3RoZXIgREFDcyB0aHJpdmUgb24gdGhlIEVPUy5JTyBibG9ja2NoYWlucy4gIEluIG9yZGVyIHRvIGZ1bmN0aW9uIGFzIGEgREFDLCBlb3NEQUMgaXMgY3JlYXRpbmcgb3BlbiBzb3VyY2UgdG9vbHMgYW5kIHdpbGwgYmUgc2hhcmluZyB0aGVtIGFzIGEgREFDIFRvb2xraXQsIHRoYXQgYW55b25lIGNhbiB1c2UsIG1vZGlmeSB0byBzZXR1cCBhbmQgcnVuIGEgREFDLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdlb3NEQUMgaXMgY3JlYXRpbmcgb3BlbiBzb3VyY2UgdG9vbHMgYW5kIHdpbGwgYmUgc2hhcmluZyB0aGVtIGFzIGEgREFDIFRvb2xraXQgdG8gZW5hYmxlIERBQ3MnLFxuICBzeW1ib2w6ICdFT1NEQUMnLFxuICBwYXJ0bmVyOiBmYWxzZSxcbiAgc3RhdGlzdGljczogZmFsc2UsXG4gIGFjY291bnRzOiBbJ2Vvc2RhY3Rva2VucycsICdlb3NkYWNzZXJ2ZXInLCAnZW9zZGFjdGhlZGFjJywgJ2RhY2N1c3RvZGlhbiddLFxuICBsb2dvOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Vvc2NhZmUvZW9zLWRhcHBzL21hc3Rlci9sb2dvcy9lb3NkYWMucG5nJyxcbiAgd2Vic2l0ZTogJycsXG4gIGFwcDogJ21lbWJlcnMuZW9zZGFjLmlvJyxcbiAgZGlzY29yZDogJ2h0dHBzOi8vZGlzY29yZC5pby9lb3NkYWMnLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9lb3NkYWNpbycsXG4gIG1lZGl1bTogJycsXG4gIHR3aXR0ZXI6ICcnLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vZW9zZGFjJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdERU9TIEdhbWVzJyxcbiAgZGVzY3JpcHRpb246ICdEZW9zIEdhbWVzIGFyZSBjYXNpbm8gZ2FtZXMgYnVpbHQgb24gRU9TIGJsb2NrY2hhaW4uIFBsYXkgemVybyBlZGdlIGdhbWVzIHdpdGggb3VyIERFT1MgdG9rZW4gYW5kIHBhcnRpY2lwYXRlIGluIGJhbmtyb2xsIHN0YWtpbmcuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ0Rlb3MgR2FtZXMgYXJlIGNhc2lubyBnYW1lcyBidWlsdCBvbiB0aGUgRU9TIGJsb2NrY2hhaW4uIFBsYXkgemVybyBlZGdlIGdhbWVzIHdpdGggREVPUyB0b2tlbi4nLFxuICBzeW1ib2w6ICdERU9TJyxcbiAgc3RhdGlzdGljczogZmFsc2UsXG4gIGFjY291bnRzOiBbJ3RoZWRlb3NnYW1lcycsICdkZW9zZ2FtZWlzc3UnXSxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL2Rlb3NnYW1lcy5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9kZW9zZ2FtZXMuY29tJyxcbiAgYXBwOiAnaHR0cHM6Ly9hcHAuZGVvc2dhbWVzLmNvbScsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2Rlb3NnYW1lc2NoYXQnLFxuICBtZWRpdW06ICdodHRwczovL21lZGl1bS5jb20vZGVvcy1nYW1lcycsXG4gIHR3aXR0ZXI6ICcnLFxuICBnaXRodWI6ICcnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ0NoaW50YWknLFxuICBkZXNjcmlwdGlvbjogJ0NoaW50YWkgaXMgYSBjb21tdW5pdHktb3duZWQsIGZlZWxlc3MsIDEwMCUgb24tY2hhaW4sIG11bHRpc2lnIGRlY2VudHJhbGl6ZWQgdG9rZW4gbGVhc2luZyBwbGF0Zm9ybSB3aGVyZSB1c2VycyBjYW4gbGVuZCB0aGVpciBFT1Mgb24gdGhlIG1hcmtldCB0byBlYXJuIGludGVyZXN0IGZyb20gb3RoZXIgdXNlcnMgdG8gYm9ycm93IHdobyBuZWVkIGFjY2VzcyB0byBDUFUvTkVUIGJhbmR3aWR0aC4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnQ2hpbnRhaSBpcyBhIGNvbW11bml0eS1vd25lZCwgZmVlbGVzcywgMTAwJSBvbi1jaGFpbiwgbXVsdGlzaWcgZGVjZW50cmFsaXplZCB0b2tlbiBsZWFzaW5nIHBsYXRmb3JtLicsXG4gIHN5bWJvbDogJycsXG4gIHN0YXRpc3RpY3M6IGZhbHNlLFxuICBhY2NvdW50czogWydjaGludGFpbGVhc2UnLCAnY2hpbnRhaXByb3h5JywgJ2JpZGNoZXh0b2tlbicsICdjaGV4Y2hleGNoZXgnXSxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL2NoaW50YWkucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHA6Ly9jaGludGFpLmlvJyxcbiAgYXBwOiAnaHR0cHM6Ly9lb3MuY2hpbnRhaS5pby9leGNoYW5nZS9FT1MyOEQnLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9DaGludGFpRU9TJyxcbiAgbWVkaXVtOiAnaHR0cHM6Ly9tZWRpdW0uY29tL0BDaGludGFpRU9TJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vY2hpbnRhaWVvcycsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9jaGludGFpLXBsYXRmb3JtJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdOZXdkZXgnLFxuICBkZXNjcmlwdGlvbjogJ05ld2RleCBpcyB0aGUgZmlyc3QgRU9TIGJhc2VkIGRlY2VudHJhbGl6ZWQgZXhjaGFuZ2UgaW4gdGhlIHdvcmxkLCB1cGhvbGRpbmcgdGhlIGNoYXJhY3RlcmlzdGljcyBvZiBzYWZlLCBmYXN0IGFuZCB0cmFuc3BhcmVudCwgZGV2b3RpbmcgdG8gY3JlYXRlIGEgbmV3LWdlbmVyYXRpb24gcGxhdGZvcm0gZm9yIGRpZ2l0YWwgYXNzZXRzIGV4Y2hhbmdlLCBsZWFkaW5nIHRoZSBpbmR1c3RyeSBpbnRvIGFuIGlkZWFsIG5ldyBlcmEuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ05ld2RleCBpcyB0aGUgZmlyc3QgRU9TIGJhc2VkIGRlY2VudHJhbGl6ZWQgZXhjaGFuZ2UgaW4gdGhlIHdvcmxkLicsXG4gIHN5bWJvbDogJycsXG4gIGFjY291bnRzOiBbJ25ld2RleHBvY2tldCddLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvbmV3ZGV4LnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL25ld2RleC5pbycsXG4gIGFwcDogJ2h0dHBzOi8vbmV3ZGV4LmlvJyxcbiAgdGVsZWdyYW06ICcnLFxuICBtZWRpdW06ICcnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9OZXdkZXhPZmZpY2lhbCcsXG4gIGdpdGh1YjogJycsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnRU9TIE5hbWUgU3dhcHMnLFxuICBkZXNjcmlwdGlvbjogJ0FuIG9wZW4tc291cmNlIEVPUyBhY2NvdW50IGV4Y2hhbmdlIHRoYXQgcHV0cyB0aGUgc2VjdXJpdHkgb2YgaXRzIHVzZXJzIGZpcnN0LicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdBbiBvcGVuLXNvdXJjZSBFT1MgYWNjb3VudCBleGNoYW5nZSB0aGF0IHB1dHMgdGhlIHNlY3VyaXR5IG9mIGl0cyB1c2VycyBmaXJzdC4nLFxuICBzeW1ib2w6ICcnLFxuICBzdGF0aXN0aWNzOiBmYWxzZSxcbiAgYWNjb3VudHM6IFsnZW9zbmFtZXN3YXBzJ10sXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9lb3NuYW1lc3dhcHMucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vd3d3LmVvc25hbWVzd2Fwcy5jb20vJyxcbiAgYXBwOiAnaHR0cHM6Ly93d3cuZW9zbmFtZXN3YXBzLmNvbS8nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9lb3NuYW1lc3dhcHMnLFxuICBtZWRpdW06ICcnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9TdGFycnkzMDE3TmlnaHQnLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vU3RhcnJ5SmFwYW5OaWdodC9lb3NuYW1lc3dhcHMnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn1dO1xuXG52YXIgZXhjaGFuZ2VzID0ge1xuICAnQml0aHVtYic6IHtcbiAgICAnbmFtZSc6ICdCaXRodW1iJyxcbiAgICAnZGVzY3JpcHRpb24nOiAn67mE7Yq47L2U7J24LCDsnbTrjZTrpqzsm4AsIOu5hO2KuOy9lOyduOy6kOyLnCwg66as7ZSMLCDrnbzsnbTtirjsvZTsnbgsIOuMgOyLnCwg66qo64Sk66GcLCDruYTtirjsvZTsnbjqs6jrk5wsIOydtOyYpOyKpCwg7J20642U66as7JuA7YG0656Y7IudLCDtgIDthYAsIOygnO2KuOy6kOyLnCwg7Iuk7Iuc6rCEIOyLnOyEuCwg7Im96rOgIOyViOyghO2VnCDqsbDrnpguJyxcbiAgICAnYWNjb3VudHMnOiBbJ2JpdGh1bWJzaGlueSddLFxuICAgICdsb2dvJzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lb3NjYWZlL2Vvcy1kYXBwcy9tYXN0ZXIvbG9nb3MvcGxhY2Vob2xkZXIucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL3d3dy5iaXRodW1iLmNvbS8nXG4gIH0sXG4gICdPS0V4Jzoge1xuICAgICduYW1lJzogJ09LRXgnLFxuICAgICdkZXNjcmlwdGlvbic6ICdPS0V4IGlzIHRoZSBsZWFkaW5nIGdsb2JhbCBiaXRjb2luIGV4Y2hhbmdlLiBTZWN1cmVkIHdpdGggYmFuay1sZXZlbCBTU0wgZW5jcnlwdGlvbiBhbmQgY29sZCBzdG9yYWdlLicsXG4gICAgJ2FjY291bnRzJzogWydva2V4b2ZmaWxpbmUnXSxcbiAgICAnbG9nbyc6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZW9zY2FmZS9lb3MtZGFwcHMvbWFzdGVyL2xvZ29zL3BsYWNlaG9sZGVyLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly93d3cub2tleC5jb20vJ1xuICB9LFxuICAnQml0ZmluZXgnOiB7XG4gICAgJ25hbWUnOiAnQml0ZmluZXgnLFxuICAgICdkZXNjcmlwdGlvbic6ICdCaXRmaW5leCBpcyBhIGZ1bGwtZmVhdHVyZWQgc3BvdCB0cmFkaW5nIHBsYXRmb3JtIGZvciBtYWpvciBkaWdpdGFsIGFzc2V0cyAmIGNyeXB0b2N1cnJlbmNpZXMsIGluY2x1ZGluZyBCaXRjb2luLCBFdGhlcmV1bSwgRU9TLCBMaXRlY29pbiwgUmlwcGxlLCBORU8sIE1vbmVybyBhbmQgbWFueSBtb3JlLicsXG4gICAgJ2FjY291bnRzJzogWydiaXRmaW5leGN3NTUnLCAnYml0ZmluZXhjdzEzJywgJ2JpdGZpbmV4Y3cxMScsICdiaXRmaW5leGN3MjQnLCAnYml0ZmluZXhjdzE1JywgJ2JpdGZpbmV4Y3czMicsICdiaXRmaW5leGN3MjEnLCAnYml0ZmluZXhjdzMxJywgJ2JpdGZpbmV4Y3cyNScsICdiaXRmaW5leGN3MjMnLCAnYml0ZmluZXhjdzMzJywgJ2JpdGZpbmV4Y3cyMicsICdiaXRmaW5leGN3MTInLCAnYml0ZmluZXhjdzE0J10sXG4gICAgJ2xvZ28nOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Vvc2NhZmUvZW9zLWRhcHBzL21hc3Rlci9sb2dvcy9wbGFjZWhvbGRlci5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vYml0ZmluZXguY29tLydcbiAgfSxcbiAgJ0dhdGUuaW8nOiB7XG4gICAgJ25hbWUnOiAnR2F0ZS5pbycsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0dhdGUuaW8gaXMgYSBiaXRjb2luIGV4Y2hhbmdlIHBsYXRmb3JtIHdoaWNoIHN1cHBvcnRzIEJUQywgTFRDLCBFdGhlcmV1bSwgUXR1bSBhbmQgbW9yZSBibG9ja2NoYWluIGFzc2V0cyB0cmFkaW5nLicsXG4gICAgJ2FjY291bnRzJzogWydnYXRlaW93YWxsZXQnXSxcbiAgICAnbG9nbyc6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZW9zY2FmZS9lb3MtZGFwcHMvbWFzdGVyL2xvZ29zL3BsYWNlaG9sZGVyLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly93d3cuZ2F0ZS5pby8nXG4gIH0sXG4gICdLcmFrZW4nOiB7XG4gICAgJ25hbWUnOiAnS3Jha2VuJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnQnV5LCBzZWxsIGFuZCBtYXJnaW4gdHJhZGUgQml0Y29pbiAoQlRDKSBhbmQgRXRoZXJ1bSAoRVRIKSBpbiBleGNoYW5nZSB3aXRoIEVVUiwgVVNELCBDQUQsIEdCUCwgYW5kIEpQWS4nLFxuICAgICdhY2NvdW50cyc6IFsna3Jha2Vua3Jha2VuJ10sXG4gICAgJ2xvZ28nOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Vvc2NhZmUvZW9zLWRhcHBzL21hc3Rlci9sb2dvcy9wbGFjZWhvbGRlci5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vd3d3LmtyYWtlbi5jb20vJ1xuICB9LFxuICAnTmV3ZGV4Jzoge1xuICAgICduYW1lJzogJ05ld2RleCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ1RoZSBmaXJzdCBFT1MgYmFzZWQgZGVjZW50cmFsaXplZCBleGNoYW5nZSBpbiB0aGUgd29ybGQuJyxcbiAgICAnYWNjb3VudHMnOiBbJ25ld2RleHBvY2tldCddLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL25ld2RleC5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vbmV3ZGV4LmlvLycsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcih0b2tlbiwgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9uZXdkZXguaW8vdHJhZGUvXCIgKyB0b2tlbi5hY2NvdW50ICsgXCItXCIgKyBwYWlyLnBhaXJfYmFzZS50b0xvd2VyQ2FzZSgpICsgXCItXCIgKyBwYWlyLnBhaXJfcXVvdGUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0sXG4gICdEZWZpQm94Jzoge1xuICAgICduYW1lJzogJ0RlZmlCb3gnLFxuICAgICdkZXNjcmlwdGlvbic6ICdPbmUtc3RvcCBEZUZpIGFwcGxpY2F0aW9uIHBsYXRmb3JtIG9uIEVPUy4uJyxcbiAgICAnYWNjb3VudHMnOiBbJ3Rva2VuLmRlZmknLCAnc3dhcC5kZWZpJ10sXG4gICAgJ2xvZ28nOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Vvc2NhZmUvZW9zLWFpcmRyb3BzL21hc3Rlci9sb2dvcy90b2tlbi5kZWZpLWJveC5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vZGVmaWJveC5pby8nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgX18pIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vZGVmaWJveC5pby9cIjtcbiAgICB9XG4gIH0sXG4gICdDaGFpbmNlJzoge1xuICAgICduYW1lJzogJ0NoYWluY2UnLFxuICAgICdkZXNjcmlwdGlvbic6ICdBIFN1cGVyaW9yIEJsb2NrY2hhaW4gQXNzZXQgVHJhZGluZyBQbGF0Zm9ybSBGb2N1c2luZyBvbiBFT1MgUHJvamVjdHMnLFxuICAgICdhY2NvdW50cyc6IFsnY2hhaW5jZW9uZW9zJ10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvY2hhaW5jZS5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vY2hhaW5jZS5jb20vJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vY2hhaW5jZS5jb20vdHJhZGUvXCIgKyBwYWlyLnBhaXJfYmFzZS50b0xvd2VyQ2FzZSgpICsgcGFpci5wYWlyX3F1b3RlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuICAnRGV4ZW9zJzoge1xuICAgICduYW1lJzogJ0RleGVvcycsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ1RoZSBXb3JsZFxcJ3MgRmlyc3QgRU9TLWJhc2VkIERlY2VudHJhbGl6ZWQgRXhjaGFuZ2UnLFxuICAgICdhY2NvdW50cyc6IFsnZGV4ZW9zd2FsbGV0J10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvZGV4ZW9zLnN2ZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9kZXhlb3MuaW8vJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vZGV4ZW9zLmlvL3RyYWRlL1wiICsgcGFpci5wYWlyX2Jhc2UudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH0sXG4gICdIb28nOiB7XG4gICAgJ25hbWUnOiAnSG9vJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnT25lLXN0b3AgYmxvY2tjaGFpbiBhc3NldCBzZXJ2aWNlIHBsYXRmb3JtJyxcbiAgICAnYWNjb3VudHMnOiBbJ2hvby5jb20nXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9ob28uanBnJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2hvby5jb20vJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vaG9vLmNvbS90cmFkZS9cIiArIHBhaXIucGFpcl9iYXNlLnRvTG93ZXJDYXNlKCkgKyBcIi1cIiArIHBhaXIucGFpcl9xdW90ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSxcbiAgJ1doYWxlZXgnOiB7XG4gICAgJ25hbWUnOiAnV2hhbGVleCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJyMxIERlY2VudHJhbGl6ZWQgRXhjaGFuZ2UgaW4gdGhlIFdvcmxkJyxcbiAgICAnYWNjb3VudHMnOiBbJ3doYWxlZXh0cnVzdCddLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL3doYWxlZXgucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL3d3dy53aGFsZWV4LmNvbScsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL3d3dy53aGFsZWV4LmNvbS90cmFkZS9cIiArIHBhaXIucGFpcl9iYXNlICsgXCJfXCIgKyBwYWlyLnBhaXJfcXVvdGU7XG4gICAgfVxuICB9LFxuICAnQ2hhaW5yaWZ0Jzoge1xuICAgICduYW1lJzogJ0NoYWlucmlmdCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0EgbWFya2V0cGxhY2UgZm9yIGRpZ2l0YWwgY3VycmVuY2llcycsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvY2hhaW5yaWZ0LnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly93d3cuY2hhaW5yaWZ0LmNvbS8nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly93d3cuY2hhaW5yaWZ0LmNvbS90cmFkaW5nP2NvaW5wYWlyPVwiICsgcGFpci5wYWlyX2Jhc2UgKyBcIi9cIiArIHBhaXIucGFpcl9xdW90ZTtcbiAgICB9XG4gIH0sXG4gICdFb3NkYXEnOiB7XG4gICAgJ25hbWUnOiAnRU9TREFRJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnQSBTdGFuZGFyZCBvZiBPbi1DaGFpbiBERVgnLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2Vvc2RhcS5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vd3d3LmVvc2RhcS5jb20vJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vZW9zZGFxLmNvbS9leGNoYW5nZS9cIiArIHBhaXIucGFpcl9iYXNlICsgXCJfXCIgKyBwYWlyLnBhaXJfcXVvdGU7XG4gICAgfVxuICB9LFxuICAnQmlnT05FJzoge1xuICAgICduYW1lJzogJ0JpZ09ORScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0EgU3RhbmRhcmQgb2YgT24tQ2hhaW4gREVYJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9iaWdPTkUuanBnJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2JpZy5vbmUnLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9iaWcub25lL3RyYWRlL1wiICsgcGFpci5wYWlyX2Jhc2UgKyBcIi1cIiArIHBhaXIucGFpcl9xdW90ZTtcbiAgICB9XG4gIH0sXG4gICdZT0xPJzoge1xuICAgICduYW1lJzogJ1lPTE8nLFxuICAgICdkZXNjcmlwdGlvbic6ICdJbnN0YW50IFRva2VuIFN3YXBzIG9uIEVPUycsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMveW9sby5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8veW9sb3N3YXAuY29tJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8veW9sb3N3YXAuY29tL3N3YXAvXCIgKyBwYWlyLnBhaXJfcXVvdGUudG9Mb3dlckNhc2UoKSArIFwiLVwiICsgcGFpci5wYWlyX2Jhc2UudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0sXG4gICdCYW5jb3InOiB7XG4gICAgJ25hbWUnOiAnQmFuY29yJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnSW5zdGFudCBMaXF1aWRpdHkuJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9iYW5jb3IucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2JhbmNvci5uZXR3b3JrJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vd3d3LmJhbmNvci5uZXR3b3JrL3Rva2VuL1wiICsgcGFpci5wYWlyX2Jhc2U7XG4gICAgfVxuICB9LFxuICAnQWxjb3InOiB7XG4gICAgJ25hbWUnOiAnQWxjb3InLFxuICAgICdkZXNjcmlwdGlvbic6ICdUaGUgZmlyc3Qgc2VsZi1saXN0aW5nIGRlY2VudHJhbGl6ZWQgZXhjaGFuZ2UnLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2FsY29yLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9hbGNvci5leGNoYW5nZScsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBfXykge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly93d3cuYWxjb3IuZXhjaGFuZ2UvbWFya2V0c1wiO1xuICAgIH1cbiAgfSxcbiAgJ0RlZmlzLk5ldHdvcmsnOiB7XG4gICAgJ25hbWUnOiAnRGVmaXMuTmV0d29yaycsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0FuIG9wZW4gZmluYW5jZSBuZXR3b3JrIHRoYXQgaW50ZWdyYXRlcyBhIHNlcmllcyBvZiBEZUZpIHByb3RvY29scycsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvZGVmaXMtdW5jYWNoZS5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vZGVmaXMubmV0d29yaycsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBfXykge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9hcHBzLmRlZmlzLm5ldHdvcmsvXCI7XG4gICAgfVxuICB9LFxuICAnRG9scGhpblN3YXAnOiB7XG4gICAgJ25hbWUnOiAnRG9scGhpblN3YXAnLFxuICAgICdkZXNjcmlwdGlvbic6ICdEb2xwaGluU3dhcCcsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvZG9scGhpbnN3YXAucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2RvbHBoaW5zd2FwLmlvL2V4Y2hhbmdlJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIF9fKSB7XG4gICAgICByZXR1cm4gJ2h0dHBzOi8vZG9scGhpbnN3YXAuaW8vZXhjaGFuZ2UnO1xuICAgIH1cbiAgfSxcbiAgJ1Byb3Rvbic6IHtcbiAgICAnbmFtZSc6ICdQcm90b25Td2FwJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnUHJvdG9uU3dhcCcsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvcHJvdG9uc3dhcC5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vcHJvdG9uc3dhcC5jb20nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgX18pIHtcbiAgICAgIHJldHVybiAnaHR0cHM6Ly9wcm90b25zd2FwLmNvbSc7XG4gICAgfVxuICB9LFxuICAnQ29pbmdlY2tvJzoge1xuICAgICduYW1lJzogJ0NvaW5HZWNrbycsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0NvaW5HZWNrbycsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvY29pbmdlY2tvLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9jb2luZ2Vja28uY29tJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIF9fKSB7XG4gICAgICByZXR1cm4gJ2h0dHBzOi8vY29pbmdlY2tvLmNvbSc7XG4gICAgfVxuICB9XG59O1xuXG52YXIgU0NBVFRFUl9ERVNLVE9QID0gJ1NjYXR0ZXJTb2NrZXRzJztcbnZhciBTQ0FUVEVSX0RFU0tUT1BfTUFOVUFMID0gJ1NjYXR0ZXJTb2NrZXRzTWFudWFsJztcbnZhciBTQ0FUVEVSX0VYVEVOU0lPTiA9ICdTY2F0dGVyRXh0ZW5zaW9uJztcbnZhciBMRURHRVIgPSAnbGVkZ2VyJztcbnZhciBMRURHRVJfVVNCID0gJ1RyYW5zcG9ydFUyRic7XG52YXIgTEVER0VSX0JMRSA9ICdUcmFuc3BvcnRXZWJCTEUnO1xudmFyIExFREdFUl9XRUJVU0IgPSAnVHJhbnNwb3J0V2VidXNiJztcbnZhciBMRURHRVJfV0VCSElEID0gJ1RyYW5zcG9ydFdlYkhJRCc7XG52YXIgTFlOWCA9ICdseW54JztcbnZhciBQUk9UT04gPSAncHJvdG9uJztcbnZhciBQUk9UT05fV0VCID0gJ3Byb3RvbndlYic7XG52YXIgQU5DSE9SID0gJ2FuY2hvcic7XG52YXIgU0lNUExFT1MgPSAnc2ltcGxlb3MnO1xudmFyIEVPU0FVVEggPSAnZW9zYXV0aCc7XG52YXIgQ0xFT1MgPSAnY2xlb3MnO1xudmFyIEVPU0MgPSAnZW9zYyc7XG52YXIgQ0xJTyA9ICdjbGlvJztcbnZhciBLRVlDQVQgPSAna2V5Y2F0JztcbnZhciBUUkVaT1IgPSAndHJlem9yJztcbnZhciBTUVJMID0gJ3NxcmwnO1xudmFyIFdPTUJBVCA9ICd3b21iYXQnO1xudmFyIFdBWF9DTE9VRF9XQUxMRVQgPSAnV2F4Q1cnO1xuXG52YXIgaGlzdG9yeVR5cGVzRmVhdHVyZXMgPSB7XG4gIFwibmF0aXZlXCI6IHtcbiAgICBuYW1lOiAnbmF0aXZlJyxcbiAgICBhY3Rpb25GaWx0ZXI6IGZhbHNlLFxuICAgIHRva2VuRmlsdGVyOiBmYWxzZSxcbiAgICBkYXRlRmlsdGVyOiBmYWxzZSxcbiAgICBjb250cmFjdEFjdGlvbkZpbHRlcjogZmFsc2UsXG4gICAgdG90YWw6IDBcbiAgfSxcbiAgZGZ1c2U6IHtcbiAgICBuYW1lOiAnZGZ1c2UnLFxuICAgIGFjdGlvbkZpbHRlcjogdHJ1ZSxcbiAgICB0b2tlbkZpbHRlcjogdHJ1ZSxcbiAgICBkYXRlRmlsdGVyOiB0cnVlLFxuICAgIGNvbnRyYWN0QWN0aW9uRmlsdGVyOiB0cnVlLFxuICAgIHRvdGFsOiA0XG4gIH0sXG4gIGh5cGVyaW9uOiB7XG4gICAgbmFtZTogJ2h5cGVyaW9uJyxcbiAgICBhY3Rpb25GaWx0ZXI6IHRydWUsXG4gICAgdG9rZW5GaWx0ZXI6IHRydWUsXG4gICAgZGF0ZUZpbHRlcjogdHJ1ZSxcbiAgICBjb250cmFjdEFjdGlvbkZpbHRlcjogdHJ1ZSxcbiAgICB0b3RhbDogM1xuICB9XG59O1xuXG52YXIgX2NoYWluSW5mbztcblxudmFyIGNoYWluSW5mbyA9IChfY2hhaW5JbmZvID0ge30sIF9jaGFpbkluZm9bJ3Byb3Rvbi10ZXN0J10gPSB7XG4gIGtleTogJ3Byb3Rvbi10ZXN0JyxcbiAgdGV4dDogJ1Byb3RvbiBUZXN0bmV0JyxcbiAgdmFsdWU6ICdodHRwczovL3Rlc3RuZXQucHJvdG9uc2Nhbi5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMvcHJvdG9uLnBuZycsXG4gIHRlc3RuZXQ6IHRydWVcbn0sIF9jaGFpbkluZm8ubG9jYWwgPSB7XG4gIGtleTogJ2xvY2FsJyxcbiAgdGV4dDogJ0xvY2FsIFRlc3RuZXQnLFxuICB2YWx1ZTogJ2h0dHBzOi8vbG9jYWwuYmxva3MuaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL2xvY2FsLnBuZycsXG4gIHRlc3RuZXQ6IHRydWVcbn0sIF9jaGFpbkluZm9bJ3dheC10ZXN0J10gPSB7XG4gIGtleTogJ3dheC10ZXN0JyxcbiAgdGV4dDogJ1dBWCBUZXN0bmV0JyxcbiAgdmFsdWU6ICdodHRwczovL3dheC10ZXN0LmJsb2tzLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy93YXgucG5nJyxcbiAgdGVzdG5ldDogdHJ1ZVxufSwgX2NoYWluSW5mb1snZmlvLXRlc3QnXSA9IHtcbiAga2V5OiAnZmlvLXRlc3QnLFxuICB0ZXh0OiAnRklPIFRlc3RuZXQnLFxuICB2YWx1ZTogJ2h0dHBzOi8vZmlvLXRlc3QuYmxva3MuaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL2Zpby5wbmcnLFxuICB0ZXN0bmV0OiB0cnVlXG59LCBfY2hhaW5JbmZvLmp1bmdsZTMgPSB7XG4gIGtleTogJ2p1bmdsZTMnLFxuICB0ZXh0OiAnSnVuZ2xlMyBUZXN0bmV0JyxcbiAgdmFsdWU6ICdodHRwczovL2p1bmdsZTMuYmxva3MuaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL2p1bmdsZS5wbmcnLFxuICB0ZXN0bmV0OiB0cnVlXG59LCBfY2hhaW5JbmZvLmt5bGluID0ge1xuICBrZXk6ICdreWxpbicsXG4gIHRleHQ6ICdLeWxpbiBUZXN0bmV0JyxcbiAgdmFsdWU6ICdodHRwczovL2t5bGluLmJsb2tzLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy9reWxpbi5wbmcnLFxuICB0ZXN0bmV0OiB0cnVlXG59LCBfY2hhaW5JbmZvLnByb3RvbiA9IHtcbiAga2V5OiAncHJvdG9uJyxcbiAgdGV4dDogJ1Byb3RvbicsXG4gIHZhbHVlOiAnaHR0cHM6Ly9wcm90b25zY2FuLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy9wcm90b24ucG5nJ1xufSwgX2NoYWluSW5mby5lb3MgPSB7XG4gIGtleTogJ2VvcycsXG4gIHRleHQ6ICdFT1MnLFxuICB2YWx1ZTogJ2h0dHBzOi8vYmxva3MuaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL2Vvcy5wbmcnXG59LCBfY2hhaW5JbmZvLndheCA9IHtcbiAga2V5OiAnd2F4JyxcbiAgdGV4dDogJ1dBWCcsXG4gIHZhbHVlOiAnaHR0cHM6Ly93YXguYmxva3MuaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL3dheC5wbmcnXG59LCBfY2hhaW5JbmZvLmZpbyA9IHtcbiAga2V5OiAnZmlvJyxcbiAgdGV4dDogJ0ZJTycsXG4gIHZhbHVlOiAnaHR0cHM6Ly9maW8uYmxva3MuaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL2Zpby5wbmcnXG59LCBfY2hhaW5JbmZvKTtcblxudmFyIGdldENvbW1vbkNvbnN0YW50cyA9IGZ1bmN0aW9uIGdldENvbW1vbkNvbnN0YW50cyhjaGFpbikge1xuICByZXR1cm4ge1xuICAgIE1BWF9SUENfU1lOQ19TRUNPTkRTX0JFSElORDogMjAsXG4gICAgSU1BR0VfUFJPWFk6ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vaW1hZ2UtcHJveHknLFxuICAgIFdSQVBfQ09OVFJBQ1Q6ICdwcm90b24ud3JhcCcsXG4gICAgQkxPS1NfQVBJOiAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvJyxcbiAgICBFU1JfUFJPVE9DT0w6IGNoYWluID09PSAncHJvdG9uJyA/ICdwcm90b24nIDogJ3Byb3Rvbi1kZXYnLFxuICAgIE1FVEFMX1BST1RPTl9FTkRQT0lOVDogY2hhaW4gPT09ICdwcm90b24nID8gJ2h0dHBzOi8vYXBpLnByb3RvbmNoYWluLmNvbScgOiAnaHR0cHM6Ly9hcGktZGV2LnByb3RvbmNoYWluLmNvbScsXG4gICAgU1dBUF9VUkw6IGNoYWluID09PSAncHJvdG9uJyA/ICdodHRwczovL290Yy5wcm90b25zd2FwLmNvbScgOiAnaHR0cHM6Ly9vdGMtdGVzdC5wcm90b25zd2FwLmNvbScsXG4gICAgV1JBUF9TRVJWRVJfVVJMOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL3Byb3Rvbi13cmFwLXB1YmxpYzInIDogJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9wcm90b24td3JhcC10ZXN0bmV0LXB1YmxpYzInXG4gIH07XG59O1xuXG52YXIgZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyA9IGZ1bmN0aW9uIGdlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoY2hhaW5JZCwgYWN0aW9uRW5kcG9pbnRzKSB7XG4gIHJldHVybiBbe1xuICAgIGNoYWluSWQ6IGNoYWluSWQsXG4gICAgcG9ydDogNDQzLFxuICAgIHByb3RvY29sOiAnaHR0cHMnLFxuICAgIGhvc3Q6IGFjdGlvbkVuZHBvaW50c1swXS5zdWJzdHIoOCksXG4gICAgaHR0cEVuZHBvaW50OiBhY3Rpb25FbmRwb2ludHNbMF0sXG4gICAgYmxvY2tjaGFpbjogJ2VvcydcbiAgfV07XG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMgPSBbJ2h0dHBzOi8vZW9zLmdyZXltYXNzLmNvbScsICdodHRwczovL2Vvcy5lb3NjYWZlYmxvY2suY29tJywgJ2h0dHBzOi8vYXBpLm1haW4uYWxvaGFlb3MuY29tJywgJ2h0dHBzOi8vYXBpLmVvc3N3ZWRlbi5vcmcnXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyA9IFsnaHR0cHM6Ly9lb3MuZ3JleW1hc3MuY29tJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyA9IFsnaHR0cHM6Ly9lb3MuZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vYXBpLmVvc3N3ZWRlbi5vcmcnXTtcbnZhciBBTE9IQV9QUk9YWV9VUkwgPSAnaHR0cHM6Ly93d3cuYWxvaGFlb3MuY29tL3ZvdGUvcHJveHknO1xudmFyIEFQSV9VUkwgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvJztcbnZhciBBVE9NSUNBU1NFVFNfQVBJID0gJ2h0dHBzOi8vZW9zLmFwaS5hdG9taWNhc3NldHMuaW8nO1xudmFyIEJMT0tTX1BST1hZID0gJ2Jsb2tzaW9wcm94eSc7XG52YXIgQ0hBSU4gPSAnZW9zJztcbnZhciBDSEFJTl9JRCA9ICdhY2EzNzZmMjA2YjhmYzI1YTZlZDQ0ZGJkYzY2NTQ3YzM2YzZjMzNlM2ExMTlmZmJlYWVmOTQzNjQyZjBlOTA2JztcbnZhciBDSEFJTl9TVEFSVF9EQVRFID0gLyojX19QVVJFX18qL25ldyBEYXRlKCcyMDE4LTA2LTA4Jyk7XG52YXIgQ09SRV9QUkVDSVNJT04gPSA0O1xudmFyIENPUkVfU1lNQk9MID0gJ0VPUyc7XG52YXIgRElTUExBWV9DSEFJTiA9ICdFT1MnO1xudmFyIERPTUFJTl9USVRMRSA9ICdFT1MgQmxva3MuaW8nO1xudmFyIEhJU1RPUllfVFlQRVMgPSBbJ25hdGl2ZScsICdoeXBlcmlvbiddO1xudmFyIEhZUEVSSU9OX1VSTCA9ICdodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8nO1xudmFyIEtFWV9QUkVGSVggPSAnRU9TJztcbnZhciBMSUdIVF9BUEkgPSAnaHR0cHM6Ly9hcGkubGlnaHQueGVvcy5tZSc7XG52YXIgTkZUU19FTkFCTEVEID0gdHJ1ZTtcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCwgQUNUSU9OU19FTkRQT0lOVFMpO1xudmFyIFJFWF9FTkFCTEVEID0gdHJ1ZTtcbnZhciBTSU1QTEVBU1NFVFNfQVBJID0gJ2h0dHBzOi8vZW9zLmFwaS5zaW1wbGVhc3NldHMuaW8nO1xudmFyIFNVUFBPUlRTX0ZSRUVfQ1BVID0gdHJ1ZTtcbnZhciBTVVBQT1JUU19SRU5UQlcgPSB0cnVlO1xudmFyIFZPVElOR19FTkFCTEVEID0gdHJ1ZTtcbnZhciBjb25zdGFudHMgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyxcbiAgQUxPSEFfUFJPWFlfVVJMOiBBTE9IQV9QUk9YWV9VUkwsXG4gIEFQSV9VUkw6IEFQSV9VUkwsXG4gIEFUT01JQ0FTU0VUU19BUEk6IEFUT01JQ0FTU0VUU19BUEksXG4gIEJMT0tTX1BST1hZOiBCTE9LU19QUk9YWSxcbiAgQ0hBSU46IENIQUlOLFxuICBDSEFJTl9JRDogQ0hBSU5fSUQsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTixcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MLFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4sXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFLFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTLFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCxcbiAgTElHSFRfQVBJOiBMSUdIVF9BUEksXG4gIE5GVFNfRU5BQkxFRDogTkZUU19FTkFCTEVELFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyxcbiAgUkVYX0VOQUJMRUQ6IFJFWF9FTkFCTEVELFxuICBTSU1QTEVBU1NFVFNfQVBJOiBTSU1QTEVBU1NFVFNfQVBJLFxuICBTVVBQT1JUU19GUkVFX0NQVTogU1VQUE9SVFNfRlJFRV9DUFUsXG4gIFNVUFBPUlRTX1JFTlRCVzogU1VQUE9SVFNfUkVOVEJXLFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTLFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRURcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyQxID0gWydodHRwczovL3dheC5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly93YXguZW9zY2FmZWJsb2NrLmNvbScsICdodHRwczovL2FwaS53YXhzd2VkZW4ub3JnJywgJ2h0dHBzOi8vY2hhaW4ud2F4LmlvJywgJ2h0dHBzOi8vd2F4LmVvc3Jpby5pbyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJDEgPSBbJ2h0dHBzOi8vd2F4LmdyZXltYXNzLmNvbScsICdodHRwczovL2FwaS53YXhzd2VkZW4ub3JnJywgJ2h0dHBzOi8vd2F4LmVvc3Jpby5pbycsICdodHRwczovL2NoYWluLndheC5pbyddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkMSA9IFsnaHR0cHM6Ly93YXguZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vYXBpLndheHN3ZWRlbi5vcmcnLCAnaHR0cHM6Ly93YXguZW9zcmlvLmlvJywgJ2h0dHBzOi8vY2hhaW4ud2F4LmlvJ107XG52YXIgQUxPSEFfUFJPWFlfVVJMJDEgPSAnaHR0cHM6Ly93d3cuYWxvaGFlb3MuY29tL3ZvdGUvcHJveHkvd2F4bWFpbic7XG52YXIgQVBJX1VSTCQxID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby93YXgnO1xudmFyIEFUT01JQ0FTU0VUU19BUEkkMSA9ICdodHRwczovL3dheC5hcGkuYXRvbWljYXNzZXRzLmlvJztcbnZhciBCTE9LU19QUk9YWSQxID0gJ2Jsb2tzaW9wcm94eSc7XG52YXIgQ0hBSU4kMSA9ICd3YXgnO1xudmFyIENIQUlOX0lEJDEgPSAnMTA2NDQ4N2IzY2QxYTg5N2NlMDNhZTViNmE4NjU2NTE3NDdlMmUxNTIwOTBmOTljMWQxOWQ0NGUwMWFlYTVhNCc7XG52YXIgQ0hBSU5fU1RBUlRfREFURSQxID0gLyojX19QVVJFX18qL25ldyBEYXRlKCcyMDE5LTA2LTI0Jyk7XG52YXIgQ09SRV9QUkVDSVNJT04kMSA9IDg7XG52YXIgQ09SRV9TWU1CT0wkMSA9ICdXQVgnO1xudmFyIERJU1BMQVlfQ0hBSU4kMSA9ICdXQVgnO1xudmFyIERPTUFJTl9USVRMRSQxID0gJ1dBWCB8IEJsb2tzLmlvJztcbnZhciBISVNUT1JZX1RZUEVTJDEgPSBbJ25hdGl2ZScsICdoeXBlcmlvbiddO1xudmFyIEhZUEVSSU9OX1VSTCQxID0gJ2h0dHBzOi8vd2F4LmVvc3Jpby5pbyc7XG52YXIgS0VZX1BSRUZJWCQxID0gJ0VPUyc7XG52YXIgTElHSFRfQVBJJDEgPSAnaHR0cHM6Ly9saWdodGFwaS5lb3NhbXN0ZXJkYW0ubmV0JztcbnZhciBORlRTX0VOQUJMRUQkMSA9IHRydWU7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJDEgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCQxLCBBQ1RJT05TX0VORFBPSU5UUyQxKTtcbnZhciBTSU1QTEVBU1NFVFNfQVBJJDEgPSAnaHR0cHM6Ly93YXguYXBpLnNpbXBsZWFzc2V0cy5pbyc7XG52YXIgVk9USU5HX0VOQUJMRUQkMSA9IHRydWU7XG52YXIgY29uc3RhbnRzJDEgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyQxLFxuICBBTE9IQV9QUk9YWV9VUkw6IEFMT0hBX1BST1hZX1VSTCQxLFxuICBBUElfVVJMOiBBUElfVVJMJDEsXG4gIEFUT01JQ0FTU0VUU19BUEk6IEFUT01JQ0FTU0VUU19BUEkkMSxcbiAgQkxPS1NfUFJPWFk6IEJMT0tTX1BST1hZJDEsXG4gIENIQUlOOiBDSEFJTiQxLFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkMSxcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSQxLFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kMSxcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJDEsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyQxLFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJDEsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJDEsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkMSxcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwkMSxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCQxLFxuICBMSUdIVF9BUEk6IExJR0hUX0FQSSQxLFxuICBORlRTX0VOQUJMRUQ6IE5GVFNfRU5BQkxFRCQxLFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyQxLFxuICBTSU1QTEVBU1NFVFNfQVBJOiBTSU1QTEVBU1NFVFNfQVBJJDEsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkMSxcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEJDFcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyQyID0gWydodHRwczovL3Byb3Rvbi5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9wcm90b24uY3J5cHRvbGlvbnMuaW8nLCAnaHR0cHM6Ly9wcm90b24uZW9zdXNhLm5ld3MnLCBcImh0dHBzOi8vZnJhbmtmdXJ0LnByb3RvbmRhdGEubmV0XCJdO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkMiA9IFsnaHR0cHM6Ly9wcm90b24uZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vcHJvdG9uLmNyeXB0b2xpb25zLmlvJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkMiA9IFsnaHR0cHM6Ly9wcm90b24uZ3JleW1hc3MuY29tJ107XG52YXIgQVBJX1VSTCQyID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9wcm90b24nO1xudmFyIEFUT01JQ0FTU0VUU19BUEkkMiA9ICdodHRwczovL3Byb3Rvbi5hcGkuYXRvbWljYXNzZXRzLmlvJztcbnZhciBDSEFJTiQyID0gJ3Byb3Rvbic7XG52YXIgQ0hBSU5fSUQkMiA9ICczODRkYTg4ODExMjAyN2YwMzIxODUwYTE2OWY3MzdjMzNlNTNiMzg4YWFkNDhiNWFkYWNlNGJhYjk3ZjQzN2UwJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJDIgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJ0FwciAyMiwgMjAyMCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OJDIgPSA0O1xudmFyIENPUkVfU1lNQk9MJDIgPSAnWFBSJztcbnZhciBESVNQTEFZX0NIQUlOJDIgPSAnUHJvdG9uJztcbnZhciBET01BSU5fVElUTEUkMiA9ICdQcm90b25TY2FuJztcbnZhciBISVNUT1JZX1RZUEVTJDIgPSBbJ25hdGl2ZScsICdoeXBlcmlvbiddO1xudmFyIEhZUEVSSU9OX1VSTCQyID0gJ2h0dHA6Ly9wcm90b24ucGluay5nZyc7XG52YXIgS0VZX1BSRUZJWCQyID0gJ0VPUyc7XG52YXIgTElHSFRfQVBJJDIgPSAnaHR0cHM6Ly9saWdodGFwaS5lb3NhbXN0ZXJkYW0ubmV0JztcbnZhciBNQVhfVk9URVMgPSA0O1xudmFyIE5GVFNfRU5BQkxFRCQyID0gdHJ1ZTtcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkMiA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJDIsIEFDVElPTlNfRU5EUE9JTlRTJDIpO1xudmFyIFZPVElOR19FTkFCTEVEJDIgPSB0cnVlO1xudmFyIGNvbnN0YW50cyQyID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkMixcbiAgQVBJX1VSTDogQVBJX1VSTCQyLFxuICBBVE9NSUNBU1NFVFNfQVBJOiBBVE9NSUNBU1NFVFNfQVBJJDIsXG4gIENIQUlOOiBDSEFJTiQyLFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkMixcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSQyLFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kMixcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJDIsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyQyLFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJDIsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJDIsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkMixcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwkMixcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCQyLFxuICBMSUdIVF9BUEk6IExJR0hUX0FQSSQyLFxuICBNQVhfVk9URVM6IE1BWF9WT1RFUyxcbiAgTkZUU19FTkFCTEVEOiBORlRTX0VOQUJMRUQkMixcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkMixcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQyLFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRUQkMlxufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJDMgPSBbJ2h0dHBzOi8vZmlvLmdyZXltYXNzLmNvbScsICdodHRwczovL2Zpby5lb3Nzd2VkZW4ub3JnJywgJ2h0dHBzOi8vZmlvLmVvc3VzYS5uZXdzJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQzID0gWydodHRwczovL2Zpby5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9maW8uZW9zc3dlZGVuLm9yZycsICdodHRwczovL2Zpby5lb3N1c2EubmV3cyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJDMgPSBbJ2h0dHBzOi8vZmlvLmdyZXltYXNzLmNvbScsICdodHRwczovL2Zpby5lb3Nzd2VkZW4ub3JnJywgJ2h0dHBzOi8vZmlvLmVvc3VzYS5uZXdzJ107XG52YXIgQUxPSEFfUFJPWFlfVVJMJDIgPSAnaHR0cHM6Ly93d3cuYWxvaGFlb3MuY29tL3ZvdGUvcHJveHkvZmlvbWFpbic7XG52YXIgQVBJX1VSTCQzID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9maW8nO1xudmFyIENIQUlOJDMgPSAnZmlvJztcbnZhciBDSEFJTl9JRCQzID0gJzIxZGNhZTQyYzAxODIyMDBlOTNmOTU0YTA3NDAxMWY5MDQ4YTc2MjRjNmZlODFkM2M5NTQxYTYxNGE4OGJkMWMnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkMyA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnTWFyIDI0LCAyMDIwJyk7XG52YXIgQ09SRV9QUkVDSVNJT04kMyA9IDk7XG52YXIgQ09SRV9TWU1CT0wkMyA9ICdGSU8nO1xudmFyIERJU0FCTEVfTUVNTyA9IHRydWU7XG52YXIgRElTUExBWV9DSEFJTiQzID0gJ0ZJTyc7XG52YXIgRE9NQUlOX1RJVExFJDMgPSAnRklPIEJsb2tzLmlvJztcbnZhciBGSU9fRkVFU19BQ0NPVU5UID0gJ2ZlZXNAYmxva3MnO1xudmFyIEhJU1RPUllfVFlQRVMkMyA9IFsnbmF0aXZlJywgJ2h5cGVyaW9uJ107XG52YXIgSFlQRVJJT05fVVJMJDMgPSAnaHR0cHM6Ly9maW8uZW9zc3dlZGVuLm9yZyc7XG52YXIgS0VZX1BSRUZJWCQzID0gJ0ZJTyc7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJDMgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCQzLCBBQ1RJT05TX0VORFBPSU5UUyQzKTtcbnZhciBWT1RJTkdfRU5BQkxFRCQzID0gdHJ1ZTtcbnZhciBjb25zdGFudHMkMyA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJDMsXG4gIEFMT0hBX1BST1hZX1VSTDogQUxPSEFfUFJPWFlfVVJMJDIsXG4gIEFQSV9VUkw6IEFQSV9VUkwkMyxcbiAgQ0hBSU46IENIQUlOJDMsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCQzLFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJDMsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiQzLFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkMyxcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJDMsXG4gIERJU0FCTEVfTUVNTzogRElTQUJMRV9NRU1PLFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJDMsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJDMsXG4gIEZJT19GRUVTX0FDQ09VTlQ6IEZJT19GRUVTX0FDQ09VTlQsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkMyxcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwkMyxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCQzLFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyQzLFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDMsXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRCQzXG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkNCA9IFtdO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJDQgPSBbXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDQgPSBbXTtcbnZhciBBUElfVVJMJDQgPSAnJztcbnZhciBDSEFJTiQ0ID0gJ2xvY2FsJztcbnZhciBDSEFJTl9JRCQ0ID0gJyc7XG52YXIgQ0hBSU5fU1RBUlRfREFURSQ0ID0gdW5kZWZpbmVkO1xudmFyIENPUkVfUFJFQ0lTSU9OJDQgPSA0O1xudmFyIENPUkVfU1lNQk9MJDQgPSAnRU9TJztcbnZhciBESVNQTEFZX0NIQUlOJDQgPSAnTG9jYWwnO1xudmFyIERPTUFJTl9USVRMRSQ0ID0gJ0xvY2FsIEJsb2tzLmlvJztcbnZhciBISVNUT1JZX1RZUEVTJDQgPSBbJ25hdGl2ZSddO1xudmFyIEtFWV9QUkVGSVgkNCA9ICdFT1MnO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyQ0ID0gW107XG52YXIgVk9USU5HX0VOQUJMRUQkNCA9IHRydWU7XG52YXIgY29uc3RhbnRzJDQgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyQ0LFxuICBBUElfVVJMOiBBUElfVVJMJDQsXG4gIENIQUlOOiBDSEFJTiQ0LFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkNCxcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSQ0LFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kNCxcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJDQsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyQ0LFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJDQsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJDQsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkNCxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCQ0LFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyQ0LFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDQsXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRCQ0XG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkNSA9IFsvLyAnaHR0cHM6Ly9qdW5nbGVhcGkuZW9zc3dlZGVuLm9yZycsXG4naHR0cHM6Ly9hcGkuanVuZ2xlLmFsb2hhZW9zLmNvbScsICdodHRwczovL2p1bmdsZTIuY3J5cHRvbGlvbnMuaW8nLCAnaHR0cHM6Ly9qdW5nbGUuZW9zcGhlcmUuaW8nLCAnaHR0cHM6Ly9lb3MtanVuZ2xlLmVvc2Jsb2Nrc21pdGguaW8nXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyQ1ID0gWydodHRwczovL2p1bmdsZS5lb3Nzd2VkZW4ub3JnJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ1ID0gWydodHRwczovL2p1bmdsZS5lb3Nzd2VkZW4ub3JnJ107XG52YXIgQVBJX1VSTCQ1ID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9qdW5nbGUnO1xudmFyIEJMT0tTX1BST1hZJDIgPSAnYmxva3NwYXJ0bmVyJztcbnZhciBDSEFJTiQ1ID0gJ2p1bmdsZSc7XG52YXIgQ0hBSU5fSUQkNSA9ICdlNzBhYWFiODk5N2UxZGZjZTU4ZmJmYWM4MGNiYmI4ZmVjZWM3Yjk5Y2Y5ODJhOTQ0NDI3M2NiYzY0YzQxNDczJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJDUgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJ05vdiAyMywgMjAxOCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OJDUgPSA0O1xudmFyIENPUkVfU1lNQk9MJDUgPSAnRU9TJztcbnZhciBESVNQTEFZX0NIQUlOJDUgPSAnSnVuZ2xlJztcbnZhciBET01BSU5fVElUTEUkNSA9ICdKdW5nbGUgQmxva3MuaW8nO1xudmFyIEhJU1RPUllfVFlQRVMkNSA9IFsnaHlwZXJpb24nLCAnbmF0aXZlJ107XG52YXIgSFlQRVJJT05fVVJMJDQgPSAnaHR0cHM6Ly9qdW5nbGUyLmNyeXB0b2xpb25zLmlvJztcbnZhciBLRVlfUFJFRklYJDUgPSAnRU9TJztcbnZhciBMSUdIVF9BUEkkMyA9ICdodHRwczovL2xpZ2h0YXBpLmVvc2dlbmV2YS5pbyc7XG52YXIgTkZUU19FTkFCTEVEJDMgPSB0cnVlO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyQ1ID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkNSwgQUNUSU9OU19FTkRQT0lOVFMkNSk7XG52YXIgUkVYX0VOQUJMRUQkMSA9IHRydWU7XG52YXIgVk9USU5HX0VOQUJMRUQkNSA9IHRydWU7XG52YXIgY29uc3RhbnRzJDUgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyQ1LFxuICBBUElfVVJMOiBBUElfVVJMJDUsXG4gIEJMT0tTX1BST1hZOiBCTE9LU19QUk9YWSQyLFxuICBDSEFJTjogQ0hBSU4kNSxcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJDUsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkNSxcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJDUsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCQ1LFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkNSxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiQ1LFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSQ1LFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJDUsXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMJDQsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkNSxcbiAgTElHSFRfQVBJOiBMSUdIVF9BUEkkMyxcbiAgTkZUU19FTkFCTEVEOiBORlRTX0VOQUJMRUQkMyxcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkNSxcbiAgUkVYX0VOQUJMRUQ6IFJFWF9FTkFCTEVEJDEsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkNSxcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEJDVcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyQ2ID0gWydodHRwczovL2p1bmdsZTMuY3J5cHRvbGlvbnMuaW8nLCAnaHR0cHM6Ly9hcGkuanVuZ2xlMy5hbG9oYWVvcy5jb20nLCAnaHR0cHM6Ly9qdW5nbGUzLmVvc3VzYS5uZXdzJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkNiA9IFsnaHR0cHM6Ly9qdW5nbGUzLmNyeXB0b2xpb25zLmlvJywgJ2h0dHBzOi8vanVuZ2xlMy5lb3N1c2EubmV3cyddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkNiA9IFsnaHR0cHM6Ly9qdW5nbGUzLmNyeXB0b2xpb25zLmlvJywgJ2h0dHBzOi8vanVuZ2xlMy5lb3N1c2EubmV3cyddO1xudmFyIEFQSV9VUkwkNiA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vanVuZ2xlMyc7XG52YXIgQ0hBSU4kNiA9ICdqdW5nbGUzJztcbnZhciBDSEFJTl9JRCQ2ID0gJzJhMDJhMDA1M2U1YThjZjczYTU2YmEwZmRhMTFlNGQ5MmUwMjM4YTRhMmFhNzRmY2NmNDZkNWE5MTA3NDY4NDAnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkNiA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnRmViIDE5LCAyMDIwJyk7XG52YXIgQ09SRV9QUkVDSVNJT04kNiA9IDQ7XG52YXIgQ09SRV9TWU1CT0wkNiA9ICdFT1MnO1xudmFyIERJU1BMQVlfQ0hBSU4kNiA9ICdKdW5nbGUgMyc7XG52YXIgRE9NQUlOX1RJVExFJDYgPSAnSnVuZ2xlIDMgQmxva3MuaW8nO1xudmFyIEhJU1RPUllfVFlQRVMkNiA9IFsnaHlwZXJpb24nXTtcbnZhciBIWVBFUklPTl9VUkwkNSA9ICdodHRwczovL2p1bmdsZTMuY3J5cHRvbGlvbnMuaW8nO1xudmFyIEtFWV9QUkVGSVgkNiA9ICdFT1MnO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyQ2ID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkNiwgQUNUSU9OU19FTkRQT0lOVFMkNik7XG52YXIgUkVYX0VOQUJMRUQkMiA9IHRydWU7XG52YXIgU1VQUE9SVFNfUkVOVEJXJDEgPSB0cnVlO1xudmFyIFZPVElOR19FTkFCTEVEJDYgPSB0cnVlO1xudmFyIGNvbnN0YW50cyQ2ID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkNixcbiAgQVBJX1VSTDogQVBJX1VSTCQ2LFxuICBDSEFJTjogQ0hBSU4kNixcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJDYsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkNixcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJDYsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCQ2LFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkNixcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiQ2LFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSQ2LFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJDYsXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMJDUsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkNixcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkNixcbiAgUkVYX0VOQUJMRUQ6IFJFWF9FTkFCTEVEJDIsXG4gIFNVUFBPUlRTX1JFTlRCVzogU1VQUE9SVFNfUkVOVEJXJDEsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkNixcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEJDZcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyQ3ID0gWydodHRwczovL2t5bGluLmVvc24uaW8nXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyQ3ID0gWydodHRwczovL2t5bGluLmVvc24uaW8nXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDcgPSBbJ2h0dHBzOi8va3lsaW4uZW9zbi5pbyddO1xudmFyIEFQSV9VUkwkNyA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8va3lsaW4nO1xudmFyIEJMT0tTX1BST1hZJDMgPSAnYmxva3NwYXJ0bmVyJztcbnZhciBDSEFJTiQ3ID0gJ2t5bGluJztcbnZhciBDSEFJTl9JRCQ3ID0gJzVmZmYxZGFlOGRjOGUyZmM0ZDViMjNiMmM3NjY1Yzk3ZjllOWQ4ZWRmMmI2NDg1YTg2YmEzMTFjMjU2MzkxOTEnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkNyA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnSnVsIDEwLCAyMDE4Jyk7XG52YXIgQ09SRV9QUkVDSVNJT04kNyA9IDQ7XG52YXIgQ09SRV9TWU1CT0wkNyA9ICdFT1MnO1xudmFyIERJU1BMQVlfQ0hBSU4kNyA9ICdLeWxpbic7XG52YXIgRE9NQUlOX1RJVExFJDcgPSAnS3lsaW4gQmxva3MuaW8nO1xudmFyIEhJU1RPUllfVFlQRVMkNyA9IFsnaHlwZXJpb24nLCAnbmF0aXZlJ107XG52YXIgSFlQRVJJT05fVVJMJDYgPSAnaHR0cHM6Ly9reWxpbi5lb3N1c2EubmV3cyc7XG52YXIgS0VZX1BSRUZJWCQ3ID0gJ0VPUyc7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJDcgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCQ3LCBBQ1RJT05TX0VORFBPSU5UUyQ3KTtcbnZhciBWT1RJTkdfRU5BQkxFRCQ3ID0gdHJ1ZTtcbnZhciBjb25zdGFudHMkNyA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJDcsXG4gIEFQSV9VUkw6IEFQSV9VUkwkNyxcbiAgQkxPS1NfUFJPWFk6IEJMT0tTX1BST1hZJDMsXG4gIENIQUlOOiBDSEFJTiQ3LFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkNyxcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSQ3LFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kNyxcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJDcsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyQ3LFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJDcsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJDcsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkNyxcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwkNixcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCQ3LFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyQ3LFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDcsXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRCQ3XG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkOCA9IFsnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2Vvcy10ZXN0LW5vZGUnXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyQ4ID0gWydodHRwczovL3d3dy5hcGkuYmxva3MuaW8vZW9zLXRlc3Qtbm9kZSddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkOCA9IFsnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2Vvcy10ZXN0LW5vZGUnXTtcbnZhciBBUElfVVJMJDggPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2Vvcy10ZXN0JztcbnZhciBDSEFJTiQ4ID0gJ2Vvcy10ZXN0JztcbnZhciBDSEFJTl9JRCQ4ID0gJzBkYjEzYWI5YjMyMWMzN2MwYmE4NDgxY2I0NjgxYzI3ODhiNjIyYzNhYmZkMWYxMmYwZTUzNTNkNDRiYTZlNzInO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkOCA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnMjAyMC0wMS0xNCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OJDggPSA0O1xudmFyIENPUkVfU1lNQk9MJDggPSAnVE5UJztcbnZhciBESVNQTEFZX0NIQUlOJDggPSAnRU9TSU8gVGVzdCc7XG52YXIgRE9NQUlOX1RJVExFJDggPSAnQmxva3MuaW8nO1xudmFyIEhJU1RPUllfVFlQRVMkOCA9IFsnbmF0aXZlJ107XG52YXIgS0VZX1BSRUZJWCQ4ID0gJ0VPUyc7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJDggPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCQ4LCBBQ1RJT05TX0VORFBPSU5UUyQ4KTtcbnZhciBjb25zdGFudHMkOCA9IHtcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJDgsXG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyQ4LFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDgsXG4gIEFQSV9VUkw6IEFQSV9VUkwkOCxcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkOCxcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJDgsXG4gIENIQUlOOiBDSEFJTiQ4LFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJDgsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkOCxcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJDgsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJDgsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkOCxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCQ4LFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kOFxufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJDkgPSBbJ2h0dHBzOi8vcHJvdG9udGVzdG5ldC5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9wcm90b24tdGVzdG5ldC5lb3NjYWZlYmxvY2suY29tJywgJ2h0dHBzOi8vdGVzdG5ldC5wcm90b25jaGFpbi5jb20nLCAnaHR0cHM6Ly90ZXN0LnByb3Rvbi5lb3N1c2EubmV3cyddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkOSA9IFsnaHR0cHM6Ly9wcm90b250ZXN0bmV0LmdyZXltYXNzLmNvbScsICdodHRwczovL3Rlc3RuZXQucHJvdG9uY2hhaW4uY29tJywgJ2h0dHBzOi8vdGVzdC5wcm90b24uZW9zdXNhLm5ld3MnXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyQ5ID0gWydodHRwczovL3Byb3RvbnRlc3RuZXQuZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vdGVzdG5ldC5wcm90b25jaGFpbi5jb20nLCAnaHR0cHM6Ly90ZXN0LnByb3Rvbi5lb3N1c2EubmV3cyddO1xudmFyIEFQSV9VUkwkOSA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vcHJvdG9uLXRlc3QnO1xudmFyIEFUT01JQ0FTU0VUU19BUEkkMyA9ICdodHRwczovL3Rlc3QucHJvdG9uLmFwaS5hdG9taWNhc3NldHMuaW8nO1xudmFyIENIQUlOJDkgPSAncHJvdG9uLXRlc3QnO1xudmFyIENIQUlOX0lEJDkgPSAnNzFlZTgzYmNmNTIxNDJkNjEwMTlkOTVmOWNjNTQyN2JhNmEwZDdmZjhhY2NkOWUyMDg4YWUyYWJlYWYzZDNkZCc7XG52YXIgQ0hBSU5fU1RBUlRfREFURSQ5ID0gLyojX19QVVJFX18qL25ldyBEYXRlKCdBcHJpbCAzLCAyMDIwJyk7XG52YXIgQ09SRV9QUkVDSVNJT04kOSA9IDQ7XG52YXIgQ09SRV9TWU1CT0wkOSA9ICdYUFInO1xudmFyIERJU1BMQVlfQ0hBSU4kOSA9ICdQcm90b24tVCc7XG52YXIgRE9NQUlOX1RJVExFJDkgPSAnUHJvdG9uIFRlc3RuZXQnO1xudmFyIEhJU1RPUllfVFlQRVMkOSA9IFsnaHlwZXJpb24nLCAnbmF0aXZlJ107XG52YXIgSFlQRVJJT05fVVJMJDcgPSAnaHR0cHM6Ly90ZXN0bmV0LnByb3Rvbi5waW5rLmdnJztcbnZhciBLRVlfUFJFRklYJDkgPSAnRU9TJztcbnZhciBNQVhfVk9URVMkMSA9IDQ7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJDkgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCQ5LCBBQ1RJT05TX0VORFBPSU5UUyQ5KTtcbnZhciBWT1RJTkdfRU5BQkxFRCQ4ID0gdHJ1ZTtcbnZhciBjb25zdGFudHMkOSA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJDksXG4gIEFQSV9VUkw6IEFQSV9VUkwkOSxcbiAgQVRPTUlDQVNTRVRTX0FQSTogQVRPTUlDQVNTRVRTX0FQSSQzLFxuICBDSEFJTjogQ0hBSU4kOSxcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJDksXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkOSxcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJDksXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCQ5LFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkOSxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiQ5LFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSQ5LFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJDksXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMJDcsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkOSxcbiAgTUFYX1ZPVEVTOiBNQVhfVk9URVMkMSxcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkOSxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ5LFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRUQkOFxufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJGEgPSBbJ2h0dHBzOi8vdGVzdG5ldC53YXguZW9zZGV0cm9pdC5pbycsICdodHRwczovL3Rlc3RuZXQud2F4LnBpbmsuZ2cnLCAnaHR0cHM6Ly90ZXN0bmV0LndheHN3ZWRlbi5vcmcnXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJGEgPSBbJ2h0dHBzOi8vdGVzdG5ldC53YXguZW9zZGV0cm9pdC5pbycsICdodHRwczovL3Rlc3RuZXQud2F4LnBpbmsuZ2cnLCAnaHR0cHM6Ly90ZXN0bmV0LndheHN3ZWRlbi5vcmcnXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyRhID0gWydodHRwczovL3Rlc3RuZXQud2F4LmVvc2RldHJvaXQuaW8nLCAnaHR0cHM6Ly90ZXN0bmV0LndheC5waW5rLmdnJywgJ2h0dHBzOi8vdGVzdG5ldC53YXhzd2VkZW4ub3JnJ107XG52YXIgQVBJX1VSTCRhID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby93YXgtdGVzdCc7XG52YXIgQVRPTUlDQVNTRVRTX0FQSSQ0ID0gJ2h0dHBzOi8vdGVzdC53YXguYXBpLmF0b21pY2Fzc2V0cy5pbyc7XG52YXIgQ0hBSU4kYSA9ICd3YXgtdGVzdCc7XG52YXIgQ0hBSU5fSUQkYSA9ICdmMTZiMTgzM2M3NDdjNDM2ODJmNDM4NmZjYTljYmIzMjc5MjkzMzRhNzYyNzU1ZWJlYzE3ZjZmMjNjOWI4YTEyJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJGEgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJ0RlYyA1LCAyMDE5Jyk7XG52YXIgQ09SRV9QUkVDSVNJT04kYSA9IDg7XG52YXIgQ09SRV9TWU1CT0wkYSA9ICdXQVgnO1xudmFyIERJU1BMQVlfQ0hBSU4kYSA9ICdXQVgtVCc7XG52YXIgRE9NQUlOX1RJVExFJGEgPSAnV0FYIFRlc3RuZXQgQmxva3MuaW8nO1xudmFyIEhJU1RPUllfVFlQRVMkYSA9IFsnbmF0aXZlJywgJ2h5cGVyaW9uJ107XG52YXIgSFlQRVJJT05fVVJMJDggPSAnaHR0cHM6Ly90ZXN0bmV0LndheHN3ZWRlbi5vcmcnO1xudmFyIEtFWV9QUkVGSVgkYSA9ICdFT1MnO1xudmFyIExJR0hUX0FQSSQ0ID0gJ2h0dHBzOi8vdGVzdG5ldC1saWdodGFwaS5lb3NhbXMueGVvcy5tZSc7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJGEgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCRhLCBBQ1RJT05TX0VORFBPSU5UUyRhKTtcbnZhciBjb25zdGFudHMkYSA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJGEsXG4gIEFQSV9VUkw6IEFQSV9VUkwkYSxcbiAgQVRPTUlDQVNTRVRTX0FQSTogQVRPTUlDQVNTRVRTX0FQSSQ0LFxuICBDSEFJTjogQ0hBSU4kYSxcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJGEsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkYSxcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJGEsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCRhLFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkYSxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiRhLFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSRhLFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJGEsXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMJDgsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkYSxcbiAgTElHSFRfQVBJOiBMSUdIVF9BUEkkNCxcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkYSxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyRhXG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkYiA9IFsnaHR0cHM6Ly9maW90ZXN0bmV0LmdyZXltYXNzLmNvbScsICdodHRwczovL3Rlc3QuZmlvLmVvc3VzYS5uZXdzJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyRiID0gWydodHRwczovL2Zpb3Rlc3RuZXQuZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vdGVzdC5maW8uZW9zdXNhLm5ld3MnXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyRiID0gWydodHRwczovL2Zpb3Rlc3RuZXQuZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vdGVzdC5maW8uZW9zdXNhLm5ld3MnXTtcbnZhciBBUElfVVJMJGIgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2Zpby10ZXN0JztcbnZhciBDSEFJTiRiID0gJ2Zpby10ZXN0JztcbnZhciBDSEFJTl9JRCRiID0gJ2IyMDkwMTM4MGFmNDRlZjU5YzU5MTg0MzlhMWY5YTQxZDgzNjY5MDIwMzE5YTgwNTc0YjgwNGE1Zjk1Y2JkN2UnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkYiA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnTWFyIDEwLCAyMDIwJyk7XG52YXIgQ09SRV9QUkVDSVNJT04kYiA9IDk7XG52YXIgQ09SRV9TWU1CT0wkYiA9ICdGSU8nO1xudmFyIERJU0FCTEVfTUVNTyQxID0gdHJ1ZTtcbnZhciBESVNQTEFZX0NIQUlOJGIgPSAnRklPIFRlc3QnO1xudmFyIERPTUFJTl9USVRMRSRiID0gJ0ZJTyBUZXN0IEJsb2tzLmlvJztcbnZhciBISVNUT1JZX1RZUEVTJGIgPSBbJ25hdGl2ZScsICdoeXBlcmlvbiddO1xudmFyIEhZUEVSSU9OX1VSTCQ5ID0gJ2h0dHBzOi8vdGVzdC5maW8uZW9zdXNhLm5ld3MnO1xudmFyIEtFWV9QUkVGSVgkYiA9ICdGSU8nO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyRiID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkYiwgQUNUSU9OU19FTkRQT0lOVFMkYik7XG52YXIgVk9USU5HX0VOQUJMRUQkOSA9IHRydWU7XG52YXIgY29uc3RhbnRzJGIgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyRiLFxuICBBUElfVVJMOiBBUElfVVJMJGIsXG4gIENIQUlOOiBDSEFJTiRiLFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkYixcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSRiLFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kYixcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJGIsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyRiLFxuICBESVNBQkxFX01FTU86IERJU0FCTEVfTUVNTyQxLFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJGIsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJGIsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkYixcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwkOSxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCRiLFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyRiLFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJGIsXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRCQ5XG59O1xuXG52YXIgX2NoYWluVG9OZXR3b3JrQ29uc3RhO1xuXG52YXIgY2hhaW5Ub05ldHdvcmtDb25zdGFudHNNYXAgPSAoX2NoYWluVG9OZXR3b3JrQ29uc3RhID0ge1xuICBlb3M6IGNvbnN0YW50cyxcbiAgd2F4OiBjb25zdGFudHMkMSxcbiAgcHJvdG9uOiBjb25zdGFudHMkMixcbiAgbG9jYWw6IGNvbnN0YW50cyQ0LFxuICBqdW5nbGU6IGNvbnN0YW50cyQ1LFxuICBqdW5nbGUzOiBjb25zdGFudHMkNixcbiAga3lsaW46IGNvbnN0YW50cyQ3LFxuICBmaW86IGNvbnN0YW50cyQzXG59LCBfY2hhaW5Ub05ldHdvcmtDb25zdGFbJ2Vvcy10ZXN0J10gPSBjb25zdGFudHMkOCwgX2NoYWluVG9OZXR3b3JrQ29uc3RhWydwcm90b24tdGVzdCddID0gY29uc3RhbnRzJDksIF9jaGFpblRvTmV0d29ya0NvbnN0YVsnd2F4LXRlc3QnXSA9IGNvbnN0YW50cyRhLCBfY2hhaW5Ub05ldHdvcmtDb25zdGFbJ2Zpby10ZXN0J10gPSBjb25zdGFudHMkYiwgX2NoYWluVG9OZXR3b3JrQ29uc3RhKTtcbnZhciBDb25zdGFudHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25zdGFudHMoKSB7XG4gICAgaWYgKCEhQ29uc3RhbnRzLmluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gQ29uc3RhbnRzLmluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb25zdGFudHMucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZShjaGFpbikge1xuICAgIGlmICghY2hhaW4gfHwgIWNoYWluVG9OZXR3b3JrQ29uc3RhbnRzTWFwW2NoYWluXSkge1xuICAgICAgY2hhaW4gPSBERUZBVUxUX0NIQUlOO1xuICAgIH1cblxuICAgIHRoaXMuc2V0TmV0d29yayhjaGFpbik7XG4gICAgdGhpcy5zZXRDb21tb24oY2hhaW4pO1xuICB9O1xuXG4gIF9wcm90by5zZXROZXR3b3JrID0gZnVuY3Rpb24gc2V0TmV0d29yayhjaGFpbikge1xuICAgIC8vIGNvbnN0IG5ldHdvcmtDb25zdGFudHMgPSBhd2FpdCBpbXBvcnQoYCcuL25ldHdvcmtzLyR7Y2hhaW59YClcbiAgICB2YXIgbmV0d29ya0NvbnN0YW50cyA9IGNoYWluVG9OZXR3b3JrQ29uc3RhbnRzTWFwW2NoYWluXTtcbiAgICB0aGlzLnNldENvbnN0YW50cyhuZXR3b3JrQ29uc3RhbnRzKTtcbiAgICB0aGlzLnNldENvbnRyYWN0KGNoYWluLCBuZXR3b3JrQ29uc3RhbnRzLlNZU1RFTV9ET01BSU4pO1xuICB9O1xuXG4gIF9wcm90by5zZXRDb21tb24gPSBmdW5jdGlvbiBzZXRDb21tb24oY2hhaW4pIHtcbiAgICB2YXIgY29tbW9uQ29uc3RhbnRzID0gZ2V0Q29tbW9uQ29uc3RhbnRzKGNoYWluKTtcbiAgICB0aGlzLnNldENvbnN0YW50cyhjb21tb25Db25zdGFudHMpO1xuICB9O1xuXG4gIF9wcm90by5zZXRDb250cmFjdCA9IGZ1bmN0aW9uIHNldENvbnRyYWN0KGNoYWluLCBzeXN0ZW1Eb21haW4pIHtcbiAgICBpZiAoc3lzdGVtRG9tYWluID09PSB2b2lkIDApIHtcbiAgICAgIHN5c3RlbURvbWFpbiA9IERFRkFVTFRfU1lTVEVNX0RPTUFJTjtcbiAgICB9XG5cbiAgICB2YXIgY29udHJhY3RDb25zdGFudHMgPSBnZXRDb250cmFjdENvbnN0YW50cyhjaGFpbiwgc3lzdGVtRG9tYWluKTtcbiAgICB0aGlzLnNldENvbnN0YW50cyhjb250cmFjdENvbnN0YW50cyk7XG4gIH07XG5cbiAgX3Byb3RvLnNldENvbnN0YW50cyA9IGZ1bmN0aW9uIHNldENvbnN0YW50cyhuZXdDb25zdGFudHMpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3QkZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG5ld0NvbnN0YW50cyk7IF9pIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9PYmplY3QkZW50cmllcyRfaSA9IF9PYmplY3QkZW50cmllc1tfaV0sXG4gICAgICAgICAga2V5ID0gX09iamVjdCRlbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIHZhbHVlID0gX09iamVjdCRlbnRyaWVzJF9pWzFdO1xuICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb25zdGFudHM7XG59KCk7XG52YXIgY29uc3RhbnRzJGMgPSAvKiNfX1BVUkVfXyovbmV3IENvbnN0YW50cygpO1xuXG5leHBvcnQgeyBBTkNIT1IsIENMRU9TLCBDTElPLCBDb25zdGFudHMsIERFRkFVTFRfQ0hBSU4sIERFRkFVTFRfU1lNQk9MLCBERUZBVUxUX1NZU1RFTV9ET01BSU4sIEVPU0FVVEgsIEVPU0MsIEtFWUNBVCwgTEVER0VSLCBMRURHRVJfQkxFLCBMRURHRVJfVVNCLCBMRURHRVJfV0VCSElELCBMRURHRVJfV0VCVVNCLCBMWU5YLCBQUk9UT04sIFBST1RPTl9XRUIsIFNDQVRURVJfREVTS1RPUCwgU0NBVFRFUl9ERVNLVE9QX01BTlVBTCwgU0NBVFRFUl9FWFRFTlNJT04sIFNJTVBMRU9TLCBTUVJMLCBUUkVaT1IsIFdBWF9DTE9VRF9XQUxMRVQsIFdPTUJBVCwgY2hhaW5JbmZvLCBjaGFpblRvTmV0d29ya0NvbnN0YW50c01hcCwgY29uc3RhbnRzJGMgYXMgY29uc3RhbnRzLCBkYXBwcywgZXhjaGFuZ2VzLCBnZXRDb250cmFjdENvbnN0YW50cywgaGlzdG9yeVR5cGVzRmVhdHVyZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5lc20uanMubWFwXG4iLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbnVtYmVycy5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL251bWJlcnMuY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBiaWdudW1iZXJfanMgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcbnZhciBudW1icm8gPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGphZnJpL251bWJybycpKTtcbnZhciBkYXlqcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdkYXlqcycpKTtcbnZhciByZWxhdGl2ZVRpbWVQbHVnaW4gPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZGF5anMvcGx1Z2luL3JlbGF0aXZlVGltZScpKTtcbnZhciB1dGNQbHVnaW4gPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZGF5anMvcGx1Z2luL3V0YycpKTtcbnZhciB0aW1lem9uZVBsdWdpbiA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdkYXlqcy9wbHVnaW4vdGltZXpvbmUnKSk7XG52YXIgYWR2YW5jZWRGb3JtYXRQbHVnaW4gPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZGF5anMvcGx1Z2luL2FkdmFuY2VkRm9ybWF0JykpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpdCkgbyA9IGl0O1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGlzVHJ1ZSwgZXJyb3IpIHtcbiAgaWYgKGlzVHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG4oZnVuY3Rpb24gKE1hdGhzKSB7XG4gIHZhciBPcGVyYXRpb25zO1xuXG4gIChmdW5jdGlvbiAoT3BlcmF0aW9ucykge1xuICAgIE9wZXJhdGlvbnNbXCJQTFVTXCJdID0gXCJwbHVzXCI7XG4gICAgT3BlcmF0aW9uc1tcIk1VTFRJUExZXCJdID0gXCJtdWx0aXBsaWVkQnlcIjtcbiAgICBPcGVyYXRpb25zW1wiRElWSURFXCJdID0gXCJkaXZpZGVkQnlcIjtcbiAgICBPcGVyYXRpb25zW1wiTUlOVVNcIl0gPSBcIm1pbnVzXCI7XG4gIH0pKE9wZXJhdGlvbnMgPSBNYXRocy5PcGVyYXRpb25zIHx8IChNYXRocy5PcGVyYXRpb25zID0ge30pKTtcbn0pKGV4cG9ydHMuTWF0aHMgfHwgKGV4cG9ydHMuTWF0aHMgPSB7fSkpO1xuXG52YXIgQXNzZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBc3NldChhc3NldCkge1xuICAgIHRoaXMuc3ltYm9sID0gbmV3IFN5bWJvbCQxKHtcbiAgICAgIGNvZGU6IGFzc2V0LmNvZGUsXG4gICAgICBwcmVjaXNpb246IGFzc2V0LnByZWNpc2lvblxuICAgIH0pO1xuICAgIHRoaXMuYW1vdW50ID0gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoYXNzZXQuYW1vdW50KTtcbiAgfVxuXG4gIEFzc2V0LmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKGFzc2V0KSB7XG4gICAgdmFyIF9hc3NldCRzcGxpdCA9IGFzc2V0LnNwbGl0KCcgJyksXG4gICAgICAgIGFtb3VudCA9IF9hc3NldCRzcGxpdFswXSxcbiAgICAgICAgY29kZSA9IF9hc3NldCRzcGxpdFsxXTtcblxuICAgIHZhciBwcmVjaXNpb24gPSAoYW1vdW50LnNwbGl0KCcuJylbMV0gfHwgW10pLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IEFzc2V0KHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgIGFtb3VudDogbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoYW1vdW50KVxuICAgIH0pO1xuICB9O1xuXG4gIEFzc2V0LmZyb21TeW1ib2wgPSBmdW5jdGlvbiBmcm9tU3ltYm9sKF9yZWYpIHtcbiAgICB2YXIgc3ltYm9sID0gX3JlZi5zeW1ib2wsXG4gICAgICAgIGFtb3VudCA9IF9yZWYuYW1vdW50O1xuXG4gICAgaWYgKCEoc3ltYm9sIGluc3RhbmNlb2YgU3ltYm9sJDEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ltYm9sJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NldCh7XG4gICAgICBjb2RlOiBzeW1ib2wuY29kZSxcbiAgICAgIHByZWNpc2lvbjogc3ltYm9sLnByZWNpc2lvbixcbiAgICAgIGFtb3VudDogYW1vdW50XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IEFzc2V0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaXNFcXVhbFRvID0gZnVuY3Rpb24gaXNFcXVhbFRvKGFzc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMb29zZWx5RXF1YWxUbyhhc3NldCkgJiYgdGhpcy5hbW91bnQgPT0gYXNzZXQuYW1vdW50O1xuICB9O1xuXG4gIF9wcm90by5pc0xvb3NlbHlFcXVhbFRvID0gZnVuY3Rpb24gaXNMb29zZWx5RXF1YWxUbyhhc3NldCkge1xuICAgIHJldHVybiB0aGlzLnN5bWJvbC5pc0VxdWFsVG8oYXNzZXQuc3ltYm9sKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIodGhpcy5hbW91bnQpLnRvRml4ZWQodGhpcy5zeW1ib2wucHJlY2lzaW9uLCBiaWdudW1iZXJfanMuQmlnTnVtYmVyLlJPVU5EX0RPV04pICsgXCIgXCIgKyB0aGlzLnN5bWJvbC5jb2RlO1xuICB9O1xuXG4gIF9wcm90by5tb2RpZnlBbW91bnQgPSBmdW5jdGlvbiBtb2RpZnlBbW91bnQoeCwgbWV0aG9kKSB7XG4gICAgdmFyIGFtb3VudCA9IG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKDApO1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiIHx8IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIuaXNCaWdOdW1iZXIoeCkpIHtcbiAgICAgIGFtb3VudCA9IG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKHgpO1xuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQXNzZXQpIHtcbiAgICAgIGFzc2VydCh0aGlzLmlzTG9vc2VseUVxdWFsVG8oeCksIFwiaW52YWxpZCBzeW1ib2xcIik7XG4gICAgICBhbW91bnQgPSBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcih4LmFtb3VudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFzc2V0LmZyb21TeW1ib2woe1xuICAgICAgc3ltYm9sOiB0aGlzLnN5bWJvbCxcbiAgICAgIGFtb3VudDogdGhpcy5hbW91bnRbbWV0aG9kXShhbW91bnQpXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKHgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RpZnlBbW91bnQoeCwgZXhwb3J0cy5NYXRocy5PcGVyYXRpb25zLlBMVVMpO1xuICB9O1xuXG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKHgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RpZnlBbW91bnQoeCwgZXhwb3J0cy5NYXRocy5PcGVyYXRpb25zLk1JTlVTKTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbGllZEJ5ID0gZnVuY3Rpb24gbXVsdGlwbGllZEJ5KHgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RpZnlBbW91bnQoeCwgZXhwb3J0cy5NYXRocy5PcGVyYXRpb25zLk1VTFRJUExZKTtcbiAgfTtcblxuICBfcHJvdG8uZGl2aWRlZEJ5ID0gZnVuY3Rpb24gZGl2aWRlZEJ5KHgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RpZnlBbW91bnQoeCwgZXhwb3J0cy5NYXRocy5PcGVyYXRpb25zLkRJVklERSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEFzc2V0LCBbe1xuICAgIGtleTogXCJpbnRlZ2VyQW1vdW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIHRoaXMuc3ltYm9sLnByZWNpc2lvbik7XG4gICAgICByZXR1cm4gdGhpcy5hbW91bnQubXVsdGlwbGllZEJ5KGZhY3Rvcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFzc2V0O1xufSgpO1xudmFyIEV4dGVuZGVkQXNzZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHRlbmRlZEFzc2V0KGV4dGVuZGVkQXNzZXQpIHtcbiAgICBpZiAoIShleHRlbmRlZEFzc2V0LnF1YW50aXR5IGluc3RhbmNlb2YgQXNzZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcXVhbnRpdHknKTtcbiAgICB9XG5cbiAgICB0aGlzLnF1YW50aXR5ID0gZXh0ZW5kZWRBc3NldC5xdWFudGl0eTtcbiAgICB0aGlzLmNvbnRyYWN0ID0gZXh0ZW5kZWRBc3NldC5jb250cmFjdDtcbiAgfVxuXG4gIEV4dGVuZGVkQXNzZXQuZnJvbVJhdyA9IGZ1bmN0aW9uIGZyb21SYXcoX3JlZjIpIHtcbiAgICB2YXIgcXVhbnRpdHkgPSBfcmVmMi5xdWFudGl0eSxcbiAgICAgICAgY29udHJhY3QgPSBfcmVmMi5jb250cmFjdDtcbiAgICByZXR1cm4gbmV3IEV4dGVuZGVkQXNzZXQoe1xuICAgICAgcXVhbnRpdHk6IEFzc2V0LmZyb21TdHJpbmcocXVhbnRpdHkpLFxuICAgICAgY29udHJhY3Q6IGNvbnRyYWN0XG4gICAgfSk7XG4gIH07XG5cbiAgRXh0ZW5kZWRBc3NldC5mcm9tRXh0ZW5kZWRTeW1ib2wgPSBmdW5jdGlvbiBmcm9tRXh0ZW5kZWRTeW1ib2woc3ltYm9sLCBhbW91bnQpIHtcbiAgICBpZiAoIShzeW1ib2wgaW5zdGFuY2VvZiBFeHRlbmRlZFN5bWJvbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBleHRlbmRlZCBzeW1ib2wnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEV4dGVuZGVkQXNzZXQoe1xuICAgICAgcXVhbnRpdHk6IEFzc2V0LmZyb21TeW1ib2woe1xuICAgICAgICBzeW1ib2w6IHN5bWJvbC5zeW0sXG4gICAgICAgIGFtb3VudDogYW1vdW50XG4gICAgICB9KSxcbiAgICAgIGNvbnRyYWN0OiBzeW1ib2wuY29udHJhY3RcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX3Byb3RvMiA9IEV4dGVuZGVkQXNzZXQucHJvdG90eXBlO1xuXG4gIF9wcm90bzIuaXNFcXVhbFRvID0gZnVuY3Rpb24gaXNFcXVhbFRvKGV4dGVuZGVkQXNzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cmFjdCA9PT0gZXh0ZW5kZWRBc3NldC5jb250cmFjdCAmJiB0aGlzLnF1YW50aXR5LmlzRXF1YWxUbyhleHRlbmRlZEFzc2V0LnF1YW50aXR5KTtcbiAgfTtcblxuICBfcHJvdG8yLmlzTG9vc2VseUVxdWFsVG8gPSBmdW5jdGlvbiBpc0xvb3NlbHlFcXVhbFRvKGV4dGVuZGVkQXNzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cmFjdCA9PT0gZXh0ZW5kZWRBc3NldC5jb250cmFjdCAmJiB0aGlzLnF1YW50aXR5LmlzTG9vc2VseUVxdWFsVG8oZXh0ZW5kZWRBc3NldC5xdWFudGl0eSk7XG4gIH07XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnF1YW50aXR5LnRvU3RyaW5nKCkgKyBcIkBcIiArIHRoaXMuY29udHJhY3Q7XG4gIH07XG5cbiAgX3Byb3RvMi50b0V4dGVuZGVkU3ltYm9sID0gZnVuY3Rpb24gdG9FeHRlbmRlZFN5bWJvbCgpIHtcbiAgICByZXR1cm4gbmV3IEV4dGVuZGVkU3ltYm9sKHRoaXMucXVhbnRpdHkuc3ltYm9sLCB0aGlzLmNvbnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8yLm1vZGlmeUFtb3VudCA9IGZ1bmN0aW9uIG1vZGlmeUFtb3VudCh4LCBtZXRob2QpIHtcbiAgICB2YXIgYW1vdW50ID0gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoMCk7XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEV4dGVuZGVkQXNzZXQpIHtcbiAgICAgIGFzc2VydCh0aGlzLmlzTG9vc2VseUVxdWFsVG8oeCksIFwiaW52YWxpZCBjb250cmFjdCBvciBzeW1ib2xcIik7XG4gICAgICBhbW91bnQgPSB4LnF1YW50aXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICBhbW91bnQgPSB4O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRXh0ZW5kZWRBc3NldCh7XG4gICAgICBjb250cmFjdDogdGhpcy5jb250cmFjdCxcbiAgICAgIHF1YW50aXR5OiB0aGlzLnF1YW50aXR5Lm1vZGlmeUFtb3VudChhbW91bnQsIG1ldGhvZClcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8yLnBsdXMgPSBmdW5jdGlvbiBwbHVzKHgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RpZnlBbW91bnQoeCwgZXhwb3J0cy5NYXRocy5PcGVyYXRpb25zLlBMVVMpO1xuICB9O1xuXG4gIF9wcm90bzIubWludXMgPSBmdW5jdGlvbiBtaW51cyh4KSB7XG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5QW1vdW50KHgsIGV4cG9ydHMuTWF0aHMuT3BlcmF0aW9ucy5NSU5VUyk7XG4gIH07XG5cbiAgX3Byb3RvMi5tdWx0aXBsaWVkQnkgPSBmdW5jdGlvbiBtdWx0aXBsaWVkQnkoeCkge1xuICAgIHJldHVybiB0aGlzLm1vZGlmeUFtb3VudCh4LCBleHBvcnRzLk1hdGhzLk9wZXJhdGlvbnMuTVVMVElQTFkpO1xuICB9O1xuXG4gIF9wcm90bzIuZGl2aWRlZEJ5ID0gZnVuY3Rpb24gZGl2aWRlZEJ5KHgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RpZnlBbW91bnQoeCwgZXhwb3J0cy5NYXRocy5PcGVyYXRpb25zLkRJVklERSk7XG4gIH07XG5cbiAgcmV0dXJuIEV4dGVuZGVkQXNzZXQ7XG59KCk7XG52YXIgU3ltYm9sJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTeW1ib2woc3ltYm9sKSB7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBzeW1ib2wucHJlY2lzaW9uO1xuICAgIHRoaXMuY29kZSA9IHN5bWJvbC5jb2RlO1xuICB9XG5cbiAgU3ltYm9sLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHN5bWJvbCkge1xuICAgIHZhciBfc3ltYm9sJHNwbGl0ID0gc3ltYm9sLnNwbGl0KCcsJyksXG4gICAgICAgIHByZWNpc2lvbiA9IF9zeW1ib2wkc3BsaXRbMF0sXG4gICAgICAgIGNvZGUgPSBfc3ltYm9sJHNwbGl0WzFdO1xuXG4gICAgcmV0dXJuIG5ldyBTeW1ib2woe1xuICAgICAgcHJlY2lzaW9uOiArcHJlY2lzaW9uLFxuICAgICAgY29kZTogY29kZVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBfcHJvdG8zID0gU3ltYm9sLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLmlzRXF1YWxUbyA9IGZ1bmN0aW9uIGlzRXF1YWxUbyhzeW1ib2wpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlID09PSBzeW1ib2wuY29kZSAmJiB0aGlzLnByZWNpc2lvbiA9PT0gc3ltYm9sLnByZWNpc2lvbjtcbiAgfTtcblxuICBfcHJvdG8zLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlY2lzaW9uICsgXCIsXCIgKyB0aGlzLmNvZGU7XG4gIH07XG5cbiAgcmV0dXJuIFN5bWJvbDtcbn0oKTtcbnZhciBFeHRlbmRlZFN5bWJvbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4dGVuZGVkU3ltYm9sKHN5bSwgY29udHJhY3QpIHtcbiAgICB0aGlzLnN5bSA9IHN5bTtcbiAgICB0aGlzLmNvbnRyYWN0ID0gY29udHJhY3Q7XG4gIH1cblxuICBFeHRlbmRlZFN5bWJvbC5mcm9tUmF3ID0gZnVuY3Rpb24gZnJvbVJhdyhfcmVmMykge1xuICAgIHZhciBzeW0gPSBfcmVmMy5zeW0sXG4gICAgICAgIGNvbnRyYWN0ID0gX3JlZjMuY29udHJhY3Q7XG4gICAgcmV0dXJuIG5ldyBFeHRlbmRlZFN5bWJvbChTeW1ib2wkMS5mcm9tU3RyaW5nKHN5bSksIGNvbnRyYWN0KTtcbiAgfTtcblxuICB2YXIgX3Byb3RvNCA9IEV4dGVuZGVkU3ltYm9sLnByb3RvdHlwZTtcblxuICBfcHJvdG80LmlzRXF1YWxUbyA9IGZ1bmN0aW9uIGlzRXF1YWxUbyhleHRlbmRlZFN5bWJvbCkge1xuICAgIHJldHVybiB0aGlzLnN5bS5pc0VxdWFsVG8oZXh0ZW5kZWRTeW1ib2wuc3ltKSAmJiB0aGlzLmNvbnRyYWN0ID09PSBleHRlbmRlZFN5bWJvbC5jb250cmFjdDtcbiAgfTtcblxuICBfcHJvdG80LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ltLnRvU3RyaW5nKCkgKyBcIkBcIiArIHRoaXMuY29udHJhY3Q7XG4gIH07XG5cbiAgcmV0dXJuIEV4dGVuZGVkU3ltYm9sO1xufSgpO1xuXG52YXIgY3VycmVuY3lNYXAgPSB7XG4gIC8vIEZpYXRcbiAgR0JQOiB7XG4gICAgc3ltYm9sOiAnwqMnLFxuICAgIHByZWNpc2lvbjogMlxuICB9LFxuICBFVVI6IHtcbiAgICBzeW1ib2w6ICfigqwnLFxuICAgIHByZWNpc2lvbjogMlxuICB9LFxuICBKUFk6IHtcbiAgICBzeW1ib2w6ICfCpScsXG4gICAgcHJlY2lzaW9uOiAwXG4gIH0sXG4gIENBRDoge1xuICAgIHN5bWJvbDogJ0NBJCcsXG4gICAgcHJlY2lzaW9uOiAyXG4gIH0sXG4gIFVTRDoge1xuICAgIHN5bWJvbDogJyQnLFxuICAgIHByZWNpc2lvbjogMlxuICB9LFxuICBJTlI6IHtcbiAgICBzeW1ib2w6ICfigrknLFxuICAgIHByZWNpc2lvbjogMlxuICB9LFxuICBDTlk6IHtcbiAgICBzeW1ib2w6ICdDTsKlJyxcbiAgICBwcmVjaXNpb246IDJcbiAgfSxcbiAgSEtEOiB7XG4gICAgc3ltYm9sOiAnSEskJyxcbiAgICBwcmVjaXNpb246IDJcbiAgfSxcbiAgS1JXOiB7XG4gICAgc3ltYm9sOiAn4oKpJyxcbiAgICBwcmVjaXNpb246IDBcbiAgfSxcbiAgQVVEOiB7XG4gICAgc3ltYm9sOiAnQVVEJCcsXG4gICAgcHJlY2lzaW9uOiAyXG4gIH0sXG4gIFNBUjoge1xuICAgIHN5bWJvbDogJ1NSJyxcbiAgICBwcmVjaXNpb246IDJcbiAgfSxcbiAgLy8gQ3J5cHRvXG4gIEVUSDoge1xuICAgIHN5bWJvbDogJ86eJyxcbiAgICBwcmVjaXNpb246IDRcbiAgfSxcbiAgQlRDOiB7XG4gICAgc3ltYm9sOiAn4oK/JyxcbiAgICBwcmVjaXNpb246IDhcbiAgfSxcbiAgRU9TOiB7XG4gICAgc3ltYm9sOiAnRU9TJyxcbiAgICBwcmVjaXNpb246IDRcbiAgfVxufTtcbnZhciBhc3NldEZvcm1hdCA9IHtcbiAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxuICBncm91cFNlcGFyYXRvcjogJywnLFxuICBncm91cFNpemU6IDNcbn07XG5cbmZ1bmN0aW9uIHRvQk4obnVtYmVyKSB7XG4gIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihudW1iZXIpO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9BbW91bnQobnVtYmVyLCBwcmVjaXNpb24sIHJvdW5kKSB7XG4gIGlmIChyb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgcm91bmQgPSBiaWdudW1iZXJfanMuQmlnTnVtYmVyLlJPVU5EX0RPV047XG4gIH1cblxuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihudW1iZXIpKSB7XG4gICAgbnVtYmVyID0gMDtcbiAgfVxuXG4gIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihudW1iZXIpLnRvRml4ZWQocHJlY2lzaW9uLCByb3VuZCk7XG59XG5mdW5jdGlvbiBudW1iZXJUb0Ftb3VudEZvcm1hdHRlZChudW1iZXIsIHByZWNpc2lvbiwgcm91bmQpIHtcbiAgaWYgKHJvdW5kID09PSB2b2lkIDApIHtcbiAgICByb3VuZCA9IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIuUk9VTkRfRE9XTjtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IHVuZGVmaW5lZCB8fCBpc05hTihudW1iZXIpKSB7XG4gICAgbnVtYmVyID0gMDtcbiAgfVxuXG4gIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihudW1iZXIpLnRvRm9ybWF0KHByZWNpc2lvbiwgcm91bmQsIGFzc2V0Rm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBlcmNlbnRhZ2UoYmFsYW5jZSwgcGVyY2VudGFnZSwgcHJlY2lzaW9uKSB7XG4gIHZhciBfZmluYWwgPSBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihiYWxhbmNlKS5tdWx0aXBsaWVkQnkocGVyY2VudGFnZSk7XG5cbiAgcmV0dXJuIG51bWJlclRvQW1vdW50KF9maW5hbCwgcHJlY2lzaW9uLCBiaWdudW1iZXJfanMuQmlnTnVtYmVyLlJPVU5EX0RPV04pO1xufVxuZnVuY3Rpb24gZW9zRGlzcGxheUZvcm1hdHRpbmcodmFsdWUsIHN5bWJvbCwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiBudW1iZXJUb0Ftb3VudEZvcm1hdHRlZCh2YWx1ZSwgcHJlY2lzaW9uKSArIFwiIFwiICsgc3ltYm9sO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9Fb3MobnVtYmVyLCBzeW1ib2wsIHByZWNpc2lvbikge1xuICByZXR1cm4gbnVtYmVyVG9BbW91bnQobnVtYmVyLCBwcmVjaXNpb24pICsgXCIgXCIgKyBzeW1ib2w7XG59XG5mdW5jdGlvbiBudW1iZXJUb0Vvc1JvdW5kVXAobnVtYmVyLCBzeW1ib2wsIHByZWNpc2lvbikge1xuICByZXR1cm4gbnVtYmVyVG9BbW91bnQobnVtYmVyLCBwcmVjaXNpb24sIGJpZ251bWJlcl9qcy5CaWdOdW1iZXIuUk9VTkRfVVApICsgXCIgXCIgKyBzeW1ib2w7XG59XG5mdW5jdGlvbiBwYXJzZVJleChyZXgpIHtcbiAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKHJleCkuZGl2aWRlZEJ5KDEwMDAwKTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0cyBVU0QgdG8geyBzeW1ib2w6IFwiVVNEXCIsIHByZWNpc2lvbjogNCB9XHJcbiAqIEBwYXJhbSB7Kn0gY3VycmVuY3lcclxuICovXG5cbmZ1bmN0aW9uIGN1cnJlbmN5VG9TeW1ib2woY3VycmVuY3kpIHtcbiAgcmV0dXJuIGN1cnJlbmN5TWFwW2N1cnJlbmN5XTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0cyBcIjEwMDAuMDAwMCBFT1NcIiB0byB7IGFtb3VudDogMTAwMCwgc3ltYm9sOiB7IGNvZGU6IFwiRU9TXCIsIHByZWNpc2lvbjogNCB9fVxyXG4gKiBAcGFyYW0geyp9IHF1YW50aXR5XHJcbiAqL1xuXG5mdW5jdGlvbiBzcGxpdChxdWFudGl0eSkge1xuICB2YXIgX3F1YW50aXR5JHNwbGl0ID0gcXVhbnRpdHkuc3BsaXQoJyAnKSxcbiAgICAgIGFtb3VudCA9IF9xdWFudGl0eSRzcGxpdFswXSxcbiAgICAgIGNvZGUgPSBfcXVhbnRpdHkkc3BsaXRbMV07XG5cbiAgdmFyIHByZWNpc2lvbiA9IChhbW91bnQuc3BsaXQoJy4nKVsxXSB8fCBbXSkubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIGFtb3VudDogK2Ftb3VudCxcbiAgICBzeW1ib2w6IHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICBwcmVjaXNpb246IHByZWNpc2lvblxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRvTnVtYnJvKG51bWJlcikge1xuICByZXR1cm4gbnVtYnJvKG51bWJlcik7XG59XG4vKipcclxuICogQ29udmVydHMgMTAwMCB0byBcIjEwMDAuMDAwMCBFT1NcIlxyXG4gKiBAcGFyYW0geyp9IGFzc2V0XHJcbiAqL1xuXG5mdW5jdGlvbiBudW1iZXJUb0Fzc2V0KG51bWJlciwgc3ltYm9sLCBwcmVjaXNpb24sIHRyaW1NYW50aXNzYSkge1xuICBpZiAodHJpbU1hbnRpc3NhID09PSB2b2lkIDApIHtcbiAgICB0cmltTWFudGlzc2EgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IHVuZGVmaW5lZCB8fCBpc05hTihudW1iZXIpKSB7XG4gICAgbnVtYmVyID0gMDtcbiAgfVxuXG4gIHZhciBhbW91bnQgPSBudW1icm8obnVtYmVyKS5mb3JtYXQoe1xuICAgIHRob3VzYW5kU2VwYXJhdGVkOiBmYWxzZSxcbiAgICBtYW50aXNzYTogcHJlY2lzaW9uLFxuICAgIHRyaW1NYW50aXNzYTogdHJpbU1hbnRpc3NhXG4gIH0pO1xuICByZXR1cm4gYW1vdW50ICsgXCIgXCIgKyBzeW1ib2w7XG59XG4vKipcclxuICogRElTUExBWSBGVU5DVElPTlNcclxuICovXG5cbi8qKlxyXG4gKiBDb252ZXJ0cyAxMDAwIHRvIDEsMDAwXHJcbiAqIEBwYXJhbSB7Kn0gbnVtYmVyXHJcbiAqL1xuXG5mdW5jdGlvbiBkaXNwbGF5TnVtYmVyKG51bWJlciwgdHJpbU1hbnRpc3NhKSB7XG4gIGlmICh0cmltTWFudGlzc2EgPT09IHZvaWQgMCkge1xuICAgIHRyaW1NYW50aXNzYSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG51bWJlcikpIHtcbiAgICBudW1iZXIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIG51bWJybyhudW1iZXIpLmZvcm1hdCh7XG4gICAgdGhvdXNhbmRTZXBhcmF0ZWQ6IHRydWUsXG4gICAgdHJpbU1hbnRpc3NhOiB0cmltTWFudGlzc2FcbiAgfSk7XG59XG4vKipcclxuICogQ29udmVydHMgMTAwMCB0byAkMSwwMDAgVVNEXHJcbiAqIEBwYXJhbSB7Kn0gbnVtYmVyXHJcbiAqL1xuXG5mdW5jdGlvbiBkaXNwbGF5TnVtYmVyQXNDdXJyZW5jeShfcmVmKSB7XG4gIHZhciBudW1iZXIgPSBfcmVmLm51bWJlcixcbiAgICAgIHByZWNpc2lvbiA9IF9yZWYucHJlY2lzaW9uLFxuICAgICAgX3JlZiRhdmVyYWdlID0gX3JlZi5hdmVyYWdlLFxuICAgICAgYXZlcmFnZSA9IF9yZWYkYXZlcmFnZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGF2ZXJhZ2UsXG4gICAgICBfcmVmJGxvd1ByZWNpc2lvbiA9IF9yZWYubG93UHJlY2lzaW9uLFxuICAgICAgbG93UHJlY2lzaW9uID0gX3JlZiRsb3dQcmVjaXNpb24gPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJGxvd1ByZWNpc2lvbixcbiAgICAgIF9yZWYkdHJpbU1hbnRpc3NhID0gX3JlZi50cmltTWFudGlzc2EsXG4gICAgICB0cmltTWFudGlzc2EgPSBfcmVmJHRyaW1NYW50aXNzYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHRyaW1NYW50aXNzYSxcbiAgICAgIF9yZWYkY3VycmVuY3kgPSBfcmVmLmN1cnJlbmN5LFxuICAgICAgY3VycmVuY3kgPSBfcmVmJGN1cnJlbmN5ID09PSB2b2lkIDAgPyAnVVNEJyA6IF9yZWYkY3VycmVuY3k7XG5cbiAgaWYgKCFjdXJyZW5jeU1hcFtjdXJyZW5jeV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGN1cnJlbmN5Jyk7XG4gIH1cblxuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQgfHwgaXNOYU4obnVtYmVyKSkge1xuICAgIG51bWJlciA9IDA7XG4gIH1cblxuICB2YXIgX2N1cnJlbmN5TWFwJGN1cnJlbmN5ID0gY3VycmVuY3lNYXBbY3VycmVuY3ldLFxuICAgICAgc3ltYm9sID0gX2N1cnJlbmN5TWFwJGN1cnJlbmN5LnN5bWJvbCxcbiAgICAgIGRlZmF1bHRQcmVjaXNpb24gPSBfY3VycmVuY3lNYXAkY3VycmVuY3kucHJlY2lzaW9uO1xuICB2YXIgZm9ybWF0ID0ge1xuICAgIHRob3VzYW5kU2VwYXJhdGVkOiB0cnVlLFxuICAgIG1hbnRpc3NhOiBwcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHByZWNpc2lvbiA6IGRlZmF1bHRQcmVjaXNpb24sXG4gICAgdHJpbU1hbnRpc3NhOiB0cmltTWFudGlzc2EsXG4gICAgYXZlcmFnZTogYXZlcmFnZVxuICB9O1xuXG4gIGlmIChhdmVyYWdlKSB7XG4gICAgZm9ybWF0Lmxvd1ByZWNpc2lvbiA9IGxvd1ByZWNpc2lvbjtcbiAgfVxuXG4gIHZhciBmb3JtYXR0ZWROdW1iZXIgPSBudW1icm8obnVtYmVyKS5mb3JtYXQoZm9ybWF0KTtcbiAgcmV0dXJuIFwiXCIgKyBzeW1ib2wgKyBmb3JtYXR0ZWROdW1iZXI7XG59XG4vKipcclxuICogQ29udmVydHMgXCIxMDAwLjAwMDAgRU9TXCIgdG8gXCIxLDAwMC4wMDAwIEVPU1wiXHJcbiAqIEBwYXJhbSB7Kn0gYXNzZXRcclxuICovXG5cbmZ1bmN0aW9uIGRpc3BsYXlBc3NldChhc3NldCkge1xuICB2YXIgX3NwbGl0ID0gc3BsaXQoYXNzZXQpLFxuICAgICAgYW1vdW50ID0gX3NwbGl0LmFtb3VudCxcbiAgICAgIGNvZGUgPSBfc3BsaXQuc3ltYm9sLmNvZGU7XG5cbiAgcmV0dXJuIGRpc3BsYXlOdW1iZXIoYW1vdW50KSArIFwiIFwiICsgY29kZTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0cyAxMDAwIHRvIDEsMDAwLjAwMDBcclxuICogQHBhcmFtIHsqfSBudW1iZXJcclxuICovXG5cbmZ1bmN0aW9uIGRpc3BsYXlOdW1iZXJBc0Ftb3VudChudW1iZXIsIHByZWNpc2lvbiwgdHJpbU1hbnRpc3NhKSB7XG4gIGlmICh0cmltTWFudGlzc2EgPT09IHZvaWQgMCkge1xuICAgIHRyaW1NYW50aXNzYSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG51bWJlcikpIHtcbiAgICBudW1iZXIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIG51bWJybyhudW1iZXIpLmZvcm1hdCh7XG4gICAgdGhvdXNhbmRTZXBhcmF0ZWQ6IHRydWUsXG4gICAgbWFudGlzc2E6IHByZWNpc2lvbixcbiAgICB0cmltTWFudGlzc2E6IHRyaW1NYW50aXNzYVxuICB9KTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0cyAxMDAwIHRvIFwiMSwwMDAuMDAwMCBFT1NcIlxyXG4gKiBAcGFyYW0geyp9IG51bWJlclxyXG4gKi9cblxuZnVuY3Rpb24gZGlzcGxheU51bWJlckFzQXNzZXQobnVtYmVyLCBzeW1ib2wsIHByZWNpc2lvbiwgdHJpbU1hbnRpc3NhKSB7XG4gIGlmICh0cmltTWFudGlzc2EgPT09IHZvaWQgMCkge1xuICAgIHRyaW1NYW50aXNzYSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG51bWJlcikpIHtcbiAgICBudW1iZXIgPSAwO1xuICB9XG5cbiAgdmFyIGFtb3VudCA9IG51bWJybyhudW1iZXIpLmZvcm1hdCh7XG4gICAgdGhvdXNhbmRTZXBhcmF0ZWQ6IHRydWUsXG4gICAgbWFudGlzc2E6IHByZWNpc2lvbixcbiAgICB0cmltTWFudGlzc2E6IHRyaW1NYW50aXNzYVxuICB9KTtcbiAgcmV0dXJuIGFtb3VudCArIFwiIFwiICsgc3ltYm9sO1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIDEwMDAwMDAwIHRvIFwiMSwwMDAuMDAwMCBFT1NcIlxyXG4gKiBAcGFyYW0geyp9IG51bWJlclxyXG4gKi9cblxuZnVuY3Rpb24gZGlzcGxheVJhd051bWJlckFzQXNzZXQobnVtYmVyLCBzeW1ib2wsIHByZWNpc2lvbiwgdHJpbU1hbnRpc3NhKSB7XG4gIGlmICh0cmltTWFudGlzc2EgPT09IHZvaWQgMCkge1xuICAgIHRyaW1NYW50aXNzYSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRpc3BsYXlOdW1iZXJBc0Fzc2V0KG51bWJlciAvIE1hdGgucG93KDEwLCBwcmVjaXNpb24pLCBzeW1ib2wsIHByZWNpc2lvbiwgdHJpbU1hbnRpc3NhKTtcbn1cblxuYmlnbnVtYmVyX2pzLkJpZ051bWJlci5zZXQoe1xuICBST1VORElOR19NT0RFOiAxXG59KTtcbmZ1bmN0aW9uIGFkZCgpIHtcbiAgdmFyIHN0YXJ0ID0gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoMCk7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG51bWJlcnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbnVtYmVyc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChudW1iZXJzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobnVtYmVycyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbnVtYmVyID0gX3N0ZXAudmFsdWU7XG4gICAgICBzdGFydCA9IHN0YXJ0LnBsdXMobnVtYmVyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhcnQ7XG59XG5mdW5jdGlvbiBzdWJzdHJhY3QoYSwgYikge1xuICByZXR1cm4gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoYSkubWludXMoYik7XG59XG5mdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihhKS5tdWx0aXBsaWVkQnkoYik7XG59XG5mdW5jdGlvbiBkaXZpZGUoYSwgYikge1xuICByZXR1cm4gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoYSkuZGl2aWRlZEJ5KGIpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvS0IoYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzID09PSB2b2lkIDApIHtcbiAgICBieXRlcyA9IDA7XG4gIH1cblxuICByZXR1cm4gbnVtYnJvKGJ5dGVzIC8gMTAyNCkuZm9ybWF0KHtcbiAgICB0aG91c2FuZFNlcGFyYXRlZDogZmFsc2UsXG4gICAgbWFudGlzc2E6IDJcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZU5ldEFuZFJhbShieXRlcykge1xuICB2YXIgcGFyc2VkVmFsdWUgPSAwO1xuICB2YXIgcGFyc2VkVGV4dCA9ICcnO1xuXG4gIGlmIChieXRlcyA8IDEwMjQpIHtcbiAgICBwYXJzZWRWYWx1ZSA9IGJ5dGVzO1xuICAgIHBhcnNlZFRleHQgPSAnQnl0ZXMnO1xuICB9IGVsc2UgaWYgKGJ5dGVzIDwgMTA0ODU3Nikge1xuICAgIHBhcnNlZFZhbHVlID0gYnl0ZXMgLyAxMDI0O1xuICAgIHBhcnNlZFRleHQgPSAnS0InO1xuICB9IGVsc2UgaWYgKGJ5dGVzIDwgMTA3Mzc0MTgyNCkge1xuICAgIHBhcnNlZFZhbHVlID0gYnl0ZXMgLyAxMDQ4NTc2O1xuICAgIHBhcnNlZFRleHQgPSAnTUInO1xuICB9IGVsc2UgaWYgKGJ5dGVzIDwgMTA5OTUxMTYyNzc3Nikge1xuICAgIHBhcnNlZFZhbHVlID0gYnl0ZXMgLyAxMDczNzQxODI0O1xuICAgIHBhcnNlZFRleHQgPSAnR0InO1xuICB9IGVsc2UgaWYgKGJ5dGVzIDwgMTEyNTg5OTkwNjg0MjYyNCkge1xuICAgIHBhcnNlZFZhbHVlID0gYnl0ZXMgLyAxMDk5NTExNjI3Nzc2O1xuICAgIHBhcnNlZFRleHQgPSAnVEInO1xuICB9XG5cbiAgcmV0dXJuIGRpc3BsYXlOdW1iZXJBc0Ftb3VudChwYXJzZWRWYWx1ZSwgMiwgdHJ1ZSkgKyBcIiBcIiArIHBhcnNlZFRleHQ7XG59XG5mdW5jdGlvbiBwYXJzZUNwdSh1cykge1xuICB2YXIgcGFyc2VkVmFsdWUgPSAwO1xuICB2YXIgcGFyc2VkVGV4dCA9ICcnO1xuXG4gIGlmICh1cyA8IDEwMDApIHtcbiAgICBwYXJzZWRWYWx1ZSA9IHVzO1xuICAgIHBhcnNlZFRleHQgPSAnwrVzJztcbiAgfSBlbHNlIGlmICh1cyA8IDEwMDAwMDApIHtcbiAgICBwYXJzZWRWYWx1ZSA9IHVzIC8gMTAwMDtcbiAgICBwYXJzZWRUZXh0ID0gJ21zJztcbiAgfSBlbHNlIGlmICh1cyA8IDYwMDAwMDAwKSB7XG4gICAgcGFyc2VkVmFsdWUgPSB1cyAvIDEwMDAwMDA7XG4gICAgcGFyc2VkVGV4dCA9ICdzJztcbiAgfSBlbHNlIGlmICh1cyA8IDM2MDAwMDAwMDApIHtcbiAgICBwYXJzZWRWYWx1ZSA9IHVzIC8gNjAwMDAwMDA7XG4gICAgcGFyc2VkVGV4dCA9ICdtaW4nO1xuICB9IGVsc2UgaWYgKHVzIDwgMzYwMDAwMDAwMDAwMCkge1xuICAgIHBhcnNlZFZhbHVlID0gdXMgLyAzNjAwMDAwMDAwO1xuICAgIHBhcnNlZFRleHQgPSAnaG91cnMnO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlZFZhbHVlID0gdXMgLyA4NjQwMDAwMDAwMDtcbiAgICBwYXJzZWRUZXh0ID0gJ2RheXMnO1xuICB9XG5cbiAgcmV0dXJuIGRpc3BsYXlOdW1iZXJBc0Ftb3VudChwYXJzZWRWYWx1ZSwgMiwgdHJ1ZSkgKyBcIiBcIiArIHBhcnNlZFRleHQ7XG59XG5cbmRheWpzLmV4dGVuZChyZWxhdGl2ZVRpbWVQbHVnaW4pO1xuZGF5anMuZXh0ZW5kKHV0Y1BsdWdpbik7XG5kYXlqcy5leHRlbmQodGltZXpvbmVQbHVnaW4pO1xuZGF5anMuZXh0ZW5kKGFkdmFuY2VkRm9ybWF0UGx1Z2luKTtcbnZhciBDT01NT05fREFURV9GT1JNQVQgPSAnTU1NLURELVlZWVksIGhoOm1tOnNzIEEnO1xuLyoqXHJcbiAqIFRpbWUgdXRpbGl0aWVzXHJcbiAqL1xuXG5mdW5jdGlvbiB0aW1lKGRhdGUpIHtcbiAgcmV0dXJuIGRheWpzKGRhdGUpO1xufVxuZnVuY3Rpb24gdXRjVGltZShkYXRlKSB7XG4gIHJldHVybiBkYXlqcyhkYXRlKS51dGMoKTtcbn1cbmZ1bmN0aW9uIHV0Y1RpbWVUb0xvY2FsKGRhdGUpIHtcbiAgcmV0dXJuIGRheWpzKGRhdGUpLmxvY2FsKCk7XG59XG5mdW5jdGlvbiB1bml4VGltZSh1bml4VGltZXN0YW1wKSB7XG4gIHJldHVybiBkYXlqcy51bml4KHVuaXhUaW1lc3RhbXApO1xufVxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7XG4gICAgZm9ybWF0ID0gQ09NTU9OX0RBVEVfRk9STUFUO1xuICB9XG5cbiAgcmV0dXJuIGRheWpzKGRhdGUpLmZvcm1hdChmb3JtYXQpO1xufVxuZnVuY3Rpb24gZm9ybWF0RGF0ZUxvY2FsKGRhdGUsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICBmb3JtYXQgPSBDT01NT05fREFURV9GT1JNQVQ7XG4gIH1cblxuICByZXR1cm4gZGF5anMoZGF0ZSkudXRjKCkuZm9ybWF0KGZvcm1hdCk7XG59XG5mdW5jdGlvbiB0aW1lc3RhbXBUb0RhdGUodGltZXN0YW1wKSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXApO1xufVxuZnVuY3Rpb24gdXRjVGltZXN0YW1wVG9EYXRlKHRpbWVzdGFtcCkge1xuICB0aW1lc3RhbXAgPSB0aW1lc3RhbXAuc2xpY2UoLTEpID09PSAnWicgPyB0aW1lc3RhbXAgOiB0aW1lc3RhbXAgKyAnWic7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXApO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wRnJvbU5vdyh0aW1lc3RhbXApIHtcbiAgcmV0dXJuIHRpbWUodGltZXN0YW1wKS5mcm9tTm93KCk7XG59XG5mdW5jdGlvbiB1dGNUaW1lc3RhbXBGcm9tTm93KHRpbWVzdGFtcCkge1xuICB0aW1lc3RhbXAgPSB0aW1lc3RhbXAuc2xpY2UoLTEpID09PSAnWicgPyB0aW1lc3RhbXAgOiB0aW1lc3RhbXAgKyAnWic7XG4gIHJldHVybiB0aW1lKHRpbWVzdGFtcCkuZnJvbU5vdygpO1xufVxuZnVuY3Rpb24gcGFyc2VUaW1lc3RhbXAodGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7XG4gICAgZm9ybWF0ID0gQ09NTU9OX0RBVEVfRk9STUFUO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdERhdGUodGltZXN0YW1wVG9EYXRlKHRpbWVzdGFtcCksIGZvcm1hdCk7XG59XG5mdW5jdGlvbiBwYXJzZVV0Y1RpbWVzdGFtcCh0aW1lc3RhbXAsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICBmb3JtYXQgPSBDT01NT05fREFURV9GT1JNQVQ7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0RGF0ZSh1dGNUaW1lc3RhbXBUb0RhdGUodGltZXN0YW1wKSwgZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGluRnV0dXJlKGRhdGUsIHV0Yykge1xuICBpZiAodXRjID09PSB2b2lkIDApIHtcbiAgICB1dGMgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB1dGMgPyB1dGNUaW1lKGRhdGUpLmlzQWZ0ZXIodXRjVGltZSgpKSA6IHRpbWUoZGF0ZSkuaXNBZnRlcih0aW1lKCkpO1xufVxuZnVuY3Rpb24gaW5QYXN0KGRhdGUsIHV0Yykge1xuICBpZiAodXRjID09PSB2b2lkIDApIHtcbiAgICB1dGMgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB1dGMgPyB1dGNUaW1lKGRhdGUpLmlzQmVmb3JlKHV0Y1RpbWUoKSkgOiB0aW1lKGRhdGUpLmlzQmVmb3JlKHRpbWUoKSk7XG59XG5mdW5jdGlvbiBpc1NhbWVEYXkoc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB2b2lkIDApIHtcbiAgICBlbmQgPSB0aW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGF5anMoc3RhcnQpLmlzU2FtZShkYXlqcyhlbmQpLCAnZGF5Jyk7XG59IC8vIFNlY29uZHMgdGlsbCBub3cgaWYgc2Vjb25kIHBhcmFtIGVtcHR5XG5cbmZ1bmN0aW9uIHNlY29uZHNGcm9tKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgZW5kID0gdGltZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRheWpzKHN0YXJ0KS5kaWZmKGRheWpzKGVuZCksICdzZWNvbmQnKTtcbn1cbmZ1bmN0aW9uIG1pbGxpc2Vjb25kc0Zyb20oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB2b2lkIDApIHtcbiAgICBlbmQgPSB0aW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGF5anMoc3RhcnQpLmRpZmYoZGF5anMoZW5kKSk7XG59XG4vKipcclxuICogU3BlY2lmaWMgdG8gRU9TXHJcbiAqL1xuXG5mdW5jdGlvbiBzdGFydERhdGUoc3RhcnREYXRlLCBkYXlzKSB7XG4gIGlmIChkYXlzID09PSB2b2lkIDApIHtcbiAgICBkYXlzID0gMztcbiAgfVxuXG4gIHJldHVybiBkYXlqcyhzdGFydERhdGUpLmNsb25lKCkuc3VidHJhY3QoZGF5cywgJ2RheXMnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFN0YXJ0RGF0ZShzdGFydFRpbWVzdGFtcCkge1xuICByZXR1cm4gc3RhcnREYXRlKHN0YXJ0VGltZXN0YW1wKS5mb3JtYXQoJ01NTS1ERC1ZWVlZLCBoaDptbTpzcyBBJyk7XG59XG5mdW5jdGlvbiBlbmREYXRlKGVuZERhdGUsIGRheXMpIHtcbiAgaWYgKGRheXMgPT09IHZvaWQgMCkge1xuICAgIGRheXMgPSAzO1xuICB9XG5cbiAgcmV0dXJuIGRheWpzKGVuZERhdGUpLmNsb25lKCkuYWRkKGRheXMsICdkYXlzJyk7XG59XG5mdW5jdGlvbiBmb3JtYXRFbmREYXRlKGVuZFRpbWVzdGFtcCkge1xuICByZXR1cm4gZW5kRGF0ZShlbmRUaW1lc3RhbXApLmZvcm1hdCgnTU1NLURELVlZWVksIGhoOm1tOnNzIEEnKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y1RpbWVQb2ludChkYXRlKSB7XG4gIGlmIChkYXRlID09PSB2b2lkIDApIHtcbiAgICBkYXRlID0gdGltZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRheWpzKGRhdGUpLnV0YygpLmZvcm1hdCgnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnKTtcbn1cbnZhciBlbXB0eVRpbWVQb2ludCA9ICcxOTcwLTAxLTAxVDAwOjAwOjAwLjAwMCc7XG5mdW5jdGlvbiBwYXJzZVNlY29uZHMoc2Vjb25kcykge1xuICB2YXIgZGF5cyA9IDA7XG4gIHZhciBob3VycyA9IDA7XG4gIHZhciBtaW51dGVzID0gMDtcbiAgdmFyIHBhcnNlZERhdGUgPSAnJzsgLy8gRGF5c1xuXG4gIGlmIChzZWNvbmRzID4gODY0MDApIHtcbiAgICBkYXlzICs9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDg2NDAwKTtcbiAgICBzZWNvbmRzIC09IGRheXMgKiA4NjQwMDtcbiAgICBwYXJzZWREYXRlICs9IGRheXMudG9GaXhlZCgwKSArIFwiIFwiICsgKGRheXMgPT09IDEgPyAnRGF5JyA6ICdEYXlzJykgKyBcIiBcIjtcbiAgfSAvLyBIb3Vyc1xuXG5cbiAgaWYgKHNlY29uZHMgPiAzNjAwKSB7XG4gICAgaG91cnMgKz0gTWF0aC5mbG9vcihzZWNvbmRzIC8gMzYwMCk7XG4gICAgc2Vjb25kcyAtPSBob3VycyAqIDM2MDA7XG4gICAgcGFyc2VkRGF0ZSArPSBob3Vycy50b0ZpeGVkKDApICsgXCIgXCIgKyAoaG91cnMgPT09IDEgPyAnSG91cicgOiAnSG91cnMnKSArIFwiIFwiO1xuICB9IC8vIE1pbnV0ZXNcblxuXG4gIGlmIChzZWNvbmRzID4gNjApIHtcbiAgICBtaW51dGVzICs9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICBzZWNvbmRzIC09IG1pbnV0ZXMgKiA2MDtcbiAgICBwYXJzZWREYXRlICs9IG1pbnV0ZXMudG9GaXhlZCgwKSArIFwiIFwiICsgKG1pbnV0ZXMgPT09IDEgPyAnTWludXRlJyA6ICdNaW51dGVzJykgKyBcIiBcIjtcbiAgfSAvLyBTZWNvbmRzXG5cblxuICBpZiAoc2Vjb25kcyA+IDApIHtcbiAgICBwYXJzZWREYXRlICs9IHNlY29uZHMudG9GaXhlZCgwKSArIFwiIFNlY29uZHMgXCI7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkRGF0ZTtcbn1cblxuZXhwb3J0cy5Bc3NldCA9IEFzc2V0O1xuZXhwb3J0cy5FeHRlbmRlZEFzc2V0ID0gRXh0ZW5kZWRBc3NldDtcbmV4cG9ydHMuRXh0ZW5kZWRTeW1ib2wgPSBFeHRlbmRlZFN5bWJvbDtcbmV4cG9ydHMuU3ltYm9sID0gU3ltYm9sJDE7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuYnl0ZXNUb0tCID0gYnl0ZXNUb0tCO1xuZXhwb3J0cy5jYWxjdWxhdGVQZXJjZW50YWdlID0gY2FsY3VsYXRlUGVyY2VudGFnZTtcbmV4cG9ydHMuY3VycmVuY3lUb1N5bWJvbCA9IGN1cnJlbmN5VG9TeW1ib2w7XG5leHBvcnRzLmRhdGVUb1V0Y1RpbWVQb2ludCA9IGRhdGVUb1V0Y1RpbWVQb2ludDtcbmV4cG9ydHMuZGlzcGxheUFzc2V0ID0gZGlzcGxheUFzc2V0O1xuZXhwb3J0cy5kaXNwbGF5TnVtYmVyID0gZGlzcGxheU51bWJlcjtcbmV4cG9ydHMuZGlzcGxheU51bWJlckFzQW1vdW50ID0gZGlzcGxheU51bWJlckFzQW1vdW50O1xuZXhwb3J0cy5kaXNwbGF5TnVtYmVyQXNBc3NldCA9IGRpc3BsYXlOdW1iZXJBc0Fzc2V0O1xuZXhwb3J0cy5kaXNwbGF5TnVtYmVyQXNDdXJyZW5jeSA9IGRpc3BsYXlOdW1iZXJBc0N1cnJlbmN5O1xuZXhwb3J0cy5kaXNwbGF5UmF3TnVtYmVyQXNBc3NldCA9IGRpc3BsYXlSYXdOdW1iZXJBc0Fzc2V0O1xuZXhwb3J0cy5kaXZpZGUgPSBkaXZpZGU7XG5leHBvcnRzLmVtcHR5VGltZVBvaW50ID0gZW1wdHlUaW1lUG9pbnQ7XG5leHBvcnRzLmVuZERhdGUgPSBlbmREYXRlO1xuZXhwb3J0cy5lb3NEaXNwbGF5Rm9ybWF0dGluZyA9IGVvc0Rpc3BsYXlGb3JtYXR0aW5nO1xuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbmV4cG9ydHMuZm9ybWF0RGF0ZUxvY2FsID0gZm9ybWF0RGF0ZUxvY2FsO1xuZXhwb3J0cy5mb3JtYXRFbmREYXRlID0gZm9ybWF0RW5kRGF0ZTtcbmV4cG9ydHMuZm9ybWF0U3RhcnREYXRlID0gZm9ybWF0U3RhcnREYXRlO1xuZXhwb3J0cy5pbkZ1dHVyZSA9IGluRnV0dXJlO1xuZXhwb3J0cy5pblBhc3QgPSBpblBhc3Q7XG5leHBvcnRzLmlzU2FtZURheSA9IGlzU2FtZURheTtcbmV4cG9ydHMubWlsbGlzZWNvbmRzRnJvbSA9IG1pbGxpc2Vjb25kc0Zyb207XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLm51bWJlclRvQW1vdW50ID0gbnVtYmVyVG9BbW91bnQ7XG5leHBvcnRzLm51bWJlclRvQW1vdW50Rm9ybWF0dGVkID0gbnVtYmVyVG9BbW91bnRGb3JtYXR0ZWQ7XG5leHBvcnRzLm51bWJlclRvQXNzZXQgPSBudW1iZXJUb0Fzc2V0O1xuZXhwb3J0cy5udW1iZXJUb0VvcyA9IG51bWJlclRvRW9zO1xuZXhwb3J0cy5udW1iZXJUb0Vvc1JvdW5kVXAgPSBudW1iZXJUb0Vvc1JvdW5kVXA7XG5leHBvcnRzLnBhcnNlQ3B1ID0gcGFyc2VDcHU7XG5leHBvcnRzLnBhcnNlTmV0QW5kUmFtID0gcGFyc2VOZXRBbmRSYW07XG5leHBvcnRzLnBhcnNlUmV4ID0gcGFyc2VSZXg7XG5leHBvcnRzLnBhcnNlU2Vjb25kcyA9IHBhcnNlU2Vjb25kcztcbmV4cG9ydHMucGFyc2VUaW1lc3RhbXAgPSBwYXJzZVRpbWVzdGFtcDtcbmV4cG9ydHMucGFyc2VVdGNUaW1lc3RhbXAgPSBwYXJzZVV0Y1RpbWVzdGFtcDtcbmV4cG9ydHMuc2Vjb25kc0Zyb20gPSBzZWNvbmRzRnJvbTtcbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbmV4cG9ydHMuc3RhcnREYXRlID0gc3RhcnREYXRlO1xuZXhwb3J0cy5zdWJzdHJhY3QgPSBzdWJzdHJhY3Q7XG5leHBvcnRzLnRpbWUgPSB0aW1lO1xuZXhwb3J0cy50aW1lc3RhbXBGcm9tTm93ID0gdGltZXN0YW1wRnJvbU5vdztcbmV4cG9ydHMudGltZXN0YW1wVG9EYXRlID0gdGltZXN0YW1wVG9EYXRlO1xuZXhwb3J0cy50b0JOID0gdG9CTjtcbmV4cG9ydHMudG9OdW1icm8gPSB0b051bWJybztcbmV4cG9ydHMudW5peFRpbWUgPSB1bml4VGltZTtcbmV4cG9ydHMudXRjVGltZSA9IHV0Y1RpbWU7XG5leHBvcnRzLnV0Y1RpbWVUb0xvY2FsID0gdXRjVGltZVRvTG9jYWw7XG5leHBvcnRzLnV0Y1RpbWVzdGFtcEZyb21Ob3cgPSB1dGNUaW1lc3RhbXBGcm9tTm93O1xuZXhwb3J0cy51dGNUaW1lc3RhbXBUb0RhdGUgPSB1dGNUaW1lc3RhbXBUb0RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXJzLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsImltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuaW1wb3J0ICdmYXN0LXRleHQtZW5jb2RpbmcnO1xuaW1wb3J0IHF1ZXJ5IGZyb20gJ3FzJztcblxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHtcbiAgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqL1xuXG4gIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH07XG5cbiAgdmFyIGV4cG9ydHMgPSB7fSxcbiAgICAgIE9wID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LFxuICAgICAgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sXG4gICAgICBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsXG4gICAgICBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsXG4gICAgICB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMFxuICAgIH0pLCBvYmpba2V5XTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcixcbiAgICAgICAgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLFxuICAgICAgICBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuICAgIHJldHVybiBnZW5lcmF0b3IuX2ludm9rZSA9IGZ1bmN0aW9uIChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgICB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgIGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcblxuICAgICAgICBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHtcbiAgICAgICAgICBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZztcbiAgICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7Oykge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG5cbiAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZztcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuICAgICAgICAgIH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgICAgc3RhdGUgPSBcImV4ZWN1dGluZ1wiO1xuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfShpbm5lckZuLCBzZWxmLCBjb250ZXh0KSwgZ2VuZXJhdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgIGFyZzogZm4uY2FsbChvYmosIGFyZylcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRocm93XCIsXG4gICAgICAgIGFyZzogZXJyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpO1xuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuXG4gICAgICBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsdWUgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIHRoaXMuX2ludm9rZSA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG5cbiAgICBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHtcbiAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkpIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcbiAgICBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdHJ5TG9jOiBsb2NzWzBdXG4gICAgfTtcbiAgICAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICB0cnlMb2M6IFwicm9vdFwiXG4gICAgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlO1xuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcblxuICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogITBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpLCBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpO1xuICB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47XG4gIH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fYXdhaXQ6IGFyZ1xuICAgIH07XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpO1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTtcblxuICAgIHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGZvciAoOyBrZXlzLmxlbmd0aDspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDtcbiAgICB9O1xuICB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChza2lwVGVtcFJlc2V0KSB7XG4gICAgICBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZG9uZSA9ICEwO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLFxuICAgICAgICAgICAgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSxcbiAgICAgICAgICAgICAgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWJydXB0OiBmdW5jdGlvbiAodHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpO1xuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIChyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuICAgIGZpbmlzaDogZnVuY3Rpb24gKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhdGNoOiBmdW5jdGlvbiAodHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfSwgZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpdCkgbyA9IGl0O1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBjbG9uZURlZXBBcnJheU9mT2JqKGFycmF5KSB7XG4gIHJldHVybiBbXS5jb25jYXQoYXJyYXkpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaSk7XG4gIH0pO1xufVxuXG52YXIgY2hhcm1hcCA9ICcuMTIzNDVhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XG5mdW5jdGlvbiBjaGFyaWR4KGNoKSB7XG4gIHZhciBpZHggPSBjaGFybWFwLmluZGV4T2YoY2gpO1xuXG4gIGlmIChpZHggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgY2hhcmFjdGVyOiAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiBpZHg7XG59XG5mdW5jdGlvbiBlbmNvZGVOYW1lKG5hbWUsIGxpdHRsZUVuZGlhbikge1xuICBpZiAobGl0dGxlRW5kaWFuID09PSB2b2lkIDApIHtcbiAgICBsaXR0bGVFbmRpYW4gPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduYW1lIHBhcmFtZXRlciBpcyBhIHJlcXVpcmVkIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKG5hbWUubGVuZ3RoID4gMTIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIG5hbWUgY2FuIGJlIHVwIHRvIDEyIGNoYXJhY3RlcnMgbG9uZycpO1xuICB9XG5cbiAgdmFyIGJpdHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IDEyOyBpKyspIHtcbiAgICAvLyBwcm9jZXNzIGFsbCA2NCBiaXRzIChldmVuIGlmIG5hbWUgaXMgc2hvcnQpXG4gICAgdmFyIGMgPSBpIDwgbmFtZS5sZW5ndGggPyBjaGFyaWR4KG5hbWVbaV0pIDogMDtcbiAgICB2YXIgYml0bGVuID0gaSA8IDEyID8gNSA6IDQ7XG4gICAgdmFyIGJpdHMgPSBOdW1iZXIoYykudG9TdHJpbmcoMik7XG5cbiAgICBpZiAoYml0cy5sZW5ndGggPiBiaXRsZW4pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuXG4gICAgYml0cyA9ICcwJy5yZXBlYXQoYml0bGVuIC0gYml0cy5sZW5ndGgpICsgYml0cztcbiAgICBiaXRzdHIgKz0gYml0cztcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyhiaXRzdHIsIHRydWUsIDIpOyAvLyBjb252ZXJ0IHRvIExJVFRMRV9FTkRJQU5cblxuICB2YXIgbGVIZXggPSAnJztcbiAgdmFyIGJ5dGVzID0gbGl0dGxlRW5kaWFuID8gdmFsdWUudG9CeXRlc0xFKCkgOiB2YWx1ZS50b0J5dGVzQkUoKTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGJ5dGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICB2YXIgYiA9IF9zdGVwLnZhbHVlO1xuICAgIHZhciBuID0gTnVtYmVyKGIpLnRvU3RyaW5nKDE2KTtcbiAgICBsZUhleCArPSAobi5sZW5ndGggPT09IDEgPyAnMCcgOiAnJykgKyBuO1xuICB9XG5cbiAgdmFyIHVsTmFtZSA9IExvbmcuZnJvbVN0cmluZyhsZUhleCwgdHJ1ZSwgMTYpLnRvU3RyaW5nKCk7IC8vIGNvbnNvbGUubG9nKCdlbmNvZGVOYW1lJywgbmFtZSwgdmFsdWUudG9TdHJpbmcoKSwgdWxOYW1lLnRvU3RyaW5nKCksIEpTT04uc3RyaW5naWZ5KGJpdHN0ci5zcGxpdCgvKC4uLi4uKS8pLnNsaWNlKDEpKSlcblxuICByZXR1cm4gdWxOYW1lLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBkZWNvZGVOYW1lKGVuY29kZWROYW1lLCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKGxpdHRsZUVuZGlhbiA9PT0gdm9pZCAwKSB7XG4gICAgbGl0dGxlRW5kaWFuID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyhlbmNvZGVkTmFtZSk7IC8vIGNvbnZlcnQgZnJvbSBMSVRUTEVfRU5ESUFOXG5cbiAgdmFyIGJlSGV4ID0gJyc7XG4gIHZhciBieXRlcyA9IGxpdHRsZUVuZGlhbiA/IHZhbHVlLnRvQnl0ZXNMRSgpIDogdmFsdWUudG9CeXRlc0JFKCk7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYnl0ZXMpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgIHZhciBiID0gX3N0ZXAyLnZhbHVlO1xuICAgIHZhciBuID0gTnVtYmVyKGIpLnRvU3RyaW5nKDE2KTtcbiAgICBiZUhleCArPSAobi5sZW5ndGggPT09IDEgPyAnMCcgOiAnJykgKyBuO1xuICB9XG5cbiAgYmVIZXggKz0gJzAnLnJlcGVhdCgxNiAtIGJlSGV4Lmxlbmd0aCk7XG4gIHZhciBmaXZlQml0cyA9IExvbmcuZnJvbU51bWJlcigweDFmLCB0cnVlKTtcbiAgdmFyIGZvdXJCaXRzID0gTG9uZy5mcm9tTnVtYmVyKDB4MGYsIHRydWUpO1xuICB2YXIgYmVWYWx1ZSA9IExvbmcuZnJvbVN0cmluZyhiZUhleCwgdHJ1ZSwgMTYpO1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciB0bXAgPSBiZVZhbHVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IDEyOyBpKyspIHtcbiAgICB2YXIgYyA9IGNoYXJtYXBbdG1wLmFuZChpID09PSAwID8gZm91ckJpdHMgOiBmaXZlQml0cyldO1xuICAgIHN0ciA9IGMgKyBzdHI7XG4gICAgdG1wID0gdG1wLnNoaWZ0UmlnaHQoaSA9PT0gMCA/IDQgOiA1KTtcbiAgfVxuXG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9cXC4rJC8sICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIGRvdHMgKGFsbCBvZiB0aGVtKVxuICAvLyBjb25zb2xlLmxvZygnZGVjb2RlTmFtZScsIHN0ciwgYmVWYWx1ZS50b1N0cmluZygpLCB2YWx1ZS50b1N0cmluZygpLCBKU09OLnN0cmluZ2lmeShiZVZhbHVlLnRvU3RyaW5nKDIpLnNwbGl0KC8oLi4uLi4pLykuc2xpY2UoMSkpKVxuXG4gIHJldHVybiBzdHI7XG59XG4vKipcclxuICogRklPIFNQRUNJRklDXHJcbiAqIEBwYXJhbSBrZXkgRklPXHJcbiAqL1xuXG52YXIgc2hvcnRlbl9rZXkgPSBmdW5jdGlvbiBzaG9ydGVuX2tleShrZXkpIHtcbiAgdmFyIHJlcyA9IG5ldyBMb25nKDAsIDAsIHRydWUpO1xuICB2YXIgaSA9IDE7IC8vIElnbm9yZSBrZXkgaGVhZFxuXG4gIHZhciBsZW4gPSAwO1xuXG4gIHdoaWxlIChsZW4gPD0gMTIpIHtcbiAgICBpZiAoaSA+PSAzMykgdGhyb3cgbmV3IEVycm9yKCdGSU86IGkgdG9vIGxhcmdlJyk7XG4gICAgdmFyIHRyaW1tZWRfY2hhciA9IGtleVtpXSAmIChsZW4gPT0gMTIgPyAweDBmIDogMHgxZik7XG5cbiAgICBpZiAodHJpbW1lZF9jaGFyID09IDApIHtcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gU2tpcCBhIHplcm8gYW5kIG1vdmUgdG8gbmV4dFxuXG5cbiAgICB2YXIgc2h1ZmZsZSA9IGxlbiA9PSAxMiA/IDAgOiA1ICogKDEyIC0gbGVuKSAtIDE7XG4gICAgcmVzID0gcmVzLm9yKExvbmcuZnJvbU51bWJlcihzaGlmdCh0cmltbWVkX2NoYXIsIHNodWZmbGUpLCB0cnVlKSk7XG4gICAgbGVuKys7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHNoaWZ0KG51bWJlciwgc2hpZnQpIHtcbiAgcmV0dXJuIG51bWJlciAqIE1hdGgucG93KDIsIHNoaWZ0KTtcbn1cblxudmFyIGZpb0tleVRvQWN0b3IgPSBmdW5jdGlvbiBmaW9LZXlUb0FjdG9yKGtleSwgc3RyaW5nVG9QdWJsaWNLZXkpIHtcbiAgdmFyIHB1YktleSA9IHN0cmluZ1RvUHVibGljS2V5KGtleSwgJ0ZJTycpLmRhdGE7XG4gIHZhciBzaG9ydGVuZWRQdWJLZXkgPSBzaG9ydGVuX2tleShwdWJLZXkpO1xuICB2YXIgZGVjb2RlZE5hbWUgPSBkZWNvZGVOYW1lKHNob3J0ZW5lZFB1YktleS50b1N0cmluZygpLCBmYWxzZSk7XG4gIHJldHVybiBkZWNvZGVkTmFtZS5zdWJzdHIoMCwgMTIpO1xufTsgLy8gY29udmVydCBieXRlcyB0byBhIFN0cmluZ1xuXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfYnl0ZSkge1xuICAgIHJldHVybiBhY2MgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKF9ieXRlKTtcbiAgfSwgJycpO1xufVxuLyoqXHJcbiAqIENoZWNrcyBpZiBzdHJpbmdcclxuICovXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHN0cmluZykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0cmluZykgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBtZXNzYWdlIFNoYTI1NlxyXG4gKi9cblxuZnVuY3Rpb24gc2hhKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX3NoYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLyoqXHJcbiAqIEZJTyBmdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0gc3RyIGV4YW1wbGU6IGNvaW5vbWlcclxuICogQHJldHVybnMgcmV0dXJuczogOTY4YmE4NDYxN2I3M2I4ZTJhNzNiNTkxNzA5NzZmNDFcclxuICovXG5cbmZ1bmN0aW9uIF9zaGEoKSB7XG4gIF9zaGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobWVzc2FnZSwgYmluYXJ5UmVwcmVzZW50YXRpb25PZkhleCwgdHlwZSkge1xuICAgIHZhciBlbmNvZGVkTWVzc2FnZSwgbWF0Y2hlZCwgbWFwcGVkLCBoYXNoQnVmZmVyLCBoYXNoQXJyYXksIGhhc2hIZXg7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGJpbmFyeVJlcHJlc2VudGF0aW9uT2ZIZXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBiaW5hcnlSZXByZXNlbnRhdGlvbk9mSGV4ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdHlwZSA9ICdTSEEtMjU2JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFiaW5hcnlSZXByZXNlbnRhdGlvbk9mSGV4KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGNoZWQgPSBtZXNzYWdlLm1hdGNoKC9bXFxkYS1mXXsyfS9naSk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0VtcHR5IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIG1hcHBlZCA9IG1hdGNoZWQubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChoLCAxNik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVuY29kZWRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWFwcGVkKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGVuY29kZWRNZXNzYWdlID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRpZ2VzdCh0eXBlLCBlbmNvZGVkTWVzc2FnZSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgaGFzaEJ1ZmZlciA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAvLyBoYXNoIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICBoYXNoQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGhhc2hCdWZmZXIpKTsgLy8gY29udmVydCBidWZmZXIgdG8gYnl0ZSBhcnJheVxuXG4gICAgICAgICAgICBoYXNoSGV4ID0gaGFzaEFycmF5Lm1hcChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICByZXR1cm4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgICAgIH0pLmpvaW4oJycpOyAvLyBjb252ZXJ0IGJ5dGVzIHRvIGhleCBzdHJpbmdcblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBoYXNoSGV4KTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfc2hhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ190b191aW50MTI4X2hhc2goX3g0KSB7XG4gIHJldHVybiBfc3RyaW5nX3RvX3VpbnQxMjhfaGFzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfc3RyaW5nX3RvX3VpbnQxMjhfaGFzaCgpIHtcbiAgX3N0cmluZ190b191aW50MTI4X2hhc2ggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHN0cikge1xuICAgIHZhciBoZXhCeXRlcztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHNoYShzdHIsIGZhbHNlLCAnU0hBLTEnKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhleEJ5dGVzID0gX2NvbnRleHQyLnNlbnQubWF0Y2goLy4uL2cpO1xuXG4gICAgICAgICAgICBpZiAoIWhleEJ5dGVzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGhleEJ5dGVzLnNsaWNlKDAsIC00KS5yZXZlcnNlKCkuam9pbignJykpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgMCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9zdHJpbmdfdG9fdWludDEyOF9oYXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG5hdGl2ZVRyYW5zZm9ybUdldEFjdGlvbnMocmVzdWx0LCBjb25zdGFudHMpIHtcbiAgcmVzdWx0LmFjdGlvbnMgPSByZXN1bHQuYWN0aW9ucy5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgIGlmIChhY3Rpb25bJ2FjdGlvbl90cmFjZSddWydhY3QnXVsnYWNjb3VudCddID09PSBjb25zdGFudHMuRU9TSU8gJiYgYWN0aW9uWydhY3Rpb25fdHJhY2UnXVsnYWN0J11bJ25hbWUnXSA9PT0gJ2NsYWltcmV3YXJkcycgJiYgYWN0aW9uWydhY3Rpb25fdHJhY2UnXVsnaW5saW5lX3RyYWNlcyddKSB7XG4gICAgICB2YXIgdG90YWxBbW91bnQgPSAwO1xuICAgICAgdmFyIHRvdGFsU3ltYm9sID0gJyc7XG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWN0aW9uWydhY3Rpb25fdHJhY2UnXVsnaW5saW5lX3RyYWNlcyddKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGlubGluZV90cmFjZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIGlmIChpbmxpbmVfdHJhY2VbJ2FjdCddWydkYXRhJ11bJ2Zyb20nXSA9PT0gY29uc3RhbnRzLkVPU0lPX1ZQQVkgfHwgaW5saW5lX3RyYWNlWydhY3QnXVsnZGF0YSddWydmcm9tJ10gPT09IGNvbnN0YW50cy5FT1NJT19CUEFZKSB7XG4gICAgICAgICAgdmFyIF9pbmxpbmVfdHJhY2UkYWN0JGRhdCA9IGlubGluZV90cmFjZVsnYWN0J11bJ2RhdGEnXVsncXVhbnRpdHknXS5zcGxpdCgnICcpLFxuICAgICAgICAgICAgICBhbW91bnQgPSBfaW5saW5lX3RyYWNlJGFjdCRkYXRbMF0sXG4gICAgICAgICAgICAgIHN5bWJvbCA9IF9pbmxpbmVfdHJhY2UkYWN0JGRhdFsxXTtcblxuICAgICAgICAgIHRvdGFsQW1vdW50ICs9IE51bWJlcihhbW91bnQpO1xuICAgICAgICAgIHRvdGFsU3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFjdGlvblsnYWN0aW9uX3RyYWNlJ11bJ2FjdCddWydkYXRhJ11bJ3F1YW50aXR5J10gPSB0b3RhbEFtb3VudC50b0ZpeGVkKGNvbnN0YW50cy5DT1JFX1BSRUNJU0lPTikgKyBcIiBcIiArIHRvdGFsU3ltYm9sO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH0pLnJldmVyc2UoKTtcbiAgcmVzdWx0Lm51bU9mVHhMb2FkZWQgPSByZXN1bHQuYWN0aW9ucy5sZW5ndGg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoeXBlcmlvblRyYW5zZm9ybUdldEFjdGlvbnMoX3JlZikge1xuICB2YXIgcXVlcnlfdGltZSA9IF9yZWYucXVlcnlfdGltZSxcbiAgICAgIGxpYiA9IF9yZWYubGliLFxuICAgICAgYWN0aW9ucyA9IF9yZWYuYWN0aW9ucyxcbiAgICAgIF9yZWYkdG90YWwgPSBfcmVmLnRvdGFsLFxuICAgICAgcmVsYXRpb24gPSBfcmVmJHRvdGFsLnJlbGF0aW9uLFxuICAgICAgdmFsdWUgPSBfcmVmJHRvdGFsLnZhbHVlO1xuICB2YXIgdHJhbnNmb3JtZWRBY3Rpb25zID0gW107XG4gIHZhciBhY3RfZGlnZXN0ID0gMDtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY3Rpb25zKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICB2YXIgYWN0aW9uID0gX3N0ZXAyLnZhbHVlO1xuICAgIGFjdGlvbi5yZWNlaXB0ID0ge1xuICAgICAgYWN0X2RpZ2VzdDogYWN0X2RpZ2VzdCsrXG4gICAgfTtcbiAgICBhY3Rpb24uYmxvY2tfdGltZSA9IGFjdGlvblsnQHRpbWVzdGFtcCddOyAvLyBTZXQgcXVhbnRpdHlcblxuICAgIGlmIChhY3Rpb24uYWN0LmRhdGEgJiYgYWN0aW9uLmFjdC5kYXRhLmFtb3VudCAmJiBhY3Rpb24uYWN0LmRhdGEuc3ltYm9sKSB7XG4gICAgICBhY3Rpb24uYWN0LmRhdGEucXVhbnRpdHkgPSBhY3Rpb24uYWN0LmRhdGEuYW1vdW50ICsgXCIgXCIgKyBhY3Rpb24uYWN0LmRhdGEuc3ltYm9sO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybWVkQWN0aW9ucy5wdXNoKHtcbiAgICAgIGFjdGlvbl90cmFjZTogYWN0aW9uXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpYjogbGliLFxuICAgIGFjdGlvbnM6IHRyYW5zZm9ybWVkQWN0aW9ucyxcbiAgICBxdWVyeV90aW1lOiBxdWVyeV90aW1lLFxuICAgIG51bU9mVHhMb2FkZWQ6IGFjdGlvbnMubGVuZ3RoLFxuICAgIHRvdGFsOiB7XG4gICAgICByZWxhdGlvbjogcmVsYXRpb24sXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZnVzZVRyYW5zZm9ybUdldEFjdGlvbnMoX3JlZjIsIGFjY291bnROYW1lLCBjb25zdGFudHMpIHtcbiAgdmFyIHRyYW5zYWN0aW9ucyA9IF9yZWYyLnRyYW5zYWN0aW9ucyxcbiAgICAgIGN1cnNvciA9IF9yZWYyLmN1cnNvcjtcblxuICAvLyBFcnJvciBjaGVja2luZ1xuICBpZiAoIXRyYW5zYWN0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBjdXJzb3I6IGN1cnNvcixcbiAgICAgIGFjdGlvbnM6IFtdLFxuICAgICAgbnVtT2ZUeExvYWRlZDogMFxuICAgIH07XG4gIH1cblxuICB2YXIgYWN0aW9ucyA9IFtdO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRyYW5zYWN0aW9ucyksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uID0gX3N0ZXAzLnZhbHVlO1xuICAgIHZhciBsaWZlY3ljbGUgPSB0cmFuc2FjdGlvbi5saWZlY3ljbGUsXG4gICAgICAgIGFjdGlvbl9pZHggPSB0cmFuc2FjdGlvbi5hY3Rpb25faWR4OyAvLyBHUkFQSFFMIC0+IERPZXNudCBnaXZlIGFjdGlvbl9pZHggc2luY2UgaXRzIG1hdGNoXG5cbiAgICBpZiAoIWFjdGlvbl9pZHgpIHtcbiAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChsaWZlY3ljbGVbJ2V4ZWN1dGlvbl90cmFjZSddWydhY3Rpb25fdHJhY2VzJ10ubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY3Rpb25fdHJhY2U6IGFjdGlvblxuICAgICAgICB9O1xuICAgICAgfSkucmV2ZXJzZSgpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50X2lkeCA9IDA7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShsaWZlY3ljbGVbJ2V4ZWN1dGlvbl90cmFjZSddWydhY3Rpb25fdHJhY2VzJ10pLCBfc3RlcDQ7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNCgpKS5kb25lOykge1xuICAgICAgdmFyIGFjdGlvbl90cmFjZSA9IF9zdGVwNC52YWx1ZTtcbiAgICAgIC8vIEZpeCBob2xlc1xuICAgICAgaWYgKCFhY3Rpb25fdHJhY2VbJ2lubGluZV90cmFjZXMnXSkgYWN0aW9uX3RyYWNlWydpbmxpbmVfdHJhY2VzJ10gPSBbXTsgLy8gQlAgQ0xBSU0gUkVXQVJEU1xuXG4gICAgICBpZiAoYWN0aW9uX3RyYWNlWydhY3QnXVsnYWNjb3VudCddID09PSBjb25zdGFudHMuRU9TSU8gJiYgYWN0aW9uX3RyYWNlWydhY3QnXVsnbmFtZSddID09PSAnY2xhaW1yZXdhcmRzJykge1xuICAgICAgICB2YXIgdG90YWxBbW91bnQgPSAwO1xuICAgICAgICB2YXIgdG90YWxTeW1ib2wgPSAnJztcblxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY3Rpb25fdHJhY2VbJ2lubGluZV90cmFjZXMnXSksIF9zdGVwNTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1KCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGlubGluZV90cmFjZSA9IF9zdGVwNS52YWx1ZTtcblxuICAgICAgICAgIGlmIChpbmxpbmVfdHJhY2VbJ2FjdCddWydkYXRhJ11bJ2Zyb20nXSA9PT0gY29uc3RhbnRzLkVPU0lPX1ZQQVkgfHwgaW5saW5lX3RyYWNlWydhY3QnXVsnZGF0YSddWydmcm9tJ10gPT09IGNvbnN0YW50cy5FT1NJT19CUEFZKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICBhY3Rpb25fdHJhY2U6IGlubGluZV90cmFjZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBfaW5saW5lX3RyYWNlJGFjdCRkYXQyID0gaW5saW5lX3RyYWNlWydhY3QnXVsnZGF0YSddWydxdWFudGl0eSddLnNwbGl0KCcgJyksXG4gICAgICAgICAgICAgICAgYW1vdW50ID0gX2lubGluZV90cmFjZSRhY3QkZGF0MlswXSxcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfaW5saW5lX3RyYWNlJGFjdCRkYXQyWzFdO1xuXG4gICAgICAgICAgICB0b3RhbEFtb3VudCArPSBOdW1iZXIoYW1vdW50KTtcbiAgICAgICAgICAgIHRvdGFsU3ltYm9sID0gc3ltYm9sO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFjdGlvbl90cmFjZVsnYWN0J11bJ2RhdGEnXVsncXVhbnRpdHknXSA9IHRvdGFsQW1vdW50LnRvRml4ZWQoY29uc3RhbnRzLkNPUkVfUFJFQ0lTSU9OKSArIFwiIFwiICsgdG90YWxTeW1ib2w7XG4gICAgICAgIGRlbGV0ZSBhY3Rpb25fdHJhY2UuaW5saW5lX3RyYWNlcztcbiAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBhY3Rpb25fdHJhY2U6IGFjdGlvbl90cmFjZVxuICAgICAgICB9KTsgLy8gUkVYIHNlbGxcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uX3RyYWNlWydhY3QnXVsnYWNjb3VudCddID09PSBjb25zdGFudHMuRU9TSU8gJiYgYWN0aW9uX3RyYWNlWydhY3QnXVsnbmFtZSddID09PSAnc2VsbHJleCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWN0aW9uX3RyYWNlWydpbmxpbmVfdHJhY2VzJ10pLCBfc3RlcDY7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfaW5saW5lX3RyYWNlID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKF9pbmxpbmVfdHJhY2VbJ2FjdCddWydhY2NvdW50J10gPT09IGNvbnN0YW50cy5FT1NJT19SRVggfHwgX2lubGluZV90cmFjZVsnYWN0J11bJ25hbWUnXSA9PT0gJ3NlbGxyZXN1bHQnKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICBhY3Rpb25fdHJhY2U6IF9pbmxpbmVfdHJhY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBhY3Rpb25fdHJhY2UuaW5saW5lX3RyYWNlcztcbiAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBhY3Rpb25fdHJhY2U6IGFjdGlvbl90cmFjZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSBmb3Igb3JkZXJpbmcgb2YgVFhcbiAgICAgICAgdmFyIGxvY2FsX2FjdGlvbnMgPSBbXTtcbiAgICAgICAgY3VycmVudF9pZHggPSBkZnVzZUV4dHJhY3RBY3Rpb25zKGFjY291bnROYW1lLCBhY3Rpb25fdHJhY2UsIGxvY2FsX2FjdGlvbnMsIGFjdGlvbl9pZHgsIGN1cnJlbnRfaWR4KTtcbiAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KGxvY2FsX2FjdGlvbnMucmV2ZXJzZSgpKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudF9pZHgrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGN1cnNvcjogY3Vyc29yLFxuICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgbnVtT2ZUeExvYWRlZDogdHJhbnNhY3Rpb25zLmxlbmd0aFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZnVzZUV4dHJhY3RBY3Rpb25zKGFjY291bnROYW1lLCBhY3Rpb24sIHRyYWNlcywgYWN0aW9uX2lkeCwgY3VycmVudF9pZHgpIHtcbiAgaWYgKGFjdGlvbl9pZHguaW5jbHVkZXMoY3VycmVudF9pZHgpKSB7XG4gICAgdHJhY2VzLnB1c2goe1xuICAgICAgYWN0aW9uX3RyYWNlOiBhY3Rpb25cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhY3Rpb25bJ2lubGluZV90cmFjZXMnXSkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjdGlvblsnaW5saW5lX3RyYWNlcyddKSwgX3N0ZXA3OyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcoKSkuZG9uZTspIHtcbiAgICAgIHZhciBpbmxpbmVfdHJhY2UgPSBfc3RlcDcudmFsdWU7XG4gICAgICBjdXJyZW50X2lkeCsrO1xuICAgICAgY3VycmVudF9pZHggPSBkZnVzZUV4dHJhY3RBY3Rpb25zKGFjY291bnROYW1lLCBpbmxpbmVfdHJhY2UsIHRyYWNlcywgYWN0aW9uX2lkeCwgY3VycmVudF9pZHgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBhY3Rpb25bJ2lubGluZV90cmFjZXMnXTtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50X2lkeDtcbn1cblxuZnVuY3Rpb24gZGZ1c2VEZXB0aEZpcnN0RXh0cmFjdChyZXN1bHQpIHtcbiAgdmFyIHRyYW5zYWN0aW9ucyA9IHJlc3VsdC50cmFuc2FjdGlvbnMsXG4gICAgICBjdXJzb3IgPSByZXN1bHQuY3Vyc29yO1xuICB2YXIgYWN0aW9ucyA9IFtdO1xuXG4gIGlmICh0cmFuc2FjdGlvbnMpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0cmFuc2FjdGlvbnMpLCBfc3RlcDg7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOCgpKS5kb25lOykge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gX3N0ZXA4LnZhbHVlO1xuICAgICAgdmFyIGxpZmVjeWNsZSA9IHRyYW5zYWN0aW9uLmxpZmVjeWNsZSxcbiAgICAgICAgICBhY3Rpb25faWR4ID0gdHJhbnNhY3Rpb24uYWN0aW9uX2lkeDtcbiAgICAgIHZhciB0cmFjZXMgPSBsaWZlY3ljbGVbJ2V4ZWN1dGlvbl90cmFjZSddWydhY3Rpb25fdHJhY2VzJ107XG4gICAgICB2YXIgY3VycmVudF9pZHggPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3I5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0cmFjZXMpLCBfc3RlcDk7ICEoX3N0ZXA5ID0gX2l0ZXJhdG9yOSgpKS5kb25lOykge1xuICAgICAgICB2YXIgdHJhY2UgPSBfc3RlcDkudmFsdWU7XG4gICAgICAgIGN1cnJlbnRfaWR4ID0gZGZ1c2VEZXB0aEZpcnN0RXh0cmFjdEhlbHBlcih0cmFjZSwgbGlmZWN5Y2xlWydkYm9wcyddLCBhY3Rpb25zLCBhY3Rpb25faWR4LCBjdXJyZW50X2lkeCk7XG4gICAgICAgIGN1cnJlbnRfaWR4Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgIGN1cnNvcjogY3Vyc29yXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRmdXNlRGVwdGhGaXJzdEV4dHJhY3RIZWxwZXIoYWN0aW9uLCBkYm9wcywgYWxsQWN0aW9ucywgYWN0aW9uX2lkeCwgY3VycmVudElkeCkge1xuICBpZiAoYWN0aW9uX2lkeCAmJiBhY3Rpb25faWR4LmluY2x1ZGVzKGN1cnJlbnRJZHgpKSB7XG4gICAgYWxsQWN0aW9ucy5wdXNoKHtcbiAgICAgIGFjdGlvbl90cmFjZTogYWN0aW9uLFxuICAgICAgZGJvcHM6IGRib3BzLmZpbHRlcihmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIG9wLmFjdGlvbl9pZHggPT09IGN1cnJlbnRJZHg7XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFjdGlvblsnaW5saW5lX3RyYWNlcyddKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMTAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjdGlvblsnaW5saW5lX3RyYWNlcyddKSwgX3N0ZXAxMDsgIShfc3RlcDEwID0gX2l0ZXJhdG9yMTAoKSkuZG9uZTspIHtcbiAgICAgIHZhciB0cmFjZSA9IF9zdGVwMTAudmFsdWU7XG4gICAgICBjdXJyZW50SWR4ID0gZGZ1c2VEZXB0aEZpcnN0RXh0cmFjdEhlbHBlcih0cmFjZSwgZGJvcHMsIGFsbEFjdGlvbnMsIGFjdGlvbl9pZHgsICsrY3VycmVudElkeCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRJZHg7XG59XG5cbmZ1bmN0aW9uIGh5cGVyaW9uVHJhbnNmb3JtRmxhdFRyYWNlcyh0cmFjZXMpIHtcbiAgdmFyIHRyYWNlc0J5T3JkaW5hbCA9IHRyYWNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHJhY2UpIHtcbiAgICBhY2NbdHJhY2UuYWN0aW9uX29yZGluYWxdID0gX2V4dGVuZHMoe30sIHRyYWNlLCB7XG4gICAgICB0cmFjZXM6IFtdLFxuICAgICAgYWNjb3VudF9yYW1fZGVsdGFzOiB0cmFjZS5hY2NvdW50X3JhbV9kZWx0YXMsXG4gICAgICByZWNlaXZlcnM6IHRyYWNlLm5vdGlmaWVkXG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvcjExID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0cmFjZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFjdGlvbl9vcmRpbmFsIC0gYS5hY3Rpb25fb3JkaW5hbDtcbiAgfSkpLCBfc3RlcDExOyAhKF9zdGVwMTEgPSBfaXRlcmF0b3IxMSgpKS5kb25lOykge1xuICAgIHZhciB0cmFjZSA9IF9zdGVwMTEudmFsdWU7XG5cbiAgICAvLyBTa2lwIHRvcCBsZXZlbCBhY3Rpb25zXG4gICAgaWYgKHRyYWNlLmNyZWF0b3JfYWN0aW9uX29yZGluYWwgPT09IDAgfHwgIXRyYWNlc0J5T3JkaW5hbFt0cmFjZS5jcmVhdG9yX2FjdGlvbl9vcmRpbmFsXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRJbmxpbmVUcmFjZXMgPSB0cmFjZXNCeU9yZGluYWxbdHJhY2UuY3JlYXRvcl9hY3Rpb25fb3JkaW5hbF0udHJhY2VzIHx8IFtdO1xuICAgIHZhciBuZXdJbmxpbmVUcmFjZXMgPSBbdHJhY2VzQnlPcmRpbmFsW3RyYWNlLmFjdGlvbl9vcmRpbmFsXV07XG4gICAgZGVsZXRlIHRyYWNlc0J5T3JkaW5hbFt0cmFjZS5hY3Rpb25fb3JkaW5hbF07XG4gICAgdHJhY2VzQnlPcmRpbmFsW3RyYWNlLmNyZWF0b3JfYWN0aW9uX29yZGluYWxdLnRyYWNlcyA9IG5ld0lubGluZVRyYWNlcy5jb25jYXQoY3VycmVudElubGluZVRyYWNlcyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gT2JqZWN0LnZhbHVlcyh0cmFjZXNCeU9yZGluYWwpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaHlwZXJpb25UcmFuc2Zvcm1UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICB2YXIgYWN0aW9ucyA9IHRyYW5zYWN0aW9uLmFjdGlvbnMsXG4gICAgICBsaWIgPSB0cmFuc2FjdGlvbi5saWIsXG4gICAgICB0cnhfaWQgPSB0cmFuc2FjdGlvbi50cnhfaWQ7XG4gIHZhciBmaXJzdEFjdGlvbiA9IGFjdGlvbnNbMF07IC8vIFBhcmVudCBvbmx5IG9uIDwgMS44XG5cbiAgdmFyIHRyYW5zZm9ybWVkQWN0aW9ucyA9IGZpcnN0QWN0aW9uLnBhcmVudCA/IGFjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uICh0cmFjZSkge1xuICAgIHJldHVybiB0cmFjZS5wYXJlbnQgPT09IDA7XG4gIH0pIDogYWN0aW9ucztcbiAgdmFyIHRyYWNlcyA9IGh5cGVyaW9uVHJhbnNmb3JtRmxhdFRyYWNlcyhhY3Rpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6ICdFeGVjdXRlZCcsXG4gICAgY3B1X3VzYWdlOiBmaXJzdEFjdGlvbi5jcHVfdXNhZ2VfdXMsXG4gICAgbmV0X3VzYWdlOiBmaXJzdEFjdGlvbi5uZXRfdXNhZ2Vfd29yZHMgKiA4LFxuICAgIGlkOiB0cnhfaWQsXG4gICAgYmxvY2tfdGltZTogZmlyc3RBY3Rpb25bJ0B0aW1lc3RhbXAnXSxcbiAgICBibG9ja19udW06IGZpcnN0QWN0aW9uWydibG9ja19udW0nXSxcbiAgICBkZWxheV9zZWM6ICdOL0EnLFxuICAgIGV4cGlyYXRpb246ICdOL0EnLFxuICAgIGxpYjogbGliLFxuICAgIGFjdGlvbnM6IHRyYW5zZm9ybWVkQWN0aW9ucyxcbiAgICB0cmFjZXM6IHRyYWNlc1xuICB9O1xufVxuZnVuY3Rpb24gZGZ1c2VUcmFuc2Zvcm1UcmFjZShfcmVmMykge1xuICB2YXIgdHJhY2UgPSBfcmVmMy50cmFjZSxcbiAgICAgIF9yZWYzJGRib3BzID0gX3JlZjMuZGJvcHMsXG4gICAgICBkYm9wcyA9IF9yZWYzJGRib3BzID09PSB2b2lkIDAgPyBbXSA6IF9yZWYzJGRib3BzLFxuICAgICAgX3JlZjMkcmFtb3BzID0gX3JlZjMucmFtb3BzLFxuICAgICAgcmFtb3BzID0gX3JlZjMkcmFtb3BzID09PSB2b2lkIDAgPyBbXSA6IF9yZWYzJHJhbW9wcyxcbiAgICAgIF9yZWYzJGluZGV4ID0gX3JlZjMuaW5kZXgsXG4gICAgICBpbmRleCA9IF9yZWYzJGluZGV4ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkaW5kZXg7XG4gIHZhciB0cmFuc2Zvcm1lZCA9IHtcbiAgICBhY3Q6IHRyYWNlLmFjdCxcbiAgICBhY2NvdW50X3JhbV9kZWx0YXM6IHRyYWNlLmFjY291bnRfcmFtX2RlbHRhcyxcbiAgICByZWNlaXZlcnM6IFt0cmFjZS5yZWNlaXB0LnJlY2VpdmVyXSxcbiAgICBhY3RfZGlnZXN0OiB0cmFjZS5yZWNlaXB0LmFjdF9kaWdlc3QsXG4gICAgZGJvcHM6IChkYm9wcyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChvcCkge1xuICAgICAgcmV0dXJuIG9wLmFjdGlvbl9pZHggPT09IGluZGV4O1xuICAgIH0pLFxuICAgIHJhbW9wczogKHJhbW9wcyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChvcCkge1xuICAgICAgcmV0dXJuIG9wLmFjdGlvbl9pZHggPT09IGluZGV4O1xuICAgIH0pLFxuICAgIHRyYWNlczogW11cbiAgfTtcblxuICBpZiAodHJhY2UuaW5saW5lX3RyYWNlcyAmJiB0cmFjZS5pbmxpbmVfdHJhY2VzLmxlbmd0aCkge1xuICAgIHRyYWNlLmlubGluZV90cmFjZXMubWFwKGZ1bmN0aW9uIChpdHJhY2UpIHtcbiAgICAgIGluZGV4Kys7IC8vIElmIFRYIGRhdGEgaXMgZGlmZmVyZW50XG5cbiAgICAgIGlmIChpdHJhY2UuYWN0LmhleF9kYXRhICE9PSB0cmFuc2Zvcm1lZC5hY3QuaGV4X2RhdGEgfHwgaXRyYWNlLmFjdC5uYW1lICE9PSB0cmFuc2Zvcm1lZC5hY3QubmFtZSB8fCBpdHJhY2UuYWN0LmFjY291bnQgIT09IHRyYW5zZm9ybWVkLmFjdC5hY2NvdW50KSB7XG4gICAgICAgIHRyYW5zZm9ybWVkLnRyYWNlcy5wdXNoKGRmdXNlVHJhbnNmb3JtVHJhY2Uoe1xuICAgICAgICAgIHRyYWNlOiBpdHJhY2UsXG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIHJhbW9wczogcmFtb3BzLFxuICAgICAgICAgIGRib3BzOiBkYm9wc1xuICAgICAgICB9KSk7IC8vIEhleCBkYXRhIGlzIHNhbWUsIGJ1dCBzdGlsbCBhZGQgaW4gaW5saW5lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRyYWNlLmlubGluZV90cmFjZXMgJiYgaXRyYWNlLmlubGluZV90cmFjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGl0cmFjZS5pbmxpbmVfdHJhY2VzKSwgX3N0ZXAxMjsgIShfc3RlcDEyID0gX2l0ZXJhdG9yMTIoKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBpaXRyYWNlID0gX3N0ZXAxMi52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZC50cmFjZXMucHVzaChkZnVzZVRyYW5zZm9ybVRyYWNlKHtcbiAgICAgICAgICAgICAgdHJhY2U6IGlpdHJhY2UsXG4gICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgcmFtb3BzOiByYW1vcHMsXG4gICAgICAgICAgICAgIGRib3BzOiBkYm9wc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBBZGQgUmVjZWl2ZXJzIGV2ZW4gaWYgbm90IGRpZmZlcmVudFxuXG5cbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1lZC5yZWNlaXZlcnMuaW5jbHVkZXMoaXRyYWNlLnJlY2VpcHQucmVjZWl2ZXIpKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWQucmVjZWl2ZXJzLnB1c2goaXRyYWNlLnJlY2VpcHQucmVjZWl2ZXIpO1xuICAgICAgICB9IC8vIEFkZCBkYiBvcHMgYW5kIHJhbSBvcHMgZXZlbiBpZiBub3QgZGlmZmVyZW50XG5cblxuICAgICAgICB0cmFuc2Zvcm1lZC5kYm9wcyA9IHRyYW5zZm9ybWVkLmRib3BzLmNvbmNhdCgoZGJvcHMgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICByZXR1cm4gb3AuYWN0aW9uX2lkeCA9PT0gaW5kZXg7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdHJhbnNmb3JtZWQucmFtb3BzID0gdHJhbnNmb3JtZWQucmFtb3BzLmNvbmNhdCgocmFtb3BzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgcmV0dXJuIG9wLmFjdGlvbl9pZHggPT09IGluZGV4O1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtZWQ7XG59XG5mdW5jdGlvbiBkZnVzZVRyYW5zZm9ybVRyYW5zYWN0aW9uKHJlc3VsdCkge1xuICB2YXIgZXhlY3V0aW9uX3RyYWNlID0gcmVzdWx0LmV4ZWN1dGlvbl90cmFjZSxcbiAgICAgIHRyYW5zYWN0aW9uID0gcmVzdWx0LnRyYW5zYWN0aW9uLFxuICAgICAgcmFtb3BzID0gcmVzdWx0LnJhbW9wcyxcbiAgICAgIGRib3BzID0gcmVzdWx0LmRib3BzLFxuICAgICAgY3JlYXRlZF9ieSA9IHJlc3VsdC5jcmVhdGVkX2J5O1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgYWN0aW9ucyA9IChleGVjdXRpb25fdHJhY2VbJ2FjdGlvbl90cmFjZXMnXSB8fCBbXSkubWFwKGZ1bmN0aW9uICh0cmFjZSkge1xuICAgIHZhciB0cmFuc2Zvcm1lZFRyYWNlID0gZGZ1c2VUcmFuc2Zvcm1UcmFjZSh7XG4gICAgICB0cmFjZTogdHJhY2UsXG4gICAgICByYW1vcHM6IHJhbW9wcyxcbiAgICAgIGRib3BzOiBkYm9wcyxcbiAgICAgIGluZGV4OiBjb3VudFxuICAgIH0pOyAvLyBJbmNyZW1lbnQgY291bnRzXG5cbiAgICB2YXIgdHJhY2VDb3VudCA9IGlubGluZVRyYWNlQ291bnRIZWxwZXIoW3RyYWNlXSk7XG4gICAgY291bnQgKz0gdHJhY2VDb3VudDtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWRUcmFjZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiBleGVjdXRpb25fdHJhY2UucmVjZWlwdC5zdGF0dXMsXG4gICAgY3B1X3VzYWdlOiBleGVjdXRpb25fdHJhY2UucmVjZWlwdC5jcHVfdXNhZ2VfdXMsXG4gICAgbmV0X3VzYWdlOiBleGVjdXRpb25fdHJhY2UucmVjZWlwdC5uZXRfdXNhZ2Vfd29yZHMgKiA4LFxuICAgIGlkOiBleGVjdXRpb25fdHJhY2UuaWQsXG4gICAgYmxvY2tfdGltZTogZXhlY3V0aW9uX3RyYWNlLmJsb2NrX3RpbWUsXG4gICAgYmxvY2tfbnVtOiBleGVjdXRpb25fdHJhY2UuYmxvY2tfbnVtLFxuICAgIGRlbGF5X3NlYzogdHJhbnNhY3Rpb24uZGVsYXlfc2VjLFxuICAgIGV4cGlyYXRpb246IHRyYW5zYWN0aW9uLmV4cGlyYXRpb24sXG4gICAgY3JlYXRlZF9ieTogY3JlYXRlZF9ieSxcbiAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgIHRyYWNlczogYWN0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gZGZ1c2VUcmFuc2Zvcm1EZWZlcnJlZEFjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBhY3Q6IF9leHRlbmRzKHt9LCBhY3Rpb24pLFxuICAgIGFjY291bnRfcmFtX2RlbHRhczogW10sXG4gICAgcmVjZWl2ZXJzOiBbXSxcbiAgICBhY3RfZGlnZXN0OiAnJyxcbiAgICB0cmFjZXM6IFtdXG4gIH07XG59XG5mdW5jdGlvbiBkZnVzZVRyYW5zZm9ybURlZmVycmVkVHJhbnNhY3Rpb24ocmVzdWx0KSB7XG4gIHZhciBhY3Rpb25zID0gcmVzdWx0LnRyYW5zYWN0aW9uLmFjdGlvbnMubWFwKGRmdXNlVHJhbnNmb3JtRGVmZXJyZWRBY3Rpb24pO1xuICByZXR1cm4ge1xuICAgIGlkOiByZXN1bHQuaWQsXG4gICAgc3RhdHVzOiAnZGVmZXJyZWQnLFxuICAgIGRmdXNlX3N0YXR1czogcmVzdWx0LnRyYW5zYWN0aW9uX3N0YXR1cyxcbiAgICBzZW5kZXI6IHJlc3VsdC5jcmVhdGVkX2J5LnNlbmRlcixcbiAgICBwYXllcjogcmVzdWx0LmNyZWF0ZWRfYnkucGF5ZXIsXG4gICAgcHVibGlzaGVkOiByZXN1bHQuY3JlYXRlZF9ieS5wdWJsaXNoZWRfYXQsXG4gICAgZGVsYXlfdW50aWw6IHJlc3VsdC5jcmVhdGVkX2J5LmRlbGF5X3VudGlsLFxuICAgIGV4cGlyYXRpb246IHJlc3VsdC50cmFuc2FjdGlvbi5leHBpcmF0aW9uLFxuICAgIGRlbGF5X3NlYzogcmVzdWx0LnRyYW5zYWN0aW9uLmRlbGF5X3NlYyxcbiAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgIHRyYWNlczogYWN0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gZGZ1c2VUcmFuc2Zvcm1UcmFuc2FjdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC5leGVjdXRpb25fdHJhY2UgPyBkZnVzZVRyYW5zZm9ybVRyYW5zYWN0aW9uKHJlc3VsdCkgOiBkZnVzZVRyYW5zZm9ybURlZmVycmVkVHJhbnNhY3Rpb24ocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIGhpc3RvcnlUcmFuc2Zvcm1EZWZlcnJlZEFjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBhY3Rpb24sIHtcbiAgICBhY2NvdW50X3JhbV9kZWx0YXM6IFtdLFxuICAgIHJlY2VpdmVyOiAnJyxcbiAgICBhY3RfZGlnZXN0OiAnJyxcbiAgICB0cmFjZXM6IFtdXG4gIH0pO1xufVxuZnVuY3Rpb24gaGlzdG9yeVRyYW5zZm9ybURlZmVycmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogdHJhbnNhY3Rpb24udHJ4X2lkLFxuICAgIHN0YXR1czogJ2RlZmVycmVkJyxcbiAgICBzZW5kZXI6IHRyYW5zYWN0aW9uLnNlbmRlcixcbiAgICBwYXllcjogdHJhbnNhY3Rpb24ucGF5ZXIsXG4gICAgcHVibGlzaGVkOiB0cmFuc2FjdGlvbi5wdWJsaXNoZWQsXG4gICAgZXhwaXJhdGlvbjogdHJhbnNhY3Rpb24uZXhwaXJhdGlvbixcbiAgICBkZWxheV91bnRpbDogdHJhbnNhY3Rpb24uZGVsYXlfdW50aWwsXG4gICAgZGVsYXlfc2VjOiB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbi5kZWxheV9zZWMsXG4gICAgYWN0aW9uczogdHJhbnNhY3Rpb24udHJhbnNhY3Rpb24uYWN0aW9ucyxcbiAgICB0cmFjZXM6IHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uLmFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5VHJhbnNmb3JtRGVmZXJyZWRBY3Rpb24oYWN0aW9uKTtcbiAgICB9KVxuICB9O1xufVxuZnVuY3Rpb24gaGlzdG9yeVRyYW5zZm9ybVJlY3Vyc2l2ZVRyYWNlKGFjdGlvbikge1xuICB2YXIgdHJhbnNmb3JtZWQgPSB7XG4gICAgYWN0OiBhY3Rpb24uYWN0LFxuICAgIGFjY291bnRfcmFtX2RlbHRhczogYWN0aW9uLmFjY291bnRfcmFtX2RlbHRhcyB8fCBbXSxcbiAgICByZWNlaXZlcnM6IFthY3Rpb24ucmVjZWlwdC5yZWNlaXZlcl0sXG4gICAgYWN0X2RpZ2VzdDogYWN0aW9uLnJlY2VpcHQuYWN0X2RpZ2VzdCxcbiAgICB0cmFjZXM6IFtdXG4gIH07XG5cbiAgaWYgKGFjdGlvbi5pbmxpbmVfdHJhY2VzICYmIGFjdGlvbi5pbmxpbmVfdHJhY2VzLmxlbmd0aCkge1xuICAgIGFjdGlvbi5pbmxpbmVfdHJhY2VzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgICB2YXIgc2FtZUFzUGFyZW50ID0gdHJhY2UucmVjZWlwdC5hY3RfZGlnZXN0ID09PSBhY3Rpb24ucmVjZWlwdC5hY3RfZGlnZXN0OyAvLyBBY3Rpb25zIGRvbmUgaW4gcmVzcG9uc2UgdG8gbm90aWZpY2F0aW9uIC0+IEFkZCBpbiBpbmxpbmUgdHJhY2VzXG5cbiAgICAgIGlmIChzYW1lQXNQYXJlbnQgJiYgdHJhY2UuaW5saW5lX3RyYWNlcyAmJiB0cmFjZS5pbmxpbmVfdHJhY2VzLmxlbmd0aCkge1xuICAgICAgICB0cmFuc2Zvcm1lZC50cmFjZXMgPSB0cmFuc2Zvcm1lZC50cmFjZXMuY29uY2F0KHRyYWNlLmlubGluZV90cmFjZXMubWFwKGhpc3RvcnlUcmFuc2Zvcm1SZWN1cnNpdmVUcmFjZSkpO1xuXG4gICAgICAgIGlmICghdHJhbnNmb3JtZWQucmVjZWl2ZXJzLmluY2x1ZGVzKHRyYWNlLnJlY2VpcHQucmVjZWl2ZXIpKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWQucmVjZWl2ZXJzLnB1c2godHJhY2UucmVjZWlwdC5yZWNlaXZlcik7XG4gICAgICAgIH0gLy8gTm9ybWFsIGFjdGlvblxuXG4gICAgICB9IGVsc2UgaWYgKCFzYW1lQXNQYXJlbnQpIHtcbiAgICAgICAgdHJhbnNmb3JtZWQudHJhY2VzLnB1c2goaGlzdG9yeVRyYW5zZm9ybVJlY3Vyc2l2ZVRyYWNlKHRyYWNlKSk7IC8vIE5vcm1hbCBub3RpZmljYXRpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdHJhbnNmb3JtZWQucmVjZWl2ZXJzLmluY2x1ZGVzKHRyYWNlLnJlY2VpcHQucmVjZWl2ZXIpKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWQucmVjZWl2ZXJzLnB1c2godHJhY2UucmVjZWlwdC5yZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2Zvcm1lZDtcbn1cbmZ1bmN0aW9uIGhpc3RvcnlUcmFuc2Zvcm1GbGF0VHJhY2VzKHRyYWNlcykge1xuICB2YXIgdHJhY2VzQnlPcmRpbmFsID0gdHJhY2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0cmFjZSkge1xuICAgIGFjY1t0cmFjZS5hY3Rpb25fb3JkaW5hbF0gPSB0cmFjZTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMTMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRyYWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYWN0aW9uX29yZGluYWwgLSBhLmFjdGlvbl9vcmRpbmFsO1xuICB9KSksIF9zdGVwMTM7ICEoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzKCkpLmRvbmU7KSB7XG4gICAgdmFyIHRyYWNlID0gX3N0ZXAxMy52YWx1ZTtcblxuICAgIC8vIFNraXAgdG9wIGxldmVsIGFjdGlvbnNcbiAgICBpZiAodHJhY2UuY3JlYXRvcl9hY3Rpb25fb3JkaW5hbCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRJbmxpbmVUcmFjZXMgPSB0cmFjZXNCeU9yZGluYWxbdHJhY2UuY3JlYXRvcl9hY3Rpb25fb3JkaW5hbF0uaW5saW5lX3RyYWNlcyB8fCBbXTtcbiAgICB2YXIgbmV3SW5saW5lVHJhY2VzID0gW3RyYWNlc0J5T3JkaW5hbFt0cmFjZS5hY3Rpb25fb3JkaW5hbF1dO1xuICAgIHRyYWNlc0J5T3JkaW5hbFt0cmFjZS5jcmVhdG9yX2FjdGlvbl9vcmRpbmFsXS5pbmxpbmVfdHJhY2VzID0gbmV3SW5saW5lVHJhY2VzLmNvbmNhdChjdXJyZW50SW5saW5lVHJhY2VzKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBPYmplY3QudmFsdWVzKHRyYWNlc0J5T3JkaW5hbCkuZmlsdGVyKGZ1bmN0aW9uICh0cmFjZSkge1xuICAgIHJldHVybiB0cmFjZS5jcmVhdG9yX2FjdGlvbl9vcmRpbmFsID09PSAwO1xuICB9KS5tYXAoZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCB0cmFjZSwge1xuICAgICAgcmVjZWl2ZXJzOiBbdHJhY2UucmVjZWlwdC5yZWNlaXZlcl0sXG4gICAgICBhY3RfZGlnZXN0OiB0cmFjZS5yZWNlaXB0LmFjdF9kaWdlc3RcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRJZlNhbWVUeChpbmxpbmVfdHJhY2VzLCBhY3QpIHtcbiAgdmFyIG1hdGNoID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMTQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGlubGluZV90cmFjZXMpLCBfc3RlcDE0OyAhKF9zdGVwMTQgPSBfaXRlcmF0b3IxNCgpKS5kb25lOykge1xuICAgIHZhciB0cmFjZSA9IF9zdGVwMTQudmFsdWU7XG5cbiAgICBpZiAodHJhY2UuYWN0LmhleF9kYXRhID09PSBhY3QuaGV4X2RhdGEgJiYgdHJhY2UuYWN0Lm5hbWUgPT09IGFjdC5uYW1lICYmIHRyYWNlLmFjdC5hY2NvdW50ID09PSBhY3QuYWNjb3VudCB8fCBmaW5kSWZTYW1lVHgodHJhY2UuaW5saW5lX3RyYWNlcywgYWN0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5mdW5jdGlvbiBpbmxpbmVUcmFjZUNvdW50SGVscGVyKHRyYWNlcykge1xuICByZXR1cm4gdHJhY2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0cmFjZSkge1xuICAgIHJldHVybiBhY2MgKyAxICsgaW5saW5lVHJhY2VDb3VudEhlbHBlcih0cmFjZS5pbmxpbmVfdHJhY2VzIHx8IFtdKTtcbiAgfSwgMCk7XG59XG5cbmZ1bmN0aW9uIGhpc3RvcnlUcmFuc2Zvcm1UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICBpZiAodHJhbnNhY3Rpb24udHJ4KSB7XG4gICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICB2YXIgZGVsYXlfc2VjO1xuICAgIHZhciBleHBpcmF0aW9uO1xuICAgIHZhciB0cmFjZXM7IC8vID49IDEuOCB0cmFjZXNcblxuICAgIGlmICh0cmFuc2FjdGlvbi50cmFjZXMgJiYgdHJhbnNhY3Rpb24udHJhY2VzLmxlbmd0aCAmJiAnY3JlYXRvcl9hY3Rpb25fb3JkaW5hbCcgaW4gdHJhbnNhY3Rpb24udHJhY2VzWzBdKSB7XG4gICAgICB0cmFjZXMgPSBoaXN0b3J5VHJhbnNmb3JtRmxhdFRyYWNlcyh0cmFuc2FjdGlvbi50cmFjZXMpLm1hcChoaXN0b3J5VHJhbnNmb3JtUmVjdXJzaXZlVHJhY2UpO1xuICAgICAgYWN0aW9ucyA9IHRyYW5zYWN0aW9uLnRyYWNlcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgICAgIHJldHVybiB0cmFjZS5jcmVhdG9yX2FjdGlvbl9vcmRpbmFsID09PSAwO1xuICAgICAgfSk7IC8vIDEuNyBhbmQgdW5kZXIgbm9kZW9zXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgX3N0ZXAxNSR2YWx1ZSA9IF9zdGVwMTUudmFsdWUsXG4gICAgICAgICAgICBpID0gX3N0ZXAxNSR2YWx1ZVswXSxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9zdGVwMTUkdmFsdWVbMV07XG4gICAgICAgIHZhciB0ZW1wVHJhY2VzID0gdHJhbnNhY3Rpb24udHJhY2VzLnNsaWNlKCk7XG4gICAgICAgIHRlbXBUcmFjZXMuc3BsaWNlKGksIGkgKyAxKTtcbiAgICAgICAgdmFyIGZvdW5kU2FtZUhleCA9IHRlbXBUcmFjZXMuZmluZChmdW5jdGlvbiAodHJhY2UpIHtcbiAgICAgICAgICByZXR1cm4gZmluZElmU2FtZVR4KHRyYWNlLmlubGluZV90cmFjZXMuc2xpY2UoKSwgYWN0aW9uLmFjdCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZm91bmRTYW1lSGV4KSB7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjE1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0cmFuc2FjdGlvbi50cmFjZXMuZW50cmllcygpKSwgX3N0ZXAxNTsgIShfc3RlcDE1ID0gX2l0ZXJhdG9yMTUoKSkuZG9uZTspIHtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH1cblxuICAgICAgdHJhY2VzID0gYWN0aW9ucy5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gaGlzdG9yeVRyYW5zZm9ybVJlY3Vyc2l2ZVRyYWNlKGFjdGlvbik7XG4gICAgICB9KTsgLy8gTm9ybWFsIG5vdCBkZWZlcnJlZCBUWFxuXG4gICAgICBpZiAodHJhbnNhY3Rpb24udHJ4LnRyeCkge1xuICAgICAgICBkZWxheV9zZWMgPSB0cmFuc2FjdGlvbi50cngudHJ4LmRlbGF5X3NlYztcbiAgICAgICAgZXhwaXJhdGlvbiA9IHRyYW5zYWN0aW9uLnRyeC50cnguZXhwaXJhdGlvbjsgLy8gRGVmZXJyZWQgVFhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGF5X3NlYyA9ICdOL0EnO1xuICAgICAgICBleHBpcmF0aW9uID0gJ04vQSc7XG4gICAgICB9IC8vIEZpeCBmb3IgZW1wdHkgYXJyYXkgKGhleCBkYXRhIGZ1Y2tlZCB1cCkgV1RGP1xuXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi50cmFjZXMubGVuZ3RoID4gMCAmJiBhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhY3Rpb25zID0gW107XG4gICAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjE2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0cmFuc2FjdGlvbi50cmFjZXMpLCBfc3RlcDE2OyAhKF9zdGVwMTYgPSBfaXRlcmF0b3IxNigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfdHggPSBfc3RlcDE2LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGkgPj0gY291bnRlcikge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKF90eCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY291bnRlciArPSBpbmxpbmVUcmFjZUNvdW50SGVscGVyKF90eC5pbmxpbmVfdHJhY2VzKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFjZXMgPSBhY3Rpb25zLm1hcChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGhpc3RvcnlUcmFuc2Zvcm1SZWN1cnNpdmVUcmFjZShhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRml4IGZvciBlbXB0eSB0cmFjZSAoYmxvY2sgaGludCB1c2VkPylcblxuXG4gICAgICBpZiAodHJhbnNhY3Rpb24udHJhY2VzLmxlbmd0aCA9PT0gMCAmJiBhY3Rpb25zLmxlbmd0aCA9PT0gMCAmJiB0cmFuc2FjdGlvbi50cngudHJ4ICYmIHRyYW5zYWN0aW9uLnRyeC50cnguYWN0aW9ucyAmJiB0cmFuc2FjdGlvbi50cngudHJ4LmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHRyYWNlcyA9IHRyYW5zYWN0aW9uLnRyeC50cnguYWN0aW9ucy5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3Q6IGFjdGlvbixcbiAgICAgICAgICAgIGFjY291bnRfcmFtX2RlbHRhczogW10sXG4gICAgICAgICAgICByZWNlaXZlcnM6IGFjdGlvbi5hdXRob3JpemF0aW9uLm1hcChmdW5jdGlvbiAoYXV0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXV0aC5hY3RvcjtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWN0X2RpZ2VzdDogJycsXG4gICAgICAgICAgICB0cmFjZXM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGlvbnMgPSB0cmFjZXM7XG4gICAgICB9XG4gICAgfSAvLyBGb3IgZGlzcGxheVxuXG5cbiAgICB2YXIgZXh0cmFGaWVsZHMgPSBfZXh0ZW5kcyh7fSwgdHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLnRyeC5yZWNlaXB0LCB0cmFuc2FjdGlvbi50cngudHJ4IHx8IHt9KTtcblxuICAgIHZhciB0eCA9IF9leHRlbmRzKHt9LCBleHRyYUZpZWxkcywge1xuICAgICAgc3RhdHVzOiB0cmFuc2FjdGlvbi50cngucmVjZWlwdC5zdGF0dXMsXG4gICAgICBjcHVfdXNhZ2U6IHRyYW5zYWN0aW9uLnRyeC5yZWNlaXB0LmNwdV91c2FnZV91cyxcbiAgICAgIG5ldF91c2FnZTogdHJhbnNhY3Rpb24udHJ4LnJlY2VpcHQubmV0X3VzYWdlX3dvcmRzICogOCxcbiAgICAgIGlkOiB0cmFuc2FjdGlvbi5pZCxcbiAgICAgIGJsb2NrX3RpbWU6IHRyYW5zYWN0aW9uLmJsb2NrX3RpbWUsXG4gICAgICBibG9ja19udW06IHRyYW5zYWN0aW9uLmJsb2NrX251bSxcbiAgICAgIGRlbGF5X3NlYzogZGVsYXlfc2VjLFxuICAgICAgZXhwaXJhdGlvbjogZXhwaXJhdGlvbixcbiAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICB0cmFjZXM6IHRyYWNlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHR4OyAvLyBNRUVUT05FIGhpc3RvcnlcbiAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbi5hY3Rpb25fdHJhY2VzKSB7XG4gICAgcmV0dXJuIGRmdXNlVHJhbnNmb3JtVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pOyAvLyBPbiBibG9ja1xuICB9IGVsc2Uge1xuICAgIHZhciBfdHJhY2VzID0gdHJhbnNhY3Rpb24udHJhY2VzLm1hcChmdW5jdGlvbiAodHJhY2UpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5VHJhbnNmb3JtUmVjdXJzaXZlVHJhY2UodHJhY2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogJ2V4ZWN1dGVkJyxcbiAgICAgIGNwdV91c2FnZTogMCxcbiAgICAgIG5ldF91c2FnZTogMCxcbiAgICAgIGlkOiB0cmFuc2FjdGlvbi5pZCxcbiAgICAgIGJsb2NrX3RpbWU6IHRyYW5zYWN0aW9uLmJsb2NrX3RpbWUsXG4gICAgICBibG9ja19udW06IHRyYW5zYWN0aW9uLmJsb2NrX251bSxcbiAgICAgIGRlbGF5X3NlYzogMCxcbiAgICAgIGV4cGlyYXRpb246IDAsXG4gICAgICBhY3Rpb25zOiBfdHJhY2VzLFxuICAgICAgdHJhY2VzOiBfdHJhY2VzXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoZXhUb1VpbnQ4QXJyYXkoaGV4KSB7XG4gIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc3RyaW5nIGNvbnRhaW5pbmcgaGV4IGRpZ2l0cycpO1xuICB9XG5cbiAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPZGQgbnVtYmVyIG9mIGhleCBkaWdpdHMnKTtcbiAgfVxuXG4gIHZhciBsID0gaGV4Lmxlbmd0aCAvIDI7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgIHZhciB4ID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpICogMiwgMiksIDE2KTtcblxuICAgIGlmIChOdW1iZXIuaXNOYU4oeCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaGV4IHN0cmluZycpO1xuICAgIH1cblxuICAgIHJlc3VsdFtpXSA9IHg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1cmxCdWlsZGVyKHVybCwgaWQsIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3VuZGVmaW5lZCcgJiYgaWQgIT09IG51bGwpIHtcbiAgICB1cmwgKz0gXCIvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaWQpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoICE9PSAwKSB7XG4gICAgdmFyIHF1ZXJ5U3RyaW5nID0gcXVlcnkuc3RyaW5naWZ5KHBhcmFtcyk7XG4gICAgdXJsICs9IFwiP1wiICsgcXVlcnlTdHJpbmc7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBjb3B5KHRleHQpIHtcbiAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIGVsLnZhbHVlID0gdGV4dDtcbiAgZWwuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICcnKTtcbiAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBlbC5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgc2VsZWN0ZWQgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgfVxuXG4gIGVsLnNlbGVjdCgpO1xuICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblxuICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGVkKSB7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbGVjdGlvbi5hZGRSYW5nZShzZWxlY3RlZCk7XG4gIH1cbn1cblxudmFyIE5mdCA9IGZ1bmN0aW9uIE5mdChfcmVmKSB7XG4gIHZhciBpZGF0YSA9IF9yZWYuaWRhdGEsXG4gICAgICBtZGF0YSA9IF9yZWYubWRhdGEsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgaW1hZ2UgPSBfcmVmLmltYWdlLFxuICAgICAgdmlkZW8gPSBfcmVmLnZpZGVvLFxuICAgICAgbW9kZWwgPSBfcmVmLm1vZGVsLFxuICAgICAgYXVkaW8gPSBfcmVmLmF1ZGlvLFxuICAgICAgc3RhZ2UgPSBfcmVmLnN0YWdlLFxuICAgICAgc2t5Ym94ID0gX3JlZi5za3lib3gsXG4gICAgICBwZGYgPSBfcmVmLnBkZixcbiAgICAgIGlkID0gX3JlZi5pZCxcbiAgICAgIGNvbnRyYWN0ID0gX3JlZi5jb250cmFjdCxcbiAgICAgIGxpbmsgPSBfcmVmLmxpbmssXG4gICAgICBvd25lciA9IF9yZWYub3duZXIsXG4gICAgICBhdXRob3IgPSBfcmVmLmF1dGhvcixcbiAgICAgIGNvbGxlY3Rpb24gPSBfcmVmLmNvbGxlY3Rpb24sXG4gICAgICBtaW50ID0gX3JlZi5taW50LFxuICAgICAgZWRpdGlvbl9zaXplID0gX3JlZi5lZGl0aW9uX3NpemU7XG4gIHRoaXMuaWRhdGEgPSBpZGF0YTtcbiAgdGhpcy5tZGF0YSA9IG1kYXRhO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gIHRoaXMudmlkZW8gPSB2aWRlbztcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLmF1ZGlvID0gYXVkaW87XG4gIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgdGhpcy5za3lib3ggPSBza3lib3g7XG4gIHRoaXMucGRmID0gcGRmO1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuY29udHJhY3QgPSBjb250cmFjdDtcbiAgdGhpcy5saW5rID0gbGluaztcbiAgdGhpcy5vd25lciA9IG93bmVyO1xuICB0aGlzLmF1dGhvciA9IGF1dGhvcjtcbiAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgdGhpcy5taW50ID0gbWludDtcbiAgdGhpcy5lZGl0aW9uX3NpemUgPSBlZGl0aW9uX3NpemU7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUlwZnMoaW1hZ2VVcmwpIHtcbiAgaWYgKCFpbWFnZVVybCkge1xuICAgIHJldHVybiBpbWFnZVVybDtcbiAgfVxuXG4gIGlmIChpbWFnZVVybC5zdWJzdHJpbmcoMCwgMikgPT09ICdRbScpIHtcbiAgICBpbWFnZVVybCA9IFwiaHR0cHM6Ly9jbG91ZGZsYXJlLWlwZnMuY29tL2lwZnMvXCIgKyBpbWFnZVVybDtcbiAgfVxuXG4gIHJldHVybiBpbWFnZVVybDtcbn1cblxuZnVuY3Rpb24gcGFyc2VTYU5mdChuZnQpIHtcbiAgdmFyIG5hbWUgPSBuZnQuaWRhdGEgJiYgbmZ0LmlkYXRhLm5hbWUgfHwgbmZ0Lm1kYXRhICYmIG5mdC5tZGF0YS5uYW1lO1xuICB2YXIgaW1hZ2VVcmwgPSBwYXJzZUlwZnMobmZ0LmlkYXRhICYmIChuZnQuaWRhdGEuaW1nIHx8IG5mdC5pZGF0YS5pbWFnZSkgfHwgbmZ0Lm1kYXRhICYmIChuZnQubWRhdGEuaW1nIHx8IG5mdC5tZGF0YS5pbWcpKTtcbiAgdmFyIHZpZGVvVXJsID0gcGFyc2VJcGZzKG5mdC5pZGF0YSAmJiBuZnQuaWRhdGEudmlkZW8gfHwgbmZ0Lm1kYXRhICYmIG5mdC5tZGF0YS52aWRlbyk7XG4gIHZhciBhdWRpb1VybCA9IHBhcnNlSXBmcyhuZnQuaWRhdGEgJiYgbmZ0LmlkYXRhLmF1ZGlvIHx8IG5mdC5tZGF0YSAmJiBuZnQubWRhdGEuYXVkaW8pO1xuICB2YXIgbW9kZWxVcmwgPSBwYXJzZUlwZnMobmZ0LmlkYXRhICYmIG5mdC5pZGF0YS5tb2RlbCB8fCBuZnQubWRhdGEgJiYgbmZ0Lm1kYXRhLm1vZGVsKTtcbiAgdmFyIHN0YWdlVXJsID0gcGFyc2VJcGZzKG5mdC5pZGF0YSAmJiBuZnQuaWRhdGEuc3RhZ2UgfHwgbmZ0Lm1kYXRhICYmIG5mdC5tZGF0YS5zdGFnZSk7XG4gIHZhciBwZGZVcmwgPSBwYXJzZUlwZnMobmZ0LmlkYXRhICYmIG5mdC5pZGF0YS5wZGYgfHwgbmZ0Lm1kYXRhICYmIG5mdC5tZGF0YS5wZGYpO1xuICB2YXIgc2t5Ym94VXJsID0gcGFyc2VJcGZzKG5mdC5pZGF0YSAmJiBuZnQuaWRhdGEuc2t5Ym94IHx8IG5mdC5tZGF0YSAmJiBuZnQubWRhdGEuc2t5Ym94KTtcbiAgdmFyIG5mdE9iaiA9IG5ldyBOZnQoe1xuICAgIGlkYXRhOiBuZnQuaWRhdGEsXG4gICAgbWRhdGE6IG5mdC5tZGF0YSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIGltYWdlOiBpbWFnZVVybCxcbiAgICB2aWRlbzogdmlkZW9VcmwsXG4gICAgbW9kZWw6IG1vZGVsVXJsLFxuICAgIGF1ZGlvOiBhdWRpb1VybCxcbiAgICBzdGFnZTogc3RhZ2VVcmwsXG4gICAgc2t5Ym94OiBza3lib3hVcmwsXG4gICAgcGRmOiBwZGZVcmwsXG4gICAgaWQ6IG5mdC5hc3NldElkLFxuICAgIGNvbnRyYWN0OiAnc2ltcGxlYXNzZXRzJyxcbiAgICBsaW5rOiBcIi9uZnQvXCIgKyBuZnQuYXNzZXRJZCxcbiAgICBvd25lcjogbmZ0Lm93bmVyLFxuICAgIGF1dGhvcjogbmZ0LmF1dGhvcixcbiAgICBtaW50OiBuZnQuZXh0cmEgJiYgbmZ0LmV4dHJhLm1pbnROdW1iZXIsXG4gICAgY29sbGVjdGlvbjogbmZ0LmNhdGVnb3J5LFxuICAgIGVkaXRpb25fc2l6ZTogbmZ0LmV4dHJhICYmIG5mdC5leHRyYS50b3RhbE1pbnRlZFxuICB9KTtcbiAgcmV0dXJuIG5mdE9iajtcbn1cbmZ1bmN0aW9uIHBhcnNlQWFOZnQobmZ0KSB7XG4gIHZhciBpbWFnZVVybCA9IHBhcnNlSXBmcyhuZnQuZGF0YS5pbWcgfHwgbmZ0LmRhdGEuaW1hZ2UpO1xuICB2YXIgdmlkZW9VcmwgPSBwYXJzZUlwZnMobmZ0LmRhdGEudmlkZW8pO1xuICB2YXIgYXVkaW9VcmwgPSBwYXJzZUlwZnMobmZ0LmRhdGEuYXVkaW8pO1xuICB2YXIgbW9kZWxVcmwgPSBwYXJzZUlwZnMobmZ0LmRhdGEubW9kZWwpO1xuICB2YXIgc3RhZ2VVcmwgPSBwYXJzZUlwZnMobmZ0LmRhdGEuc3RhZ2UpO1xuICB2YXIgc2t5Ym94VXJsID0gcGFyc2VJcGZzKG5mdC5kYXRhLnNreWJveCk7XG4gIHZhciBwZGZVcmwgPSBwYXJzZUlwZnMobmZ0LmRhdGEucGRmKTtcbiAgdmFyIGlkYXRhID0gbmZ0LmltbXV0YWJsZV9kYXRhO1xuXG4gIGlmIChuZnQudGVtcGxhdGUgJiYgbmZ0LnRlbXBsYXRlLmltbXV0YWJsZV9kYXRhKSB7XG4gICAgaWRhdGEgPSBfZXh0ZW5kcyh7fSwgaWRhdGEsIG5mdC50ZW1wbGF0ZS5pbW11dGFibGVfZGF0YSk7XG4gIH1cblxuICB2YXIgbmZ0T2JqID0gbmV3IE5mdCh7XG4gICAgaWRhdGE6IGlkYXRhLFxuICAgIG1kYXRhOiBuZnQubXV0YWJsZV9kYXRhLFxuICAgIG5hbWU6IG5mdC5uYW1lIHx8IG5mdC5kYXRhLm5hbWUgfHwgbmZ0LmFzc2V0X2lkLFxuICAgIGltYWdlOiBpbWFnZVVybCxcbiAgICB2aWRlbzogdmlkZW9VcmwsXG4gICAgbW9kZWw6IG1vZGVsVXJsLFxuICAgIGF1ZGlvOiBhdWRpb1VybCxcbiAgICBzdGFnZTogc3RhZ2VVcmwsXG4gICAgc2t5Ym94OiBza3lib3hVcmwsXG4gICAgcGRmOiBwZGZVcmwsXG4gICAgaWQ6IG5mdC5hc3NldF9pZCxcbiAgICBjb250cmFjdDogJ2F0b21pY2Fzc2V0cycsXG4gICAgbGluazogXCIvbmZ0L1wiICsgbmZ0LmFzc2V0X2lkLFxuICAgIG93bmVyOiBuZnQub3duZXIsXG4gICAgYXV0aG9yOiBuZnQuY29sbGVjdGlvbi5hdXRob3IsXG4gICAgY29sbGVjdGlvbjogbmZ0LmNvbGxlY3Rpb24uY29sbGVjdGlvbl9uYW1lLFxuICAgIG1pbnQ6IG5mdC50ZW1wbGF0ZV9taW50ID8gK25mdC50ZW1wbGF0ZV9taW50IDogdW5kZWZpbmVkLFxuICAgIGVkaXRpb25fc2l6ZTogbmZ0LnRlbXBsYXRlID8gK25mdC50ZW1wbGF0ZS5tYXhfc3VwcGx5IHx8ICtuZnQudGVtcGxhdGUuaXNzdWVkX3N1cHBseSA6IHVuZGVmaW5lZFxuICB9KTtcbiAgcmV0dXJuIG5mdE9iajtcbn1cblxuZnVuY3Rpb24gd2FpdChfeCkge1xuICByZXR1cm4gX3dhaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3dhaXQoKSB7XG4gIF93YWl0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKG1zKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF93YWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxyXG4gKiBOYXRpdmVcclxuICovXG52YXIgRGJvcE9wO1xuXG4oZnVuY3Rpb24gKERib3BPcCkge1xuICBEYm9wT3BbXCJJbnNcIl0gPSBcIklOU1wiO1xuICBEYm9wT3BbXCJSZW1cIl0gPSBcIlJFTVwiO1xuICBEYm9wT3BbXCJVcGRcIl0gPSBcIlVQRFwiO1xufSkoRGJvcE9wIHx8IChEYm9wT3AgPSB7fSkpO1xuXG5leHBvcnQgeyBEYm9wT3AsIE5mdCwgYnl0ZXNUb1N0cmluZywgY2hhcmlkeCwgY2xvbmVEZWVwQXJyYXlPZk9iaiwgY29weSwgZGVjb2RlTmFtZSwgZGZ1c2VEZXB0aEZpcnN0RXh0cmFjdCwgZGZ1c2VUcmFuc2Zvcm1EZWZlcnJlZEFjdGlvbiwgZGZ1c2VUcmFuc2Zvcm1EZWZlcnJlZFRyYW5zYWN0aW9uLCBkZnVzZVRyYW5zZm9ybUdldEFjdGlvbnMsIGRmdXNlVHJhbnNmb3JtVHJhY2UsIGRmdXNlVHJhbnNmb3JtVHJhbnNhY3Rpb24sIGRmdXNlVHJhbnNmb3JtVHJhbnNhY3Rpb25SZXN1bHQsIGVuY29kZU5hbWUsIGZpb0tleVRvQWN0b3IsIGhleFRvVWludDhBcnJheSwgaGlzdG9yeVRyYW5zZm9ybURlZmVycmVkQWN0aW9uLCBoaXN0b3J5VHJhbnNmb3JtRGVmZXJyZWRUcmFuc2FjdGlvbiwgaGlzdG9yeVRyYW5zZm9ybUZsYXRUcmFjZXMsIGhpc3RvcnlUcmFuc2Zvcm1SZWN1cnNpdmVUcmFjZSwgaGlzdG9yeVRyYW5zZm9ybVRyYW5zYWN0aW9uLCBoeXBlcmlvblRyYW5zZm9ybUZsYXRUcmFjZXMsIGh5cGVyaW9uVHJhbnNmb3JtR2V0QWN0aW9ucywgaHlwZXJpb25UcmFuc2Zvcm1UcmFuc2FjdGlvbiwgaXNTdHJpbmcsIG5hdGl2ZVRyYW5zZm9ybUdldEFjdGlvbnMsIHBhcnNlQWFOZnQsIHBhcnNlU2FOZnQsIHNoYSwgc3RyaW5nX3RvX3VpbnQxMjhfaGFzaCwgdXJsQnVpbGRlciwgd2FpdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuZXNtLmpzLm1hcFxuIiwiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXsoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzKS5udW1icm89ZSgpfX0oZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gYShvLHUsYyl7ZnVuY3Rpb24gcyh0LGUpe2lmKCF1W3RdKXtpZighb1t0XSl7dmFyIHI9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZSYmcilyZXR1cm4gcih0LCEwKTtpZihsKXJldHVybiBsKHQsITApO3ZhciBuPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrdCtcIidcIik7dGhyb3cgbi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLG59dmFyIGk9dVt0XT17ZXhwb3J0czp7fX07b1t0XVswXS5jYWxsKGkuZXhwb3J0cyxmdW5jdGlvbihlKXtyZXR1cm4gcyhvW3RdWzFdW2VdfHxlKX0saSxpLmV4cG9ydHMsYSxvLHUsYyl9cmV0dXJuIHVbdF0uZXhwb3J0c31mb3IodmFyIGw9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxlPTA7ZTxjLmxlbmd0aDtlKyspcyhjW2VdKTtyZXR1cm4gc30oezE6W2Z1bmN0aW9uKGUscix0KXshZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQsQz0vXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxUPU1hdGguY2VpbCxVPU1hdGguZmxvb3IsUj1cIltCaWdOdW1iZXIgRXJyb3JdIFwiLEk9UitcIk51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IFwiLCQ9MWUxNCxHPTE0LFY9OTAwNzE5OTI1NDc0MDk5MSxxPVsxLDEwLDEwMCwxZTMsMWU0LDFlNSwxZTYsMWU3LDFlOCwxZTksMWUxMCwxZTExLDFlMTIsMWUxM10sWj0xZTcsej0xZTk7ZnVuY3Rpb24gVyhlKXt2YXIgdD0wfGU7cmV0dXJuIDA8ZXx8ZT09PXQ/dDp0LTF9ZnVuY3Rpb24gSChlKXtmb3IodmFyIHQscixuPTEsaT1lLmxlbmd0aCxhPWVbMF0rXCJcIjtuPGk7KXtmb3IodD1lW24rK10rXCJcIixyPUctdC5sZW5ndGg7ci0tO3Q9XCIwXCIrdCk7YSs9dH1mb3IoaT1hLmxlbmd0aDs0OD09PWEuY2hhckNvZGVBdCgtLWkpOyk7cmV0dXJuIGEuc2xpY2UoMCxpKzF8fDEpfWZ1bmN0aW9uIFkoZSx0KXt2YXIgcixuLGk9ZS5jLGE9dC5jLG89ZS5zLHU9dC5zLGM9ZS5lLHM9dC5lO2lmKCFvfHwhdSlyZXR1cm4gbnVsbDtpZihyPWkmJiFpWzBdLG49YSYmIWFbMF0scnx8bilyZXR1cm4gcj9uPzA6LXU6bztpZihvIT11KXJldHVybiBvO2lmKHI9bzwwLG49Yz09cywhaXx8IWEpcmV0dXJuIG4/MDohaV5yPzE6LTE7aWYoIW4pcmV0dXJuIHM8Y15yPzE6LTE7Zm9yKHU9KGM9aS5sZW5ndGgpPChzPWEubGVuZ3RoKT9jOnMsbz0wO288dTtvKyspaWYoaVtvXSE9YVtvXSlyZXR1cm4gaVtvXT5hW29dXnI/MTotMTtyZXR1cm4gYz09cz8wOnM8Y15yPzE6LTF9ZnVuY3Rpb24gSyhlLHQscixuKXtpZihlPHR8fHI8ZXx8ZSE9PVUoZSkpdGhyb3cgRXJyb3IoUisobnx8XCJBcmd1bWVudFwiKSsoXCJudW1iZXJcIj09dHlwZW9mIGU/ZTx0fHxyPGU/XCIgb3V0IG9mIHJhbmdlOiBcIjpcIiBub3QgYW4gaW50ZWdlcjogXCI6XCIgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogXCIpK1N0cmluZyhlKSl9ZnVuY3Rpb24gSihlKXt2YXIgdD1lLmMubGVuZ3RoLTE7cmV0dXJuIFcoZS5lL0cpPT10JiZlLmNbdF0lMiE9MH1mdW5jdGlvbiBYKGUsdCl7cmV0dXJuKDE8ZS5sZW5ndGg/ZS5jaGFyQXQoMCkrXCIuXCIrZS5zbGljZSgxKTplKSsodDwwP1wiZVwiOlwiZStcIikrdH1mdW5jdGlvbiBRKGUsdCxyKXt2YXIgbixpO2lmKHQ8MCl7Zm9yKGk9citcIi5cIjsrK3Q7aSs9cik7ZT1pK2V9ZWxzZSBpZigrK3Q+KG49ZS5sZW5ndGgpKXtmb3IoaT1yLHQtPW47LS10O2krPXIpO2UrPWl9ZWxzZSB0PG4mJihlPWUuc2xpY2UoMCx0KStcIi5cIitlLnNsaWNlKHQpKTtyZXR1cm4gZX0odD1mdW5jdGlvbiBlKHQpe3ZhciB2LGYscCxyLHMsbSxvLHUsYyxsLGcsbj1BLnByb3RvdHlwZT17Y29uc3RydWN0b3I6QSx0b1N0cmluZzpudWxsLHZhbHVlT2Y6bnVsbH0saD1uZXcgQSgxKSx5PTIwLGI9NCxkPS03LHc9MjEsUz0tMWU3LHg9MWU3LE89ITEsYT0xLE49MCxCPXtwcmVmaXg6XCJcIixncm91cFNpemU6MyxzZWNvbmRhcnlHcm91cFNpemU6MCxncm91cFNlcGFyYXRvcjpcIixcIixkZWNpbWFsU2VwYXJhdG9yOlwiLlwiLGZyYWN0aW9uR3JvdXBTaXplOjAsZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjpcIsKgXCIsc3VmZml4OlwiXCJ9LE09XCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtmdW5jdGlvbiBBKGUsdCl7dmFyIHIsbixpLGEsbyx1LGMscyxsPXRoaXM7aWYoIShsIGluc3RhbmNlb2YgQSkpcmV0dXJuIG5ldyBBKGUsdCk7aWYobnVsbD09dCl7aWYoZSYmITA9PT1lLl9pc0JpZ051bWJlcilyZXR1cm4gbC5zPWUucyx2b2lkKCFlLmN8fGUuZT54P2wuYz1sLmU9bnVsbDplLmU8Uz9sLmM9W2wuZT0wXToobC5lPWUuZSxsLmM9ZS5jLnNsaWNlKCkpKTtpZigodT1cIm51bWJlclwiPT10eXBlb2YgZSkmJjAqZT09MCl7aWYobC5zPTEvZTwwPyhlPS1lLC0xKToxLGU9PT1+fmUpe2ZvcihhPTAsbz1lOzEwPD1vO28vPTEwLGErKyk7cmV0dXJuIHZvaWQoeDxhP2wuYz1sLmU9bnVsbDoobC5lPWEsbC5jPVtlXSkpfXM9U3RyaW5nKGUpfWVsc2V7aWYoIUMudGVzdChzPVN0cmluZyhlKSkpcmV0dXJuIHAobCxzLHUpO2wucz00NT09cy5jaGFyQ29kZUF0KDApPyhzPXMuc2xpY2UoMSksLTEpOjF9LTE8KGE9cy5pbmRleE9mKFwiLlwiKSkmJihzPXMucmVwbGFjZShcIi5cIixcIlwiKSksMDwobz1zLnNlYXJjaCgvZS9pKSk/KGE8MCYmKGE9byksYSs9K3Muc2xpY2UobysxKSxzPXMuc3Vic3RyaW5nKDAsbykpOmE8MCYmKGE9cy5sZW5ndGgpfWVsc2V7aWYoSyh0LDIsTS5sZW5ndGgsXCJCYXNlXCIpLDEwPT10KXJldHVybiBQKGw9bmV3IEEoZSkseStsLmUrMSxiKTtpZihzPVN0cmluZyhlKSx1PVwibnVtYmVyXCI9PXR5cGVvZiBlKXtpZigwKmUhPTApcmV0dXJuIHAobCxzLHUsdCk7aWYobC5zPTEvZTwwPyhzPXMuc2xpY2UoMSksLTEpOjEsQS5ERUJVRyYmMTU8cy5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sXCJcIikubGVuZ3RoKXRocm93IEVycm9yKEkrZSl9ZWxzZSBsLnM9NDU9PT1zLmNoYXJDb2RlQXQoMCk/KHM9cy5zbGljZSgxKSwtMSk6MTtmb3Iocj1NLnNsaWNlKDAsdCksYT1vPTAsYz1zLmxlbmd0aDtvPGM7bysrKWlmKHIuaW5kZXhPZihuPXMuY2hhckF0KG8pKTwwKXtpZihcIi5cIj09bil7aWYoYTxvKXthPWM7Y29udGludWV9fWVsc2UgaWYoIWkmJihzPT1zLnRvVXBwZXJDYXNlKCkmJihzPXMudG9Mb3dlckNhc2UoKSl8fHM9PXMudG9Mb3dlckNhc2UoKSYmKHM9cy50b1VwcGVyQ2FzZSgpKSkpe2k9ITAsbz0tMSxhPTA7Y29udGludWV9cmV0dXJuIHAobCxTdHJpbmcoZSksdSx0KX11PSExLC0xPChhPShzPWYocyx0LDEwLGwucykpLmluZGV4T2YoXCIuXCIpKT9zPXMucmVwbGFjZShcIi5cIixcIlwiKTphPXMubGVuZ3RofWZvcihvPTA7NDg9PT1zLmNoYXJDb2RlQXQobyk7bysrKTtmb3IoYz1zLmxlbmd0aDs0OD09PXMuY2hhckNvZGVBdCgtLWMpOyk7aWYocz1zLnNsaWNlKG8sKytjKSl7aWYoYy09byx1JiZBLkRFQlVHJiYxNTxjJiYoVjxlfHxlIT09VShlKSkpdGhyb3cgRXJyb3IoSStsLnMqZSk7aWYoKGE9YS1vLTEpPngpbC5jPWwuZT1udWxsO2Vsc2UgaWYoYTxTKWwuYz1bbC5lPTBdO2Vsc2V7aWYobC5lPWEsbC5jPVtdLG89KGErMSklRyxhPDAmJihvKz1HKSxvPGMpe2ZvcihvJiZsLmMucHVzaCgrcy5zbGljZSgwLG8pKSxjLT1HO288YzspbC5jLnB1c2goK3Muc2xpY2UobyxvKz1HKSk7bz1HLShzPXMuc2xpY2UobykpLmxlbmd0aH1lbHNlIG8tPWM7Zm9yKDtvLS07cys9XCIwXCIpO2wuYy5wdXNoKCtzKX19ZWxzZSBsLmM9W2wuZT0wXX1mdW5jdGlvbiBEKGUsdCxyLG4pe2Zvcih2YXIgaSxhLG89WzBdLHU9MCxjPWUubGVuZ3RoO3U8Yzspe2ZvcihhPW8ubGVuZ3RoO2EtLTtvW2FdKj10KTtmb3Iob1swXSs9bi5pbmRleE9mKGUuY2hhckF0KHUrKykpLGk9MDtpPG8ubGVuZ3RoO2krKylvW2ldPnItMSYmKG51bGw9PW9baSsxXSYmKG9baSsxXT0wKSxvW2krMV0rPW9baV0vcnwwLG9baV0lPXIpfXJldHVybiBvLnJldmVyc2UoKX1mdW5jdGlvbiBFKGUsdCxyKXt2YXIgbixpLGEsbyx1PTAsYz1lLmxlbmd0aCxzPXQlWixsPXQvWnwwO2ZvcihlPWUuc2xpY2UoKTtjLS07KXU9KChpPXMqKGE9ZVtjXSVaKSsobj1sKmErKG89ZVtjXS9afDApKnMpJVoqWit1KS9yfDApKyhuL1p8MCkrbCpvLGVbY109aSVyO3JldHVybiB1JiYoZT1bdV0uY29uY2F0KGUpKSxlfWZ1bmN0aW9uIEYoZSx0LHIsbil7dmFyIGksYTtpZihyIT1uKWE9bjxyPzE6LTE7ZWxzZSBmb3IoaT1hPTA7aTxyO2krKylpZihlW2ldIT10W2ldKXthPWVbaV0+dFtpXT8xOi0xO2JyZWFrfXJldHVybiBhfWZ1bmN0aW9uIGsoZSx0LHIsbil7Zm9yKHZhciBpPTA7ci0tOyllW3JdLT1pLGk9ZVtyXTx0W3JdPzE6MCxlW3JdPWkqbitlW3JdLXRbcl07Zm9yKDshZVswXSYmMTxlLmxlbmd0aDtlLnNwbGljZSgwLDEpKTt9ZnVuY3Rpb24gaShlLHQscixuKXt2YXIgaSxhLG8sdSxjO2lmKG51bGw9PXI/cj1iOksociwwLDgpLCFlLmMpcmV0dXJuIGUudG9TdHJpbmcoKTtpZihpPWUuY1swXSxvPWUuZSxudWxsPT10KWM9SChlLmMpLGM9MT09bnx8Mj09biYmKG88PWR8fHc8PW8pP1goYyxvKTpRKGMsbyxcIjBcIik7ZWxzZSBpZihhPShlPVAobmV3IEEoZSksdCxyKSkuZSx1PShjPUgoZS5jKSkubGVuZ3RoLDE9PW58fDI9PW4mJih0PD1hfHxhPD1kKSl7Zm9yKDt1PHQ7Yys9XCIwXCIsdSsrKTtjPVgoYyxhKX1lbHNlIGlmKHQtPW8sYz1RKGMsYSxcIjBcIiksdTxhKzEpe2lmKDA8LS10KWZvcihjKz1cIi5cIjt0LS07Yys9XCIwXCIpO31lbHNlIGlmKDA8KHQrPWEtdSkpZm9yKGErMT09dSYmKGMrPVwiLlwiKTt0LS07Yys9XCIwXCIpO3JldHVybiBlLnM8MCYmaT9cIi1cIitjOmN9ZnVuY3Rpb24gXyhlLHQpe2Zvcih2YXIgcixuPTEsaT1uZXcgQShlWzBdKTtuPGUubGVuZ3RoO24rKyl7aWYoIShyPW5ldyBBKGVbbl0pKS5zKXtpPXI7YnJlYWt9dC5jYWxsKGkscikmJihpPXIpfXJldHVybiBpfWZ1bmN0aW9uIEwoZSx0LHIpe2Zvcih2YXIgbj0xLGk9dC5sZW5ndGg7IXRbLS1pXTt0LnBvcCgpKTtmb3IoaT10WzBdOzEwPD1pO2kvPTEwLG4rKyk7cmV0dXJuKHI9bityKkctMSk+eD9lLmM9ZS5lPW51bGw6cjxTP2UuYz1bZS5lPTBdOihlLmU9cixlLmM9dCksZX1mdW5jdGlvbiBQKGUsdCxyLG4pe3ZhciBpLGEsbyx1LGMscyxsLGY9ZS5jLHA9cTtpZihmKXtlOntmb3IoaT0xLHU9ZlswXTsxMDw9dTt1Lz0xMCxpKyspO2lmKChhPXQtaSk8MClhKz1HLG89dCxsPShjPWZbcz0wXSkvcFtpLW8tMV0lMTB8MDtlbHNlIGlmKChzPVQoKGErMSkvRykpPj1mLmxlbmd0aCl7aWYoIW4pYnJlYWsgZTtmb3IoO2YubGVuZ3RoPD1zO2YucHVzaCgwKSk7Yz1sPTAsbz0oYSU9RyktRysoaT0xKX1lbHNle2ZvcihjPXU9ZltzXSxpPTE7MTA8PXU7dS89MTAsaSsrKTtsPShvPShhJT1HKS1HK2kpPDA/MDpjL3BbaS1vLTFdJTEwfDB9aWYobj1ufHx0PDB8fG51bGwhPWZbcysxXXx8KG88MD9jOmMlcFtpLW8tMV0pLG49cjw0PyhsfHxuKSYmKDA9PXJ8fHI9PShlLnM8MD8zOjIpKTo1PGx8fDU9PWwmJig0PT1yfHxufHw2PT1yJiYoMDxhPzA8bz9jL3BbaS1vXTowOmZbcy0xXSklMTAmMXx8cj09KGUuczwwPzg6NykpLHQ8MXx8IWZbMF0pcmV0dXJuIGYubGVuZ3RoPTAsbj8odC09ZS5lKzEsZlswXT1wWyhHLXQlRyklR10sZS5lPS10fHwwKTpmWzBdPWUuZT0wLGU7aWYoMD09YT8oZi5sZW5ndGg9cyx1PTEscy0tKTooZi5sZW5ndGg9cysxLHU9cFtHLWFdLGZbc109MDxvP1UoYy9wW2ktb10lcFtvXSkqdTowKSxuKWZvcig7Oyl7aWYoMD09cyl7Zm9yKGE9MSxvPWZbMF07MTA8PW87by89MTAsYSsrKTtmb3Iobz1mWzBdKz11LHU9MTsxMDw9bztvLz0xMCx1KyspO2EhPXUmJihlLmUrKyxmWzBdPT0kJiYoZlswXT0xKSk7YnJlYWt9aWYoZltzXSs9dSxmW3NdIT0kKWJyZWFrO2Zbcy0tXT0wLHU9MX1mb3IoYT1mLmxlbmd0aDswPT09ZlstLWFdO2YucG9wKCkpO31lLmU+eD9lLmM9ZS5lPW51bGw6ZS5lPFMmJihlLmM9W2UuZT0wXSl9cmV0dXJuIGV9ZnVuY3Rpb24gaihlKXt2YXIgdCxyPWUuZTtyZXR1cm4gbnVsbD09PXI/ZS50b1N0cmluZygpOih0PUgoZS5jKSx0PXI8PWR8fHc8PXI/WCh0LHIpOlEodCxyLFwiMFwiKSxlLnM8MD9cIi1cIit0OnQpfXJldHVybiBBLmNsb25lPWUsQS5ST1VORF9VUD0wLEEuUk9VTkRfRE9XTj0xLEEuUk9VTkRfQ0VJTD0yLEEuUk9VTkRfRkxPT1I9MyxBLlJPVU5EX0hBTEZfVVA9NCxBLlJPVU5EX0hBTEZfRE9XTj01LEEuUk9VTkRfSEFMRl9FVkVOPTYsQS5ST1VORF9IQUxGX0NFSUw9NyxBLlJPVU5EX0hBTEZfRkxPT1I9OCxBLkVVQ0xJRD05LEEuY29uZmlnPUEuc2V0PWZ1bmN0aW9uKGUpe3ZhciB0LHI7aWYobnVsbCE9ZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgRXJyb3IoUitcIk9iamVjdCBleHBlY3RlZDogXCIrZSk7aWYoZS5oYXNPd25Qcm9wZXJ0eSh0PVwiREVDSU1BTF9QTEFDRVNcIikmJihLKHI9ZVt0XSwwLHosdCkseT1yKSxlLmhhc093blByb3BlcnR5KHQ9XCJST1VORElOR19NT0RFXCIpJiYoSyhyPWVbdF0sMCw4LHQpLGI9ciksZS5oYXNPd25Qcm9wZXJ0eSh0PVwiRVhQT05FTlRJQUxfQVRcIikmJigocj1lW3RdKSYmci5wb3A/KEsoclswXSwteiwwLHQpLEsoclsxXSwwLHosdCksZD1yWzBdLHc9clsxXSk6KEsociwteix6LHQpLGQ9LSh3PXI8MD8tcjpyKSkpLGUuaGFzT3duUHJvcGVydHkodD1cIlJBTkdFXCIpKWlmKChyPWVbdF0pJiZyLnBvcClLKHJbMF0sLXosLTEsdCksSyhyWzFdLDEseix0KSxTPXJbMF0seD1yWzFdO2Vsc2V7aWYoSyhyLC16LHosdCksIXIpdGhyb3cgRXJyb3IoUit0K1wiIGNhbm5vdCBiZSB6ZXJvOiBcIityKTtTPS0oeD1yPDA/LXI6cil9aWYoZS5oYXNPd25Qcm9wZXJ0eSh0PVwiQ1JZUFRPXCIpKXtpZigocj1lW3RdKSE9PSEhcil0aHJvdyBFcnJvcihSK3QrXCIgbm90IHRydWUgb3IgZmFsc2U6IFwiK3IpO2lmKHIpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjcnlwdG98fCFjcnlwdG98fCFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzJiYhY3J5cHRvLnJhbmRvbUJ5dGVzKXRocm93IE89IXIsRXJyb3IoUitcImNyeXB0byB1bmF2YWlsYWJsZVwiKTtPPXJ9ZWxzZSBPPXJ9aWYoZS5oYXNPd25Qcm9wZXJ0eSh0PVwiTU9EVUxPX01PREVcIikmJihLKHI9ZVt0XSwwLDksdCksYT1yKSxlLmhhc093blByb3BlcnR5KHQ9XCJQT1dfUFJFQ0lTSU9OXCIpJiYoSyhyPWVbdF0sMCx6LHQpLE49ciksZS5oYXNPd25Qcm9wZXJ0eSh0PVwiRk9STUFUXCIpKXtpZihcIm9iamVjdFwiIT10eXBlb2Yocj1lW3RdKSl0aHJvdyBFcnJvcihSK3QrXCIgbm90IGFuIG9iamVjdDogXCIrcik7Qj1yfWlmKGUuaGFzT3duUHJvcGVydHkodD1cIkFMUEhBQkVUXCIpKXtpZihcInN0cmluZ1wiIT10eXBlb2Yocj1lW3RdKXx8L14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdChyKSl0aHJvdyBFcnJvcihSK3QrXCIgaW52YWxpZDogXCIrcik7TT1yfX1yZXR1cm57REVDSU1BTF9QTEFDRVM6eSxST1VORElOR19NT0RFOmIsRVhQT05FTlRJQUxfQVQ6W2Qsd10sUkFOR0U6W1MseF0sQ1JZUFRPOk8sTU9EVUxPX01PREU6YSxQT1dfUFJFQ0lTSU9OOk4sRk9STUFUOkIsQUxQSEFCRVQ6TX19LEEuaXNCaWdOdW1iZXI9ZnVuY3Rpb24oZSl7aWYoIWV8fCEwIT09ZS5faXNCaWdOdW1iZXIpcmV0dXJuITE7aWYoIUEuREVCVUcpcmV0dXJuITA7dmFyIHQscixuPWUuYyxpPWUuZSxhPWUucztlOmlmKFwiW29iamVjdCBBcnJheV1cIj09e30udG9TdHJpbmcuY2FsbChuKSl7aWYoKDE9PT1hfHwtMT09PWEpJiYtejw9aSYmaTw9eiYmaT09PVUoaSkpe2lmKDA9PT1uWzBdKXtpZigwPT09aSYmMT09PW4ubGVuZ3RoKXJldHVybiEwO2JyZWFrIGV9aWYoKHQ9KGkrMSklRyk8MSYmKHQrPUcpLFN0cmluZyhuWzBdKS5sZW5ndGg9PXQpe2Zvcih0PTA7dDxuLmxlbmd0aDt0KyspaWYoKHI9blt0XSk8MHx8JDw9cnx8ciE9PVUocikpYnJlYWsgZTtpZigwIT09cilyZXR1cm4hMH19fWVsc2UgaWYobnVsbD09PW4mJm51bGw9PT1pJiYobnVsbD09PWF8fDE9PT1hfHwtMT09PWEpKXJldHVybiEwO3Rocm93IEVycm9yKFIrXCJJbnZhbGlkIEJpZ051bWJlcjogXCIrZSl9LEEubWF4aW11bT1BLm1heD1mdW5jdGlvbigpe3JldHVybiBfKGFyZ3VtZW50cyxuLmx0KX0sQS5taW5pbXVtPUEubWluPWZ1bmN0aW9uKCl7cmV0dXJuIF8oYXJndW1lbnRzLG4uZ3QpfSxBLnJhbmRvbT0ocj05MDA3MTk5MjU0NzQwOTkyLHM9TWF0aC5yYW5kb20oKSpyJjIwOTcxNTE/ZnVuY3Rpb24oKXtyZXR1cm4gVShNYXRoLnJhbmRvbSgpKnIpfTpmdW5jdGlvbigpe3JldHVybiA4Mzg4NjA4KigxMDczNzQxODI0Kk1hdGgucmFuZG9tKCl8MCkrKDgzODg2MDgqTWF0aC5yYW5kb20oKXwwKX0sZnVuY3Rpb24oZSl7dmFyIHQscixuLGksYSxvPTAsdT1bXSxjPW5ldyBBKGgpO2lmKG51bGw9PWU/ZT15OksoZSwwLHopLGk9VChlL0cpLE8paWYoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyl7Zm9yKHQ9Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoaSo9MikpO288aTspOWUxNTw9KGE9MTMxMDcyKnRbb10rKHRbbysxXT4+PjExKSk/KHI9Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpLHRbb109clswXSx0W28rMV09clsxXSk6KHUucHVzaChhJTFlMTQpLG8rPTIpO289aS8yfWVsc2V7aWYoIWNyeXB0by5yYW5kb21CeXRlcyl0aHJvdyBPPSExLEVycm9yKFIrXCJjcnlwdG8gdW5hdmFpbGFibGVcIik7Zm9yKHQ9Y3J5cHRvLnJhbmRvbUJ5dGVzKGkqPTcpO288aTspOWUxNTw9KGE9MjgxNDc0OTc2NzEwNjU2KigzMSZ0W29dKSsxMDk5NTExNjI3Nzc2KnRbbysxXSs0Mjk0OTY3Mjk2KnRbbysyXSsxNjc3NzIxNip0W28rM10rKHRbbys0XTw8MTYpKyh0W28rNV08PDgpK3Rbbys2XSk/Y3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkodCxvKToodS5wdXNoKGElMWUxNCksbys9Nyk7bz1pLzd9aWYoIU8pZm9yKDtvPGk7KShhPXMoKSk8OWUxNSYmKHVbbysrXT1hJTFlMTQpO2ZvcihpPXVbLS1vXSxlJT1HLGkmJmUmJihhPXFbRy1lXSx1W29dPVUoaS9hKSphKTswPT09dVtvXTt1LnBvcCgpLG8tLSk7aWYobzwwKXU9W249MF07ZWxzZXtmb3Iobj0tMTswPT09dVswXTt1LnNwbGljZSgwLDEpLG4tPUcpO2ZvcihvPTEsYT11WzBdOzEwPD1hO2EvPTEwLG8rKyk7bzxHJiYobi09Ry1vKX1yZXR1cm4gYy5lPW4sYy5jPXUsY30pLEEuc3VtPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPTEsdD1hcmd1bWVudHMscj1uZXcgQSh0WzBdKTtlPHQubGVuZ3RoOylyPXIucGx1cyh0W2UrK10pO3JldHVybiByfSxtPVwiMDEyMzQ1Njc4OVwiLGY9ZnVuY3Rpb24oZSx0LHIsbixpKXt2YXIgYSxvLHUsYyxzLGwsZixwLGc9ZS5pbmRleE9mKFwiLlwiKSxkPXksaD1iO2ZvcigwPD1nJiYoYz1OLE49MCxlPWUucmVwbGFjZShcIi5cIixcIlwiKSxsPShwPW5ldyBBKHQpKS5wb3coZS5sZW5ndGgtZyksTj1jLHAuYz1EKFEoSChsLmMpLGwuZSxcIjBcIiksMTAscixtKSxwLmU9cC5jLmxlbmd0aCksdT1jPShmPUQoZSx0LHIsaT8oYT1NLG0pOihhPW0sTSkpKS5sZW5ndGg7MD09ZlstLWNdO2YucG9wKCkpO2lmKCFmWzBdKXJldHVybiBhLmNoYXJBdCgwKTtpZihnPDA/LS11OihsLmM9ZixsLmU9dSxsLnM9bixmPShsPXYobCxwLGQsaCxyKSkuYyxzPWwucix1PWwuZSksZz1mW289dStkKzFdLGM9ci8yLHM9c3x8bzwwfHxudWxsIT1mW28rMV0scz1oPDQ/KG51bGwhPWd8fHMpJiYoMD09aHx8aD09KGwuczwwPzM6MikpOmM8Z3x8Zz09YyYmKDQ9PWh8fHN8fDY9PWgmJjEmZltvLTFdfHxoPT0obC5zPDA/ODo3KSksbzwxfHwhZlswXSllPXM/UShhLmNoYXJBdCgxKSwtZCxhLmNoYXJBdCgwKSk6YS5jaGFyQXQoMCk7ZWxzZXtpZihmLmxlbmd0aD1vLHMpZm9yKC0tcjsrK2ZbLS1vXT5yOylmW29dPTAsb3x8KCsrdSxmPVsxXS5jb25jYXQoZikpO2ZvcihjPWYubGVuZ3RoOyFmWy0tY107KTtmb3IoZz0wLGU9XCJcIjtnPD1jO2UrPWEuY2hhckF0KGZbZysrXSkpO2U9UShlLHUsYS5jaGFyQXQoMCkpfXJldHVybiBlfSx2PWZ1bmN0aW9uKGUsdCxyLG4saSl7dmFyIGEsbyx1LGMscyxsLGYscCxnLGQsaCx2LG0seSxiLHcsUyx4PWUucz09dC5zPzE6LTEsTz1lLmMsTj10LmM7aWYoIShPJiZPWzBdJiZOJiZOWzBdKSlyZXR1cm4gbmV3IEEoZS5zJiZ0LnMmJihPPyFOfHxPWzBdIT1OWzBdOk4pP08mJjA9PU9bMF18fCFOPzAqeDp4LzA6TmFOKTtmb3IoZz0ocD1uZXcgQSh4KSkuYz1bXSx4PXIrKG89ZS5lLXQuZSkrMSxpfHwoaT0kLG89VyhlLmUvRyktVyh0LmUvRykseD14L0d8MCksdT0wO05bdV09PShPW3VdfHwwKTt1KyspO2lmKE5bdV0+KE9bdV18fDApJiZvLS0seDwwKWcucHVzaCgxKSxjPSEwO2Vsc2V7Zm9yKHk9Ty5sZW5ndGgsdz1OLmxlbmd0aCx4Kz0yLDE8KHM9VShpLyhOW3U9MF0rMSkpKSYmKE49RShOLHMsaSksTz1FKE8scyxpKSx3PU4ubGVuZ3RoLHk9Ty5sZW5ndGgpLG09dyxoPShkPU8uc2xpY2UoMCx3KSkubGVuZ3RoO2g8dztkW2grK109MCk7Uz1OLnNsaWNlKCksUz1bMF0uY29uY2F0KFMpLGI9TlswXSxOWzFdPj1pLzImJmIrKztkb3tpZihzPTAsKGE9RihOLGQsdyxoKSk8MCl7aWYodj1kWzBdLHchPWgmJih2PXYqaSsoZFsxXXx8MCkpLDE8KHM9VSh2L2IpKSlmb3IoaTw9cyYmKHM9aS0xKSxmPShsPUUoTixzLGkpKS5sZW5ndGgsaD1kLmxlbmd0aDsxPT1GKGwsZCxmLGgpOylzLS0sayhsLHc8Zj9TOk4sZixpKSxmPWwubGVuZ3RoLGE9MTtlbHNlIDA9PXMmJihhPXM9MSksZj0obD1OLnNsaWNlKCkpLmxlbmd0aDtpZihmPGgmJihsPVswXS5jb25jYXQobCkpLGsoZCxsLGgsaSksaD1kLmxlbmd0aCwtMT09YSlmb3IoO0YoTixkLHcsaCk8MTspcysrLGsoZCx3PGg/UzpOLGgsaSksaD1kLmxlbmd0aH1lbHNlIDA9PT1hJiYocysrLGQ9WzBdKTtnW3UrK109cyxkWzBdP2RbaCsrXT1PW21dfHwwOihkPVtPW21dXSxoPTEpfXdoaWxlKChtKys8eXx8bnVsbCE9ZFswXSkmJngtLSk7Yz1udWxsIT1kWzBdLGdbMF18fGcuc3BsaWNlKDAsMSl9aWYoaT09JCl7Zm9yKHU9MSx4PWdbMF07MTA8PXg7eC89MTAsdSsrKTtQKHAscisocC5lPXUrbypHLTEpKzEsbixjKX1lbHNlIHAuZT1vLHAucj0rYztyZXR1cm4gcH0sbz0vXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLHU9L14oW14uXSspXFwuJC8sYz0vXlxcLihbXi5dKykkLyxsPS9eLT8oSW5maW5pdHl8TmFOKSQvLGc9L15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nLHA9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGksYT1yP3Q6dC5yZXBsYWNlKGcsXCJcIik7aWYobC50ZXN0KGEpKWUucz1pc05hTihhKT9udWxsOmE8MD8tMToxO2Vsc2V7aWYoIXImJihhPWEucmVwbGFjZShvLGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gaT1cInhcIj09KHI9ci50b0xvd2VyQ2FzZSgpKT8xNjpcImJcIj09cj8yOjgsbiYmbiE9aT9lOnR9KSxuJiYoaT1uLGE9YS5yZXBsYWNlKHUsXCIkMVwiKS5yZXBsYWNlKGMsXCIwLiQxXCIpKSx0IT1hKSlyZXR1cm4gbmV3IEEoYSxpKTtpZihBLkRFQlVHKXRocm93IEVycm9yKFIrXCJOb3QgYVwiKyhuP1wiIGJhc2UgXCIrbjpcIlwiKStcIiBudW1iZXI6IFwiK3QpO2Uucz1udWxsfWUuYz1lLmU9bnVsbH0sbi5hYnNvbHV0ZVZhbHVlPW4uYWJzPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IEEodGhpcyk7cmV0dXJuIGUuczwwJiYoZS5zPTEpLGV9LG4uY29tcGFyZWRUbz1mdW5jdGlvbihlLHQpe3JldHVybiBZKHRoaXMsbmV3IEEoZSx0KSl9LG4uZGVjaW1hbFBsYWNlcz1uLmRwPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpO2lmKG51bGwhPWUpcmV0dXJuIEsoZSwwLHopLG51bGw9PXQ/dD1iOksodCwwLDgpLFAobmV3IEEodGhpcyksZSt0aGlzLmUrMSx0KTtpZighKHI9dGhpcy5jKSlyZXR1cm4gbnVsbDtpZihuPSgoaT1yLmxlbmd0aC0xKS1XKHRoaXMuZS9HKSkqRyxpPXJbaV0pZm9yKDtpJTEwPT0wO2kvPTEwLG4tLSk7cmV0dXJuIG48MCYmKG49MCksbn0sbi5kaXZpZGVkQnk9bi5kaXY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdih0aGlzLG5ldyBBKGUsdCkseSxiKX0sbi5kaXZpZGVkVG9JbnRlZ2VyQnk9bi5pZGl2PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHYodGhpcyxuZXcgQShlLHQpLDAsMSl9LG4uZXhwb25lbnRpYXRlZEJ5PW4ucG93PWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLGEsbyx1LGMscyxsPXRoaXM7aWYoKGU9bmV3IEEoZSkpLmMmJiFlLmlzSW50ZWdlcigpKXRocm93IEVycm9yKFIrXCJFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogXCIraihlKSk7aWYobnVsbCE9dCYmKHQ9bmV3IEEodCkpLG89MTQ8ZS5lLCFsLmN8fCFsLmNbMF18fDE9PWwuY1swXSYmIWwuZSYmMT09bC5jLmxlbmd0aHx8IWUuY3x8IWUuY1swXSlyZXR1cm4gcz1uZXcgQShNYXRoLnBvdygraihsKSxvPzItSihlKToraihlKSkpLHQ/cy5tb2QodCk6cztpZih1PWUuczwwLHQpe2lmKHQuYz8hdC5jWzBdOiF0LnMpcmV0dXJuIG5ldyBBKE5hTik7KG49IXUmJmwuaXNJbnRlZ2VyKCkmJnQuaXNJbnRlZ2VyKCkpJiYobD1sLm1vZCh0KSl9ZWxzZXtpZig5PGUuZSYmKDA8bC5lfHxsLmU8LTF8fCgwPT1sLmU/MTxsLmNbMF18fG8mJjI0ZTc8PWwuY1sxXTpsLmNbMF08OGUxM3x8byYmbC5jWzBdPD05OTk5OTc1ZTcpKSlyZXR1cm4gYT1sLnM8MCYmSihlKT8tMDowLC0xPGwuZSYmKGE9MS9hKSxuZXcgQSh1PzEvYTphKTtOJiYoYT1UKE4vRysyKSl9Zm9yKGM9bz8ocj1uZXcgQSguNSksdSYmKGUucz0xKSxKKGUpKTooaT1NYXRoLmFicygraihlKSkpJTIscz1uZXcgQShoKTs7KXtpZihjKXtpZighKHM9cy50aW1lcyhsKSkuYylicmVhazthP3MuYy5sZW5ndGg+YSYmKHMuYy5sZW5ndGg9YSk6biYmKHM9cy5tb2QodCkpfWlmKGkpe2lmKDA9PT0oaT1VKGkvMikpKWJyZWFrO2M9aSUyfWVsc2UgaWYoUChlPWUudGltZXMociksZS5lKzEsMSksMTQ8ZS5lKWM9SihlKTtlbHNle2lmKDA9PShpPStqKGUpKSlicmVhaztjPWklMn1sPWwudGltZXMobCksYT9sLmMmJmwuYy5sZW5ndGg+YSYmKGwuYy5sZW5ndGg9YSk6biYmKGw9bC5tb2QodCkpfXJldHVybiBuP3M6KHUmJihzPWguZGl2KHMpKSx0P3MubW9kKHQpOmE/UChzLE4sYix2b2lkIDApOnMpfSxuLmludGVnZXJWYWx1ZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQSh0aGlzKTtyZXR1cm4gbnVsbD09ZT9lPWI6SyhlLDAsOCksUCh0LHQuZSsxLGUpfSxuLmlzRXF1YWxUbz1uLmVxPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDA9PT1ZKHRoaXMsbmV3IEEoZSx0KSl9LG4uaXNGaW5pdGU9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuY30sbi5pc0dyZWF0ZXJUaGFuPW4uZ3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMDxZKHRoaXMsbmV3IEEoZSx0KSl9LG4uaXNHcmVhdGVyVGhhbk9yRXF1YWxUbz1uLmd0ZT1mdW5jdGlvbihlLHQpe3JldHVybiAxPT09KHQ9WSh0aGlzLG5ldyBBKGUsdCkpKXx8MD09PXR9LG4uaXNJbnRlZ2VyPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmMmJlcodGhpcy5lL0cpPnRoaXMuYy5sZW5ndGgtMn0sbi5pc0xlc3NUaGFuPW4ubHQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gWSh0aGlzLG5ldyBBKGUsdCkpPDB9LG4uaXNMZXNzVGhhbk9yRXF1YWxUbz1uLmx0ZT1mdW5jdGlvbihlLHQpe3JldHVybi0xPT09KHQ9WSh0aGlzLG5ldyBBKGUsdCkpKXx8MD09PXR9LG4uaXNOYU49ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5zfSxuLmlzTmVnYXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zPDB9LG4uaXNQb3NpdGl2ZT1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuc30sbi5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuYyYmMD09dGhpcy5jWzBdfSxuLm1pbnVzPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLGEsbz10aGlzLHU9by5zO2lmKHQ9KGU9bmV3IEEoZSx0KSkucywhdXx8IXQpcmV0dXJuIG5ldyBBKE5hTik7aWYodSE9dClyZXR1cm4gZS5zPS10LG8ucGx1cyhlKTt2YXIgYz1vLmUvRyxzPWUuZS9HLGw9by5jLGY9ZS5jO2lmKCFjfHwhcyl7aWYoIWx8fCFmKXJldHVybiBsPyhlLnM9LXQsZSk6bmV3IEEoZj9vOk5hTik7aWYoIWxbMF18fCFmWzBdKXJldHVybiBmWzBdPyhlLnM9LXQsZSk6bmV3IEEobFswXT9vOjM9PWI/LTA6MCl9aWYoYz1XKGMpLHM9VyhzKSxsPWwuc2xpY2UoKSx1PWMtcyl7Zm9yKChpPShhPXU8MCk/KHU9LXUsbCk6KHM9YyxmKSkucmV2ZXJzZSgpLHQ9dTt0LS07aS5wdXNoKDApKTtpLnJldmVyc2UoKX1lbHNlIGZvcihuPShhPSh1PWwubGVuZ3RoKTwodD1mLmxlbmd0aCkpP3U6dCx1PXQ9MDt0PG47dCsrKWlmKGxbdF0hPWZbdF0pe2E9bFt0XTxmW3RdO2JyZWFrfWlmKGEmJihpPWwsbD1mLGY9aSxlLnM9LWUucyksMDwodD0obj1mLmxlbmd0aCktKHI9bC5sZW5ndGgpKSlmb3IoO3QtLTtsW3IrK109MCk7Zm9yKHQ9JC0xO3U8bjspe2lmKGxbLS1uXTxmW25dKXtmb3Iocj1uO3ImJiFsWy0tcl07bFtyXT10KTstLWxbcl0sbFtuXSs9JH1sW25dLT1mW25dfWZvcig7MD09bFswXTtsLnNwbGljZSgwLDEpLC0tcyk7cmV0dXJuIGxbMF0/TChlLGwscyk6KGUucz0zPT1iPy0xOjEsZS5jPVtlLmU9MF0sZSl9LG4ubW9kdWxvPW4ubW9kPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpPXRoaXM7cmV0dXJuIGU9bmV3IEEoZSx0KSwhaS5jfHwhZS5zfHxlLmMmJiFlLmNbMF0/bmV3IEEoTmFOKTohZS5jfHxpLmMmJiFpLmNbMF0/bmV3IEEoaSk6KDk9PWE/KG49ZS5zLGUucz0xLHI9dihpLGUsMCwzKSxlLnM9bixyLnMqPW4pOnI9dihpLGUsMCxhKSwoZT1pLm1pbnVzKHIudGltZXMoZSkpKS5jWzBdfHwxIT1hfHwoZS5zPWkucyksZSl9LG4ubXVsdGlwbGllZEJ5PW4udGltZXM9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksYSxvLHUsYyxzLGwsZixwLGcsZCxoLHYsbT10aGlzLHk9bS5jLGI9KGU9bmV3IEEoZSx0KSkuYztpZighKHkmJmImJnlbMF0mJmJbMF0pKXJldHVybiFtLnN8fCFlLnN8fHkmJiF5WzBdJiYhYnx8YiYmIWJbMF0mJiF5P2UuYz1lLmU9ZS5zPW51bGw6KGUucyo9bS5zLHkmJmI/KGUuYz1bMF0sZS5lPTApOmUuYz1lLmU9bnVsbCksZTtmb3Iobj1XKG0uZS9HKStXKGUuZS9HKSxlLnMqPW0ucywoYz15Lmxlbmd0aCk8KGY9Yi5sZW5ndGgpJiYoZD15LHk9YixiPWQsaT1jLGM9ZixmPWkpLGk9YytmLGQ9W107aS0tO2QucHVzaCgwKSk7Zm9yKGg9JCx2PVosaT1mOzA8PS0taTspe2ZvcihyPTAscD1iW2ldJXYsZz1iW2ldL3Z8MCxhPWkrKG89Yyk7aTxhOylyPSgocz1wKihzPXlbLS1vXSV2KSsodT1nKnMrKGw9eVtvXS92fDApKnApJXYqditkW2FdK3IpL2h8MCkrKHUvdnwwKStnKmwsZFthLS1dPXMlaDtkW2FdPXJ9cmV0dXJuIHI/KytuOmQuc3BsaWNlKDAsMSksTChlLGQsbil9LG4ubmVnYXRlZD1mdW5jdGlvbigpe3ZhciBlPW5ldyBBKHRoaXMpO3JldHVybiBlLnM9LWUuc3x8bnVsbCxlfSxuLnBsdXM9ZnVuY3Rpb24oZSx0KXt2YXIgcixuPXRoaXMsaT1uLnM7aWYodD0oZT1uZXcgQShlLHQpKS5zLCFpfHwhdClyZXR1cm4gbmV3IEEoTmFOKTtpZihpIT10KXJldHVybiBlLnM9LXQsbi5taW51cyhlKTt2YXIgYT1uLmUvRyxvPWUuZS9HLHU9bi5jLGM9ZS5jO2lmKCFhfHwhbyl7aWYoIXV8fCFjKXJldHVybiBuZXcgQShpLzApO2lmKCF1WzBdfHwhY1swXSlyZXR1cm4gY1swXT9lOm5ldyBBKHVbMF0/bjowKmkpfWlmKGE9VyhhKSxvPVcobyksdT11LnNsaWNlKCksaT1hLW8pe2Zvcigocj0wPGk/KG89YSxjKTooaT0taSx1KSkucmV2ZXJzZSgpO2ktLTtyLnB1c2goMCkpO3IucmV2ZXJzZSgpfWZvcigoaT11Lmxlbmd0aCktKHQ9Yy5sZW5ndGgpPDAmJihyPWMsYz11LHU9cix0PWkpLGk9MDt0OylpPSh1Wy0tdF09dVt0XStjW3RdK2kpLyR8MCx1W3RdPSQ9PT11W3RdPzA6dVt0XSUkO3JldHVybiBpJiYodT1baV0uY29uY2F0KHUpLCsrbyksTChlLHUsbyl9LG4ucHJlY2lzaW9uPW4uc2Q9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGk7aWYobnVsbCE9ZSYmZSE9PSEhZSlyZXR1cm4gSyhlLDEseiksbnVsbD09dD90PWI6Syh0LDAsOCksUChuZXcgQSh0aGlzKSxlLHQpO2lmKCEocj10aGlzLmMpKXJldHVybiBudWxsO2lmKG49KGk9ci5sZW5ndGgtMSkqRysxLGk9cltpXSl7Zm9yKDtpJTEwPT0wO2kvPTEwLG4tLSk7Zm9yKGk9clswXTsxMDw9aTtpLz0xMCxuKyspO31yZXR1cm4gZSYmdGhpcy5lKzE+biYmKG49dGhpcy5lKzEpLG59LG4uc2hpZnRlZEJ5PWZ1bmN0aW9uKGUpe3JldHVybiBLKGUsLVYsViksdGhpcy50aW1lcyhcIjFlXCIrZSl9LG4uc3F1YXJlUm9vdD1uLnNxcnQ9ZnVuY3Rpb24oKXt2YXIgZSx0LHIsbixpLGE9dGhpcyxvPWEuYyx1PWEucyxjPWEuZSxzPXkrNCxsPW5ldyBBKFwiMC41XCIpO2lmKDEhPT11fHwhb3x8IW9bMF0pcmV0dXJuIG5ldyBBKCF1fHx1PDAmJighb3x8b1swXSk/TmFOOm8/YToxLzApO2lmKChyPTA9PSh1PU1hdGguc3FydCgraihhKSkpfHx1PT0xLzA/KCgodD1IKG8pKS5sZW5ndGgrYyklMj09MCYmKHQrPVwiMFwiKSx1PU1hdGguc3FydCgrdCksYz1XKChjKzEpLzIpLShjPDB8fGMlMiksbmV3IEEodD11PT0xLzA/XCI1ZVwiK2M6KHQ9dS50b0V4cG9uZW50aWFsKCkpLnNsaWNlKDAsdC5pbmRleE9mKFwiZVwiKSsxKStjKSk6bmV3IEEodStcIlwiKSkuY1swXSlmb3IoKHU9KGM9ci5lKStzKTwzJiYodT0wKTs7KWlmKGk9cixyPWwudGltZXMoaS5wbHVzKHYoYSxpLHMsMSkpKSxIKGkuYykuc2xpY2UoMCx1KT09PSh0PUgoci5jKSkuc2xpY2UoMCx1KSl7aWYoci5lPGMmJi0tdSxcIjk5OTlcIiE9KHQ9dC5zbGljZSh1LTMsdSsxKSkmJihufHxcIjQ5OTlcIiE9dCkpeyt0JiYoK3Quc2xpY2UoMSl8fFwiNVwiIT10LmNoYXJBdCgwKSl8fChQKHIsci5lK3krMiwxKSxlPSFyLnRpbWVzKHIpLmVxKGEpKTticmVha31pZighbiYmKFAoaSxpLmUreSsyLDApLGkudGltZXMoaSkuZXEoYSkpKXtyPWk7YnJlYWt9cys9NCx1Kz00LG49MX1yZXR1cm4gUChyLHIuZSt5KzEsYixlKX0sbi50b0V4cG9uZW50aWFsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGwhPWUmJihLKGUsMCx6KSxlKyspLGkodGhpcyxlLHQsMSl9LG4udG9GaXhlZD1mdW5jdGlvbihlLHQpe3JldHVybiBudWxsIT1lJiYoSyhlLDAseiksZT1lK3RoaXMuZSsxKSxpKHRoaXMsZSx0KX0sbi50b0Zvcm1hdD1mdW5jdGlvbihlLHQscil7dmFyIG47aWYobnVsbD09ciludWxsIT1lJiZ0JiZcIm9iamVjdFwiPT10eXBlb2YgdD8ocj10LHQ9bnVsbCk6ZSYmXCJvYmplY3RcIj09dHlwZW9mIGU/KHI9ZSxlPXQ9bnVsbCk6cj1CO2Vsc2UgaWYoXCJvYmplY3RcIiE9dHlwZW9mIHIpdGhyb3cgRXJyb3IoUitcIkFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IFwiK3IpO2lmKG49dGhpcy50b0ZpeGVkKGUsdCksdGhpcy5jKXt2YXIgaSxhPW4uc3BsaXQoXCIuXCIpLG89K3IuZ3JvdXBTaXplLHU9K3Iuc2Vjb25kYXJ5R3JvdXBTaXplLGM9ci5ncm91cFNlcGFyYXRvcnx8XCJcIixzPWFbMF0sbD1hWzFdLGY9dGhpcy5zPDAscD1mP3Muc2xpY2UoMSk6cyxnPXAubGVuZ3RoO2lmKHUmJihpPW8sbz11LGctPXU9aSksMDxvJiYwPGcpe2ZvcihpPWclb3x8byxzPXAuc3Vic3RyKDAsaSk7aTxnO2krPW8pcys9YytwLnN1YnN0cihpLG8pOzA8dSYmKHMrPWMrcC5zbGljZShpKSksZiYmKHM9XCItXCIrcyl9bj1sP3MrKHIuZGVjaW1hbFNlcGFyYXRvcnx8XCJcIikrKCh1PStyLmZyYWN0aW9uR3JvdXBTaXplKT9sLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxke1wiK3UrXCJ9XFxcXEJcIixcImdcIiksXCIkJlwiKyhyLmZyYWN0aW9uR3JvdXBTZXBhcmF0b3J8fFwiXCIpKTpsKTpzfXJldHVybihyLnByZWZpeHx8XCJcIikrbisoci5zdWZmaXh8fFwiXCIpfSxuLnRvRnJhY3Rpb249ZnVuY3Rpb24oZSl7dmFyIHQscixuLGksYSxvLHUsYyxzLGwsZixwLGc9dGhpcyxkPWcuYztpZihudWxsIT1lJiYoISh1PW5ldyBBKGUpKS5pc0ludGVnZXIoKSYmKHUuY3x8MSE9PXUucyl8fHUubHQoaCkpKXRocm93IEVycm9yKFIrXCJBcmd1bWVudCBcIisodS5pc0ludGVnZXIoKT9cIm91dCBvZiByYW5nZTogXCI6XCJub3QgYW4gaW50ZWdlcjogXCIpK2oodSkpO2lmKCFkKXJldHVybiBuZXcgQShnKTtmb3IodD1uZXcgQShoKSxzPXI9bmV3IEEoaCksbj1jPW5ldyBBKGgpLHA9SChkKSxhPXQuZT1wLmxlbmd0aC1nLmUtMSx0LmNbMF09cVsobz1hJUcpPDA/RytvOm9dLGU9IWV8fDA8dS5jb21wYXJlZFRvKHQpPzA8YT90OnM6dSxvPXgseD0xLzAsdT1uZXcgQShwKSxjLmNbMF09MDtsPXYodSx0LDAsMSksMSE9KGk9ci5wbHVzKGwudGltZXMobikpKS5jb21wYXJlZFRvKGUpOylyPW4sbj1pLHM9Yy5wbHVzKGwudGltZXMoaT1zKSksYz1pLHQ9dS5taW51cyhsLnRpbWVzKGk9dCkpLHU9aTtyZXR1cm4gaT12KGUubWludXMociksbiwwLDEpLGM9Yy5wbHVzKGkudGltZXMocykpLHI9ci5wbHVzKGkudGltZXMobikpLGMucz1zLnM9Zy5zLGY9dihzLG4sYSo9MixiKS5taW51cyhnKS5hYnMoKS5jb21wYXJlZFRvKHYoYyxyLGEsYikubWludXMoZykuYWJzKCkpPDE/W3Msbl06W2Mscl0seD1vLGZ9LG4udG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4raih0aGlzKX0sbi50b1ByZWNpc2lvbj1mdW5jdGlvbihlLHQpe3JldHVybiBudWxsIT1lJiZLKGUsMSx6KSxpKHRoaXMsZSx0LDIpfSxuLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0LHI9dGhpcyxuPXIucyxpPXIuZTtyZXR1cm4gbnVsbD09PWk/bj8odD1cIkluZmluaXR5XCIsbjwwJiYodD1cIi1cIit0KSk6dD1cIk5hTlwiOih0PW51bGw9PWU/aTw9ZHx8dzw9aT9YKEgoci5jKSxpKTpRKEgoci5jKSxpLFwiMFwiKToxMD09PWU/UShIKChyPVAobmV3IEEocikseStpKzEsYikpLmMpLHIuZSxcIjBcIik6KEsoZSwyLE0ubGVuZ3RoLFwiQmFzZVwiKSxmKFEoSChyLmMpLGksXCIwXCIpLDEwLGUsbiwhMCkpLG48MCYmci5jWzBdJiYodD1cIi1cIit0KSksdH0sbi52YWx1ZU9mPW4udG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIGoodGhpcyl9LG4uX2lzQmlnTnVtYmVyPSEwLG51bGwhPXQmJkEuc2V0KHQpLEF9KCkpLmRlZmF1bHQ9dC5CaWdOdW1iZXI9dCx2b2lkIDAhPT1yJiZyLmV4cG9ydHM/ci5leHBvcnRzPXQ6KGU9ZXx8KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmP3NlbGY6d2luZG93KSkuQmlnTnVtYmVyPXR9KHRoaXMpfSx7fV0sMjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz17bGFuZ3VhZ2VUYWc6XCJlbi1VU1wiLGRlbGltaXRlcnM6e3Rob3VzYW5kczpcIixcIixkZWNpbWFsOlwiLlwifSxhYmJyZXZpYXRpb25zOnt0aG91c2FuZDpcImtcIixtaWxsaW9uOlwibVwiLGJpbGxpb246XCJiXCIsdHJpbGxpb246XCJ0XCJ9LHNwYWNlU2VwYXJhdGVkOiExLG9yZGluYWw6ZnVuY3Rpb24oZSl7dmFyIHQ9ZSUxMDtyZXR1cm4gMT09fn4oZSUxMDAvMTApP1widGhcIjoxPT10P1wic3RcIjoyPT10P1wibmRcIjozPT10P1wicmRcIjpcInRoXCJ9LGJ5dGVzOntiaW5hcnlTdWZmaXhlczpbXCJCXCIsXCJLaUJcIixcIk1pQlwiLFwiR2lCXCIsXCJUaUJcIixcIlBpQlwiLFwiRWlCXCIsXCJaaUJcIixcIllpQlwiXSxkZWNpbWFsU3VmZml4ZXM6W1wiQlwiLFwiS0JcIixcIk1CXCIsXCJHQlwiLFwiVEJcIixcIlBCXCIsXCJFQlwiLFwiWkJcIixcIllCXCJdfSxjdXJyZW5jeTp7c3ltYm9sOlwiJFwiLHBvc2l0aW9uOlwicHJlZml4XCIsY29kZTpcIlVTRFwifSxjdXJyZW5jeUZvcm1hdDp7dGhvdXNhbmRTZXBhcmF0ZWQ6ITAsdG90YWxMZW5ndGg6NCxzcGFjZVNlcGFyYXRlZDohMCxzcGFjZVNlcGFyYXRlZEN1cnJlbmN5OiEwfSxmb3JtYXRzOntmb3VyRGlnaXRzOnt0b3RhbExlbmd0aDo0LHNwYWNlU2VwYXJhdGVkOiEwfSxmdWxsV2l0aFR3b0RlY2ltYWxzOntvdXRwdXQ6XCJjdXJyZW5jeVwiLHRob3VzYW5kU2VwYXJhdGVkOiEwLG1hbnRpc3NhOjJ9LGZ1bGxXaXRoVHdvRGVjaW1hbHNOb0N1cnJlbmN5Ont0aG91c2FuZFNlcGFyYXRlZDohMCxtYW50aXNzYToyfSxmdWxsV2l0aE5vRGVjaW1hbHM6e291dHB1dDpcImN1cnJlbmN5XCIsdGhvdXNhbmRTZXBhcmF0ZWQ6ITAsbWFudGlzc2E6MH19fX0se31dLDM6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBJKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9KGUpfHxmdW5jdGlvbihlLHQpe2lmKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSkpcmV0dXJuO3ZhciByPVtdLG49ITAsaT0hMSxhPXZvaWQgMDt0cnl7Zm9yKHZhciBvLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShuPShvPXUubmV4dCgpKS5kb25lKSYmKHIucHVzaChvLnZhbHVlKSwhdHx8ci5sZW5ndGghPT10KTtuPSEwKTt9Y2F0Y2goZSl7aT0hMCxhPWV9ZmluYWxseXt0cnl7bnx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihpKXRocm93IGF9fXJldHVybiByfShlLHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfXZhciAkPWUoXCIuL2dsb2JhbFN0YXRlXCIpLG89ZShcIi4vdmFsaWRhdGluZ1wiKSx1PWUoXCIuL3BhcnNpbmdcIiksRz17dHJpbGxpb246TWF0aC5wb3coMTAsMTIpLGJpbGxpb246TWF0aC5wb3coMTAsOSksbWlsbGlvbjpNYXRoLnBvdygxMCw2KSx0aG91c2FuZDpNYXRoLnBvdygxMCwzKX0sVj17dG90YWxMZW5ndGg6MCxjaGFyYWN0ZXJpc3RpYzowLGZvcmNlQXZlcmFnZTohMSxhdmVyYWdlOiExLG1hbnRpc3NhOi0xLG9wdGlvbmFsTWFudGlzc2E6ITAsdGhvdXNhbmRTZXBhcmF0ZWQ6ITEsc3BhY2VTZXBhcmF0ZWQ6ITEsbmVnYXRpdmU6XCJzaWduXCIsZm9yY2VTaWduOiExLHJvdW5kaW5nRnVuY3Rpb246TWF0aC5yb3VuZCxzcGFjZVNlcGFyYXRlZEFiYnJldmlhdGlvbjohMX0sbj0kLmN1cnJlbnRCeXRlcygpLGQ9bi5iaW5hcnlTdWZmaXhlcyxoPW4uZGVjaW1hbFN1ZmZpeGVzLGk9e2dlbmVyYWw6e3NjYWxlOjEwMjQsc3VmZml4ZXM6aCxtYXJrZXI6XCJiZFwifSxiaW5hcnk6e3NjYWxlOjEwMjQsc3VmZml4ZXM6ZCxtYXJrZXI6XCJiXCJ9LGRlY2ltYWw6e3NjYWxlOjFlMyxzdWZmaXhlczpoLG1hcmtlcjpcImRcIn19O2Z1bmN0aW9uIGEoZSl7dmFyIHQ9MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LHI9Mjxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1syXTp2b2lkIDA7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PXUucGFyc2VGb3JtYXQodCkpLCFvLnZhbGlkYXRlRm9ybWF0KHQpKXJldHVyblwiRVJST1I6IGludmFsaWQgZm9ybWF0XCI7dmFyIG49dC5wcmVmaXh8fFwiXCIsaT10LnBvc3RmaXh8fFwiXCIsYT1mdW5jdGlvbihlLHQscil7c3dpdGNoKHQub3V0cHV0KXtjYXNlXCJjdXJyZW5jeVwiOnJldHVybiB0PWModCwkLmN1cnJlbnRDdXJyZW5jeURlZmF1bHRGb3JtYXQoKSksZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIuY3VycmVudEN1cnJlbmN5KCksaT1PYmplY3QuYXNzaWduKHt9LFYsdCksYT12b2lkIDAsbz1cIlwiLHU9ISFpLnRvdGFsTGVuZ3RofHwhIWkuZm9yY2VBdmVyYWdlfHxpLmF2ZXJhZ2UsYz10LmN1cnJlbmN5UG9zaXRpb258fG4ucG9zaXRpb24scz10LmN1cnJlbmN5U3ltYm9sfHxuLnN5bWJvbCxsPXZvaWQgMCE9PWkuc3BhY2VTZXBhcmF0ZWRDdXJyZW5jeT9pLnNwYWNlU2VwYXJhdGVkQ3VycmVuY3k6aS5zcGFjZVNlcGFyYXRlZDt2b2lkIDA9PT10Lmxvd1ByZWNpc2lvbiYmKHQubG93UHJlY2lzaW9uPSExKTtsJiYobz1cIiBcIik7XCJpbmZpeFwiPT09YyYmKGE9bytzK28pO3ZhciBmPW0oe2luc3RhbmNlOmUscHJvdmlkZWRGb3JtYXQ6dCxzdGF0ZTpyLGRlY2ltYWxTZXBhcmF0b3I6YX0pO1wicHJlZml4XCI9PT1jJiYoZj1lLl92YWx1ZTwwJiZcInNpZ25cIj09PWkubmVnYXRpdmU/XCItXCIuY29uY2F0KG8pLmNvbmNhdChzKS5jb25jYXQoZi5zbGljZSgxKSk6MDxlLl92YWx1ZSYmaS5mb3JjZVNpZ24/XCIrXCIuY29uY2F0KG8pLmNvbmNhdChzKS5jb25jYXQoZi5zbGljZSgxKSk6cytvK2YpO2MmJlwicG9zdGZpeFwiIT09Y3x8KG89IWkuc3BhY2VTZXBhcmF0ZWRBYmJyZXZpYXRpb24mJnU/XCJcIjpvLGY9ZitvK3MpO3JldHVybiBmfShlLHQsJCk7Y2FzZVwicGVyY2VudFwiOnJldHVybiB0PWModCwkLmN1cnJlbnRQZXJjZW50YWdlRGVmYXVsdEZvcm1hdCgpKSxmdW5jdGlvbihlLHQscixuKXt2YXIgaT10LnByZWZpeFN5bWJvbCxhPW0oe2luc3RhbmNlOm4oMTAwKmUuX3ZhbHVlKSxwcm92aWRlZEZvcm1hdDp0LHN0YXRlOnJ9KSxvPU9iamVjdC5hc3NpZ24oe30sVix0KTtpZihpKXJldHVyblwiJVwiLmNvbmNhdChvLnNwYWNlU2VwYXJhdGVkP1wiIFwiOlwiXCIpLmNvbmNhdChhKTtyZXR1cm5cIlwiLmNvbmNhdChhKS5jb25jYXQoby5zcGFjZVNlcGFyYXRlZD9cIiBcIjpcIlwiLFwiJVwiKX0oZSx0LCQscik7Y2FzZVwiYnl0ZVwiOnJldHVybiB0PWModCwkLmN1cnJlbnRCeXRlRGVmYXVsdEZvcm1hdCgpKSxmdW5jdGlvbihlLHQscixuKXt2YXIgaT10LmJhc2V8fFwiYmluYXJ5XCIsYT1PYmplY3QuYXNzaWduKHt9LFYsdCksbz1yLmN1cnJlbnRCeXRlcygpLHU9by5iaW5hcnlTdWZmaXhlcyxjPW8uZGVjaW1hbFN1ZmZpeGVzLHM9e2dlbmVyYWw6e3NjYWxlOjEwMjQsc3VmZml4ZXM6Y3x8aCxtYXJrZXI6XCJiZFwifSxiaW5hcnk6e3NjYWxlOjEwMjQsc3VmZml4ZXM6dXx8ZCxtYXJrZXI6XCJiXCJ9LGRlY2ltYWw6e3NjYWxlOjFlMyxzdWZmaXhlczpjfHxoLG1hcmtlcjpcImRcIn19W2ldLGw9dihlLl92YWx1ZSxzLnN1ZmZpeGVzLHMuc2NhbGUpLGY9bC52YWx1ZSxwPWwuc3VmZml4LGc9bSh7aW5zdGFuY2U6bihmKSxwcm92aWRlZEZvcm1hdDp0LHN0YXRlOnIsZGVmYXVsdHM6ci5jdXJyZW50Qnl0ZURlZmF1bHRGb3JtYXQoKX0pO3JldHVyblwiXCIuY29uY2F0KGcpLmNvbmNhdChhLnNwYWNlU2VwYXJhdGVkP1wiIFwiOlwiXCIpLmNvbmNhdChwKX0oZSx0LCQscik7Y2FzZVwidGltZVwiOnJldHVybiB0PWModCwkLmN1cnJlbnRUaW1lRGVmYXVsdEZvcm1hdCgpKSxmdW5jdGlvbihlKXt2YXIgdD1NYXRoLmZsb29yKGUuX3ZhbHVlLzYwLzYwKSxyPU1hdGguZmxvb3IoKGUuX3ZhbHVlLTYwKnQqNjApLzYwKSxuPU1hdGgucm91bmQoZS5fdmFsdWUtNjAqdCo2MC02MCpyKTtyZXR1cm5cIlwiLmNvbmNhdCh0LFwiOlwiKS5jb25jYXQocjwxMD9cIjBcIjpcIlwiKS5jb25jYXQocixcIjpcIikuY29uY2F0KG48MTA/XCIwXCI6XCJcIikuY29uY2F0KG4pfShlKTtjYXNlXCJvcmRpbmFsXCI6cmV0dXJuIHQ9Yyh0LCQuY3VycmVudE9yZGluYWxEZWZhdWx0Rm9ybWF0KCkpLGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yLmN1cnJlbnRPcmRpbmFsKCksaT1PYmplY3QuYXNzaWduKHt9LFYsdCksYT1tKHtpbnN0YW5jZTplLHByb3ZpZGVkRm9ybWF0OnQsc3RhdGU6cn0pLG89bihlLl92YWx1ZSk7cmV0dXJuXCJcIi5jb25jYXQoYSkuY29uY2F0KGkuc3BhY2VTZXBhcmF0ZWQ/XCIgXCI6XCJcIikuY29uY2F0KG8pfShlLHQsJCk7Y2FzZVwibnVtYmVyXCI6ZGVmYXVsdDpyZXR1cm4gbSh7aW5zdGFuY2U6ZSxwcm92aWRlZEZvcm1hdDp0LG51bWJybzpyfSl9fShlLHQscik7cmV0dXJuIGE9KGE9bithKStpfWZ1bmN0aW9uIHYoZSx0LHIpe3ZhciBuPXRbMF0saT1NYXRoLmFicyhlKTtpZihyPD1pKXtmb3IodmFyIGE9MTthPHQubGVuZ3RoOysrYSl7dmFyIG89TWF0aC5wb3cocixhKSx1PU1hdGgucG93KHIsYSsxKTtpZihvPD1pJiZpPHUpe249dFthXSxlLz1vO2JyZWFrfX1uPT09dFswXSYmKGUvPU1hdGgucG93KHIsdC5sZW5ndGgtMSksbj10W3QubGVuZ3RoLTFdKX1yZXR1cm57dmFsdWU6ZSxzdWZmaXg6bn19ZnVuY3Rpb24gcChlKXtmb3IodmFyIHQ9XCJcIixyPTA7cjxlO3IrKyl0Kz1cIjBcIjtyZXR1cm4gdH1mdW5jdGlvbiBxKGUsdCxyKXt2YXIgbj0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PXI/cjpNYXRoLnJvdW5kO3JldHVybi0xIT09ZS50b1N0cmluZygpLmluZGV4T2YoXCJlXCIpP2Z1bmN0aW9uKGUsdCl7dmFyIHI9ZS50b1N0cmluZygpLG49SShyLnNwbGl0KFwiZVwiKSwyKSxpPW5bMF0sYT1uWzFdLG89SShpLnNwbGl0KFwiLlwiKSwyKSx1PW9bMF0sYz1vWzFdLHM9dm9pZCAwPT09Yz9cIlwiOmM7aWYoMDwrYSlyPXUrcytwKGEtcy5sZW5ndGgpO2Vsc2V7dmFyIGw9XCIuXCI7bD0rdTwwP1wiLTBcIi5jb25jYXQobCk6XCIwXCIuY29uY2F0KGwpO3ZhciBmPShwKC1hLTEpK01hdGguYWJzKHUpK3MpLnN1YnN0cigwLHQpO2YubGVuZ3RoPHQmJihmKz1wKHQtZi5sZW5ndGgpKSxyPWwrZn1yZXR1cm4gMDwrYSYmMDx0JiYocis9XCIuXCIuY29uY2F0KHAodCkpKSxyfShlLHQpOihuKCtcIlwiLmNvbmNhdChlLFwiZStcIikuY29uY2F0KHQpKS9NYXRoLnBvdygxMCx0KSkudG9GaXhlZCh0KX1mdW5jdGlvbiBaKGUsdCxyLG4saSl7dmFyIGE9bi5jdXJyZW50RGVsaW1pdGVycygpLG89YS50aG91c2FuZHM7aT1pfHxhLmRlY2ltYWw7dmFyIHU9YS50aG91c2FuZHNTaXplfHwzLGM9ZS50b1N0cmluZygpLHM9Yy5zcGxpdChcIi5cIilbMF0sbD1jLnNwbGl0KFwiLlwiKVsxXSxmPXQ8MCYmMD09PXMuaW5kZXhPZihcIi1cIik7ciYmKGYmJihzPXMuc2xpY2UoMSkpLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPVtdLG49MCxpPWU7MDxpO2ktLSluPT09dCYmKHIudW5zaGlmdChpKSxuPTApLG4rKztyZXR1cm4gcn0ocy5sZW5ndGgsdSkuZm9yRWFjaChmdW5jdGlvbihlLHQpe3M9cy5zbGljZSgwLGUrdCkrbytzLnNsaWNlKGUrdCl9KSxmJiYocz1cIi1cIi5jb25jYXQocykpKTtyZXR1cm4gYz1sP3MraStsOnN9ZnVuY3Rpb24gbShlKXt2YXIgdD1lLmluc3RhbmNlLHI9ZS5wcm92aWRlZEZvcm1hdCxuPWUuc3RhdGUsaT12b2lkIDA9PT1uPyQ6bixhPWUuZGVjaW1hbFNlcGFyYXRvcixvPWUuZGVmYXVsdHMsdT12b2lkIDA9PT1vP2kuY3VycmVudERlZmF1bHRzKCk6byxjPXQuX3ZhbHVlO2lmKDA9PT1jJiZpLmhhc1plcm9Gb3JtYXQoKSlyZXR1cm4gaS5nZXRaZXJvRm9ybWF0KCk7aWYoIWlzRmluaXRlKGMpKXJldHVybiBjLnRvU3RyaW5nKCk7dmFyIHMsbCxmLHAsZyxkLGgsdixtPU9iamVjdC5hc3NpZ24oe30sVix1LHIpLHk9bS50b3RhbExlbmd0aCxiPXk/MDptLmNoYXJhY3RlcmlzdGljLHc9bS5vcHRpb25hbENoYXJhY3RlcmlzdGljLFM9bS5mb3JjZUF2ZXJhZ2UseD1tLmxvd1ByZWNpc2lvbixPPSEheXx8ISFTfHxtLmF2ZXJhZ2UsTj15Py0xOk8mJnZvaWQgMD09PXIubWFudGlzc2E/MDptLm1hbnRpc3NhLEI9IXkmJih2b2lkIDA9PT1yLm9wdGlvbmFsTWFudGlzc2E/LTE9PT1OOm0ub3B0aW9uYWxNYW50aXNzYSksTT1tLnRyaW1NYW50aXNzYSxBPW0udGhvdXNhbmRTZXBhcmF0ZWQsRD1tLnNwYWNlU2VwYXJhdGVkLEU9bS5uZWdhdGl2ZSxGPW0uZm9yY2VTaWduLGs9bS5leHBvbmVudGlhbCxfPW0ucm91bmRpbmdGdW5jdGlvbixMPVwiXCI7aWYoTyl7dmFyIFA9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS52YWx1ZSxyPWUuZm9yY2VBdmVyYWdlLG49ZS5sb3dQcmVjaXNpb24saT12b2lkIDA9PT1ufHxuLGE9ZS5hYmJyZXZpYXRpb25zLG89ZS5zcGFjZVNlcGFyYXRlZCx1PXZvaWQgMCE9PW8mJm8sYz1lLnRvdGFsTGVuZ3RoLHM9dm9pZCAwPT09Yz8wOmMsbD1lLnJvdW5kaW5nRnVuY3Rpb24sZj12b2lkIDA9PT1sP01hdGgucm91bmQ6bCxwPVwiXCIsZz1NYXRoLmFicyh0KSxkPS0xO2lmKHImJmFbcl0mJkdbcl0/KHA9YVtyXSx0Lz1HW3JdKTpnPj1HLnRyaWxsaW9ufHxpJiYxPT09ZihnL0cudHJpbGxpb24pPyhwPWEudHJpbGxpb24sdC89Ry50cmlsbGlvbik6ZzxHLnRyaWxsaW9uJiZnPj1HLmJpbGxpb258fGkmJjE9PT1mKGcvRy5iaWxsaW9uKT8ocD1hLmJpbGxpb24sdC89Ry5iaWxsaW9uKTpnPEcuYmlsbGlvbiYmZz49Ry5taWxsaW9ufHxpJiYxPT09ZihnL0cubWlsbGlvbik/KHA9YS5taWxsaW9uLHQvPUcubWlsbGlvbik6KGc8Ry5taWxsaW9uJiZnPj1HLnRob3VzYW5kfHxpJiYxPT09ZihnL0cudGhvdXNhbmQpKSYmKHA9YS50aG91c2FuZCx0Lz1HLnRob3VzYW5kKSxwPXAmJih1P1wiIFwiOlwiXCIpK3Ascyl7dmFyIGg9dDwwLHY9dC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVswXSxtPWg/di5sZW5ndGgtMTp2Lmxlbmd0aDtkPU1hdGgubWF4KHMtbSwwKX1yZXR1cm57dmFsdWU6dCxhYmJyZXZpYXRpb246cCxtYW50aXNzYVByZWNpc2lvbjpkfX0oe3ZhbHVlOmMsZm9yY2VBdmVyYWdlOlMsbG93UHJlY2lzaW9uOngsYWJicmV2aWF0aW9uczppLmN1cnJlbnRBYmJyZXZpYXRpb25zKCksc3BhY2VTZXBhcmF0ZWQ6RCxyb3VuZGluZ0Z1bmN0aW9uOl8sdG90YWxMZW5ndGg6eX0pO2M9UC52YWx1ZSxMKz1QLmFiYnJldmlhdGlvbix5JiYoTj1QLm1hbnRpc3NhUHJlY2lzaW9uKX1pZihrKXt2YXIgaj0obD0ocz17dmFsdWU6YyxjaGFyYWN0ZXJpc3RpY1ByZWNpc2lvbjpifSkudmFsdWUsZj1zLmNoYXJhY3RlcmlzdGljUHJlY2lzaW9uLHA9dm9pZCAwPT09Zj8wOmYsZz1JKGwudG9FeHBvbmVudGlhbCgpLnNwbGl0KFwiZVwiKSwyKSxkPWdbMF0saD1nWzFdLHY9K2QscCYmMTxwJiYodio9TWF0aC5wb3coMTAscC0xKSxoPTA8PShoLT1wLTEpP1wiK1wiLmNvbmNhdChoKTpoKSx7dmFsdWU6dixhYmJyZXZpYXRpb246XCJlXCIuY29uY2F0KGgpfSk7Yz1qLnZhbHVlLEw9ai5hYmJyZXZpYXRpb24rTH12YXIgQyxULFUsUj1mdW5jdGlvbihlLHQscixuLGksYSl7aWYoLTE9PT1uKXJldHVybiBlO3ZhciBvPXEodCxuLGEpLHU9SShvLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpLDIpLGM9dVswXSxzPXVbMV0sbD12b2lkIDA9PT1zP1wiXCI6cztpZihsLm1hdGNoKC9eMCskLykmJihyfHxpKSlyZXR1cm4gYzt2YXIgZj1sLm1hdGNoKC8wKyQvKTtyZXR1cm4gaSYmZj9cIlwiLmNvbmNhdChjLFwiLlwiKS5jb25jYXQobC50b1N0cmluZygpLnNsaWNlKDAsZi5pbmRleCkpOm8udG9TdHJpbmcoKX0oYy50b1N0cmluZygpLGMsQixOLE0sXyk7cmV0dXJuIFI9WihSPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPWUsYT1JKGkudG9TdHJpbmcoKS5zcGxpdChcIi5cIiksMiksbz1hWzBdLHU9YVsxXTtpZihvLm1hdGNoKC9eLT8wJC8pJiZyKXJldHVybiB1P1wiXCIuY29uY2F0KG8ucmVwbGFjZShcIjBcIixcIlwiKSxcIi5cIikuY29uY2F0KHUpOm8ucmVwbGFjZShcIjBcIixcIlwiKTt2YXIgYz10PDAmJjA9PT1vLmluZGV4T2YoXCItXCIpO2lmKGMmJihvPW8uc2xpY2UoMSksaT1pLnNsaWNlKDEpKSxvLmxlbmd0aDxuKWZvcih2YXIgcz1uLW8ubGVuZ3RoLGw9MDtsPHM7bCsrKWk9XCIwXCIuY29uY2F0KGkpO3JldHVybiBjJiYoaT1cIi1cIi5jb25jYXQoaSkpLGkudG9TdHJpbmcoKX0oUixjLHcsYiksYyxBLGksYSksKE98fGspJiYoUj1SK0wpLChGfHxjPDApJiYoQz1SLFU9RSxSPTA9PT0oVD1jKT9DOjA9PStDP0MucmVwbGFjZShcIi1cIixcIlwiKTowPFQ/XCIrXCIuY29uY2F0KEMpOlwic2lnblwiPT09VT9DOlwiKFwiLmNvbmNhdChDLnJlcGxhY2UoXCItXCIsXCJcIiksXCIpXCIpKSxSfWZ1bmN0aW9uIGMoZSx0KXtpZighZSlyZXR1cm4gdDt2YXIgcj1PYmplY3Qua2V5cyhlKTtyZXR1cm4gMT09PXIubGVuZ3RoJiZcIm91dHB1dFwiPT09clswXT90OmV9dC5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybntmb3JtYXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxyPTA7cjxlO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gYS5hcHBseSh2b2lkIDAsdC5jb25jYXQoW25dKSl9LGdldEJ5dGVVbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWkuZ2VuZXJhbDtyZXR1cm4gdihlLl92YWx1ZSx0LnN1ZmZpeGVzLHQuc2NhbGUpLnN1ZmZpeH0uYXBwbHkodm9pZCAwLHQuY29uY2F0KFtuXSkpfSxnZXRCaW5hcnlCeXRlVW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdO3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1pLmJpbmFyeTtyZXR1cm4gdihlLl92YWx1ZSx0LnN1ZmZpeGVzLHQuc2NhbGUpLnN1ZmZpeH0uYXBwbHkodm9pZCAwLHQuY29uY2F0KFtuXSkpfSxnZXREZWNpbWFsQnl0ZVVuaXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxyPTA7cjxlO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWNpbWFsO3JldHVybiB2KGUuX3ZhbHVlLHQuc3VmZml4ZXMsdC5zY2FsZSkuc3VmZml4fS5hcHBseSh2b2lkIDAsdC5jb25jYXQoW25dKSl9LGZvcm1hdE9yRGVmYXVsdDpjfX19LHtcIi4vZ2xvYmFsU3RhdGVcIjo0LFwiLi9wYXJzaW5nXCI6OCxcIi4vdmFsaWRhdGluZ1wiOjEwfV0sNDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuL2VuLVVTXCIpLG49ZShcIi4vdmFsaWRhdGluZ1wiKSxhPWUoXCIuL3BhcnNpbmdcIiksbz17fSx1PXZvaWQgMCxjPXt9LHM9bnVsbCxsPXt9O2Z1bmN0aW9uIGYoZSl7dT1lfWZ1bmN0aW9uIHAoKXtyZXR1cm4gY1t1XX1vLmxhbmd1YWdlcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LGMpfSxvLmN1cnJlbnRMYW5ndWFnZT1mdW5jdGlvbigpe3JldHVybiB1fSxvLmN1cnJlbnRCeXRlcz1mdW5jdGlvbigpe3JldHVybiBwKCkuYnl0ZXN8fHt9fSxvLmN1cnJlbnRDdXJyZW5jeT1mdW5jdGlvbigpe3JldHVybiBwKCkuY3VycmVuY3l9LG8uY3VycmVudEFiYnJldmlhdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gcCgpLmFiYnJldmlhdGlvbnN9LG8uY3VycmVudERlbGltaXRlcnM9ZnVuY3Rpb24oKXtyZXR1cm4gcCgpLmRlbGltaXRlcnN9LG8uY3VycmVudE9yZGluYWw9ZnVuY3Rpb24oKXtyZXR1cm4gcCgpLm9yZGluYWx9LG8uY3VycmVudERlZmF1bHRzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30scCgpLmRlZmF1bHRzLGwpfSxvLmN1cnJlbnRPcmRpbmFsRGVmYXVsdEZvcm1hdD1mdW5jdGlvbigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LG8uY3VycmVudERlZmF1bHRzKCkscCgpLm9yZGluYWxGb3JtYXQpfSxvLmN1cnJlbnRCeXRlRGVmYXVsdEZvcm1hdD1mdW5jdGlvbigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LG8uY3VycmVudERlZmF1bHRzKCkscCgpLmJ5dGVGb3JtYXQpfSxvLmN1cnJlbnRQZXJjZW50YWdlRGVmYXVsdEZvcm1hdD1mdW5jdGlvbigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LG8uY3VycmVudERlZmF1bHRzKCkscCgpLnBlcmNlbnRhZ2VGb3JtYXQpfSxvLmN1cnJlbnRDdXJyZW5jeURlZmF1bHRGb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxvLmN1cnJlbnREZWZhdWx0cygpLHAoKS5jdXJyZW5jeUZvcm1hdCl9LG8uY3VycmVudFRpbWVEZWZhdWx0Rm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sby5jdXJyZW50RGVmYXVsdHMoKSxwKCkudGltZUZvcm1hdCl9LG8uc2V0RGVmYXVsdHM9ZnVuY3Rpb24oZSl7ZT1hLnBhcnNlRm9ybWF0KGUpLG4udmFsaWRhdGVGb3JtYXQoZSkmJihsPWUpfSxvLmdldFplcm9Gb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gc30sby5zZXRaZXJvRm9ybWF0PWZ1bmN0aW9uKGUpe3JldHVybiBzPVwic3RyaW5nXCI9PXR5cGVvZiBlP2U6bnVsbH0sby5oYXNaZXJvRm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT1zfSxvLmxhbmd1YWdlRGF0YT1mdW5jdGlvbihlKXtpZihlKXtpZihjW2VdKXJldHVybiBjW2VdO3Rocm93IG5ldyBFcnJvcignVW5rbm93biB0YWcgXCInLmNvbmNhdChlLCdcIicpKX1yZXR1cm4gcCgpfSxvLnJlZ2lzdGVyTGFuZ3VhZ2U9ZnVuY3Rpb24oZSl7dmFyIHQ9MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtpZighbi52YWxpZGF0ZUxhbmd1YWdlKGUpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbGFuZ3VhZ2UgZGF0YVwiKTtjW2UubGFuZ3VhZ2VUYWddPWUsdCYmZihlLmxhbmd1YWdlVGFnKX0sby5zZXRMYW5ndWFnZT1mdW5jdGlvbihlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06aS5sYW5ndWFnZVRhZztpZighY1tlXSl7dmFyIHI9ZS5zcGxpdChcIi1cIilbMF0sbj1PYmplY3Qua2V5cyhjKS5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNwbGl0KFwiLVwiKVswXT09PXJ9KTtyZXR1cm4gY1tuXT92b2lkIGYobik6dm9pZCBmKHQpfWYoZSl9LG8ucmVnaXN0ZXJMYW5ndWFnZShpKSx1PWkubGFuZ3VhZ2VUYWcsdC5leHBvcnRzPW99LHtcIi4vZW4tVVNcIjoyLFwiLi9wYXJzaW5nXCI6OCxcIi4vdmFsaWRhdGluZ1wiOjEwfV0sNTpbZnVuY3Rpb24obixlLHQpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm57bG9hZExhbmd1YWdlc0luTm9kZTpmdW5jdGlvbihlKXtyZXR1cm4gcj10LHZvaWQgZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPXZvaWQgMDt0cnl7ZT1uKFwiLi4vbGFuZ3VhZ2VzL1wiLmNvbmNhdCh0KSl9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcignVW5hYmxlIHRvIGxvYWQgXCInLmNvbmNhdCh0LCdcIi4gTm8gbWF0Y2hpbmcgbGFuZ3VhZ2UgZmlsZSBmb3VuZC4nKSl9ZSYmci5yZWdpc3Rlckxhbmd1YWdlKGUpfSk7dmFyIHJ9fX19LHt9XSw2OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGM9ZShcImJpZ251bWJlci5qc1wiKTtmdW5jdGlvbiBhKGUsdCxyKXt2YXIgbj1uZXcgYyhlLl92YWx1ZSksaT10O3JldHVybiByLmlzTnVtYnJvKHQpJiYoaT10Ll92YWx1ZSksaT1uZXcgYyhpKSxlLl92YWx1ZT1uLm1pbnVzKGkpLnRvTnVtYmVyKCksZX10LmV4cG9ydHM9ZnVuY3Rpb24odSl7cmV0dXJue2FkZDpmdW5jdGlvbihlLHQpe3JldHVybiBuPXQsaT11LGE9bmV3IGMoKHI9ZSkuX3ZhbHVlKSxvPW4saS5pc051bWJybyhuKSYmKG89bi5fdmFsdWUpLG89bmV3IGMobyksci5fdmFsdWU9YS5wbHVzKG8pLnRvTnVtYmVyKCkscjt2YXIgcixuLGksYSxvfSxzdWJ0cmFjdDpmdW5jdGlvbihlLHQpe3JldHVybiBhKGUsdCx1KX0sbXVsdGlwbHk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbj10LGk9dSxhPW5ldyBjKChyPWUpLl92YWx1ZSksbz1uLGkuaXNOdW1icm8obikmJihvPW4uX3ZhbHVlKSxvPW5ldyBjKG8pLHIuX3ZhbHVlPWEudGltZXMobykudG9OdW1iZXIoKSxyO3ZhciByLG4saSxhLG99LGRpdmlkZTpmdW5jdGlvbihlLHQpe3JldHVybiBuPXQsaT11LGE9bmV3IGMoKHI9ZSkuX3ZhbHVlKSxvPW4saS5pc051bWJybyhuKSYmKG89bi5fdmFsdWUpLG89bmV3IGMobyksci5fdmFsdWU9YS5kaXZpZGVkQnkobykudG9OdW1iZXIoKSxyO3ZhciByLG4saSxhLG99LHNldDpmdW5jdGlvbihlLHQpe3JldHVybiByPWUsaT1uPXQsdS5pc051bWJybyhuKSYmKGk9bi5fdmFsdWUpLHIuX3ZhbHVlPWkscjt2YXIgcixuLGl9LGRpZmZlcmVuY2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gcj10LGEoaT0obj11KShlLl92YWx1ZSkscixuKSxNYXRoLmFicyhpLl92YWx1ZSk7dmFyIHIsbixpfSxCaWdOdW1iZXI6Y319fSx7XCJiaWdudW1iZXIuanNcIjoxfV0sNzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fXZhciBhPWUoXCIuL2dsb2JhbFN0YXRlXCIpLG49ZShcIi4vdmFsaWRhdGluZ1wiKSxvPWUoXCIuL2xvYWRpbmdcIikoZyksdT1lKFwiLi91bmZvcm1hdHRpbmdcIiksYz1lKFwiLi9mb3JtYXR0aW5nXCIpKGcpLHM9ZShcIi4vbWFuaXB1bGF0aW5nXCIpKGcpLGw9ZShcIi4vcGFyc2luZ1wiKSxmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHQpLHRoaXMuX3ZhbHVlPWV9dmFyIGUscixuO3JldHVybiBlPXQsKHI9W3trZXk6XCJjbG9uZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGcodGhpcy5fdmFsdWUpfX0se2tleTpcImZvcm1hdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PTA8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09ZT9lOnt9O3JldHVybiBjLmZvcm1hdCh0aGlzLHQpfX0se2tleTpcImZvcm1hdEN1cnJlbmN5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPWwucGFyc2VGb3JtYXQoZSkpLChlPWMuZm9ybWF0T3JEZWZhdWx0KGUsYS5jdXJyZW50Q3VycmVuY3lEZWZhdWx0Rm9ybWF0KCkpKS5vdXRwdXQ9XCJjdXJyZW5jeVwiLGMuZm9ybWF0KHRoaXMsZSl9fSx7a2V5OlwiZm9ybWF0VGltZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PTA8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09ZT9lOnt9O3JldHVybiB0Lm91dHB1dD1cInRpbWVcIixjLmZvcm1hdCh0aGlzLHQpfX0se2tleTpcImJpbmFyeUJ5dGVVbml0c1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGMuZ2V0QmluYXJ5Qnl0ZVVuaXQodGhpcyl9fSx7a2V5OlwiZGVjaW1hbEJ5dGVVbml0c1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGMuZ2V0RGVjaW1hbEJ5dGVVbml0KHRoaXMpfX0se2tleTpcImJ5dGVVbml0c1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGMuZ2V0Qnl0ZVVuaXQodGhpcyl9fSx7a2V5OlwiZGlmZmVyZW5jZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBzLmRpZmZlcmVuY2UodGhpcyxlKX19LHtrZXk6XCJhZGRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gcy5hZGQodGhpcyxlKX19LHtrZXk6XCJzdWJ0cmFjdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBzLnN1YnRyYWN0KHRoaXMsZSl9fSx7a2V5OlwibXVsdGlwbHlcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gcy5tdWx0aXBseSh0aGlzLGUpfX0se2tleTpcImRpdmlkZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBzLmRpdmlkZSh0aGlzLGUpfX0se2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBzLnNldCh0aGlzLHAoZSkpfX0se2tleTpcInZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFsdWV9fSx7a2V5OlwidmFsdWVPZlwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ZhbHVlfX1dKSYmaShlLnByb3RvdHlwZSxyKSxuJiZpKGUsbiksdH0oKTtmdW5jdGlvbiBwKGUpe3ZhciB0PWU7cmV0dXJuIGcuaXNOdW1icm8oZSk/dD1lLl92YWx1ZTpcInN0cmluZ1wiPT10eXBlb2YgZT90PWcudW5mb3JtYXQoZSk6aXNOYU4oZSkmJih0PU5hTiksdH1mdW5jdGlvbiBnKGUpe3JldHVybiBuZXcgZihwKGUpKX1nLnZlcnNpb249XCIyLjMuMlwiLGcuaXNOdW1icm89ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBmfSxnLmxhbmd1YWdlPWEuY3VycmVudExhbmd1YWdlLGcucmVnaXN0ZXJMYW5ndWFnZT1hLnJlZ2lzdGVyTGFuZ3VhZ2UsZy5zZXRMYW5ndWFnZT1hLnNldExhbmd1YWdlLGcubGFuZ3VhZ2VzPWEubGFuZ3VhZ2VzLGcubGFuZ3VhZ2VEYXRhPWEubGFuZ3VhZ2VEYXRhLGcuemVyb0Zvcm1hdD1hLnNldFplcm9Gb3JtYXQsZy5kZWZhdWx0Rm9ybWF0PWEuY3VycmVudERlZmF1bHRzLGcuc2V0RGVmYXVsdHM9YS5zZXREZWZhdWx0cyxnLmRlZmF1bHRDdXJyZW5jeUZvcm1hdD1hLmN1cnJlbnRDdXJyZW5jeURlZmF1bHRGb3JtYXQsZy52YWxpZGF0ZT1uLnZhbGlkYXRlLGcubG9hZExhbmd1YWdlc0luTm9kZT1vLmxvYWRMYW5ndWFnZXNJbk5vZGUsZy51bmZvcm1hdD11LnVuZm9ybWF0LGcuQmlnTnVtYmVyPXMuQmlnTnVtYmVyLHQuZXhwb3J0cz1nfSx7XCIuL2Zvcm1hdHRpbmdcIjozLFwiLi9nbG9iYWxTdGF0ZVwiOjQsXCIuL2xvYWRpbmdcIjo1LFwiLi9tYW5pcHVsYXRpbmdcIjo2LFwiLi9wYXJzaW5nXCI6OCxcIi4vdW5mb3JtYXR0aW5nXCI6OSxcIi4vdmFsaWRhdGluZ1wiOjEwfV0sODpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz17cGFyc2VGb3JtYXQ6ZnVuY3Rpb24oZSl7dmFyIHQscixuLGksYSxvLHUsYyxzLGwsZixwLGcsZCxoLHYsbSx5LGIsdyxTLHgsTz0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGU/ZToocj1PLGU9KG49KHQ9ZSkubWF0Y2goL157KFtefV0qKX0vKSk/KHIucHJlZml4PW5bMV0sdC5zbGljZShuWzBdLmxlbmd0aCkpOnQsYT1PLGZ1bmN0aW9uKGUsdCl7aWYoLTE9PT1lLmluZGV4T2YoXCIkXCIpKXtpZigtMT09PWUuaW5kZXhPZihcIiVcIikpcmV0dXJuLTEhPT1lLmluZGV4T2YoXCJiZFwiKT8odC5vdXRwdXQ9XCJieXRlXCIsdC5iYXNlPVwiZ2VuZXJhbFwiKTotMSE9PWUuaW5kZXhPZihcImJcIik/KHQub3V0cHV0PVwiYnl0ZVwiLHQuYmFzZT1cImJpbmFyeVwiKTotMSE9PWUuaW5kZXhPZihcImRcIik/KHQub3V0cHV0PVwiYnl0ZVwiLHQuYmFzZT1cImRlY2ltYWxcIik6LTE9PT1lLmluZGV4T2YoXCI6XCIpPy0xIT09ZS5pbmRleE9mKFwib1wiKSYmKHQub3V0cHV0PVwib3JkaW5hbFwiKTp0Lm91dHB1dD1cInRpbWVcIjt0Lm91dHB1dD1cInBlcmNlbnRcIn1lbHNlIHQub3V0cHV0PVwiY3VycmVuY3lcIn0oZT0obz0oaT1lKS5tYXRjaCgveyhbXn1dKil9JC8pKT8oYS5wb3N0Zml4PW9bMV0saS5zbGljZSgwLC1vWzBdLmxlbmd0aCkpOmksTyksdT1PLChjPWUubWF0Y2goL1sxLTldK1swLTldKi8pKSYmKHUudG90YWxMZW5ndGg9K2NbMF0pLHM9TywobD1lLnNwbGl0KFwiLlwiKVswXS5tYXRjaCgvMCsvKSkmJihzLmNoYXJhY3RlcmlzdGljPWxbMF0ubGVuZ3RoKSxmdW5jdGlvbihlLHQpe2lmKC0xIT09ZS5pbmRleE9mKFwiLlwiKSl7dmFyIHI9ZS5zcGxpdChcIi5cIilbMF07dC5vcHRpb25hbENoYXJhY3RlcmlzdGljPS0xPT09ci5pbmRleE9mKFwiMFwiKX19KGUsTyksZj1PLC0xIT09ZS5pbmRleE9mKFwiYVwiKSYmKGYuYXZlcmFnZT0hMCksZz1PLC0xIT09KHA9ZSkuaW5kZXhPZihcIktcIik/Zy5mb3JjZUF2ZXJhZ2U9XCJ0aG91c2FuZFwiOi0xIT09cC5pbmRleE9mKFwiTVwiKT9nLmZvcmNlQXZlcmFnZT1cIm1pbGxpb25cIjotMSE9PXAuaW5kZXhPZihcIkJcIik/Zy5mb3JjZUF2ZXJhZ2U9XCJiaWxsaW9uXCI6LTEhPT1wLmluZGV4T2YoXCJUXCIpJiYoZy5mb3JjZUF2ZXJhZ2U9XCJ0cmlsbGlvblwiKSxmdW5jdGlvbihlLHQpe3ZhciByPWUuc3BsaXQoXCIuXCIpWzFdO2lmKHIpe3ZhciBuPXIubWF0Y2goLzArLyk7biYmKHQubWFudGlzc2E9blswXS5sZW5ndGgpfX0oZSxPKSxoPU8sKGQ9ZSkubWF0Y2goL1xcW1xcLl0vKT9oLm9wdGlvbmFsTWFudGlzc2E9ITA6ZC5tYXRjaCgvXFwuLykmJihoLm9wdGlvbmFsTWFudGlzc2E9ITEpLHY9TywobT1lLnNwbGl0KFwiLlwiKVsxXSkmJih2LnRyaW1NYW50aXNzYT0tMSE9PW0uaW5kZXhPZihcIltcIikpLHk9TywtMSE9PWUuaW5kZXhPZihcIixcIikmJih5LnRob3VzYW5kU2VwYXJhdGVkPSEwKSxiPU8sLTEhPT1lLmluZGV4T2YoXCIgXCIpJiYoYi5zcGFjZVNlcGFyYXRlZD0hMCxiLnNwYWNlU2VwYXJhdGVkQ3VycmVuY3k9ITAsKGIuYXZlcmFnZXx8Yi5mb3JjZUF2ZXJhZ2UpJiYoYi5zcGFjZVNlcGFyYXRlZEFiYnJldmlhdGlvbj0hMCkpLFM9Tywodz1lKS5tYXRjaCgvXlxcKz9cXChbXildKlxcKSQvKSYmKFMubmVnYXRpdmU9XCJwYXJlbnRoZXNpc1wiKSx3Lm1hdGNoKC9eXFwrPy0vKSYmKFMubmVnYXRpdmU9XCJzaWduXCIpLHg9TyxlLm1hdGNoKC9eXFwrLykmJih4LmZvcmNlU2lnbj0hMCksTyl9fX0se31dLDk6W2Z1bmN0aW9uKHAsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgTT1be2tleTpcIlppQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDcpfSx7a2V5OlwiWkJcIixmYWN0b3I6TWF0aC5wb3coMWUzLDcpfSx7a2V5OlwiWWlCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsOCl9LHtrZXk6XCJZQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsOCl9LHtrZXk6XCJUaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCw0KX0se2tleTpcIlRCXCIsZmFjdG9yOk1hdGgucG93KDFlMyw0KX0se2tleTpcIlBpQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDUpfSx7a2V5OlwiUEJcIixmYWN0b3I6TWF0aC5wb3coMWUzLDUpfSx7a2V5OlwiTWlCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsMil9LHtrZXk6XCJNQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsMil9LHtrZXk6XCJLaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCwxKX0se2tleTpcIktCXCIsZmFjdG9yOk1hdGgucG93KDFlMywxKX0se2tleTpcIkdpQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDMpfSx7a2V5OlwiR0JcIixmYWN0b3I6TWF0aC5wb3coMWUzLDMpfSx7a2V5OlwiRWlCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsNil9LHtrZXk6XCJFQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsNil9LHtrZXk6XCJCXCIsZmFjdG9yOjF9XTtmdW5jdGlvbiBBKGUpe3JldHVybiBlLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csXCJcXFxcJCZcIil9ZnVuY3Rpb24gZyhlLHQscixuLGksYSxvKXt2YXIgdT0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PXI/cjpcIlwiLGM9Mzxhcmd1bWVudHMubGVuZ3RoP246dm9pZCAwLHM9NDxhcmd1bWVudHMubGVuZ3RoP2k6dm9pZCAwLGw9NTxhcmd1bWVudHMubGVuZ3RoP2E6dm9pZCAwLGY9Njxhcmd1bWVudHMubGVuZ3RoP286dm9pZCAwO2lmKFwiXCIhPT1lKXJldHVybiBlPT09cz8wOmZ1bmN0aW9uIGUodCxyLG4saSxhLG8sdSl7dmFyIGM9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1uP246XCJcIixzPTM8YXJndW1lbnRzLmxlbmd0aD9pOnZvaWQgMCxsPTQ8YXJndW1lbnRzLmxlbmd0aD9hOnZvaWQgMCxmPTU8YXJndW1lbnRzLmxlbmd0aD9vOnZvaWQgMCxwPTY8YXJndW1lbnRzLmxlbmd0aD91OnZvaWQgMDtpZighaXNOYU4oK3QpKXJldHVybit0O3ZhciBnPVwiXCIsZD10LnJlcGxhY2UoLyheW14oXSopXFwoKC4qKVxcKShbXildKiQpLyxcIiQxJDIkM1wiKTtpZihkIT09dClyZXR1cm4tMSplKGQscixjLHMsbCxmLHApO2Zvcih2YXIgaD0wO2g8TS5sZW5ndGg7aCsrKXt2YXIgdj1NW2hdO2lmKChnPXQucmVwbGFjZShSZWdFeHAoXCIoWzAtOSBdKShcIi5jb25jYXQodi5rZXksXCIpJFwiKSksXCIkMVwiKSkhPT10KXJldHVybiBlKGcscixjLHMsbCxmLHApKnYuZmFjdG9yfWlmKChnPXQucmVwbGFjZShcIiVcIixcIlwiKSkhPT10KXJldHVybiBlKGcscixjLHMsbCxmLHApLzEwMDt2YXIgbT1wYXJzZUZsb2F0KHQpO2lmKCFpc05hTihtKSl7dmFyIHk9cyhtKTtpZih5JiZcIi5cIiE9PXkmJihnPXQucmVwbGFjZShuZXcgUmVnRXhwKFwiXCIuY29uY2F0KEEoeSksXCIkXCIpKSxcIlwiKSkhPT10KXJldHVybiBlKGcscixjLHMsbCxmLHApO3ZhciBiPXt9O09iamVjdC5rZXlzKGYpLmZvckVhY2goZnVuY3Rpb24oZSl7YltmW2VdXT1lfSk7Zm9yKHZhciB3PU9iamVjdC5rZXlzKGIpLnNvcnQoKS5yZXZlcnNlKCksUz13Lmxlbmd0aCx4PTA7eDxTO3grKyl7dmFyIE89d1t4XSxOPWJbT107aWYoKGc9dC5yZXBsYWNlKE8sXCJcIikpIT09dCl7dmFyIEI9dm9pZCAwO3N3aXRjaChOKXtjYXNlXCJ0aG91c2FuZFwiOkI9TWF0aC5wb3coMTAsMyk7YnJlYWs7Y2FzZVwibWlsbGlvblwiOkI9TWF0aC5wb3coMTAsNik7YnJlYWs7Y2FzZVwiYmlsbGlvblwiOkI9TWF0aC5wb3coMTAsOSk7YnJlYWs7Y2FzZVwidHJpbGxpb25cIjpCPU1hdGgucG93KDEwLDEyKX1yZXR1cm4gZShnLHIsYyxzLGwsZixwKSpCfX19fShmdW5jdGlvbihlLHQscil7dmFyIG49Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1yP3I6XCJcIixpPWUucmVwbGFjZShuLFwiXCIpO3JldHVybiBpPShpPWkucmVwbGFjZShuZXcgUmVnRXhwKFwiKFswLTldKVwiLmNvbmNhdChBKHQudGhvdXNhbmRzKSxcIihbMC05XSlcIiksXCJnXCIpLFwiJDEkMlwiKSkucmVwbGFjZSh0LmRlY2ltYWwsXCIuXCIpfShlLHQsdSksdCx1LGMscyxsLGYpfWUuZXhwb3J0cz17dW5mb3JtYXQ6ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksYT1wKFwiLi9nbG9iYWxTdGF0ZVwiKSxvPWEuY3VycmVudERlbGltaXRlcnMoKSx1PWEuY3VycmVudEN1cnJlbmN5KCkuc3ltYm9sLGM9YS5jdXJyZW50T3JkaW5hbCgpLHM9YS5nZXRaZXJvRm9ybWF0KCksbD1hLmN1cnJlbnRBYmJyZXZpYXRpb25zKCksZj12b2lkIDA7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpZj1mdW5jdGlvbihlLHQpe2lmKGUuaW5kZXhPZihcIjpcIikmJlwiOlwiIT09dC50aG91c2FuZHMpe3ZhciByPWUuc3BsaXQoXCI6XCIpO2lmKDM9PT1yLmxlbmd0aCl7dmFyIG49K3JbMF0saT0rclsxXSxhPStyWzJdO3JldHVybiFpc05hTihuKSYmIWlzTmFOKGkpJiYhaXNOYU4oYSl9fX0oZSxvKT8ocj1lLnNwbGl0KFwiOlwiKSxuPStyWzBdLGk9K3JbMV0sK3JbMl0rNjAqaSszNjAwKm4pOmcoZSxvLHUsYyxzLGwsdCk7ZWxzZXtpZihcIm51bWJlclwiIT10eXBlb2YgZSlyZXR1cm47Zj1lfWlmKHZvaWQgMCE9PWYpcmV0dXJuIGZ9fX0se1wiLi9nbG9iYWxTdGF0ZVwiOjR9XSwxMDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2Zvcih2YXIgdD0wLHI9bmV3IEFycmF5KGUubGVuZ3RoKTt0PGUubGVuZ3RoO3QrKylyW3RdPWVbdF07cmV0dXJuIHJ9fShlKXx8ZnVuY3Rpb24oZSl7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSlyZXR1cm4gQXJyYXkuZnJvbShlKX0oZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfWZ1bmN0aW9uIGYoZSl7cmV0dXJuKGY9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfXZhciBpPWUoXCIuL3VuZm9ybWF0dGluZ1wiKSxhPS9eW2Etel17MiwzfSgtW2EtekEtWl17NH0pPygtKFtBLVpdezJ9fFswLTldezN9KSk/JC8scD17b3V0cHV0Ont0eXBlOlwic3RyaW5nXCIsdmFsaWRWYWx1ZXM6W1wiY3VycmVuY3lcIixcInBlcmNlbnRcIixcImJ5dGVcIixcInRpbWVcIixcIm9yZGluYWxcIixcIm51bWJlclwiXX0sYmFzZTp7dHlwZTpcInN0cmluZ1wiLHZhbGlkVmFsdWVzOltcImRlY2ltYWxcIixcImJpbmFyeVwiLFwiZ2VuZXJhbFwiXSxyZXN0cmljdGlvbjpmdW5jdGlvbihlLHQpe3JldHVyblwiYnl0ZVwiPT09dC5vdXRwdXR9LG1lc3NhZ2U6XCJgYmFzZWAgbXVzdCBiZSBwcm92aWRlZCBvbmx5IHdoZW4gdGhlIG91dHB1dCBpcyBgYnl0ZWBcIixtYW5kYXRvcnk6ZnVuY3Rpb24oZSl7cmV0dXJuXCJieXRlXCI9PT1lLm91dHB1dH19LGNoYXJhY3RlcmlzdGljOnt0eXBlOlwibnVtYmVyXCIscmVzdHJpY3Rpb246ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PWV9LG1lc3NhZ2U6XCJ2YWx1ZSBtdXN0IGJlIHBvc2l0aXZlXCJ9LHByZWZpeDpcInN0cmluZ1wiLHBvc3RmaXg6XCJzdHJpbmdcIixmb3JjZUF2ZXJhZ2U6e3R5cGU6XCJzdHJpbmdcIix2YWxpZFZhbHVlczpbXCJ0cmlsbGlvblwiLFwiYmlsbGlvblwiLFwibWlsbGlvblwiLFwidGhvdXNhbmRcIl19LGF2ZXJhZ2U6XCJib29sZWFuXCIsbG93UHJlY2lzaW9uOnt0eXBlOlwiYm9vbGVhblwiLHJlc3RyaWN0aW9uOmZ1bmN0aW9uKGUsdCl7cmV0dXJuITA9PT10LmF2ZXJhZ2V9LG1lc3NhZ2U6XCJgbG93UHJlY2lzaW9uYCBtdXN0IGJlIHByb3ZpZGVkIG9ubHkgd2hlbiB0aGUgb3B0aW9uIGBhdmVyYWdlYCBpcyBzZXRcIn0sY3VycmVuY3lQb3NpdGlvbjp7dHlwZTpcInN0cmluZ1wiLHZhbGlkVmFsdWVzOltcInByZWZpeFwiLFwiaW5maXhcIixcInBvc3RmaXhcIl19LGN1cnJlbmN5U3ltYm9sOlwic3RyaW5nXCIsdG90YWxMZW5ndGg6e3R5cGU6XCJudW1iZXJcIixyZXN0cmljdGlvbnM6W3tyZXN0cmljdGlvbjpmdW5jdGlvbihlKXtyZXR1cm4gMDw9ZX0sbWVzc2FnZTpcInZhbHVlIG11c3QgYmUgcG9zaXRpdmVcIn0se3Jlc3RyaWN0aW9uOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIXQuZXhwb25lbnRpYWx9LG1lc3NhZ2U6XCJgdG90YWxMZW5ndGhgIGlzIGluY29tcGF0aWJsZSB3aXRoIGBleHBvbmVudGlhbGBcIn1dfSxtYW50aXNzYTp7dHlwZTpcIm51bWJlclwiLHJlc3RyaWN0aW9uOmZ1bmN0aW9uKGUpe3JldHVybiAwPD1lfSxtZXNzYWdlOlwidmFsdWUgbXVzdCBiZSBwb3NpdGl2ZVwifSxvcHRpb25hbE1hbnRpc3NhOlwiYm9vbGVhblwiLHRyaW1NYW50aXNzYTpcImJvb2xlYW5cIixyb3VuZGluZ0Z1bmN0aW9uOlwiZnVuY3Rpb25cIixvcHRpb25hbENoYXJhY3RlcmlzdGljOlwiYm9vbGVhblwiLHRob3VzYW5kU2VwYXJhdGVkOlwiYm9vbGVhblwiLHNwYWNlU2VwYXJhdGVkOlwiYm9vbGVhblwiLHNwYWNlU2VwYXJhdGVkQ3VycmVuY3k6XCJib29sZWFuXCIsc3BhY2VTZXBhcmF0ZWRBYmJyZXZpYXRpb246XCJib29sZWFuXCIsYWJicmV2aWF0aW9uczp7dHlwZTpcIm9iamVjdFwiLGNoaWxkcmVuOnt0aG91c2FuZDpcInN0cmluZ1wiLG1pbGxpb246XCJzdHJpbmdcIixiaWxsaW9uOlwic3RyaW5nXCIsdHJpbGxpb246XCJzdHJpbmdcIn19LG5lZ2F0aXZlOnt0eXBlOlwic3RyaW5nXCIsdmFsaWRWYWx1ZXM6W1wic2lnblwiLFwicGFyZW50aGVzaXNcIl19LGZvcmNlU2lnbjpcImJvb2xlYW5cIixleHBvbmVudGlhbDp7dHlwZTpcImJvb2xlYW5cIn0scHJlZml4U3ltYm9sOnt0eXBlOlwiYm9vbGVhblwiLHJlc3RyaWN0aW9uOmZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJwZXJjZW50XCI9PT10Lm91dHB1dH0sbWVzc2FnZTpcImBwcmVmaXhTeW1ib2xgIGNhbiBiZSBwcm92aWRlZCBvbmx5IHdoZW4gdGhlIG91dHB1dCBpcyBgcGVyY2VudGBcIn19LG89e2xhbmd1YWdlVGFnOnt0eXBlOlwic3RyaW5nXCIsbWFuZGF0b3J5OiEwLHJlc3RyaWN0aW9uOmZ1bmN0aW9uKGUpe3JldHVybiBlLm1hdGNoKGEpfSxtZXNzYWdlOlwidGhlIGxhbmd1YWdlIHRhZyBtdXN0IGZvbGxvdyB0aGUgQkNQIDQ3IHNwZWNpZmljYXRpb24gKHNlZSBodHRwczovL3Rvb2xzLmllZnQub3JnL2h0bWwvYmNwNDcpXCJ9LGRlbGltaXRlcnM6e3R5cGU6XCJvYmplY3RcIixjaGlsZHJlbjp7dGhvdXNhbmRzOlwic3RyaW5nXCIsZGVjaW1hbDpcInN0cmluZ1wiLHRob3VzYW5kc1NpemU6XCJudW1iZXJcIn0sbWFuZGF0b3J5OiEwfSxhYmJyZXZpYXRpb25zOnt0eXBlOlwib2JqZWN0XCIsY2hpbGRyZW46e3Rob3VzYW5kOnt0eXBlOlwic3RyaW5nXCIsbWFuZGF0b3J5OiEwfSxtaWxsaW9uOnt0eXBlOlwic3RyaW5nXCIsbWFuZGF0b3J5OiEwfSxiaWxsaW9uOnt0eXBlOlwic3RyaW5nXCIsbWFuZGF0b3J5OiEwfSx0cmlsbGlvbjp7dHlwZTpcInN0cmluZ1wiLG1hbmRhdG9yeTohMH19LG1hbmRhdG9yeTohMH0sc3BhY2VTZXBhcmF0ZWQ6XCJib29sZWFuXCIsc3BhY2VTZXBhcmF0ZWRDdXJyZW5jeTpcImJvb2xlYW5cIixvcmRpbmFsOnt0eXBlOlwiZnVuY3Rpb25cIixtYW5kYXRvcnk6ITB9LGJ5dGVzOnt0eXBlOlwib2JqZWN0XCIsY2hpbGRyZW46e2JpbmFyeVN1ZmZpeGVzOlwib2JqZWN0XCIsZGVjaW1hbFN1ZmZpeGVzOlwib2JqZWN0XCJ9fSxjdXJyZW5jeTp7dHlwZTpcIm9iamVjdFwiLGNoaWxkcmVuOntzeW1ib2w6XCJzdHJpbmdcIixwb3NpdGlvbjpcInN0cmluZ1wiLGNvZGU6XCJzdHJpbmdcIn0sbWFuZGF0b3J5OiEwfSxkZWZhdWx0czpcImZvcm1hdFwiLG9yZGluYWxGb3JtYXQ6XCJmb3JtYXRcIixieXRlRm9ybWF0OlwiZm9ybWF0XCIscGVyY2VudGFnZUZvcm1hdDpcImZvcm1hdFwiLGN1cnJlbmN5Rm9ybWF0OlwiZm9ybWF0XCIsdGltZURlZmF1bHRzOlwiZm9ybWF0XCIsZm9ybWF0czp7dHlwZTpcIm9iamVjdFwiLGNoaWxkcmVuOntmb3VyRGlnaXRzOnt0eXBlOlwiZm9ybWF0XCIsbWFuZGF0b3J5OiEwfSxmdWxsV2l0aFR3b0RlY2ltYWxzOnt0eXBlOlwiZm9ybWF0XCIsbWFuZGF0b3J5OiEwfSxmdWxsV2l0aFR3b0RlY2ltYWxzTm9DdXJyZW5jeTp7dHlwZTpcImZvcm1hdFwiLG1hbmRhdG9yeTohMH0sZnVsbFdpdGhOb0RlY2ltYWxzOnt0eXBlOlwiZm9ybWF0XCIsbWFuZGF0b3J5OiEwfX19fTtmdW5jdGlvbiB1KGUpe3JldHVybiB2b2lkIDAhPT1pLnVuZm9ybWF0KGUpfWZ1bmN0aW9uIGcoYyxzLGwsZSl7dmFyIHQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1lJiZlLHI9T2JqZWN0LmtleXMoYykubWFwKGZ1bmN0aW9uKGUpe2lmKCFzW2VdKXJldHVybiBjb25zb2xlLmVycm9yKFwiXCIuY29uY2F0KGwsXCIgSW52YWxpZCBrZXk6IFwiKS5jb25jYXQoZSkpLCExO3ZhciB0PWNbZV0scj1zW2VdO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByJiYocj17dHlwZTpyfSksXCJmb3JtYXRcIj09PXIudHlwZSl7aWYoIWcodCxwLFwiW1ZhbGlkYXRlIFwiLmNvbmNhdChlLFwiXVwiKSwhMCkpcmV0dXJuITF9ZWxzZSBpZihmKHQpIT09ci50eXBlKXJldHVybiBjb25zb2xlLmVycm9yKFwiXCIuY29uY2F0KGwsXCIgXCIpLmNvbmNhdChlLCcgdHlwZSBtaXNtYXRjaGVkOiBcIicpLmNvbmNhdChyLnR5cGUsJ1wiIGV4cGVjdGVkLCBcIicpLmNvbmNhdChmKHQpLCdcIiBwcm92aWRlZCcpKSwhMTtpZihyLnJlc3RyaWN0aW9ucyYmci5yZXN0cmljdGlvbnMubGVuZ3RoKWZvcih2YXIgbj1yLnJlc3RyaWN0aW9ucy5sZW5ndGgsaT0wO2k8bjtpKyspe3ZhciBhPXIucmVzdHJpY3Rpb25zW2ldLG89YS5yZXN0cmljdGlvbix1PWEubWVzc2FnZTtpZighbyh0LGMpKXJldHVybiBjb25zb2xlLmVycm9yKFwiXCIuY29uY2F0KGwsXCIgXCIpLmNvbmNhdChlLFwiIGludmFsaWQgdmFsdWU6IFwiKS5jb25jYXQodSkpLCExfWlmKHIucmVzdHJpY3Rpb24mJiFyLnJlc3RyaWN0aW9uKHQsYykpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCxcIiBcIikuY29uY2F0KGUsXCIgaW52YWxpZCB2YWx1ZTogXCIpLmNvbmNhdChyLm1lc3NhZ2UpKSwhMTtpZihyLnZhbGlkVmFsdWVzJiYtMT09PXIudmFsaWRWYWx1ZXMuaW5kZXhPZih0KSlyZXR1cm4gY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdChsLFwiIFwiKS5jb25jYXQoZSxcIiBpbnZhbGlkIHZhbHVlOiBtdXN0IGJlIGFtb25nIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkoci52YWxpZFZhbHVlcyksJywgXCInKS5jb25jYXQodCwnXCIgcHJvdmlkZWQnKSksITE7aWYoci5jaGlsZHJlbiYmIWcodCxyLmNoaWxkcmVuLFwiW1ZhbGlkYXRlIFwiLmNvbmNhdChlLFwiXVwiKSkpcmV0dXJuITE7cmV0dXJuITB9KTtyZXR1cm4gdHx8ci5wdXNoLmFwcGx5KHIsbihPYmplY3Qua2V5cyhzKS5tYXAoZnVuY3Rpb24oZSl7dmFyIHQ9c1tlXTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9e3R5cGU6dH0pLHQubWFuZGF0b3J5KXt2YXIgcj10Lm1hbmRhdG9yeTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiByJiYocj1yKGMpKSxyJiZ2b2lkIDA9PT1jW2VdKXJldHVybiBjb25zb2xlLmVycm9yKFwiXCIuY29uY2F0KGwsJyBNaXNzaW5nIG1hbmRhdG9yeSBrZXkgXCInKS5jb25jYXQoZSwnXCInKSksITF9cmV0dXJuITB9KSkpLHIucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUmJnR9LCEwKX1mdW5jdGlvbiBjKGUpe3JldHVybiBnKGUscCxcIltWYWxpZGF0ZSBmb3JtYXRdXCIpfXQuZXhwb3J0cz17dmFsaWRhdGU6ZnVuY3Rpb24oZSx0KXt2YXIgcj11KGUpLG49Yyh0KTtyZXR1cm4gciYmbn0sdmFsaWRhdGVGb3JtYXQ6Yyx2YWxpZGF0ZUlucHV0OnUsdmFsaWRhdGVMYW5ndWFnZTpmdW5jdGlvbihlKXtyZXR1cm4gZyhlLG8sXCJbVmFsaWRhdGUgbGFuZ3VhZ2VdXCIpfX19LHtcIi4vdW5mb3JtYXR0aW5nXCI6OX1dfSx7fSxbN10pKDcpfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1icm8ubWluLmpzLm1hcFxuIiwiaW1wb3J0IHsgTnVtZXJpYywgUnBjRXJyb3IsIEpzb25ScGMsIFNlcmlhbGl6ZSwgS2V5LCBBcGkgfSBmcm9tICdAcHJvdG9uL2pzJztcbmltcG9ydCB7IGNvbnN0YW50cyB9IGZyb20gJ0BibG9rcy9jb25zdGFudHMnO1xuaW1wb3J0IHsgSnNvblJwYyBhcyBKc29uUnBjJDIgfSBmcm9tICdAcHJvdG9uL2h5cGVyaW9uJztcbmltcG9ydCB7IEpzb25ScGMgYXMgSnNvblJwYyQxIH0gZnJvbSAnQHByb3Rvbi9saWdodC1hcGknO1xuaW1wb3J0IHsgdXJsQnVpbGRlciwgbmF0aXZlVHJhbnNmb3JtR2V0QWN0aW9ucywgZGZ1c2VUcmFuc2Zvcm1HZXRBY3Rpb25zLCBoeXBlcmlvblRyYW5zZm9ybUdldEFjdGlvbnMsIGVuY29kZU5hbWUsIHN0cmluZ190b191aW50MTI4X2hhc2gsIGhleFRvVWludDhBcnJheSwgaGlzdG9yeVRyYW5zZm9ybVRyYW5zYWN0aW9uLCBoaXN0b3J5VHJhbnNmb3JtRGVmZXJyZWRUcmFuc2FjdGlvbiwgaHlwZXJpb25UcmFuc2Zvcm1UcmFuc2FjdGlvbiwgZmlvS2V5VG9BY3RvciB9IGZyb20gJ0BibG9rcy91dGlscyc7XG5pbXBvcnQgZmV0Y2ggZnJvbSAnY3Jvc3MtZmV0Y2gnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGV4Y2hhbmdlUmF0ZXNQYXJzZXIsIHdpdGhkcmF3YWxGZWVRdW90ZVBhcnNlciB9IGZyb20gJ0Bwcm90b24vd3JhcC1jb25zdGFudHMnO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgeyBtdWx0aXBseSwgZGl2aWRlLCBmb3JtYXREYXRlLCB1dGNUaW1lLCBzdGFydERhdGUsIHRpbWUgfSBmcm9tICdAYmxva3MvbnVtYmVycyc7XG5cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi9cblxuICBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9O1xuXG4gIHZhciBleHBvcnRzID0ge30sXG4gICAgICBPcCA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LFxuICAgICAgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLFxuICAgICAgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLFxuICAgICAgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITBcbiAgICB9KSwgb2JqW2tleV07XG4gIH1cblxuICB0cnkge1xuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsXG4gICAgICAgIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSxcbiAgICAgICAgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yLl9pbnZva2UgPSBmdW5jdGlvbiAoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgICAgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgICBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG5cbiAgICAgICAgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7XG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7XG4gICAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuXG4gICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7XG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgICB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICAgIHN0YXRlID0gXCJleGVjdXRpbmdcIjtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oaW5uZXJGbiwgc2VsZiwgY29udGV4dCksIGdlbmVyYXRvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICBhcmc6IGZuLmNhbGwob2JqLCBhcmcpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICBhcmc6IGVyclxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbHVlICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICB0aGlzLl9pbnZva2UgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSB7XG4gICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybiAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpKSByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG4gICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDtcbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgIHRyeUxvYzogbG9jc1swXVxuICAgIH07XG4gICAgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbe1xuICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTtcblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6ICEwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSwgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTtcbiAgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuO1xuICB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICBfX2F3YWl0OiBhcmdcbiAgICB9O1xuICB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgIH0pO1xuICB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7XG5cbiAgICByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBmb3IgKDsga2V5cy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgfTtcbiAgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoc2tpcFRlbXBSZXNldCkge1xuICAgICAgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRvbmUgPSAhMDtcbiAgICAgIHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247XG4gICAgICBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSxcbiAgICAgICAgICAgIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgIGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksXG4gICAgICAgICAgICAgIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFicnVwdDogZnVuY3Rpb24gKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTtcbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7XG4gICAgICByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uIChmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYXRjaDogZnVuY3Rpb24gKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH0sIGV4cG9ydHM7XG59XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWNjb3VudChfeCkge1xuICByZXR1cm4gX2dldEFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjY291bnQoKSB7XG4gIF9nZXRBY2NvdW50ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFjY291bnROYW1lKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBhY2NvdW50O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X2FjY291bnQoYWNjb3VudE5hbWUpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgYWNjb3VudCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBhY2NvdW50LnBlcm1pc3Npb25zID0gYWNjb3VudC5wZXJtaXNzaW9ucy5tYXAoZnVuY3Rpb24gKHBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgcGVybWlzc2lvbi5yZXF1aXJlZF9hdXRoLmtleXMgPSBwZXJtaXNzaW9uLnJlcXVpcmVkX2F1dGgua2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkua2V5LmluZGV4T2YoX3RoaXMuY29uc3RhbnRzLktFWV9QUkVGSVgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAga2V5LmtleSA9IE51bWVyaWMuY29udmVydExlZ2FjeVB1YmxpY0tleShrZXkua2V5LCBfdGhpcy5jb25zdGFudHMuS0VZX1BSRUZJWCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBwZXJtaXNzaW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFjY291bnQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNlYXJjaEFjY291bnQoX3gyLCBfeDMpIHtcbiAgcmV0dXJuIF9zZWFyY2hBY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zZWFyY2hBY2NvdW50KCkge1xuICBfc2VhcmNoQWNjb3VudCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocXVlcnksIGxpbWl0KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISghcXVlcnkgfHwgIS8oXlthLXpBLVoxMjM0NS5dKyQpLy50ZXN0KHF1ZXJ5KSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKCEocXVlcnkuaW5kZXhPZignLicpID09PSAwKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDQ7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9ieV9zY29wZSh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBxdWVyeSxcbiAgICAgICAgICAgICAgdGFibGU6ICd1c2VycmVzJyxcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6IFwiXCIgKyBxdWVyeSArIChxdWVyeS5sZW5ndGggPCAxMiA/ICd6Jy5yZXBlYXQoMTIgLSBxdWVyeS5sZW5ndGgpIDogJycpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5yb3dzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gcm93LnNjb3BlO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbNCwgMTNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9zZWFyY2hBY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEdyYXZhdGFyKF94NCkge1xuICByZXR1cm4gX2dldEdyYXZhdGFyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRHcmF2YXRhcigpIHtcbiAgX2dldEdyYXZhdGFyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhY2NvdW50KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEodGhpcy5jb25zdGFudHMuQ0hBSU4gPT09ICdlb3MnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5BQ0NPVU5UX0lORk8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5BQ0NPVU5UX0lORk8sXG4gICAgICAgICAgICAgIHRhYmxlOiAnYWNjb3VudHMnLFxuICAgICAgICAgICAgICB0YWJsZV9rZXk6ICcnLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ25hbWUnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogYWNjb3VudCxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDEsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LnJvd3MubGVuZ3RoID4gMCAmJiByZXN1bHQucm93c1swXS5hY2NvdW50X25hbWUgPT09IGFjY291bnQgPyByZXN1bHQucm93c1swXSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0R3JhdmF0YXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KF94NSkge1xuICByZXR1cm4gX2dldFBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UGFyZW50KCkge1xuICBfZ2V0UGFyZW50ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhY2NvdW50KSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFUy5pbmNsdWRlcygnaHlwZXJpb24nKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLkhZUEVSSU9OX1VSTCkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0aGlzLmh5cGVyaW9uLmdldF9jcmVhdG9yKGFjY291bnQpKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuZ2V0KHVybEJ1aWxkZXIodGhpcy5jb25zdGFudHMuQVBJX1VSTCwgJ2h5cGVyaW9uJywge1xuICAgICAgICAgICAgICB0eXBlOiAnZ2V0X2NyZWF0b3InLFxuICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50XG4gICAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBY2NvdW50TGlnaHREYXRhKF94Nikge1xuICByZXR1cm4gX2dldEFjY291bnRMaWdodERhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjY291bnRMaWdodERhdGEoKSB7XG4gIF9nZXRBY2NvdW50TGlnaHREYXRhID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShhY2NvdW50TmFtZSkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAodGhpcy5saWdodEFwaSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAyO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlnaHRBcGkuZ2V0X2FjY291bnRfaW5mbyhhY2NvdW50TmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDUuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0NS50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzIsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY2NvdW50TGlnaHREYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvbnNGcm9tTmF0aXZlKF94LCBfeDIsIF94MywgX3g0KSB7XG4gIHJldHVybiBfZ2V0QWN0aW9uc0Zyb21OYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjdGlvbnNGcm9tTmF0aXZlKCkge1xuICBfZ2V0QWN0aW9uc0Zyb21OYXRpdmUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYWNjb3VudE5hbWUsIGFjdGlvblNraXAsIGFjdGlvbnNQZXJQYWdlLCBoaXN0b3J5VHlwZSkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGhpc3RvcnlUeXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgaGlzdG9yeVR5cGUgPSAnbmF0aXZlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIGFjdGlvbnMgZnJvbTonLCBoaXN0b3J5VHlwZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmV0Y2ggUGFyYW1zOicsICdhY3Rpb25Ta2lwJywgYWN0aW9uU2tpcCwgJ2FjdGlvbnNQZXJQYWdlJywgYWN0aW9uc1BlclBhZ2UpOyAvLyBSZXF1ZXN0XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uc1JwYy5oaXN0b3J5X2dldF9hY3Rpb25zKGFjY291bnROYW1lLCBhY3Rpb25Ta2lwLCBhY3Rpb25zUGVyUGFnZSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmV0cmlldmUgYWN0aW9ucycpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgaWYgKCEoaGlzdG9yeVR5cGUgPT09ICduYXRpdmUnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZVRyYW5zZm9ybUdldEFjdGlvbnMocmVzdWx0LCB0aGlzLmNvbnN0YW50cykpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY3Rpb25zRnJvbU5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBY3Rpb25zKF94NSwgX3g2LCBfeDcpIHtcbiAgcmV0dXJuIF9nZXRBY3Rpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY3Rpb25zKCkge1xuICBfZ2V0QWN0aW9ucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYWNjb3VudE5hbWUsIGhpc3RvcnlUeXBlLCBfdGVtcCkge1xuICAgIHZhciBfcmVmLCBfcmVmJGFjdGlvbnNQZXJQYWdlLCBhY3Rpb25zUGVyUGFnZSwgX3JlZiRhY3Rpb25Ta2lwLCBhY3Rpb25Ta2lwLCBfcmVmJHNvcnREaXJlY3Rpb24sIHNvcnREaXJlY3Rpb24sIF9yZWYkZGZ1c2VDdXJzb3JTdGFjaywgZGZ1c2VDdXJzb3JTdGFjaywgdG9rZW5GaWx0ZXIsIGFjdGlvbkZpbHRlcnMsIGNvbnRyYWN0RmlsdGVyLCBhY3Rpb25GaWx0ZXIsIHN0YXJ0LCBlbmQsIHJlc3VsdCwgaW5wdXRDdXJzb3I7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLCBfcmVmJGFjdGlvbnNQZXJQYWdlID0gX3JlZi5hY3Rpb25zUGVyUGFnZSwgYWN0aW9uc1BlclBhZ2UgPSBfcmVmJGFjdGlvbnNQZXJQYWdlID09PSB2b2lkIDAgPyAxMDAgOiBfcmVmJGFjdGlvbnNQZXJQYWdlLCBfcmVmJGFjdGlvblNraXAgPSBfcmVmLmFjdGlvblNraXAsIGFjdGlvblNraXAgPSBfcmVmJGFjdGlvblNraXAgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGFjdGlvblNraXAsIF9yZWYkc29ydERpcmVjdGlvbiA9IF9yZWYuc29ydERpcmVjdGlvbiwgc29ydERpcmVjdGlvbiA9IF9yZWYkc29ydERpcmVjdGlvbiA9PT0gdm9pZCAwID8gJ2Rlc2MnIDogX3JlZiRzb3J0RGlyZWN0aW9uLCBfcmVmJGRmdXNlQ3Vyc29yU3RhY2sgPSBfcmVmLmRmdXNlQ3Vyc29yU3RhY2ssIGRmdXNlQ3Vyc29yU3RhY2sgPSBfcmVmJGRmdXNlQ3Vyc29yU3RhY2sgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRkZnVzZUN1cnNvclN0YWNrLCB0b2tlbkZpbHRlciA9IF9yZWYudG9rZW5GaWx0ZXIsIGFjdGlvbkZpbHRlcnMgPSBfcmVmLmFjdGlvbkZpbHRlcnMsIGNvbnRyYWN0RmlsdGVyID0gX3JlZi5jb250cmFjdEZpbHRlciwgYWN0aW9uRmlsdGVyID0gX3JlZi5hY3Rpb25GaWx0ZXIsIHN0YXJ0ID0gX3JlZi5zdGFydCwgZW5kID0gX3JlZi5lbmQ7XG5cbiAgICAgICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmNvbnN0YW50cy5DSEFJTl9TVEFSVF9EQVRFO1xuICAgICAgICAgICAgfSAvLyBGYWxsYmFjayBmb3IgaGlzdG9yeSB0eXBlXG5cblxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFUyk7XG5cbiAgICAgICAgICAgIGlmICghaGlzdG9yeVR5cGUgJiYgdGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaGlzdG9yeVR5cGUgPSB0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTWzBdO1xuICAgICAgICAgICAgfSAvLyBGaXggZm9yIGZpcmVmb3ggYW5kIElFIGFuZCBzYWZhcmlcblxuXG4gICAgICAgICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgdGhpcy5jb25zdGFudHMuQ0hBSU5fU1RBUlRfREFURSA/IG5ldyBEYXRlKHN0YXJ0IHx8IHRoaXMuY29uc3RhbnRzLkNIQUlOX1NUQVJUX0RBVEUpLnRvSVNPU3RyaW5nKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKGVuZCB8fCBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGVuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoaGlzdG9yeVR5cGUgPT09ICdkZnVzZScpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnB1dEN1cnNvciA9IGRmdXNlQ3Vyc29yU3RhY2subGVuZ3RoID4gMCA/IGRmdXNlQ3Vyc29yU3RhY2tbZGZ1c2VDdXJzb3JTdGFjay5sZW5ndGggLSAxXSA6ICcnO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9uc0Zyb21EZnVzZShhY2NvdW50TmFtZSwge1xuICAgICAgICAgICAgICBsaW1pdDogYWN0aW9uc1BlclBhZ2UsXG4gICAgICAgICAgICAgIGN1cnNvcjogaW5wdXRDdXJzb3IsXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogc29ydERpcmVjdGlvbixcbiAgICAgICAgICAgICAgcXVlcnk6ICcnLFxuICAgICAgICAgICAgICBhZnRlcjogc3RhcnQsXG4gICAgICAgICAgICAgIGJlZm9yZTogZW5kLFxuICAgICAgICAgICAgICB0b2tlbkZpbHRlcjogdG9rZW5GaWx0ZXIsXG4gICAgICAgICAgICAgIGFjdGlvbkZpbHRlcnM6IGFjdGlvbkZpbHRlcnMsXG4gICAgICAgICAgICAgIGNvbnRyYWN0RmlsdGVyOiBjb250cmFjdEZpbHRlcixcbiAgICAgICAgICAgICAgYWN0aW9uRmlsdGVyOiBhY3Rpb25GaWx0ZXJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgaWYgKCEoaGlzdG9yeVR5cGUgPT09ICdoeXBlcmlvbicpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9uc0Zyb21IeXBlcmlvbihhY2NvdW50TmFtZSwge1xuICAgICAgICAgICAgICBza2lwOiBNYXRoLmFicyhhY3Rpb25Ta2lwKSAtIDEsXG4gICAgICAgICAgICAgIGxpbWl0OiBhY3Rpb25zUGVyUGFnZSxcbiAgICAgICAgICAgICAgc29ydDogc29ydERpcmVjdGlvbixcbiAgICAgICAgICAgICAgYWZ0ZXI6IHN0YXJ0LFxuICAgICAgICAgICAgICBiZWZvcmU6IGVuZCxcbiAgICAgICAgICAgICAgdG9rZW5GaWx0ZXI6IHRva2VuRmlsdGVyLFxuICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXJzOiBhY3Rpb25GaWx0ZXJzLFxuICAgICAgICAgICAgICBjb250cmFjdEZpbHRlcjogY29udHJhY3RGaWx0ZXIsXG4gICAgICAgICAgICAgIGFjdGlvbkZpbHRlcjogYWN0aW9uRmlsdGVyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9uc0Zyb21OYXRpdmUoYWNjb3VudE5hbWUsIGFjdGlvblNraXAsIC1hY3Rpb25zUGVyUGFnZSwgJ25hdGl2ZScpO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCk7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWN0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBY3Rpb25zRnJvbURmdXNlKF94OCwgX3g5KSB7XG4gIHJldHVybiBfZ2V0QWN0aW9uc0Zyb21EZnVzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWN0aW9uc0Zyb21EZnVzZSgpIHtcbiAgX2dldEFjdGlvbnNGcm9tRGZ1c2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGFjY291bnROYW1lLCBfdGVtcDIpIHtcbiAgICB2YXIgX3JlZjIsIGJlZm9yZSwgYWZ0ZXIsIF9yZWYyJGxpbWl0LCBsaW1pdCwgY3Vyc29yLCBxdWVyeSwgX3JlZjIkZGlyZWN0aW9uLCBkaXJlY3Rpb24sIHRva2VuRmlsdGVyLCBhY3Rpb25GaWx0ZXJzLCBjb250cmFjdEZpbHRlciwgYWN0aW9uRmlsdGVyLCBfcmVmMiR0eXBlLCB0eXBlLCBxLCBfdG9rZW5GaWx0ZXIkc3BsaXQsIHRva2VuQ29udHJhY3QsIHRva2VuZmlsdGVyLCBhY3Rpb25GaWx0ZXJzTG9jYWwsIGFjdGlvbkZpbHRlcnNRdWVyeSwgcmVzdWx0O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9yZWYyID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMiwgYmVmb3JlID0gX3JlZjIuYmVmb3JlLCBhZnRlciA9IF9yZWYyLmFmdGVyLCBfcmVmMiRsaW1pdCA9IF9yZWYyLmxpbWl0LCBsaW1pdCA9IF9yZWYyJGxpbWl0ID09PSB2b2lkIDAgPyAyNSA6IF9yZWYyJGxpbWl0LCBjdXJzb3IgPSBfcmVmMi5jdXJzb3IsIHF1ZXJ5ID0gX3JlZjIucXVlcnksIF9yZWYyJGRpcmVjdGlvbiA9IF9yZWYyLmRpcmVjdGlvbiwgZGlyZWN0aW9uID0gX3JlZjIkZGlyZWN0aW9uID09PSB2b2lkIDAgPyAnZGVzYycgOiBfcmVmMiRkaXJlY3Rpb24sIHRva2VuRmlsdGVyID0gX3JlZjIudG9rZW5GaWx0ZXIsIGFjdGlvbkZpbHRlcnMgPSBfcmVmMi5hY3Rpb25GaWx0ZXJzLCBjb250cmFjdEZpbHRlciA9IF9yZWYyLmNvbnRyYWN0RmlsdGVyLCBhY3Rpb25GaWx0ZXIgPSBfcmVmMi5hY3Rpb25GaWx0ZXIsIF9yZWYyJHR5cGUgPSBfcmVmMi50eXBlLCB0eXBlID0gX3JlZjIkdHlwZSA9PT0gdm9pZCAwID8gJ3NlYXJjaF90cmFuc2FjdGlvbnNfZ3JhcGhxbCcgOiBfcmVmMiR0eXBlO1xuICAgICAgICAgICAgcSA9IHF1ZXJ5IHx8IFwiKGF1dGg6XCIgKyBhY2NvdW50TmFtZSArIFwiIE9SXFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcjpcIiArIGFjY291bnROYW1lICsgXCIgT1JcXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudG86XCIgKyBhY2NvdW50TmFtZSArIFwiIE9SXFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZyb206XCIgKyBhY2NvdW50TmFtZSArIFwiIE9SXFxuICAgICAgICAgICAgICAgICAgICBkYXRhLnJlY2VpdmVyOlwiICsgYWNjb3VudE5hbWUgKyBcIilcIjtcblxuICAgICAgICAgICAgaWYgKHRva2VuRmlsdGVyKSB7XG4gICAgICAgICAgICAgIF90b2tlbkZpbHRlciRzcGxpdCA9IHRva2VuRmlsdGVyLnNwbGl0KCcgJyksIHRva2VuQ29udHJhY3QgPSBfdG9rZW5GaWx0ZXIkc3BsaXRbMV07XG4gICAgICAgICAgICAgIHRva2VuZmlsdGVyID0gXCJhY2NvdW50OlwiICsgdG9rZW5Db250cmFjdDtcbiAgICAgICAgICAgICAgcSA9IHEgKyBcIiBcIiArIHRva2VuZmlsdGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWN0aW9uRmlsdGVycykge1xuICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXJzTG9jYWwgPSBPYmplY3QuZW50cmllcyhhY3Rpb25GaWx0ZXJzKS5yZWR1Y2UoZnVuY3Rpb24gKGZpbHRlcnMsIF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjRbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmlzQWN0aXZlID8gZmlsdGVycy5jb25jYXQodmFsdWUpIDogZmlsdGVycztcbiAgICAgICAgICAgICAgfSwgW10pO1xuXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25GaWx0ZXJzTG9jYWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uRmlsdGVyc1F1ZXJ5ID0gYWN0aW9uRmlsdGVyc0xvY2FsLm1hcChmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyLmRmdXNlUXVlcnkoYWNjb3VudE5hbWUpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJyBPUiAnKTsgLy8gV3JhcCBhcm91bmQgdGhlIGFjdGlvbiBmaWx0ZXJzXG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uRmlsdGVyc1F1ZXJ5LnNlYXJjaCgnT1InKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbkZpbHRlcnNRdWVyeSA9IFwiKFwiICsgYWN0aW9uRmlsdGVyc1F1ZXJ5ICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgfSAvLyBTZXQgdGhlIGFjdGlvbiBmaWx0ZXJzXG5cblxuICAgICAgICAgICAgICAgIHEgPSBxICsgXCIgXCIgKyBhY3Rpb25GaWx0ZXJzUXVlcnk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29udHJhY3RGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBxID0gcSArIFwiIGFjY291bnQ6XCIgKyBjb250cmFjdEZpbHRlcjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25GaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBxID0gcSArIFwiIGFjdGlvbjpcIiArIGFjdGlvbkZpbHRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsQnVpbGRlcih0aGlzLmNvbnN0YW50cy5BUElfVVJMLCAnZGZ1c2UnLCB7XG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIHE6IHEsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICBzb3J0OiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBjdXJzb3IsXG4gICAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgICAgIHdpdGhSZXZlcnNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICAgICAgICAgIGFmdGVyOiBhZnRlcixcbiAgICAgICAgICAgICAgICBjb2RlOiAxXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZXRyaWV2ZSBhY3Rpb25zJyk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBkZnVzZVRyYW5zZm9ybUdldEFjdGlvbnMocmVzdWx0LCBhY2NvdW50TmFtZSwgdGhpcy5jb25zdGFudHMpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY3Rpb25zRnJvbURmdXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvbnNGcm9tSHlwZXJpb24oX3gxMCwgX3gxMSkge1xuICByZXR1cm4gX2dldEFjdGlvbnNGcm9tSHlwZXJpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjdGlvbnNGcm9tSHlwZXJpb24oKSB7XG4gIF9nZXRBY3Rpb25zRnJvbUh5cGVyaW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhY2NvdW50LCBfdGVtcDMpIHtcbiAgICB2YXIgX3JlZjMsIHNraXAsIGxpbWl0LCBzb3J0LCBhZnRlciwgYmVmb3JlLCBmaWx0ZXIsIHRva2VuRmlsdGVyLCBhY3Rpb25GaWx0ZXJzLCBjb250cmFjdEZpbHRlciwgYWN0aW9uRmlsdGVyLCBwYXJhbXMsIHJlc3VsdCwgX3Rva2VuRmlsdGVyJHNwbGl0MiwgdG9rZW5Db250cmFjdCwgYWN0aW9uRmlsdGVyc0xvY2FsLCBfaXRlcmF0b3IsIF9zdGVwLCBlYWNoRmlsdGVyLCB1bmlxdWVDb250cmFjdHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX3JlZjMgPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzLCBza2lwID0gX3JlZjMuc2tpcCwgbGltaXQgPSBfcmVmMy5saW1pdCwgc29ydCA9IF9yZWYzLnNvcnQsIGFmdGVyID0gX3JlZjMuYWZ0ZXIsIGJlZm9yZSA9IF9yZWYzLmJlZm9yZSwgZmlsdGVyID0gX3JlZjMuZmlsdGVyLCB0b2tlbkZpbHRlciA9IF9yZWYzLnRva2VuRmlsdGVyLCBhY3Rpb25GaWx0ZXJzID0gX3JlZjMuYWN0aW9uRmlsdGVycywgY29udHJhY3RGaWx0ZXIgPSBfcmVmMy5jb250cmFjdEZpbHRlciwgYWN0aW9uRmlsdGVyID0gX3JlZjMuYWN0aW9uRmlsdGVyO1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZVxuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgICAgc2tpcDogc2tpcCxcbiAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgICBzb3J0OiBzb3J0LFxuICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXIsXG4gICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIGFjdGlvbnMgZnJvbSBIeXBlcmlvbicpO1xuXG4gICAgICAgICAgICAvLyBUb2tlbiBmaWx0ZXIsIHdlIHdvdWxkIG9ubHkgcmVjZWl2ZSB1bmRlZmluZWQgb3IgKjphY3Rpb25cbiAgICAgICAgICAgIGlmICh0b2tlbkZpbHRlcikge1xuICAgICAgICAgICAgICBfdG9rZW5GaWx0ZXIkc3BsaXQyID0gdG9rZW5GaWx0ZXIuc3BsaXQoJyAnKSwgdG9rZW5Db250cmFjdCA9IF90b2tlbkZpbHRlciRzcGxpdDJbMV07XG5cbiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyID0gcGFyYW1zLmZpbHRlci5yZXBsYWNlKCcqJywgdG9rZW5Db250cmFjdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZpbHRlciA9IHRva2VuQ29udHJhY3QgKyBcIjoqXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGlvbkZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgYWN0aW9uRmlsdGVyc0xvY2FsID0gT2JqZWN0LmVudHJpZXMoYWN0aW9uRmlsdGVycykucmVkdWNlKGZ1bmN0aW9uIChmaWx0ZXJzLCBfcmVmNSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWY1WzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5pc0FjdGl2ZSA/IGZpbHRlcnMuY29uY2F0KHZhbHVlKSA6IGZpbHRlcnM7XG4gICAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgICBpZiAoYWN0aW9uRmlsdGVyc0xvY2FsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY3Rpb25GaWx0ZXJzTG9jYWwpOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICBlYWNoRmlsdGVyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICBlYWNoRmlsdGVyLmh5cGVyaW9uUXVlcnkoYWNjb3VudCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwYXJhbXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIEFjdGlvbnMgY29udHJhY3QgZmlsdGVyc1xuXG5cbiAgICAgICAgICAgIGlmIChjb250cmFjdEZpbHRlcikge1xuICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIgPSBwYXJhbXMuZmlsdGVyLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdEZpbHRlciArIFwiOlwiICsgZmlsdGVyLnNwbGl0KCc6JylbMV07XG4gICAgICAgICAgICAgICAgfSkuam9pbignLCcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIgPSBjb250cmFjdEZpbHRlciArIFwiOipcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWN0aW9uRmlsdGVyKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlQ29udHJhY3RzID0gQXJyYXkuZnJvbShuZXcgU2V0KHBhcmFtcy5maWx0ZXIuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5zcGxpdCgnOicpWzBdO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZpbHRlciA9IHVuaXF1ZUNvbnRyYWN0cy5tYXAoZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QgKyBcIjpcIiArIGFjdGlvbkZpbHRlcjtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcsJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZpbHRlciA9IFwiKjpcIiArIGFjdGlvbkZpbHRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBJZiBoeXBlcmlvbiBVUkwgcHJvdmlkZWQsIGRvIGl0IGNsaWVudCBzaWRlXG5cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5IWVBFUklPTl9VUkwpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbi5nZXRfYWN0aW9ucyhhY2NvdW50LCBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybEJ1aWxkZXIodGhpcy5jb25zdGFudHMuQVBJX1VSTCwgJ2h5cGVyaW9uJywge1xuICAgICAgICAgICAgICB0eXBlOiAnZ2V0X2FjdGlvbnMnLFxuICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ0LnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmV0cmlldmUgYWN0aW9ucycpO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIGh5cGVyaW9uVHJhbnNmb3JtR2V0QWN0aW9ucyhyZXN1bHQpKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY3Rpb25zRnJvbUh5cGVyaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERhcHBTdGF0cygpIHtcbiAgcmV0dXJuIF9nZXREYXBwU3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERhcHBTdGF0cygpIHtcbiAgX2dldERhcHBTdGF0cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZGFwcHNlcnZpY2VzJyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgICAgIHNjb3BlOiAnLi4uLi4uMmtlMS5vNCcsXG4gICAgICAgICAgICAgIHRhYmxlOiAnc3RhdGV4dCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKCEoIXJlc3VsdCB8fCAhcmVzdWx0LnJvd3MgfHwgIXJlc3VsdC5yb3dzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHt9KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LnJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDExO1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7fSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDExXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RGFwcFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERzcFBhY2thZ2VzKCkge1xuICByZXR1cm4gX2dldERzcFBhY2thZ2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREc3BQYWNrYWdlcygpIHtcbiAgX2dldERzcFBhY2thZ2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZGFwcHNlcnZpY2VzJyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDUwMCxcbiAgICAgICAgICAgICAgc2NvcGU6ICdkYXBwc2VydmljZXMnLFxuICAgICAgICAgICAgICB0YWJsZTogJ3BhY2thZ2UnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0ICYmIHJlc3VsdC5yb3dzICYmIHJlc3VsdC5yb3dzLmxlbmd0aCA/IHJlc3VsdC5yb3dzIDogW10pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA3O1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDIudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDddXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREc3BQYWNrYWdlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREYXBwaG9kbEJhbGFuY2UoX3gpIHtcbiAgcmV0dXJuIF9nZXREYXBwaG9kbEJhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERhcHBob2RsQmFsYW5jZSgpIHtcbiAgX2dldERhcHBob2RsQmFsYW5jZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYWNjb3VudCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdkYXBwYWlyaG9kbDEnLFxuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgc2NvcGU6IGFjY291bnQsXG4gICAgICAgICAgICAgIHRhYmxlOiAnYWNjb3VudHMnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0ICYmIHJlc3VsdC5yb3dzICYmIHJlc3VsdC5yb3dzLmxlbmd0aCA/IHJlc3VsdC5yb3dzWzBdIDoge30pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSA3O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB7fSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMCwgN11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERhcHBob2RsQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREYXBwQmFsYW5jZShfeDIpIHtcbiAgcmV0dXJuIF9nZXREYXBwQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RGFwcEJhbGFuY2UoKSB7XG4gIF9nZXREYXBwQmFsYW5jZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWNjb3VudCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdkYXBwc2VydmljZXMnLFxuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgc2NvcGU6IGFjY291bnQsXG4gICAgICAgICAgICAgIHRhYmxlOiAnYWNjb3VudHMnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0ICYmIHJlc3VsdC5yb3dzICYmIHJlc3VsdC5yb3dzLmxlbmd0aCA/IHJlc3VsdC5yb3dzWzBdIDoge30pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSA3O1xuICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB7fSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMsIFtbMCwgN11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERhcHBCYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERhcHBTdGFrZXMoX3gzKSB7XG4gIHJldHVybiBfZ2V0RGFwcFN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RGFwcFN0YWtlcygpIHtcbiAgX2dldERhcHBTdGFrZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGFjY291bnQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZGFwcHNlcnZpY2VzJyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMCxcbiAgICAgICAgICAgICAgc2NvcGU6IGFjY291bnQsXG4gICAgICAgICAgICAgIHRhYmxlOiAnc3Rha2luZydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByZXN1bHQgJiYgcmVzdWx0LnJvd3MgJiYgcmVzdWx0LnJvd3MubGVuZ3RoID8gcmVzdWx0LnJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcm93LnNjb3BlID0gYWNjb3VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgICAgIH0pIDogW10pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA3O1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMCwgN11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERhcHBTdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGFwcGhvZGxTdGFrZXMoX3g0LCBfeDUpIHtcbiAgcmV0dXJuIF9nZXREYXBwaG9kbFN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RGFwcGhvZGxTdGFrZXMoKSB7XG4gIF9nZXREYXBwaG9kbFN0YWtlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoYWNjb3VudCwgbG93ZXJfYm91bmQpIHtcbiAgICB2YXIgcmVzdWx0LCByb3dzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAobG93ZXJfYm91bmQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBsb3dlcl9ib3VuZCA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZGFwcHNlcnZpY2VzJyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMDAsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZGFwcGFpcmhvZGwxJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdzdGFraW5nJyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGxvd2VyX2JvdW5kXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Ni5zZW50O1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJvd3MgPSByZXN1bHQucm93cztcblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQubW9yZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gcm93cztcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXBwaG9kbFN0YWtlcyhhY2NvdW50LCArcm93c1tyb3dzLmxlbmd0aCAtIDFdLmlkICsgMSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQ2LnQxID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX2NvbnRleHQ2LnQwLmNvbmNhdC5jYWxsKF9jb250ZXh0Ni50MCwgX2NvbnRleHQ2LnQxKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuYWNjb3VudCA9PT0gYWNjb3VudDtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJvdy5zY29wZSA9ICdkYXBwYWlyaG9kbDEnO1xuICAgICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMTc7XG4gICAgICAgICAgICBfY29udGV4dDYudDIgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNiwgdGhpcywgW1sxLCAxN11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERhcHBob2RsU3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERhcHBVbnN0YWtlcyhfeDYpIHtcbiAgcmV0dXJuIF9nZXREYXBwVW5zdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERhcHBVbnN0YWtlcygpIHtcbiAgX2dldERhcHBVbnN0YWtlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoYWNjb3VudCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdkYXBwc2VydmljZXMnLFxuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICAgICAgICBzY29wZTogYWNjb3VudCxcbiAgICAgICAgICAgICAgdGFibGU6ICdyZWZ1bmRzJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCAmJiByZXN1bHQucm93cyAmJiByZXN1bHQucm93cy5sZW5ndGggPyByZXN1bHQucm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByb3cuc2NvcGUgPSBhY2NvdW50O1xuICAgICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICAgICAgfSkgOiBbXSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDc7XG4gICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgdGhpcywgW1swLCA3XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RGFwcFVuc3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERhcHBob2RsVW5zdGFrZXMoX3g3KSB7XG4gIHJldHVybiBfZ2V0RGFwcGhvZGxVbnN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RGFwcGhvZGxVbnN0YWtlcygpIHtcbiAgX2dldERhcHBob2RsVW5zdGFrZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KGFjY291bnQpIHtcbiAgICB2YXIgcmVzdWx0LCByb3dzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZGFwcHNlcnZpY2VzJyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMDAsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZGFwcGFpcmhvZGwxJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdyZWZ1bmRzJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDguc2VudDtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByb3dzID0gcmVzdWx0LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghcmVzdWx0Lm1vcmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0OC50MCA9IHJvd3M7XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGFwcGhvZGxVbnN0YWtlcyhhY2NvdW50KTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDgudDEgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfY29udGV4dDgudDAuY29uY2F0LmNhbGwoX2NvbnRleHQ4LnQwLCBfY29udGV4dDgudDEpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5hY2NvdW50ID09PSBhY2NvdW50O1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcm93LnNjb3BlID0gJ2RhcHBhaXJob2RsMSc7XG4gICAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAxNjtcbiAgICAgICAgICAgIF9jb250ZXh0OC50MiA9IF9jb250ZXh0OFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU4LCB0aGlzLCBbWzAsIDE2XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RGFwcGhvZGxVbnN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgaHR0cCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmMiA9IC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoX3JlZikge1xuICAgIHZhciBwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMsIGRhdGEsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHBhdGggPSBfcmVmLnBhdGgsIG1ldGhvZCA9IF9yZWYubWV0aG9kLCBib2R5ID0gX3JlZi5ib2R5LCBoZWFkZXJzID0gX3JlZi5oZWFkZXJzO1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChwYXRoLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzIHx8IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTA7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBScGNFcnJvcihkYXRhIHx8ICdFcnJvcicpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzEsIDEwXV0pO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGh0dHAoX3gpIHtcbiAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcbnZhciBnZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZjMgPSAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihwYXRoLCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBodHRwKHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gZ2V0KF94MiwgX3gzKSB7XG4gICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG52YXIgcG9zdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmNCA9IC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHBhdGgsIGJvZHkpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGh0dHAoe1xuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQzLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMpO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBvc3QoX3g0LCBfeDUpIHtcbiAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gZ2V0RklPVm90ZXIoX3gpIHtcbiAgcmV0dXJuIF9nZXRGSU9Wb3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RklPVm90ZXIoKSB7XG4gIF9nZXRGSU9Wb3RlciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdGFibGU6ICd2b3RlcnMnLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAzLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5yb3dzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByb3dzLmxlbmd0aCA/IHJvd3NbMF0gOiB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRGSU9Wb3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRGSU9BZGRyZXNzQnlOYW1lKF94Mikge1xuICByZXR1cm4gX2dldEZJT0FkZHJlc3NCeU5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEZJT0FkZHJlc3NCeU5hbWUoKSB7XG4gIF9nZXRGSU9BZGRyZXNzQnlOYW1lID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihuYW1lKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gdGhpcy5ycGM7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nX3RvX3VpbnQxMjhfaGFzaChuYW1lKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQyLnQyID0gJzB4JyArIF9jb250ZXh0Mi50MTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MyA9IHtcbiAgICAgICAgICAgICAgY29kZTogJ2Zpby5hZGRyZXNzJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdmaW8uYWRkcmVzcycsXG4gICAgICAgICAgICAgIHRhYmxlOiAnZmlvbmFtZXMnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogX2NvbnRleHQyLnQyLFxuICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpMTI4JyxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnQwLmdldF90YWJsZV9yb3dzLmNhbGwoX2NvbnRleHQyLnQwLCBfY29udGV4dDIudDMpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90MiA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDIucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCAmJiByb3dzWzBdLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE4O1xuICAgICAgICAgICAgX2NvbnRleHQyLnQ0ID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDIudDQpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCAxOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEZJT0FkZHJlc3NCeU5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0TkZUc0J5RmlvQWRkcmVzcyhfeDMpIHtcbiAgcmV0dXJuIF9nZXRORlRzQnlGaW9BZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRORlRzQnlGaW9BZGRyZXNzKCkge1xuICBfZ2V0TkZUc0J5RmlvQWRkcmVzcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMobmFtZSkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X24sIG5mdHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF9uZnRzX2Zpb19hZGRyZXNzKG5hbWUpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF9uID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBuZnRzID0gX3lpZWxkJHRoaXMkcnBjJGdldF9uLm5mdHM7XG5cbiAgICAgICAgICAgIGlmICghKG5mdHMgJiYgbmZ0cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIG5mdHMpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDEyO1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDMudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzAsIDEyXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0TkZUc0J5RmlvQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRGSU9Eb21haW5CeU5hbWUoX3g0KSB7XG4gIHJldHVybiBfZ2V0RklPRG9tYWluQnlOYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRGSU9Eb21haW5CeU5hbWUoKSB7XG4gIF9nZXRGSU9Eb21haW5CeU5hbWUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KG5hbWUpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Mywgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDQudDAgPSB0aGlzLnJwYztcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdfdG9fdWludDEyOF9oYXNoKG5hbWUpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX2NvbnRleHQ0LnQxID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDQudDIgPSAnMHgnICsgX2NvbnRleHQ0LnQxO1xuICAgICAgICAgICAgX2NvbnRleHQ0LnQzID0ge1xuICAgICAgICAgICAgICBjb2RlOiAnZmlvLmFkZHJlc3MnLFxuICAgICAgICAgICAgICBzY29wZTogJ2Zpby5hZGRyZXNzJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdkb21haW5zJyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IF9jb250ZXh0NC50MixcbiAgICAgICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTEyOCcsXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiA0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC50MC5nZXRfdGFibGVfcm93cy5jYWxsKF9jb250ZXh0NC50MCwgX2NvbnRleHQ0LnQzKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDMgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QzLnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGggJiYgcm93c1swXS5uYW1lID09PSBuYW1lKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDIyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAxODtcbiAgICAgICAgICAgIF9jb250ZXh0NC50NCA9IF9jb250ZXh0NFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ0LnQ0KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMsIFtbMCwgMThdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRGSU9Eb21haW5CeU5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RG9tYWlucyhfeDUsIF94Nikge1xuICByZXR1cm4gX2dldERvbWFpbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERvbWFpbnMoKSB7XG4gIF9nZXREb21haW5zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShsaW1pdCwgdXBwZXJfYm91bmQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90NCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBsaW1pdCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZmlvLmFkZHJlc3MnLFxuICAgICAgICAgICAgICBzY29wZTogJ2Zpby5hZGRyZXNzJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdkb21haW5zJyxcbiAgICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6IHVwcGVyX2JvdW5kLFxuICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NCA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDQucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDE3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxMztcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ1LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1sxLCAxM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERvbWFpbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWRkcmVzc2VzKF94NywgX3g4KSB7XG4gIHJldHVybiBfZ2V0QWRkcmVzc2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBZGRyZXNzZXMoKSB7XG4gIF9nZXRBZGRyZXNzZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGxpbWl0LCB1cHBlcl9ib3VuZCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGxpbWl0ID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdmaW8uYWRkcmVzcycsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZmlvLmFkZHJlc3MnLFxuICAgICAgICAgICAgICB0YWJsZTogJ2Zpb25hbWVzJyxcbiAgICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6IHVwcGVyX2JvdW5kLFxuICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NSA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDUucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxMztcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NltcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ2LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNiwgdGhpcywgW1sxLCAxM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFkZHJlc3Nlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRGSU9Qcm9kdWNlcnMoX3g5KSB7XG4gIHJldHVybiBfZ2V0RklPUHJvZHVjZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRGSU9Qcm9kdWNlcnMoKSB7XG4gIF9nZXRGSU9Qcm9kdWNlcnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KGxpbWl0KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDYsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdwcm9kdWNlcnMnLFxuICAgICAgICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NiA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDYucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTI7XG4gICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Ny50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTcsIHRoaXMsIFtbMCwgMTJdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRGSU9Qcm9kdWNlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RklPQmFsYW5jZShfeDEwKSB7XG4gIHJldHVybiBfZ2V0RklPQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RklPQmFsYW5jZSgpIHtcbiAgX2dldEZJT0JhbGFuY2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KGZpb19wdWJsaWNfa2V5KSB7XG4gICAgdmFyIGJhbGFuY2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5mZXRjaCgnL3YxL2NoYWluL2dldF9maW9fYmFsYW5jZScsIHtcbiAgICAgICAgICAgICAgZmlvX3B1YmxpY19rZXk6IGZpb19wdWJsaWNfa2V5XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGJhbGFuY2UgPSBfY29udGV4dDguc2VudDtcblxuICAgICAgICAgICAgaWYgKCFiYWxhbmNlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIGJhbGFuY2UpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAxMTtcbiAgICAgICAgICAgIF9jb250ZXh0OC50MCA9IF9jb250ZXh0OFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ4LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU4LCB0aGlzLCBbWzAsIDExXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RklPQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRGSU9TdXBwbHlCcmVha2Rvd24oKSB7XG4gIHJldHVybiBfZ2V0RklPU3VwcGx5QnJlYWtkb3duLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRGSU9TdXBwbHlCcmVha2Rvd24oKSB7XG4gIF9nZXRGSU9TdXBwbHlCcmVha2Rvd24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KCkge1xuICAgIHZhciB0b2tlblJlcywgc3VwcGx5LCBicFJld2FyZFJlcywgYnBSZXdhcmRzLCBicEJ1Y2tldFJlcywgYnBCdWNrZXQsIHRvdGFsQnAsIGNpcmN1bGF0aW5nLCB0b3RhbExvY2tlZDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogXCJmaW8udG9rZW5cIixcbiAgICAgICAgICAgICAgc2NvcGU6IFwiRklPXCIsXG4gICAgICAgICAgICAgIHRhYmxlOiBcInN0YXRcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0b2tlblJlcyA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgc3VwcGx5ID0gK3Rva2VuUmVzLnJvd3NbMF0uc3VwcGx5LnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiBcImZpby50cmVhc3VyeVwiLFxuICAgICAgICAgICAgICBzY29wZTogXCJmaW8udHJlYXN1cnlcIixcbiAgICAgICAgICAgICAgdGFibGU6IFwiYnByZXdhcmRzXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgYnBSZXdhcmRSZXMgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgIGJwUmV3YXJkcyA9IGJwUmV3YXJkUmVzLnJvd3NbMF0ucmV3YXJkcyAvIE1hdGgucG93KDEwLCB0aGlzLmNvbnN0YW50cy5DT1JFX1BSRUNJU0lPTik7XG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogXCJmaW8udHJlYXN1cnlcIixcbiAgICAgICAgICAgICAgc2NvcGU6IFwiZmlvLnRyZWFzdXJ5XCIsXG4gICAgICAgICAgICAgIHRhYmxlOiBcImJwYnVja2V0cG9vbFwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBicEJ1Y2tldFJlcyA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgYnBCdWNrZXQgPSBicEJ1Y2tldFJlcy5yb3dzWzBdLnJld2FyZHMgLyBNYXRoLnBvdygxMCwgdGhpcy5jb25zdGFudHMuQ09SRV9QUkVDSVNJT04pO1xuICAgICAgICAgICAgdG90YWxCcCA9IGJwUmV3YXJkcyArIGJwQnVja2V0OyAvLyBjb25zdCB0b3RhbExvY2tlZCA9IGJhc2VMb2NrZWQgKyB0b3RhbEJwXG4gICAgICAgICAgICAvLyBjb25zdCBjaXJjdWxhdGluZyA9IHN1cHBseSAtIHRvdGFsTG9ja2VkXG5cbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ2h0dHBzOi8vZmlvcHJvdG9jb2wuaW8vY2lyY3VsYXRpbmcnKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBjaXJjdWxhdGluZyA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgdG90YWxMb2NrZWQgPSBzdXBwbHkgLSArY2lyY3VsYXRpbmc7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIHN1cHBseTogc3VwcGx5LFxuICAgICAgICAgICAgICB0b3RhbExvY2tlZDogdG90YWxMb2NrZWQsXG4gICAgICAgICAgICAgIGJwUmV3YXJkczogYnBSZXdhcmRzLFxuICAgICAgICAgICAgICBicEJ1Y2tldDogYnBCdWNrZXQsXG4gICAgICAgICAgICAgIHRvdGFsQnA6IHRvdGFsQnAsXG4gICAgICAgICAgICAgIGNpcmN1bGF0aW5nOiBjaXJjdWxhdGluZ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RklPU3VwcGx5QnJlYWtkb3duLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEZJT0ZlZXMoKSB7XG4gIHJldHVybiBfZ2V0RklPRmVlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RklPRmVlcygpIHtcbiAgX2dldEZJT0ZlZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMCgpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdmaW8uZmVlJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdmaW8uZmVlJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdmaW9mZWVzJyxcbiAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yb3dzO1xuICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEZJT0ZlZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gYWRkRklPRmVlVG9BY3Rpb25zKF94MTEsIF94MTIpIHtcbiAgcmV0dXJuIF9hZGRGSU9GZWVUb0FjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2FkZEZJT0ZlZVRvQWN0aW9ucygpIHtcbiAgX2FkZEZJT0ZlZVRvQWN0aW9ucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKGFjdGlvbnMsIGFjdG9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBmaW9GZWVzTWFwLCBmZWVzLCBtb2RpZmllZEFjdGlvbnMsIF9sb29wLCBfaXRlcmF0b3IsIF9zdGVwO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBmaW9GZWVzTWFwID0ge1xuICAgICAgICAgICAgICAnZW9zaW86OmRlbGV0ZWF1dGgnOiAnYXV0aF9kZWxldGUnLFxuICAgICAgICAgICAgICAnZW9zaW86OmxpbmthdXRoJzogJ2F1dGhfbGluaycsXG4gICAgICAgICAgICAgICdlb3Npbzo6cmVncHJvZHVjZXInOiAncmVnaXN0ZXJfcHJvZHVjZXInLFxuICAgICAgICAgICAgICAnZW9zaW86OnJlZ3Byb3h5JzogJ3JlZ2lzdGVyX3Byb3h5JyxcbiAgICAgICAgICAgICAgJ2Vvc2lvOjp1bnJlZ3Byb2QnOiAndW5yZWdpc3Rlcl9wcm9kdWNlcicsXG4gICAgICAgICAgICAgICdlb3Npbzo6dW5yZWdwcm94eSc6ICd1bnJlZ2lzdGVyX3Byb3h5JyxcbiAgICAgICAgICAgICAgJ2Vvc2lvOjp1cGRhdGVhdXRoJzogJ2F1dGhfdXBkYXRlJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvOjp2b3RlcHJvZHVjZXInOiAndm90ZV9wcm9kdWNlcicsXG4gICAgICAgICAgICAgICdlb3Npbzo6dm90ZXByb3h5JzogJ3Byb3h5X3ZvdGUnLFxuICAgICAgICAgICAgICAnZmlvLnRva2VuOjp0cm5zZmlvcHVia3knOiAndHJhbnNmZXJfdG9rZW5zX3B1Yl9rZXknLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OmFkZGFkZHJlc3MnOiAnYWRkX3B1Yl9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjpyZWdhZGRyZXNzJzogJ3JlZ2lzdGVyX2Zpb19hZGRyZXNzJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjpyZWdkb21haW4nOiAncmVnaXN0ZXJfZmlvX2RvbWFpbicsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6cmVuZXdhZGRyZXNzJzogJ3JlbmV3X2Zpb19hZGRyZXNzJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjpyZW5ld2RvbWFpbic6ICdyZW5ld19maW9fZG9tYWluJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjpzZXRkb21haW5wdWInOiAnc2V0X2Zpb19kb21haW5fcHVibGljJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvLm1zaWc6OmFwcHJvdmUnOiAnbXNpZ19hcHByb3ZlJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvLm1zaWc6OmNhbmNlbCc6ICdtc2lnX2NhbmNlbCcsXG4gICAgICAgICAgICAgICdlb3Npby5tc2lnOjpleGVjJzogJ21zaWdfZXhlYycsXG4gICAgICAgICAgICAgICdlb3Npby5tc2lnOjppbnZhbGlkYXRlJzogJ21zaWdfaW52YWxpZGF0ZScsXG4gICAgICAgICAgICAgICdlb3Npby5tc2lnOjpwcm9wb3NlJzogJ21zaWdfcHJvcG9zZScsXG4gICAgICAgICAgICAgICdlb3Npby5tc2lnOjp1bmFwcHJvdmUnOiAnbXNpZ19hcHByb3ZlJyxcbiAgICAgICAgICAgICAgJ2Zpby5yZXFvYnQ6Om5ld2Z1bmRzcmVxJzogJ25ld19mdW5kc19yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgJ2Zpby5yZXFvYnQ6OnJlamVjdGZuZHJlcSc6ICdyZWplY3RfZnVuZHNfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICdmaW8ucmVxb2J0OjpjYW5jZWxmbmRyZXEnOiAnY2FuY2VsZm5kcmVxJyxcbiAgICAgICAgICAgICAgJ2Zpby5yZXFvYnQ6OnJlY29yZG9idCc6ICdyZWNvcmRfb2J0X2RhdGEnLFxuICAgICAgICAgICAgICAnZmlvLnJlcW9idDo6bmV3cHViYWRkcmVxJzogJ25ld19wdWJfYWRkcmVzc19yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgJ2Zpby5yZXFvYnQ6OnJlbHB1YmFkZCc6ICdyZWxlYXNlX3B1Yl9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgJ2Zpby5yZXFvYnQ6OnJlamVjdGFkZHJlcSc6ICdyZWplY3RfcHViX2FkZHJlc3NfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICdmaW8ucmVxb2J0OjpjYW5jZWxhZGRyZXEnOiAnY2FuY2VsX3B1Yl9hZGRyZXNzX3JlcXVlc3QnLFxuICAgICAgICAgICAgICAnZmlvLmxvY2s6OnRybnNsb2N0b2tzJzogJ3RyYW5zZmVyX2xvY2tlZF90b2tlbnMnLFxuICAgICAgICAgICAgICAnZmlvLmxvY2s6OmxvY2t0b2tlbnMnOiAnbG9ja190b2tlbnMnLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OnJlbWFkZHJlc3MnOiAncmVtb3ZlX3B1Yl9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjpyZW1hbGxhZGRyJzogJ3JlbW92ZV9hbGxfcHViX2FkZHJlc3NlcycsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6YnVybmFkZHJlc3MnOiAnYnVybl9maW9fYWRkcmVzcycsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6eGZlcmRvbWFpbic6ICd0cmFuc2Zlcl9maW9fZG9tYWluJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjp4ZmVyYWRkcmVzcyc6ICd0cmFuc2Zlcl9maW9fYWRkcmVzcydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RklPRmVlcygpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZmVlcyA9IF9jb250ZXh0MTIuc2VudDtcbiAgICAgICAgICAgIG1vZGlmaWVkQWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgX2xvb3AgPSAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgICAgIHZhciBhY3Rpb24sIF95aWVsZCRfdGhpcyRhcGkkZ2V0QywgX3lpZWxkJF90aGlzJGFwaSRnZXRDMiwgYWJpQWN0aW9ucywgYWJpU3RydWN0cywgcmVsZXZhbnRBY3Rpb24sIHJlbGV2YW50U3RydWN0LCBtYXhGZWVGaWVsZCwgZW5kcG9pbnQsIHJlbGV2YW50RmVlLCBhY3RvckZpZWxkLCB0cGlkRmllbGQsIGFkZHJlc3NGaWVsZCwgYWRkcmVzc2VzO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfbG9vcCQoX2NvbnRleHQxMSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXBpLmdldENhY2hlZEFiaShhY3Rpb24uYWNjb3VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgIF95aWVsZCRfdGhpcyRhcGkkZ2V0QyA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICBfeWllbGQkX3RoaXMkYXBpJGdldEMyID0gX3lpZWxkJF90aGlzJGFwaSRnZXRDLmFiaTtcbiAgICAgICAgICAgICAgICAgICAgICBhYmlBY3Rpb25zID0gX3lpZWxkJF90aGlzJGFwaSRnZXRDMi5hY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICAgIGFiaVN0cnVjdHMgPSBfeWllbGQkX3RoaXMkYXBpJGdldEMyLnN0cnVjdHM7XG4gICAgICAgICAgICAgICAgICAgICAgcmVsZXZhbnRBY3Rpb24gPSBhYmlBY3Rpb25zLmZpbmQoZnVuY3Rpb24gKGFiaUFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFiaUFjdGlvbi5uYW1lID09PSBhY3Rpb24ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVsZXZhbnRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgcmVsZXZhbnRTdHJ1Y3QgPSBhYmlTdHJ1Y3RzLmZpbmQoZnVuY3Rpb24gKGFiaVN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFiaVN0cnVjdC5uYW1lID09PSByZWxldmFudEFjdGlvbi50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxldmFudFN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVGaWVsZCA9IHJlbGV2YW50U3RydWN0LmZpZWxkcy5maW5kKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm5hbWUgPT09IFwibWF4X2ZlZVwiO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1heEZlZUZpZWxkICYmIGFjdGlvbi5kYXRhLm1heF9mZWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBmaW9GZWVzTWFwW2FjdGlvbi5hY2NvdW50ICsgXCI6OlwiICsgYWN0aW9uLm5hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsZXZhbnRGZWUgPSBmZWVzLmZpbmQoZnVuY3Rpb24gKGZlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmZWUuZW5kX3BvaW50ID09PSBlbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGV2YW50RmVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmRhdGEubWF4X2ZlZSA9IHJlbGV2YW50RmVlLnN1Zl9hbW91bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmRhdGEubWF4X2ZlZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBhY3RvckZpZWxkID0gcmVsZXZhbnRTdHJ1Y3QuZmllbGRzLmZpbmQoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQubmFtZSA9PT0gXCJhY3RvclwiO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yRmllbGQgJiYgYWN0aW9uLmRhdGEuYWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmRhdGEuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICB0cGlkRmllbGQgPSByZWxldmFudFN0cnVjdC5maWVsZHMuZmluZChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC5uYW1lID09PSBcInRwaWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0cGlkRmllbGQgJiYgYWN0aW9uLmRhdGEudHBpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24uZGF0YS50cGlkID0gX3RoaXMuY29uc3RhbnRzLkZJT19GRUVTX0FDQ09VTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc0ZpZWxkID0gcmVsZXZhbnRTdHJ1Y3QuZmllbGRzLmZpbmQoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQubmFtZSA9PT0gXCJmaW9fYWRkcmVzc1wiO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYWRkcmVzc0ZpZWxkICYmIGFjdGlvbi5kYXRhLmZpb19hZGRyZXNzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRGSU9BZGRyZXNzZXMoYWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzID0gX2NvbnRleHQxMS5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5kYXRhLmZpb19hZGRyZXNzID0gYWRkcmVzc2VzWzBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBY3Rpb25zLnB1c2goYWN0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgX2xvb3ApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWYgKChfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuZGVsZWdhdGVZaWVsZChfbG9vcCgpLCBcInQwXCIsIDkpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCBtb2RpZmllZEFjdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMTEsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfYWRkRklPRmVlVG9BY3Rpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEZJT0FkZHJlc3NlcyhhY2NvdW50KSB7XG4gIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgY29kZTogJ2Zpby5hZGRyZXNzJyxcbiAgICBzY29wZTogJ2Zpby5hZGRyZXNzJyxcbiAgICB0YWJsZTogJ2Zpb25hbWVzJyxcbiAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgbGltaXQ6IC0xLFxuICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICB1cHBlcl9ib3VuZDogbmV3IEJpZ051bWJlcihlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSkucGx1cygxKS50b1N0cmluZygpLFxuICAgIGluZGV4X3Bvc2l0aW9uOiA0XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQucm93cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5vd25lcl9hY2NvdW50ID09PSBhY2NvdW50O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF8pIHtcbiAgICByZXR1cm4gW107XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RklPRG9tYWlucyhhY2NvdW50KSB7XG4gIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgY29kZTogJ2Zpby5hZGRyZXNzJyxcbiAgICBzY29wZTogJ2Zpby5hZGRyZXNzJyxcbiAgICB0YWJsZTogJ2RvbWFpbnMnLFxuICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICBsaW1pdDogLTEsXG4gICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgIHVwcGVyX2JvdW5kOiBuZXcgQmlnTnVtYmVyKGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpKS5wbHVzKDEpLnRvU3RyaW5nKCksXG4gICAgaW5kZXhfcG9zaXRpb246IDJcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5yb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiByZXN1bHQucm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gcm93LmFjY291bnQgPT09IGFjY291bnQ7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoXykge1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRGSU9BZGRyZXNzZXNBbmREb21haW5zKGZpb19wdWJsaWNfa2V5KSB7XG4gIHJldHVybiBwb3N0KHRoaXMuY29uc3RhbnRzLkRFRkFVTFRfRU5EUE9JTlRTWzBdICsgXCIvdjEvZ2V0X2Zpb19uYW1lc1wiLCB7XG4gICAgZmlvX3B1YmxpY19rZXk6IGZpb19wdWJsaWNfa2V5XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBbGxNc2lncygpIHtcbiAgcmV0dXJuIF9nZXRBbGxNc2lncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWxsTXNpZ3MoKSB7XG4gIF9nZXRBbGxNc2lncyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkZ2V0LCB0YWJsZXMsIHJvd3MsIGxvd2VyX2JvdW5kLCByZXN1bHQ7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVMuaW5jbHVkZXMoJ2RmdXNlJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmxCdWlsZGVyKHRoaXMuY29uc3RhbnRzLkFQSV9VUkwsICdkZnVzZScsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0YXRlX3Njb3BlX3BpcGVsaW5lJyxcbiAgICAgICAgICAgICAgYWNjb3VudDogdGhpcy5jb25zdGFudHMuRU9TSU9fTVNJRyxcbiAgICAgICAgICAgICAgdGFibGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUdfUFJPUE9TQUxTX1RBQkxFLFxuICAgICAgICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHRhYmxlcyA9IF95aWVsZCR0aGlzJGdldC50YWJsZXM7XG4gICAgICAgICAgICB0YWJsZXMgPSB0YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgICB0YWJsZS5yb3dzID0gdGFibGUucm93cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIuYmxvY2sgLSBhLmJsb2NrO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGFibGUuaGlnaGVzdEJsb2NrID0gdGFibGUucm93c1swXS5ibG9jaztcbiAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYi5oaWdoZXN0QmxvY2sgLSBhLmhpZ2hlc3RCbG9jaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0YWJsZXMpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcm93cyA9IFtdO1xuICAgICAgICAgICAgbG93ZXJfYm91bmQgPSAnJztcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX2J5X3Njb3BlKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogJ2Vvc2lvLm1zaWcnLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogbG93ZXJfYm91bmQsXG4gICAgICAgICAgICAgIHRhYmxlOiAncHJvcG9zYWwnLFxuICAgICAgICAgICAgICB1cHBlcl9ib3VuZDogJydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBsb3dlcl9ib3VuZCA9IHJlc3VsdC5tb3JlO1xuICAgICAgICAgICAgcm93cyA9IHJvd3MuY29uY2F0KHJlc3VsdC5yb3dzKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBpZiAobG93ZXJfYm91bmQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY29wZTogcm93LnNjb3BlLFxuICAgICAgICAgICAgICAgIHJvd3M6IEFycmF5KHJvdy5jb3VudCkuZmlsbCh7XG4gICAgICAgICAgICAgICAgICBrZXk6ICcnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWxsTXNpZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0TXNpZ1Byb3Bvc2FsKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9nZXRNc2lnUHJvcG9zYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldE1zaWdQcm9wb3NhbCgpIHtcbiAgX2dldE1zaWdQcm9wb3NhbCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYWNjb3VudE5hbWUsIHByb3Bvc2FsTmFtZSkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogJ2Vvc2lvLm1zaWcnLFxuICAgICAgICAgICAgICBzY29wZTogYWNjb3VudE5hbWUsXG4gICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogcHJvcG9zYWxOYW1lLFxuICAgICAgICAgICAgICB0YWJsZTogJ3Byb3Bvc2FsJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Qucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCAmJiByb3dzWzBdLnByb3Bvc2FsX25hbWUgPT09IHByb3Bvc2FsTmFtZSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0TXNpZ1Byb3Bvc2FsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFja2VkTXNpZ0FjdGlvbnMoX3gzKSB7XG4gIHJldHVybiBfcGFyc2VQYWNrZWRNc2lnQWN0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcGFyc2VQYWNrZWRNc2lnQWN0aW9ucygpIHtcbiAgX3BhcnNlUGFja2VkTXNpZ0FjdGlvbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHBhY2tlZEFjdGlvbnMpIHtcbiAgICB2YXIgYWN0aW9ucywgX2l0ZXJhdG9yLCBfc3RlcCwgYWN0aW9uO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UocGFja2VkQWN0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFjdGlvbiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIShhY3Rpb24uYWNjb3VudCA9PT0gdGhpcy5jb25zdGFudHMuRU9TSU9fTVNJRyAmJiBhY3Rpb24ubmFtZSA9PT0gJ3Byb3Bvc2UnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGkuZGVzZXJpYWxpemVBY3Rpb25zU3luYyhhY3Rpb24uZGF0YS50cnguYWN0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBhY3Rpb24uZGF0YS50cnguYWN0aW9ucyA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgaWYgKCEoYWN0aW9uLmFjY291bnQgPT09IHRoaXMuY29uc3RhbnRzLkVPU0lPICYmIGFjdGlvbi5uYW1lID09PSAnc2V0YWJpJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGkucmF3QWJpVG9Kc29uKGhleFRvVWludDhBcnJheShhY3Rpb24uZGF0YS5hYmkpKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBhY3Rpb24uZGF0YS5hYmkgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGlvbl90cmFjZToge1xuICAgICAgICAgICAgICAgICAgYWN0OiBhY3Rpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIGFjdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX3BhcnNlUGFja2VkTXNpZ0FjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYWNrZWRNc2lnKF94NCkge1xuICByZXR1cm4gX3BhcnNlUGFja2VkTXNpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcGFyc2VQYWNrZWRNc2lnKCkge1xuICBfcGFyc2VQYWNrZWRNc2lnID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChwYWNrZWRfdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgdHg7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaS5kZXNlcmlhbGl6ZVRyYW5zYWN0aW9uV2l0aEFjdGlvbnMocGFja2VkX3RyYW5zYWN0aW9uKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHR4ID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBhY2tlZE1zaWdBY3Rpb25zKHR4LmFjdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgdHguYWN0aW9ucyA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdHgpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTA7XG4gICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBwYXJzaW5nIHBhY2tlZCBtc2lnJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDQudDApO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzAsIDEwXV0pO1xuICB9KSk7XG4gIHJldHVybiBfcGFyc2VQYWNrZWRNc2lnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEZ1bGxNc2lnUHJvcG9zYWwoX3g1LCBfeDYpIHtcbiAgcmV0dXJuIF9nZXRGdWxsTXNpZ1Byb3Bvc2FsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRGdWxsTXNpZ1Byb3Bvc2FsKCkge1xuICBfZ2V0RnVsbE1zaWdQcm9wb3NhbCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoYWNjb3VudF9uYW1lLCBwcm9wb3NhbF9uYW1lKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU9fTVNJRyxcbiAgICAgICAgICAgICAgc2NvcGU6IGVuY29kZU5hbWUoYWNjb3VudF9uYW1lLCBmYWxzZSksXG4gICAgICAgICAgICAgIHRhYmxlOiB0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHX1BST1BPU0FMU19UQUJMRSxcbiAgICAgICAgICAgICAgdGFibGVfa2V5OiAnJyxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICduYW1lJyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IHByb3Bvc2FsX25hbWUsXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAxLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgaWYgKCEocmVzdWx0ICYmIHJlc3VsdC5yb3dzICYmIHJlc3VsdC5yb3dzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYWNrZWRNc2lnKHJlc3VsdC5yb3dzWzBdLnBhY2tlZF90cmFuc2FjdGlvbik7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDUuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxMDtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ1LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1swLCAxMF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEZ1bGxNc2lnUHJvcG9zYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0TXNpZ0FwcHJvdmFscyhfeDcsIF94OCkge1xuICByZXR1cm4gX2dldE1zaWdBcHByb3ZhbHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldE1zaWdBcHByb3ZhbHMoKSB7XG4gIF9nZXRNc2lnQXBwcm92YWxzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihhY2NvdW50LCB0YWJsZSkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUcsXG4gICAgICAgICAgICAgIHNjb3BlOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICBsaW1pdDogLTFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90MiA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDIucm93cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gX2NvbnRleHQ2W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDYudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzAsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRNc2lnQXBwcm92YWxzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjY291bnRzTXNpZ1Byb3Bvc2FscyhfeDkpIHtcbiAgcmV0dXJuIF9nZXRBY2NvdW50c01zaWdQcm9wb3NhbHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjY291bnRzTXNpZ1Byb3Bvc2FscygpIHtcbiAgX2dldEFjY291bnRzTXNpZ1Byb3Bvc2FscyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoYWNjb3VudCkge1xuICAgIHZhciBwcm9taXNlcywgX3lpZWxkJFByb21pc2UkYWxsLCByb3dzMiwgcm93czE7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAwO1xuICAgICAgICAgICAgcHJvbWlzZXMgPSBbdGhpcy5nZXRNc2lnQXBwcm92YWxzKGFjY291bnQsIHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUdfQVBQUk9WQUxTX1RBQkxFKV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHX0FQUFJPVkFMU19UQUJMRSA9PT0gJ2FwcHJvdmFsczInKSB7XG4gICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5nZXRNc2lnQXBwcm92YWxzKGFjY291bnQsICdhcHByb3ZhbHMnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfeWllbGQkUHJvbWlzZSRhbGwgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgIHJvd3MyID0gX3lpZWxkJFByb21pc2UkYWxsWzBdO1xuICAgICAgICAgICAgcm93czEgPSBfeWllbGQkUHJvbWlzZSRhbGxbMV07XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCByb3dzMi5jb25jYXQocm93czEpKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDExO1xuICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDcudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU3LCB0aGlzLCBbWzAsIDExXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWNjb3VudHNNc2lnUHJvcG9zYWxzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGh5cGVyaW9uR2V0TXNpZyhfeDEwKSB7XG4gIHJldHVybiBfaHlwZXJpb25HZXRNc2lnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9oeXBlcmlvbkdldE1zaWcoKSB7XG4gIF9oeXBlcmlvbkdldE1zaWcgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KG1zaWdGaWx0ZXJzKSB7XG4gICAgdmFyIHJlcywgZXhlY3V0aW9uVHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLCBwcm9wb3NhbCwgX3lpZWxkJFByb21pc2UkYWxsMiwgYWN0aW9uc1JlcywgYWN0aW9uc1JlczIsIHJlbGV2YW50QWN0aW9uLCB0eDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAodGhpcy5oeXBlcmlvbikge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb24uZ2V0X3Byb3Bvc2Fscyhtc2lnRmlsdGVycyk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXMgPSBfY29udGV4dDguc2VudDtcblxuICAgICAgICAgICAgaWYgKCEocmVzICYmIHJlcy5wcm9wb3NhbHMgJiYgcmVzLnByb3Bvc2Fscy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wb3NhbCA9IHJlcy5wcm9wb3NhbHNbMF07XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMuaHlwZXJpb24uZ2V0X2FjdGlvbnModGhpcy5jb25zdGFudHMuRU9TSU9fTVNJRywge1xuICAgICAgICAgICAgICBibG9ja19udW06IHByb3Bvc2FsLmJsb2NrX251bSxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pLCB0aGlzLmh5cGVyaW9uLmdldF9kZWx0YXModGhpcy5jb25zdGFudHMuRU9TSU9fTVNJRywgbXNpZ0ZpbHRlcnMucHJvcG9zZXIsICdwcm9wb3NhbCcsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICBibG9ja19udW06IHByb3Bvc2FsLmJsb2NrX251bVxuICAgICAgICAgICAgfSldKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF95aWVsZCRQcm9taXNlJGFsbDIgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgIGFjdGlvbnNSZXMgPSBfeWllbGQkUHJvbWlzZSRhbGwyWzBdO1xuICAgICAgICAgICAgYWN0aW9uc1JlczIgPSBfeWllbGQkUHJvbWlzZSRhbGwyWzFdO1xuXG4gICAgICAgICAgICBpZiAoYWN0aW9uc1JlcyAmJiBhY3Rpb25zUmVzLmFjdGlvbnMgJiYgYWN0aW9uc1Jlcy5hY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZWxldmFudEFjdGlvbiA9IGFjdGlvbnNSZXMuYWN0aW9ucy5maW5kKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLmFjdC5kYXRhLnByb3Bvc2FsX25hbWUgPT09IG1zaWdGaWx0ZXJzLnByb3Bvc2FsO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAocmVsZXZhbnRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBleGVjdXRpb25UcmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgIHBheWVyOiByZWxldmFudEFjdGlvbi5hY3QuZGF0YS5leGVjdXRlciB8fCByZWxldmFudEFjdGlvbi5hY3QuZGF0YS5jYW5jZWxlcixcbiAgICAgICAgICAgICAgICAgIHRyeF9pZDogcmVsZXZhbnRBY3Rpb24udHJ4X2lkLFxuICAgICAgICAgICAgICAgICAgcHVibGlzaGVkX2F0OiByZWxldmFudEFjdGlvbi50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IHJlbGV2YW50QWN0aW9uLmFjdC5uYW1lID09PSAnY2FuY2VsJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoYWN0aW9uc1JlczIgJiYgYWN0aW9uc1JlczIuZGVsdGFzICYmIGFjdGlvbnNSZXMyLmRlbHRhcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0eCA9IGFjdGlvbnNSZXMyLmRlbHRhc1swXS5kYXRhLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxNztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFja2VkTXNpZ0FjdGlvbnModHguYWN0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgdHguYWN0aW9ucyA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0eDtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIGFwcHJvdmFsczogcHJvcG9zYWwsXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgZXhlY3V0aW9uVHJhbnNhY3Rpb246IGV4ZWN1dGlvblRyYW5zYWN0aW9uXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2h5cGVyaW9uR2V0TXNpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRWb3RlcihfeCkge1xuICByZXR1cm4gX2dldFZvdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRWb3RlcigpIHtcbiAgX2dldFZvdGVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB0YWJsZTogJ3ZvdGVycycsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90LnJvd3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MubGVuZ3RoID8gcm93c1swXSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFZvdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb3hpZXMoKSB7XG4gIHJldHVybiBfZ2V0UHJveGllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJveGllcygpIHtcbiAgX2dldFByb3hpZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3lpZWxkJHRoaXMkZ2V0LCBwcm94aWVzLCBfeWllbGQkdGhpcyRoeXBlcmlvbiQsIHZvdGVycztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh0aGlzLmNvbnN0YW50cy5BTE9IQV9QUk9YWV9VUkwgIT09ICcnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5jb25zdGFudHMuQUxPSEFfUFJPWFlfVVJMICsgXCI/b3V0cHV0PWpzb25cIik7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRnZXQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHByb3hpZXMgPSBfeWllbGQkdGhpcyRnZXQucHJveGllcztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHByb3hpZXMpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uLmdldF92b3RlcnMoe1xuICAgICAgICAgICAgICBwcm94eTogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMDBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGh5cGVyaW9uJCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgdm90ZXJzID0gX3lpZWxkJHRoaXMkaHlwZXJpb24kLnZvdGVycztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHZvdGVycy5tYXAoZnVuY3Rpb24gKHZvdGVyLCBpbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHZvdGVyLCB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0OiB2b3Rlci53ZWlnaHQgLyBNYXRoLnBvdygxMCwgX3RoaXMuY29uc3RhbnRzLkNPUkVfUFJFQ0lTSU9OKSxcbiAgICAgICAgICAgICAgICByYW5rOiBpbmRleCArIDFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UHJveGllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRWb3RlcnMoX3gyKSB7XG4gIHJldHVybiBfZ2V0Vm90ZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRWb3RlcnMoKSB7XG4gIF9nZXRWb3RlcnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHByb2R1Y2VyKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3lpZWxkJHRoaXMkaHlwZXJpb24kMiwgdm90ZXJzLCB2b3RlV2VpZ2h0O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghdGhpcy5oeXBlcmlvbikge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbi5nZXRfdm90ZXJzKHtcbiAgICAgICAgICAgICAgcHJvZHVjZXI6IHByb2R1Y2VyLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGh5cGVyaW9uJDIgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHZvdGVycyA9IF95aWVsZCR0aGlzJGh5cGVyaW9uJDIudm90ZXJzO1xuICAgICAgICAgICAgdm90ZVdlaWdodCA9IHRoaXMuY2FsY3VsYXRlVm90ZVdlaWdodCgpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgdm90ZXJzLm1hcChmdW5jdGlvbiAodm90ZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCB2b3Rlciwge1xuICAgICAgICAgICAgICAgIHZvdGU6IF90aGlzMi53ZWlnaHRlZFZvdGVUb051bWJlcih2b3Rlci53ZWlnaHQsIHZvdGVXZWlnaHQpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRWb3RlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlVm90ZVdlaWdodCgpIHtcbiAgdmFyIGRlY2F5V2Vla3MgPSB0aGlzLmNvbnN0YW50cy5DSEFJTiA9PT0gJ3dheCcgPyAxMyA6IDUyO1xuICB2YXIgdGltZXN0YW1wX2Vwb2NoID0gOTQ2Njg0ODAwMDAwO1xuICB2YXIgZGF0ZXMgPSBEYXRlLm5vdygpIC8gMTAwMCAtIHRpbWVzdGFtcF9lcG9jaCAvIDEwMDA7XG4gIHZhciB3ZWlnaHQgPSBNYXRoLmZsb29yKGRhdGVzIC8gKDg2NDAwICogNykpIC8gZGVjYXlXZWVrcztcbiAgcmV0dXJuIE1hdGgucG93KDIsIHdlaWdodCk7XG59XG5mdW5jdGlvbiB3ZWlnaHRlZFZvdGVUb051bWJlcih3ZWlnaHRlZFZvdGUsIHZvdGVXZWlnaHQpIHtcbiAgaWYgKCF2b3RlV2VpZ2h0KSB7XG4gICAgdm90ZVdlaWdodCA9IHRoaXMuY2FsY3VsYXRlVm90ZVdlaWdodCgpO1xuICB9XG5cbiAgcmV0dXJuICt3ZWlnaHRlZFZvdGUgLyB2b3RlV2VpZ2h0IC8gTWF0aC5wb3coMTAsIHRoaXMuY29uc3RhbnRzLkNPUkVfUFJFQ0lTSU9OKTtcbn1cbmZ1bmN0aW9uIGdldFByb3h5RGF0YShfeDMpIHtcbiAgcmV0dXJuIF9nZXRQcm94eURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3h5RGF0YSgpIHtcbiAgX2dldFByb3h5RGF0YSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWNjb3VudE5hbWUpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkZ2V0MiwgcHJveHk7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEodGhpcy5jb25zdGFudHMuQUxPSEFfUFJPWFlfVVJMICE9PSAnJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuY29uc3RhbnRzLkFMT0hBX1BST1hZX1VSTCArIFwiL1wiICsgYWNjb3VudE5hbWUgKyBcIj9vdXRwdXQ9anNvblwiKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldDIgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHByb3h5ID0gX3lpZWxkJHRoaXMkZ2V0Mi5wcm94eTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHByb3h5KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQcm94eURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvZHVjZXJzTG9jYWwoKSB7XG4gIHJldHVybiBfZ2V0UHJvZHVjZXJzTG9jYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb2R1Y2Vyc0xvY2FsKCkge1xuICBfZ2V0UHJvZHVjZXJzTG9jYWwgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgIHZhciBtb3JlLCByb3dzLCByZXN1bHQsIGxvd2VyX2JvdW5kO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBtb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJvd3MgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBsb3dlcl9ib3VuZCA9IG51bGw7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ3Byb2R1Y2VycycsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBsb3dlcl9ib3VuZCxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDEsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIG1vcmUgPSByZXN1bHQubW9yZTtcbiAgICAgICAgICAgIHJvd3MgPSByb3dzLmNvbmNhdChyZXN1bHQucm93cyk7XG4gICAgICAgICAgICBsb3dlcl9ib3VuZCA9IG5ldyBCaWdOdW1iZXIoZW5jb2RlTmFtZShyb3dzW3Jvd3MubGVuZ3RoIC0gMV0ub3duZXIsIGZhbHNlKSkucGx1cygxKS50b1N0cmluZygpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGlmIChtb3JlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UHJvZHVjZXJzTG9jYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvZHVjZXJzKF94NCwgX3g1LCBfeDYpIHtcbiAgcmV0dXJuIF9nZXRQcm9kdWNlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb2R1Y2VycygpIHtcbiAgX2dldFByb2R1Y2VycyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYocGFnZU51bSwgcGVyUGFnZSwgbG9jYWwpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHBhZ2VOdW0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBwYWdlTnVtID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBlclBhZ2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBwZXJQYWdlID0gNTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2NhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGxvY2FsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKHRoaXMuY29uc3RhbnRzLkFQSV9VUkwgIT09ICcnICYmICFsb2NhbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybEJ1aWxkZXIodGhpcy5jb25zdGFudHMuQVBJX1VSTCwgJ3Byb2R1Y2VycycsIHtcbiAgICAgICAgICAgICAgcGFnZU51bTogcGFnZU51bSxcbiAgICAgICAgICAgICAgcGVyUGFnZTogcGVyUGFnZVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ2LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5nZXRQcm9kdWNlcnNMb2NhbCgpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQcm9kdWNlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhaW5UYWJsZSgpIHtcbiAgcmV0dXJuIF9nZXRDaGFpblRhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRDaGFpblRhYmxlKCkge1xuICBfZ2V0Q2hhaW5UYWJsZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdnbG9iYWwnLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QyID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Mi5yb3dzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRDaGFpblRhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBLeWNTdGF0dXM7XG5cbihmdW5jdGlvbiAoS3ljU3RhdHVzKSB7XG4gIEt5Y1N0YXR1c1tcIkZBSUxFRFwiXSA9IFwiRkFJTEVEXCI7XG4gIEt5Y1N0YXR1c1tcIlVOU1VCTUlUVEVEXCJdID0gXCJVTlNVQk1JVFRFRFwiO1xuICBLeWNTdGF0dXNbXCJQRU5ESU5HXCJdID0gXCJQRU5ESU5HXCI7XG4gIEt5Y1N0YXR1c1tcIlBBU1NFRFwiXSA9IFwiUEFTU0VEXCI7XG59KShLeWNTdGF0dXMgfHwgKEt5Y1N0YXR1cyA9IHt9KSk7XG5cbnZhciBjb3VudHJ5T3B0aW9ucyA9IFt7XG4gIGtleTogJ0FGJyxcbiAgdmFsdWU6ICdBRicsXG4gIGZsYWc6ICdhZicsXG4gIHRleHQ6ICdBZmdoYW5pc3Rhbidcbn0sIHtcbiAga2V5OiAnQVgnLFxuICB2YWx1ZTogJ0FYJyxcbiAgZmxhZzogJ2F4JyxcbiAgdGV4dDogJ0FsYW5kIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ0FMJyxcbiAgdmFsdWU6ICdBTCcsXG4gIGZsYWc6ICdhbCcsXG4gIHRleHQ6ICdBbGJhbmlhJ1xufSwge1xuICBrZXk6ICdEWicsXG4gIHZhbHVlOiAnRFonLFxuICBmbGFnOiAnZHonLFxuICB0ZXh0OiAnQWxnZXJpYSdcbn0sIHtcbiAga2V5OiAnQVMnLFxuICB2YWx1ZTogJ0FTJyxcbiAgZmxhZzogJ2FzJyxcbiAgdGV4dDogJ0FtZXJpY2FuIFNhbW9hJ1xufSwge1xuICBrZXk6ICdBRCcsXG4gIHZhbHVlOiAnQUQnLFxuICBmbGFnOiAnYWQnLFxuICB0ZXh0OiAnQW5kb3JyYSdcbn0sIHtcbiAga2V5OiAnQU8nLFxuICB2YWx1ZTogJ0FPJyxcbiAgZmxhZzogJ2FvJyxcbiAgdGV4dDogJ0FuZ29sYSdcbn0sIHtcbiAga2V5OiAnQUknLFxuICB2YWx1ZTogJ0FJJyxcbiAgZmxhZzogJ2FpJyxcbiAgdGV4dDogJ0FuZ3VpbGxhJ1xufSwge1xuICBrZXk6ICdBRycsXG4gIHZhbHVlOiAnQUcnLFxuICBmbGFnOiAnYWcnLFxuICB0ZXh0OiAnQW50aWd1YSdcbn0sIHtcbiAga2V5OiAnQVInLFxuICB2YWx1ZTogJ0FSJyxcbiAgZmxhZzogJ2FyJyxcbiAgdGV4dDogJ0FyZ2VudGluYSdcbn0sIHtcbiAga2V5OiAnQU0nLFxuICB2YWx1ZTogJ0FNJyxcbiAgZmxhZzogJ2FtJyxcbiAgdGV4dDogJ0FybWVuaWEnXG59LCB7XG4gIGtleTogJ0FXJyxcbiAgdmFsdWU6ICdBVycsXG4gIGZsYWc6ICdhdycsXG4gIHRleHQ6ICdBcnViYSdcbn0sIHtcbiAga2V5OiAnQVUnLFxuICB2YWx1ZTogJ0FVJyxcbiAgZmxhZzogJ2F1JyxcbiAgdGV4dDogJ0F1c3RyYWxpYSdcbn0sIHtcbiAga2V5OiAnQVQnLFxuICB2YWx1ZTogJ0FUJyxcbiAgZmxhZzogJ2F0JyxcbiAgdGV4dDogJ0F1c3RyaWEnXG59LCB7XG4gIGtleTogJ0FaJyxcbiAgdmFsdWU6ICdBWicsXG4gIGZsYWc6ICdheicsXG4gIHRleHQ6ICdBemVyYmFpamFuJ1xufSwge1xuICBrZXk6ICdCUycsXG4gIHZhbHVlOiAnQlMnLFxuICBmbGFnOiAnYnMnLFxuICB0ZXh0OiAnQmFoYW1hcydcbn0sIHtcbiAga2V5OiAnQkgnLFxuICB2YWx1ZTogJ0JIJyxcbiAgZmxhZzogJ2JoJyxcbiAgdGV4dDogJ0JhaHJhaW4nXG59LCB7XG4gIGtleTogJ0JEJyxcbiAgdmFsdWU6ICdCRCcsXG4gIGZsYWc6ICdiZCcsXG4gIHRleHQ6ICdCYW5nbGFkZXNoJ1xufSwge1xuICBrZXk6ICdCQicsXG4gIHZhbHVlOiAnQkInLFxuICBmbGFnOiAnYmInLFxuICB0ZXh0OiAnQmFyYmFkb3MnXG59LCB7XG4gIGtleTogJ0JZJyxcbiAgdmFsdWU6ICdCWScsXG4gIGZsYWc6ICdieScsXG4gIHRleHQ6ICdCZWxhcnVzJ1xufSwge1xuICBrZXk6ICdCRScsXG4gIHZhbHVlOiAnQkUnLFxuICBmbGFnOiAnYmUnLFxuICB0ZXh0OiAnQmVsZ2l1bSdcbn0sIHtcbiAga2V5OiAnQlonLFxuICB2YWx1ZTogJ0JaJyxcbiAgZmxhZzogJ2J6JyxcbiAgdGV4dDogJ0JlbGl6ZSdcbn0sIHtcbiAga2V5OiAnQkonLFxuICB2YWx1ZTogJ0JKJyxcbiAgZmxhZzogJ2JqJyxcbiAgdGV4dDogJ0JlbmluJ1xufSwge1xuICBrZXk6ICdCTScsXG4gIHZhbHVlOiAnQk0nLFxuICBmbGFnOiAnYm0nLFxuICB0ZXh0OiAnQmVybXVkYSdcbn0sIHtcbiAga2V5OiAnQlQnLFxuICB2YWx1ZTogJ0JUJyxcbiAgZmxhZzogJ2J0JyxcbiAgdGV4dDogJ0JodXRhbidcbn0sIHtcbiAga2V5OiAnQk8nLFxuICB2YWx1ZTogJ0JPJyxcbiAgZmxhZzogJ2JvJyxcbiAgdGV4dDogJ0JvbGl2aWEnXG59LCB7XG4gIGtleTogJ0JBJyxcbiAgdmFsdWU6ICdCQScsXG4gIGZsYWc6ICdiYScsXG4gIHRleHQ6ICdCb3NuaWEnXG59LCB7XG4gIGtleTogJ0JXJyxcbiAgdmFsdWU6ICdCVycsXG4gIGZsYWc6ICdidycsXG4gIHRleHQ6ICdCb3Rzd2FuYSdcbn0sIHtcbiAga2V5OiAnQlYnLFxuICB2YWx1ZTogJ0JWJyxcbiAgZmxhZzogJ2J2JyxcbiAgdGV4dDogJ0JvdXZldCBJc2xhbmQnXG59LCB7XG4gIGtleTogJ0JSJyxcbiAgdmFsdWU6ICdCUicsXG4gIGZsYWc6ICdicicsXG4gIHRleHQ6ICdCcmF6aWwnXG59LCB7XG4gIGtleTogJ1ZHJyxcbiAgdmFsdWU6ICdWRycsXG4gIGZsYWc6ICd2ZycsXG4gIHRleHQ6ICdCcml0aXNoIFZpcmdpbiBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdCTicsXG4gIHZhbHVlOiAnQk4nLFxuICBmbGFnOiAnYm4nLFxuICB0ZXh0OiAnQnJ1bmVpJ1xufSwge1xuICBrZXk6ICdCRycsXG4gIHZhbHVlOiAnQkcnLFxuICBmbGFnOiAnYmcnLFxuICB0ZXh0OiAnQnVsZ2FyaWEnXG59LCB7XG4gIGtleTogJ0JGJyxcbiAgdmFsdWU6ICdCRicsXG4gIGZsYWc6ICdiZicsXG4gIHRleHQ6ICdCdXJraW5hIEZhc28nXG59LCB7XG4gIGtleTogJ0JJJyxcbiAgdmFsdWU6ICdCSScsXG4gIGZsYWc6ICdiaScsXG4gIHRleHQ6ICdCdXJ1bmRpJ1xufSwge1xuICBrZXk6ICdUQycsXG4gIHZhbHVlOiAnVEMnLFxuICBmbGFnOiAndGMnLFxuICB0ZXh0OiAnQ2FpY29zIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ0tIJyxcbiAgdmFsdWU6ICdLSCcsXG4gIGZsYWc6ICdraCcsXG4gIHRleHQ6ICdDYW1ib2RpYSdcbn0sIHtcbiAga2V5OiAnQ00nLFxuICB2YWx1ZTogJ0NNJyxcbiAgZmxhZzogJ2NtJyxcbiAgdGV4dDogJ0NhbWVyb29uJ1xufSwge1xuICBrZXk6ICdDQScsXG4gIHZhbHVlOiAnQ0EnLFxuICBmbGFnOiAnY2EnLFxuICB0ZXh0OiAnQ2FuYWRhJ1xufSwge1xuICBrZXk6ICdDVicsXG4gIHZhbHVlOiAnQ1YnLFxuICBmbGFnOiAnY3YnLFxuICB0ZXh0OiAnQ2FwZSBWZXJkZSdcbn0sIHtcbiAga2V5OiAnS1knLFxuICB2YWx1ZTogJ0tZJyxcbiAgZmxhZzogJ2t5JyxcbiAgdGV4dDogJ0NheW1hbiBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdDRicsXG4gIHZhbHVlOiAnQ0YnLFxuICBmbGFnOiAnY2YnLFxuICB0ZXh0OiAnQ2VudHJhbCBBZnJpY2FuIFJlcHVibGljJ1xufSwge1xuICBrZXk6ICdURCcsXG4gIHZhbHVlOiAnVEQnLFxuICBmbGFnOiAndGQnLFxuICB0ZXh0OiAnQ2hhZCdcbn0sIHtcbiAga2V5OiAnQ0wnLFxuICB2YWx1ZTogJ0NMJyxcbiAgZmxhZzogJ2NsJyxcbiAgdGV4dDogJ0NoaWxlJ1xufSwge1xuICBrZXk6ICdDTicsXG4gIHZhbHVlOiAnQ04nLFxuICBmbGFnOiAnY24nLFxuICB0ZXh0OiAnQ2hpbmEnXG59LCB7XG4gIGtleTogJ0NYJyxcbiAgdmFsdWU6ICdDWCcsXG4gIGZsYWc6ICdjeCcsXG4gIHRleHQ6ICdDaHJpc3RtYXMgSXNsYW5kJ1xufSwge1xuICBrZXk6ICdDQycsXG4gIHZhbHVlOiAnQ0MnLFxuICBmbGFnOiAnY2MnLFxuICB0ZXh0OiAnQ29jb3MgSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnQ08nLFxuICB2YWx1ZTogJ0NPJyxcbiAgZmxhZzogJ2NvJyxcbiAgdGV4dDogJ0NvbG9tYmlhJ1xufSwge1xuICBrZXk6ICdLTScsXG4gIHZhbHVlOiAnS00nLFxuICBmbGFnOiAna20nLFxuICB0ZXh0OiAnQ29tb3Jvcydcbn0sIHtcbiAga2V5OiAnQ0cnLFxuICB2YWx1ZTogJ0NHJyxcbiAgZmxhZzogJ2NnJyxcbiAgdGV4dDogJ0NvbmdvIEJyYXp6YXZpbGxlJ1xufSwge1xuICBrZXk6ICdDRCcsXG4gIHZhbHVlOiAnQ0QnLFxuICBmbGFnOiAnY2QnLFxuICB0ZXh0OiAnQ29uZ28nXG59LCB7XG4gIGtleTogJ0NLJyxcbiAgdmFsdWU6ICdDSycsXG4gIGZsYWc6ICdjaycsXG4gIHRleHQ6ICdDb29rIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ0NSJyxcbiAgdmFsdWU6ICdDUicsXG4gIGZsYWc6ICdjcicsXG4gIHRleHQ6ICdDb3N0YSBSaWNhJ1xufSwge1xuICBrZXk6ICdDSScsXG4gIHZhbHVlOiAnQ0knLFxuICBmbGFnOiAnY2knLFxuICB0ZXh0OiAnQ290ZSBEaXZvaXJlJ1xufSwge1xuICBrZXk6ICdIUicsXG4gIHZhbHVlOiAnSFInLFxuICBmbGFnOiAnaHInLFxuICB0ZXh0OiAnQ3JvYXRpYSdcbn0sIHtcbiAga2V5OiAnQ1UnLFxuICB2YWx1ZTogJ0NVJyxcbiAgZmxhZzogJ2N1JyxcbiAgdGV4dDogJ0N1YmEnXG59LCB7XG4gIGtleTogJ0NZJyxcbiAgdmFsdWU6ICdDWScsXG4gIGZsYWc6ICdjeScsXG4gIHRleHQ6ICdDeXBydXMnXG59LCB7XG4gIGtleTogJ0NaJyxcbiAgdmFsdWU6ICdDWicsXG4gIGZsYWc6ICdjeicsXG4gIHRleHQ6ICdDemVjaCBSZXB1YmxpYydcbn0sIHtcbiAga2V5OiAnREsnLFxuICB2YWx1ZTogJ0RLJyxcbiAgZmxhZzogJ2RrJyxcbiAgdGV4dDogJ0Rlbm1hcmsnXG59LCB7XG4gIGtleTogJ0RKJyxcbiAgdmFsdWU6ICdESicsXG4gIGZsYWc6ICdkaicsXG4gIHRleHQ6ICdEamlib3V0aSdcbn0sIHtcbiAga2V5OiAnRE0nLFxuICB2YWx1ZTogJ0RNJyxcbiAgZmxhZzogJ2RtJyxcbiAgdGV4dDogJ0RvbWluaWNhJ1xufSwge1xuICBrZXk6ICdETycsXG4gIHZhbHVlOiAnRE8nLFxuICBmbGFnOiAnZG8nLFxuICB0ZXh0OiAnRG9taW5pY2FuIFJlcHVibGljJ1xufSwge1xuICBrZXk6ICdFQycsXG4gIHZhbHVlOiAnRUMnLFxuICBmbGFnOiAnZWMnLFxuICB0ZXh0OiAnRWN1YWRvcidcbn0sIHtcbiAga2V5OiAnRUcnLFxuICB2YWx1ZTogJ0VHJyxcbiAgZmxhZzogJ2VnJyxcbiAgdGV4dDogJ0VneXB0J1xufSwge1xuICBrZXk6ICdTVicsXG4gIHZhbHVlOiAnU1YnLFxuICBmbGFnOiAnc3YnLFxuICB0ZXh0OiAnRWwgU2FsdmFkb3InXG59LCB7XG4gIGtleTogJ0dCJyxcbiAgdmFsdWU6ICdHQicsXG4gIGZsYWc6ICdnYicsXG4gIHRleHQ6ICdFbmdsYW5kJ1xufSwge1xuICBrZXk6ICdHUScsXG4gIHZhbHVlOiAnR1EnLFxuICBmbGFnOiAnZ3EnLFxuICB0ZXh0OiAnRXF1YXRvcmlhbCBHdWluZWEnXG59LCB7XG4gIGtleTogJ0VSJyxcbiAgdmFsdWU6ICdFUicsXG4gIGZsYWc6ICdlcicsXG4gIHRleHQ6ICdFcml0cmVhJ1xufSwge1xuICBrZXk6ICdFRScsXG4gIHZhbHVlOiAnRUUnLFxuICBmbGFnOiAnZWUnLFxuICB0ZXh0OiAnRXN0b25pYSdcbn0sIHtcbiAga2V5OiAnRVQnLFxuICB2YWx1ZTogJ0VUJyxcbiAgZmxhZzogJ2V0JyxcbiAgdGV4dDogJ0V0aGlvcGlhJ1xufSwge1xuICBrZXk6ICdFVScsXG4gIHZhbHVlOiAnRVUnLFxuICBmbGFnOiAnZXUnLFxuICB0ZXh0OiAnRXVyb3BlYW4gVW5pb24nXG59LCB7XG4gIGtleTogJ0ZLJyxcbiAgdmFsdWU6ICdGSycsXG4gIGZsYWc6ICdmaycsXG4gIHRleHQ6ICdGYWxrbGFuZCBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdGTycsXG4gIHZhbHVlOiAnRk8nLFxuICBmbGFnOiAnZm8nLFxuICB0ZXh0OiAnRmFyb2UgSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnRkonLFxuICB2YWx1ZTogJ0ZKJyxcbiAgZmxhZzogJ2ZqJyxcbiAgdGV4dDogJ0ZpamknXG59LCB7XG4gIGtleTogJ0ZJJyxcbiAgdmFsdWU6ICdGSScsXG4gIGZsYWc6ICdmaScsXG4gIHRleHQ6ICdGaW5sYW5kJ1xufSwge1xuICBrZXk6ICdGUicsXG4gIHZhbHVlOiAnRlInLFxuICBmbGFnOiAnZnInLFxuICB0ZXh0OiAnRnJhbmNlJ1xufSwge1xuICBrZXk6ICdHRicsXG4gIHZhbHVlOiAnR0YnLFxuICBmbGFnOiAnZ2YnLFxuICB0ZXh0OiAnRnJlbmNoIEd1aWFuYSdcbn0sIHtcbiAga2V5OiAnUEYnLFxuICB2YWx1ZTogJ1BGJyxcbiAgZmxhZzogJ3BmJyxcbiAgdGV4dDogJ0ZyZW5jaCBQb2x5bmVzaWEnXG59LCB7XG4gIGtleTogJ1RGJyxcbiAgdmFsdWU6ICdURicsXG4gIGZsYWc6ICd0ZicsXG4gIHRleHQ6ICdGcmVuY2ggVGVycml0b3JpZXMnXG59LCB7XG4gIGtleTogJ0dBJyxcbiAgdmFsdWU6ICdHQScsXG4gIGZsYWc6ICdnYScsXG4gIHRleHQ6ICdHYWJvbidcbn0sIHtcbiAga2V5OiAnR00nLFxuICB2YWx1ZTogJ0dNJyxcbiAgZmxhZzogJ2dtJyxcbiAgdGV4dDogJ0dhbWJpYSdcbn0sIHtcbiAga2V5OiAnR0UnLFxuICB2YWx1ZTogJ0dFJyxcbiAgZmxhZzogJ2dlJyxcbiAgdGV4dDogJ0dlb3JnaWEnXG59LCB7XG4gIGtleTogJ0RFJyxcbiAgdmFsdWU6ICdERScsXG4gIGZsYWc6ICdkZScsXG4gIHRleHQ6ICdHZXJtYW55J1xufSwge1xuICBrZXk6ICdHSCcsXG4gIHZhbHVlOiAnR0gnLFxuICBmbGFnOiAnZ2gnLFxuICB0ZXh0OiAnR2hhbmEnXG59LCB7XG4gIGtleTogJ0dJJyxcbiAgdmFsdWU6ICdHSScsXG4gIGZsYWc6ICdnaScsXG4gIHRleHQ6ICdHaWJyYWx0YXInXG59LCB7XG4gIGtleTogJ0dSJyxcbiAgdmFsdWU6ICdHUicsXG4gIGZsYWc6ICdncicsXG4gIHRleHQ6ICdHcmVlY2UnXG59LCB7XG4gIGtleTogJ0dMJyxcbiAgdmFsdWU6ICdHTCcsXG4gIGZsYWc6ICdnbCcsXG4gIHRleHQ6ICdHcmVlbmxhbmQnXG59LCB7XG4gIGtleTogJ0dEJyxcbiAgdmFsdWU6ICdHRCcsXG4gIGZsYWc6ICdnZCcsXG4gIHRleHQ6ICdHcmVuYWRhJ1xufSwge1xuICBrZXk6ICdHUCcsXG4gIHZhbHVlOiAnR1AnLFxuICBmbGFnOiAnZ3AnLFxuICB0ZXh0OiAnR3VhZGVsb3VwZSdcbn0sIHtcbiAga2V5OiAnR1UnLFxuICB2YWx1ZTogJ0dVJyxcbiAgZmxhZzogJ2d1JyxcbiAgdGV4dDogJ0d1YW0nXG59LCB7XG4gIGtleTogJ0dUJyxcbiAgdmFsdWU6ICdHVCcsXG4gIGZsYWc6ICdndCcsXG4gIHRleHQ6ICdHdWF0ZW1hbGEnXG59LCB7XG4gIGtleTogJ0dXJyxcbiAgdmFsdWU6ICdHVycsXG4gIGZsYWc6ICdndycsXG4gIHRleHQ6ICdHdWluZWEtQmlzc2F1J1xufSwge1xuICBrZXk6ICdHTicsXG4gIHZhbHVlOiAnR04nLFxuICBmbGFnOiAnZ24nLFxuICB0ZXh0OiAnR3VpbmVhJ1xufSwge1xuICBrZXk6ICdHWScsXG4gIHZhbHVlOiAnR1knLFxuICBmbGFnOiAnZ3knLFxuICB0ZXh0OiAnR3V5YW5hJ1xufSwge1xuICBrZXk6ICdIVCcsXG4gIHZhbHVlOiAnSFQnLFxuICBmbGFnOiAnaHQnLFxuICB0ZXh0OiAnSGFpdGknXG59LCB7XG4gIGtleTogJ0hNJyxcbiAgdmFsdWU6ICdITScsXG4gIGZsYWc6ICdobScsXG4gIHRleHQ6ICdIZWFyZCBJc2xhbmQnXG59LCB7XG4gIGtleTogJ0hOJyxcbiAgdmFsdWU6ICdITicsXG4gIGZsYWc6ICdobicsXG4gIHRleHQ6ICdIb25kdXJhcydcbn0sIHtcbiAga2V5OiAnSEsnLFxuICB2YWx1ZTogJ0hLJyxcbiAgZmxhZzogJ2hrJyxcbiAgdGV4dDogJ0hvbmcgS29uZydcbn0sIHtcbiAga2V5OiAnSFUnLFxuICB2YWx1ZTogJ0hVJyxcbiAgZmxhZzogJ2h1JyxcbiAgdGV4dDogJ0h1bmdhcnknXG59LCB7XG4gIGtleTogJ0lTJyxcbiAgdmFsdWU6ICdJUycsXG4gIGZsYWc6ICdpcycsXG4gIHRleHQ6ICdJY2VsYW5kJ1xufSwge1xuICBrZXk6ICdJTicsXG4gIHZhbHVlOiAnSU4nLFxuICBmbGFnOiAnaW4nLFxuICB0ZXh0OiAnSW5kaWEnXG59LCB7XG4gIGtleTogJ0lPJyxcbiAgdmFsdWU6ICdJTycsXG4gIGZsYWc6ICdpbycsXG4gIHRleHQ6ICdJbmRpYW4gT2NlYW4gVGVycml0b3J5J1xufSwge1xuICBrZXk6ICdJRCcsXG4gIHZhbHVlOiAnSUQnLFxuICBmbGFnOiAnaWQnLFxuICB0ZXh0OiAnSW5kb25lc2lhJ1xufSwge1xuICBrZXk6ICdJUicsXG4gIHZhbHVlOiAnSVInLFxuICBmbGFnOiAnaXInLFxuICB0ZXh0OiAnSXJhbidcbn0sIHtcbiAga2V5OiAnSVEnLFxuICB2YWx1ZTogJ0lRJyxcbiAgZmxhZzogJ2lxJyxcbiAgdGV4dDogJ0lyYXEnXG59LCB7XG4gIGtleTogJ0lFJyxcbiAgdmFsdWU6ICdJRScsXG4gIGZsYWc6ICdpZScsXG4gIHRleHQ6ICdJcmVsYW5kJ1xufSwge1xuICBrZXk6ICdJTCcsXG4gIHZhbHVlOiAnSUwnLFxuICBmbGFnOiAnaWwnLFxuICB0ZXh0OiAnSXNyYWVsJ1xufSwge1xuICBrZXk6ICdJVCcsXG4gIHZhbHVlOiAnSVQnLFxuICBmbGFnOiAnaXQnLFxuICB0ZXh0OiAnSXRhbHknXG59LCB7XG4gIGtleTogJ0pNJyxcbiAgdmFsdWU6ICdKTScsXG4gIGZsYWc6ICdqbScsXG4gIHRleHQ6ICdKYW1haWNhJ1xufSwge1xuICBrZXk6ICdKUCcsXG4gIHZhbHVlOiAnSlAnLFxuICBmbGFnOiAnanAnLFxuICB0ZXh0OiAnSmFwYW4nXG59LCB7XG4gIGtleTogJ0pPJyxcbiAgdmFsdWU6ICdKTycsXG4gIGZsYWc6ICdqbycsXG4gIHRleHQ6ICdKb3JkYW4nXG59LCB7XG4gIGtleTogJ0taJyxcbiAgdmFsdWU6ICdLWicsXG4gIGZsYWc6ICdreicsXG4gIHRleHQ6ICdLYXpha2hzdGFuJ1xufSwge1xuICBrZXk6ICdLRScsXG4gIHZhbHVlOiAnS0UnLFxuICBmbGFnOiAna2UnLFxuICB0ZXh0OiAnS2VueWEnXG59LCB7XG4gIGtleTogJ0tJJyxcbiAgdmFsdWU6ICdLSScsXG4gIGZsYWc6ICdraScsXG4gIHRleHQ6ICdLaXJpYmF0aSdcbn0sIHtcbiAga2V5OiAnS1cnLFxuICB2YWx1ZTogJ0tXJyxcbiAgZmxhZzogJ2t3JyxcbiAgdGV4dDogJ0t1d2FpdCdcbn0sIHtcbiAga2V5OiAnS0cnLFxuICB2YWx1ZTogJ0tHJyxcbiAgZmxhZzogJ2tnJyxcbiAgdGV4dDogJ0t5cmd5enN0YW4nXG59LCB7XG4gIGtleTogJ0xBJyxcbiAgdmFsdWU6ICdMQScsXG4gIGZsYWc6ICdsYScsXG4gIHRleHQ6ICdMYW9zJ1xufSwge1xuICBrZXk6ICdMVicsXG4gIHZhbHVlOiAnTFYnLFxuICBmbGFnOiAnbHYnLFxuICB0ZXh0OiAnTGF0dmlhJ1xufSwge1xuICBrZXk6ICdMQicsXG4gIHZhbHVlOiAnTEInLFxuICBmbGFnOiAnbGInLFxuICB0ZXh0OiAnTGViYW5vbidcbn0sIHtcbiAga2V5OiAnTFMnLFxuICB2YWx1ZTogJ0xTJyxcbiAgZmxhZzogJ2xzJyxcbiAgdGV4dDogJ0xlc290aG8nXG59LCB7XG4gIGtleTogJ0xSJyxcbiAgdmFsdWU6ICdMUicsXG4gIGZsYWc6ICdscicsXG4gIHRleHQ6ICdMaWJlcmlhJ1xufSwge1xuICBrZXk6ICdMWScsXG4gIHZhbHVlOiAnTFknLFxuICBmbGFnOiAnbHknLFxuICB0ZXh0OiAnTGlieWEnXG59LCB7XG4gIGtleTogJ0xJJyxcbiAgdmFsdWU6ICdMSScsXG4gIGZsYWc6ICdsaScsXG4gIHRleHQ6ICdMaWVjaHRlbnN0ZWluJ1xufSwge1xuICBrZXk6ICdMVCcsXG4gIHZhbHVlOiAnTFQnLFxuICBmbGFnOiAnbHQnLFxuICB0ZXh0OiAnTGl0aHVhbmlhJ1xufSwge1xuICBrZXk6ICdMVScsXG4gIHZhbHVlOiAnTFUnLFxuICBmbGFnOiAnbHUnLFxuICB0ZXh0OiAnTHV4ZW1ib3VyZydcbn0sIHtcbiAga2V5OiAnTU8nLFxuICB2YWx1ZTogJ01PJyxcbiAgZmxhZzogJ21vJyxcbiAgdGV4dDogJ01hY2F1J1xufSwge1xuICBrZXk6ICdNSycsXG4gIHZhbHVlOiAnTUsnLFxuICBmbGFnOiAnbWsnLFxuICB0ZXh0OiAnTWFjZWRvbmlhJ1xufSwge1xuICBrZXk6ICdNRycsXG4gIHZhbHVlOiAnTUcnLFxuICBmbGFnOiAnbWcnLFxuICB0ZXh0OiAnTWFkYWdhc2Nhcidcbn0sIHtcbiAga2V5OiAnTVcnLFxuICB2YWx1ZTogJ01XJyxcbiAgZmxhZzogJ213JyxcbiAgdGV4dDogJ01hbGF3aSdcbn0sIHtcbiAga2V5OiAnTVknLFxuICB2YWx1ZTogJ01ZJyxcbiAgZmxhZzogJ215JyxcbiAgdGV4dDogJ01hbGF5c2lhJ1xufSwge1xuICBrZXk6ICdNVicsXG4gIHZhbHVlOiAnTVYnLFxuICBmbGFnOiAnbXYnLFxuICB0ZXh0OiAnTWFsZGl2ZXMnXG59LCB7XG4gIGtleTogJ01MJyxcbiAgdmFsdWU6ICdNTCcsXG4gIGZsYWc6ICdtbCcsXG4gIHRleHQ6ICdNYWxpJ1xufSwge1xuICBrZXk6ICdNVCcsXG4gIHZhbHVlOiAnTVQnLFxuICBmbGFnOiAnbXQnLFxuICB0ZXh0OiAnTWFsdGEnXG59LCB7XG4gIGtleTogJ01IJyxcbiAgdmFsdWU6ICdNSCcsXG4gIGZsYWc6ICdtaCcsXG4gIHRleHQ6ICdNYXJzaGFsbCBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdNUScsXG4gIHZhbHVlOiAnTVEnLFxuICBmbGFnOiAnbXEnLFxuICB0ZXh0OiAnTWFydGluaXF1ZSdcbn0sIHtcbiAga2V5OiAnTVInLFxuICB2YWx1ZTogJ01SJyxcbiAgZmxhZzogJ21yJyxcbiAgdGV4dDogJ01hdXJpdGFuaWEnXG59LCB7XG4gIGtleTogJ01VJyxcbiAgdmFsdWU6ICdNVScsXG4gIGZsYWc6ICdtdScsXG4gIHRleHQ6ICdNYXVyaXRpdXMnXG59LCB7XG4gIGtleTogJ1lUJyxcbiAgdmFsdWU6ICdZVCcsXG4gIGZsYWc6ICd5dCcsXG4gIHRleHQ6ICdNYXlvdHRlJ1xufSwge1xuICBrZXk6ICdNWCcsXG4gIHZhbHVlOiAnTVgnLFxuICBmbGFnOiAnbXgnLFxuICB0ZXh0OiAnTWV4aWNvJ1xufSwge1xuICBrZXk6ICdGTScsXG4gIHZhbHVlOiAnRk0nLFxuICBmbGFnOiAnZm0nLFxuICB0ZXh0OiAnTWljcm9uZXNpYSdcbn0sIHtcbiAga2V5OiAnTUQnLFxuICB2YWx1ZTogJ01EJyxcbiAgZmxhZzogJ21kJyxcbiAgdGV4dDogJ01vbGRvdmEnXG59LCB7XG4gIGtleTogJ01DJyxcbiAgdmFsdWU6ICdNQycsXG4gIGZsYWc6ICdtYycsXG4gIHRleHQ6ICdNb25hY28nXG59LCB7XG4gIGtleTogJ01OJyxcbiAgdmFsdWU6ICdNTicsXG4gIGZsYWc6ICdtbicsXG4gIHRleHQ6ICdNb25nb2xpYSdcbn0sIHtcbiAga2V5OiAnTUUnLFxuICB2YWx1ZTogJ01FJyxcbiAgZmxhZzogJ21lJyxcbiAgdGV4dDogJ01vbnRlbmVncm8nXG59LCB7XG4gIGtleTogJ01TJyxcbiAgdmFsdWU6ICdNUycsXG4gIGZsYWc6ICdtcycsXG4gIHRleHQ6ICdNb250c2VycmF0J1xufSwge1xuICBrZXk6ICdNQScsXG4gIHZhbHVlOiAnTUEnLFxuICBmbGFnOiAnbWEnLFxuICB0ZXh0OiAnTW9yb2Njbydcbn0sIHtcbiAga2V5OiAnTVonLFxuICB2YWx1ZTogJ01aJyxcbiAgZmxhZzogJ216JyxcbiAgdGV4dDogJ01vemFtYmlxdWUnXG59LCB7XG4gIGtleTogJ05BJyxcbiAgdmFsdWU6ICdOQScsXG4gIGZsYWc6ICduYScsXG4gIHRleHQ6ICdOYW1pYmlhJ1xufSwge1xuICBrZXk6ICdOUicsXG4gIHZhbHVlOiAnTlInLFxuICBmbGFnOiAnbnInLFxuICB0ZXh0OiAnTmF1cnUnXG59LCB7XG4gIGtleTogJ05QJyxcbiAgdmFsdWU6ICdOUCcsXG4gIGZsYWc6ICducCcsXG4gIHRleHQ6ICdOZXBhbCdcbn0sIHtcbiAga2V5OiAnQU4nLFxuICB2YWx1ZTogJ0FOJyxcbiAgZmxhZzogJ2FuJyxcbiAgdGV4dDogJ05ldGhlcmxhbmRzIEFudGlsbGVzJ1xufSwge1xuICBrZXk6ICdOTCcsXG4gIHZhbHVlOiAnTkwnLFxuICBmbGFnOiAnbmwnLFxuICB0ZXh0OiAnTmV0aGVybGFuZHMnXG59LCB7XG4gIGtleTogJ05DJyxcbiAgdmFsdWU6ICdOQycsXG4gIGZsYWc6ICduYycsXG4gIHRleHQ6ICdOZXcgQ2FsZWRvbmlhJ1xufSwge1xuICBrZXk6ICdQRycsXG4gIHZhbHVlOiAnUEcnLFxuICBmbGFnOiAncGcnLFxuICB0ZXh0OiAnTmV3IEd1aW5lYSdcbn0sIHtcbiAga2V5OiAnTlonLFxuICB2YWx1ZTogJ05aJyxcbiAgZmxhZzogJ256JyxcbiAgdGV4dDogJ05ldyBaZWFsYW5kJ1xufSwge1xuICBrZXk6ICdOSScsXG4gIHZhbHVlOiAnTkknLFxuICBmbGFnOiAnbmknLFxuICB0ZXh0OiAnTmljYXJhZ3VhJ1xufSwge1xuICBrZXk6ICdORScsXG4gIHZhbHVlOiAnTkUnLFxuICBmbGFnOiAnbmUnLFxuICB0ZXh0OiAnTmlnZXInXG59LCB7XG4gIGtleTogJ05HJyxcbiAgdmFsdWU6ICdORycsXG4gIGZsYWc6ICduZycsXG4gIHRleHQ6ICdOaWdlcmlhJ1xufSwge1xuICBrZXk6ICdOVScsXG4gIHZhbHVlOiAnTlUnLFxuICBmbGFnOiAnbnUnLFxuICB0ZXh0OiAnTml1ZSdcbn0sIHtcbiAga2V5OiAnTkYnLFxuICB2YWx1ZTogJ05GJyxcbiAgZmxhZzogJ25mJyxcbiAgdGV4dDogJ05vcmZvbGsgSXNsYW5kJ1xufSwge1xuICBrZXk6ICdLUCcsXG4gIHZhbHVlOiAnS1AnLFxuICBmbGFnOiAna3AnLFxuICB0ZXh0OiAnTm9ydGggS29yZWEnXG59LCB7XG4gIGtleTogJ01QJyxcbiAgdmFsdWU6ICdNUCcsXG4gIGZsYWc6ICdtcCcsXG4gIHRleHQ6ICdOb3J0aGVybiBNYXJpYW5hIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ05PJyxcbiAgdmFsdWU6ICdOTycsXG4gIGZsYWc6ICdubycsXG4gIHRleHQ6ICdOb3J3YXknXG59LCB7XG4gIGtleTogJ09NJyxcbiAgdmFsdWU6ICdPTScsXG4gIGZsYWc6ICdvbScsXG4gIHRleHQ6ICdPbWFuJ1xufSwge1xuICBrZXk6ICdQSycsXG4gIHZhbHVlOiAnUEsnLFxuICBmbGFnOiAncGsnLFxuICB0ZXh0OiAnUGFraXN0YW4nXG59LCB7XG4gIGtleTogJ1BXJyxcbiAgdmFsdWU6ICdQVycsXG4gIGZsYWc6ICdwdycsXG4gIHRleHQ6ICdQYWxhdSdcbn0sIHtcbiAga2V5OiAnUFMnLFxuICB2YWx1ZTogJ1BTJyxcbiAgZmxhZzogJ3BzJyxcbiAgdGV4dDogJ1BhbGVzdGluZSdcbn0sIHtcbiAga2V5OiAnUEEnLFxuICB2YWx1ZTogJ1BBJyxcbiAgZmxhZzogJ3BhJyxcbiAgdGV4dDogJ1BhbmFtYSdcbn0sIHtcbiAga2V5OiAnUFknLFxuICB2YWx1ZTogJ1BZJyxcbiAgZmxhZzogJ3B5JyxcbiAgdGV4dDogJ1BhcmFndWF5J1xufSwge1xuICBrZXk6ICdQRScsXG4gIHZhbHVlOiAnUEUnLFxuICBmbGFnOiAncGUnLFxuICB0ZXh0OiAnUGVydSdcbn0sIHtcbiAga2V5OiAnUEgnLFxuICB2YWx1ZTogJ1BIJyxcbiAgZmxhZzogJ3BoJyxcbiAgdGV4dDogJ1BoaWxpcHBpbmVzJ1xufSwge1xuICBrZXk6ICdQTicsXG4gIHZhbHVlOiAnUE4nLFxuICBmbGFnOiAncG4nLFxuICB0ZXh0OiAnUGl0Y2Fpcm4gSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnUEwnLFxuICB2YWx1ZTogJ1BMJyxcbiAgZmxhZzogJ3BsJyxcbiAgdGV4dDogJ1BvbGFuZCdcbn0sIHtcbiAga2V5OiAnUFQnLFxuICB2YWx1ZTogJ1BUJyxcbiAgZmxhZzogJ3B0JyxcbiAgdGV4dDogJ1BvcnR1Z2FsJ1xufSwge1xuICBrZXk6ICdQUicsXG4gIHZhbHVlOiAnUFInLFxuICBmbGFnOiAncHInLFxuICB0ZXh0OiAnUHVlcnRvIFJpY28nXG59LCB7XG4gIGtleTogJ1FBJyxcbiAgdmFsdWU6ICdRQScsXG4gIGZsYWc6ICdxYScsXG4gIHRleHQ6ICdRYXRhcidcbn0sIHtcbiAga2V5OiAnUkUnLFxuICB2YWx1ZTogJ1JFJyxcbiAgZmxhZzogJ3JlJyxcbiAgdGV4dDogJ1JldW5pb24nXG59LCB7XG4gIGtleTogJ1JPJyxcbiAgdmFsdWU6ICdSTycsXG4gIGZsYWc6ICdybycsXG4gIHRleHQ6ICdSb21hbmlhJ1xufSwge1xuICBrZXk6ICdSVScsXG4gIHZhbHVlOiAnUlUnLFxuICBmbGFnOiAncnUnLFxuICB0ZXh0OiAnUnVzc2lhJ1xufSwge1xuICBrZXk6ICdSVycsXG4gIHZhbHVlOiAnUlcnLFxuICBmbGFnOiAncncnLFxuICB0ZXh0OiAnUndhbmRhJ1xufSwge1xuICBrZXk6ICdTSCcsXG4gIHZhbHVlOiAnU0gnLFxuICBmbGFnOiAnc2gnLFxuICB0ZXh0OiAnU2FpbnQgSGVsZW5hJ1xufSwge1xuICBrZXk6ICdLTicsXG4gIHZhbHVlOiAnS04nLFxuICBmbGFnOiAna24nLFxuICB0ZXh0OiAnU2FpbnQgS2l0dHMgYW5kIE5ldmlzJ1xufSwge1xuICBrZXk6ICdMQycsXG4gIHZhbHVlOiAnTEMnLFxuICBmbGFnOiAnbGMnLFxuICB0ZXh0OiAnU2FpbnQgTHVjaWEnXG59LCB7XG4gIGtleTogJ1BNJyxcbiAgdmFsdWU6ICdQTScsXG4gIGZsYWc6ICdwbScsXG4gIHRleHQ6ICdTYWludCBQaWVycmUnXG59LCB7XG4gIGtleTogJ1ZDJyxcbiAgdmFsdWU6ICdWQycsXG4gIGZsYWc6ICd2YycsXG4gIHRleHQ6ICdTYWludCBWaW5jZW50J1xufSwge1xuICBrZXk6ICdXUycsXG4gIHZhbHVlOiAnV1MnLFxuICBmbGFnOiAnd3MnLFxuICB0ZXh0OiAnU2Ftb2EnXG59LCB7XG4gIGtleTogJ1NNJyxcbiAgdmFsdWU6ICdTTScsXG4gIGZsYWc6ICdzbScsXG4gIHRleHQ6ICdTYW4gTWFyaW5vJ1xufSwge1xuICBrZXk6ICdHUycsXG4gIHZhbHVlOiAnR1MnLFxuICBmbGFnOiAnZ3MnLFxuICB0ZXh0OiAnU2FuZHdpY2ggSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnU1QnLFxuICB2YWx1ZTogJ1NUJyxcbiAgZmxhZzogJ3N0JyxcbiAgdGV4dDogJ1NhbyBUb21lJ1xufSwge1xuICBrZXk6ICdTQScsXG4gIHZhbHVlOiAnU0EnLFxuICBmbGFnOiAnc2EnLFxuICB0ZXh0OiAnU2F1ZGkgQXJhYmlhJ1xufSwge1xuICBrZXk6ICdTTicsXG4gIHZhbHVlOiAnU04nLFxuICBmbGFnOiAnc24nLFxuICB0ZXh0OiAnU2VuZWdhbCdcbn0sIHtcbiAga2V5OiAnQ1MnLFxuICB2YWx1ZTogJ0NTJyxcbiAgZmxhZzogJ2NzJyxcbiAgdGV4dDogJ1NlcmJpYSdcbn0sIHtcbiAga2V5OiAnUlMnLFxuICB2YWx1ZTogJ1JTJyxcbiAgZmxhZzogJ3JzJyxcbiAgdGV4dDogJ1NlcmJpYSdcbn0sIHtcbiAga2V5OiAnU0MnLFxuICB2YWx1ZTogJ1NDJyxcbiAgZmxhZzogJ3NjJyxcbiAgdGV4dDogJ1NleWNoZWxsZXMnXG59LCB7XG4gIGtleTogJ1NMJyxcbiAgdmFsdWU6ICdTTCcsXG4gIGZsYWc6ICdzbCcsXG4gIHRleHQ6ICdTaWVycmEgTGVvbmUnXG59LCB7XG4gIGtleTogJ1NHJyxcbiAgdmFsdWU6ICdTRycsXG4gIGZsYWc6ICdzZycsXG4gIHRleHQ6ICdTaW5nYXBvcmUnXG59LCB7XG4gIGtleTogJ1NLJyxcbiAgdmFsdWU6ICdTSycsXG4gIGZsYWc6ICdzaycsXG4gIHRleHQ6ICdTbG92YWtpYSdcbn0sIHtcbiAga2V5OiAnU0knLFxuICB2YWx1ZTogJ1NJJyxcbiAgZmxhZzogJ3NpJyxcbiAgdGV4dDogJ1Nsb3ZlbmlhJ1xufSwge1xuICBrZXk6ICdTQicsXG4gIHZhbHVlOiAnU0InLFxuICBmbGFnOiAnc2InLFxuICB0ZXh0OiAnU29sb21vbiBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdTTycsXG4gIHZhbHVlOiAnU08nLFxuICBmbGFnOiAnc28nLFxuICB0ZXh0OiAnU29tYWxpYSdcbn0sIHtcbiAga2V5OiAnWkEnLFxuICB2YWx1ZTogJ1pBJyxcbiAgZmxhZzogJ3phJyxcbiAgdGV4dDogJ1NvdXRoIEFmcmljYSdcbn0sIHtcbiAga2V5OiAnS1InLFxuICB2YWx1ZTogJ0tSJyxcbiAgZmxhZzogJ2tyJyxcbiAgdGV4dDogJ1NvdXRoIEtvcmVhJ1xufSwge1xuICBrZXk6ICdFUycsXG4gIHZhbHVlOiAnRVMnLFxuICBmbGFnOiAnZXMnLFxuICB0ZXh0OiAnU3BhaW4nXG59LCB7XG4gIGtleTogJ0xLJyxcbiAgdmFsdWU6ICdMSycsXG4gIGZsYWc6ICdsaycsXG4gIHRleHQ6ICdTcmkgTGFua2EnXG59LCB7XG4gIGtleTogJ1NEJyxcbiAgdmFsdWU6ICdTRCcsXG4gIGZsYWc6ICdzZCcsXG4gIHRleHQ6ICdTdWRhbidcbn0sIHtcbiAga2V5OiAnU1InLFxuICB2YWx1ZTogJ1NSJyxcbiAgZmxhZzogJ3NyJyxcbiAgdGV4dDogJ1N1cmluYW1lJ1xufSwge1xuICBrZXk6ICdTSicsXG4gIHZhbHVlOiAnU0onLFxuICBmbGFnOiAnc2onLFxuICB0ZXh0OiAnU3ZhbGJhcmQnXG59LCB7XG4gIGtleTogJ1NaJyxcbiAgdmFsdWU6ICdTWicsXG4gIGZsYWc6ICdzeicsXG4gIHRleHQ6ICdTd2F6aWxhbmQnXG59LCB7XG4gIGtleTogJ1NFJyxcbiAgdmFsdWU6ICdTRScsXG4gIGZsYWc6ICdzZScsXG4gIHRleHQ6ICdTd2VkZW4nXG59LCB7XG4gIGtleTogJ0NIJyxcbiAgdmFsdWU6ICdDSCcsXG4gIGZsYWc6ICdjaCcsXG4gIHRleHQ6ICdTd2l0emVybGFuZCdcbn0sIHtcbiAga2V5OiAnU1knLFxuICB2YWx1ZTogJ1NZJyxcbiAgZmxhZzogJ3N5JyxcbiAgdGV4dDogJ1N5cmlhJ1xufSwge1xuICBrZXk6ICdUVycsXG4gIHZhbHVlOiAnVFcnLFxuICBmbGFnOiAndHcnLFxuICB0ZXh0OiAnVGFpd2FuJ1xufSwge1xuICBrZXk6ICdUSicsXG4gIHZhbHVlOiAnVEonLFxuICBmbGFnOiAndGonLFxuICB0ZXh0OiAnVGFqaWtpc3Rhbidcbn0sIHtcbiAga2V5OiAnVFonLFxuICB2YWx1ZTogJ1RaJyxcbiAgZmxhZzogJ3R6JyxcbiAgdGV4dDogJ1RhbnphbmlhJ1xufSwge1xuICBrZXk6ICdUSCcsXG4gIHZhbHVlOiAnVEgnLFxuICBmbGFnOiAndGgnLFxuICB0ZXh0OiAnVGhhaWxhbmQnXG59LCB7XG4gIGtleTogJ1RMJyxcbiAgdmFsdWU6ICdUTCcsXG4gIGZsYWc6ICd0bCcsXG4gIHRleHQ6ICdUaW1vcmxlc3RlJ1xufSwge1xuICBrZXk6ICdURycsXG4gIHZhbHVlOiAnVEcnLFxuICBmbGFnOiAndGcnLFxuICB0ZXh0OiAnVG9nbydcbn0sIHtcbiAga2V5OiAnVEsnLFxuICB2YWx1ZTogJ1RLJyxcbiAgZmxhZzogJ3RrJyxcbiAgdGV4dDogJ1Rva2VsYXUnXG59LCB7XG4gIGtleTogJ1RPJyxcbiAgdmFsdWU6ICdUTycsXG4gIGZsYWc6ICd0bycsXG4gIHRleHQ6ICdUb25nYSdcbn0sIHtcbiAga2V5OiAnVFQnLFxuICB2YWx1ZTogJ1RUJyxcbiAgZmxhZzogJ3R0JyxcbiAgdGV4dDogJ1RyaW5pZGFkJ1xufSwge1xuICBrZXk6ICdUTicsXG4gIHZhbHVlOiAnVE4nLFxuICBmbGFnOiAndG4nLFxuICB0ZXh0OiAnVHVuaXNpYSdcbn0sIHtcbiAga2V5OiAnVFInLFxuICB2YWx1ZTogJ1RSJyxcbiAgZmxhZzogJ3RyJyxcbiAgdGV4dDogJ1R1cmtleSdcbn0sIHtcbiAga2V5OiAnVE0nLFxuICB2YWx1ZTogJ1RNJyxcbiAgZmxhZzogJ3RtJyxcbiAgdGV4dDogJ1R1cmttZW5pc3Rhbidcbn0sIHtcbiAga2V5OiAnVFYnLFxuICB2YWx1ZTogJ1RWJyxcbiAgZmxhZzogJ3R2JyxcbiAgdGV4dDogJ1R1dmFsdSdcbn0sIHtcbiAga2V5OiAnVUcnLFxuICB2YWx1ZTogJ1VHJyxcbiAgZmxhZzogJ3VnJyxcbiAgdGV4dDogJ1VnYW5kYSdcbn0sIHtcbiAga2V5OiAnVUEnLFxuICB2YWx1ZTogJ1VBJyxcbiAgZmxhZzogJ3VhJyxcbiAgdGV4dDogJ1VrcmFpbmUnXG59LCB7XG4gIGtleTogJ0FFJyxcbiAgdmFsdWU6ICdBRScsXG4gIGZsYWc6ICdhZScsXG4gIHRleHQ6ICdVbml0ZWQgQXJhYiBFbWlyYXRlcydcbn0sIHtcbiAga2V5OiAnVVMnLFxuICB2YWx1ZTogJ1VTJyxcbiAgZmxhZzogJ3VzJyxcbiAgdGV4dDogJ1VuaXRlZCBTdGF0ZXMnXG59LCB7XG4gIGtleTogJ1VZJyxcbiAgdmFsdWU6ICdVWScsXG4gIGZsYWc6ICd1eScsXG4gIHRleHQ6ICdVcnVndWF5J1xufSwge1xuICBrZXk6ICdVTScsXG4gIHZhbHVlOiAnVU0nLFxuICBmbGFnOiAndW0nLFxuICB0ZXh0OiAnVXMgTWlub3IgSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnVkknLFxuICB2YWx1ZTogJ1ZJJyxcbiAgZmxhZzogJ3ZpJyxcbiAgdGV4dDogJ1VzIFZpcmdpbiBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdVWicsXG4gIHZhbHVlOiAnVVonLFxuICBmbGFnOiAndXonLFxuICB0ZXh0OiAnVXpiZWtpc3Rhbidcbn0sIHtcbiAga2V5OiAnVlUnLFxuICB2YWx1ZTogJ1ZVJyxcbiAgZmxhZzogJ3Z1JyxcbiAgdGV4dDogJ1ZhbnVhdHUnXG59LCB7XG4gIGtleTogJ1ZBJyxcbiAgdmFsdWU6ICdWQScsXG4gIGZsYWc6ICd2YScsXG4gIHRleHQ6ICdWYXRpY2FuIENpdHknXG59LCB7XG4gIGtleTogJ1ZFJyxcbiAgdmFsdWU6ICdWRScsXG4gIGZsYWc6ICd2ZScsXG4gIHRleHQ6ICdWZW5lenVlbGEnXG59LCB7XG4gIGtleTogJ1ZOJyxcbiAgdmFsdWU6ICdWTicsXG4gIGZsYWc6ICd2bicsXG4gIHRleHQ6ICdWaWV0bmFtJ1xufSwge1xuICBrZXk6ICdXRicsXG4gIHZhbHVlOiAnV0YnLFxuICBmbGFnOiAnd2YnLFxuICB0ZXh0OiAnV2FsbGlzIGFuZCBGdXR1bmEnXG59LCB7XG4gIGtleTogJ0VIJyxcbiAgdmFsdWU6ICdFSCcsXG4gIGZsYWc6ICdlaCcsXG4gIHRleHQ6ICdXZXN0ZXJuIFNhaGFyYSdcbn0sIHtcbiAga2V5OiAnWUUnLFxuICB2YWx1ZTogJ1lFJyxcbiAgZmxhZzogJ3llJyxcbiAgdGV4dDogJ1llbWVuJ1xufSwge1xuICBrZXk6ICdaTScsXG4gIHZhbHVlOiAnWk0nLFxuICBmbGFnOiAnem0nLFxuICB0ZXh0OiAnWmFtYmlhJ1xufSwge1xuICBrZXk6ICdaVycsXG4gIHZhbHVlOiAnWlcnLFxuICBmbGFnOiAnencnLFxuICB0ZXh0OiAnWmltYmFid2UnXG59XTtcblxuZnVuY3Rpb24gZmV0Y2hLeWNDb3VudHJpZXMoX3gpIHtcbiAgcmV0dXJuIF9mZXRjaEt5Y0NvdW50cmllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLyoqXHJcbiAqIEZBSUxFRFxyXG4gKiBVTlNVQk1JVFRFRFxyXG4gKiBQRU5ESU5HXHJcbiAqIFBBU1NFRFxyXG4gKi9cblxuZnVuY3Rpb24gX2ZldGNoS3ljQ291bnRyaWVzKCkge1xuICBfZmV0Y2hLeWNDb3VudHJpZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoX3JlZikge1xuICAgIHZhciBjaGFpbiwgdXJsLCBfeWllbGQkdGhpcyRnZXQsIGNvdW50cmllcywgY291bnRyaWVzQnlJZDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNoYWluID0gX3JlZi5jaGFpbjtcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLkJMT0tTX0FQSSArIFwiL1wiICsgY2hhaW4gKyBcIi9reWM/dHlwZT1jb3VudHJpZXMmY2hhaW49XCIgKyBjaGFpbjtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRnZXQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgY291bnRyaWVzID0gX3lpZWxkJHRoaXMkZ2V0LmNvbnRlbnQ7XG4gICAgICAgICAgICBjb3VudHJpZXNCeUlkID0gY291bnRyaWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjb3VudHJ5KSB7XG4gICAgICAgICAgICAgIGFjY1tjb3VudHJ5LmlkXSA9IGNvdW50cnk7XG4gICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvdW50cnlPcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoY291bnRyeU9wdGlvbikge1xuICAgICAgICAgICAgICByZXR1cm4gY291bnRyaWVzQnlJZFtjb3VudHJ5T3B0aW9uLmtleV07XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZmV0Y2hLeWNDb3VudHJpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tVc2VyS3ljU3RhdHVzKF94Mikge1xuICByZXR1cm4gX2NoZWNrVXNlckt5Y1N0YXR1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfY2hlY2tVc2VyS3ljU3RhdHVzKCkge1xuICBfY2hlY2tVc2VyS3ljU3RhdHVzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChfcmVmMikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2hhaW4sIGFjdG9yLCBleHBlY3RlZFRpZXI7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNoYWluID0gX3JlZjIuY2hhaW4sIGFjdG9yID0gX3JlZjIuYWN0b3IsIGV4cGVjdGVkVGllciA9IF9yZWYyLmV4cGVjdGVkVGllcjtcblxuICAgICAgICAgICAgaWYgKCEoIWNoYWluIHx8ICFhY3RvciB8fCAhZXhwZWN0ZWRUaWVyKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVycycpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFByb21pc2UoIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdldFN0YXR1cztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGFsbCBLWUMgcmVjb3JkcyBmb3IgdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3lpZWxkJF90aGlzJHJwYyRpc0xpLCB1c2VySW5mbywgdXJsLCBreWMsIG1hdGNoZWRUaWVyLCBzdGF0dXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJwYy5pc0xpZ2h0S1lDVmVyaWZpZWQoYWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3lpZWxkJF90aGlzJHJwYyRpc0xpID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VySW5mbyA9IF95aWVsZCRfdGhpcyRycGMkaXNMaVswXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodXNlckluZm8gJiYgdXNlckluZm8uaXNMaWdodEtZQ1ZlcmlmaWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXNvbHZlKEt5Y1N0YXR1cy5QQVNTRUQpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IF90aGlzLmNvbnN0YW50cy5CTE9LU19BUEkgKyBcIi9cIiArIGNoYWluICsgXCIva3ljP3R5cGU9c3RhdHVzJmNoYWluPVwiICsgY2hhaW4gKyBcIiZhY3Rvcj1cIiArIGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldCh1cmwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga3ljID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFreWMgfHwgIWt5Yy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgZmV0Y2ggS1lDIHJlY29yZCcpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCByZWxldmFudCBLWUMgcmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVGllciA9IGt5Yy5maW5kKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGllciA9IF9yZWY1LnRpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aWVyID09PSBTdHJpbmcoZXhwZWN0ZWRUaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFRpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlamVjdChuZXcgRXJyb3IoJ05vIGt5YyBkYXRhIG1hdGNoaW5nIHRpZXIgZm91bmQnKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVud3JhcCBreWMgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gbWF0Y2hlZFRpZXIuc3RhdHVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFRpZXIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZWplY3QobmV3IEVycm9yKCdLWUMgU3RhdHVzIG5vdCBmb3VuZCcpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3RhdHVzID09PSBLeWNTdGF0dXMuUEVORElORykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDAwICogMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzb2x2ZShzdGF0dXMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0dXMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3g0LCBfeDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKSkpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQpO1xuICB9KSk7XG4gIHJldHVybiBfY2hlY2tVc2VyS3ljU3RhdHVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5Rm9yS3ljKF94Mykge1xuICByZXR1cm4gX2FwcGx5Rm9yS3ljLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9hcHBseUZvckt5YygpIHtcbiAgX2FwcGx5Rm9yS3ljID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShwYXJhbXMpIHtcbiAgICB2YXIgdXJsLCBkYXRhO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5CTE9LU19BUEkgKyBcIi9cIiArIHBhcmFtcy5jaGFpbiArIFwiL2t5Y1wiO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdCh1cmwsIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgdHlwZTogJ2FwcGx5J1xuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQ1LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGFwcGx5IGZvciBLWUMnKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2FwcGx5Rm9yS3ljLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBjaGFpbkluZm9QYXJzZXIgPSAvKiNfX1BVUkVfXyovei5vYmplY3Qoe1xuICBjaGFpbklkOiAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSxcbiAgZXhwbG9yZXJVcmw6IC8qI19fUFVSRV9fKi96LnN0cmluZygpLFxuICBleHBsb3Jlck5hbWU6IC8qI19fUFVSRV9fKi96LnN0cmluZygpLFxuICByZXNvdXJjZVRva2VuU3ltYm9sOiAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSxcbiAgcmVzb3VyY2VUb2tlbkNvbnRyYWN0OiAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSxcbiAgc3lzdGVtVG9rZW5TeW1ib2w6IC8qI19fUFVSRV9fKi96LnN0cmluZygpLFxuICBzeXN0ZW1Ub2tlbkNvbnRyYWN0OiAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSxcbiAgcnBjRW5kcG9pbnRzOiAvKiNfX1BVUkVfXyovei5hcnJheSggLyojX19QVVJFX18qL3ouc3RyaW5nKCkpLFxuICBhY3Rpb25zUnBjRW5kcG9pbnRzOiAvKiNfX1BVUkVfXyovei5hcnJheSggLyojX19QVVJFX18qL3ouc3RyaW5nKCkpLFxuICBoeXBlcmlvbkVuZHBvaW50czogLyojX19QVVJFX18qL3ouYXJyYXkoIC8qI19fUFVSRV9fKi96LnN0cmluZygpKSxcbiAgbGlnaHRFbmRwb2ludHM6IC8qI19fUFVSRV9fKi96LmFycmF5KCAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSlcbn0pO1xuXG5mdW5jdGlvbiBnZXRDaGFpbkluZm8oKSB7XG4gIHJldHVybiBfZ2V0Q2hhaW5JbmZvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRDaGFpbkluZm8oKSB7XG4gIF9nZXRDaGFpbkluZm8gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIHVybCwgZGF0YTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5DSEFJTiA9PT0gJ3Byb3Rvbi10ZXN0JyA/ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vUHJvdG9uUHJvdG9jb2wvY2hhaW4taW5mby9tYWluL3Rlc3RuZXQuanNvbicgOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1Byb3RvblByb3RvY29sL2NoYWluLWluZm8vbWFpbi9tYWlubmV0Lmpzb24nO1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwsIHt9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjaGFpbkluZm9QYXJzZXIucGFyc2UoZGF0YSkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzEsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRDaGFpbkluZm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW5QcmljZXMoKSB7XG4gIHJldHVybiBfZ2V0VG9rZW5QcmljZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFRva2VuUHJpY2VzKCkge1xuICBfZ2V0VG9rZW5QcmljZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgIHZhciB1cmwsIGRhdGE7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLk1FVEFMX1BST1RPTl9FTkRQT0lOVCArIFwiL3YxL2NoYWluL2V4Y2hhbmdlLXJhdGVzL2luZm9cIjtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZXhjaGFuZ2VSYXRlc1BhcnNlci5wYXJzZShkYXRhKSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmZXRjaCBleGNoYW5nZSByYXRlc1wiKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1sxLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0VG9rZW5QcmljZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2l0aGRyYXdhbEZlZShfeCkge1xuICByZXR1cm4gX2dldFdpdGhkcmF3YWxGZWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFdpdGhkcmF3YWxGZWUoKSB7XG4gIF9nZXRXaXRoZHJhd2FsRmVlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhfcmVmKSB7XG4gICAgdmFyIGN1cnJlbmN5LCBuZXR3b3JrLCB1cmwsIGRhdGE7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGN1cnJlbmN5ID0gX3JlZi5jdXJyZW5jeSwgbmV0d29yayA9IF9yZWYubmV0d29yaztcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLk1FVEFMX1BST1RPTl9FTkRQT0lOVCArIFwiL3YxL3N3YXBzL2NhbGN1bGF0ZS1lc3RpbWF0ZWQtZmVlXCI7XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDI7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHVybCwge1xuICAgICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3ksXG4gICAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgd2l0aGRyYXdhbEZlZVF1b3RlUGFyc2VyLnBhcnNlKGRhdGEpKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gOTtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQzLnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMiwgOV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFdpdGhkcmF3YWxGZWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY3VycmVudExvY2F0aW9uKCkge1xuICByZXR1cm4gX2N1cnJlbnRMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfY3VycmVudExvY2F0aW9uKCkge1xuICBfY3VycmVudExvY2F0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5NRVRBTF9QUk9UT05fRU5EUE9JTlQgKyBcIi92MS9reWMvaXAtaW5mb1wiO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9jdXJyZW50TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlRmVhdHVyZXMoX3gyKSB7XG4gIHJldHVybiBfZ2V0QXZhaWxhYmxlRmVhdHVyZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEF2YWlsYWJsZUZlYXR1cmVzKCkge1xuICBfZ2V0QXZhaWxhYmxlRmVhdHVyZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGFjY291bnQpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5NRVRBTF9QUk9UT05fRU5EUE9JTlQgKyAoXCIvdjIva3ljL2J5LWNoYWluLWFjY291bnQvXCIgKyBhY2NvdW50ICsgXCIvYXZhaWxhYmxlLWZlYXR1cmVzXCIpO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDUuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBdmFpbGFibGVGZWF0dXJlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY2NvdW50KF94Mykge1xuICByZXR1cm4gX2NyZWF0ZUFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUFjY291bnQoKSB7XG4gIF9jcmVhdGVBY2NvdW50ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihwYXJhbXMpIHtcbiAgICB2YXIgdXJsLCBkYXRhO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5NRVRBTF9QUk9UT05fRU5EUE9JTlQgKyBcIi92Mi91c2Vycy9jcmVhdGVcIjtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QodXJsLCBwYXJhbXMpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9jcmVhdGVBY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGxvZ2luQWNjb3VudChfeDQpIHtcbiAgcmV0dXJuIF9sb2dpbkFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xvZ2luQWNjb3VudCgpIHtcbiAgX2xvZ2luQWNjb3VudCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcocGFyYW1zKSB7XG4gICAgdmFyIHVybCwgZGF0YTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuTUVUQUxfUFJPVE9OX0VORFBPSU5UICsgXCIvdjIvdXNlcnMvbG9naW5cIjtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QodXJsLCBwYXJhbXMpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9sb2dpbkFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gb3RjUXVvdGUoX3gpIHtcbiAgcmV0dXJuIF9vdGNRdW90ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb3RjUXVvdGUoKSB7XG4gIF9vdGNRdW90ZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShib2R5KSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5TV0FQX1VSTCArIChcIi92MS9xdW90ZS9cIiArIGJvZHkuYmFzZVN5bWJvbCArIFwiL1wiICsgYm9keS5iYXNlQW1vdW50ICsgXCIvXCIgKyBib2R5LnF1b3RlU3ltYm9sKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX290Y1F1b3RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG90Y09yZGVyKF94Mikge1xuICByZXR1cm4gX290Y09yZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vdGNPcmRlcigpIHtcbiAgX290Y09yZGVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihpZCkge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLlNXQVBfVVJMICsgKFwiL3YxL29yZGVyL1wiICsgaWQpO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9vdGNPcmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUFkZHJlc3MoX3gpIHtcbiAgcmV0dXJuIF9nZW5lcmF0ZUFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dlbmVyYXRlQWRkcmVzcygpIHtcbiAgX2dlbmVyYXRlQWRkcmVzcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShib2R5KSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5XUkFQX1NFUlZFUl9VUkwgKyAnL2FkZHJlc3MvZ2VuZXJhdGUnO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHVybCwgYm9keSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dlbmVyYXRlQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkZWxldGVBZGRyZXNzKF94Mikge1xuICByZXR1cm4gX2RlbGV0ZUFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2RlbGV0ZUFkZHJlc3MoKSB7XG4gIF9kZWxldGVBZGRyZXNzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihib2R5KSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuV1JBUF9TRVJWRVJfVVJMICsgJy9hZGRyZXNzL2RlbGV0ZSc7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHVybCwgYm9keSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9kZWxldGVBZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHdpdGhkcmF3TWV0YWwoX3gzKSB7XG4gIHJldHVybiBfd2l0aGRyYXdNZXRhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfd2l0aGRyYXdNZXRhbCgpIHtcbiAgX3dpdGhkcmF3TWV0YWwgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGJvZHkpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5XUkFQX1NFUlZFUl9VUkwgKyAnL3dpdGhkcmF3JztcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QodXJsLCBib2R5KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0My5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX3dpdGhkcmF3TWV0YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gd2l0aGRyYXdhbEhpc3RvcnlNZXRhbChfeDQpIHtcbiAgcmV0dXJuIF93aXRoZHJhd2FsSGlzdG9yeU1ldGFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93aXRoZHJhd2FsSGlzdG9yeU1ldGFsKCkge1xuICBfd2l0aGRyYXdhbEhpc3RvcnlNZXRhbCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWNjb3VudCkge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLldSQVBfU0VSVkVSX1VSTCArIChcIi93aXRoZHJhd2Fscy9cIiArIGFjY291bnQpO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF93aXRoZHJhd2FsSGlzdG9yeU1ldGFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFhwclRvdGFsU3Rha2VkQW5kQXByKCkge1xuICByZXR1cm4gX2dldFhwclRvdGFsU3Rha2VkQW5kQXByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRYcHJUb3RhbFN0YWtlZEFuZEFwcigpIHtcbiAgX2dldFhwclRvdGFsU3Rha2VkQW5kQXByID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgIHZhciBfeWllbGQkUHJvbWlzZSRhbGwsIHN1cHBseSwgdG90YWxTdGFrZWRVbnBhcnNlZCwgX3lpZWxkJFByb21pc2UkYWxsJCwgY29udGludW91c19yYXRlLCBpbmZsYXRpb25fcGF5X2ZhY3Rvciwgdm90ZXBheV9mYWN0b3IsIGFkZGl0aW9uYWxJbmZsYXRpb24sIG5ld190b2tlbnMsIHRvX3lpZWxkZmFybXMsIGJwYW5kc2F2aW5ncywgdG9fcHJvZHVjZXJzLCB0b19wcm9kdWNlcnNfYmxvY2ssIHRvX3Byb2R1Y2Vyc192b3RlLCBzYXZpbmdzLCB0b19zYXZpbmdzLCB0b19jb25zb3J0aXVtLCB0b3RhbFN0YWtlZCwgYXByO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpcy5nZXRUb2tlblN1cHBseSh0aGlzLmNvbnN0YW50cy5FT1NJT19UT0tFTiwgdGhpcy5jb25zdGFudHMuQ09SRV9TWU1CT0wpLCB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAnZ2xvYmFsc2QnLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXMucm93c1swXTtcbiAgICAgICAgICAgIH0pLCB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAnZ2xvYmFsNCcsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yb3dzWzBdO1xuICAgICAgICAgICAgfSldKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCRQcm9taXNlJGFsbCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBzdXBwbHkgPSBfeWllbGQkUHJvbWlzZSRhbGxbMF0uc3VwcGx5O1xuICAgICAgICAgICAgdG90YWxTdGFrZWRVbnBhcnNlZCA9IF95aWVsZCRQcm9taXNlJGFsbFsxXS50b3RhbHJzdGFrZWQ7XG4gICAgICAgICAgICBfeWllbGQkUHJvbWlzZSRhbGwkID0gX3lpZWxkJFByb21pc2UkYWxsWzJdO1xuICAgICAgICAgICAgY29udGludW91c19yYXRlID0gX3lpZWxkJFByb21pc2UkYWxsJC5jb250aW51b3VzX3JhdGU7XG4gICAgICAgICAgICBpbmZsYXRpb25fcGF5X2ZhY3RvciA9IF95aWVsZCRQcm9taXNlJGFsbCQuaW5mbGF0aW9uX3BheV9mYWN0b3I7XG4gICAgICAgICAgICB2b3RlcGF5X2ZhY3RvciA9IF95aWVsZCRQcm9taXNlJGFsbCQudm90ZXBheV9mYWN0b3I7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSW5mbGF0aW9uID0gK2NvbnRpbnVvdXNfcmF0ZSAqIHN1cHBseTtcbiAgICAgICAgICAgIG5ld190b2tlbnMgPSBhZGRpdGlvbmFsSW5mbGF0aW9uO1xuICAgICAgICAgICAgdG9feWllbGRmYXJtcyA9IG5ld190b2tlbnMgLyA0O1xuICAgICAgICAgICAgYnBhbmRzYXZpbmdzID0gbmV3X3Rva2VucyAtIHRvX3lpZWxkZmFybXM7XG4gICAgICAgICAgICB0b19wcm9kdWNlcnMgPSBicGFuZHNhdmluZ3MgKiAoMTAwMDAgLyBpbmZsYXRpb25fcGF5X2ZhY3Rvcik7XG4gICAgICAgICAgICB0b19wcm9kdWNlcnNfYmxvY2sgPSB0b19wcm9kdWNlcnMgKiAoMTAwMDAgLyB2b3RlcGF5X2ZhY3Rvcik7XG4gICAgICAgICAgICB0b19wcm9kdWNlcnNfdm90ZSA9IHRvX3Byb2R1Y2VycyAtIHRvX3Byb2R1Y2Vyc19ibG9jaztcbiAgICAgICAgICAgIHNhdmluZ3MgPSBicGFuZHNhdmluZ3MgLSB0b19wcm9kdWNlcnM7XG4gICAgICAgICAgICB0b19zYXZpbmdzID0gMiAqIHNhdmluZ3MgLyAzO1xuICAgICAgICAgICAgdG9fY29uc29ydGl1bSA9IHNhdmluZ3MgLSB0b19zYXZpbmdzO1xuICAgICAgICAgICAgdG90YWxTdGFrZWQgPSArdG90YWxTdGFrZWRVbnBhcnNlZCAvIE1hdGgucG93KDEwLCB0aGlzLmNvbnN0YW50cy5DT1JFX1BSRUNJU0lPTik7XG4gICAgICAgICAgICBhcHIgPSB0b19zYXZpbmdzIC8gdG90YWxTdGFrZWQgKiAxMDA7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgc3VwcGx5OiBzdXBwbHksXG4gICAgICAgICAgICAgIHlpZWxkRmFybWluZzogdG9feWllbGRmYXJtcyxcbiAgICAgICAgICAgICAgcHJvZHVjZXJzOiB0b19wcm9kdWNlcnMsXG4gICAgICAgICAgICAgIHByb2R1Y2Vyc0Jsb2NrOiB0b19wcm9kdWNlcnNfYmxvY2ssXG4gICAgICAgICAgICAgIHByb2R1Y2Vyc1ZvdGU6IHRvX3Byb2R1Y2Vyc192b3RlLFxuICAgICAgICAgICAgICBjb25zb3J0aXVtOiB0b19jb25zb3J0aXVtLFxuICAgICAgICAgICAgICBzdGFraW5nOiB0b19zYXZpbmdzLFxuICAgICAgICAgICAgICB0b3RhbFN0YWtlZDogdG90YWxTdGFrZWQsXG4gICAgICAgICAgICAgIGFwcjogYXByXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjU7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIDApO1xuXG4gICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCAyNV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFhwclRvdGFsU3Rha2VkQW5kQXByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFhwclZvdGVyKF94KSB7XG4gIHJldHVybiBfZ2V0WHByVm90ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFhwclZvdGVyKCkge1xuICBfZ2V0WHByVm90ZXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdGFibGU6ICd2b3RlcnN4cHInLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Qucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCAmJiByb3dzWzBdLm93bmVyID09PSBhY2NvdW50KSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTI7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDEyXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0WHByVm90ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0WHByQWNjb3VudFN0YWtlcyhfeDIpIHtcbiAgcmV0dXJuIF9nZXRYcHJBY2NvdW50U3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRYcHJBY2NvdW50U3Rha2VzKCkge1xuICBfZ2V0WHByQWNjb3VudFN0YWtlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYWNjb3VudCkge1xuICAgIHZhciBzdGFrZXMsIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgc3Rha2VzID0gW107XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB0YWJsZTogJ2RlbHhwcicsXG4gICAgICAgICAgICAgIGxpbWl0OiAtMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QyID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Mi5yb3dzO1xuXG4gICAgICAgICAgICBpZiAocm93cyAmJiByb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBzdGFrZXMgPSByb3dzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDk7XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgc3Rha2VzKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcywgW1sxLCA5XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0WHByQWNjb3VudFN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRYcHJBY2NvdW50UmVmdW5kKF94Mykge1xuICByZXR1cm4gX2dldFhwckFjY291bnRSZWZ1bmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFhwckFjY291bnRSZWZ1bmQoKSB7XG4gIF9nZXRYcHJBY2NvdW50UmVmdW5kID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhY2NvdW50KSB7XG4gICAgdmFyIHJlZnVuZCwgX3lpZWxkJHRoaXMkcnBjJGdldF90Mywgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB0YWJsZTogJ3JlZnVuZHN4cHInLFxuICAgICAgICAgICAgICBsaW1pdDogLTFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90MyA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDMucm93cztcblxuICAgICAgICAgICAgaWYgKHJvd3MgJiYgcm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVmdW5kID0gcm93c1swXTtcbiAgICAgICAgICAgICAgcmVmdW5kLnF1YW50aXR5ID0gK3JlZnVuZC5xdWFudGl0eS5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0NC50MCk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVmdW5kKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1swLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0WHByQWNjb3VudFJlZnVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRYcHJPcmFjbGVEYXRhKF94NCkge1xuICByZXR1cm4gX2dldFhwck9yYWNsZURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFhwck9yYWNsZURhdGEoKSB7XG4gIF9nZXRYcHJPcmFjbGVEYXRhID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShvcmFjbGVJbmRleCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q0LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdvcmFjbGVzJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdvcmFjbGVzJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBvcmFjbGVJbmRleCxcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6IG9yYWNsZUluZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDQgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q0LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxMjtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ1LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMCwgMTJdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRYcHJPcmFjbGVEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFsbE9yYWNsZUZlZWRzKF94NSkge1xuICByZXR1cm4gX2dldEFsbE9yYWNsZUZlZWRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBbGxPcmFjbGVGZWVkcygpIHtcbiAgX2dldEFsbE9yYWNsZUZlZWRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihsb3dlcl9ib3VuZCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1LCByb3dzLCBtb3JlLCBuZXh0X2tleSwgcmVzdE9mUm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAobG93ZXJfYm91bmQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBsb3dlcl9ib3VuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ29yYWNsZXMnLFxuICAgICAgICAgICAgICBzY29wZTogJ29yYWNsZXMnLFxuICAgICAgICAgICAgICB0YWJsZTogJ2ZlZWRzJyxcbiAgICAgICAgICAgICAgbGltaXQ6IC0xLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogbG93ZXJfYm91bmRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NSA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDUucm93cztcbiAgICAgICAgICAgIG1vcmUgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1Lm1vcmU7XG4gICAgICAgICAgICBuZXh0X2tleSA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDUubmV4dF9rZXk7XG5cbiAgICAgICAgICAgIGlmICghbW9yZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbE9yYWNsZUZlZWRzKG5leHRfa2V5KTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXN0T2ZSb3dzID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByb3dzLmNvbmNhdChyZXN0T2ZSb3dzKSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMTg7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Ni50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYsIHRoaXMsIFtbMSwgMThdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBbGxPcmFjbGVGZWVkcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWZpY09yYWNsZURhdGEoX3g2KSB7XG4gIHJldHVybiBfZ2V0U3BlY2lmaWNPcmFjbGVEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59IC8vIHB1YlxuXG5mdW5jdGlvbiBfZ2V0U3BlY2lmaWNPcmFjbGVEYXRhKCkge1xuICBfZ2V0U3BlY2lmaWNPcmFjbGVEYXRhID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhmZWVkX2luZGV4KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDYsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ29yYWNsZXMnLFxuICAgICAgICAgICAgICBzY29wZTogJ29yYWNsZXMnLFxuICAgICAgICAgICAgICB0YWJsZTogJ2RhdGEnLFxuICAgICAgICAgICAgICBsaW1pdDogLTEsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBmZWVkX2luZGV4LFxuICAgICAgICAgICAgICB1cHBlcl9ib3VuZDogZmVlZF9pbmRleFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q2ID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Ni5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoICYmIHJvd3NbMF0uZmVlZF9pbmRleCA9PT0gZmVlZF9pbmRleCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDEyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDk7XG4gICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Ny50MCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgdGhpcywgW1swLCA5XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0U3BlY2lmaWNPcmFjbGVEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFsbE9yYWNsZURhdGEoX3g3KSB7XG4gIHJldHVybiBfZ2V0QWxsT3JhY2xlRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWxsT3JhY2xlRGF0YSgpIHtcbiAgX2dldEFsbE9yYWNsZURhdGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KGxvd2VyX2JvdW5kKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDcsIHJvd3MsIG1vcmUsIG5leHRfa2V5O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdvcmFjbGVzJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdvcmFjbGVzJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgbGltaXQ6IC0xLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogbG93ZXJfYm91bmRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NyA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDcucm93cztcbiAgICAgICAgICAgIG1vcmUgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q3Lm1vcmU7XG4gICAgICAgICAgICBuZXh0X2tleSA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDcubmV4dF9rZXk7XG5cbiAgICAgICAgICAgIGlmICghbW9yZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDEzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ4LnQwID0gcm93cztcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxPcmFjbGVEYXRhKG5leHRfa2V5KTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDgudDEgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfY29udGV4dDgudDAuY29uY2F0LmNhbGwoX2NvbnRleHQ4LnQwLCBfY29udGV4dDgudDEpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMTY7XG4gICAgICAgICAgICBfY29udGV4dDgudDIgPSBfY29udGV4dDhbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0OC50Mik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTgsIHRoaXMsIFtbMCwgMTZdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBbGxPcmFjbGVEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb3RvbkF2YXRhcnMoX3g4LCBfeDkpIHtcbiAgcmV0dXJuIF9nZXRQcm90b25BdmF0YXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b25BdmF0YXJzKCkge1xuICBfZ2V0UHJvdG9uQXZhdGFycyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoYWNjb3VudCwgbGltaXQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBsaW1pdCA9IDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISh0aGlzLmNvbnN0YW50cy5DSEFJTi5pbmRleE9mKCdwcm90b24nKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDkucHJldiA9IDI7XG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiAnZW9zaW8ucHJvdG9uJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdlb3Npby5wcm90b24nLFxuICAgICAgICAgICAgICB0YWJsZTogJ3VzZXJzaW5mbycsXG4gICAgICAgICAgICAgIHRhYmxlX2tleTogJycsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogMSxcbiAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LnJvd3MpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQ5LnByZXYgPSA5O1xuICAgICAgICAgICAgX2NvbnRleHQ5LnQwID0gX2NvbnRleHQ5W1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ2V0UHJvdG9uQXZhdGFyIGVycm9yJywgX2NvbnRleHQ5LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTksIHRoaXMsIFtbMiwgOV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb3RvbkF2YXRhcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdG9uQXZhdGFyKF94MTApIHtcbiAgcmV0dXJuIF9nZXRQcm90b25BdmF0YXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvbkF2YXRhcigpIHtcbiAgX2dldFByb3RvbkF2YXRhciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKGFjY291bnQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEodGhpcy5jb25zdGFudHMuQ0hBSU4uaW5kZXhPZigncHJvdG9uJykgIT09IC0xKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogJ2Vvc2lvLnByb3RvbicsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZW9zaW8ucHJvdG9uJyxcbiAgICAgICAgICAgICAgdGFibGU6ICd1c2Vyc2luZm8nLFxuICAgICAgICAgICAgICB0YWJsZV9rZXk6ICcnLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDEsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0MTAuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCByZXN1bHQucm93cy5sZW5ndGggPiAwICYmIHJlc3VsdC5yb3dzWzBdLmFjYyA9PT0gYWNjb3VudCA/IHJlc3VsdC5yb3dzWzBdIDogdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDEwLnQwID0gX2NvbnRleHQxMFtcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dldFByb3RvbkF2YXRhciBlcnJvcicsIF9jb250ZXh0MTAudDApO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMTAsIHRoaXMsIFtbMSwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb3RvbkF2YXRhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSZW50YndTdGF0ZSgpIHtcbiAgcmV0dXJuIF9nZXRSZW50YndTdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmVudGJ3U3RhdGUoKSB7XG4gIF9nZXRSZW50YndTdGF0ZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IDAsXG4gICAgICAgICAgICAgIHRhYmxlOiAncG93dXAuc3RhdGUnLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5yb3dzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZW50YndTdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkZWxlZ2F0ZWRCYW5kd2lkdGgoX3gsIF94Mikge1xuICByZXR1cm4gX2RlbGVnYXRlZEJhbmR3aWR0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZGVsZWdhdGVkQmFuZHdpZHRoKCkge1xuICBfZGVsZWdhdGVkQmFuZHdpZHRoID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhY2NvdW50LCBsb3dlcl9ib3VuZCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHRhYmxlOiAnZGVsYmFuZCcsXG4gICAgICAgICAgICAgIHRhYmxlX2tleTogJycsXG4gICAgICAgICAgICAgIGxpbWl0OiAtMSxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGxvd2VyX2JvdW5kLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAxXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9kZWxlZ2F0ZWRCYW5kd2lkdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWNjb3VudERlbGVnYXRlZEJhbmR3aWR0aChfeDMpIHtcbiAgcmV0dXJuIF9nZXRBY2NvdW50RGVsZWdhdGVkQmFuZHdpZHRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY2NvdW50RGVsZWdhdGVkQmFuZHdpZHRoKCkge1xuICBfZ2V0QWNjb3VudERlbGVnYXRlZEJhbmR3aWR0aCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYWNjb3VudCkge1xuICAgIHZhciBtb3JlLCByb3dzLCByZXN1bHQsIGxvd2VyX2JvdW5kO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBtb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJvd3MgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBsb3dlcl9ib3VuZCA9ICcnO1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSA0O1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVkQmFuZHdpZHRoKGFjY291bnQsIGxvd2VyX2JvdW5kKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgbW9yZSA9IHJlc3VsdC5tb3JlO1xuICAgICAgICAgICAgcm93cyA9IHJvd3MuY29uY2F0KHJlc3VsdC5yb3dzKTtcblxuICAgICAgICAgICAgaWYgKG1vcmUpIHtcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQgPSBuZXcgQmlnTnVtYmVyKGVuY29kZU5hbWUocm93c1tyb3dzLmxlbmd0aCAtIDFdLnRvLCBmYWxzZSkpLnBsdXMoMSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBpZiAobW9yZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE0O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzQsIDE0XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWNjb3VudERlbGVnYXRlZEJhbmR3aWR0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBY2NvdW50UmVzb3VyY2VzKF94NCkge1xuICByZXR1cm4gX2dldEFjY291bnRSZXNvdXJjZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjY291bnRSZXNvdXJjZXMoKSB7XG4gIF9nZXRBY2NvdW50UmVzb3VyY2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdGFibGU6ICd1c2VycmVzJyxcbiAgICAgICAgICAgICAgdGFibGVfa2V5OiAnJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90MiA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDIucm93cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWNjb3VudFJlc291cmNlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSYW1QcmljZUluRW9zKCkge1xuICByZXR1cm4gX2dldFJhbVByaWNlSW5Fb3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJhbVByaWNlSW5Fb3MoKSB7XG4gIF9nZXRSYW1QcmljZUluRW9zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICB2YXIgcmFtLCBiYXNlU3RyaW5nLCBiYXNlLCBxdW90ZVN0cmluZywgcXVvdGUsIHByaWNlLCByYW1QcmljZUVvcztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdyYW1tYXJrZXQnLFxuICAgICAgICAgICAgICB0YWJsZV9rZXk6ICcnLFxuICAgICAgICAgICAgICBsaW1pdDogMTBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmFtID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICAvLyBBbW91bnQgb2YgUkFNIGJ5dGVzIGluIHVzZVxuICAgICAgICAgICAgYmFzZVN0cmluZyA9IHJhbS5yb3dzWzBdLmJhc2UuYmFsYW5jZTtcbiAgICAgICAgICAgIGJhc2UgPSArYmFzZVN0cmluZy5zdWJzdHIoMCwgYmFzZVN0cmluZy5pbmRleE9mKCcgJykpOyAvLyBBbW91bnQgb2YgRU9TIGluIHRoZSBSQU0gY29sbGVjdG9yXG5cbiAgICAgICAgICAgIHF1b3RlU3RyaW5nID0gcmFtLnJvd3NbMF0ucXVvdGUuYmFsYW5jZTtcbiAgICAgICAgICAgIHF1b3RlID0gcXVvdGVTdHJpbmcuc3Vic3RyKDAsIHF1b3RlU3RyaW5nLmluZGV4T2YoJyAnKSk7IC8vIFByaWNlIGluIGtiXG5cbiAgICAgICAgICAgIHByaWNlID0gcXVvdGUgLyBiYXNlO1xuICAgICAgICAgICAgcmFtUHJpY2VFb3MgPSBOdW1iZXIocHJpY2UudG9GaXhlZCg4KSkgKiAxMDI0O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmFtUHJpY2VFb3MpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0NS50MCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgMCk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMCwgMTNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSYW1QcmljZUluRW9zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEVvc1RvcFN0YWtlcyhfeCkge1xuICByZXR1cm4gX2dldEVvc1RvcFN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RW9zVG9wU3Rha2VzKCkge1xuICBfZ2V0RW9zVG9wU3Rha2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGxpbWl0KSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbGltaXQgPSA1MDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5saWdodEFwaS5nZXRfdG9wc3Rha2UobGltaXQpKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRFb3NUb3BTdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW9zVG9wUmFtcyhfeDIpIHtcbiAgcmV0dXJuIF9nZXRFb3NUb3BSYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRFb3NUb3BSYW1zKCkge1xuICBfZ2V0RW9zVG9wUmFtcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIobGltaXQpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbGltaXQgPSA1MDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMubGlnaHRBcGkuZ2V0X3RvcHJhbShsaW1pdCkpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RW9zVG9wUmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50TmFtZUJpZHMoX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9nZXRDdXJyZW50TmFtZUJpZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEN1cnJlbnROYW1lQmlkcygpIHtcbiAgX2dldEN1cnJlbnROYW1lQmlkcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdCwgcm93cywgbW9yZSwgbmV4dF9rZXk7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGxvd2VyX2JvdW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVwcGVyX2JvdW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICduYW1lYmlkcycsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGxvd2VyX2JvdW5kICYmIGxvd2VyX2JvdW5kLmxlbmd0aCA8PSAxMiA/IGVuY29kZU5hbWUobG93ZXJfYm91bmQsIHRydWUpIDogbG93ZXJfYm91bmQsXG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiB1cHBlcl9ib3VuZCAmJiB1cHBlcl9ib3VuZC5sZW5ndGggPD0gMTIgPyBlbmNvZGVOYW1lKHVwcGVyX2JvdW5kLCB0cnVlKSA6IHVwcGVyX2JvdW5kLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogMSxcbiAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5yb3dzO1xuICAgICAgICAgICAgbW9yZSA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5tb3JlO1xuICAgICAgICAgICAgbmV4dF9rZXkgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QubmV4dF9rZXk7XG5cbiAgICAgICAgICAgIGlmICghbW9yZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gcm93cztcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50TmFtZUJpZHMobmV4dF9rZXksIHVwcGVyX2JvdW5kKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDMudDEgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfY29udGV4dDMudDAuY29uY2F0LmNhbGwoX2NvbnRleHQzLnQwLCBfY29udGV4dDMudDEpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEN1cnJlbnROYW1lQmlkcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgY2hhaW5Ub1JleE1hcCA9IHtcbiAganVuZ2xlOiAnanVuZ2xlJyxcbiAgYm9zOiAnYm9zJyxcbiAgZW9zOiAnbWFpbm5ldCcsXG4gIHRlbG9zOiAndGVsb3MnXG59O1xuZnVuY3Rpb24gZ2V0UmV4UXVldWVkKF94KSB7XG4gIHJldHVybiBfZ2V0UmV4UXVldWVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXhRdWV1ZWQoKSB7XG4gIF9nZXRSZXhRdWV1ZWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdyZXhxdWV1ZScsXG4gICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Qucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCAmJiByb3dzWzBdLm93bmVyID09PSBhY2NvdW50KSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgOV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJleFF1ZXVlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXhQb29sKCkge1xuICByZXR1cm4gX2dldFJleFBvb2wuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJleFBvb2woKSB7XG4gIF9nZXRSZXhQb29sID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Miwgcm93cywgcG9vbCwgYXNzZXRUb051bWJlciwgdG90YWxfbGVudCwgdG90YWxfbGVuZGFibGUsIHRvdGFsX3VubGVudCwgdG90YWxfcmV4LCB0b3RhbF9yZW50LCBsZW50X3BlcmNlbnQsIHJleF9wcmljZSwgcmVzb3VyY2VfcHJpY2U7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdyZXhwb29sJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QyID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Mi5yb3dzO1xuICAgICAgICAgICAgcG9vbCA9IHJvd3NbMF07XG5cbiAgICAgICAgICAgIGFzc2V0VG9OdW1iZXIgPSBmdW5jdGlvbiBhc3NldFRvTnVtYmVyKGFzc2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoYXNzZXQuc3BsaXQoJyAnKVswXSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0b3RhbF9sZW50ID0gYXNzZXRUb051bWJlcihwb29sLnRvdGFsX2xlbnQpO1xuICAgICAgICAgICAgdG90YWxfbGVuZGFibGUgPSBhc3NldFRvTnVtYmVyKHBvb2wudG90YWxfbGVuZGFibGUpO1xuICAgICAgICAgICAgdG90YWxfdW5sZW50ID0gYXNzZXRUb051bWJlcihwb29sLnRvdGFsX3VubGVudCk7XG4gICAgICAgICAgICB0b3RhbF9yZXggPSBhc3NldFRvTnVtYmVyKHBvb2wudG90YWxfcmV4KTtcbiAgICAgICAgICAgIHRvdGFsX3JlbnQgPSBhc3NldFRvTnVtYmVyKHBvb2wudG90YWxfcmVudCk7XG4gICAgICAgICAgICBsZW50X3BlcmNlbnQgPSBtdWx0aXBseShkaXZpZGUodG90YWxfbGVudCwgdG90YWxfbGVuZGFibGUpLCAxMDApO1xuICAgICAgICAgICAgcmV4X3ByaWNlID0gK2RpdmlkZSh0b3RhbF9sZW5kYWJsZSwgdG90YWxfcmV4KTtcbiAgICAgICAgICAgIHJlc291cmNlX3ByaWNlID0gK2RpdmlkZSh0b3RhbF91bmxlbnQsIHRvdGFsX3JlbnQgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgdmVyc2lvbjogcG9vbC52ZXJzaW9uLFxuICAgICAgICAgICAgICBuYW1lYmlkX3Byb2NlZWRzOiBhc3NldFRvTnVtYmVyKHBvb2wubmFtZWJpZF9wcm9jZWVkcyksXG4gICAgICAgICAgICAgIGxvYW5fbnVtOiBwb29sLmxvYW5fbnVtLFxuICAgICAgICAgICAgICB0b3RhbF9sZW50OiB0b3RhbF9sZW50LFxuICAgICAgICAgICAgICB0b3RhbF91bmxlbnQ6IHRvdGFsX3VubGVudCxcbiAgICAgICAgICAgICAgdG90YWxfcmVudDogdG90YWxfcmVudCxcbiAgICAgICAgICAgICAgdG90YWxfbGVuZGFibGU6IHRvdGFsX2xlbmRhYmxlLFxuICAgICAgICAgICAgICB0b3RhbF9yZXg6IHRvdGFsX3JleCxcbiAgICAgICAgICAgICAgbGVudF9wZXJjZW50OiBsZW50X3BlcmNlbnQsXG4gICAgICAgICAgICAgIHJleF9wcmljZTogcmV4X3ByaWNlLFxuICAgICAgICAgICAgICByZXNvdXJjZV9wcmljZTogcmVzb3VyY2VfcHJpY2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJleFBvb2wuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmV4QmFsYW5jZShfeDIpIHtcbiAgcmV0dXJuIF9nZXRSZXhCYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXhCYWxhbmNlKCkge1xuICBfZ2V0UmV4QmFsYW5jZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QzLCByb3dzLCBiYWw7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdyZXhiYWwnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90MyA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDMucm93cztcbiAgICAgICAgICAgIGJhbCA9IHJvd3NbMF07XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBiYWwub3duZXIgPT09IGFjY291bnQgPyBiYWwgOiB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmV4QmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXhDcHVMb2FucyhfeDMpIHtcbiAgcmV0dXJuIF9nZXRSZXhDcHVMb2Fucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmV4Q3B1TG9hbnMoKSB7XG4gIF9nZXRSZXhDcHVMb2FucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q0LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAnY3B1bG9hbicsXG4gICAgICAgICAgICAgIHRhYmxlX2tleTogJ2J5b3duZXInLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDAsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDQucm93cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5mcm9tID09PSBhY2NvdW50O1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmV4Q3B1TG9hbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmV4TmV0TG9hbnMoX3g0KSB7XG4gIHJldHVybiBfZ2V0UmV4TmV0TG9hbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJleE5ldExvYW5zKCkge1xuICBfZ2V0UmV4TmV0TG9hbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90NSwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ25ldGxvYW4nLFxuICAgICAgICAgICAgICB0YWJsZV9rZXk6ICdieW93bmVyJyxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpNjQnLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDUgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1LnJvd3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuZnJvbSA9PT0gYWNjb3VudDtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJleE5ldExvYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEVvc0RlcG9zaXRlZEludG9SZXgoX3g1KSB7XG4gIHJldHVybiBfZ2V0RW9zRGVwb3NpdGVkSW50b1JleC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RW9zRGVwb3NpdGVkSW50b1JleCgpIHtcbiAgX2dldEVvc0RlcG9zaXRlZEludG9SZXggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Niwgcm93cywgcm93O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAncmV4ZnVuZCcsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q2ID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Ni5yb3dzO1xuICAgICAgICAgICAgcm93ID0gcm93c1swXTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHJvdy5vd25lciA9PT0gYWNjb3VudCA/IE51bWJlcihyb3cuYmFsYW5jZS5zcGxpdCgnICcpWzBdKSA6IDApO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RW9zRGVwb3NpdGVkSW50b1JleC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXhSZXR1cm5SYXRlKF94Nikge1xuICByZXR1cm4gX2dldFJleFJldHVyblJhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJleFJldHVyblJhdGUoKSB7XG4gIF9nZXRSZXhSZXR1cm5SYXRlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNyh0eXBlKSB7XG4gICAgdmFyIGNoYWluLCBfeWllbGQkdGhpcyRwb3N0LCBkYXRhO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdHlwZSA9ICdtcHInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFpbiA9IGNoYWluVG9SZXhNYXBbdGhpcy5jb25zdGFudHMuQ0hBSU5dO1xuXG4gICAgICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KCdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vZ3JhcGhxbC92MWFscGhhMS9ncmFwaHFsJywge1xuICAgICAgICAgICAgICBxdWVyeTogXCJxdWVyeSB7XFxuICAgICAgICBcIiArIGNoYWluICsgXCJfXCIgKyB0eXBlICsgXCIge1xcbiAgICAgICAgICBcIiArIHR5cGUgKyBcIlxcbiAgICAgICAgfVxcbiAgICAgIH1cIixcbiAgICAgICAgICAgICAgdmFyaWFibGVzOiBudWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHBvc3QgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgIGRhdGEgPSBfeWllbGQkdGhpcyRwb3N0LmRhdGE7XG5cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgTWF0aC5hYnMoZGF0YVtjaGFpbiArIFwiX1wiICsgdHlwZV1bMF1bdHlwZV0pKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCAwKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgMCk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmV4UmV0dXJuUmF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXhQcmljZUNoYXJ0KCkge1xuICByZXR1cm4gX2dldFJleFByaWNlQ2hhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJleFByaWNlQ2hhcnQoKSB7XG4gIF9nZXRSZXhQcmljZUNoYXJ0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICB2YXIgY2hhaW4sIGN1cnJlbnRfdGltZSwgc2V2ZW5fZGF5c19hZ28sIF95aWVsZCR0aGlzJHBvc3QyLCBkYXRhO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNoYWluID0gY2hhaW5Ub1JleE1hcFt0aGlzLmNvbnN0YW50cy5DSEFJTl07XG5cbiAgICAgICAgICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRfdGltZSA9IGZvcm1hdERhdGUodXRjVGltZSgpKTtcbiAgICAgICAgICAgIHNldmVuX2RheXNfYWdvID0gZm9ybWF0RGF0ZSh1dGNUaW1lKHN0YXJ0RGF0ZSh0aW1lKCksIDcpKSk7XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KCdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vZ3JhcGhxbC92MWFscGhhMS9ncmFwaHFsJywge1xuICAgICAgICAgICAgICBxdWVyeTogXCJxdWVyeSB7XFxuICAgICAgICBcIiArIGNoYWluICsgXCJfcHJpY2VjaGFydChhcmdzOiB7XFxuICAgICAgICAgIGZyb21fdGltZTogXFxcIlwiICsgc2V2ZW5fZGF5c19hZ28gKyBcIlxcXCIsXFxuICAgICAgICAgIHRvX3RpbWU6IFxcXCJcIiArIGN1cnJlbnRfdGltZSArIFwiXFxcIlxcbiAgICAgICAgfSkge1xcbiAgICAgICAgICB0XFxuICAgICAgICAgIG9cXG4gICAgICAgICAgaFxcbiAgICAgICAgICBsXFxuICAgICAgICAgIGNcXG4gICAgICAgIH1cXG4gICAgICB9XCIsXG4gICAgICAgICAgICAgIHZhcmlhYmxlczogbnVsbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRwb3N0MiA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgZGF0YSA9IF95aWVsZCR0aGlzJHBvc3QyLmRhdGE7XG5cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YVtjaGFpbiArIFwiX3ByaWNlY2hhcnRcIl0pO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmV4UHJpY2VDaGFydC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRFb3NCYWxhbmNlKF94KSB7XG4gIHJldHVybiBfZ2V0RW9zQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RW9zQmFsYW5jZSgpIHtcbiAgX2dldEVvc0JhbGFuY2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYWNjb3VudE5hbWUpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF9jLCBiYWxhbmNlO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X2N1cnJlbmN5X2JhbGFuY2UodGhpcy5jb25zdGFudHMuRU9TSU9fVE9LRU4sIGFjY291bnROYW1lLCB0aGlzLmNvbnN0YW50cy5DT1JFX1NZTUJPTCk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X2MgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgYmFsYW5jZSA9IF95aWVsZCR0aGlzJHJwYyRnZXRfY1swXTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYmFsYW5jZSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RW9zQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRUb2tlbkJhbGFuY2UoX3gyLCBfeDMsIF94NCkge1xuICByZXR1cm4gX2dldFRva2VuQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSAvLyBHZXQgQWNjb3VudCBUb2tlbnNcblxuZnVuY3Rpb24gX2dldFRva2VuQmFsYW5jZSgpIHtcbiAgX2dldFRva2VuQmFsYW5jZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoY29udHJhY3QsIGFjY291bnROYW1lLCBzeW1ib2wpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X2N1cnJlbmN5X2JhbGFuY2UoY29udHJhY3QsIGFjY291bnROYW1lLCBzeW1ib2wpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXN1bHRbMF0pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRUb2tlbkJhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWNjb3VudFRva2VucyhfeDUpIHtcbiAgcmV0dXJuIF9nZXRBY2NvdW50VG9rZW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY2NvdW50VG9rZW5zKCkge1xuICBfZ2V0QWNjb3VudFRva2VucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYWNjb3VudE5hbWUpIHtcbiAgICB2YXIgYWNjb3VudEJhbGFuY2VzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoYWNjb3VudEJhbGFuY2VzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpZ2h0R2V0VG9rZW5zKGFjY291bnROYW1lKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGFjY291bnRCYWxhbmNlcyA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaWYgKGFjY291bnRCYWxhbmNlcykge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbkdldFRva2Vuc0ZvckFjY291bnQoYWNjb3VudE5hbWUpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgYWNjb3VudEJhbGFuY2VzID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBhY2NvdW50QmFsYW5jZXMgfHwgW10pO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWNjb3VudFRva2Vucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBsaWdodEdldFRva2VucyhfeDYpIHtcbiAgcmV0dXJuIF9saWdodEdldFRva2Vucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbGlnaHRHZXRUb2tlbnMoKSB7XG4gIF9saWdodEdldFRva2VucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRsaWdodEFwaSQsIGJhbGFuY2VzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpZ2h0QXBpLmdldF9iYWxhbmNlcyhhY2NvdW50KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGxpZ2h0QXBpJCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgYmFsYW5jZXMgPSBfeWllbGQkdGhpcyRsaWdodEFwaSQuYmFsYW5jZXM7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBiYWxhbmNlcy5tYXAoZnVuY3Rpb24gKGJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeTogYmFsYW5jZS5jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IE51bWJlcihiYWxhbmNlLmFtb3VudCksXG4gICAgICAgICAgICAgICAgY29udHJhY3Q6IGJhbGFuY2UuY29udHJhY3QsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IE51bWJlcihiYWxhbmNlLmRlY2ltYWxzKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbGlnaHRHZXRUb2tlbnMgZXJyb3InLCBfY29udGV4dDQudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1swLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfbGlnaHRHZXRUb2tlbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gaHlwZXJpb25HZXRUb2tlbnNGb3JBY2NvdW50KF94Nykge1xuICByZXR1cm4gX2h5cGVyaW9uR2V0VG9rZW5zRm9yQWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaHlwZXJpb25HZXRUb2tlbnNGb3JBY2NvdW50KCkge1xuICBfaHlwZXJpb25HZXRUb2tlbnNGb3JBY2NvdW50ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJGh5cGVyaW9uJCwgdG9rZW5zO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uLmdldF90b2tlbnMoYWNjb3VudCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRoeXBlcmlvbiQgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIHRva2VucyA9IF95aWVsZCR0aGlzJGh5cGVyaW9uJC50b2tlbnM7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5OiB0b2tlbi5zeW1ib2wsXG4gICAgICAgICAgICAgICAgYW1vdW50OiBOdW1iZXIodG9rZW4uYW1vdW50KSxcbiAgICAgICAgICAgICAgICBjb250cmFjdDogdG9rZW4uY29udHJhY3QsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IE51bWJlcih0b2tlbi5wcmVjaXNpb24pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdoeXBlcmlvbkdldFRva2Vuc0ZvckFjY291bnQgZXJyb3InLCBfY29udGV4dDUudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1swLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfaHlwZXJpb25HZXRUb2tlbnNGb3JBY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFRva2VuU3VwcGx5KF94OCwgX3g5KSB7XG4gIHJldHVybiBfZ2V0VG9rZW5TdXBwbHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFRva2VuU3VwcGx5KCkge1xuICBfZ2V0VG9rZW5TdXBwbHkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGNvbnRyYWN0LCBzeW1ib2wpIHtcbiAgICB2YXIgc3RhdHMsIF9zdGF0cyRzeW1ib2wsIHN1cHBseSwgbWF4X3N1cHBseTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X2N1cnJlbmN5X3N0YXRzKGNvbnRyYWN0LCBzeW1ib2wpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RhdHMgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIF9zdGF0cyRzeW1ib2wgPSBzdGF0c1tzeW1ib2xdLCBzdXBwbHkgPSBfc3RhdHMkc3ltYm9sLnN1cHBseSwgbWF4X3N1cHBseSA9IF9zdGF0cyRzeW1ib2wubWF4X3N1cHBseTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgc3VwcGx5OiBzdXBwbHkgPyArc3VwcGx5LnNwbGl0KCcgJylbMF0gOiAwLFxuICAgICAgICAgICAgICBtYXhfc3VwcGx5OiBtYXhfc3VwcGx5ID8gK21heF9zdXBwbHkuc3BsaXQoJyAnKVswXSA6IDBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gX2NvbnRleHQ2W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDYudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBzdXBwbHk6IDAsXG4gICAgICAgICAgICAgIG1heF9zdXBwbHk6IDBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzAsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRUb2tlblN1cHBseS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRIaXN0b3J5VHJhbnNhY3Rpb24oX3gsIF94Mikge1xuICByZXR1cm4gX2dldEhpc3RvcnlUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0SGlzdG9yeVRyYW5zYWN0aW9uKCkge1xuICBfZ2V0SGlzdG9yeVRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKHR4SWQsIGJsb2NrSGludCkge1xuICAgIHZhciBlb3NUcmFuc2FjdGlvbnMsIHR4O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChibG9ja0hpbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBibG9ja0hpbnQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlb3NUcmFuc2FjdGlvbnMgPSBuZXcgSnNvblJwYyh0aGlzLmNvbnN0YW50cy5UUkFOU0FDVElPTlNfRU5EUE9JTlRTKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGVvc1RyYW5zYWN0aW9ucy5oaXN0b3J5X2dldF90cmFuc2FjdGlvbih0eElkLCBibG9ja0hpbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdHggPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAodHgpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RYIG5vdCBmb3VuZCcpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBoaXN0b3J5VHJhbnNmb3JtVHJhbnNhY3Rpb24odHgpKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRIaXN0b3J5VHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmZXJyZWRUcmFuc2FjdGlvbihfeDMpIHtcbiAgcmV0dXJuIF9nZXREZWZlcnJlZFRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREZWZlcnJlZFRyYW5zYWN0aW9uKCkge1xuICBfZ2V0RGVmZXJyZWRUcmFuc2FjdGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIodHhJZCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3MsIHRyYW5zYWN0aW9ucztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3NjaGVkdWxlZF90cmFuc2FjdGlvbnModHJ1ZSwgdHhJZCwgMSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3MgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfcy50cmFuc2FjdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9ucy5sZW5ndGggPiAwICYmIHRyYW5zYWN0aW9uc1swXS50cnhfaWQuc3Vic3RyaW5nKDAsIDYpID09PSB0eElkLnN1YnN0cmluZygwLCA2KSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgaGlzdG9yeVRyYW5zZm9ybURlZmVycmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25zWzBdKSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7fSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREZWZlcnJlZFRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEh5cGVyaW9uVHJhbnNhY3Rpb24oX3g0KSB7XG4gIHJldHVybiBfZ2V0SHlwZXJpb25UcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0SHlwZXJpb25UcmFuc2FjdGlvbigpIHtcbiAgX2dldEh5cGVyaW9uVHJhbnNhY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGlkKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5IWVBFUklPTl9VUkwpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb24uZ2V0X3RyYW5zYWN0aW9uKGlkKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsQnVpbGRlcih0aGlzLmNvbnN0YW50cy5BUElfVVJMLCAnaHlwZXJpb24nLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdnZXRfdHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGlmICghKCFyZXN1bHQgfHwgIXJlc3VsdC5hY3Rpb25zIHx8ICFyZXN1bHQuYWN0aW9ucy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RYIG5vdCBmb3VuZCcpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIGh5cGVyaW9uVHJhbnNmb3JtVHJhbnNhY3Rpb24ocmVzdWx0KSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0SHlwZXJpb25UcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVRyYW5zYWN0aW9uU2V0dGluZ3MoX3g1LCBfeDYsIF94Nykge1xuICByZXR1cm4gX2dlbmVyYXRlVHJhbnNhY3Rpb25TZXR0aW5ncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVUcmFuc2FjdGlvblNldHRpbmdzKCkge1xuICBfZ2VuZXJhdGVUcmFuc2FjdGlvblNldHRpbmdzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChleHBpcmVTZWNvbmRzLCBibG9ja3NCZWhpbmQsIGRlbGF5U2VjKSB7XG4gICAgdmFyIGluZm8sIHJlZkJsb2NrLCByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChleHBpcmVTZWNvbmRzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgZXhwaXJlU2Vjb25kcyA9IDMwMDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChibG9ja3NCZWhpbmQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBibG9ja3NCZWhpbmQgPSAxMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlbGF5U2VjID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgZGVsYXlTZWMgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X2luZm8oKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGluZm8gPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X2Jsb2NrKGluZm8uaGVhZF9ibG9ja19udW0gLSBibG9ja3NCZWhpbmQpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJlZkJsb2NrID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSBTZXJpYWxpemUudHJhbnNhY3Rpb25IZWFkZXIocmVmQmxvY2ssIGV4cGlyZVNlY29uZHMpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgbWF4X25ldF91c2FnZV93b3JkczogMCxcbiAgICAgICAgICAgICAgbWF4X2NwdV91c2FnZV9tczogMCxcbiAgICAgICAgICAgICAgZGVsYXlfc2VjOiBkZWxheVNlYyxcbiAgICAgICAgICAgICAgY29udGV4dF9mcmVlX2FjdGlvbnM6IFtdLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXSxcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb25fZXh0ZW5zaW9uczogW11cbiAgICAgICAgICAgIH0sIHJlc3VsdCkpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dlbmVyYXRlVHJhbnNhY3Rpb25TZXR0aW5ncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250cm9sbGVkQWNjb3VudHMoYWNjb3VudE5hbWUpIHtcbiAgaWYgKHRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVMuaW5jbHVkZXMoJ25hdGl2ZScpKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9uc1JwYy5oaXN0b3J5X2dldF9jb250cm9sbGVkX2FjY291bnRzKGFjY291bnROYW1lKTtcbiAgfSBlbHNlIGlmICh0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTLmluY2x1ZGVzKCdoeXBlcmlvbicpKSB7XG4gICAgdmFyIGFjdGlvbnNScGMgPSBuZXcgSnNvblJwYyhbdGhpcy5jb25zdGFudHMuSFlQRVJJT05fVVJMXSk7XG4gICAgcmV0dXJuIGFjdGlvbnNScGMuaGlzdG9yeV9nZXRfY29udHJvbGxlZF9hY2NvdW50cyhhY2NvdW50TmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9uTGlua3MoX3gpIHtcbiAgcmV0dXJuIF9nZXRQZXJtaXNzaW9uTGlua3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFBlcm1pc3Npb25MaW5rcygpIHtcbiAgX2dldFBlcm1pc3Npb25MaW5rcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhY2NvdW50KSB7XG4gICAgdmFyIGxpZ2h0QWNjb3VudCwgX3lpZWxkJHRoaXMkZ2V0LCBsaW5rZWRfcGVybWlzc2lvbnMsIF95aWVsZCR0aGlzJGh5cGVyaW9uJCwgbGlua3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLkxJR0hUX0FQSSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudExpZ2h0RGF0YShhY2NvdW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGxpZ2h0QWNjb3VudCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghbGlnaHRBY2NvdW50KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBsaWdodEFjY291bnQubGlua2F1dGgubWFwKGZ1bmN0aW9uIChhdXRoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhdXRoLnR5cGUsXG4gICAgICAgICAgICAgICAgY29udHJhY3Q6IGF1dGguY29kZSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uX25hbWU6IGF1dGgucmVxdWlyZW1lbnRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDk7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTLmluY2x1ZGVzKCdkZnVzZScpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMztcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmNvbnN0YW50cy5BUElfVVJMICsgXCIvZGZ1c2U/dHlwZT1zdGF0ZV9wZXJtaXNzaW9uX2xpbmtzJmFjY291bnQ9XCIgKyBhY2NvdW50KTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRnZXQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgbGlua2VkX3Blcm1pc3Npb25zID0gX3lpZWxkJHRoaXMkZ2V0LmxpbmtlZF9wZXJtaXNzaW9ucztcblxuICAgICAgICAgICAgaWYgKCFsaW5rZWRfcGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBsaW5rZWRfcGVybWlzc2lvbnMpO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMjtcbiAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxMyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MSk7XG5cbiAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTLmluY2x1ZGVzKCdoeXBlcmlvbicpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNjtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyOTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uLmdldF9saW5rcyhhY2NvdW50KTtcblxuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRoeXBlcmlvbiQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgbGlua3MgPSBfeWllbGQkdGhpcyRoeXBlcmlvbiQubGlua3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGxpbmtzLm1hcChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogbGluay5hY3Rpb24sXG4gICAgICAgICAgICAgICAgY29udHJhY3Q6IGxpbmsuY29kZSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uX25hbWU6IGxpbmsucGVybWlzc2lvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzNDtcbiAgICAgICAgICAgIF9jb250ZXh0LnQyID0gX2NvbnRleHRbXCJjYXRjaFwiXSgyNik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50Mik7XG5cbiAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Blcm1pc3Npb24gbGlua3Mgbm90IGF2YWlsYWJsZSBvbiBjaGFpbicpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzEsIDldLCBbMTMsIDIyXSwgWzI2LCAzNF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFBlcm1pc3Npb25MaW5rcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkZnVzZUdldEtleUFjY291bnRzKF94Mikge1xuICByZXR1cm4gX2RmdXNlR2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2RmdXNlR2V0S2V5QWNjb3VudHMoKSB7XG4gIF9kZnVzZUdldEtleUFjY291bnRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihrZXkpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkZ2V0MiwgYWNjb3VudF9uYW1lcztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5jb25zdGFudHMuQVBJX1VSTCArIFwiL2RmdXNlP3R5cGU9c3RhdGVfa2V5X2FjY291bnRzJnB1YmxpY0tleT1cIiArIGtleSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRnZXQyID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBhY2NvdW50X25hbWVzID0gX3lpZWxkJHRoaXMkZ2V0Mi5hY2NvdW50X25hbWVzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgYWNjb3VudF9uYW1lcyAmJiBhY2NvdW50X25hbWVzLmxlbmd0aCA/IGFjY291bnRfbmFtZXMgOiBbXSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gZGZ1c2UgYWNjb3VudHMgZm91bmQgYXNzb2NpYXRlZCB3aXRoIGtleTonLCBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9kZnVzZUdldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUdldEtleUFjY291bnRzKF94Mykge1xuICByZXR1cm4gX25hdGl2ZUdldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9uYXRpdmVHZXRLZXlBY2NvdW50cygpIHtcbiAgX25hdGl2ZUdldEtleUFjY291bnRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhrZXkpIHtcbiAgICB2YXIga2V5QWNjb3VudHMsIGZpb0FjY291bnQsIF95aWVsZCR0aGlzJHJwYyRnZXRfYSwgYWNjb3VudHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAwO1xuICAgICAgICAgICAga2V5QWNjb3VudHMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCFbJ2ZpbycsICdmaW8tdGVzdCddLmluY2x1ZGVzKHRoaXMuY29uc3RhbnRzLkNIQUlOKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaW9BY2NvdW50ID0gZmlvS2V5VG9BY3RvcihrZXkucmVwbGFjZSgnRU9TJywgJ0ZJTycpLCBOdW1lcmljLnN0cmluZ1RvUHVibGljS2V5KTtcblxuICAgICAgICAgICAgaWYgKGtleUFjY291bnRzLmluZGV4T2YoZmlvQWNjb3VudCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGtleUFjY291bnRzLnB1c2goZmlvQWNjb3VudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfYWNjb3VudHNfYnlfYXV0aG9yaXplcnMoW10sIFtrZXldKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfYSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgYWNjb3VudHMgPSBfeWllbGQkdGhpcyRycGMkZ2V0X2EuYWNjb3VudHM7XG4gICAgICAgICAgICBrZXlBY2NvdW50cyA9IEFycmF5LmZyb20obmV3IFNldChhY2NvdW50cy5tYXAoZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjY291bnQuYWNjb3VudF9uYW1lO1xuICAgICAgICAgICAgfSkpKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBrZXlBY2NvdW50cyk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNTtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQzLnQwKTtcbiAgICAgICAgICAgIHRocm93IF9jb250ZXh0My50MDtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCAxNV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX25hdGl2ZUdldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGh5cGVyaW9uR2V0S2V5QWNjb3VudHMoX3g0KSB7XG4gIHJldHVybiBfaHlwZXJpb25HZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaHlwZXJpb25HZXRLZXlBY2NvdW50cygpIHtcbiAgX2h5cGVyaW9uR2V0S2V5QWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGtleSkge1xuICAgIHZhciBsZWdhY3lQdWJsaWNLZXksIF95aWVsZCR0aGlzJGh5cGVyaW9uJDIsIGFjY291bnRfbmFtZXM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHRoaXMuaHlwZXJpb24pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIeXBlcmlvbiBBUEkgbm90IHN1cHBvcnRlZCcpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGVnYWN5UHVibGljS2V5ID0gS2V5LlB1YmxpY0tleS5mcm9tU3RyaW5nKGtleSkudG9MZWdhY3lTdHJpbmcoKTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uLmdldF9rZXlfYWNjb3VudHMobGVnYWN5UHVibGljS2V5KTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGh5cGVyaW9uJDIgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIGFjY291bnRfbmFtZXMgPSBfeWllbGQkdGhpcyRoeXBlcmlvbiQyLmFjY291bnRfbmFtZXM7XG5cbiAgICAgICAgICAgIGlmICghKGFjY291bnRfbmFtZXMgJiYgYWNjb3VudF9uYW1lcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBhY2NvdW50X25hbWVzKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGtleXMgZm91bmQnKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9oeXBlcmlvbkdldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGxpZ2h0R2V0S2V5QWNjb3VudHMoX3g1KSB7XG4gIHJldHVybiBfbGlnaHRHZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbGlnaHRHZXRLZXlBY2NvdW50cygpIHtcbiAgX2xpZ2h0R2V0S2V5QWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGtleSkge1xuICAgIHZhciBsaWdodENoYWluLCBhY2NvdW50c0J5Q2hhaW4sIGFjY291bnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAodGhpcy5saWdodEFwaSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpZ2h0IEFQSSBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsaWdodENoYWluID0gdGhpcy5jb25zdGFudHMuQ0hBSU4udG9Mb3dlckNhc2UoKS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlnaHRBcGkuZ2V0X2tleV9hY2NvdW50cyhrZXkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgYWNjb3VudHNCeUNoYWluID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICBhY2NvdW50cyA9IGFjY291bnRzQnlDaGFpbltsaWdodENoYWluXS5hY2NvdW50cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIEFycmF5LmZyb20obmV3IFNldChPYmplY3Qua2V5cyhhY2NvdW50cykpKSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9saWdodEdldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEtleUFjY291bnRzQnlUeXBlKF94NiwgX3g3KSB7XG4gIHJldHVybiBfZ2V0S2V5QWNjb3VudHNCeVR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8qKlxyXG4gKiBUcmllcyBhbGwgaGlzdG9yaWVzIHRvIGdldCBrZXlzLlxyXG4gKiBAcGFyYW0geyp9IGtleVxyXG4gKi9cblxuZnVuY3Rpb24gX2dldEtleUFjY291bnRzQnlUeXBlKCkge1xuICBfZ2V0S2V5QWNjb3VudHNCeVR5cGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGtleSwgdHlwZSkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSB0eXBlO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSBfY29udGV4dDYudDAgPT09ICdkZnVzZScgPyAzIDogX2NvbnRleHQ2LnQwID09PSAnbmF0aXZlJyA/IDYgOiBfY29udGV4dDYudDAgPT09ICdoeXBlcmlvbicgPyA5IDogX2NvbnRleHQ2LnQwID09PSAnbGlnaHQnID8gMTIgOiAxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGZ1c2VHZXRLZXlBY2NvdW50cyhrZXkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ2LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlR2V0S2V5QWNjb3VudHMoa2V5KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ni5zZW50KTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbkdldEtleUFjY291bnRzKGtleSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ2LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saWdodEdldEtleUFjY291bnRzKGtleSk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ2LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEtleUFjY291bnRzQnlUeXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEtleUFjY291bnRzKF94OCkge1xuICByZXR1cm4gX2dldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlBY2NvdW50cygpIHtcbiAgX2dldEtleUFjY291bnRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhrZXkpIHtcbiAgICB2YXIgX2ksIF9hcnIsIGhpc3RvcnlUeXBlLCByZXM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdGSU8nKSkge1xuICAgICAgICAgICAgICBrZXkgPSBrZXkucmVwbGFjZSgnRklPJywgJ0VPUycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaSA9IDAsIF9hcnIgPSBbdGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFU1swXSwgJ2xpZ2h0J10uY29uY2F0KHRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVMuc2xpY2UoMSkpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKCEoX2kgPCBfYXJyLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhpc3RvcnlUeXBlID0gX2FycltfaV07XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDQ7XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXlBY2NvdW50c0J5VHlwZShrZXksIGhpc3RvcnlUeXBlKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0Ny5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxMjtcbiAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ3LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwiY29udGludWVcIiwgMTYpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTcsIHRoaXMsIFtbNCwgMTJdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlBY2NvdW50c0ZvckFsbENoYWlucyhfeDkpIHtcbiAgcmV0dXJuIF9nZXRLZXlBY2NvdW50c0ZvckFsbENoYWlucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHJlc29sdmVzIGFsbCByZXF1aXJlZCBwZXJtaXNzaW9uc1xyXG4gKiBAcGFyYW0gYWNjb3VudE5hbWVcclxuICogQHBhcmFtIHBlcm1pc3Npb25cclxuICovXG5cbmZ1bmN0aW9uIF9nZXRLZXlBY2NvdW50c0ZvckFsbENoYWlucygpIHtcbiAgX2dldEtleUFjY291bnRzRm9yQWxsQ2hhaW5zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOChrZXkpIHtcbiAgICB2YXIga2V5QWNjb3VudHMsIGNvbWJpbmVkO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAodGhpcy5saWdodEFwaSkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpZ2h0IEFQSSBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDI7XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saWdodEFwaS5nZXRfYWxsX2tleV9hY2NvdW50cyhrZXkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAga2V5QWNjb3VudHMgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgIGNvbWJpbmVkID0ga2V5QWNjb3VudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgb2JqKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIE9iamVjdC5lbnRyaWVzKGNvbWJpbmVkKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX3JlZikge1xuICAgICAgICAgICAgICB2YXIgY2hhaW4gPSBfcmVmWzBdLFxuICAgICAgICAgICAgICAgICAgYWNjb3VudHNCeU5hbWUgPSBfcmVmWzFdLmFjY291bnRzO1xuICAgICAgICAgICAgICB2YXIgYWNjb3VudHMgPSBPYmplY3Qua2V5cyhhY2NvdW50c0J5TmFtZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIFtdKSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAxMDtcbiAgICAgICAgICAgIF9jb250ZXh0OC50MCA9IF9jb250ZXh0OFtcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ4LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlOCwgdGhpcywgW1syLCAxMF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEtleUFjY291bnRzRm9yQWxsQ2hhaW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJlcXVpcmVkQWNjb3VudHMoX3gxMCwgX3gxMSwgX3gxMiwgX3gxMywgX3gxNCkge1xuICByZXR1cm4gX2dldFJlcXVpcmVkQWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVkQWNjb3VudHMoKSB7XG4gIF9nZXRSZXF1aXJlZEFjY291bnRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOShhY2NvdW50TmFtZSwgcGVybWlzc2lvbk5hbWUsIGFsbFBlcm1pc3Npb25zLCBjdXJyZW50TGV2ZWwsIG1heExldmVsKSB7XG4gICAgdmFyIGFjY291bnRJbmZvLCBfaXRlcmF0b3IsIF9zdGVwLCBwZXJtaXNzaW9uLCBhY2NvdW50cywgcHJvZHVjZXJzLCBfaXRlcmF0b3IyLCBfc3RlcDIsIGFjY291bnQ7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGFsbFBlcm1pc3Npb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgYWxsUGVybWlzc2lvbnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXhMZXZlbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG1heExldmVsID0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudChhY2NvdW50TmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBhY2NvdW50SW5mbyA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY2NvdW50SW5mby5wZXJtaXNzaW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZiAoKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAzMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBlcm1pc3Npb24gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKCEocGVybWlzc2lvbi5wZXJtX25hbWUgPT09IHBlcm1pc3Npb25OYW1lKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDI5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IGFsbCBhY2NvdW50IChlLmcuIGd5eSwgaGFydG9ubywgdGhvbXBzb24pXG4gICAgICAgICAgICBhY2NvdW50cyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIShhY2NvdW50TmFtZSA9PT0gJ2Vvc2lvJyAmJiBbJ293bmVyJywgJ2FjdGl2ZSddLmluY2x1ZGVzKHBlcm1pc3Npb24ucGVybV9uYW1lKSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9kdWNlcnNMb2NhbCgpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHByb2R1Y2VycyA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgYWNjb3VudHMgPSBwcm9kdWNlcnMubWFwKGZ1bmN0aW9uIChwcm9kdWNlcikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdG9yOiBwcm9kdWNlci5vd25lcixcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uOiAnYWN0aXZlJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYWNjb3VudHMgPSBwZXJtaXNzaW9uLnJlcXVpcmVkX2F1dGguYWNjb3VudHMubWFwKGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY291bnQucGVybWlzc2lvbjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFsbFBlcm1pc3Npb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGFjdG9yOiBhY2NvdW50TmFtZSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uOiBwZXJtaXNzaW9uTmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gLy8gRm9yIGVhY2ggYWNjb3VudCAoZS5nLiBoYXJ0b25vKVxuXG5cbiAgICAgICAgICAgIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjY291bnRzKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICBpZiAoKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDI5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWNjb3VudCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKCEoY3VycmVudExldmVsIDwgbWF4TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDI0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVxdWlyZWRBY2NvdW50cyhhY2NvdW50LmFjdG9yLCBhY2NvdW50LnBlcm1pc3Npb24sIGFsbFBlcm1pc3Npb25zLCArK2N1cnJlbnRMZXZlbCwgbWF4TGV2ZWwpO1xuXG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICBhbGxQZXJtaXNzaW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgYWN0b3I6IGFjY291bnQuYWN0b3IsXG4gICAgICAgICAgICAgIHBlcm1pc3Npb246IGFjY291bnQucGVybWlzc2lvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIGFsbFBlcm1pc3Npb25zKTtcblxuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZXF1aXJlZEFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJzRnJvbUtleXMoX3gxNSkge1xuICByZXR1cm4gX2dldFVzZXJzRnJvbUtleXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFVzZXJzRnJvbUtleXMoKSB7XG4gIF9nZXRVc2Vyc0Zyb21LZXlzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIoa2V5cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdXNlcnMsIHByb21pc2VzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXNlcnMgPSBbXTtcbiAgICAgICAgICAgIHByb21pc2VzID0ga2V5cy5tYXAoIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBhY2NvdW50X25hbWVzLCBwcm9taXNlczI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldEtleUFjY291bnRzKGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50X25hbWVzID0gX2NvbnRleHQxMS5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMyID0gYWNjb3VudF9uYW1lcy5tYXAoIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKGFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWNjb3VudEluZm8sIF9pdGVyYXRvcjMsIF9zdGVwMywgcGVybWlzc2lvbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRBY2NvdW50KGFjY291bnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudEluZm8gPSBfY29udGV4dDEwLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBldmVyeSBwZXJtaXNzaW9uLCBhZGQgdG8gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWNjb3VudEluZm8ucGVybWlzc2lvbnMpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMoKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbiA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBrZXkgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJtaXNzaW9uLnJlcXVpcmVkX2F1dGgua2V5cy5maW5kKGZ1bmN0aW9uIChwZXJtS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlcm1LZXkua2V5ID09PSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RvcjogYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb246IHBlcm1pc3Npb24ucGVybV9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MTcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTExKTtcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIHVzZXJzKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMTIpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0VXNlcnNGcm9tS2V5cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgQXBpQ2xhc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBcGlDbGFzcyhjaGFpbikge1xuICAgIHRoaXMucnBjID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWN0aW9uc1JwYyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFwaSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmh5cGVyaW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGlnaHRBcGkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5jb25zdGFudHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5odHRwID0gaHR0cDtcbiAgICB0aGlzLmdldCA9IGdldDtcbiAgICB0aGlzLnBvc3QgPSBwb3N0O1xuICAgIHRoaXMuZ2V0QWNjb3VudCA9IGdldEFjY291bnQ7XG4gICAgdGhpcy5nZXRHcmF2YXRhciA9IGdldEdyYXZhdGFyO1xuICAgIHRoaXMuc2VhcmNoQWNjb3VudCA9IHNlYXJjaEFjY291bnQ7XG4gICAgdGhpcy5nZXRQYXJlbnQgPSBnZXRQYXJlbnQ7XG4gICAgdGhpcy5nZXRBY2NvdW50TGlnaHREYXRhID0gZ2V0QWNjb3VudExpZ2h0RGF0YTtcbiAgICB0aGlzLmdldEFjdGlvbnNGcm9tTmF0aXZlID0gZ2V0QWN0aW9uc0Zyb21OYXRpdmU7XG4gICAgdGhpcy5nZXRBY3Rpb25zID0gZ2V0QWN0aW9ucztcbiAgICB0aGlzLmdldEFjdGlvbnNGcm9tRGZ1c2UgPSBnZXRBY3Rpb25zRnJvbURmdXNlO1xuICAgIHRoaXMuZ2V0QWN0aW9uc0Zyb21IeXBlcmlvbiA9IGdldEFjdGlvbnNGcm9tSHlwZXJpb247XG4gICAgdGhpcy5nZXREYXBwU3RhdHMgPSBnZXREYXBwU3RhdHM7XG4gICAgdGhpcy5nZXREc3BQYWNrYWdlcyA9IGdldERzcFBhY2thZ2VzO1xuICAgIHRoaXMuZ2V0RGFwcGhvZGxCYWxhbmNlID0gZ2V0RGFwcGhvZGxCYWxhbmNlO1xuICAgIHRoaXMuZ2V0RGFwcEJhbGFuY2UgPSBnZXREYXBwQmFsYW5jZTtcbiAgICB0aGlzLmdldERhcHBTdGFrZXMgPSBnZXREYXBwU3Rha2VzO1xuICAgIHRoaXMuZ2V0RGFwcGhvZGxTdGFrZXMgPSBnZXREYXBwaG9kbFN0YWtlcztcbiAgICB0aGlzLmdldERhcHBVbnN0YWtlcyA9IGdldERhcHBVbnN0YWtlcztcbiAgICB0aGlzLmdldERhcHBob2RsVW5zdGFrZXMgPSBnZXREYXBwaG9kbFVuc3Rha2VzO1xuICAgIHRoaXMuZ2V0RklPVm90ZXIgPSBnZXRGSU9Wb3RlcjtcbiAgICB0aGlzLmdldEZJT0FkZHJlc3NCeU5hbWUgPSBnZXRGSU9BZGRyZXNzQnlOYW1lO1xuICAgIHRoaXMuZ2V0RklPRG9tYWluQnlOYW1lID0gZ2V0RklPRG9tYWluQnlOYW1lO1xuICAgIHRoaXMuZ2V0TkZUc0J5RmlvQWRkcmVzcyA9IGdldE5GVHNCeUZpb0FkZHJlc3M7XG4gICAgdGhpcy5nZXREb21haW5zID0gZ2V0RG9tYWlucztcbiAgICB0aGlzLmdldEFkZHJlc3NlcyA9IGdldEFkZHJlc3NlcztcbiAgICB0aGlzLmdldEZJT1Byb2R1Y2VycyA9IGdldEZJT1Byb2R1Y2VycztcbiAgICB0aGlzLmdldEZJT1N1cHBseUJyZWFrZG93biA9IGdldEZJT1N1cHBseUJyZWFrZG93bjtcbiAgICB0aGlzLmdldEZJT0ZlZXMgPSBnZXRGSU9GZWVzO1xuICAgIHRoaXMuYWRkRklPRmVlVG9BY3Rpb25zID0gYWRkRklPRmVlVG9BY3Rpb25zO1xuICAgIHRoaXMuZ2V0RklPQWRkcmVzc2VzID0gZ2V0RklPQWRkcmVzc2VzO1xuICAgIHRoaXMuZ2V0RklPRG9tYWlucyA9IGdldEZJT0RvbWFpbnM7XG4gICAgdGhpcy5nZXRGSU9BZGRyZXNzZXNBbmREb21haW5zID0gZ2V0RklPQWRkcmVzc2VzQW5kRG9tYWlucztcbiAgICB0aGlzLmdldEZJT0JhbGFuY2UgPSBnZXRGSU9CYWxhbmNlO1xuICAgIHRoaXMuZ2V0Q29udHJvbGxlZEFjY291bnRzID0gZ2V0Q29udHJvbGxlZEFjY291bnRzO1xuICAgIHRoaXMuZ2V0UGVybWlzc2lvbkxpbmtzID0gZ2V0UGVybWlzc2lvbkxpbmtzO1xuICAgIHRoaXMuZGZ1c2VHZXRLZXlBY2NvdW50cyA9IGRmdXNlR2V0S2V5QWNjb3VudHM7XG4gICAgdGhpcy5uYXRpdmVHZXRLZXlBY2NvdW50cyA9IG5hdGl2ZUdldEtleUFjY291bnRzO1xuICAgIHRoaXMuaHlwZXJpb25HZXRLZXlBY2NvdW50cyA9IGh5cGVyaW9uR2V0S2V5QWNjb3VudHM7XG4gICAgdGhpcy5saWdodEdldEtleUFjY291bnRzID0gbGlnaHRHZXRLZXlBY2NvdW50cztcbiAgICB0aGlzLmdldEtleUFjY291bnRzQnlUeXBlID0gZ2V0S2V5QWNjb3VudHNCeVR5cGU7XG4gICAgdGhpcy5nZXRLZXlBY2NvdW50cyA9IGdldEtleUFjY291bnRzO1xuICAgIHRoaXMuZ2V0S2V5QWNjb3VudHNGb3JBbGxDaGFpbnMgPSBnZXRLZXlBY2NvdW50c0ZvckFsbENoYWlucztcbiAgICB0aGlzLmdldFJlcXVpcmVkQWNjb3VudHMgPSBnZXRSZXF1aXJlZEFjY291bnRzO1xuICAgIHRoaXMuZ2V0VXNlcnNGcm9tS2V5cyA9IGdldFVzZXJzRnJvbUtleXM7XG4gICAgdGhpcy5nZXRBbGxNc2lncyA9IGdldEFsbE1zaWdzO1xuICAgIHRoaXMucGFyc2VQYWNrZWRNc2lnQWN0aW9ucyA9IHBhcnNlUGFja2VkTXNpZ0FjdGlvbnM7XG4gICAgdGhpcy5wYXJzZVBhY2tlZE1zaWcgPSBwYXJzZVBhY2tlZE1zaWc7XG4gICAgdGhpcy5nZXRGdWxsTXNpZ1Byb3Bvc2FsID0gZ2V0RnVsbE1zaWdQcm9wb3NhbDtcbiAgICB0aGlzLmdldE1zaWdBcHByb3ZhbHMgPSBnZXRNc2lnQXBwcm92YWxzO1xuICAgIHRoaXMuZ2V0QWNjb3VudHNNc2lnUHJvcG9zYWxzID0gZ2V0QWNjb3VudHNNc2lnUHJvcG9zYWxzO1xuICAgIHRoaXMuaHlwZXJpb25HZXRNc2lnID0gaHlwZXJpb25HZXRNc2lnO1xuICAgIHRoaXMuZ2V0TXNpZ1Byb3Bvc2FsID0gZ2V0TXNpZ1Byb3Bvc2FsO1xuICAgIHRoaXMuZ2V0UmVudGJ3U3RhdGUgPSBnZXRSZW50YndTdGF0ZTtcbiAgICB0aGlzLmRlbGVnYXRlZEJhbmR3aWR0aCA9IGRlbGVnYXRlZEJhbmR3aWR0aDtcbiAgICB0aGlzLmdldEFjY291bnREZWxlZ2F0ZWRCYW5kd2lkdGggPSBnZXRBY2NvdW50RGVsZWdhdGVkQmFuZHdpZHRoO1xuICAgIHRoaXMuZ2V0QWNjb3VudFJlc291cmNlcyA9IGdldEFjY291bnRSZXNvdXJjZXM7XG4gICAgdGhpcy5nZXRSYW1QcmljZUluRW9zID0gZ2V0UmFtUHJpY2VJbkVvcztcbiAgICB0aGlzLmdldFJleFF1ZXVlZCA9IGdldFJleFF1ZXVlZDtcbiAgICB0aGlzLmdldFJleFBvb2wgPSBnZXRSZXhQb29sO1xuICAgIHRoaXMuZ2V0UmV4QmFsYW5jZSA9IGdldFJleEJhbGFuY2U7XG4gICAgdGhpcy5nZXRSZXhDcHVMb2FucyA9IGdldFJleENwdUxvYW5zO1xuICAgIHRoaXMuZ2V0UmV4TmV0TG9hbnMgPSBnZXRSZXhOZXRMb2FucztcbiAgICB0aGlzLmdldEVvc0RlcG9zaXRlZEludG9SZXggPSBnZXRFb3NEZXBvc2l0ZWRJbnRvUmV4O1xuICAgIHRoaXMuZ2V0UmV4UmV0dXJuUmF0ZSA9IGdldFJleFJldHVyblJhdGU7XG4gICAgdGhpcy5nZXRSZXhQcmljZUNoYXJ0ID0gZ2V0UmV4UHJpY2VDaGFydDtcbiAgICB0aGlzLmdldEVvc1RvcFN0YWtlcyA9IGdldEVvc1RvcFN0YWtlcztcbiAgICB0aGlzLmdldEVvc1RvcFJhbXMgPSBnZXRFb3NUb3BSYW1zO1xuICAgIHRoaXMuZ2V0Q3VycmVudE5hbWVCaWRzID0gZ2V0Q3VycmVudE5hbWVCaWRzO1xuICAgIHRoaXMuZ2V0RW9zQmFsYW5jZSA9IGdldEVvc0JhbGFuY2U7XG4gICAgdGhpcy5nZXRUb2tlbkJhbGFuY2UgPSBnZXRUb2tlbkJhbGFuY2U7XG4gICAgdGhpcy5oeXBlcmlvbkdldFRva2Vuc0ZvckFjY291bnQgPSBoeXBlcmlvbkdldFRva2Vuc0ZvckFjY291bnQ7XG4gICAgdGhpcy5nZXRUb2tlblN1cHBseSA9IGdldFRva2VuU3VwcGx5O1xuICAgIHRoaXMubGlnaHRHZXRUb2tlbnMgPSBsaWdodEdldFRva2VucztcbiAgICB0aGlzLmdldEFjY291bnRUb2tlbnMgPSBnZXRBY2NvdW50VG9rZW5zO1xuICAgIHRoaXMuZ2V0SGlzdG9yeVRyYW5zYWN0aW9uID0gZ2V0SGlzdG9yeVRyYW5zYWN0aW9uO1xuICAgIHRoaXMuZ2V0RGVmZXJyZWRUcmFuc2FjdGlvbiA9IGdldERlZmVycmVkVHJhbnNhY3Rpb247XG4gICAgdGhpcy5nZXRIeXBlcmlvblRyYW5zYWN0aW9uID0gZ2V0SHlwZXJpb25UcmFuc2FjdGlvbjtcbiAgICB0aGlzLmdlbmVyYXRlVHJhbnNhY3Rpb25TZXR0aW5ncyA9IGdlbmVyYXRlVHJhbnNhY3Rpb25TZXR0aW5ncztcbiAgICB0aGlzLmdldFByb3hpZXMgPSBnZXRQcm94aWVzO1xuICAgIHRoaXMuZ2V0Vm90ZXJzID0gZ2V0Vm90ZXJzO1xuICAgIHRoaXMuY2FsY3VsYXRlVm90ZVdlaWdodCA9IGNhbGN1bGF0ZVZvdGVXZWlnaHQ7XG4gICAgdGhpcy53ZWlnaHRlZFZvdGVUb051bWJlciA9IHdlaWdodGVkVm90ZVRvTnVtYmVyO1xuICAgIHRoaXMuZ2V0UHJveHlEYXRhID0gZ2V0UHJveHlEYXRhO1xuICAgIHRoaXMuZ2V0Vm90ZXIgPSBnZXRWb3RlcjtcbiAgICB0aGlzLmdldFByb2R1Y2VycyA9IGdldFByb2R1Y2VycztcbiAgICB0aGlzLmdldFByb2R1Y2Vyc0xvY2FsID0gZ2V0UHJvZHVjZXJzTG9jYWw7XG4gICAgdGhpcy5nZXRDaGFpblRhYmxlID0gZ2V0Q2hhaW5UYWJsZTtcbiAgICB0aGlzLmZldGNoS3ljQ291bnRyaWVzID0gZmV0Y2hLeWNDb3VudHJpZXM7XG4gICAgdGhpcy5jaGVja1VzZXJLeWNTdGF0dXMgPSBjaGVja1VzZXJLeWNTdGF0dXM7XG4gICAgdGhpcy5hcHBseUZvckt5YyA9IGFwcGx5Rm9yS3ljO1xuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xuICAgIHRoaXMuZ2V0QXZhaWxhYmxlRmVhdHVyZXMgPSBnZXRBdmFpbGFibGVGZWF0dXJlcztcbiAgICB0aGlzLm90Y1F1b3RlID0gb3RjUXVvdGU7XG4gICAgdGhpcy5vdGNPcmRlciA9IG90Y09yZGVyO1xuICAgIHRoaXMuZ2VuZXJhdGVBZGRyZXNzID0gZ2VuZXJhdGVBZGRyZXNzO1xuICAgIHRoaXMuZGVsZXRlQWRkcmVzcyA9IGRlbGV0ZUFkZHJlc3M7XG4gICAgdGhpcy53aXRoZHJhd01ldGFsID0gd2l0aGRyYXdNZXRhbDtcbiAgICB0aGlzLndpdGhkcmF3YWxIaXN0b3J5TWV0YWwgPSB3aXRoZHJhd2FsSGlzdG9yeU1ldGFsO1xuICAgIHRoaXMuZ2V0VG9rZW5QcmljZXMgPSBnZXRUb2tlblByaWNlcztcbiAgICB0aGlzLmdldFdpdGhkcmF3YWxGZWUgPSBnZXRXaXRoZHJhd2FsRmVlO1xuICAgIHRoaXMuZ2V0Q2hhaW5JbmZvID0gZ2V0Q2hhaW5JbmZvO1xuICAgIHRoaXMuY3JlYXRlQWNjb3VudCA9IGNyZWF0ZUFjY291bnQ7XG4gICAgdGhpcy5sb2dpbkFjY291bnQgPSBsb2dpbkFjY291bnQ7XG4gICAgdGhpcy5nZXRYcHJUb3RhbFN0YWtlZEFuZEFwciA9IGdldFhwclRvdGFsU3Rha2VkQW5kQXByO1xuICAgIHRoaXMuZ2V0WHByVm90ZXIgPSBnZXRYcHJWb3RlcjtcbiAgICB0aGlzLmdldFhwckFjY291bnRTdGFrZXMgPSBnZXRYcHJBY2NvdW50U3Rha2VzO1xuICAgIHRoaXMuZ2V0WHByQWNjb3VudFJlZnVuZCA9IGdldFhwckFjY291bnRSZWZ1bmQ7XG4gICAgdGhpcy5nZXRYcHJPcmFjbGVEYXRhID0gZ2V0WHByT3JhY2xlRGF0YTtcbiAgICB0aGlzLmdldEFsbE9yYWNsZUZlZWRzID0gZ2V0QWxsT3JhY2xlRmVlZHM7XG4gICAgdGhpcy5nZXRBbGxPcmFjbGVEYXRhID0gZ2V0QWxsT3JhY2xlRGF0YTtcbiAgICB0aGlzLmdldFNwZWNpZmljT3JhY2xlRGF0YSA9IGdldFNwZWNpZmljT3JhY2xlRGF0YTtcbiAgICB0aGlzLmdldFByb3RvbkF2YXRhciA9IGdldFByb3RvbkF2YXRhcjtcbiAgICB0aGlzLmdldFByb3RvbkF2YXRhcnMgPSBnZXRQcm90b25BdmF0YXJzO1xuXG4gICAgaWYgKGNoYWluKSB7XG4gICAgICBjb25zdGFudHMuaW5pdGlhbGl6ZShjaGFpbik7XG4gICAgICB0aGlzLmluaXRpYWxpemUoY29uc3RhbnRzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQXBpQ2xhc3MucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZShjb25zdGFudHMsIF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgcnBjRW5kcG9pbnRzID0gX3JlZi5ycGNFbmRwb2ludHMsXG4gICAgICAgIGFjdGlvbnNScGNFbmRwb2ludHMgPSBfcmVmLmFjdGlvbnNScGNFbmRwb2ludHMsXG4gICAgICAgIGxpZ2h0RW5kcG9pbnQgPSBfcmVmLmxpZ2h0RW5kcG9pbnQsXG4gICAgICAgIGh5cGVyaW9uRW5kcG9pbnQgPSBfcmVmLmh5cGVyaW9uRW5kcG9pbnQ7XG5cbiAgICB0aGlzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiAgICB0aGlzLnJwYyA9IG5ldyBKc29uUnBjKHJwY0VuZHBvaW50cyB8fCB0aGlzLmNvbnN0YW50cy5ERUZBVUxUX0VORFBPSU5UUyk7XG4gICAgdGhpcy5hY3Rpb25zUnBjID0gbmV3IEpzb25ScGMoYWN0aW9uc1JwY0VuZHBvaW50cyB8fCB0aGlzLmNvbnN0YW50cy5BQ1RJT05TX0VORFBPSU5UUyk7XG4gICAgdGhpcy5hcGkgPSBuZXcgQXBpKHtcbiAgICAgIHJwYzogdGhpcy5ycGNcbiAgICB9KTtcbiAgICB2YXIgbGlnaHRVcmwgPSBsaWdodEVuZHBvaW50IHx8IHRoaXMuY29uc3RhbnRzLkxJR0hUX0FQSTtcblxuICAgIGlmIChsaWdodFVybCkge1xuICAgICAgdGhpcy5saWdodEFwaSA9IG5ldyBKc29uUnBjJDEodGhpcy5jb25zdGFudHMuQ0hBSU4udG9Mb3dlckNhc2UoKS5yZXBsYWNlKCctJywgJycpLCB7XG4gICAgICAgIGVuZHBvaW50OiBsaWdodFVybFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGh5cGVyaW9uVXJsID0gaHlwZXJpb25FbmRwb2ludCB8fCB0aGlzLmNvbnN0YW50cy5IWVBFUklPTl9VUkw7XG5cbiAgICBpZiAoaHlwZXJpb25VcmwpIHtcbiAgICAgIHRoaXMuaHlwZXJpb24gPSBuZXcgSnNvblJwYyQyKGh5cGVyaW9uVXJsKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBBcGlDbGFzcztcbn0oKTtcblxuZXhwb3J0IHsgQXBpQ2xhc3MsIEt5Y1N0YXR1cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmVzbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBUeXBlU2NyaXB0IERlZmluaXRpb25zXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL3R5cGVzL2FjdGlvbl90cmFjZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL3R5cGVzL2FwaVwiKSwgZXhwb3J0cyk7XG4vLyBIeXBlcmlvbiBBUElcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvanNvbnJwY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL2VuZHBvaW50c1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL3JwY2Vycm9yXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WMl9HRVRfVFJBTlNGRVJTID0gZXhwb3J0cy5WMl9HRVRfVFJBTlNBQ1RJT04gPSBleHBvcnRzLlYyX0dFVF9UUkFOU0FDVEVEX0FDQ09VTlRTID0gZXhwb3J0cy5WMl9HRVRfREVMVEFTID0gZXhwb3J0cy5WMl9HRVRfQ1JFQVRPUiA9IGV4cG9ydHMuVjJfR0VUX0NSRUFURURfQUNDT1VOVFMgPSBleHBvcnRzLlYyX0dFVF9BQ1RJT05TID0gZXhwb3J0cy5WMl9HRVRfQUJJX1NOQVBTSE9UID0gZXhwb3J0cy5WMl9HRVRfUFJPUE9TQUxTID0gZXhwb3J0cy5WMl9HRVRfTElOS1MgPSBleHBvcnRzLlYyX0dFVF9WT1RFUlMgPSBleHBvcnRzLlYyX0dFVF9UT0tFTlMgPSBleHBvcnRzLlYyX0dFVF9LRVlfQUNDT1VOVFMgPSBleHBvcnRzLlYyX0FMSVZFID0gdm9pZCAwO1xuLy8gU3RhdGVcbmV4cG9ydHMuVjJfQUxJVkUgPSBcIi92Mi9zdGF0ZS9hbGl2ZVwiO1xuZXhwb3J0cy5WMl9HRVRfS0VZX0FDQ09VTlRTID0gXCIvdjIvc3RhdGUvZ2V0X2tleV9hY2NvdW50c1wiO1xuZXhwb3J0cy5WMl9HRVRfVE9LRU5TID0gXCIvdjIvc3RhdGUvZ2V0X3Rva2Vuc1wiO1xuZXhwb3J0cy5WMl9HRVRfVk9URVJTID0gXCIvdjIvc3RhdGUvZ2V0X3ZvdGVyc1wiO1xuZXhwb3J0cy5WMl9HRVRfTElOS1MgPSBcIi92Mi9zdGF0ZS9nZXRfbGlua3NcIjtcbmV4cG9ydHMuVjJfR0VUX1BST1BPU0FMUyA9IFwiL3YyL3N0YXRlL2dldF9wcm9wb3NhbHNcIjtcbi8vIEhpc3RvcnlcbmV4cG9ydHMuVjJfR0VUX0FCSV9TTkFQU0hPVCA9IFwiL3YyL2hpc3RvcnkvZ2V0X2FiaV9zbmFwc2hvdFwiO1xuZXhwb3J0cy5WMl9HRVRfQUNUSU9OUyA9IFwiL3YyL2hpc3RvcnkvZ2V0X2FjdGlvbnNcIjtcbmV4cG9ydHMuVjJfR0VUX0NSRUFURURfQUNDT1VOVFMgPSBcIi92Mi9oaXN0b3J5L2dldF9jcmVhdGVkX2FjY291bnRzXCI7XG5leHBvcnRzLlYyX0dFVF9DUkVBVE9SID0gXCIvdjIvaGlzdG9yeS9nZXRfY3JlYXRvclwiO1xuZXhwb3J0cy5WMl9HRVRfREVMVEFTID0gXCIvdjIvaGlzdG9yeS9nZXRfZGVsdGFzXCI7XG5leHBvcnRzLlYyX0dFVF9UUkFOU0FDVEVEX0FDQ09VTlRTID0gXCIvdjIvaGlzdG9yeS9nZXRfdHJhbnNhY3RlZF9hY2NvdW50c1wiO1xuZXhwb3J0cy5WMl9HRVRfVFJBTlNBQ1RJT04gPSBcIi92Mi9oaXN0b3J5L2dldF90cmFuc2FjdGlvblwiO1xuZXhwb3J0cy5WMl9HRVRfVFJBTlNGRVJTID0gXCIvdjIvaGlzdG9yeS9nZXRfdHJhbnNmZXJzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmRwb2ludHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSnNvblJwYyA9IHZvaWQgMDtcbnZhciBlbmRwb2ludHNfMSA9IHJlcXVpcmUoXCIuL2VuZHBvaW50c1wiKTtcbnZhciBycGNlcnJvcl8xID0gcmVxdWlyZShcIi4vcnBjZXJyb3JcIik7XG52YXIgY3Jvc3NfZmV0Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3Jvc3MtZmV0Y2hcIikpO1xuZnVuY3Rpb24gcXVlcnlQYXJhbXMocGFyYW1zKSB7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocGFyYW1zKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnRyaWVzLmpvaW4oXCImXCIpO1xufVxuZnVuY3Rpb24gZmV0Y2hXaXRoVGltZW91dChyZXNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWVvdXQsIGNvbnRyb2xsZXIsIGlkLCByZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xsZXIuYWJvcnQoKTsgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBjcm9zc19mZXRjaF8xLmRlZmF1bHQpKHJlc291cmNlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEpzb25ScGNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgaHlwZXJpb24gZW5kcG9pbnRcbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgZW5kcG9pbnQgPSBcImh0dHBzOi8vYnIuZW9zcmlvLmlvXCJcbiAqIGNvbnN0IHJwYyA9IG5ldyBKc29uUnBjKGVuZHBvaW50LCB7IGZldGNoIH0pXG4gKi9cbnZhciBKc29uUnBjID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb25ScGMoZW5kcG9pbnQsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0ge307IH1cbiAgICAgICAgdGhpcy50aW1lb3V0ID0gODAwMDtcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICAgICAgICBpZiAoYXJncy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBhcmdzLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogcG9zdFxuICAgICAqXG4gICAgICogUE9TVCBgYm9keWAgdG8gYGVuZHBvaW50ICsgcGF0aGAuXG4gICAgICogVGhyb3dzIGRldGFpbGVkIGVycm9yIGluZm9ybWF0aW9uIGluIGBScGNFcnJvcmAgd2hlbiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAocGF0aCwgYm9keSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGpzb24sIGVfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaFdpdGhUaW1lb3V0KHRoaXMuZW5kcG9pbnQgKyBwYXRoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UuanNvbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLnByb2Nlc3NlZCAmJiBqc29uLnByb2Nlc3NlZC5leGNlcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcnBjZXJyb3JfMS5ScGNFcnJvcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEuaXNGZXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBycGNlcnJvcl8xLlJwY0Vycm9yKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGpzb25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFxuICAgICAqXG4gICAgICogR0VUIGBwYXJhbXNgIHRvIGBlbmRwb2ludCArIHBhdGhgLlxuICAgICAqIFRocm93cyBkZXRhaWxlZCBlcnJvciBpbmZvcm1hdGlvbiBpbiBgUnBjRXJyb3JgIHdoZW4gYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGF0aCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwganNvbiwgdXJsLCBlXzI7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmVuZHBvaW50ICsgcGF0aCArIFwiP1wiICsgcXVlcnlQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoV2l0aFRpbWVvdXQodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBycGNlcnJvcl8xLlJwY1N0YXR1c0Vycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLmpzb24oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5wcm9jZXNzZWQgJiYganNvbi5wcm9jZXNzZWQuZXhjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJwY2Vycm9yXzEuUnBjRXJyb3IoanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZV8yLmlzRmV0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcnBjZXJyb3JfMS5ScGNFcnJvcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBqc29uXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9zdGF0ZS9hbGl2ZV0oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvc3RhdGUvZ2V0X3YyX3N0YXRlX2FsaXZlKVxuICAgICAqXG4gICAgICogc2ltcGxlIHNlcnZlciBoZWFsdGhjaGVja1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWxpdmU+fSBhbGl2ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5hbGl2ZSgpO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiAvLyA9PiB7XCJzdGF0dXNcIjogXCJPS1wifVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmFsaXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfQUxJVkUsIHt9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL2hpc3RvcnkvZ2V0X2FiaV9zbmFwc2hvdF0oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvaGlzdG9yeS9nZXRfdjJfaGlzdG9yeV9nZXRfYWJpX3NuYXBzaG90KVxuICAgICAqXG4gICAgICogZmV0Y2ggY29udHJhY3QgYWJpIGF0IHNwZWNpZmljIGJsb2NrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3QgY29udHJhY3QgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgdGFyZ2V0IGJsb2NrXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0QWJpU25hcHNob3Q+fSBhYmkgc25hcHNob3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X2FiaV9zbmFwc2hvdChcImVvc2lvXCIsIDIwMCk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UudmVyc2lvbik7XG4gICAgICogLy8gPT4gXCJlb3Npbzo6YWJpLzEuMFwiXG4gICAgICpcbiAgICAgKiBmb3IgKGNvbnN0IHRhYmxlIG9mIHJlc3BvbnNlLnRhYmxlcykge1xuICAgICAqICAgICBjb25zb2xlLmxvZyh0YWJsZSk7XG4gICAgICogICAgIC8vID0+IHsgbmFtZTogJ3Byb2R1Y2VycycsIGluZGV4X3R5cGU6ICdpNjQnLCBrZXlfbmFtZXM6IFsgJ293bmVyJyBdLCBrZXlfdHlwZXM6IFsgJ3VpbnQ2NCcgXSwgdHlwZTogJ3Byb2R1Y2VyX2luZm8nIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2FiaV9zbmFwc2hvdCA9IGZ1bmN0aW9uIChjb250cmFjdCwgYmxvY2spIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvbnRyYWN0OiBjb250cmFjdCxcbiAgICAgICAgICAgIGJsb2NrOiBibG9jayxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9BQklfU05BUFNIT1QsIHBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9zdGF0ZS9nZXRfdm90ZXJzXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9zdGF0ZS9nZXRfdjJfc3RhdGVfZ2V0X3ZvdGVycylcbiAgICAgKlxuICAgICAqIGdldCB2b3RlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcm9kdWNlcl0gZmlsdGVyIGJ5IHZvdGVkIHByb2R1Y2VyIChjb21tYSBzZXBhcmF0ZWQpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcm94eV0gdHJ1ZSBvciBmYWxzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5za2lwXSBza2lwIFtuXSBhY3Rpb25zIChwYWdpbmF0aW9uKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW1pdF0gbGltaXQgb2YgW25dIGFjdGlvbnMgcGVyIHBhZ2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRWb3RlcnM+fSB2b3RlcnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X3ZvdGVycyh7IHByb2R1Y2VyOiBcImVvc2NhZmVibG9ja1wiLCBsaW1pdDogMTAwIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLnZvdGVycyk7XG4gICAgICogLy8gPT4gXCJbe1xuICAgICAqIC8vICAgXCJhY2NvdW50XCI6IFwiZ3V6ZGttcnRnYWdlXCIsXG4gICAgICogLy8gICBcIndlaWdodFwiOiA3ODQzNDY5NTIzNjUwNTI4MCxcbiAgICAgKiAvLyAgIFwibGFzdF92b3RlXCI6IDY0ODA0NzY4XG4gICAgICogLy8gfV1cIlxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF92b3RlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX1ZPVEVSUywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9zdGF0ZS9nZXRfbGlua3NdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL3N0YXRlL2dldF92Ml9zdGF0ZV9saW5rcylcbiAgICAgKlxuICAgICAqIGdldCB2b3RlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYWNjb3VudF0gYWNjb3VudCB0byBnZXQgbGlua3MgZm9yXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0TGlua3M+fSBsaW5rc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfbGlua3MoXCJlb3NjYWZlYmxvY2tcIik7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UubGlua3MpO1xuICAgICAqIC8vID0+IFwiW3tcbiAgICAgKiBcImJsb2NrX251bVwiOjI2MDg4MDcyLFxuICAgICAqIFwidGltZXN0YW1wXCI6XCIyMDE5LTExLTIyVDIzOjE3OjQyLjAwMFwiLFxuICAgICAqIFwiYWNjb3VudFwiOlwiZW9zcmlvYnJhemlsXCIsXG4gICAgICogXCJwZXJtaXNzaW9uXCI6XCJjbGFpbTJcIixcbiAgICAgKiBcImNvZGVcIjpcImVvc2lvXCIsXG4gICAgICogXCJhY3Rpb25cIjpcInZvdGVwcm9kdWNlclwiXG4gICAgICogfV1cIlxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9saW5rcyA9IGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfTElOS1MsIHsgYWNjb3VudDogYWNjb3VudCB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL3N0YXRlL2dldF9wcm9wb3NhbHNdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL3N0YXRlL2dldF92Ml9zdGF0ZV9nZXRfcHJvcG9zYWxzKVxuICAgICAqXG4gICAgICogZ2V0IHByb3Bvc2Fsc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFthY2NvdW50XSBhY2NvdW50IHRvIGdldCBwcm9wb3NhbHMgZm9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3Bvc2VyXSBmaWx0ZXIgYnkgcHJvcG9zZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvcG9zYWxdIGZpbHRlciBieSBwcm9wb3NhbCBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFjY291bnRdIGZpbHRlciBieSBlaXRoZXIgcmVxdWVzdGVkIG9yIHByb3ZpZGVkIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVxdWVzdGVkXSBmaWx0ZXIgYnkgcmVxdWVzdGVkIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvdmlkZWRdIGZpbHRlciBieSBwcm92aWRlZCBhY2NvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrXSB0b3RhbCByZXN1bHRzIHRvIHRyYWNrIChjb3VudCkgW251bWJlciBvciB0cnVlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5za2lwXSBza2lwIFtuXSBhY3Rpb25zIChwYWdpbmF0aW9uKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW1pdF0gbGltaXQgb2YgW25dIGFjdGlvbnMgcGVyIHBhZ2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRQcm9wb3NhbHM+fSBwcm9wb3NhbHNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfcHJvcG9zYWxzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9QUk9QT1NBTFMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvaGlzdG9yeS9nZXRfYWN0aW9uc10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvaGlzdG9yeS9nZXRfdjJfaGlzdG9yeV9nZXRfYWN0aW9ucylcbiAgICAgKlxuICAgICAqIGdldCBhY3Rpb25zIGJhc2VkIG9uIG5vdGlmaWVkIGFjY291bnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50IG5vdGlmaWVkIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmlsdGVyXSBjb2RlOjpuYW1lIGZpbHRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5za2lwXSBza2lwIFtuXSBhY3Rpb25zIChwYWdpbmF0aW9uKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW1pdF0gbGltaXQgb2YgW25dIGFjdGlvbnMgcGVyIHBhZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc29ydF0gc29ydCBkaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWZ0ZXJdIGZpbHRlciBhZnRlciBzcGVjaWZpZWQgZGF0ZSAoSVNPODYwMSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmVmb3JlXSBmaWx0ZXIgYmVmb3JlIHNwZWNpZmllZCBkYXRlIChJU084NjAxKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFuc2Zlcl90b10gdHJhbnNmZXIgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYW5zZmVyX2Zyb21dICB0cmFuc2ZlciBmaWx0ZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFuc2Zlcl9zeW1ib2xdICB0cmFuc2ZlciBmaWx0ZXIgc3ltYm9sXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFjdF9uYW1lXSAgYWN0IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWN0X2FjY291bnRdICBhY3QgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldEFjdGlvbnM+fSBnZXQgYWN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfYWN0aW9ucyhcImVvc2NhZmVibG9ja1wiLCB7XG4gICAgICogICAgIGZpbHRlcjogXCJlb3Npby50b2tlbjoqXCIsXG4gICAgICogICAgIHNraXA6IDEwMCxcbiAgICAgKiAgICAgbGltaXQ6IDEwMCxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZvciAoY29uc3QgYWN0aW9uIG9mIHJlc3BvbnNlLmFjdGlvbnMpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYWN0aW9uKTtcbiAgICAgKiAgICAgLy8gPT4geyBhY3Q6IHsgYWNjb3VudDogJ2Vvc2lvLnRva2VuJywgbmFtZTogJ3RyYW5zZmVyJywgLi4uIH0gfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfYWN0aW9ucyA9IGZ1bmN0aW9uIChhY2NvdW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB7IGFjY291bnQ6IGFjY291bnQgfSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfQUNUSU9OUywgcGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL2hpc3RvcnkvZ2V0X2NyZWF0ZWRfYWNjb3VudHNdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL2hpc3RvcnkvZ2V0X3YyX2hpc3RvcnlfZ2V0X2NyZWF0ZWRfYWNjb3VudHMpXG4gICAgICpcbiAgICAgKiBnZXQgY3JlYXRlZCBhY2NvdW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnQgY3JlYXRlZCBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0Q3JlYXRlZEFjY291bnRzPn0gZ2V0IGNyZWF0b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X2NyZWF0ZWRfYWNjb3VudHMoXCJlb3NuYXRpb25mdHdcIik7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIC8vID0+IHtcImFjY291bnRzXCI6IFt7XCJuYW1lXCI6XCJlb3NuYXRpb25kc3BcIixcInRyeF9pZFwiOlwiNzI4ZDRhNGRhMzZhOThkOTA0ODA4MDQ2MWRhY2FmOTc1YWQwODNlODE1OGVmODRlZGVhNjBjYzc1NWFiMmMxYVwiLFwidGltZXN0YW1wXCI6XCIyMDE5LTAyLTI4VDIyOjM2OjQ1LjAwMFwifSwgLi4uIF19XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2NyZWF0ZWRfYWNjb3VudHMgPSBmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9DUkVBVEVEX0FDQ09VTlRTLCBwYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvaGlzdG9yeS9nZXRfY3JlYXRvcl0oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvaGlzdG9yeS9nZXRfdjJfaGlzdG9yeV9nZXRfY3JlYXRvcilcbiAgICAgKlxuICAgICAqIGdldCBjcmVhdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudCBjcmVhdGVkIGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRDcmVhdG9yPn0gZ2V0IGNyZWF0b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X2NyZWF0b3IoXCJlb3NuYXRpb25mdHdcIik7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIC8vID0+IHsgYWNjb3VudDogJ2Vvc25hdGlvbmZ0dycsIGNyZWF0b3I6ICdneXp0Y21ydmdxZ2UnLCB0aW1lc3RhbXA6ICcyMDE4LTA2LTEwVDEzOjA2OjQzLjUwMCcsIC4uLiB9XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2NyZWF0b3IgPSBmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9DUkVBVE9SLCBwYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvaGlzdG9yeS9nZXRfZGVsdGFzXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9oaXN0b3J5L2dldF92Ml9oaXN0b3J5X2dldF9kZWx0YXMpXG4gICAgICpcbiAgICAgKiBnZXQgZGVsdGFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBjb250cmFjdCBhY2NvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlIHRhYmxlIHNjb3BlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlIHRhYmxlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF5ZXIgcGF5ZXIgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldERlbHRhcz59IGdldCBkZWx0YXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X2RlbHRhcyhcImVvc2lvLnRva2VuXCIsIFwiZW9zbmF0aW9uZnR3XCIsIFwiYWNjb3VudHNcIiwgXCJlb3NuYXRpb25mdHdcIik7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIC8vID0+IHsgXCJxdWVyeV90aW1lXCI6IDE5LCBcInRvdGFsXCI6IHsgXCJ2YWx1ZVwiOiA0ODYsIFwicmVsYXRpb25cIjogXCJlcVwiIH0sIFwiZGVsdGFzXCI6IFsgLi4uIF0gfVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9kZWx0YXMgPSBmdW5jdGlvbiAoY29kZSwgc2NvcGUsIHRhYmxlLCBwYXllciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgIHBheWVyOiBwYXllcixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfREVMVEFTLCBwYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVC92Mi9zdGF0ZS9nZXRfa2V5X2FjY291bnRzXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9zdGF0ZS9nZXRfdjJfc3RhdGVfZ2V0X2tleV9hY2NvdW50cylcbiAgICAgKlxuICAgICAqIGdldCBhY2NvdW50IGJ5IHB1YmxpYyBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNfa2V5IENvbnRyYWN0IGFjY291bnQgdGFyZ2V0ZWQgYnkgdGhlIGFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRLZXlBY2NvdW50cz59IGtleSBhY2NvdW50c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfa2V5X2FjY291bnRzKFwiRU9TNU10bzNLbTZCQ1Z4b3diNkxra0ZhVDlvYVV3TFZnc3dnY3h2WTRRZ2M0cmhIcnk0VHZcIik7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UuYWNjb3VudF9uYW1lcyk7XG4gICAgICogLy8gPT4gWyAnZW9zY2FmZWJsb2NrJyBdXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2tleV9hY2NvdW50cyA9IGZ1bmN0aW9uIChwdWJsaWNfa2V5KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBwdWJsaWNfa2V5OiBwdWJsaWNfa2V5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX0tFWV9BQ0NPVU5UUywgcGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL3N0YXRlL2dldF90b2tlbnNdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL3N0YXRlL2dldF92Ml9zdGF0ZV9nZXRfdG9rZW5zKVxuICAgICAqXG4gICAgICogZ2V0IHRva2Vuc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnQgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldFRva2Vucz59IGdldCB0b2tlbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X3Rva2VucyhcImVvc25hdGlvbmZ0d1wiKTtcbiAgICAgKiBmb3IgKGNvbnN0IHRva2VuIG9mIHJlc3BvbnNlLnRva2Vucykge1xuICAgICAqICAgICBjb25zb2xlLmxvZyh0b2tlbik7XG4gICAgICogICAgIC8vID0+IHsgc3ltYm9sOiAnWk9TJywgcHJlY2lzaW9uOiA0LCBhbW91bnQ6IDE0MCwgY29udHJhY3Q6ICd6b3NkaXNjb3VudHMnIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3Rva2VucyA9IGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX1RPS0VOUywgcGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL2hpc3RvcnkvZ2V0X3RyYW5zYWN0ZWRfYWNjb3VudHNdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL2hpc3RvcnkvZ2V0X3YyX2hpc3RvcnlfZ2V0X3RyYW5zYWN0ZWRfYWNjb3VudHMpXG4gICAgICpcbiAgICAgKiBnZXQgYWxsIGFjY291bnQgdGhhdCBpbnRlcmFjdGVkIHdpdGggdGhlIHNvdXJjZSBhY2NvdW50IHByb3ZpZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudCBzb3VyY2UgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gc2VhcmNoIGRpcmVjdGlvbiAoaW4sIG91dCBvciBib3RoKVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldFRyYW5zYWN0ZWRBY2NvdW50cz59IHRyYW5zYWN0ZWQgYWNjb3VudHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X3RyYW5zYWN0ZWRfYWNjb3VudHMoXCJlb3NjYWZlYmxvY2tcIiwgXCJpblwiKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogLy8gPT4geyBxdWVyeV90aW1lOiAyNjgsIGFjY291bnQ6ICdlb3NjYWZlYmxvY2snLCB0b3RhbF9pbjogMTA5MjM2OS4xODI3LCBpbnB1dHM6IFsgLi4uIF0gfVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90cmFuc2FjdGVkX2FjY291bnRzID0gZnVuY3Rpb24gKGFjY291bnQsIGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgeyBhY2NvdW50OiBhY2NvdW50LCBkaXJlY3Rpb246IGRpcmVjdGlvbiB9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9UUkFOU0FDVEVEX0FDQ09VTlRTLCBwYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvaGlzdG9yeS9nZXRfdHJhbnNhY3Rpb25dKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL2hpc3RvcnkvZ2V0X3YyX2hpc3RvcnlfZ2V0X3RyYW5zYWN0aW9uKVxuICAgICAqXG4gICAgICogZ2V0IGFsbCBhY3Rpb25zIGJlbG9uZ2luZyB0byB0aGUgc2FtZSB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRyYW5zYWN0aW9uIGlkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0VHJhbnNhY3Rpb24+fSB0cmFuc2FjdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfdHJhbnNhY3Rpb24oXCI0MmRhY2Q1NzIyMDAxYjczNGJlNDZhMjE0MDkxN2UwNmNkMjFkNDI0MjVmOTI3ZjUwNmMwN2I0Mzg4YjA3ZjYyXCIpO1xuICAgICAqIGZvciAoY29uc3QgYWN0aW9uIG9mIHJlc3BvbnNlLmFjdGlvbnMpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYWN0aW9uKTtcbiAgICAgKiAgICAgLy8gPT4geyBhY3Q6IHsgYWNjb3VudDogJ2Vvc2lvJywgbmFtZTogJ2J1eXJhbWJ5dGVzJywgLi4uIH19XG4gICAgICogfVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX1RSQU5TQUNUSU9OLCBwYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvaGlzdG9yeS9nZXRfdHJhbnNmZXJzXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9oaXN0b3J5L2dldF92Ml9oaXN0b3J5X2dldF90cmFuc2ZlcnMpXG4gICAgICpcbiAgICAgKiBnZXQgdG9rZW4gdHJhbnNmZXJzIHV0aWxpemluZyB0aGUgZW9zaW8udG9rZW4gc3RhbmRhcmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mcm9tXSBzb3VyY2UgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b10gZGVzdGluYXRpb24gYWNjb3VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zeW1ib2xdIHRva2VuIHN5bWJvbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb250cmFjdF0gdG9rZW4gY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpcF0gc2tpcCBbbl0gYWN0aW9ucyAocGFnaW5hdGlvbilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGltaXRdIGxpbWl0IG9mIFtuXSBhY3Rpb25zIHBlciBwYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFmdGVyXSBmaWx0ZXIgYWZ0ZXIgc3BlY2lmaWVkIGRhdGUgKElTTzg2MDEpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJlZm9yZV0gZmlsdGVyIGJlZm9yZSBzcGVjaWZpZWQgZGF0ZSAoSVNPODYwMSlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRUcmFuc2ZlcnM+fSB0cmFuc2ZlcnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X3RyYW5zZmVycyh7dG86IFwiZW9zbmV3eW9ya2lvXCJ9KTtcbiAgICAgKiBmb3IgKGNvbnN0IGFjdGlvbiBvZiByZXNwb25zZS5hY3Rpb25zKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGFjdGlvbi5hY3QuZGF0YSk7XG4gICAgICogICAgIC8vID0+IHsgZnJvbTogJ2Vvc2lvLmJwYXknLCB0bzogJ2Vvc25ld3lvcmtpbycsIGFtb3VudDogMzI2LjUyNCwgc3ltYm9sOiAnRU9TJywgbWVtbzogJ3Byb2R1Y2VyIGJsb2NrIHBheScgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdHJhbnNmZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX1RSQU5TRkVSUywgcGFyYW1zKTtcbiAgICB9O1xuICAgIHJldHVybiBKc29uUnBjO1xufSgpKTtcbmV4cG9ydHMuSnNvblJwYyA9IEpzb25ScGM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29ucnBjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUnBjU3RhdHVzRXJyb3IgPSBleHBvcnRzLlJwY0Vycm9yID0gdm9pZCAwO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQG1vZHVsZSBSUEMtRXJyb3JcbiAqXG4gKiBjb3B5cmlnaHQgZGVmaW5lZCBpbiBlb3Nqcy9MSUNFTlNFLnR4dFxuICovXG52YXIgUnBjRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJwY0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJwY0Vycm9yKGpzb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGpzb24uZXJyb3IgJiYganNvbi5lcnJvci5kZXRhaWxzICYmIGpzb24uZXJyb3IuZGV0YWlscy5sZW5ndGggJiYganNvbi5lcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywganNvbi5lcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvbi5wcm9jZXNzZWQgJiYganNvbi5wcm9jZXNzZWQuZXhjZXB0ICYmIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdC5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBqc29uLm1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBScGNFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICBfdGhpcy5qc29uID0ganNvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUnBjRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlJwY0Vycm9yID0gUnBjRXJyb3I7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBScGNTdGF0dXNFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUnBjU3RhdHVzRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUnBjU3RhdHVzRXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA1KSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlc3BvbnNlLnN0YXR1c1RleHQpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBScGNTdGF0dXNFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBScGNTdGF0dXNFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUnBjU3RhdHVzRXJyb3IgPSBScGNTdGF0dXNFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJwY2Vycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aW9uX3RyYWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBUeXBlU2NyaXB0IERlZmluaXRpb25zXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL3R5cGVzL2FwaVwiKSwgZXhwb3J0cyk7XG4vLyBMaWdodCBBUElcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvanNvbnJwY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL2VuZHBvaW50c1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL3JwY2Vycm9yXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HRVRfQUNDT1VOVFNfRlJPTV9LRVlTID0gZXhwb3J0cy5HRVRfVE9LRU5fSE9MREVSUyA9IGV4cG9ydHMuR0VUX1RPS0VOX0hPTERFUl9DT1VOVCA9IGV4cG9ydHMuR0VUX0NPREVIQVNIID0gZXhwb3J0cy5HRVRfVE9QU1RBS0UgPSBleHBvcnRzLkdFVF9UT1BSQU0gPSBleHBvcnRzLkdFVF9VU0VSQ09VTlQgPSBleHBvcnRzLkdFVF9UT1BIT0xERVJTID0gZXhwb3J0cy5HRVRfVE9LRU5fQkFMQU5DRSA9IGV4cG9ydHMuR0VUX1NZTkNfSU5GTyA9IGV4cG9ydHMuR0VUX05FVFdPUktTID0gZXhwb3J0cy5HRVRfS0VZX0FDQ09VTlRTID0gZXhwb3J0cy5HRVRfQkFMQU5DRVMgPSBleHBvcnRzLkdFVF9BQ0NPVU5UX0lORk8gPSBleHBvcnRzLkdFVF9BQ0NPVU5UID0gdm9pZCAwO1xuZXhwb3J0cy5HRVRfQUNDT1VOVCA9IFwiL2FwaS9hY2NvdW50XCI7XG5leHBvcnRzLkdFVF9BQ0NPVU5UX0lORk8gPSBcIi9hcGkvYWNjaW5mb1wiO1xuZXhwb3J0cy5HRVRfQkFMQU5DRVMgPSBcIi9hcGkvYmFsYW5jZXNcIjtcbmV4cG9ydHMuR0VUX0tFWV9BQ0NPVU5UUyA9IFwiL2FwaS9rZXlcIjtcbmV4cG9ydHMuR0VUX05FVFdPUktTID0gXCIvYXBpL25ldHdvcmtzXCI7XG5leHBvcnRzLkdFVF9TWU5DX0lORk8gPSBcIi9hcGkvc3luY1wiO1xuZXhwb3J0cy5HRVRfVE9LRU5fQkFMQU5DRSA9IFwiL2FwaS90b2tlbmJhbGFuY2VcIjtcbmV4cG9ydHMuR0VUX1RPUEhPTERFUlMgPSBcIi9hcGkvdG9waG9sZGVyc1wiO1xuZXhwb3J0cy5HRVRfVVNFUkNPVU5UID0gXCIvYXBpL3VzZXJjb3VudFwiO1xuZXhwb3J0cy5HRVRfVE9QUkFNID0gXCIvYXBpL3RvcHJhbVwiO1xuZXhwb3J0cy5HRVRfVE9QU1RBS0UgPSBcIi9hcGkvdG9wc3Rha2VcIjtcbmV4cG9ydHMuR0VUX0NPREVIQVNIID0gXCIvYXBpL2NvZGVoYXNoXCI7XG5leHBvcnRzLkdFVF9UT0tFTl9IT0xERVJfQ09VTlQgPSBcIi9hcGkvaG9sZGVyY291bnRcIjtcbmV4cG9ydHMuR0VUX1RPS0VOX0hPTERFUlMgPSBcImdldF90b2tlbl9ob2xkZXJzXCI7XG5leHBvcnRzLkdFVF9BQ0NPVU5UU19GUk9NX0tFWVMgPSBcImdldF9hY2NvdW50c19mcm9tX2tleXNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuZHBvaW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Kc29uUnBjID0gdm9pZCAwO1xudmFyIGVuZHBvaW50c18xID0gcmVxdWlyZShcIi4vZW5kcG9pbnRzXCIpO1xudmFyIHJwY2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ycGNlcnJvclwiKTtcbnZhciBjcm9zc19mZXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcm9zcy1mZXRjaFwiKSk7XG52YXIganNvbnJwYzJfd3NfMSA9IHJlcXVpcmUoXCJqc29ucnBjMi13c1wiKTtcbnZhciBjaGFpblRvRW5kcG9pbnQgPSB7XG4gICAgZW9zOiBcImh0dHBzOi8vYXBpLmxpZ2h0Lnhlb3MubWVcIixcbiAgICB0ZWxvczogXCJodHRwczovL2FwaS5saWdodC54ZW9zLm1lXCIsXG4gICAganVuZ2xlOiBcImh0dHBzOi8vbGlnaHRhcGkuZW9zZ2VuZXZhLmlvXCIsXG4gICAgYm9zOiBcImh0dHBzOi8vbGlnaHRhcGkuZW9zYW1zdGVyZGFtLm5ldFwiLFxuICAgIGluc3RhcjogXCJodHRwczovL2xpZ2h0YXBpLmVvc2Ftc3RlcmRhbS5uZXRcIixcbiAgICBwcm90b246IFwiaHR0cHM6Ly9wcm90b24ubGlnaHQtYXBpLm5ldFwiLFxuICAgIHdheDogXCJodHRwczovL2xpZ2h0YXBpLmVvc2Ftc3RlcmRhbS5uZXRcIixcbiAgICB3b3JibGk6IFwiaHR0cHM6Ly9saWdodGFwaS5lb3NhbXN0ZXJkYW0ubmV0XCIsXG4gICAgeGVjOiBcImh0dHBzOi8vbGlnaHRhcGkuZW9zYW1zdGVyZGFtLm5ldFwiLFxuICAgIHByb3RvbnRlc3Q6IFwiaHR0cHM6Ly90ZXN0bmV0LWxpZ2h0YXBpLmVvc2Ftcy54ZW9zLm1lXCIsXG4gICAgdGVsb3N0ZXN0OiBcImh0dHBzOi8vdGVzdG5ldC1saWdodGFwaS5lb3NhbXMueGVvcy5tZVwiLFxuICAgIHdheHRlc3Q6IFwiaHR0cHM6Ly90ZXN0bmV0LWxpZ2h0YXBpLmVvc2Ftcy54ZW9zLm1lXCIsXG4gICAgY29mZmU6IFwiaHR0cHM6Ly9oeXBlcmlvbi5jb2ZmZS5pb1wiLFxufTtcbmZ1bmN0aW9uIGZldGNoV2l0aFRpbWVvdXQocmVzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lb3V0LCBjb250cm9sbGVyLCBpZCwgcmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sbGVyLmFib3J0KCk7IH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgY3Jvc3NfZmV0Y2hfMS5kZWZhdWx0KShyZXNvdXJjZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSksIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBKc29uUnBjXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50IExJR0hUIEFQSSBlbmRwb2ludFxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBycGMgPSBuZXcgSnNvblJwYyhcInByb3RvblwiKVxuICovXG52YXIgSnNvblJwYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKc29uUnBjKGNoYWluLCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IHt9OyB9XG4gICAgICAgIHRoaXMudGltZW91dCA9IDUwMDA7XG4gICAgICAgIHRoaXMud3NSZXF1ZXN0SWQgPSAxMDA7XG4gICAgICAgIHRoaXMuY2hhaW4gPSBjaGFpbjtcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IGFyZ3MuZW5kcG9pbnQgfHwgY2hhaW5Ub0VuZHBvaW50W2NoYWluXTtcbiAgICAgICAgdGhpcy53c0NsaWVudCA9IG5ldyBqc29ucnBjMl93c18xLkNsaWVudCh0aGlzLmVuZHBvaW50LnJlcGxhY2UoJ2h0dHBzOicsICd3c3M6JykgKyAnL3dzYXBpJyk7XG4gICAgICAgIGlmICghdGhpcy5lbmRwb2ludCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhaW4gXCIuY29uY2F0KGNoYWluLCBcIiBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBlbmRwb2ludCwgcHJvdmlkZSBvbmUgaW4gYXJnc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MudGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gYXJncy50aW1lb3V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFxuICAgICAqXG4gICAgICogR0VUIGBwYXJhbXNgIHRvIGBlbmRwb2ludCArIHBhdGhgLlxuICAgICAqIFRocm93cyBkZXRhaWxlZCBlcnJvciBpbmZvcm1hdGlvbiBpbiBgUnBjRXJyb3JgIHdoZW4gYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGF0aCwgZW5kcG9pbnQpIHtcbiAgICAgICAgaWYgKGVuZHBvaW50ID09PSB2b2lkIDApIHsgZW5kcG9pbnQgPSB0aGlzLmVuZHBvaW50OyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwganNvbiwgdXJsLCB0ZXh0LCBlXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBlbmRwb2ludCArIHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgNCwgLCA1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaFdpdGhUaW1lb3V0KHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJwY2Vycm9yXzEuUnBjU3RhdHVzRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UudGV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24ucHJvY2Vzc2VkICYmIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcnBjZXJyb3JfMS5ScGNFcnJvcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEuaXNGZXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBycGNlcnJvcl8xLlJwY0Vycm9yKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGpzb25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS9hY2NvdW50XVxuICAgICAqXG4gICAgICogUmV0cmlldmUgYWxsIHRva2VuIGJhbGFuY2VzLCByZXNvdXJjZXMgYW5kIGF1dGhvcml6YXRpb24gaW5mb3JtYXRpb24gZm9yIGFuIGFjY291bnQ6XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudE5hbWUgbmFtZSBvZiBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0QWNjb3VudD59IGFjY291bnRcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfYWNjb3VudCA9IGZ1bmN0aW9uIChhY2NvdW50TmFtZSkge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX0FDQ09VTlQsIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbiwgXCIvXCIpLmNvbmNhdChhY2NvdW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL2FjY2luZm9dXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBhbGwgcmVzb3VyY2VzIGFuZCBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIGZvciBhbiBhY2NvdW50OlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnROYW1lIG5hbWUgb2YgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldEFjY291bnRJbmZvPn0gYWNjb3VudFxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9hY2NvdW50X2luZm8gPSBmdW5jdGlvbiAoYWNjb3VudE5hbWUpIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9BQ0NPVU5UX0lORk8sIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbiwgXCIvXCIpLmNvbmNhdChhY2NvdW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL2JhbGFuY2VzXVxuICAgICAqXG4gICAgICogUmV0cmlldmUgb25seSB0b2tlbiBiYWxhbmNlcyBmb3IgYW4gYWNjb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnROYW1lIG5hbWUgb2YgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldEJhbGFuY2VzPn0gYmFsYW5jZXNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfYmFsYW5jZXMgPSBmdW5jdGlvbiAoYWNjb3VudE5hbWUpIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9CQUxBTkNFUywgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluLCBcIi9cIikuY29uY2F0KGFjY291bnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkva2V5XVxuICAgICAqXG4gICAgICogUmV0cmlldmUgYWxsIGFjY291bnRzIGluIGFsbCBrbm93biBFT1MgbmV0d29ya3MgZGVwZW5kZW50IG9uIGEgcHVibGljIGtleTpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgcHVibGljIGtleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldEtleUFjY291bnRzW10+fSBhY2NvdW50cyBwZXIgbmV0d29ya1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9hbGxfa2V5X2FjY291bnRzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobmV3IFNldChPYmplY3QudmFsdWVzKGNoYWluVG9FbmRwb2ludCkpKSwgZmFsc2UpLm1hcChmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX0tFWV9BQ0NPVU5UUywgXCIvXCIpLmNvbmNhdChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXQodXJsLCBlbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHByb21pc2VzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL2tleV1cbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGFsbCBhY2NvdW50cyBpbiBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHB1YmxpYyBrZXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRLZXlBY2NvdW50cz59IGFjY291bnRzXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2tleV9hY2NvdW50cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfS0VZX0FDQ09VTlRTLCBcIi9cIikuY29uY2F0KGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZ2V0KHVybCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL25ldHdvcmtzXVxuICAgICAqXG4gICAgICogUmV0cmlldmUgYWxsIGFjY291bnRzIGluIGFsbCBrbm93biBFT1MgbmV0d29ya3MgZGVwZW5kZW50IG9uIGEgcHVibGljIGtleTpcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldE5ldHdvcmtzPn0gYWNjb3VudHNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfbmV0d29ya3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5HRVRfTkVUV09SS1MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL3N5bmNdXG4gICAgICpcbiAgICAgKiByZXR1cm5zIGEgcGxhaW4gdGV4dCB3aXRoIGRlbGF5IGluIHNlY29uZHMgdGhhdCB0aGlzIHNlcnZlcidzIGJsb2NrY2hhaW4gZGF0YWJhc2UgaXMgYmVoaW5kIHRoZSByZWFsIHRpbWUsIGFuZCBhIHN0YXR1czogT0sgaWYgdGhlIGRlbGF5IGlzIHdpdGhpbiAxODAgc2Vjb25kcywgb3IgJ09VVF9PRl9TWU5DJyBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBnZXQgc3luY1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9zeW5jX2luZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfU1lOQ19JTkZPLCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS90b2tlbmJhbGFuY2VdXG4gICAgICpcbiAgICAgKiAgcmV0dXJucyBhIHBsYWluIHRleHQgd2l0aCBudW1lcmljIG91dHB1dCBpbmRpY2F0aW5nIHRoZSB0b2tlbiBiYWxhbmNlLiBaZXJvIGlzIHJldHVybmVkIGlmIHRoZSB0b2tlbiBpcyBub3QgcHJlc2VudCBvciBkb2VzIG5vdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50IG93bmVyIG9mIHRva2VuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0IHRva2VuIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIHRva2VuIHN5bWJvbFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IHRva2VuIGJhbGFuY2VcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdG9rZW5fYmFsYW5jZSA9IGZ1bmN0aW9uIChhY2NvdW50LCBjb250cmFjdCwgdG9rZW4pIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9UT0tFTl9CQUxBTkNFLCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4sIFwiL1wiKS5jb25jYXQoYWNjb3VudCwgXCIvXCIpLmNvbmNhdChjb250cmFjdCwgXCIvXCIpLmNvbmNhdCh0b2tlbik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL3RvcGhvbGRlcnNdXG4gICAgICpcbiAgICAgKiByZXR1cm5zIHRvcCBOVU0gaG9sZGVycyBvZiBhIHNwZWNpZmllZCB0b2tlbiBpbiBhIEpTT04gYXJyYXkgY29udGFpbmluZyBhcnJheXMgb2YgKGFjY291bnQsIGFtb3VudCkgcGFpcnMuIE5VTSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gMTAgb3IgbW9yZSB0aGFuIDEwMDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3QgdG9rZW4gY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gdG9rZW4gc3ltYm9sXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bSBudW1iZXIgb2YgdG9wIGhvbGRlcnMgKG1pbiAxMCwgbWF4IDEwMDApXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSB0b2tlbiBiYWxhbmNlXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3RvcGhvbGRlcnMgPSBmdW5jdGlvbiAoY29udHJhY3QsIHRva2VuLCBudW0pIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9UT1BIT0xERVJTLCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4sIFwiL1wiKS5jb25jYXQoY29udHJhY3QsIFwiL1wiKS5jb25jYXQodG9rZW4sIFwiL1wiKS5jb25jYXQobnVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvdXNlcmNvdW50XVxuICAgICAqXG4gICAgICogcmV0dXJucyBhIHBsYWluIHRleHQgd2l0aCB0b3RhbCBudW1iZXIgb2YgYWNjb3VudHMgaW4gdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSB0b2tlbiBiYWxhbmNlXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3VzZXJjb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9VU0VSQ09VTlQsIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL3RvcHJhbV1cbiAgICAgKlxuICAgICAqIHJldHVybnMgdG9wIE5VTSBSQU0gYnV5ZXJzIGluIGEgSlNPTiBhcnJheSBjb250YWluaW5nIGFycmF5cyBvZiAoYWNjb3VudCwgYnl0ZXMpIHBhaXJzLiBOVU0gbXVzdCBub3QgYmUgbGVzcyB0aGFuIDEwIG9yIG1vcmUgdGhhbiAxMDAwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bSBudW1iZXIgb2YgdG9wIGhvbGRlcnMgKG1pbiAxMCwgbWF4IDEwMDApXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRUb3BSYW0+fSB0b3AgcmFtIGhvbGRlcnNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdG9wcmFtID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX1RPUFJBTSwgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluLCBcIi9cIikuY29uY2F0KG51bSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL3RvcHN0YWtlXVxuICAgICAqXG4gICAgICogcmV0dXJucyB0b3AgTlVNIFJBTSBidXllcnMgaW4gYSBKU09OIGFycmF5IGNvbnRhaW5pbmcgYXJyYXlzIG9mIChhY2NvdW50LCBieXRlcykgcGFpcnMuIE5VTSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gMTAgb3IgbW9yZSB0aGFuIDEwMDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtIHJldHVybnMgdG9wIE5VTSBzdGFrZSBob2xkZXJzIGJ5IHN1bSBvZiBDUFUgYW5kIE5ldCBzdGFrZXMsIGluIGEgSlNPTiBhcnJheSBjb250YWluaW5nIGFycmF5cyBvZiAoYWNjb3VudCwgY3B1X3dlaWdodCwgbmV0X3dlaWdodCkgdHVwbGVzLiBOVU0gbXVzdCBub3QgYmUgbGVzcyB0aGFuIDEwIG9yIG1vcmUgdGhhbiAxMDAwLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0VG9wU3Rha2U+fSB0b3Agc3Rha2UgaG9sZGVyc1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90b3BzdGFrZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9UT1BTVEFLRSwgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluLCBcIi9cIikuY29uY2F0KG51bSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL2NvZGVoYXNoXVxuICAgICAqXG4gICAgICogcmV0cmlldmVzIGFsbCBhY2NvdW50cyBpbiBhbGwga25vd24gRU9TIG5ldHdvcmtzIGJ5IGNvbnRyYWN0IGhhc2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtIHJldHVybnMgdG9wIE5VTSBzdGFrZSBob2xkZXJzIGJ5IHN1bSBvZiBDUFUgYW5kIE5ldCBzdGFrZXMsIGluIGEgSlNPTiBhcnJheSBjb250YWluaW5nIGFycmF5cyBvZiAoYWNjb3VudCwgY3B1X3dlaWdodCwgbmV0X3dlaWdodCkgdHVwbGVzLiBOVU0gbXVzdCBub3QgYmUgbGVzcyB0aGFuIDEwIG9yIG1vcmUgdGhhbiAxMDAwLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0Q29kZWhhc2g+fSBhY2NvdW50c1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9jb2RlaGFzaCA9IGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfQ09ERUhBU0gsIFwiL1wiKS5jb25jYXQoaGFzaCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL2hvbGRlcmNvdW50XVxuICAgICAqXG4gICAgICogcmV0dXJucyBhIHBsYWludGV4dCBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG51bWJlciBvZiBhY2NvdW50cyB3aXRoIHBvc2l0aXZlIGJhbGFuY2UgZm9yIGEgc3BlY2lmaWVkIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0IHRva2VuIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIHRva2VuIHN5bWJvbFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gY291bnRcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdG9rZW5ob2xkZXJfY291bnQgPSBmdW5jdGlvbiAoY29udHJhY3QsIHRva2VuKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfVE9LRU5fSE9MREVSX0NPVU5ULCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4sIFwiL1wiKS5jb25jYXQoY29udHJhY3QsIFwiL1wiKS5jb25jYXQodG9rZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtXUyBnZXRfdG9rZW5faG9sZGVyc11cbiAgICAgKlxuICAgICAqIEdldCBhbGwgdG9rZW4gaG9sZGVycyBvZiBhIGNvbnRyYWN0IGFuZCBzeW1ib2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdCB0b2tlbiBjb250cmFjdFxuICAgICAqIEBwYXJhbSB0b2tlbiB0b2tlbiBzeW1ib2xcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90b2tlbl9ob2xkZXJzID0gZnVuY3Rpb24gKGNvbnRyYWN0LCB0b2tlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVxSWQgPSArK3RoaXMud3NSZXF1ZXN0SWQ7XG4gICAgICAgIHZhciBiYWxhbmNlcyA9IFtdO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMud3NDbGllbnQub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcmVqZWN0KGVycik7IH0pO1xuICAgICAgICAgICAgX3RoaXMud3NDbGllbnQubWV0aG9kcy5zZXQoJ3JlcWRhdGEnLCBmdW5jdGlvbiAoXywgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShiYWxhbmNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhbGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiBwYXJhbXMuZGF0YS5hY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6ICtwYXJhbXMuZGF0YS5hbW91bnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud3NDbGllbnQuY2FsbChlbmRwb2ludHNfMS5HRVRfVE9LRU5fSE9MREVSUywge1xuICAgICAgICAgICAgICAgICAgICByZXFpZDogcmVxSWQsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcms6IF90aGlzLmNoYWluLFxuICAgICAgICAgICAgICAgICAgICBjb250cmFjdDogY29udHJhY3QsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiB0b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW1dTIGdldF9hY2NvdW50c19mcm9tX2tleXNdXG4gICAgICpcbiAgICAgKiBHZXQgYWxsIHRva2VuIGhvbGRlcnMgb2YgYSBjb250cmFjdCBhbmQgc3ltYm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5c1tdIGFycmF5IG9mIGtleXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9hY2NvdW50c19mcm9tX2tleXMgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVxSWQgPSArK3RoaXMud3NSZXF1ZXN0SWQ7XG4gICAgICAgIHZhciBhY2NvdW50cyA9IFtdO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMud3NDbGllbnQub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcmVqZWN0KGVycik7IH0pO1xuICAgICAgICAgICAgX3RoaXMud3NDbGllbnQubWV0aG9kcy5zZXQoJ3JlcWRhdGEnLCBmdW5jdGlvbiAoXywgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhY2NvdW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50X25hbWU6IHBhcmFtcy5kYXRhLmFjY291bnRfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGVybTogcGFyYW1zLmRhdGEucGVybSxcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiArcGFyYW1zLmRhdGEud2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5kYXRhLnB1YmtleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy53c0NsaWVudC5jYWxsKGVuZHBvaW50c18xLkdFVF9BQ0NPVU5UU19GUk9NX0tFWVMsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxaWQ6IHJlcUlkLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBfdGhpcy5jaGFpbixcbiAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEpzb25ScGM7XG59KCkpO1xuZXhwb3J0cy5Kc29uUnBjID0gSnNvblJwYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb25ycGMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ScGNTdGF0dXNFcnJvciA9IGV4cG9ydHMuUnBjRXJyb3IgPSB2b2lkIDA7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAbW9kdWxlIFJQQy1FcnJvclxuICpcbiAqIGNvcHlyaWdodCBkZWZpbmVkIGluIGVvc2pzL0xJQ0VOU0UudHh0XG4gKi9cbnZhciBScGNFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUnBjRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUnBjRXJyb3IoanNvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoanNvbi5lcnJvciAmJiBqc29uLmVycm9yLmRldGFpbHMgJiYganNvbi5lcnJvci5kZXRhaWxzLmxlbmd0aCAmJiBqc29uLmVycm9yLmRldGFpbHNbMF0ubWVzc2FnZSkge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBqc29uLmVycm9yLmRldGFpbHNbMF0ubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc29uLnByb2Nlc3NlZCAmJiBqc29uLnByb2Nlc3NlZC5leGNlcHQgJiYganNvbi5wcm9jZXNzZWQuZXhjZXB0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywganNvbi5wcm9jZXNzZWQuZXhjZXB0Lm1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGpzb24ubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJwY0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIF90aGlzLmpzb24gPSBqc29uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBScGNFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUnBjRXJyb3IgPSBScGNFcnJvcjtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIFJwY1N0YXR1c0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhScGNTdGF0dXNFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBScGNTdGF0dXNFcnJvcihyZXNwb25zZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDUpIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVzcG9uc2Uuc3RhdHVzVGV4dCkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJwY1N0YXR1c0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJwY1N0YXR1c0Vycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5ScGNTdGF0dXNFcnJvciA9IFJwY1N0YXR1c0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnBjZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIiwiaW1wb3J0IHsgc3RyaW5nLCBvYmplY3QsIGFycmF5LCBsaXRlcmFsLCBudW1iZXIsIGFueSwgbmF0aXZlRW51bSwgYm9vbGVhbiB9IGZyb20gJ3pvZCc7XG5cbnZhciBfc2ltaWxhckNoYWlucywgX2V4cGxvcmVyTGlua0J5Q2hhaW47XG5cbnZhciBDaGFpbnM7XG5cbihmdW5jdGlvbiAoQ2hhaW5zKSB7XG4gIENoYWluc1tcIkJpdGNvaW5NYWlubmV0XCJdID0gXCJCaXRjb2luXCI7XG4gIENoYWluc1tcIkJpdGNvaW5UZXN0bmV0XCJdID0gXCJCaXRjb2luIChUZXN0bmV0KVwiO1xuICBDaGFpbnNbXCJFdGhlcmV1bU1haW5uZXRcIl0gPSBcIkV0aGVyZXVtXCI7XG4gIENoYWluc1tcIkV0aGVyZXVtUm9wc3RlblwiXSA9IFwiRXRoZXJldW0gKFJvcHN0ZW4pXCI7XG4gIENoYWluc1tcIkxpdGVjb2luTWFpbm5ldFwiXSA9IFwiTGl0ZWNvaW5cIjtcbiAgQ2hhaW5zW1wiTGl0ZWNvaW5UZXN0bmV0XCJdID0gXCJMaXRlY29pbiAoVGVzdG5ldClcIjtcbiAgQ2hhaW5zW1wiQml0Y29pbkNhc2hNYWlubmV0XCJdID0gXCJCaXRjb2luIENhc2hcIjtcbiAgQ2hhaW5zW1wiQml0Y29pbkNhc2hUZXN0bmV0XCJdID0gXCJCaXRjb2luIENhc2ggKFRlc3RuZXQpXCI7XG4gIENoYWluc1tcIlN0ZWxsYXJNYWlubmV0XCJdID0gXCJTdGVsbGFyXCI7XG4gIENoYWluc1tcIlN0ZWxsYXJUZXN0bmV0XCJdID0gXCJTdGVsbGFyIChUZXN0bmV0KVwiO1xuICBDaGFpbnNbXCJQcm90b25NYWlubmV0XCJdID0gXCJQcm90b25cIjtcbiAgQ2hhaW5zW1wiUHJvdG9uVGVzdG5ldFwiXSA9IFwiUHJvdG9uIChUZXN0bmV0KVwiO1xuICBDaGFpbnNbXCJQb2xrYWRvdE1haW5uZXRcIl0gPSBcIlBvbGthZG90XCI7XG4gIENoYWluc1tcIkJpbmFuY2VCRVAyXCJdID0gXCJCaW5hbmNlIChCRVAyKVwiO1xuICBDaGFpbnNbXCJCaW5hbmNlQkVQMjBcIl0gPSBcIkJpbmFuY2UgKEJFUDIwKVwiO1xuICBDaGFpbnNbXCJFb3NNYWlubmV0XCJdID0gXCJFT1NcIjtcbiAgQ2hhaW5zW1wiRW9zVGVzdG5ldFwiXSA9IFwiRU9TIChKdW5nbGUgVGVzdG5ldClcIjtcbiAgQ2hhaW5zW1wiSGVkZXJhTWFpbm5ldFwiXSA9IFwiSGVkZXJhIChNYWlubmV0KVwiO1xuICBDaGFpbnNbXCJIZWRlcmFUZXN0bmV0XCJdID0gXCJIZWRlcmEgKFRlc3RuZXQpXCI7XG4gIENoYWluc1tcIkRvZ2VNYWlubmV0XCJdID0gXCJEb2dlY29pblwiO1xuICBDaGFpbnNbXCJDYXJkYW5vTWFpbm5ldFwiXSA9IFwiQ2FyZGFub1wiO1xuICBDaGFpbnNbXCJBdmFsYW5jaGVYQ2hhaW5cIl0gPSBcIkF2YWxhbmNoZSBYLUNoYWluXCI7XG4gIENoYWluc1tcIkF2YWxhbmNoZUNDaGFpblwiXSA9IFwiQXZhbGFuY2hlIEMtQ2hhaW5cIjtcbiAgQ2hhaW5zW1wiUG9seWdvbk1haW5uZXRcIl0gPSBcIlBvbHlnb25cIjtcbiAgQ2hhaW5zW1wiVGVycmFNYWlubmV0XCJdID0gXCJUZXJyYVwiO1xufSkoQ2hhaW5zIHx8IChDaGFpbnMgPSB7fSkpO1xuXG52YXIgTmV0d29ya3M7XG5cbihmdW5jdGlvbiAoTmV0d29ya3MpIHtcbiAgTmV0d29ya3NbXCJNYWlubmV0XCJdID0gXCJtYWlubmV0XCI7XG4gIE5ldHdvcmtzW1wiVGVzdG5ldFwiXSA9IFwidGVzdG5ldFwiO1xuICBOZXR3b3Jrc1tcIlJvcHN0ZW5cIl0gPSBcInJvcHN0ZW5cIjtcbiAgTmV0d29ya3NbXCJFUkMyMFwiXSA9IFwiZXJjMjBcIjtcbiAgTmV0d29ya3NbXCJCRVAyMFwiXSA9IFwiYmVwMjBcIjtcbiAgTmV0d29ya3NbXCJYTE1cIl0gPSBcInhsbVwiO1xufSkoTmV0d29ya3MgfHwgKE5ldHdvcmtzID0ge30pKTtcblxudmFyIHNpbWlsYXJDaGFpbnMgPSAoX3NpbWlsYXJDaGFpbnMgPSB7fSwgX3NpbWlsYXJDaGFpbnNbQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldF0gPSBbQ2hhaW5zLkJpbmFuY2VCRVAyMF0sIF9zaW1pbGFyQ2hhaW5zW0NoYWlucy5CaW5hbmNlQkVQMjBdID0gW0NoYWlucy5FdGhlcmV1bU1haW5uZXRdLCBfc2ltaWxhckNoYWlucyk7XG52YXIgZXhwbG9yZXJMaW5rQnlDaGFpbiA9IChfZXhwbG9yZXJMaW5rQnlDaGFpbiA9IHt9LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuQml0Y29pbk1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ibG9ja2NoYWluLmNvbS9idGMvdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkJpdGNvaW5UZXN0bmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmxvY2tzdHJlYW0uaW5mby90ZXN0bmV0L3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5FdGhlcmV1bU1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ldGhlcnNjYW4uaW8vdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkV0aGVyZXVtUm9wc3Rlbl0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL3JvcHN0ZW4uZXRoZXJzY2FuLmlvL3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5MaXRlY29pbk1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ibG9ja2NoYWlyLmNvbS9saXRlY29pbi90cmFuc2FjdGlvbi9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuTGl0ZWNvaW5UZXN0bmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmxvY2tleHBsb3Jlci5vbmUvbGl0ZWNvaW4vdGVzdG5ldC9ibG9ja0hhc2gvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkJpdGNvaW5DYXNoTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2Jsb2NrY2hhaXIuY29tL2JpdGNvaW4tY2FzaC90cmFuc2FjdGlvbi9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuQml0Y29pbkNhc2hUZXN0bmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmxvY2tleHBsb3Jlci5vbmUvYml0Y29pbi1jYXNoL3Rlc3RuZXQvYmxvY2tIYXNoL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5TdGVsbGFyTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2Jsb2NrY2hhaXIuY29tL3N0ZWxsYXIvdHJhbnNhY3Rpb24vXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLlN0ZWxsYXJUZXN0bmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vdGVzdG5ldC5zdGVleHAuY29tL3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5Qcm90b25NYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vcHJvdG9uLmJsb2tzLmlvL3RyYW5zYWN0aW9uL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5Qcm90b25UZXN0bmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vcHJvdG9uLXRlc3QuYmxva3MuaW8vdHJhbnNhY3Rpb24vXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLlBvbGthZG90TWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL3BvbGthZG90LnN1YnNjYW4uaW8vZXh0cmluc2ljL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5CaW5hbmNlQkVQMl0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2JpbmFuY2UubWludHNjYW4uaW8vdHhzL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5CaW5hbmNlQkVQMjBdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ic2NzY2FuLmNvbS90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuRW9zTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2Jsb2tzLmlvL3RyYW5zYWN0aW9uL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5Fb3NUZXN0bmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vanVuZ2xlLmJsb2tzLmlvL3RyYW5zYWN0aW9uL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5IZWRlcmFNYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYXBwLmRyYWdvbmdsYXNzLm1lL3RyYW5zYWN0aW9ucy9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuSGVkZXJhVGVzdG5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL3Rlc3RuZXQuZHJhZ29uZ2xhc3MubWUvdHJhbnNhY3Rpb25zL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5Eb2dlTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2Jsb2NrY2hhaXIuY29tL2RvZ2Vjb2luL3RyYW5zYWN0aW9uL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5DYXJkYW5vTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2V4cGxvcmVyLmNhcmRhbm8ub3JnL2VuL3RyYW5zYWN0aW9uP2lkPVwiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5BdmFsYW5jaGVYQ2hhaW5dID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9hdmFzY2FuLmluZm8vYmxvY2tjaGFpbi94L3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5BdmFsYW5jaGVDQ2hhaW5dID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9zbm93dHJhY2UuaW8vdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLlBvbHlnb25NYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vcG9seWdvbnNjYW4uY29tL3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5UZXJyYU1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly90ZXJyYS5zdGFrZS5pZC8/Iy90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbik7XG52YXIgaW5pdGlhbGl6ZUNvaW5zID0gZnVuY3Rpb24gaW5pdGlhbGl6ZUNvaW5zKHByb3RvbkNoYWluKSB7XG4gIHZhciBJU19NQUlOTkVUID0gcHJvdG9uQ2hhaW4gPT09ICdwcm90b24nO1xuICB2YXIgSVNfVEVTVE5FVCA9IHByb3RvbkNoYWluID09PSAncHJvdG9uLXRlc3QnO1xuICB2YXIgY29pbnMgPSBbe1xuICAgIGFsbG93U3dhcDogdHJ1ZSxcbiAgICBhbGxvd0JyaWRnZTogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0xlbmQ6IHRydWUsXG4gICAgYWxsb3dCb3Jyb3c6IHRydWUsXG4gICAgbmFtZTogJ1Byb3RvbicsXG4gICAgY29pbjogJ1hQUicsXG4gICAgeHRva2VuU3ltYm9sOiAnWFBSJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDQsXG4gICAgeHRva2VuQ29udHJhY3Q6ICdlb3Npby50b2tlbicsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnWFBSLUVSQzIwJyxcbiAgICAgIHN5bWJvbDogJ1hQUicsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiA0LFxuICAgICAgY29udHJhY3Q6ICcweEQ3RUZCMDBEMTJDMkMxMzEzMUZEMzE5MzM2RkRGOTUyNTI1REEyQUYnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHdhbGxldDogJ1hQUi1CRVAyMCcsXG4gICAgICBzeW1ib2w6ICdYUFInLFxuICAgICAgY2hhaW46IENoYWlucy5CaW5hbmNlQkVQMjAsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5CRVAyMCxcbiAgICAgIHByZWNpc2lvbjogNCxcbiAgICAgIGNvbnRyYWN0OiAnMHg1REUzOTM5QjJGODExQTYxRDgzMEU2RjUyRDEzQjA2Njg4MTQxMkFCJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL2Vvc2lvLXRva2VuWFBSLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdwcm90b24nXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IHRydWUsXG4gICAgYWxsb3dCcmlkZ2U6IHRydWUsXG4gICAgYWxsb3dMZW5kOiB0cnVlLFxuICAgIGFsbG93Qm9ycm93OiB0cnVlLFxuICAgIG5hbWU6ICdVU0QgQ29pbicsXG4gICAgY29pbjogJ1VTREMnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hVU0RDJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdVU0RDJyxcbiAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogNixcbiAgICAgIGNvbnRyYWN0OiAnMHhBMEI4Njk5MUM2MjE4QjM2QzFEMTlENEEyRTlFQjBDRTM2MDZFQjQ4JyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9LCB7XG4gICAgICB3YWxsZXQ6ICdVU0RDLUJFUDIwJyxcbiAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgY2hhaW46IENoYWlucy5CaW5hbmNlQkVQMjAsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5CRVAyMCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4OEFDNzZBNTFDQzk1MEQ5ODIyRDY4QjgzRkUxQUQ5N0IzMkNENTgwRCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfSwge1xuICAgICAgd2FsbGV0OiAnVVNEQy1YTE0nLFxuICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICBjaGFpbjogQ2hhaW5zLlN0ZWxsYXJNYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuWExNLFxuICAgICAgcHJlY2lzaW9uOiA3LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogdHJ1ZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnVVNEQycsXG4gICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1Sb3BzdGVuLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuUm9wc3RlbixcbiAgICAgIHByZWNpc2lvbjogNixcbiAgICAgIGNvbnRyYWN0OiAnMHhBMEI4Njk5MUM2MjE4QjM2QzFEMTlENEEyRTlFQjBDRTM2MDZFQjQ4JyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYVVNEQy5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAndXNkLWNvaW4nXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IHRydWUsXG4gICAgYWxsb3dCcmlkZ2U6IElTX01BSU5ORVQsXG4gICAgYWxsb3dMZW5kOiB0cnVlLFxuICAgIGFsbG93Qm9ycm93OiB0cnVlLFxuICAgIG5hbWU6ICdNZXRhbCcsXG4gICAgY29pbjogJ01UTCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWE1UJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDgsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdNVEwnLFxuICAgICAgc3ltYm9sOiAnTVRMJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDgsXG4gICAgICBjb250cmFjdDogJzB4RjQzMzA4OTM2Njg5OUQ4M0E5RjI2QTc3M0Q1OUVDN0VDRjMwMzU1RScsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWE1ULnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdtZXRhbCdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogdHJ1ZSxcbiAgICBhbGxvd0JyaWRnZTogdHJ1ZSxcbiAgICBhbGxvd0xlbmQ6IHRydWUsXG4gICAgYWxsb3dCb3Jyb3c6IHRydWUsXG4gICAgbmFtZTogJ0JpdGNvaW4nLFxuICAgIGNvaW46ICdCVEMnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hCVEMnLFxuICAgIHh0b2tlblByZWNpc2lvbjogOCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0JUQycsXG4gICAgICBzeW1ib2w6ICdCVEMnLFxuICAgICAgY2hhaW46IENoYWlucy5CaXRjb2luTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDgsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnQlRDJyxcbiAgICAgIHN5bWJvbDogJ0JUQycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkJpdGNvaW5UZXN0bmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuVGVzdG5ldCxcbiAgICAgIHByZWNpc2lvbjogOCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWEJUQy5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnYml0Y29pbidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogdHJ1ZSxcbiAgICBhbGxvd0JyaWRnZTogdHJ1ZSxcbiAgICBhbGxvd0xlbmQ6IHRydWUsXG4gICAgYWxsb3dCb3Jyb3c6IHRydWUsXG4gICAgbmFtZTogJ0V0aGVyZXVtJyxcbiAgICBjb2luOiAnRVRIJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYRVRIJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDgsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdFVEgnLFxuICAgICAgc3ltYm9sOiAnRVRIJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdFVEgnLFxuICAgICAgc3ltYm9sOiAnRVRIJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1Sb3BzdGVuLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuUm9wc3RlbixcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWEVUSC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnZXRoZXJldW0nXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IHRydWUsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdMb2FuJyxcbiAgICBjb2luOiAnTE9BTicsXG4gICAgeHRva2VuU3ltYm9sOiAnTE9BTicsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA0LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAnbG9hbi50b2tlbicsXG4gICAgd2FsbGV0czogW10sXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy9sb2FuLnRva2VuTE9BTi5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAncHJvdG9uLWxvYW4nXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IElTX01BSU5ORVQsXG4gICAgYWxsb3dCcmlkZ2U6IHRydWUsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1RldGhlcicsXG4gICAgY29pbjogJ1VTRFQnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hVU0RUJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdVU0RUJyxcbiAgICAgIHN5bWJvbDogJ1VTRFQnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogNixcbiAgICAgIGNvbnRyYWN0OiAnMHhEQUMxN0Y5NThEMkVFNTIzQTIyMDYyMDY5OTQ1OTdDMTNEODMxRUM3JyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1VTRFQnLFxuICAgICAgc3ltYm9sOiAnVVNEVCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtUm9wc3RlbixcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlJvcHN0ZW4sXG4gICAgICBwcmVjaXNpb246IDYsXG4gICAgICBjb250cmFjdDogJzB4REFDMTdGOTU4RDJFRTUyM0EyMjA2MjA2OTk0NTk3QzEzRDgzMUVDNycsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWFVTRFQucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3RldGhlcidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IElTX01BSU5ORVQsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1RydWVVU0QnLFxuICAgIGNvaW46ICdUVVNEJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYVFVTRCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnVFVTRCcsXG4gICAgICBzeW1ib2w6ICdUVVNEJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDAwMDAwMDAwMDAwODVENDc4MEI3MzExOUI2NDRBRTVFQ0QyMkIzNzYnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hUVVNELnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICd0cnVlLXVzZCdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IElTX01BSU5ORVQsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1BheG9zIFN0YW5kYXJkJyxcbiAgICBjb2luOiAnUEFYJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYUEFYJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdQQVgnLFxuICAgICAgc3ltYm9sOiAnUEFYJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDhFODcwRDY3RjY2MEQ5NUQ1QkU1MzAzODBEMEVDMEJEMzg4Mjg5RTEnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hQQVgucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3VzZHAnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiB0cnVlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdQYXhvcyBHb2xkJyxcbiAgICBjb2luOiAnUEFYRycsXG4gICAgeHRva2VuU3ltYm9sOiAnWFBBWEcnLFxuICAgIHh0b2tlblByZWNpc2lvbjogOCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1BBWEcnLFxuICAgICAgc3ltYm9sOiAnUEFYRycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHg0NTgwNDg4MERFMjI5MTNEQUZFMDlGNDk4MDg0OEVDRTZFQ0JBRjc4JyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1BBWEcnLFxuICAgICAgc3ltYm9sOiAnUEFYRycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtUm9wc3RlbixcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlJvcHN0ZW4sXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDQ1ODA0ODgwREUyMjkxM0RBRkUwOUY0OTgwODQ4RUNFNkVDQkFGNzgnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hQQVhHLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdwYXgtZ29sZCdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0JyaWRnZTogdHJ1ZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnVW5pc3dhcCcsXG4gICAgY29pbjogJ1VOSScsXG4gICAgeHRva2VuU3ltYm9sOiAnWFVOSScsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnVU5JJyxcbiAgICAgIHN5bWJvbDogJ1VOSScsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHgxRjk4NDBBODVENUFGNUJGMUQxNzYyRjkyNUJEQUREQzQyMDFGOTg0JyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1VOSScsXG4gICAgICBzeW1ib2w6ICdVTkknLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bVJvcHN0ZW4sXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5Sb3BzdGVuLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHgxRjk4NDBBODVENUFGNUJGMUQxNzYyRjkyNUJEQUREQzQyMDFGOTg0JyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYVU5JLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICd1bmlzd2FwJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJzFJTkNIJyxcbiAgICBjb2luOiAnMUlOQ0gnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hJTkNIJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICcxSU5DSCcsXG4gICAgICBzeW1ib2w6ICcxSU5DSCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHgxMTExMTExMTExMTdEQzBBQTc4Qjc3MEZBNkE3MzgwMzQxMjBDMzAyJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYSU5DSC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnMWluY2gnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnQ2hhaW5saW5rJyxcbiAgICBjb2luOiAnTElOSycsXG4gICAgeHRva2VuU3ltYm9sOiAnWExJTksnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0xJTksnLFxuICAgICAgc3ltYm9sOiAnTElOSycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHg1MTQ5MTA3NzFBRjlDQTY1NkFGODQwREZGODNFODI2NEVDRjk4NkNBJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYTElOSy5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnY2hhaW5saW5rJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBJU19NQUlOTkVULFxuICAgIGFsbG93QnJpZGdlOiB0cnVlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdMaXRlY29pbicsXG4gICAgY29pbjogJ0xUQycsXG4gICAgeHRva2VuU3ltYm9sOiAnWExUQycsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA4LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnTFRDJyxcbiAgICAgIHN5bWJvbDogJ0xUQycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkxpdGVjb2luTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDgsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnTFRDJyxcbiAgICAgIHN5bWJvbDogJ0xUQycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkxpdGVjb2luVGVzdG5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlRlc3RuZXQsXG4gICAgICBwcmVjaXNpb246IDgsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hMVEMucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2xpdGVjb2luJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBJU19NQUlOTkVULFxuICAgIGFsbG93QnJpZGdlOiB0cnVlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdCaXRjb2luIENhc2gnLFxuICAgIGNvaW46ICdCQ0gnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hCQ0gnLFxuICAgIHh0b2tlblByZWNpc2lvbjogOCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0JDSCcsXG4gICAgICBzeW1ib2w6ICdCQ0gnLFxuICAgICAgY2hhaW46IENoYWlucy5CaXRjb2luQ2FzaE1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA4LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0JDSCcsXG4gICAgICBzeW1ib2w6ICdCQ0gnLFxuICAgICAgY2hhaW46IENoYWlucy5CaXRjb2luQ2FzaFRlc3RuZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5UZXN0bmV0LFxuICAgICAgcHJlY2lzaW9uOiA4LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYQkNILnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdiaXRjb2luLWNhc2gnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnU3RlbGxhcicsXG4gICAgY29pbjogJ1hMTScsXG4gICAgeHRva2VuU3ltYm9sOiAnWFhMTScsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnWExNJyxcbiAgICAgIHN5bWJvbDogJ1hMTScsXG4gICAgICBjaGFpbjogQ2hhaW5zLlN0ZWxsYXJNYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogNyxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IHRydWVcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1hMTScsXG4gICAgICBzeW1ib2w6ICdYTE0nLFxuICAgICAgY2hhaW46IENoYWlucy5TdGVsbGFyVGVzdG5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlRlc3RuZXQsXG4gICAgICBwcmVjaXNpb246IDcsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiB0cnVlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWFhMTS5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnc3RlbGxhcidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1NlbnNlJyxcbiAgICBjb2luOiAnU0VOU0UnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hTRU5TRScsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA0LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAnc2Vuc2UnLFxuICAgIHdhbGxldHM6IFtdLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMvc2Vuc2VYU0VOU0UucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3NlbnNlJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1BvbGthZG90JyxcbiAgICBjb2luOiAnRE9UJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYRE9UJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDgsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdET1QnLFxuICAgICAgc3ltYm9sOiAnRE9UJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuUG9sa2Fkb3RNYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogMTAsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hET1QucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3BvbGthZG90J1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiB0cnVlLFxuICAgIGFsbG93QnJpZGdlOiBJU19NQUlOTkVULFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdCaW5hbmNlIENvaW4nLFxuICAgIGNvaW46ICdCTkInLFxuICAgIHh0b2tlblN5bWJvbDogJ1hCTkInLFxuICAgIHh0b2tlblByZWNpc2lvbjogOCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0JOQicsXG4gICAgICBzeW1ib2w6ICdCTkInLFxuICAgICAgY2hhaW46IENoYWlucy5CaW5hbmNlQkVQMjAsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5CRVAyMCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hCTkIucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2JpbmFuY2Vjb2luJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiB0cnVlLFxuICAgIGFsbG93QnJpZGdlOiB0cnVlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdFT1MnLFxuICAgIGNvaW46ICdFT1MnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hFT1MnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0VPUycsXG4gICAgICBzeW1ib2w6ICdFT1MnLFxuICAgICAgY2hhaW46IENoYWlucy5Fb3NNYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogNCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IHRydWVcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0VPUycsXG4gICAgICBzeW1ib2w6ICdFT1MnLFxuICAgICAgY2hhaW46IENoYWlucy5Fb3NUZXN0bmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuVGVzdG5ldCxcbiAgICAgIHByZWNpc2lvbjogNCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IHRydWVcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYRU9TLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdlb3MnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IElTX01BSU5ORVQsXG4gICAgYWxsb3dCcmlkZ2U6IElTX01BSU5ORVQsXG4gICAgYWxsb3dMZW5kOiB0cnVlLFxuICAgIGFsbG93Qm9ycm93OiB0cnVlLFxuICAgIG5hbWU6ICdEb2dlY29pbicsXG4gICAgY29pbjogJ0RPR0UnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hET0dFJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdET0dFJyxcbiAgICAgIHN5bWJvbDogJ0RPR0UnLFxuICAgICAgY2hhaW46IENoYWlucy5Eb2dlTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDgsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hET0dFLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdkb2dlY29pbidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0JyaWRnZTogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnQ2FyZGFubycsXG4gICAgY29pbjogJ0FEQScsXG4gICAgeHRva2VuU3ltYm9sOiAnWEFEQScsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnQURBJyxcbiAgICAgIHN5bWJvbDogJ0FEQScsXG4gICAgICBjaGFpbjogQ2hhaW5zLkNhcmRhbm9NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogNixcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWEFEQS5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnY2FyZGFubydcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdBdmFsYW5jaGUnLFxuICAgIGNvaW46ICdBVkFYJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYQVZBWCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA5LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnQVZBWCcsXG4gICAgICBzeW1ib2w6ICdBVkFYJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQXZhbGFuY2hlWENoYWluLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogOSxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfSwge1xuICAgICAgd2FsbGV0OiAnQVZBWCcsXG4gICAgICBzeW1ib2w6ICdBVkFYJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQXZhbGFuY2hlQ0NoYWluLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogOSxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWEFWQVgucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2F2YWxhbmNoZS0yJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1BvbHlnb24nLFxuICAgIGNvaW46ICdNQVRJQycsXG4gICAgeHRva2VuU3ltYm9sOiAnWE1BVElDJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDgsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdNQVRJQycsXG4gICAgICBzeW1ib2w6ICdNQVRJQycsXG4gICAgICBjaGFpbjogQ2hhaW5zLlBvbHlnb25NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWE1BVElDLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdtYXRpYy1uZXR3b3JrJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0x1bmEnLFxuICAgIGNvaW46ICdMVU5BJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYTFVOQScsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnTFVOQScsXG4gICAgICBzeW1ib2w6ICdMVU5BJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuVGVycmFNYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogNixcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IHRydWVcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYTFVOQS5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAndGVycmEtbHVuYSdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdUZXJyYVVTRCcsXG4gICAgY29pbjogJ1VTVCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWFVTVCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnVVNUJyxcbiAgICAgIHN5bWJvbDogJ1VTVCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLlRlcnJhTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDYsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiB0cnVlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWFVTVC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAndGVycmF1c2QnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBJU19URVNUTkVULFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdIQkFSJyxcbiAgICBjb2luOiAnSEJBUicsXG4gICAgeHRva2VuU3ltYm9sOiAnWEhCQVInLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0hCQVInLFxuICAgICAgc3ltYm9sOiAnSEJBUicsXG4gICAgICBjaGFpbjogQ2hhaW5zLkhlZGVyYVRlc3RuZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5UZXN0bmV0LFxuICAgICAgcHJlY2lzaW9uOiA4LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogdHJ1ZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hIQkFSLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdoZWRlcmEtaGFzaGdyYXBoJ1xuICB9XTsgLy8gVmFsaWRhdGlvblxuXG4gIHZhciB3YWxsZXRXaXRoRHVwbGljYXRlQ2hhaW5zID0gY29pbnMuZmluZChmdW5jdGlvbiAoY29pbikge1xuICAgIHZhciBjaGFpbnMgPSBjb2luLndhbGxldHMubWFwKGZ1bmN0aW9uICh3YWxsZXQpIHtcbiAgICAgIHJldHVybiB3YWxsZXQuY2hhaW47XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBTZXQoY2hhaW5zKS5zaXplICE9PSBjaGFpbnMubGVuZ3RoO1xuICB9KTtcblxuICBpZiAod2FsbGV0V2l0aER1cGxpY2F0ZUNoYWlucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvaW4gXCIgKyB3YWxsZXRXaXRoRHVwbGljYXRlQ2hhaW5zLmNvaW4gKyBcIiBoYXMgZHVwbGljYXRlIGNoYWlucyBpbiB3YWxsZXRcIik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFsbENvaW5zOiBjb2lucyxcbiAgICBzd2FwQ29pbnM6IGNvaW5zLmZpbHRlcihmdW5jdGlvbiAoY29pbikge1xuICAgICAgcmV0dXJuIGNvaW4uYWxsb3dTd2FwO1xuICAgIH0pLFxuICAgIGJyaWRnZUNvaW5zOiBjb2lucy5maWx0ZXIoZnVuY3Rpb24gKGNvaW4pIHtcbiAgICAgIHJldHVybiBjb2luLmFsbG93QnJpZGdlO1xuICAgIH0pLFxuICAgIGxlbmRDb2luczogY29pbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2luKSB7XG4gICAgICByZXR1cm4gY29pbi5hbGxvd0xlbmQ7XG4gICAgfSksXG4gICAgYm9ycm93Q29pbnM6IGNvaW5zLmZpbHRlcihmdW5jdGlvbiAoY29pbikge1xuICAgICAgcmV0dXJuIGNvaW4uYWxsb3dCb3Jyb3c7XG4gICAgfSksXG4gICAgbG9hbkNvaW5zOiBjb2lucy5maWx0ZXIoZnVuY3Rpb24gKGNvaW4pIHtcbiAgICAgIHJldHVybiBjb2luLmFsbG93TGVuZCB8fCBjb2luLmFsbG93Qm9ycm93O1xuICAgIH0pLFxuICAgIGFsbEVuYWJsZWRDb2luczogY29pbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2luKSB7XG4gICAgICByZXR1cm4gY29pbi5hbGxvd1N3YXAgfHwgY29pbi5hbGxvd0JyaWRnZTtcbiAgICB9KVxuICB9O1xufTtcblxudmFyIGFjY291bnRQYXJzZXIgPSAvKiNfX1BVUkVfXyovc3RyaW5nKCkucmVnZXgoL15bLjEtNWEtel17MCwxMn1bLjEtNWEtal0/JC8pO1xudmFyIGF1dGhvcml6YXRpb25QYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgYWN0b3I6IGFjY291bnRQYXJzZXIsXG4gIHBlcm1pc3Npb246IC8qI19fUFVSRV9fKi9zdHJpbmcoKVxufSk7XG52YXIgYXV0aG9yaXphdGlvbnNQYXJzZXIgPSAvKiNfX1BVUkVfXyovYXJyYXkoYXV0aG9yaXphdGlvblBhcnNlcikubWluKDEpO1xudmFyIEV4dGVuZGVkQXNzZXRQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgcXVhbnRpdHk6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY29udHJhY3Q6IGFjY291bnRQYXJzZXJcbn0pO1xuXG52YXIgcmF3VHJhbnNhY3Rpb25QYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgZXhwaXJhdGlvbjogLyojX19QVVJFX18qL3N0cmluZygpLFxuICByZWZfYmxvY2tfbnVtOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHJlZl9ibG9ja19wcmVmaXg6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgbWF4X25ldF91c2FnZV93b3JkczogLyojX19QVVJFX18qL251bWJlcigpLFxuICBtYXhfY3B1X3VzYWdlX21zOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIGRlbGF5X3NlYzogLyojX19QVVJFX18qL251bWJlcigpLFxuICBjb250ZXh0X2ZyZWVfYWN0aW9uczogLyojX19QVVJFX18qL2FycmF5KCAvKiNfX1BVUkVfXyovYW55KCkpLFxuICB0cmFuc2FjdGlvbl9leHRlbnNpb25zOiAvKiNfX1BVUkVfXyovYXJyYXkoIC8qI19fUFVSRV9fKi9hbnkoKSlcbn0pO1xudmFyIGJhc2VBY3Rpb25QYXJzZXIgPSBmdW5jdGlvbiBiYXNlQWN0aW9uUGFyc2VyKGNvbnRyYWN0LCBhY3Rpb24sIGRhdGEpIHtcbiAgcmV0dXJuIG9iamVjdCh7XG4gICAgYWNjb3VudDogY29udHJhY3QgPT09ICcqJyA/IGFjY291bnRQYXJzZXIgOiBsaXRlcmFsKGNvbnRyYWN0KSxcbiAgICBuYW1lOiBsaXRlcmFsKGFjdGlvbiksXG4gICAgZGF0YTogb2JqZWN0KGRhdGEpLFxuICAgIGF1dGhvcml6YXRpb246IGF1dGhvcml6YXRpb25zUGFyc2VyXG4gIH0pO1xufTtcbnZhciBiYXNlQWN0aW9uU2VyaWFsaXplZFBhcnNlciA9IGZ1bmN0aW9uIGJhc2VBY3Rpb25TZXJpYWxpemVkUGFyc2VyKGNvbnRyYWN0LCBhY3Rpb24sIGRhdGEpIHtcbiAgcmV0dXJuIG9iamVjdCh7XG4gICAgYWNjb3VudDogY29udHJhY3QgPT09ICcqJyA/IGFjY291bnRQYXJzZXIgOiBsaXRlcmFsKGNvbnRyYWN0KSxcbiAgICBuYW1lOiBsaXRlcmFsKGFjdGlvbiksXG4gICAgZGF0YTogc3RyaW5nKCkub3Iob2JqZWN0KGRhdGEpKSxcbiAgICBhdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uc1BhcnNlclxuICB9KTtcbn07XG52YXIgd2ViYXV0aEFjdGlvblBhcnNlciA9IGZ1bmN0aW9uIHdlYmF1dGhBY3Rpb25QYXJzZXIoY29udHJhY3QsIGFjdGlvbiwgZGF0YSkge1xuICByZXR1cm4gb2JqZWN0KHtcbiAgICBhY2NvdW50OiBsaXRlcmFsKCd3ZWJhdXRobicpLFxuICAgIG5hbWU6IGxpdGVyYWwoJ2V4ZWMnKSxcbiAgICBkYXRhOiBvYmplY3Qoe1xuICAgICAgYWNjb3VudDogYWNjb3VudFBhcnNlcixcbiAgICAgIGtleTogb2JqZWN0KHtcbiAgICAgICAga2V5OiBhcnJheShzdHJpbmcoKS5vcihvYmplY3Qoe1xuICAgICAgICAgIG1vZHVsdXM6IHN0cmluZygpLFxuICAgICAgICAgIGV4cG9uZW50OiBzdHJpbmcoKVxuICAgICAgICB9KSkpLFxuICAgICAgICB1c2VyX3ByZXNlbmNlOiBudW1iZXIoKSxcbiAgICAgICAgcnBpZDogc3RyaW5nKClcbiAgICAgIH0pLFxuICAgICAgbm9uY2U6IG51bWJlcigpLFxuICAgICAgcGVybWlzc2lvbnM6IGF1dGhvcml6YXRpb25zUGFyc2VyLFxuICAgICAgc2lnbmF0dXJlOiBvYmplY3Qoe1xuICAgICAgICBhdXRoX2RhdGE6IHN0cmluZygpLFxuICAgICAgICBjbGllbnRfanNvbjogc3RyaW5nKCksXG4gICAgICAgIHNpZ25hdHVyZTogc3RyaW5nKClcbiAgICAgIH0pLFxuICAgICAgdHJ4OiByYXdUcmFuc2FjdGlvblBhcnNlci5tZXJnZShvYmplY3Qoe1xuICAgICAgICBhY3Rpb25zOiBhcnJheShiYXNlQWN0aW9uU2VyaWFsaXplZFBhcnNlcihjb250cmFjdCwgYWN0aW9uLCBkYXRhKSkubGVuZ3RoKDEpXG4gICAgICB9KSlcbiAgICB9KSxcbiAgICBhdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uc1BhcnNlclxuICB9KTtcbn07XG52YXIgc2luZ2xlQWN0aW9uVHJhbnNhY3Rpb25QYXJzZXIgPSBmdW5jdGlvbiBzaW5nbGVBY3Rpb25UcmFuc2FjdGlvblBhcnNlcihjb250cmFjdCwgYWN0aW9uLCBkYXRhKSB7XG4gIHZhciBiYXNlQWN0aW9uID0gYmFzZUFjdGlvblBhcnNlcihjb250cmFjdCwgYWN0aW9uLCBkYXRhKTtcbiAgdmFyIHdlYmF1dGhBY3Rpb24gPSB3ZWJhdXRoQWN0aW9uUGFyc2VyKGNvbnRyYWN0LCBhY3Rpb24sIGRhdGEpO1xuICByZXR1cm4gcmF3VHJhbnNhY3Rpb25QYXJzZXIubWVyZ2Uob2JqZWN0KHtcbiAgICBhY3Rpb25zOiBhcnJheShiYXNlQWN0aW9uLm9yKHdlYmF1dGhBY3Rpb24pKS5sZW5ndGgoMSlcbiAgfSkpO1xufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIFdSQVBfQ09OVFJBQ1QgPSAncHJvdG9uLndyYXAnO1xudmFyIFdSQVBfQVVUSF9BQ1RJT04gPSAnZ2VuZXJhdGVhdXRoJztcbnZhciBpbml0aWFsaXplQ29uc3RhbnRzID0gZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbnN0YW50cyhjaGFpbikge1xuICB2YXIgX2luaXRpYWxpemVDb2lucyA9IGluaXRpYWxpemVDb2lucyhjaGFpbiksXG4gICAgICBzd2FwQ29pbnMgPSBfaW5pdGlhbGl6ZUNvaW5zLnN3YXBDb2lucyxcbiAgICAgIGJyaWRnZUNvaW5zID0gX2luaXRpYWxpemVDb2lucy5icmlkZ2VDb2lucyxcbiAgICAgIGFsbEVuYWJsZWRDb2lucyA9IF9pbml0aWFsaXplQ29pbnMuYWxsRW5hYmxlZENvaW5zLFxuICAgICAgYWxsQ29pbnMgPSBfaW5pdGlhbGl6ZUNvaW5zLmFsbENvaW5zLFxuICAgICAgbGVuZENvaW5zID0gX2luaXRpYWxpemVDb2lucy5sZW5kQ29pbnMsXG4gICAgICBib3Jyb3dDb2lucyA9IF9pbml0aWFsaXplQ29pbnMuYm9ycm93Q29pbnMsXG4gICAgICBsb2FuQ29pbnMgPSBfaW5pdGlhbGl6ZUNvaW5zLmxvYW5Db2lucztcblxuICB2YXIgY29uc3RhbnRzID0ge1xuICAgIFNXQVBfQ09OVFJBQ1Q6ICdwcm90b24uc3dhcHMnLFxuICAgIEZFRV9GQUNUT1I6IDEwMDAwLFxuICAgIEdPT0dMRV9NQVBTX0tFWTogJ0FJemFTeURiMl9DckswMzJrU0lxQlhia2R3bWFMS1dFTGwwU3hWcycsXG4gICAgU1dBUF9VUkw6IGNoYWluID09PSAncHJvdG9uJyA/ICdodHRwczovL290Yy5wcm90b25zd2FwLmNvbScgOiAnaHR0cHM6Ly9vdGMtdGVzdC5wcm90b25zd2FwLmNvbScsXG4gICAgV1JBUF9TRVJWRVJfVVJMOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL3Byb3Rvbi13cmFwLXB1YmxpYzInIDogJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9wcm90b24td3JhcC10ZXN0bmV0LXB1YmxpYzInLFxuICAgIFdSQVBfQ09OVFJBQ1Q6IFdSQVBfQ09OVFJBQ1QsXG4gICAgV1JBUF9BQ1RJT05TOiB7XG4gICAgICBTQVZFX0FERFJFU1M6ICdzYXZlYWRkcmVzczInLFxuICAgICAgREVMRVRFX0FERFJFU1M6ICdkZWxhZGRyZXNzMicsXG4gICAgICBXUkFQX1NUQVJUOiAnd3JhcHN0YXJ0MicsXG4gICAgICBXUkFQX0ZJTklTSDogJ3dyYXBmaW5pc2gyJyxcbiAgICAgIFdSQVBfUFJPQ0VTUzogJ3dyYXBwcm9jZXNzMicsXG4gICAgICBXUkFQX1NFVF9DT05GOiAnd3JhcHNldGNvbmYyJ1xuICAgIH0sXG4gICAgV1JBUF9UQUJMRVM6IHtcbiAgICAgIEFERFJFU1NFUzogJ2FkZHJlc3NlczInLFxuICAgICAgV1JBUFM6ICd3cmFwczInXG4gICAgfSxcbiAgICBBRERSRVNTRVNfSU5ERVhFUzoge1xuICAgICAgQllfQUNDT1VOVDogMixcbiAgICAgIEJZX0FERFJfSEFTSDogM1xuICAgIH0sXG4gICAgV1JBUFNfSU5ERVhFUzoge1xuICAgICAgQllfQUNDT1VOVDogMixcbiAgICAgIEJZX1NUQVRVUzogMyxcbiAgICAgIEJZX1dSQVBfSEFTSDogNFxuICAgIH0sXG4gICAgV1JBUF9QUk9DRVNTX1RJTUVSOiA1MDAwLFxuICAgIEZBUk1fQ09OVFJBQ1Q6ICd5aWVsZC5mYXJtcycsXG4gICAgV0VCSE9PS19QRVJNSVNTSU9OOiAnd2ViaG9vaycsXG4gICAgUFVCTElDX1BFUk1JU1NJT046ICdwdWJsaWMnLFxuICAgIExJR0hUX1BFUk1JU1NJT046ICdsaWdodCcsXG4gICAgV1JBUF9BVVRIX0FDVElPTjogV1JBUF9BVVRIX0FDVElPTixcbiAgICBNRVRBTF9FTkRQT0lOVDogY2hhaW4gPT09ICdwcm90b24nID8gJ2h0dHBzOi8vY2lycnVzLm1ldGFscGF5LmNvbScgOiAnaHR0cHM6Ly9jaXJydXMtZGV2Lm1ldGFscGF5LmNvbScsXG4gICAgTUVUQUxfUFJPVE9OX0VORFBPSU5UOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyAnaHR0cHM6Ly9hcGkucHJvdG9uY2hhaW4uY29tJyA6ICdodHRwczovL2FwaS1kZXYucHJvdG9uY2hhaW4uY29tJyxcbiAgICBQUk9UT05fRU5EUE9JTlRTOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyBbJ2h0dHBzOi8vcHJvdG9uLmdyZXltYXNzLmNvbScsICdodHRwczovL3Byb3Rvbi5lb3NjYWZlYmxvY2suY29tJywgJ2h0dHBzOi8vcHJvdG9uLmNyeXB0b2xpb25zLmlvJywgJ2h0dHBzOi8vcHJvdG9uLmVvc3VzYS5uZXdzJ10gOiBbJ2h0dHBzOi8vdGVzdG5ldC5wcm90b25jaGFpbi5jb20nXSxcbiAgICBDSEFJTl9JRDogY2hhaW4gPT09ICdwcm90b24nID8gJzM4NGRhODg4MTEyMDI3ZjAzMjE4NTBhMTY5ZjczN2MzM2U1M2IzODhhYWQ0OGI1YWRhY2U0YmFiOTdmNDM3ZTAnIDogJzcxZWU4M2JjZjUyMTQyZDYxMDE5ZDk1ZjljYzU0MjdiYTZhMGQ3ZmY4YWNjZDllMjA4OGFlMmFiZWFmM2QzZGQnLFxuICAgIENIQUlOOiBjaGFpbixcbiAgICBTV0FQX0NPSU5TOiBzd2FwQ29pbnMsXG4gICAgQlJJREdFX0NPSU5TOiBicmlkZ2VDb2lucyxcbiAgICBBTExfRU5BQkxFRF9DT0lOUzogYWxsRW5hYmxlZENvaW5zLFxuICAgIExFTkRfQ09JTlM6IGxlbmRDb2lucyxcbiAgICBCT1JST1dfQ09JTlM6IGJvcnJvd0NvaW5zLFxuICAgIExPQU5fQ09JTlM6IGxvYW5Db2lucyxcbiAgICBBTExfQ09JTlM6IGFsbENvaW5zLFxuICAgIGZpbmRCcmlkZ2VDb2luV2FsbGV0QnlYdG9rZW5BbmRDaGFpbjogZnVuY3Rpb24gZmluZEJyaWRnZUNvaW5XYWxsZXRCeVh0b2tlbkFuZENoYWluKHh0b2tlblN5bWJvbCwgY2hhaW4pIHtcbiAgICAgIHZhciBicmlkZ2VDb2luID0gY29uc3RhbnRzLkJSSURHRV9DT0lOUy5maW5kKGZ1bmN0aW9uIChicmlkZ2VDb2luKSB7XG4gICAgICAgIHJldHVybiBicmlkZ2VDb2luLnh0b2tlblN5bWJvbCA9PT0geHRva2VuU3ltYm9sO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWJyaWRnZUNvaW4pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgYnJpZGdlV2FsbGV0ID0gYnJpZGdlQ29pbi53YWxsZXRzLmZpbmQoZnVuY3Rpb24gKGJyaWRnZVdhbGxldCkge1xuICAgICAgICByZXR1cm4gYnJpZGdlV2FsbGV0LmNoYWluID09PSBjaGFpbjtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFicmlkZ2VXYWxsZXQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGJyaWRnZUNvaW4sIGJyaWRnZVdhbGxldCk7XG4gICAgfSxcbiAgICBmaW5kQnJpZGdlQ29pbldhbGxldDogZnVuY3Rpb24gZmluZEJyaWRnZUNvaW5XYWxsZXQoY29pbiwgd2FsbGV0KSB7XG4gICAgICB2YXIgYnJpZGdlQ29pbiA9IGNvbnN0YW50cy5CUklER0VfQ09JTlMuZmluZChmdW5jdGlvbiAoYnJpZGdlQ29pbikge1xuICAgICAgICByZXR1cm4gYnJpZGdlQ29pbi5jb2luID09PSBjb2luO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWJyaWRnZUNvaW4pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgYnJpZGdlV2FsbGV0ID0gYnJpZGdlQ29pbi53YWxsZXRzLmZpbmQoZnVuY3Rpb24gKGJyaWRnZVdhbGxldCkge1xuICAgICAgICByZXR1cm4gYnJpZGdlV2FsbGV0LndhbGxldCA9PT0gd2FsbGV0O1xuICAgICAgfSk7XG4gICAgICBpZiAoIWJyaWRnZVdhbGxldCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYnJpZGdlQ29pbiwgYnJpZGdlV2FsbGV0KTtcbiAgICB9LFxuICAgIGZpbmRCcmlkZ2VDb2luTmV0d29yazogZnVuY3Rpb24gZmluZEJyaWRnZUNvaW5OZXR3b3JrKGNvaW4sIG5ldHdvcmspIHtcbiAgICAgIHZhciBicmlkZ2VDb2luID0gY29uc3RhbnRzLkJSSURHRV9DT0lOUy5maW5kKGZ1bmN0aW9uIChicmlkZ2VDb2luKSB7XG4gICAgICAgIHJldHVybiBicmlkZ2VDb2luLmNvaW4gPT09IGNvaW47XG4gICAgICB9KTtcbiAgICAgIGlmICghYnJpZGdlQ29pbikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBicmlkZ2VXYWxsZXQgPSBicmlkZ2VDb2luLndhbGxldHMuZmluZChmdW5jdGlvbiAoYnJpZGdlV2FsbGV0KSB7XG4gICAgICAgIHJldHVybiBicmlkZ2VXYWxsZXQubmV0d29yayA9PT0gbmV0d29yaztcbiAgICAgIH0pO1xuICAgICAgaWYgKCFicmlkZ2VXYWxsZXQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGJyaWRnZUNvaW4sIGJyaWRnZVdhbGxldCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gY29uc3RhbnRzO1xufTtcblxudmFyIGNyZWF0ZUFic3RyYWN0QXV0aFBhcnNlciA9IGZ1bmN0aW9uIGNyZWF0ZUFic3RyYWN0QXV0aFBhcnNlcihjb250cmFjdCwgYWN0aW9uLCBkYXRhKSB7XG4gIHJldHVybiBvYmplY3Qoe1xuICAgIHNpZ25lcjogYXV0aG9yaXphdGlvblBhcnNlcixcbiAgICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSkubGVuZ3RoKDEpLFxuICAgIHRyYW5zYWN0aW9uOiBzaW5nbGVBY3Rpb25UcmFuc2FjdGlvblBhcnNlcihjb250cmFjdCwgYWN0aW9uLCBkYXRhKVxuICB9KTtcbn07XG52YXIgZ2VuZXJhdGVBdXRoRGF0YSA9IHtcbiAgdGltZTogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBwcm90b25BY2NvdW50OiAvKiNfX1BVUkVfXyovc3RyaW5nKClcbn07XG52YXIgZ2VuZXJhdGVBdXRoUGFyc2VyID0gLyojX19QVVJFX18qL2NyZWF0ZUFic3RyYWN0QXV0aFBhcnNlcihXUkFQX0NPTlRSQUNULCBXUkFQX0FVVEhfQUNUSU9OLCBnZW5lcmF0ZUF1dGhEYXRhKTtcblxudmFyIGFkZHJlc3NQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgaW5kZXg6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgYWNjb3VudDogYWNjb3VudFBhcnNlcixcbiAgY2hhaW46IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgYWRkcmVzczogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBhZGRyZXNzX2hhc2g6IC8qI19fUFVSRV9fKi9zdHJpbmcoKVxufSk7XG52YXIgZ2VuZXJhdGVBZGRyZXNzQm9keVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBjb2luOiBzdHJpbmcoKSxcbiAgd2FsbGV0OiBzdHJpbmcoKVxufSkubWVyZ2UoZ2VuZXJhdGVBdXRoUGFyc2VyKTtcbnZhciBnZW5lcmF0ZUFkZHJlc3NSZXNwb25zZSA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBpZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBhZGRyZXNzOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNvaW46IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgd2FsbGV0OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIG1lbW86IC8qI19fUFVSRV9fKi9zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcblxudmFyIHJhdGVQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgY291bnRlckN1cnJlbmN5OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHByaWNlOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHByaWNlQ2hhbmdlUGVyY2VudDogLyojX19QVVJFX18qL251bWJlcigpLFxuICBtYXJrZXRDYXA6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgdm9sdW1lOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogLyojX19QVVJFX18qL251bWJlcigpXG59KTtcbnZhciBleGNoYW5nZVJhdGVQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgY29udHJhY3Q6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgc3ltYm9sOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHJhbms6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgcmF0ZXM6IC8qI19fUFVSRV9fKi9hcnJheShyYXRlUGFyc2VyKVxufSk7XG52YXIgZXhjaGFuZ2VSYXRlc1BhcnNlciA9IC8qI19fUFVSRV9fKi9hcnJheShleGNoYW5nZVJhdGVQYXJzZXIpO1xuXG52YXIgVHlwZTtcblxuKGZ1bmN0aW9uIChUeXBlKSB7XG4gIFR5cGVbXCJSRUNFSVZFXCJdID0gXCJyZWNlaXZlXCI7XG4gIFR5cGVbXCJTRU5EXCJdID0gXCJzZW5kXCI7XG59KShUeXBlIHx8IChUeXBlID0ge30pKTtcblxudmFyIGRlcG9zaXRCb2R5UGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHR5cGU6IC8qI19fUFVSRV9fKi9uYXRpdmVFbnVtKFR5cGUpLFxuICBoYXNoOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNvaW46IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgd2FsbGV0OiAvKiNfX1BVUkVfXyovc3RyaW5nKClcbn0pO1xudmFyIHRyYW5zYWN0aW9uUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHdhbGxldDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB2YWx1ZTogLyojX19QVVJFX18qL251bWJlcigpLFxuICB2YWx1ZVN0cmluZzogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBhZGRyZXNzOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHR5cGU6IC8qI19fUFVSRV9fKi9uYXRpdmVFbnVtKFR5cGUpLFxuICBzdGF0ZTogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjb25maXJtYXRpb25zOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIGhhc2g6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgYmxvY2tIYXNoOiAvKiNfX1BVUkVfXyovc3RyaW5nKCkub3B0aW9uYWwoKS5udWxsYWJsZSgpLFxuICBibG9ja0hlaWdodDogLyojX19QVVJFX18qL251bWJlcigpLm9wdGlvbmFsKCkubnVsbGFibGUoKVxufSk7XG5cbnZhciBvdGNPcmRlclJlc3BvbnNlUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIHN1Y2Nlc3M6IC8qI19fUFVSRV9fKi9ib29sZWFuKCksXG4gIHRyYW5zYWN0aW9uX2lkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGVycm9ybXNnOiAvKiNfX1BVUkVfXyovc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG52YXIgb3RjUXVvdGVCb2R5UGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGJhc2VBbW91bnQ6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgYmFzZVN5bWJvbDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBxdW90ZVN5bWJvbDogLyojX19QVVJFX18qL3N0cmluZygpXG59KTtcbnZhciBvdGNRdW90ZVJlc3BvbnNlUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIHN1Y2Nlc3M6IC8qI19fUFVSRV9fKi9ib29sZWFuKCksXG4gIHRva2VuOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHF0eTogLyojX19QVVJFX18qL251bWJlcigpLFxuICBlcnJvcm1zZzogLyojX19QVVJFX18qL3N0cmluZygpLm9wdGlvbmFsKClcbn0pO1xuXG52YXIgd2l0aGRyYXdEYXRhID0ge1xuICBmcm9tOiAvKiNfX1BVUkVfXyovc3RyaW5nKCkucmVmaW5lKGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsICE9PSBXUkFQX0NPTlRSQUNUO1xuICB9LCB7XG4gICAgbWVzc2FnZTogV1JBUF9DT05UUkFDVCArIFwiIG11c3QgYmUgcmVjZWl2ZXJcIlxuICB9KSxcbiAgdG86IC8qI19fUFVSRV9fKi9saXRlcmFsKFdSQVBfQ09OVFJBQ1QpLFxuICBxdWFudGl0eTogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBtZW1vOiAvKiNfX1BVUkVfXyovc3RyaW5nKClcbn07XG52YXIgd2l0aGRyYXdCb2R5UGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIHNpZ25lcjogYXV0aG9yaXphdGlvblBhcnNlcixcbiAgc2lnbmF0dXJlczogLyojX19QVVJFX18qL2FycmF5KHN0cmluZygpKS5sZW5ndGgoMSksXG4gIHRyYW5zYWN0aW9uOiAvKiNfX1BVUkVfXyovc2luZ2xlQWN0aW9uVHJhbnNhY3Rpb25QYXJzZXIoJyonLCAndHJhbnNmZXInLCB3aXRoZHJhd0RhdGEpLFxuICBxdW90ZUlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHByb3ZpZGVyOiAvKiNfX1BVUkVfXyovc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG52YXIgd2l0aGRyYXdNZXRhbFJlc3BvbnNlUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIHN1Y2Nlc3M6IC8qI19fUFVSRV9fKi9ib29sZWFuKCksXG4gIGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKClcbn0pO1xudmFyIHdpdGhkcmF3YWxGZWVRdW90ZVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBxdW90ZUlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGVzdGltYXRlZEZlZTogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjdXJyZW5jeTogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBuZXR3b3JrOiAvKiNfX1BVUkVfXyovc3RyaW5nKClcbn0pO1xuXG52YXIgd2l0aGRyYXdIaXN0b3J5TWV0YWxTd2FwUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHN0YXR1czogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBhbW91bnQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY3VycmVuY3k6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgbmV0d29yazogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjcmVhdGVkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHdpdGhkcmF3YWxBZGRyZXNzOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHdpdGhkcmF3YWxIYXNoOiAvKiNfX1BVUkVfXyovc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG52YXIgd2l0aGRyYXdIaXN0b3J5TWV0YWxSZXNwb25zZVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBzd2FwczogLyojX19QVVJFX18qL2FycmF5KHdpdGhkcmF3SGlzdG9yeU1ldGFsU3dhcFBhcnNlciksXG4gIHBhZ2U6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgcGFnZVNpemU6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgbnVtYmVyT2ZFbGVtZW50czogLyojX19QVVJFX18qL251bWJlcigpLFxuICB0b3RhbFBhZ2VzOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHRvdGFsRWxlbWVudHM6IC8qI19fUFVSRV9fKi9udW1iZXIoKVxufSk7XG5cbnZhciBTdGF0dXM7XG5cbihmdW5jdGlvbiAoU3RhdHVzKSB7XG4gIFN0YXR1c1tcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgU3RhdHVzW1wiU1VDQ0VTU1wiXSA9IFwic3VjY2Vzc1wiO1xuICBTdGF0dXNbXCJGQUlMXCJdID0gXCJmYWlsXCI7XG4gIFN0YXR1c1tcIlBST0NFU1NJTkdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbn0pKFN0YXR1cyB8fCAoU3RhdHVzID0ge30pKTtcblxudmFyIHdyYXBTdGFydFBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBiYWxhbmNlOiBFeHRlbmRlZEFzc2V0UGFyc2VyLFxuICBpZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB0eGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNoYWluOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGRlcG9zaXRfYWRkcmVzczogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjb25maXJtYXRpb25zOiAvKiNfX1BVUkVfXyovbnVtYmVyKClcbn0pO1xudmFyIHdyYXBTZXRDb25mUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIHdyYXBfaGFzaDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjb25maXJtYXRpb25zOiAvKiNfX1BVUkVfXyovbnVtYmVyKClcbn0pO1xudmFyIHdyYXBQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgaW5kZXg6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgcHJvdG9uX2FjY291bnQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgYmFsYW5jZTogRXh0ZW5kZWRBc3NldFBhcnNlcixcbiAgaWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgdHhpZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjaGFpbjogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBkZXBvc2l0X2FkZHJlc3M6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgc3RhdHVzOiAvKiNfX1BVUkVfXyovbmF0aXZlRW51bShTdGF0dXMpLFxuICBmaW5pc2hfdHhpZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB3cmFwX2hhc2g6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY29uZmlybWF0aW9uczogLyojX19QVVJFX18qL251bWJlcigpXG59KTtcblxudmFyIGlzU2FtZVRva2VuID0gZnVuY3Rpb24gaXNTYW1lVG9rZW4odG9rZW4xLCB0b2tlbjIpIHtcbiAgcmV0dXJuIHRva2VuMS54dG9rZW5TeW1ib2wgPT09IHRva2VuMi54dG9rZW5TeW1ib2wgJiYgdG9rZW4xLnh0b2tlblByZWNpc2lvbiA9PT0gdG9rZW4yLnh0b2tlblByZWNpc2lvbiAmJiB0b2tlbjEueHRva2VuQ29udHJhY3QgPT09IHRva2VuMi54dG9rZW5Db250cmFjdDtcbn07XG5cbmV4cG9ydCB7IENoYWlucywgRXh0ZW5kZWRBc3NldFBhcnNlciwgTmV0d29ya3MsIFN0YXR1cywgVHlwZSwgV1JBUF9BVVRIX0FDVElPTiwgV1JBUF9DT05UUkFDVCwgYWNjb3VudFBhcnNlciwgYWRkcmVzc1BhcnNlciwgYXV0aG9yaXphdGlvblBhcnNlciwgYXV0aG9yaXphdGlvbnNQYXJzZXIsIGJhc2VBY3Rpb25QYXJzZXIsIGJhc2VBY3Rpb25TZXJpYWxpemVkUGFyc2VyLCBjcmVhdGVBYnN0cmFjdEF1dGhQYXJzZXIsIGRlcG9zaXRCb2R5UGFyc2VyLCBleGNoYW5nZVJhdGVQYXJzZXIsIGV4Y2hhbmdlUmF0ZXNQYXJzZXIsIGV4cGxvcmVyTGlua0J5Q2hhaW4sIGdlbmVyYXRlQWRkcmVzc0JvZHlQYXJzZXIsIGdlbmVyYXRlQWRkcmVzc1Jlc3BvbnNlLCBnZW5lcmF0ZUF1dGhQYXJzZXIsIGluaXRpYWxpemVDb2lucywgaW5pdGlhbGl6ZUNvbnN0YW50cywgaXNTYW1lVG9rZW4sIG90Y09yZGVyUmVzcG9uc2VQYXJzZXIsIG90Y1F1b3RlQm9keVBhcnNlciwgb3RjUXVvdGVSZXNwb25zZVBhcnNlciwgcmF0ZVBhcnNlciwgc2ltaWxhckNoYWlucywgc2luZ2xlQWN0aW9uVHJhbnNhY3Rpb25QYXJzZXIsIHRyYW5zYWN0aW9uUGFyc2VyLCB3ZWJhdXRoQWN0aW9uUGFyc2VyLCB3aXRoZHJhd0JvZHlQYXJzZXIsIHdpdGhkcmF3SGlzdG9yeU1ldGFsUmVzcG9uc2VQYXJzZXIsIHdpdGhkcmF3SGlzdG9yeU1ldGFsU3dhcFBhcnNlciwgd2l0aGRyYXdNZXRhbFJlc3BvbnNlUGFyc2VyLCB3aXRoZHJhd2FsRmVlUXVvdGVQYXJzZXIsIHdyYXBQYXJzZXIsIHdyYXBTZXRDb25mUGFyc2VyLCB3cmFwU3RhcnRQYXJzZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXAtY29uc3RhbnRzLmVzbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsXCIpO1xuZXhwb3J0cy5ab2RFcnJvckNvZGUgPSB1dGlsXzEudXRpbC5hcnJheVRvRW51bShbXG4gICAgJ2ludmFsaWRfdHlwZScsXG4gICAgJ25vbmVtcHR5X2FycmF5X2lzX2VtcHR5JyxcbiAgICAnY3VzdG9tX2Vycm9yJyxcbiAgICAnaW52YWxpZF91bmlvbicsXG4gICAgJ2ludmFsaWRfbGl0ZXJhbF92YWx1ZScsXG4gICAgJ2ludmFsaWRfZW51bV92YWx1ZScsXG4gICAgJ3VucmVjb2duaXplZF9rZXlzJyxcbiAgICAnaW52YWxpZF9hcmd1bWVudHMnLFxuICAgICdpbnZhbGlkX3JldHVybl90eXBlJyxcbiAgICAnaW52YWxpZF9kYXRlJyxcbiAgICAnaW52YWxpZF9zdHJpbmcnLFxuICAgICd0b29fc21hbGwnLFxuICAgICd0b29fYmlnJyxcbl0pO1xuZXhwb3J0cy5xdW90ZWxlc3NKc29uID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTsgLy8ge1wibmFtZVwiOlwiSm9obiBTbWl0aFwifVxuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgJyQxOicpO1xufTtcbnZhciBab2RFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kRXJyb3IoZXJyb3JzKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXJyb3JzID0gW107XG4gICAgICAgIF90aGlzLmFkZEVycm9yID0gZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgX3RoaXMuZXJyb3JzID0gX3RoaXMuZXJyb3JzLmNvbmNhdChbc3ViXSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFkZEVycm9ycyA9IGZ1bmN0aW9uIChzdWJzKSB7XG4gICAgICAgICAgICBpZiAoc3VicyA9PT0gdm9pZCAwKSB7IHN1YnMgPSBbXTsgfVxuICAgICAgICAgICAgX3RoaXMuZXJyb3JzID0gX3RoaXMuZXJyb3JzLmNvbmNhdChzdWJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZmxhdHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICAgICAgdmFyIGZvcm1FcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5lcnJvcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKHN1Yi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChzdWIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZm9ybUVycm9yczogZm9ybUVycm9ycywgZmllbGRFcnJvcnM6IGZpZWxkRXJyb3JzIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlc3RvcmUgcHJvdG90eXBlIGNoYWluXG4gICAgICAgIHZhciBhY3R1YWxQcm90byA9IF9uZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kRXJyb3IucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmVycm9ycywgbnVsbCwgMik7XG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLmxlbmd0aCArIFwiIHZhbGlkYXRpb24gaXNzdWUocylcIixcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5lcnJvcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFN0cmluZyA9IGVyci5wYXRoLmpvaW4oJy4nKSB8fCAnW1tyb290XV0nO1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZS5wdXNoKFwiICBJc3N1ZSAjXCIgKyB0aGlzLmVycm9ycy5pbmRleE9mKGVycikgKyBcIjogXCIgKyBlcnIuY29kZSArIFwiIGF0IFwiICsgcGF0aFN0cmluZyk7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlLnB1c2goXCIgIFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZS5wdXNoKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2Uuam9pbignXFxuJyk7XG4gICAgICAgICAgICAvLyByZXR1cm4gcXVvdGVsZXNzSnNvbih0aGlzKTtcbiAgICAgICAgICAgIC8vIC5tYXAoKHsgcGF0aCwgbWVzc2FnZSB9KSA9PiB7XG4gICAgICAgICAgICAvLyAgIHJldHVybiBwYXRoLmxlbmd0aCA/IGAke3BhdGguam9pbignLi9pbmRleCcpfTogJHttZXNzYWdlfWAgOiBgJHttZXNzYWdlfWA7XG4gICAgICAgICAgICAvLyB9KVxuICAgICAgICAgICAgLy8gLmpvaW4oJ1xcbicpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kRXJyb3IucHJvdG90eXBlLCBcImlzRW1wdHlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9ycy5sZW5ndGggPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RFcnJvci5wcm90b3R5cGUsIFwiZm9ybUVycm9yc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBab2RFcnJvci5jcmVhdGUgPSBmdW5jdGlvbiAoZXJyb3JzKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBab2RFcnJvcihlcnJvcnMpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlpvZEVycm9yID0gWm9kRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ab2RFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2luZGV4XCIpKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxcIik7XG52YXIgaXNPcHRpb25hbCA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICB2YXIgZGVmID0gc2NoZW1hLl9kZWY7XG4gICAgaWYgKGRlZi50ID09PSB6LlpvZFR5cGVzLnVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZWxzZSBpZiAoZGVmLnQgPT09IHouWm9kVHlwZXMuaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBpc09wdGlvbmFsKGRlZi5yaWdodCkgJiYgaXNPcHRpb25hbChkZWYubGVmdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi50ID09PSB6LlpvZFR5cGVzLnVuaW9uKSB7XG4gICAgICAgIHJldHVybiBkZWYub3B0aW9ucy5tYXAoaXNPcHRpb25hbCkuc29tZShmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gdHJ1ZTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG52YXIgWm9kQ29kZUdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBab2RDb2RlR2VuZXJhdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNlZW4gPSBbXTtcbiAgICAgICAgdGhpcy5zZXJpYWwgPSAwO1xuICAgICAgICB0aGlzLnJhbmRvbUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSVpvZFwiICsgX3RoaXMuc2VyaWFsKys7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmluZEJ5U2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlZW4uZmluZChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5zY2hlbWEgPT09IHNjaGVtYTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmluZEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IF90aGlzLnNlZW4uZmluZChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5pZCA9PT0gaWQ7IH0pO1xuICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmZvdW5kIElEOiBcIiArIGlkKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxudHlwZSBJZGVudGl0eTxUPiA9IFQ7XFxuXFxuXCIgKyBfdGhpcy5zZWVuXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gXCJ0eXBlIFwiICsgaXRlbS5pZCArIFwiID0gSWRlbnRpdHk8XCIgKyBpdGVtLnR5cGUgKyBcIj47XCI7IH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcblxcbicpICsgXCJcXG5cIjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRUeXBlID0gZnVuY3Rpb24gKGlkLCB0eXBlKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBfdGhpcy5maW5kQnlJZChpZCk7XG4gICAgICAgICAgICBmb3VuZC50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IF90aGlzLmZpbmRCeVNjaGVtYShzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIHZhciBkZWYgPSBzY2hlbWEuX2RlZjtcbiAgICAgICAgICAgIHZhciBpZCA9IF90aGlzLnJhbmRvbUlkKCk7XG4gICAgICAgICAgICB2YXIgdHkgPSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiX19JTkNPTVBMRVRFX19cIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5zZWVuLnB1c2godHkpO1xuICAgICAgICAgICAgc3dpdGNoIChkZWYudCkge1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5zdHJpbmc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcInN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMubnVtYmVyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmJpZ2ludDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwiYmlnaW50XCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5ib29sZWFuOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJib29sZWFuXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5kYXRlOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJEYXRlXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy51bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcInVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMubnVsbDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwibnVsbFwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMuYW55OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJhbnlcIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnVua25vd246XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcInVua25vd25cIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnZvaWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcInZvaWRcIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmxpdGVyYWw6XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBkZWYudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXRlcmFsVHlwZSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gXCJcXFwiXCIgKyB2YWwgKyBcIlxcXCJcIiA6IFwiXCIgKyB2YWw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBsaXRlcmFsVHlwZSk7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmVudW06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBkZWYudmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gXCJcXFwiXCIgKyB2ICsgXCJcXFwiXCI7IH0pLmpvaW4oJyB8ICcpKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMub2JqZWN0OlxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0TGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gZGVmLnNoYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkU2NoZW1hID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFR5cGUgPSBfdGhpcy5nZW5lcmF0ZShjaGlsZFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgT1BUS0VZID0gaXNPcHRpb25hbChjaGlsZFNjaGVtYSkgPyAnPycgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdExpbmVzLnB1c2goXCJcIiArIGtleSArIE9QVEtFWSArIFwiOiBcIiArIGNoaWxkVHlwZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VTdHJ1Y3QgPSBcIntcXG5cIiArIG9iamVjdExpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBcIiAgXCIgKyBsaW5lICsgXCI7XCI7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJykgKyBcIlxcbn1cIjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0VHlwZShpZCwgXCJcIiArIGJhc2VTdHJ1Y3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMudHVwbGU6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZUxpbmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBkZWYuaXRlbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxTY2hlbWEgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxUeXBlID0gX3RoaXMuZ2VuZXJhdGUoZWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVMaW5lcy5wdXNoKGVsVHlwZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VUdXBsZSA9IFwiW1xcblwiICsgdHVwbGVMaW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gXCIgIFwiICsgbGluZSArIFwiLFwiOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpICsgXCJcXG5dXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcIlwiICsgYmFzZVR1cGxlKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMuYXJyYXk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBfdGhpcy5nZW5lcmF0ZShkZWYudHlwZSkuaWQgKyBcIltdXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5mdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBfdGhpcy5nZW5lcmF0ZShkZWYuYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5zID0gX3RoaXMuZ2VuZXJhdGUoZGVmLnJldHVybnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCIoLi4uYXJnczogXCIgKyBhcmdzLmlkICsgXCIpPT5cIiArIHJldHVybnMuaWQpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5wcm9taXNlOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbVZhbHVlID0gX3RoaXMuZ2VuZXJhdGUoZGVmLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJQcm9taXNlPFwiICsgcHJvbVZhbHVlLmlkICsgXCI+XCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy51bmlvbjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuaW9uTGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGRlZi5vcHRpb25zOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsU2NoZW1hID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsVHlwZSA9IF90aGlzLmdlbmVyYXRlKGVsU2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaW9uTGluZXMucHVzaChlbFR5cGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCB1bmlvbkxpbmVzLmpvaW4oXCIgfCBcIikpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5pbnRlcnNlY3Rpb246XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBfdGhpcy5nZW5lcmF0ZShkZWYubGVmdCkuaWQgKyBcIiAmIFwiICsgX3RoaXMuZ2VuZXJhdGUoZGVmLnJpZ2h0KS5pZCk7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnJlY29yZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwie1trOnN0cmluZ106IFwiICsgX3RoaXMuZ2VuZXJhdGUoZGVmLnZhbHVlVHlwZSkuaWQgKyBcIn1cIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmxhenk6XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXp5VHlwZSA9IGRlZi5nZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIF90aGlzLmdlbmVyYXRlKGxhenlUeXBlKS5pZCk7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm5hdGl2ZUVudW06XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGxhenlUeXBlID0gZGVmLmdldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgJ2FzZGYnKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMua2V5b2Y6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGxhenlUeXBlID0gZGVmLmdldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJrZXlvZiBbXCIgKyBkZWYudmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IFwiXFxcIlwiICsgdmFsICsgXCJcXFwiXCIgOiB2YWwpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLnV0aWwuYXNzZXJ0TmV2ZXIoZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5maW5kQnlJZChpZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFpvZENvZGVHZW5lcmF0b3IuY3JlYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFpvZENvZGVHZW5lcmF0b3IoKTsgfTtcbiAgICByZXR1cm4gWm9kQ29kZUdlbmVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlpvZENvZGVHZW5lcmF0b3IgPSBab2RDb2RlR2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWdlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBab2RFcnJvcl8xID0gcmVxdWlyZShcIi4vWm9kRXJyb3JcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsXCIpO1xuZXhwb3J0cy5kZWZhdWx0RXJyb3JNYXAgPSBmdW5jdGlvbiAoZXJyb3IsIF9jdHgpIHtcbiAgICB2YXIgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoZXJyb3IucmVjZWl2ZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9ICdSZXF1aXJlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJFeHBlY3RlZCBcIiArIGVycm9yLmV4cGVjdGVkICsgXCIsIHJlY2VpdmVkIFwiICsgZXJyb3IucmVjZWl2ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5ub25lbXB0eV9hcnJheV9pc19lbXB0eTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkxpc3QgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBpdGVtXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiBcIiArIGVycm9yLmtleXMubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBcIidcIiArIGsgKyBcIidcIjsgfSkuam9pbignLCAnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gY2FzZSBab2RFcnJvckNvZGUuaW52YWxpZF90dXBsZV9sZW5ndGg6XG4gICAgICAgIC8vICAgbWVzc2FnZSA9IGBFeHBlY3RlZCBsaXN0IG9mICR7ZXJyb3IuZXhwZWN0ZWR9IGl0ZW1zLCByZWNlaXZlZCAke2Vycm9yLnJlY2VpdmVkfSBpdGVtc2A7XG4gICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9saXRlcmFsX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW5wdXQgbXVzdCBiZSBcXFwiXCIgKyBlcnJvci5leHBlY3RlZCArIFwiXFxcIlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW5wdXQgbXVzdCBiZSBvbmUgb2YgdGhlc2UgdmFsdWVzOiBcIiArIGVycm9yLm9wdGlvbnMuam9pbignLCAnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGRhdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBjYXNlIFpvZEVycm9yQ29kZS50b29fc21hbGw6XG4gICAgICAgIC8vICAgY29uc3QgdG9vU2hvcnROb3VuID0gX2N0eC5kYXRhID09PSAnc3RyaW5nJyA/ICdjaGFyYWN0ZXJzJyA6ICdpdGVtcyc7XG4gICAgICAgIC8vICAgbWVzc2FnZSA9IGBUb28gc2hvcnQsIHNob3VsZCBiZSBhdCBsZWFzdCAke2Vycm9yLm1pbmltdW19ICR7dG9vU2hvcnROb3VufWA7XG4gICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgIC8vIGNhc2UgWm9kRXJyb3JDb2RlLnRvb19iaWc6XG4gICAgICAgIC8vICAgY29uc3QgdG9vTG9uZ05vdW4gPSBfY3R4LmRhdGEgPT09ICdzdHJpbmcnID8gJ2NoYXJhY3RlcnMnIDogJ2l0ZW1zJztcbiAgICAgICAgLy8gICBtZXNzYWdlID0gYFRvbyBzaG9ydCwgc2hvdWxkIGJlIGF0IG1vc3QgJHtlcnJvci5tYXhpbXVtfSAke3Rvb0xvbmdOb3VufWA7XG4gICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAoZXJyb3IudmFsaWRhdGlvbiAhPT0gJ3JlZ2V4JylcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIFwiICsgZXJyb3IudmFsaWRhdGlvbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ0ludmFsaWQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGNhc2UgWm9kRXJyb3JDb2RlLmludmFsaWRfdXJsOlxuICAgICAgICAvLyAgIG1lc3NhZ2UgPSAnSW52YWxpZCBVUkwuJztcbiAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgLy8gY2FzZSBab2RFcnJvckNvZGUuaW52YWxpZF91dWlkOlxuICAgICAgICAvLyAgIG1lc3NhZ2UgPSAnSW52YWxpZCBVVUlELic7XG4gICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX3NtYWxsOlxuICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICdhcnJheScpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiU2hvdWxkIGhhdmUgXCIgKyAoZXJyb3IuaW5jbHVzaXZlID8gXCJhdCBsZWFzdFwiIDogXCJtb3JlIHRoYW5cIikgKyBcIiBcIiArIGVycm9yLm1pbmltdW0gKyBcIiBpdGVtc1wiO1xuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiU2hvdWxkIGJlIFwiICsgKGVycm9yLmluY2x1c2l2ZSA/IFwiYXQgbGVhc3RcIiA6IFwib3ZlclwiKSArIFwiIFwiICsgZXJyb3IubWluaW11bSArIFwiIGNoYXJhY3RlcnNcIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnR5cGUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlZhbHVlIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gXCIgKyAoZXJyb3IuaW5jbHVzaXZlID8gXCJvciBlcXVhbCB0byBcIiA6IFwiXCIpICsgZXJyb3IubWluaW11bTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ0ludmFsaWQgaW5wdXQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSAnYXJyYXknKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlNob3VsZCBoYXZlIFwiICsgKGVycm9yLmluY2x1c2l2ZSA/IFwiYXQgbW9zdFwiIDogXCJsZXNzIHRoYW5cIikgKyBcIiBcIiArIGVycm9yLm1heGltdW0gKyBcIiBpdGVtc1wiO1xuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiU2hvdWxkIGJlIFwiICsgKGVycm9yLmluY2x1c2l2ZSA/IFwiYXQgbW9zdFwiIDogXCJ1bmRlclwiKSArIFwiIFwiICsgZXJyb3IubWF4aW11bSArIFwiIGNoYXJhY3RlcnMgbG9uZ1wiO1xuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiVmFsdWUgc2hvdWxkIGJlIGxlc3MgdGhhbiBcIiArIChlcnJvci5pbmNsdXNpdmUgPyBcIm9yIGVxdWFsIHRvIFwiIDogXCJcIikgKyBlcnJvci5tYXhpbXVtO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnSW52YWxpZCBpbnB1dCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5jdXN0b21fZXJyb3I6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0LlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0LlwiO1xuICAgICAgICAgICAgdXRpbF8xLnV0aWwuYXNzZXJ0TmV2ZXIoZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgLy8gcmV0dXJuIGBJbnZhbGlkIGlucHV0LmA7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdEVycm9yTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSA6IG1lc3NhZ2UgfHwge30pOyB9O1xufSkoZXJyb3JVdGlsID0gZXhwb3J0cy5lcnJvclV0aWwgfHwgKGV4cG9ydHMuZXJyb3JVdGlsID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yVXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmFzZV8xID0gcmVxdWlyZShcIi4uL3R5cGVzL2Jhc2VcIik7XG52YXIgaW50ZXJzZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMvaW50ZXJzZWN0aW9uXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcIi4uL3R5cGVzL29iamVjdFwiKTtcbnZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHZhciBmaXJzdEtleXMgPSBPYmplY3Qua2V5cyhmaXJzdCk7XG4gICAgICAgIHZhciBzZWNvbmRLZXlzID0gT2JqZWN0LmtleXMoc2Vjb25kKTtcbiAgICAgICAgdmFyIHNoYXJlZEtleXMgPSBmaXJzdEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBzZWNvbmRLZXlzLmluZGV4T2YoaykgIT09IC0xOyB9KTtcbiAgICAgICAgdmFyIHNoYXJlZFNoYXBlID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgc2hhcmVkS2V5c18xID0gc2hhcmVkS2V5czsgX2kgPCBzaGFyZWRLZXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgayA9IHNoYXJlZEtleXNfMVtfaV07XG4gICAgICAgICAgICBzaGFyZWRTaGFwZVtrXSA9IGludGVyc2VjdGlvbl8xLlpvZEludGVyc2VjdGlvbi5jcmVhdGUoZmlyc3Rba10sIHNlY29uZFtrXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCBmaXJzdCwgc2Vjb25kLCBzaGFyZWRTaGFwZSk7XG4gICAgfTtcbiAgICBvYmplY3RVdGlsLm1lcmdlT2JqZWN0cyA9IGZ1bmN0aW9uIChmaXJzdCkgeyByZXR1cm4gZnVuY3Rpb24gKHNlY29uZCkge1xuICAgICAgICB2YXIgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKGZpcnN0Ll9kZWYuc2hhcGUoKSwgc2Vjb25kLl9kZWYuc2hhcGUoKSk7XG4gICAgICAgIHZhciBtZXJnZWQgPSBuZXcgb2JqZWN0XzEuWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHQ6IGJhc2VfMS5ab2RUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICBjaGVja3M6IChmaXJzdC5fZGVmLmNoZWNrcyB8fCBbXSkuY29uY2F0KChzZWNvbmQuX2RlZi5jaGVja3MgfHwgW10pKSxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHN0cmljdDogZmlyc3QucGFyYW1zLnN0cmljdCAmJiBzZWNvbmQucGFyYW1zLnN0cmljdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaGFwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVyZ2VkU2hhcGU7IH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH07IH07XG59KShvYmplY3RVdGlsID0gZXhwb3J0cy5vYmplY3RVdGlsIHx8IChleHBvcnRzLm9iamVjdFV0aWwgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0VXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsO1xuKGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpdGVtc18xID0gaXRlbXM7IF9pIDwgaXRlbXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNfMVtfaV07XG4gICAgICAgICAgICBvYmpbaXRlbV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIHZhbGlkS2V5cyA9IE9iamVjdC5rZXlzKG9iaikuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiB0eXBlb2Ygb2JqW29ialtrXV0gIT09ICdudW1iZXInOyB9KTtcbiAgICAgICAgdmFyIGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgdmFsaWRLZXlzXzEgPSB2YWxpZEtleXM7IF9pIDwgdmFsaWRLZXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgayA9IHZhbGlkS2V5c18xW19pXTtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLmdldFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2VdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0VmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG59KSh1dGlsID0gZXhwb3J0cy51dGlsIHx8IChleHBvcnRzLnV0aWwgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qIFpPRCAqL1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3N0cmluZ1wiKTtcbmV4cG9ydHMuWm9kU3RyaW5nID0gc3RyaW5nXzEuWm9kU3RyaW5nO1xudmFyIG51bWJlcl8xID0gcmVxdWlyZShcIi4vdHlwZXMvbnVtYmVyXCIpO1xuZXhwb3J0cy5ab2ROdW1iZXIgPSBudW1iZXJfMS5ab2ROdW1iZXI7XG52YXIgYmlnaW50XzEgPSByZXF1aXJlKFwiLi90eXBlcy9iaWdpbnRcIik7XG5leHBvcnRzLlpvZEJpZ0ludCA9IGJpZ2ludF8xLlpvZEJpZ0ludDtcbnZhciBib29sZWFuXzEgPSByZXF1aXJlKFwiLi90eXBlcy9ib29sZWFuXCIpO1xuZXhwb3J0cy5ab2RCb29sZWFuID0gYm9vbGVhbl8xLlpvZEJvb2xlYW47XG52YXIgZGF0ZV8xID0gcmVxdWlyZShcIi4vdHlwZXMvZGF0ZVwiKTtcbmV4cG9ydHMuWm9kRGF0ZSA9IGRhdGVfMS5ab2REYXRlO1xudmFyIHVuZGVmaW5lZF8xID0gcmVxdWlyZShcIi4vdHlwZXMvdW5kZWZpbmVkXCIpO1xuZXhwb3J0cy5ab2RVbmRlZmluZWQgPSB1bmRlZmluZWRfMS5ab2RVbmRlZmluZWQ7XG52YXIgbnVsbF8xID0gcmVxdWlyZShcIi4vdHlwZXMvbnVsbFwiKTtcbmV4cG9ydHMuWm9kTnVsbCA9IG51bGxfMS5ab2ROdWxsO1xudmFyIGFueV8xID0gcmVxdWlyZShcIi4vdHlwZXMvYW55XCIpO1xuZXhwb3J0cy5ab2RBbnkgPSBhbnlfMS5ab2RBbnk7XG52YXIgdW5rbm93bl8xID0gcmVxdWlyZShcIi4vdHlwZXMvdW5rbm93blwiKTtcbmV4cG9ydHMuWm9kVW5rbm93biA9IHVua25vd25fMS5ab2RVbmtub3duO1xudmFyIHZvaWRfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3ZvaWRcIik7XG5leHBvcnRzLlpvZFZvaWQgPSB2b2lkXzEuWm9kVm9pZDtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vdHlwZXMvYXJyYXlcIik7XG5leHBvcnRzLlpvZEFycmF5ID0gYXJyYXlfMS5ab2RBcnJheTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL29iamVjdFwiKTtcbmV4cG9ydHMuWm9kT2JqZWN0ID0gb2JqZWN0XzEuWm9kT2JqZWN0O1xudmFyIHVuaW9uXzEgPSByZXF1aXJlKFwiLi90eXBlcy91bmlvblwiKTtcbmV4cG9ydHMuWm9kVW5pb24gPSB1bmlvbl8xLlpvZFVuaW9uO1xudmFyIGludGVyc2VjdGlvbl8xID0gcmVxdWlyZShcIi4vdHlwZXMvaW50ZXJzZWN0aW9uXCIpO1xuZXhwb3J0cy5ab2RJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb25fMS5ab2RJbnRlcnNlY3Rpb247XG52YXIgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3R1cGxlXCIpO1xuZXhwb3J0cy5ab2RUdXBsZSA9IHR1cGxlXzEuWm9kVHVwbGU7XG52YXIgcmVjb3JkXzEgPSByZXF1aXJlKFwiLi90eXBlcy9yZWNvcmRcIik7XG5leHBvcnRzLlpvZFJlY29yZCA9IHJlY29yZF8xLlpvZFJlY29yZDtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vdHlwZXMvZnVuY3Rpb25cIik7XG5leHBvcnRzLlpvZEZ1bmN0aW9uID0gZnVuY3Rpb25fMS5ab2RGdW5jdGlvbjtcbnZhciBsYXp5XzEgPSByZXF1aXJlKFwiLi90eXBlcy9sYXp5XCIpO1xuZXhwb3J0cy5ab2RMYXp5ID0gbGF6eV8xLlpvZExhenk7XG52YXIgbGl0ZXJhbF8xID0gcmVxdWlyZShcIi4vdHlwZXMvbGl0ZXJhbFwiKTtcbmV4cG9ydHMuWm9kTGl0ZXJhbCA9IGxpdGVyYWxfMS5ab2RMaXRlcmFsO1xudmFyIGVudW1fMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2VudW1cIik7XG5leHBvcnRzLlpvZEVudW0gPSBlbnVtXzEuWm9kRW51bTtcbnZhciBuYXRpdmVFbnVtXzEgPSByZXF1aXJlKFwiLi90eXBlcy9uYXRpdmVFbnVtXCIpO1xuZXhwb3J0cy5ab2ROYXRpdmVFbnVtID0gbmF0aXZlRW51bV8xLlpvZE5hdGl2ZUVudW07XG52YXIga2V5b2ZfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2tleW9mXCIpO1xudmFyIHByb21pc2VfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3Byb21pc2VcIik7XG5leHBvcnRzLlpvZFByb21pc2UgPSBwcm9taXNlXzEuWm9kUHJvbWlzZTtcbnZhciBiYXNlXzEgPSByZXF1aXJlKFwiLi90eXBlcy9iYXNlXCIpO1xuZXhwb3J0cy5ab2RUeXBlID0gYmFzZV8xLlpvZFR5cGU7XG5leHBvcnRzLlNjaGVtYSA9IGJhc2VfMS5ab2RUeXBlO1xuZXhwb3J0cy5ab2RTY2hlbWEgPSBiYXNlXzEuWm9kVHlwZTtcbmV4cG9ydHMuWm9kVHlwZXMgPSBiYXNlXzEuWm9kVHlwZXM7XG4vLyBpbXBvcnQgeyBab2RFcnJvciwgWm9kRXJyb3JDb2RlLCBab2RJbnZhbGlkVHlwZUVycm9yLFxuLy8gWm9kTm9uRW1wdHlBcnJheUlzRW1wdHlFcnJvcixcbi8vIFpvZFVucmVjb2duaXplZEtleXNFcnJvcixcbi8vIFpvZEludmFsaWRVbmlvbkVycm9yLFxuLy8gWm9kSW52YWxpZExpdGVyYWxWYWx1ZUVycm9yLFxuLy8gWm9kSW52YWxpZEVudW1WYWx1ZUVycm9yLFxuLy8gWm9kSW52YWxpZEFyZ3VtZW50c0Vycm9yLFxuLy8gWm9kSW52YWxpZFJldHVyblR5cGVFcnJvcixcbi8vIFpvZEludmFsaWREYXRlRXJyb3IsXG4vLyBab2RJbnZhbGlkU3RyaW5nRXJyb3IsXG4vLyBab2RUb29TbWFsbEVycm9yLFxuLy8gWm9kVG9vQmlnRXJyb3IsXG4vLyBab2RDdXN0b21FcnJvciB9IGZyb20gJy4vWm9kRXJyb3InO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuZXhwb3J0cy5ab2RQYXJzZWRUeXBlID0gcGFyc2VyXzEuWm9kUGFyc2VkVHlwZTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuZXhwb3J0cy5ab2RDb2RlR2VuZXJhdG9yID0gY29kZWdlbl8xLlpvZENvZGVHZW5lcmF0b3I7XG52YXIgc3RyaW5nVHlwZSA9IHN0cmluZ18xLlpvZFN0cmluZy5jcmVhdGU7XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZ1R5cGU7XG52YXIgbnVtYmVyVHlwZSA9IG51bWJlcl8xLlpvZE51bWJlci5jcmVhdGU7XG5leHBvcnRzLm51bWJlciA9IG51bWJlclR5cGU7XG52YXIgYmlnSW50VHlwZSA9IGJpZ2ludF8xLlpvZEJpZ0ludC5jcmVhdGU7XG5leHBvcnRzLmJpZ2ludCA9IGJpZ0ludFR5cGU7XG52YXIgYm9vbGVhblR5cGUgPSBib29sZWFuXzEuWm9kQm9vbGVhbi5jcmVhdGU7XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuVHlwZTtcbnZhciBkYXRlVHlwZSA9IGRhdGVfMS5ab2REYXRlLmNyZWF0ZTtcbmV4cG9ydHMuZGF0ZSA9IGRhdGVUeXBlO1xudmFyIHVuZGVmaW5lZFR5cGUgPSB1bmRlZmluZWRfMS5ab2RVbmRlZmluZWQuY3JlYXRlO1xuZXhwb3J0cy51bmRlZmluZWQgPSB1bmRlZmluZWRUeXBlO1xudmFyIG51bGxUeXBlID0gbnVsbF8xLlpvZE51bGwuY3JlYXRlO1xuZXhwb3J0cy5udWxsID0gbnVsbFR5cGU7XG52YXIgYW55VHlwZSA9IGFueV8xLlpvZEFueS5jcmVhdGU7XG5leHBvcnRzLmFueSA9IGFueVR5cGU7XG52YXIgdW5rbm93blR5cGUgPSB1bmtub3duXzEuWm9kVW5rbm93bi5jcmVhdGU7XG5leHBvcnRzLnVua25vd24gPSB1bmtub3duVHlwZTtcbnZhciB2b2lkVHlwZSA9IHZvaWRfMS5ab2RWb2lkLmNyZWF0ZTtcbmV4cG9ydHMudm9pZCA9IHZvaWRUeXBlO1xudmFyIGFycmF5VHlwZSA9IGFycmF5XzEuWm9kQXJyYXkuY3JlYXRlO1xuZXhwb3J0cy5hcnJheSA9IGFycmF5VHlwZTtcbnZhciBvYmplY3RUeXBlID0gb2JqZWN0XzEuWm9kT2JqZWN0LmNyZWF0ZTtcbmV4cG9ydHMub2JqZWN0ID0gb2JqZWN0VHlwZTtcbnZhciB1bmlvblR5cGUgPSB1bmlvbl8xLlpvZFVuaW9uLmNyZWF0ZTtcbmV4cG9ydHMudW5pb24gPSB1bmlvblR5cGU7XG52YXIgaW50ZXJzZWN0aW9uVHlwZSA9IGludGVyc2VjdGlvbl8xLlpvZEludGVyc2VjdGlvbi5jcmVhdGU7XG5leHBvcnRzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvblR5cGU7XG52YXIgdHVwbGVUeXBlID0gdHVwbGVfMS5ab2RUdXBsZS5jcmVhdGU7XG5leHBvcnRzLnR1cGxlID0gdHVwbGVUeXBlO1xudmFyIHJlY29yZFR5cGUgPSByZWNvcmRfMS5ab2RSZWNvcmQuY3JlYXRlO1xuZXhwb3J0cy5yZWNvcmQgPSByZWNvcmRUeXBlO1xudmFyIGZ1bmN0aW9uVHlwZSA9IGZ1bmN0aW9uXzEuWm9kRnVuY3Rpb24uY3JlYXRlO1xuZXhwb3J0cy5mdW5jdGlvbiA9IGZ1bmN0aW9uVHlwZTtcbnZhciBsYXp5VHlwZSA9IGxhenlfMS5ab2RMYXp5LmNyZWF0ZTtcbmV4cG9ydHMubGF6eSA9IGxhenlUeXBlO1xudmFyIGxpdGVyYWxUeXBlID0gbGl0ZXJhbF8xLlpvZExpdGVyYWwuY3JlYXRlO1xuZXhwb3J0cy5saXRlcmFsID0gbGl0ZXJhbFR5cGU7XG52YXIgZW51bVR5cGUgPSBlbnVtXzEuWm9kRW51bS5jcmVhdGU7XG5leHBvcnRzLmVudW0gPSBlbnVtVHlwZTtcbnZhciBuYXRpdmVFbnVtVHlwZSA9IG5hdGl2ZUVudW1fMS5ab2ROYXRpdmVFbnVtLmNyZWF0ZTtcbmV4cG9ydHMubmF0aXZlRW51bSA9IG5hdGl2ZUVudW1UeXBlO1xudmFyIHByb21pc2VUeXBlID0gcHJvbWlzZV8xLlpvZFByb21pc2UuY3JlYXRlO1xuZXhwb3J0cy5wcm9taXNlID0gcHJvbWlzZVR5cGU7XG52YXIga2V5b2ZUeXBlID0ga2V5b2ZfMS5ab2RLZXlvZi5jcmVhdGU7XG5leHBvcnRzLmtleW9mID0ga2V5b2ZUeXBlO1xudmFyIG9zdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTsgfTtcbmV4cG9ydHMub3N0cmluZyA9IG9zdHJpbmc7XG52YXIgb251bWJlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bWJlclR5cGUoKS5vcHRpb25hbCgpOyB9O1xuZXhwb3J0cy5vbnVtYmVyID0gb251bWJlcjtcbnZhciBvYm9vbGVhbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTsgfTtcbmV4cG9ydHMub2Jvb2xlYW4gPSBvYm9vbGVhbjtcbnZhciBjb2RlZ2VuID0gY29kZWdlbl8xLlpvZENvZGVHZW5lcmF0b3IuY3JlYXRlO1xuZXhwb3J0cy5jb2RlZ2VuID0gY29kZWdlbjtcbmV4cG9ydHMuY3VzdG9tID0gZnVuY3Rpb24gKGNoZWNrLCBwYXJhbXMpIHsgcmV0dXJuIGFueVR5cGUoKS5yZWZpbmUoY2hlY2ssIHBhcmFtcyk7IH07XG52YXIgaW5zdGFuY2VPZlR5cGUgPSBmdW5jdGlvbiAoY2xzLCBwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge1xuICAgICAgICBtZXNzYWdlOiBcIklucHV0IG5vdCBpbnN0YW5jZSBvZiBcIiArIGNscy5uYW1lLFxuICAgIH07IH1cbiAgICByZXR1cm4gZXhwb3J0cy5jdXN0b20oZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBjbHM7IH0sIHBhcmFtcyk7XG59O1xuZXhwb3J0cy5pbnN0YW5jZW9mID0gaW5zdGFuY2VPZlR5cGU7XG5leHBvcnRzLmxhdGUgPSB7XG4gICAgb2JqZWN0OiBvYmplY3RfMS5ab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ab2RFcnJvclwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2luZGV4XCIpKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxcIik7XG5leHBvcnRzLmlzU2NhbGFyID0gZnVuY3Rpb24gKHNjaGVtYSwgcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHsgcm9vdDogdHJ1ZSB9OyB9XG4gICAgdmFyIGRlZiA9IHNjaGVtYS5fZGVmO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIHN3aXRjaCAoZGVmLnQpIHtcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnN0cmluZzpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubnVtYmVyOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5iaWdpbnQ6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmJvb2xlYW46XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubnVsbDpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuYW55OlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudW5rbm93bjpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnZvaWQ6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5hcnJheTpcbiAgICAgICAgICAgIGlmIChwYXJhbXMucm9vdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBleHBvcnRzLmlzU2NhbGFyKGRlZi50eXBlLCB7IHJvb3Q6IGZhbHNlIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5vYmplY3Q6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy51bmlvbjpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZGVmLm9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGV4cG9ydHMuaXNTY2FsYXIoeCk7IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5pbnRlcnNlY3Rpb246XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGV4cG9ydHMuaXNTY2FsYXIoZGVmLmxlZnQpICYmIGV4cG9ydHMuaXNTY2FsYXIoZGVmLnJpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudHVwbGU6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5sYXp5OlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBleHBvcnRzLmlzU2NhbGFyKGRlZi5nZXR0ZXIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmxpdGVyYWw6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmVudW06XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm5hdGl2ZUVudW06XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmZ1bmN0aW9uOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMucmVjb3JkOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuZGF0ZTpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMucHJvbWlzZTpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmtleW9mOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1dGlsXzEudXRpbC5hc3NlcnROZXZlcihkZWYpO1xuICAgICAgICAvLyByZXR1cm5WYWx1ZSA9IGZhbHNlOyBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2NhbGFyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX3RoaXMgPSB0aGlzO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvYmFzZVwiKSk7XG52YXIgWm9kRXJyb3JfMSA9IHJlcXVpcmUoXCIuL1pvZEVycm9yXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbFwiKTtcbnZhciBkZWZhdWx0RXJyb3JNYXBfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRFcnJvck1hcFwiKTtcbmV4cG9ydHMuZ2V0UGFyc2VkVHlwZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihkYXRhKSlcbiAgICAgICAgICAgIHJldHVybiAnbmFuJztcbiAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdib29sZWFuJylcbiAgICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdiaWdpbnQnKVxuICAgICAgICByZXR1cm4gJ2JpZ2ludCc7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3ltYm9sJylcbiAgICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24nO1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICBpZiAoZGF0YS50aGVuICYmXG4gICAgICAgICAgICB0eXBlb2YgZGF0YS50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBkYXRhLmNhdGNoICYmXG4gICAgICAgICAgICB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuICdwcm9taXNlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIHJldHVybiAndW5rbm93bic7XG59O1xuZXhwb3J0cy5ab2RQYXJzZWRUeXBlID0gdXRpbF8xLnV0aWwuYXJyYXlUb0VudW0oW1xuICAgICdzdHJpbmcnLFxuICAgICduYW4nLFxuICAgICdudW1iZXInLFxuICAgICdpbnRlZ2VyJyxcbiAgICAnYm9vbGVhbicsXG4gICAgJ2RhdGUnLFxuICAgICdiaWdpbnQnLFxuICAgICdzeW1ib2wnLFxuICAgICdmdW5jdGlvbicsXG4gICAgJ3VuZGVmaW5lZCcsXG4gICAgJ251bGwnLFxuICAgICdhcnJheScsXG4gICAgJ29iamVjdCcsXG4gICAgJ3Vua25vd24nLFxuICAgICdwcm9taXNlJyxcbiAgICAndm9pZCcsXG5dKTtcbmV4cG9ydHMuZmluZCA9IGZ1bmN0aW9uIChhcnIsIGNoZWNrZXIpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFycl8xID0gYXJyOyBfaSA8IGFycl8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IGFycl8xW19pXTtcbiAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG52YXIgbWFrZUVycm9yID0gZnVuY3Rpb24gKHBhcmFtcywgb2JqLCBlcnJvckRhdGEpIHtcbiAgICB2YXIgZXJyb3JBcmcgPSBfX2Fzc2lnbih7fSwgZXJyb3JEYXRhLCB7IHBhdGg6IHBhcmFtcy5wYXRoLmNvbmNhdCgoZXJyb3JEYXRhLnBhdGggfHwgW10pKSB9KTtcbiAgICB2YXIgY3R4QXJnID0geyBkYXRhOiBvYmogfTtcbiAgICB2YXIgZGVmYXVsdEVycm9yID0gZGVmYXVsdEVycm9yTWFwXzEuZGVmYXVsdEVycm9yTWFwID09PSBwYXJhbXMuZXJyb3JNYXBcbiAgICAgICAgPyB7IG1lc3NhZ2U6IFwiSW52YWxpZCB2YWx1ZS5cIiB9XG4gICAgICAgIDogZGVmYXVsdEVycm9yTWFwXzEuZGVmYXVsdEVycm9yTWFwKGVycm9yQXJnLCBfX2Fzc2lnbih7fSwgY3R4QXJnLCB7IGRlZmF1bHRFcnJvcjogXCJJbnZhbGlkIHZhbHVlLlwiIH0pKTtcbiAgICByZXR1cm4gX19hc3NpZ24oe30sIGVycm9yRGF0YSwgeyBwYXRoOiBwYXJhbXMucGF0aC5jb25jYXQoKGVycm9yRGF0YS5wYXRoIHx8IFtdKSksIG1lc3NhZ2U6IGVycm9yRGF0YS5tZXNzYWdlIHx8XG4gICAgICAgICAgICBwYXJhbXMuZXJyb3JNYXAoZXJyb3JBcmcsIF9fYXNzaWduKHt9LCBjdHhBcmcsIHsgZGVmYXVsdEVycm9yOiBkZWZhdWx0RXJyb3IubWVzc2FnZSB9KSkubWVzc2FnZSB9KTtcbn07XG5leHBvcnRzLlpvZFBhcnNlciA9IGZ1bmN0aW9uIChzY2hlbWFEZWYpIHsgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGJhc2VQYXJhbXMpIHtcbiAgICBpZiAoYmFzZVBhcmFtcyA9PT0gdm9pZCAwKSB7IGJhc2VQYXJhbXMgPSB7IHNlZW46IFtdLCBlcnJvck1hcDogZGVmYXVsdEVycm9yTWFwXzEuZGVmYXVsdEVycm9yTWFwLCBwYXRoOiBbXSB9OyB9XG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgc2VlbjogYmFzZVBhcmFtcy5zZWVuIHx8IFtdLFxuICAgICAgICBwYXRoOiBiYXNlUGFyYW1zLnBhdGggfHwgW10sXG4gICAgICAgIGVycm9yTWFwOiBiYXNlUGFyYW1zLmVycm9yTWFwIHx8IGRlZmF1bHRFcnJvck1hcF8xLmRlZmF1bHRFcnJvck1hcCxcbiAgICB9O1xuICAgIHZhciBkZWYgPSBzY2hlbWFEZWY7XG4gICAgdmFyIHBhcnNlZFR5cGUgPSBleHBvcnRzLmdldFBhcnNlZFR5cGUob2JqKTtcbiAgICB2YXIgc2NoZW1hU2VlbiA9IGV4cG9ydHMuZmluZChwYXJhbXMuc2VlbiwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2NoZW1hID09PSBzY2hlbWFEZWY7IH0pO1xuICAgIHZhciBpc05vbnByaW1pdGl2ZSA9IFsnYXJyYXknLCAnb2JqZWN0J10uaW5kZXhPZihwYXJzZWRUeXBlKSAhPT0gLTE7XG4gICAgaWYgKGlzTm9ucHJpbWl0aXZlKSB7XG4gICAgICAgIGlmIChzY2hlbWFTZWVuKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBleHBvcnRzLmZpbmQoc2NoZW1hU2Vlbi5vYmplY3RzLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kYXRhID09PSBvYmo7IH0pO1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZvdW5kLmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3VuZC50aW1lcyA9IGZvdW5kLnRpbWVzICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQudGltZXMgPiA1ICYmIGlzTm9ucHJpbWl0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2woJ3JlY3Vyc2lvbiBkZXB0aCBleGNlZWRlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm91bmQudGltZXMgPiAyKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBzY2hlbWFTZWVuLm9iamVjdHMucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLnNlZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWFEZWYsXG4gICAgICAgICAgICAgICAgb2JqZWN0czogW3sgZGF0YTogb2JqLCBlcnJvcjogdW5kZWZpbmVkLCB0aW1lczogMSB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnN0IHNldEVycm9yID0gKGVycm9yOiBFcnJvcikgPT4ge1xuICAgIC8vICAgY29uc3Qgc2NoZW1hU2VlbiA9IHBhcmFtcy5zZWVuLmZpbmQoeCA9PiB4LnNjaGVtYSA9PT0gc2NoZW1hRGVmKTtcbiAgICAvLyAgIGlmIChzY2hlbWFTZWVuKSB7XG4gICAgLy8gICAgIGNvbnN0IGZvdW5kID0gc2NoZW1hU2Vlbi5vYmplY3RzLmZpbmQoeCA9PiB4LmRhdGEgPT09IG9iaik7XG4gICAgLy8gICAgIGlmIChmb3VuZCkge1xuICAgIC8vICAgICAgIGZvdW5kLmVycm9yID0gZXJyb3I7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9O1xuICAgIHZhciBlcnJvciA9IG5ldyBab2RFcnJvcl8xLlpvZEVycm9yKFtdKTtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBvYmo7XG4gICAgc3dpdGNoIChkZWYudCkge1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuc3RyaW5nOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubnVtYmVyOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4ob2JqKSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5iaWdpbnQ6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5ib29sZWFuOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy51bmRlZmluZWQ6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5udWxsOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5hbnk6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnVua25vd246XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnZvaWQ6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5hcnJheTpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBvYmo7XG4gICAgICAgICAgICBpZiAoZGVmLm5vbmVtcHR5ID09PSB0cnVlICYmIG9iai5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUubm9uZW1wdHlfYXJyYXlfaXNfZW1wdHksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZEl0ZW0gPSBkZWYudHlwZS5wYXJzZShpdGVtLCBfX2Fzc2lnbih7fSwgcGFyYW1zLCB7IHBhdGg6IHBhcmFtcy5wYXRoLmNvbmNhdChbaV0pIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHplcnIgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9ycyh6ZXJyLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWVycm9yLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm9iamVjdDpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBkZWYuc2hhcGUoKTtcbiAgICAgICAgICAgIGlmIChkZWYucGFyYW1zLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZUtleXNfMSA9IE9iamVjdC5rZXlzKHNoYXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhS2V5cyA9IG9iaktleXMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBzaGFwZUtleXNfMS5pbmRleE9mKGspID09PSAtMTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGV4dHJhS2V5cyxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZlxuICAgICAgICAgICAgICAgICAgICAgICAgLnNoYXBlKClba2V5XS5wYXJzZShvYmpba2V5XSwgX19hc3NpZ24oe30sIHBhcmFtcywgeyBwYXRoOiBwYXJhbXMucGF0aC5jb25jYXQoW2tleV0pIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgemVyciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3JzKHplcnIuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnVuaW9uOlxuICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB1bmlvbkVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRlZi5vcHRpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnBhcnNlKG9iaiwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pb25FcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZEVycm9ycyA9IHVuaW9uRXJyb3JzLmZpbHRlcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIuZXJyb3JzWzBdLmNvZGUgIT09ICdpbnZhbGlkX3R5cGUnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZEVycm9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3JzKGZpbHRlcmVkRXJyb3JzWzBdLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlvbkVycm9yczogdW5pb25FcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmludGVyc2VjdGlvbjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGVmLmxlZnQucGFyc2Uob2JqLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9ycyhlcnIuZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGVmLnJpZ2h0LnBhcnNlKG9iaiwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcnMoZXJyLmVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnR1cGxlOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA+IGRlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9iai5sZW5ndGggPCBkZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJzZWRUdXBsZSA9IFtdO1xuICAgICAgICAgICAgdmFyIHR1cGxlRGF0YSA9IG9iajtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4IGluIHR1cGxlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdHVwbGVEYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbVBhcnNlciA9IGRlZi5pdGVtc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkVHVwbGUucHVzaChpdGVtUGFyc2VyLnBhcnNlKGl0ZW0sIF9fYXNzaWduKHt9LCBwYXJhbXMsIHsgcGF0aDogcGFyYW1zLnBhdGguY29uY2F0KFtpbmRleF0pIH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3JzKGVyci5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubGF6eTpcbiAgICAgICAgICAgIHZhciBsYXp5U2NoZW1hID0gZGVmLmdldHRlcigpO1xuICAgICAgICAgICAgbGF6eVNjaGVtYS5wYXJzZShvYmosIHBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmxpdGVyYWw6XG4gICAgICAgICAgICBpZiAob2JqICE9PSBkZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9saXRlcmFsX3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuZW51bTpcbiAgICAgICAgICAgIGlmIChkZWYudmFsdWVzLmluZGV4T2Yob2JqKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBkZWYudmFsdWVzLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubmF0aXZlRW51bTpcbiAgICAgICAgICAgIGlmICh1dGlsXzEudXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMoZGVmLnZhbHVlcykuaW5kZXhPZihvYmopID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHV0aWxfMS51dGlsLmdldFZhbHVlcyhkZWYudmFsdWVzKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmtleW9mOlxuICAgICAgICAgICAgaWYgKHV0aWxfMS51dGlsLmdldFZhbGlkRW51bVZhbHVlcyhkZWYudmFsdWVzKS5pbmRleE9mKG9iaikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdXRpbF8xLnV0aWwuZ2V0VmFsdWVzKGRlZi52YWx1ZXMpLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuZnVuY3Rpb246XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZWRGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZWYuYXJncy5wYXJzZShhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgWm9kRXJyb3JfMS5ab2RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3NFcnJvciA9IG5ldyBab2RFcnJvcl8xLlpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NFcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYXJnc0Vycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iai5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWYucmV0dXJucy5wYXJzZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBab2RFcnJvcl8xLlpvZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuc0Vycm9yID0gbmV3IFpvZEVycm9yXzEuWm9kRXJyb3IoW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuc0Vycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXR1cm5zRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnJlY29yZDpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlVHlwZS5wYXJzZShvYmpba2V5XSwgX19hc3NpZ24oe30sIHBhcmFtcywgeyBwYXRoOiBwYXJhbXMucGF0aC5jb25jYXQoW2tleV0pIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcnMoZXJyLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5kYXRlOlxuICAgICAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmRhdGUsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOYU4ob2JqLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9kYXRlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnByb21pc2U6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ialZhbHVlLCBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG9ial07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqVmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gZGVmLnR5cGUucGFyc2Uob2JqVmFsdWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyhwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlaihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHV0aWxfMS51dGlsLmFzc2VydE5ldmVyKGRlZik7XG4gICAgfVxuICAgIHZhciBjdXN0b21DaGVja3MgPSBkZWYuY2hlY2tzIHx8IFtdO1xuICAgIGZvciAodmFyIF9iID0gMCwgY3VzdG9tQ2hlY2tzXzEgPSBjdXN0b21DaGVja3M7IF9iIDwgY3VzdG9tQ2hlY2tzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBjaGVjayA9IGN1c3RvbUNoZWNrc18xW19iXTtcbiAgICAgICAgaWYgKCFjaGVjay5jaGVjayhyZXR1cm5WYWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBjaGVja01ldGhvZCA9IGNoZWNrLmNoZWNrLCBub01ldGhvZENoZWNrID0gX19yZXN0KGNoZWNrLCBbXCJjaGVja1wiXSk7XG4gICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIG5vTWV0aG9kQ2hlY2spKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWVycm9yLmlzRW1wdHkpIHtcbiAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kQW55ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RBbnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kQW55KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kQW55LmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5hbnksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZEFueTtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZEFueSA9IFpvZEFueTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFueS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xuLy8gaW1wb3J0IHsgWm9kVW5kZWZpbmVkIH0gZnJvbSAnLi91bmRlZmluZWQnO1xuLy8gaW1wb3J0IHsgWm9kTnVsbCB9IGZyb20gJy4vbnVsbCc7XG4vLyBpbXBvcnQgeyBab2RVbmlvbiB9IGZyb20gJy4vdW5pb24nO1xudmFyIFpvZEVycm9yXzEgPSByZXF1aXJlKFwiLi4vWm9kRXJyb3JcIik7XG52YXIgWm9kQXJyYXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZEFycmF5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZEFycmF5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0OiBfdGhpcy5fZGVmLnQsXG4gICAgICAgICAgICAgICAgbm9uZW1wdHk6IF90aGlzLl9kZWYubm9uZW1wdHksXG4gICAgICAgICAgICAgICAgdHlwZTogX3RoaXMuX2RlZi50eXBlLnRvSlNPTigpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLm1pbiA9IGZ1bmN0aW9uIChtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YS5sZW5ndGggPj0gbWluTGVuZ3RoOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fc21hbGwsIHR5cGU6ICdhcnJheScsIGluY2x1c2l2ZTogdHJ1ZSwgbWluaW11bTogbWluTGVuZ3RoIH0sICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSA6IG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm1heCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YS5sZW5ndGggPD0gbWF4TGVuZ3RoOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fYmlnLCB0eXBlOiAnYXJyYXknLCBpbmNsdXNpdmU6IHRydWUsIG1heGltdW06IG1heExlbmd0aCB9LCAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8geyBtZXNzYWdlOiBtZXNzYWdlIH0gOiBtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5sZW5ndGggPSBmdW5jdGlvbiAobGVuLCBtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5taW4obGVuLCB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSkubWF4KGxlbiwgeyBtZXNzYWdlOiBtZXNzYWdlIH0pOyB9O1xuICAgICAgICBfdGhpcy5ub25lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kTm9uRW1wdHlBcnJheShfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyBub25lbXB0eTogdHJ1ZSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZEFycmF5LnByb3RvdHlwZSwgXCJlbGVtZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFpvZEFycmF5LmNyZWF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmFycmF5LFxuICAgICAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICAgICAgbm9uZW1wdHk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RBcnJheTtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZEFycmF5ID0gWm9kQXJyYXk7XG52YXIgWm9kTm9uRW1wdHlBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kTm9uRW1wdHlBcnJheSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2ROb25FbXB0eUFycmF5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0OiBfdGhpcy5fZGVmLnQsXG4gICAgICAgICAgICAgICAgdHlwZTogX3RoaXMuX2RlZi50eXBlLnRvSlNPTigpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLm1pbiA9IGZ1bmN0aW9uIChtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YS5sZW5ndGggPj0gbWluTGVuZ3RoOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fc21hbGwsIG1pbmltdW06IG1pbkxlbmd0aCwgdHlwZTogJ2FycmF5JywgaW5jbHVzaXZlOiB0cnVlIH0sICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSA6IG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm1heCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YS5sZW5ndGggPD0gbWF4TGVuZ3RoOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fYmlnLCBtYXhpbXVtOiBtYXhMZW5ndGgsIHR5cGU6ICdhcnJheScsIGluY2x1c2l2ZTogdHJ1ZSB9LCAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8geyBtZXNzYWdlOiBtZXNzYWdlIH0gOiBtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5sZW5ndGggPSBmdW5jdGlvbiAobGVuLCBtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5taW4obGVuLCB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSkubWF4KGxlbiwgeyBtZXNzYWdlOiBtZXNzYWdlIH0pOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBab2ROb25FbXB0eUFycmF5O1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kTm9uRW1wdHlBcnJheSA9IFpvZE5vbkVtcHR5QXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vcGFyc2VyXCIpO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG52YXIgWm9kVHlwZXM7XG4oZnVuY3Rpb24gKFpvZFR5cGVzKSB7XG4gICAgWm9kVHlwZXNbXCJzdHJpbmdcIl0gPSBcInN0cmluZ1wiO1xuICAgIFpvZFR5cGVzW1wibnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbiAgICBab2RUeXBlc1tcImJpZ2ludFwiXSA9IFwiYmlnaW50XCI7XG4gICAgWm9kVHlwZXNbXCJib29sZWFuXCJdID0gXCJib29sZWFuXCI7XG4gICAgWm9kVHlwZXNbXCJkYXRlXCJdID0gXCJkYXRlXCI7XG4gICAgWm9kVHlwZXNbXCJ1bmRlZmluZWRcIl0gPSBcInVuZGVmaW5lZFwiO1xuICAgIFpvZFR5cGVzW1wibnVsbFwiXSA9IFwibnVsbFwiO1xuICAgIFpvZFR5cGVzW1wiYXJyYXlcIl0gPSBcImFycmF5XCI7XG4gICAgWm9kVHlwZXNbXCJvYmplY3RcIl0gPSBcIm9iamVjdFwiO1xuICAgIFpvZFR5cGVzW1widW5pb25cIl0gPSBcInVuaW9uXCI7XG4gICAgWm9kVHlwZXNbXCJpbnRlcnNlY3Rpb25cIl0gPSBcImludGVyc2VjdGlvblwiO1xuICAgIFpvZFR5cGVzW1widHVwbGVcIl0gPSBcInR1cGxlXCI7XG4gICAgWm9kVHlwZXNbXCJyZWNvcmRcIl0gPSBcInJlY29yZFwiO1xuICAgIFpvZFR5cGVzW1wiZnVuY3Rpb25cIl0gPSBcImZ1bmN0aW9uXCI7XG4gICAgWm9kVHlwZXNbXCJsYXp5XCJdID0gXCJsYXp5XCI7XG4gICAgWm9kVHlwZXNbXCJsaXRlcmFsXCJdID0gXCJsaXRlcmFsXCI7XG4gICAgWm9kVHlwZXNbXCJlbnVtXCJdID0gXCJlbnVtXCI7XG4gICAgWm9kVHlwZXNbXCJuYXRpdmVFbnVtXCJdID0gXCJuYXRpdmVFbnVtXCI7XG4gICAgWm9kVHlwZXNbXCJwcm9taXNlXCJdID0gXCJwcm9taXNlXCI7XG4gICAgWm9kVHlwZXNbXCJhbnlcIl0gPSBcImFueVwiO1xuICAgIFpvZFR5cGVzW1widW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICAgIFpvZFR5cGVzW1widm9pZFwiXSA9IFwidm9pZFwiO1xuICAgIFpvZFR5cGVzW1wia2V5b2ZcIl0gPSBcImtleW9mXCI7XG59KShab2RUeXBlcyA9IGV4cG9ydHMuWm9kVHlwZXMgfHwgKGV4cG9ydHMuWm9kVHlwZXMgPSB7fSkpO1xudmFyIFpvZFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWm9kVHlwZShkZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSBmdW5jdGlvbiAoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBfdGhpcy5wYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnNlZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBpbmRleF8xLlpvZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gZnVuY3Rpb24gKHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gX3RoaXMucGFyc2UodmFsdWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVmaW5lID0gZnVuY3Rpb24gKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSAnSW52YWxpZCB2YWx1ZS4nOyB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlZmluZW1lbnQoeyBjaGVjazogY2hlY2ssIG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBjaGVjayB9LCBtZXNzYWdlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IGZ1bmN0aW9uIChyZWZpbmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjb2RlOiBpbmRleF8xLlpvZEVycm9yQ29kZS5jdXN0b21fZXJyb3IgfSwgcmVmaW5lbWVudCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yZWZpbmVtZW50ID0gZnVuY3Rpb24gKHJlZmluZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgX3RoaXMuY29uc3RydWN0b3IoX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgY2hlY2tzOiAoX3RoaXMuX2RlZi5jaGVja3MgfHwgW10pLmNvbmNhdChbcmVmaW5lbWVudF0pIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gIGFic3RyYWN0IC8vIG9wdCBvcHRpb25hbDogKCkgPT4gYW55O1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4XzEuWm9kVW5pb24uY3JlYXRlKFtfdGhpcywgaW5kZXhfMS5ab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleF8xLlpvZFVuaW9uLmNyZWF0ZShbX3RoaXMsIGluZGV4XzEuWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfMS5ab2RBcnJheS5jcmVhdGUoX3RoaXMpOyB9O1xuICAgICAgICB0aGlzLm9yID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4XzEuWm9kVW5pb24uY3JlYXRlKFtfdGhpcywgYXJnXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlcl8xLlpvZFBhcnNlcihkZWYpO1xuICAgIH1cbiAgICBab2RUeXBlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlKHUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBab2RUeXBlLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlKHUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gWm9kVHlwZTtcbn0oKSk7XG5leHBvcnRzLlpvZFR5cGUgPSBab2RUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kQmlnSW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RCaWdJbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kQmlnSW50KCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kQmlnSW50LmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5iaWdpbnQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZEJpZ0ludDtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZEJpZ0ludCA9IFpvZEJpZ0ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZ2ludC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kQm9vbGVhbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kQm9vbGVhbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RCb29sZWFuKCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kQm9vbGVhbi5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmJvb2xlYW4sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZEJvb2xlYW47XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RCb29sZWFuID0gWm9kQm9vbGVhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xlYW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZERhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZERhdGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kRGF0ZSgpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZERhdGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5kYXRlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2REYXRlO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kRGF0ZSA9IFpvZERhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RFbnVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RFbnVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZEVudW0oKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kRW51bS5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RFbnVtLnByb3RvdHlwZSwgXCJlbnVtXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2RlZi52YWx1ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZEVudW0ucHJvdG90eXBlLCBcIlZhbHVlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9kZWYudmFsdWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RFbnVtLnByb3RvdHlwZSwgXCJFbnVtXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2RlZi52YWx1ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgWm9kRW51bS5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmVudW0sXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kRW51bTtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZEVudW0gPSBab2RFbnVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbnZhciB1bmtub3duXzEgPSByZXF1aXJlKFwiLi91bmtub3duXCIpO1xudmFyIFpvZEZ1bmN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RGdW5jdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RGdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgYXJnczogdHVwbGVfMS5ab2RUdXBsZS5jcmVhdGUoaXRlbXMpIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmV0dXJucyA9IGZ1bmN0aW9uIChyZXR1cm5UeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IHJldHVybnM6IHJldHVyblR5cGUgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pbXBsZW1lbnQgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRlZEZ1bmMgPSBfdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy52YWxpZGF0ZSA9IF90aGlzLmltcGxlbWVudDtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdDogX3RoaXMuX2RlZi50LFxuICAgICAgICAgICAgICAgIGFyZ3M6IF90aGlzLl9kZWYuYXJncy50b0pTT04oKSxcbiAgICAgICAgICAgICAgICByZXR1cm5zOiBfdGhpcy5fZGVmLnJldHVybnMudG9KU09OKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZEZ1bmN0aW9uLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcmdzLCByZXR1cm5zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5mdW5jdGlvbixcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MgfHwgdHVwbGVfMS5ab2RUdXBsZS5jcmVhdGUoW10pLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCB1bmtub3duXzEuWm9kVW5rbm93bi5jcmVhdGUoKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kRnVuY3Rpb247XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RGdW5jdGlvbiA9IFpvZEZ1bmN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZEludGVyc2VjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kSW50ZXJzZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZEludGVyc2VjdGlvbigpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgdDogX3RoaXMuX2RlZi50LFxuICAgICAgICAgICAgbGVmdDogX3RoaXMuX2RlZi5sZWZ0LnRvSlNPTigpLFxuICAgICAgICAgICAgcmlnaHQ6IF90aGlzLl9kZWYucmlnaHQudG9KU09OKCksXG4gICAgICAgIH0pOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5pbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb247XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RJbnRlcnNlY3Rpb24gPSBab2RJbnRlcnNlY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnNlY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZEtleW9mID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RLZXlvZiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RLZXlvZigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICB0OiBfdGhpcy5fZGVmLnQsXG4gICAgICAgICAgICB2YWx1ZXM6IF90aGlzLl9kZWYudmFsdWVzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b1N0cmluZygpOyB9KSxcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kS2V5b2YuY3JlYXRlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEtleW9mKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMua2V5b2YsXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBjYXN0IGlzIG5vdCBjb3JyZWN0IGluIHRoZSBnZW5lcmFsIGNhc2VcbiAgICAgICAgICAgIC8vIFNlZSBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTI4NzBcbiAgICAgICAgICAgIHZhbHVlczogT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kS2V5b2Y7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RLZXlvZiA9IFpvZEtleW9mO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5b2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZExhenkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZExhenksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kTGF6eSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBKU09OaWZ5IHJlY3Vyc2l2ZSBzdHJ1Y3R1cmVcIik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZExhenkucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgWm9kTGF6eS5jcmVhdGUgPSBmdW5jdGlvbiAoZ2V0dGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmxhenksXG4gICAgICAgICAgICBnZXR0ZXI6IGdldHRlcixcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kTGF6eTtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZExhenkgPSBab2RMYXp5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kTGl0ZXJhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kTGl0ZXJhbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RMaXRlcmFsKCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kTGl0ZXJhbC5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMubGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kTGl0ZXJhbDtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZExpdGVyYWwgPSBab2RMaXRlcmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl0ZXJhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kTmF0aXZlRW51bSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kTmF0aXZlRW51bSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2ROYXRpdmVFbnVtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2ROYXRpdmVFbnVtLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMubmF0aXZlRW51bSxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2ROYXRpdmVFbnVtO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kTmF0aXZlRW51bSA9IFpvZE5hdGl2ZUVudW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXRpdmVFbnVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2ROdWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2ROdWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZE51bGwoKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2ROdWxsLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMubnVsbCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kTnVsbDtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZE51bGwgPSBab2ROdWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xuLy8gaW1wb3J0IHsgWm9kVW5kZWZpbmVkIH0gZnJvbSAnLi91bmRlZmluZWQnO1xuLy8gaW1wb3J0IHsgWm9kTnVsbCB9IGZyb20gJy4vbnVsbCc7XG4vLyBpbXBvcnQgeyBab2RVbmlvbiB9IGZyb20gJy4vdW5pb24nO1xudmFyIFpvZEVycm9yXzEgPSByZXF1aXJlKFwiLi4vWm9kRXJyb3JcIik7XG52YXIgZXJyb3JVdGlsXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lcnJvclV0aWxcIik7XG52YXIgWm9kTnVtYmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2ROdW1iZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kTnVtYmVyKCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIF90aGlzLm1pbiA9IGZ1bmN0aW9uIChtaW5pbXVtLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgPj0gbWluaW11bTsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX3NtYWxsLCBtaW5pbXVtOiBtaW5pbXVtLCB0eXBlOiAnbnVtYmVyJywgaW5jbHVzaXZlOiB0cnVlIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tYXggPSBmdW5jdGlvbiAobWF4aW11bSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhIDw9IG1heGltdW07IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19iaWcsIG1heGltdW06IG1heGltdW0sIHR5cGU6ICdudW1iZXInLCBpbmNsdXNpdmU6IHRydWUgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmludCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoZGF0YSk7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSwgZXhwZWN0ZWQ6ICdpbnRlZ2VyJywgcmVjZWl2ZWQ6ICdudW1iZXInIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5wb3NpdGl2ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgPiAwOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fc21hbGwsIG1pbmltdW06IDAsIHR5cGU6ICdudW1iZXInLCBpbmNsdXNpdmU6IGZhbHNlIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5uZWdhdGl2ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgPCAwOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fYmlnLCBtYXhpbXVtOiAwLCB0eXBlOiAnbnVtYmVyJywgaW5jbHVzaXZlOiBmYWxzZSB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubm9ucG9zaXRpdmUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhIDw9IDA7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19iaWcsIG1heGltdW06IDAsIHR5cGU6ICdudW1iZXInLCBpbmNsdXNpdmU6IHRydWUgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm5vbm5lZ2F0aXZlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSA+PSAwOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fc21hbGwsIG1pbmltdW06IDAsIHR5cGU6ICdudW1iZXInLCBpbmNsdXNpdmU6IHRydWUgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kTnVtYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5udW1iZXIsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZE51bWJlcjtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZE51bWJlciA9IFpvZE51bWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIG9iamVjdFV0aWxfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL29iamVjdFV0aWxcIik7XG52YXIgaXNTY2FsYXJfMSA9IHJlcXVpcmUoXCIuLi9pc1NjYWxhclwiKTtcbnZhciBBdWdtZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIGZ1bmN0aW9uIChhdWdtZW50YXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdChfX2Fzc2lnbih7fSwgZGVmLCB7IHNoYXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oe30sIGRlZi5zaGFwZSgpLCBhdWdtZW50YXRpb24pKTsgfSB9KSk7XG59OyB9O1xudmFyIG9iamVjdERlZlRvSnNvbiA9IGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuICh7XG4gICAgdDogZGVmLnQsXG4gICAgc2hhcGU6IE9iamVjdC5hc3NpZ24oe30sIE9iamVjdC5rZXlzKGRlZi5zaGFwZSgpKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0ge30sXG4gICAgICAgICAgICBfYVtrXSA9IGRlZi5zaGFwZSgpW2tdLnRvSlNPTigpLFxuICAgICAgICAgICAgX2EpO1xuICAgIH0pKSxcbn0pOyB9O1xudmFyIFpvZE9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kT2JqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZE9iamVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iamVjdERlZlRvSnNvbihfdGhpcy5fZGVmKTsgfTtcbiAgICAgICAgX3RoaXMubm9uc3RyaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgICAgIHNoYXBlOiBfdGhpcy5fZGVmLnNoYXBlLFxuICAgICAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgICAgIHBhcmFtczogX19hc3NpZ24oe30sIF90aGlzLl9wYXJhbXMsIHsgc3RyaWN0OiBmYWxzZSB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIC8vIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLmF1Z21lbnQgPSBBdWdtZW50RmFjdG9yeShfdGhpcy5fZGVmKTtcbiAgICAgICAgX3RoaXMuZXh0ZW5kID0gQXVnbWVudEZhY3RvcnkoX3RoaXMuX2RlZik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICAgICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICAgICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubWVyZ2UgPSBvYmplY3RVdGlsXzEub2JqZWN0VXRpbC5tZXJnZU9iamVjdHMoX3RoaXMpO1xuICAgICAgICBfdGhpcy5waWNrID0gZnVuY3Rpb24gKG1hc2spIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobWFzaykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gX3RoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3QoX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgc2hhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXBlOyB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub21pdCA9IGZ1bmN0aW9uIChtYXNrKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzLnNoYXBlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhtYXNrKS5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSBfdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3QoX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgc2hhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXBlOyB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucGFydGlhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIF90aGlzLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IF90aGlzLnNoYXBlW2tleV0ub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IHNoYXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXdTaGFwZTsgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnByaW1pdGl2ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBfdGhpcy5zaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1NjYWxhcl8xLmlzU2NhbGFyKF90aGlzLnNoYXBlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBfdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IHNoYXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXdTaGFwZTsgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm5vbnByaW1pdGl2ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBfdGhpcy5zaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNTY2FsYXJfMS5pc1NjYWxhcihfdGhpcy5zaGFwZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gX3RoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdChfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyBzaGFwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3U2hhcGU7IH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5kZWVwUGFydGlhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIF90aGlzLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkU2NoZW1hID0gX3RoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRTY2hlbWEgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLmRlZXBQYXJ0aWFsKCkub3B0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBfdGhpcy5zaGFwZVtrZXldLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3QoX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgc2hhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ld1NoYXBlOyB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kT2JqZWN0LnByb3RvdHlwZSwgXCJzaGFwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kT2JqZWN0LnByb3RvdHlwZSwgXCJwYXJhbXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYucGFyYW1zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBab2RPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgc2hhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXBlOyB9LFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBab2RPYmplY3QubGF6eWNyZWF0ZSA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZE9iamVjdDtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZE9iamVjdCA9IFpvZE9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kUHJvbWlzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kUHJvbWlzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RQcm9taXNlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0OiBfdGhpcy5fZGVmLnQsXG4gICAgICAgICAgICAgICAgdHlwZTogX3RoaXMuX2RlZi50eXBlLnRvSlNPTigpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgIFpvZFByb21pc2UuY3JlYXRlID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFByb21pc2Uoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5wcm9taXNlLFxuICAgICAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RQcm9taXNlO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kUHJvbWlzZSA9IFpvZFByb21pc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RSZWNvcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZFJlY29yZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RSZWNvcmQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgdDogX3RoaXMuX2RlZi50LFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBfdGhpcy5fZGVmLnZhbHVlVHlwZS50b0pTT04oKSxcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICBab2RSZWNvcmQuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLnJlY29yZCxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogdmFsdWVUeXBlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RSZWNvcmQ7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RSZWNvcmQgPSBab2RSZWNvcmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvcmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbi8vIGltcG9ydCB7IFpvZFVuZGVmaW5lZCB9IGZyb20gJy4vdW5kZWZpbmVkJztcbi8vIGltcG9ydCB7IFpvZE51bGwgfSBmcm9tICcuL251bGwnO1xuLy8gaW1wb3J0IHsgWm9kVW5pb24gfSBmcm9tICcuL3VuaW9uJztcbnZhciBab2RFcnJvcl8xID0gcmVxdWlyZShcIi4uL1pvZEVycm9yXCIpO1xudmFyIGVycm9yVXRpbF8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZXJyb3JVdGlsXCIpO1xudmFyIGVtYWlsUmVnZXggPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkkL2k7XG52YXIgdXVpZFJlZ2V4ID0gL15bYS1mMC05XXs4fS1bYS1mMC05XXs0fS00W2EtZjAtOV17M30tWzg5YUFiQl1bYS1mMC05XXszfS1bYS1mMC05XXsxMn0kL2k7XG52YXIgWm9kU3RyaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RTdHJpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kU3RyaW5nKCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIF90aGlzLm1pbiA9IGZ1bmN0aW9uIChtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YS5sZW5ndGggPj0gbWluTGVuZ3RoOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fc21hbGwsIG1pbmltdW06IG1pbkxlbmd0aCwgdHlwZTogJ3N0cmluZycsIGluY2x1c2l2ZTogdHJ1ZSB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWF4ID0gZnVuY3Rpb24gKG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhLmxlbmd0aCA8PSBtYXhMZW5ndGg7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19iaWcsIG1heGltdW06IG1heExlbmd0aCwgdHlwZTogJ3N0cmluZycsIGluY2x1c2l2ZTogdHJ1ZSB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX3JlZ2V4ID0gZnVuY3Rpb24gKHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uLCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3N0cmluZywgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiByZWdleC50ZXN0KGRhdGEpOyB9IH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5lbWFpbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZ2V4KGVtYWlsUmVnZXgsICdlbWFpbCcsIG1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy51cmwgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3N0cmluZywgdmFsaWRhdGlvbjogJ3VybCcgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHVybCA9IChtZXNzYWdlPzogZXJyb3JVdGlsLkVyck1lc3NhZ2UpID0+IHRoaXMuX3JlZ2V4KHVybFJlZ2V4LCAndXJsJywgbWVzc2FnZSk7XG4gICAgICAgIF90aGlzLnV1aWQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWdleCh1dWlkUmVnZXgsICd1dWlkJywgbWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlZ2V4ID0gZnVuY3Rpb24gKHJlZ2V4cCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWdleChyZWdleHAsICdyZWdleCcsIG1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5ub25lbXB0eSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubWluKDEsIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kU3RyaW5nLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihsZW4sIG1lc3NhZ2UpLm1heChsZW4sIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgWm9kU3RyaW5nLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kU3RyaW5nO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kU3RyaW5nID0gWm9kU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RUdXBsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kVHVwbGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kVHVwbGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgdDogX3RoaXMuX2RlZi50LFxuICAgICAgICAgICAgaXRlbXM6IF90aGlzLl9kZWYuaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnRvSlNPTigpOyB9KSxcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICBab2RUdXBsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc2NoZW1hcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMudHVwbGUsXG4gICAgICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kVHVwbGU7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RUdXBsZSA9IFpvZFR1cGxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHVwbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZFVuZGVmaW5lZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kVW5kZWZpbmVkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZFVuZGVmaW5lZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICBab2RVbmRlZmluZWQuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFVuZGVmaW5lZCh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLnVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kVW5kZWZpbmVkO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kVW5kZWZpbmVkID0gWm9kVW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5kZWZpbmVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RVbmlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kVW5pb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kVW5pb24oKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHQ6IF90aGlzLl9kZWYudCxcbiAgICAgICAgICAgIG9wdGlvbnM6IF90aGlzLl9kZWYub3B0aW9ucy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9KU09OKCk7IH0pLFxuICAgICAgICB9KTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBkaXN0cmlidXRlID0gPEYgZXh0ZW5kcyAoYXJnOiBUW251bWJlcl0pID0+IHouWm9kVHlwZUFueT4oZjogRik6IFpvZFVuaW9uPHsgW2sgaW4ga2V5b2YgVF06IFJldHVyblR5cGU8Rj4gfT4gPT4ge1xuICAgIC8vICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZSh0aGlzLl9kZWYub3B0aW9ucy5tYXAoZikgYXMgYW55KTtcbiAgICAvLyB9O1xuICAgIFpvZFVuaW9uLmNyZWF0ZSA9IGZ1bmN0aW9uICh0eXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMudW5pb24sXG4gICAgICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kVW5pb247XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RVbmlvbiA9IFpvZFVuaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZFVua25vd24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZFVua25vd24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kVW5rbm93bigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZFVua25vd24uY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy51bmtub3duLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RVbmtub3duO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kVW5rbm93biA9IFpvZFVua25vd247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmtub3duLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RWb2lkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RWb2lkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZFZvaWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RWb2lkLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RWb2lkKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMudm9pZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kVm9pZDtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZFZvaWQgPSBab2RWb2lkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dm9pZC5qcy5tYXAiLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmNvbnN0IERyb3Bkb3duID0gKHsgb3B0aW9ucywgc2VsZWN0ZWRPcHRpb24sIHNldFNlbGVjdGVkT3B0aW9uIH0pID0+IHtcclxuICAgIGNvbnN0IFtpc09wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgZHJvcGRvd24gPSB1c2VSZWYobnVsbCk7XHJcblxyXG4gICAgLy8gT3Blbi9DbG9zZSBvbiBjbGljayBvZiBkcm9wZG93biBoZWFkZXJcclxuICAgIGNvbnN0IHRvZ2dsZURyb3Bkb3duID0gKCkgPT4gc2V0T3BlbighaXNPcGVuKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgc2VsZWN0ZWQgb3B0aW9uLCBjbG9zZSBkcm9wZG93blxyXG4gICAgY29uc3QgaGFuZGxlSXRlbUNsaWNrID0gKGN1cnJlbmN5KSA9PiB7XHJcbiAgICAgICAgc2V0U2VsZWN0ZWRPcHRpb24oY3VycmVuY3kpO1xyXG4gICAgICAgIHNldE9wZW4oZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDbG9zZSBkcm9wZG93biB3aGVuIGNsaWNrZWQgb3V0c2lkZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVDbGlja091dHNpZGUoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGRyb3Bkb3duLmN1cnJlbnQgJiYgIWRyb3Bkb3duLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgc2V0T3BlbihmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVDbGlja091dHNpZGUpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2Ryb3Bkb3duXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRyb3Bkb3duXCIgcmVmPXtkcm9wZG93bn0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHJvcGRvd24taGVhZGVyXCIgb25DbGljaz17dG9nZ2xlRHJvcGRvd259PlxyXG4gICAgICAgICAgICAgICAge3NlbGVjdGVkT3B0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmZpbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbikgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmN1cnJlbmN5ID09PSBzZWxlY3RlZE9wdGlvbi5jdXJyZW5jeVxyXG4gICAgICAgICAgICAgICAgICAgICAgKT8uY3VycmVuY3lcclxuICAgICAgICAgICAgICAgICAgICA6IFwic2VsZWN0IGEgdG9rZW5cIn1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgZHJvcGRvd24tYm9keSAke2lzT3BlbiAmJiBcIm9wZW5cIn1gfT5cclxuICAgICAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgICAgICB7KG9wdGlvbnMgfHwgW10pLm1hcCgoaXRlbSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJkcm9wZG93bi1pdGVtXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPXtpdGVtLmN1cnJlbmN5fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpdGVtLmN1cnJlbmN5fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVJdGVtQ2xpY2soaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXRlbS5jdXJyZW5jeX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duO1xyXG4iLCIvLyBPcHRpb25zIGxpc3QgZm9yIGRyb3Bkb3duXHJcbmV4cG9ydCBjb25zdCBjdXJyZW5jaWVzID0gW1xyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhQUlwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcImVvc2lvLnRva2VuXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNFwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBkZWNpbWFsczogXCI0XCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwibG9hbi50b2tlblwiLFxyXG4gICAgICAgIGN1cnJlbmN5OiBcIkxPQU5cIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiRk9PQkFSXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNFwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInN0b3JleFwiLFxyXG4gICAgICAgIGN1cnJlbmN5OiBcIlNUUlhcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiQlRDTFwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcIndyYXBwZXJcIixcclxuICAgICAgICBkZWNpbWFsczogXCI4XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhBREFcIixcclxuICAgICAgICBkZWNpbWFsczogXCI2XCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjdXJyZW5jeTogXCJYQkNIXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjhcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjhcIixcclxuICAgICAgICBjdXJyZW5jeTogXCJYQk5CXCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhCVENcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiOFwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjdXJyZW5jeTogXCJYQlVTRFwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI2XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhET0dFXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjhcIixcclxuICAgICAgICBjdXJyZW5jeTogXCJYRE9UXCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGRlY2ltYWxzOiBcIjRcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgY3VycmVuY3k6IFwiWEVPU1wiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiOFwiLFxyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhFVEhcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiWExUQ1wiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI4XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgY3VycmVuY3k6IFwiWExVTkFcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgICAgICBjdXJyZW5jeTogXCJYTURBXCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhNVFwiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjhcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhQQVhcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNlwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjdXJyZW5jeTogXCJYUEFYR1wiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI4XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhTT0xcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNlwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjdXJyZW5jeTogXCJYVFVTRFwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI2XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI2XCIsXHJcbiAgICAgICAgY3VycmVuY3k6IFwiWFVOSVwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjdXJyZW5jeTogXCJYVVNEQ1wiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI2XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI2XCIsXHJcbiAgICAgICAgY3VycmVuY3k6IFwiWFVTRFRcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgICAgICBjdXJyZW5jeTogXCJYVVNUXCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhYUlBcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNlwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjb250cmFjdDogXCJyZWFsZXN0YXRlc2VcIixcclxuICAgICAgICBjdXJyZW5jeTogXCJNRVNTQUdFXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNFwiLFxyXG4gICAgfSxcclxuXTtcclxuIiwiaW1wb3J0IHsgRnJhZ21lbnQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9jb21wb25lbnRzL3VpL01vZGFsXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uL2NvbXBvbmVudHMvdWkvQnV0dG9uXCI7XHJcbmltcG9ydCBBdXRoQ29udGV4dCBmcm9tIFwiLi4vc3RvcmUvYXV0aC1jb250ZXh0XCI7XHJcblxyXG5pbXBvcnQgRHJvcGRvd24gZnJvbSBcIi4uL2NvbXBvbmVudHMvdWkvQ3VycmVuY3lEcm9wZG93blwiO1xyXG5pbXBvcnQgeyBjdXJyZW5jaWVzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9DdXJyZW5jeUxpc3RcIjtcclxuaW1wb3J0IFdhbGxldENvbnRleHQgZnJvbSBcIi4uL3N0b3JlL3dhbGxldC1jb250ZXh0XCI7XHJcbmltcG9ydCB7XHJcbiAgICBzdGFydFBvb2wsXHJcbiAgICBmZXRjaEVzY3Jvd3MsXHJcbiAgICBmaWxsRXNjcm93LFxyXG4gICAgcGFydGFrZVBvb2wsXHJcbiAgICBmaWxsUG9vbCxcclxuICAgIGNhbmNlbFBvb2wsXHJcbn0gZnJvbSBcIi4uL3Nkay9lYXN5cG9vbFNES1wiO1xyXG5pbXBvcnQgeyB1c2VOYXZpZ2F0ZSB9IGZyb20gXCJyZWFjdC1yb3V0ZXItZG9tXCI7XHJcblxyXG5jb25zdCBDb250ZXN0ID0gKCkgPT4ge1xyXG4gICAgY29uc3QgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xyXG4gICAgY29uc3QgY3R4ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XHJcbiAgICBjb25zdCB3YWxsZXRDdHggPSB1c2VDb250ZXh0KFdhbGxldENvbnRleHQpO1xyXG4gICAgY29uc3QgW3N1Y2Nlc3NQb3B1cCwgc2V0U3VjY2Vzc1BvcHVwXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgICBjb25zdCBbc3VjY2Vzcywgc2V0U3VjY2Vzc10gPSB1c2VTdGF0ZShcIlwiKTtcclxuICAgIGNvbnN0IFtjaGVja0Vycm9yLCBzZXRDaGVja0Vycm9yXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IGNsb3NlU3VjY2Vzc1BvcHVwID0gKCkgPT4ge1xyXG4gICAgICAgIHNldFN1Y2Nlc3NQb3B1cChmYWxzZSk7XHJcbiAgICAgICAgbmF2aWdhdGUoXCIvdHJhbnNhY3Rpb25zXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBbdGl0bGUsIHNldFRpdGxlXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gICAgY29uc3QgW2Rlc2NyaXB0aW9uLCBzZXREZXNjcmlwdGlvbl0gPSB1c2VTdGF0ZShcIlwiKTtcclxuICAgIGNvbnN0IFtwb29sVHlwZSwgc2V0UG9vbFR5cGVdID0gdXNlU3RhdGUoXCJkYXRlXCIpO1xyXG4gICAgY29uc3QgW2Ftb3VudCwgc2V0QW1vdW50XSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gICAgY29uc3QgW3Rva2VuLCBzZXRUb2tlbl0gPSB1c2VTdGF0ZSh7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiU2VsZWN0IGEgdG9rZW5cIixcclxuICAgICAgICBhbW91bnQ6IFwiMFwiLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBbdG9rZW5zLCBzZXRUb2tlbnNdID0gdXNlU3RhdGUoW1xyXG4gICAgICAgIHsgY3VycmVuY3k6IFwiU2VsZWN0IGEgdG9rZW5cIiwgYW1vdW50OiBcIjBcIiB9LFxyXG4gICAgXSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICh3YWxsZXRDdHguYmFsYW5jZXMgIT0gW10gJiYgd2FsbGV0Q3R4LmJhbGFuY2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgc2V0VG9rZW4od2FsbGV0Q3R4LmJhbGFuY2VzWzBdKTtcclxuICAgICAgICAgICAgc2V0VG9rZW5zKHdhbGxldEN0eC5iYWxhbmNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3dhbGxldEN0eC5iYWxhbmNlc10pO1xyXG4gICAgY29uc3QgW2NoZWNrRXhjaGFuZ2UsIHNldENoZWNrRXhjaGFuZ2VdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHZhbGlkYXRlRm9ybSA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGl0bGUgPT0gXCJcIiB8fCBkZXNjcmlwdGlvbiA9PSBcIlwiIHx8IGFtb3VudCA9PSBcIlwiIHx8IHRva2VuID09IFwiXCIpIHtcclxuICAgICAgICAgICAgc2V0RXJyb3IoXCJBbGwgZmllbGRzIGFyZSByZXF1aXJlZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFjaGVja0V4Y2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHNldEVycm9yKFwiXCIpO1xyXG4gICAgICAgICAgICBzZXRDaGVja0Vycm9yKFwiUGxlYXNlIHRpY2sgdGhlIGNoZWNrYm94IHRvIGNvbmZpcm0gZXhjaGFuZ2VcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRFcnJvcihcIlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVDb250ZXN0Rm9ybVN1Ym1pdCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgaWYgKHZhbGlkYXRlRm9ybSgpKSBoYW5kbGVUcmFuc2FjdGlvbigpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHNsZWVwID0gKG1pbGxpc2Vjb25kcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IG51bGw7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudERhdGUgLSBkYXRlIDwgbWlsbGlzZWNvbmRzKTtcclxuICAgIH07XHJcbiAgICAvL1VcclxuICAgIGNvbnN0IGhhbmRsZVRyYW5zYWN0aW9uID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyeSA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3I6IGN0eC5hdXRoLmFjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb246IGN0eC5hdXRoLnBlcm1pc3Npb24sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXN0ZXJzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb21OZnRzID0gW107XHJcbiAgICAgICAgICAgIGF3YWl0IHN0YXJ0UG9vbChcclxuICAgICAgICAgICAgICAgIGN0eC5hdXRoLmFjdG9yLFxyXG4gICAgICAgICAgICAgICAgY29udGVzdGVycyxcclxuICAgICAgICAgICAgICAgIHRva2VuLFxyXG4gICAgICAgICAgICAgICAgYW1vdW50LFxyXG4gICAgICAgICAgICAgICAgZnJvbU5mdHMsXHJcbiAgICAgICAgICAgICAgICBleHBpcnksXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgICAgICAgICAgd2FsbGV0Q3R4LnNlc3Npb25cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHNsZWVwKDIwMDApO1xyXG4gICAgICAgICAgICBsZXQgZXNjcm93cyA9IGF3YWl0IGZldGNoRXNjcm93cyhjdHguYXV0aC5hY3Rvcik7XHJcbiAgICAgICAgICAgIGxldCBteUVzY3Jvd3MgPSBlc2Nyb3dzLmZpbHRlcihcclxuICAgICAgICAgICAgICAgIChlc2Nyb3cpID0+IGVzY3Jvdy5mcm9tID09IGN0eC5hdXRoLmFjdG9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGxldCBsb29wSWQgPSAyO1xyXG4gICAgICAgICAgICBpZiAoIW15RXNjcm93cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICghbXlFc2Nyb3dzLmxlbmd0aCAmJiBsb29wSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbGVlcCgyMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBmZXRjaEVzY3Jvd3MoY3R4LmF1dGguYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIG15RXNjcm93cyA9IGVzY3Jvd3MuZmlsdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXNjcm93KSA9PiBlc2Nyb3cuZnJvbSA9PSBjdHguYXV0aC5hY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9vcElkLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGVzY3Jvd0lkID0gXCIwXCI7XHJcbiAgICAgICAgICAgIGlmIChteUVzY3Jvd3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBlc2Nyb3dJZCA9IG15RXNjcm93c1tteUVzY3Jvd3MubGVuZ3RoIC0gMV0uaWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGF3YWl0IGNhbmNlbFBvb2woXHJcbiAgICAgICAgICAgIC8vICAgICBjdHguYXV0aC5hY3RvcixcclxuICAgICAgICAgICAgLy8gICAgIG15RXNjcm93c1tteUVzY3Jvd3MubGVuZ3RoIC0gMV0uaWQsXHJcbiAgICAgICAgICAgIC8vICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgICAgICAvLyAgICAgd2FsbGV0Q3R4LnNlc3Npb25cclxuICAgICAgICAgICAgLy8gKTtcclxuICAgICAgICAgICAgLy8gYXdhaXQgcGFydGFrZVBvb2woXHJcbiAgICAgICAgICAgIC8vICAgICBjdHguYXV0aC5hY3RvcixcclxuICAgICAgICAgICAgLy8gICAgIG15RXNjcm93c1tteUVzY3Jvd3MubGVuZ3RoIC0gMV0uaWQsXHJcbiAgICAgICAgICAgIC8vICAgICBteUVzY3Jvd3NbbXlFc2Nyb3dzLmxlbmd0aCAtIDFdLmZyb21Ub2tlbnNbMF0sXHJcbiAgICAgICAgICAgIC8vICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgICAgICAvLyAgICAgd2FsbGV0Q3R4LnNlc3Npb25cclxuICAgICAgICAgICAgLy8gKTtcclxuICAgICAgICAgICAgLy8gYXdhaXQgZmlsbFBvb2woXHJcbiAgICAgICAgICAgIC8vICAgICBjdHguYXV0aC5hY3RvcixcclxuICAgICAgICAgICAgLy8gICAgIG15RXNjcm93c1tteUVzY3Jvd3MubGVuZ3RoIC0gMV0uaWQsXHJcbiAgICAgICAgICAgIC8vICAgICBbY3R4LmF1dGguYWN0b3IsIFwiZXNjcm93dXNlcjJcIl0sXHJcbiAgICAgICAgICAgIC8vICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgICAgICAvLyAgICAgd2FsbGV0Q3R4LnNlc3Npb25cclxuICAgICAgICAgICAgLy8gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNeUVzY3Jvd3NcIiwgbXlFc2Nyb3dzKTtcclxuICAgICAgICAgICAgZmV0Y2goYCR7cHJvY2Vzcy5lbnYuTUlYX0FQSV9VUkx9L3VzZXIvYWRkZXNjcm93YCwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlX2lkOiA1LFxyXG4gICAgICAgICAgICAgICAgICAgIGVzY3Jvd19pZDogTnVtYmVyKGVzY3Jvd0lkKSxcclxuICAgICAgICAgICAgICAgICAgICBlc2Nyb3dfc3RhdHVzOiBcInJlYWR5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBhbW91bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRva2VuLmN1cnJlbmN5LFxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcclxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgcG9vbF90eXBlOiBwb29sVHlwZSxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IFwiQmVhcmVyIFwiICsgY3R4LmF1dGguYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0Q29uZmlybWF0aW9uUG9wdXAoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdWNjZXNzUG9wdXAodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN1Y2Nlc3MoZGF0YS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcihkYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxGcmFnbWVudD5cclxuICAgICAgICAgICAgPG1haW4+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBiYW5uZXItaW5uZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aDE+UG9vbCAvIENvbnRlc3Q8L2gxPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBibG9ja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVDb250ZXN0Rm9ybVN1Ym1pdH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiY29udGVzdC10aXRsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFkZCBhIHRpdGxlIGZvciB0aGUgUG9vbCAvIENvbnRlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJjb250ZXN0LXRpdGxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGl0bGUoZXZlbnQudGFyZ2V0LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cImNvbnRlc3QtZGVzY1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlc2NyaXB0aW9uIG9mIFBvb2wgLyBDb250ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJjb250ZXN0LWRlc2NcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtkZXNjcmlwdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXREZXNjcmlwdGlvbihldmVudC50YXJnZXQudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvdGV4dGFyZWE+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWw+UG9vbCBpcyBmb3I6PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaW9cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJjYWwtZGF0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJwb29sLWZvclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwiQ2FsZW5kYXIgZGF0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3Bvb2xUeXBlID09IFwiZGF0ZVwifVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gc2V0UG9vbFR5cGUoXCJkYXRlXCIpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJjYWwtZGF0ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIENhbGVuZGFyIGRhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJhZGlvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwibnVtZXJpY2FsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cInBvb2wtZm9yXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJOdW1lcmljYWwgdmFsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtwb29sVHlwZSA9PSBcImludGVnZXJcIn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldFBvb2xUeXBlKFwiaW50ZWdlclwiKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwibnVtZXJpY2FsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgTnVtZXJpY2FsIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgbnVtZXJpY2FsIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB0byBhbnkgaXRlbSBhc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0cyByZXByZXNlbnRhdGlvbiBhbmQgcGxhY2VkIGluIHRoZSBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveC4gU3VjaCBhcyAxIGZvciByZWQsIDIgZm9yIGJsdWUsIDMgZm9yIGdyZWVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV0Yy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc21hbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cImNvbnRlc3RfdG9rZW5cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWxlY3QgYSB0b2tlbiB0aGF0IHlvdSB3aXNoIHRvIHVzZSBmb3IgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvb2wgLyBjb250ZXN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEcm9wZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e3Rva2Vuc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE9wdGlvbj17dG9rZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRPcHRpb249e3NldFRva2VufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiY29udGVzdC1hbW91bnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbnRlciBhIG51bWVyaWNhbCBhbW91bnQgdGhhdCBlYWNoIHVzZXIgd2lsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyaWJ1dGUgdG8gdGhlIHBvb2wgLyBjb250ZXN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA9XCIwLjAxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD1cImNvbnRlc3QtYW1vdW50XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17YW1vdW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFtb3VudChldmVudC50YXJnZXQudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3cgY29uZmlybS1jaGVja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD1cImNvbnRlc3QtaXRlbVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImNvbnRlc3QtaXRlbVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLXJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGxlYXNlIGNvbmZpcm0gdGhlIGZvbGxvd2luZyBwcm9wb3NlZCBwdXJjaGFzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLXJvdyBjb25maXJtLWNoZWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwiY3J5cHRvX2V4Y2hhbmdlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiY3J5cHRvX2V4Y2hhbmdlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y2hlY2tFeGNoYW5nZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDaGVja0V4Y2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cImNyeXB0b19leGNoYW5nZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtgUGxlYXNlIGNvbmZpcm0gdG8gYWRkICR7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCB8fCBcIih0b2tlbiBudW1lcmljYWwgYW1vdW50KVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5jdXJyZW5jeSB8fCBcIih0b2tlbiBuYW1lKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB0byB0aGUgcG9vbC9jb250ZXN0LmB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLXJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0aGlzIGlzIGNvcnJlY3QgcGxlYXNlIGNvbmZpcm0gYW5kIHlvdXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3J5cHRvIHdpbGwgYmUgbW92ZWQgb3V0IG9mIHlvdXIgUHJvdG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldCBpbnRvIHRoZSBFYXN5RXNjcm93IFNtYXJ0IENvbnRyYWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc21hbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hlY2tFcnJvciAhPT0gXCJcIiAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93IGVycm9yXCI+e2NoZWNrRXJyb3J9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtlcnJvciAhPT0gXCJcIiAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93IGVycm9yXCI+e2Vycm9yfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y3R4LmlzTG9nZ2VkSW4gJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLXJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJDb25maXJtXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc9e2xvYWRpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IWN0eC5pc0xvZ2dlZEluICYmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTG9naW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXthc3luYyAoKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2FsbGV0Q3R4LnByb3RvbkNvbm5lY3Rpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc9e2xvYWRpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L21haW4+XHJcblxyXG4gICAgICAgICAgICB7c3VjY2Vzc1BvcHVwICYmIChcclxuICAgICAgICAgICAgICAgIDxNb2RhbCBoaWRlUG9wdXA9eygpID0+IHNldFN1Y2Nlc3NQb3B1cChmYWxzZSl9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJtb2RhbC1oZWFkZXJcIj5Qb29sIC8gQ29udGVzdDwvaDM+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3cgc3VjY2Vzc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+e3N1Y2Nlc3N9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1jb25maXJtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJDb250aW51ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17Y2xvc2VTdWNjZXNzUG9wdXB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgPC9GcmFnbWVudD5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb250ZXN0O1xyXG4iLCIvL1VzZSBBUEkgdG8gc2F2ZSB0cmFuc2FjdGlvbiBkZXRhaWxzXHJcbmltcG9ydCB7IEFwaUNsYXNzIH0gZnJvbSBcIkBwcm90b24vYXBpXCI7XHJcbmltcG9ydCB7IGN1cnJlbnRfbmV0d29yayB9IGZyb20gXCIuLi9jb25zdGFudHMvbmV0d29ya3NcIjtcclxuXHJcbmNvbnN0IGFwaSA9IG5ldyBBcGlDbGFzcyhjdXJyZW50X25ldHdvcmsuY2hhaW4pO1xyXG5jb25zdCBjb250cmFjdCA9IFwiZWFzeWVzY3Jvd3BsXCI7XHJcblxyXG5jb25zdCBmZWVDb250cmFjdCA9IFwieHRva2Vuc1wiO1xyXG5jb25zdCBmZWVRdWFudGl0eSA9IFwiMC4yNTAwMDAgWFVTRENcIjtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEVzY3Jvd0FsbCgpIHtcclxuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgYXBpLnJwYy5nZXRfdGFibGVfcm93cyh7XHJcbiAgICAgICAgY29kZTogY29udHJhY3QsXHJcbiAgICAgICAgc2NvcGU6IGNvbnRyYWN0LFxyXG4gICAgICAgIHRhYmxlOiBcImVzY3Jvd3NcIixcclxuICAgICAgICBpbmRleF9wb3NpdGlvbjogMixcclxuICAgICAgICBrZXlfdHlwZTogXCJpNjRcIixcclxuICAgICAgICBsaW1pdDogLTEsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiByb3dzO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hFc2Nyb3dzKGFjY291bnROYW1lKSB7XHJcbiAgICBjb25zdCB7IHJvd3MgfSA9IGF3YWl0IGFwaS5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xyXG4gICAgICAgIGNvZGU6IGNvbnRyYWN0LFxyXG4gICAgICAgIHNjb3BlOiBjb250cmFjdCxcclxuICAgICAgICB0YWJsZTogXCJlc2Nyb3dzXCIsXHJcbiAgICAgICAgaW5kZXhfcG9zaXRpb246IDIsXHJcbiAgICAgICAga2V5X3R5cGU6IFwiaTY0XCIsXHJcbiAgICAgICAgbG93ZXJfYm91bmQ6IGFjY291bnROYW1lLFxyXG4gICAgICAgIHVwcGVyX2JvdW5kOiBhY2NvdW50TmFtZSxcclxuICAgICAgICBsaW1pdDogLTEsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiByb3dzO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydFBvb2woXHJcbiAgICBmcm9tLFxyXG4gICAgY29udGVzdGVycyxcclxuICAgIGZyb21Ub2tlbixcclxuICAgIGZyb21BbW91bnQsXHJcbiAgICBmcm9tTmZ0cyxcclxuICAgIGV4cGlyeSxcclxuICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICBzZXNzaW9uXHJcbikge1xyXG4gICAgY29uc3QgYW1vdW50SW4gPSBwYXJzZUZsb2F0KGZyb21BbW91bnQpXHJcbiAgICAgICAgLnRvRml4ZWQoTnVtYmVyKGZyb21Ub2tlbi5kZWNpbWFscykpXHJcbiAgICAgICAgLnRvU3RyaW5nKCk7XHJcbiAgICBjb25zdCBmcm9tUXVhbnRpdHkgPSBhbW91bnRJbiArIFwiIFwiICsgZnJvbVRva2VuLmN1cnJlbmN5O1xyXG4gICAgY29uc3QgYWN0aW9ucyA9IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFjY291bnQ6IGZlZUNvbnRyYWN0LFxyXG4gICAgICAgICAgICBuYW1lOiBcInRyYW5zZmVyXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXHJcbiAgICAgICAgICAgICAgICB0bzogY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogZmVlUXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICBtZW1vOiBgJHtmcm9tfSBkZXBvc2l0IGEgZmVlIGZvciBhIHBvb2wuYCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWNjb3VudDogZnJvbVRva2VuLmNvbnRyYWN0LFxyXG4gICAgICAgICAgICBuYW1lOiBcInRyYW5zZmVyXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXHJcbiAgICAgICAgICAgICAgICB0bzogY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogZnJvbVF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgbWVtbzogYCR7ZnJvbX0gZGVwb3NpdCBmb3IgYSBwb29sYCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWNjb3VudDogY29udHJhY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IFwic3RhcnRwb29sXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXHJcbiAgICAgICAgICAgICAgICBjb250ZXN0ZXJzOiBjb250ZXN0ZXJzLFxyXG4gICAgICAgICAgICAgICAgZnJvbVRva2VuczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3Q6IGZyb21Ub2tlbi5jb250cmFjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGZyb21RdWFudGl0eSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIGZyb21OZnRzOiBmcm9tTmZ0cyxcclxuICAgICAgICAgICAgICAgIGV4cGlyeTogZXhwaXJ5LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgIH0sXHJcbiAgICBdO1xyXG5cclxuICAgIGF3YWl0IHNlc3Npb24udHJhbnNhY3Qoe1xyXG4gICAgICAgIHRyYW5zYWN0aW9uOiB7XHJcbiAgICAgICAgICAgIGFjdGlvbnMsXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFydGFrZVBvb2woXHJcbiAgICBhY3RvcixcclxuICAgIGVzY3Jvd0lkLFxyXG4gICAgZnJvbVRva2VuLFxyXG4gICAgYXV0aG9yaXphdGlvbixcclxuICAgIHNlc3Npb25cclxuKSB7XHJcbiAgICBjb25zdCBhY3Rpb25zID0gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWNjb3VudDogZmVlQ29udHJhY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogYWN0b3IsXHJcbiAgICAgICAgICAgICAgICB0bzogY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogZmVlUXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICBtZW1vOiBgJHthY3Rvcn0gZGVwb3NpdCBhIGZlZSBmb3IgYSBwdXJjaGFzZS5gLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhY2NvdW50OiBmcm9tVG9rZW4uY29udHJhY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogYWN0b3IsXHJcbiAgICAgICAgICAgICAgICB0bzogY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogZnJvbVRva2VuLnF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgbWVtbzogYCR7YWN0b3J9IGRlcG9zaXQgZm9yIGEgcG9vbGAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFjY291bnQ6IGNvbnRyYWN0LFxyXG4gICAgICAgICAgICBuYW1lOiBcInBhcnRha2Vwb29sXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGFjdG9yOiBhY3RvcixcclxuICAgICAgICAgICAgICAgIGlkOiBlc2Nyb3dJZC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgIH0sXHJcbiAgICBdO1xyXG5cclxuICAgIGF3YWl0IHNlc3Npb24udHJhbnNhY3Qoe1xyXG4gICAgICAgIHRyYW5zYWN0aW9uOiB7XHJcbiAgICAgICAgICAgIGFjdGlvbnMsXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYW5jZWxQb29sKGFjdG9yLCBlc2Nyb3dJZCwgYXV0aG9yaXphdGlvbiwgc2Vzc2lvbikge1xyXG4gICAgY29uc3QgYWN0aW9ucyA9IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFjY291bnQ6IGNvbnRyYWN0LFxyXG4gICAgICAgICAgICBuYW1lOiBcImNhbmNlbHBvb2xcIixcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgYWN0b3I6IGFjdG9yLFxyXG4gICAgICAgICAgICAgICAgaWQ6IGVzY3Jvd0lkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgfSxcclxuICAgIF07XHJcblxyXG4gICAgYXdhaXQgc2Vzc2lvbi50cmFuc2FjdCh7XHJcbiAgICAgICAgdHJhbnNhY3Rpb246IHtcclxuICAgICAgICAgICAgYWN0aW9ucyxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaWxsUG9vbChcclxuICAgIGFjdG9yLFxyXG4gICAgZXNjcm93SWQsXHJcbiAgICB3aW5uZXJzLFxyXG4gICAgYXV0aG9yaXphdGlvbixcclxuICAgIHNlc3Npb25cclxuKSB7XHJcbiAgICBjb25zdCBhY3Rpb25zID0gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWNjb3VudDogY29udHJhY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IFwiZmlsbHBvb2xcIixcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogYWN0b3IsXHJcbiAgICAgICAgICAgICAgICBpZDogZXNjcm93SWQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIHdpbm5lcnM6IHdpbm5lcnMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgfSxcclxuICAgIF07XHJcblxyXG4gICAgYXdhaXQgc2Vzc2lvbi50cmFuc2FjdCh7XHJcbiAgICAgICAgdHJhbnNhY3Rpb246IHtcclxuICAgICAgICAgICAgYWN0aW9ucyxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuLy8gY29uc3QgaGlzdG9yeSA9IGF3YWl0IGFwaS5nZXRBY3Rpb25zRnJvbUh5cGVyaW9uKGN0eC5hdXRoLmFjdG9yLCB7XHJcbi8vICAgICBsaW1pdDogMTAsXHJcbi8vICAgICBza2lwOiAwLFxyXG4vLyAgICAgc29ydDogXCJkZXNjXCIsXHJcbi8vICAgICBmaWx0ZXI6IGNvbnRyYWN0KlwiLFxyXG4vLyB9KTtcclxuXHJcbi8vIGNvbnNvbGUubG9nKFwiSGlzdG9yeVwiLCBoaXN0b3J5KTtcclxuIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG4iLCI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4wLjJcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMSBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IDIgLSBpc09kZChuKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgICBpZiAobSkge1xyXG5cclxuICAgICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAgICovXHJcbiAgICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoeExUeSkgdCA9IHhjLCB4YyA9IHljLCB5YyA9IHQsIHkucyA9IC15LnM7XHJcblxyXG4gICAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgeGNbal0gKz0gQkFTRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgICAvLyBmb3IgZmluaXRlIHggYW5kIHkuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgIG4gJSAwID0gIE5cclxuICAgICAqICAgbiAlIE4gPSAgTlxyXG4gICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgKiAgIDAgJSBuID0gIDBcclxuICAgICAqICAtMCAlIG4gPSAtMFxyXG4gICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgKiAgIDAgJSBOID0gIE5cclxuICAgICAqICAgMCAlIEkgPSAgMFxyXG4gICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgKiAgIE4gJSAwID0gIE5cclxuICAgICAqICAgTiAlIE4gPSAgTlxyXG4gICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgKiAgIEkgJSBuID0gIE5cclxuICAgICAqICAgSSAlIDAgPSAgTlxyXG4gICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgKiAgIEkgJSBJID0gIE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgcSwgcyxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICAgIHMgPSB5LnM7XHJcbiAgICAgICAgeS5zID0gMTtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgcS5zICo9IHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICAgIGlmICgheS5jWzBdICYmIE1PRFVMT19NT0RFID09IDEpIHkucyA9IHgucztcclxuXHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICogMCA9IDBcclxuICAgICAqICBuICogTiA9IE5cclxuICAgICAqICBuICogSSA9IElcclxuICAgICAqICAwICogbiA9IDBcclxuICAgICAqICAwICogMCA9IDBcclxuICAgICAqICAwICogTiA9IE5cclxuICAgICAqICAwICogSSA9IE5cclxuICAgICAqICBOICogbiA9IE5cclxuICAgICAqICBOICogMCA9IE5cclxuICAgICAqICBOICogTiA9IE5cclxuICAgICAqICBOICogSSA9IE5cclxuICAgICAqICBJICogbiA9IElcclxuICAgICAqICBJICogMCA9IE5cclxuICAgICAqICBJICogTiA9IE5cclxuICAgICAqICBJICogSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgaWYgKCF4YyB8fCAheWMgfHwgIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICB5LnMgKj0geC5zO1xyXG4gICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgaWYgKHhjTCA8IHljTCkgemMgPSB4YywgeGMgPSB5YywgeWMgPSB6YywgaSA9IHhjTCwgeGNMID0geWNMLCB5Y0wgPSBpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgZm9yICg7IDspICB7XHJcbiAgICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgICBuID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICogbmVnYXRpdmUgemVyby5cclxuICAgICAqL1xyXG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICAgIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4gIC8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbiAgLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gICAgdmFyIGkgPSBuIHwgMDtcclxuICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG4gIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgdmFyIHMsIHosXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBqID0gYS5sZW5ndGgsXHJcbiAgICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gICAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICAgIHIgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gICAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gICAgdmFyIGEsIGIsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYyxcclxuICAgICAgaSA9IHgucyxcclxuICAgICAgaiA9IHkucyxcclxuICAgICAgayA9IHguZSxcclxuICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gICAgYSA9IGkgPCAwO1xyXG4gICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICAgIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICAgIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICAgIHZhciBsZW4sIHpzO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgICAgc3RyICs9IHpzO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0pO1xyXG5cclxuICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsT2JqZWN0KSB7XHJcbiAgICAgIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbE9iamVjdC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqcz1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9MWUzLGU9NmU0LG49MzZlNSxyPVwibWlsbGlzZWNvbmRcIixpPVwic2Vjb25kXCIscz1cIm1pbnV0ZVwiLHU9XCJob3VyXCIsYT1cImRheVwiLG89XCJ3ZWVrXCIsZj1cIm1vbnRoXCIsaD1cInF1YXJ0ZXJcIixjPVwieWVhclwiLGQ9XCJkYXRlXCIsJD1cIkludmFsaWQgRGF0ZVwiLGw9L14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbVHRcXHNdKihcXGR7MSwyfSk/Oj8oXFxkezEsMn0pPzo/KFxcZHsxLDJ9KT9bLjpdPyhcXGQrKT8kLyx5PS9cXFsoW15cXF1dKyldfFl7MSw0fXxNezEsNH18RHsxLDJ9fGR7MSw0fXxIezEsMn18aHsxLDJ9fGF8QXxtezEsMn18c3sxLDJ9fFp7MSwyfXxTU1MvZyxNPXtuYW1lOlwiZW5cIix3ZWVrZGF5czpcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLG1vbnRoczpcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIil9LG09ZnVuY3Rpb24odCxlLG4pe3ZhciByPVN0cmluZyh0KTtyZXR1cm4hcnx8ci5sZW5ndGg+PWU/dDpcIlwiK0FycmF5KGUrMS1yLmxlbmd0aCkuam9pbihuKSt0fSxnPXtzOm0sejpmdW5jdGlvbih0KXt2YXIgZT0tdC51dGNPZmZzZXQoKSxuPU1hdGguYWJzKGUpLHI9TWF0aC5mbG9vcihuLzYwKSxpPW4lNjA7cmV0dXJuKGU8PTA/XCIrXCI6XCItXCIpK20ociwyLFwiMFwiKStcIjpcIittKGksMixcIjBcIil9LG06ZnVuY3Rpb24gdChlLG4pe2lmKGUuZGF0ZSgpPG4uZGF0ZSgpKXJldHVybi10KG4sZSk7dmFyIHI9MTIqKG4ueWVhcigpLWUueWVhcigpKSsobi5tb250aCgpLWUubW9udGgoKSksaT1lLmNsb25lKCkuYWRkKHIsZikscz1uLWk8MCx1PWUuY2xvbmUoKS5hZGQocisocz8tMToxKSxmKTtyZXR1cm4rKC0ocisobi1pKS8ocz9pLXU6dS1pKSl8fDApfSxhOmZ1bmN0aW9uKHQpe3JldHVybiB0PDA/TWF0aC5jZWlsKHQpfHwwOk1hdGguZmxvb3IodCl9LHA6ZnVuY3Rpb24odCl7cmV0dXJue006Zix5OmMsdzpvLGQ6YSxEOmQsaDp1LG06cyxzOmksbXM6cixROmh9W3RdfHxTdHJpbmcodHx8XCJcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9zJC8sXCJcIil9LHU6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR9fSx2PVwiZW5cIixEPXt9O0Rbdl09TTt2YXIgcD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIF99LFM9ZnVuY3Rpb24gdChlLG4scil7dmFyIGk7aWYoIWUpcmV0dXJuIHY7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBzPWUudG9Mb3dlckNhc2UoKTtEW3NdJiYoaT1zKSxuJiYoRFtzXT1uLGk9cyk7dmFyIHU9ZS5zcGxpdChcIi1cIik7aWYoIWkmJnUubGVuZ3RoPjEpcmV0dXJuIHQodVswXSl9ZWxzZXt2YXIgYT1lLm5hbWU7RFthXT1lLGk9YX1yZXR1cm4hciYmaSYmKHY9aSksaXx8IXImJnZ9LHc9ZnVuY3Rpb24odCxlKXtpZihwKHQpKXJldHVybiB0LmNsb25lKCk7dmFyIG49XCJvYmplY3RcIj09dHlwZW9mIGU/ZTp7fTtyZXR1cm4gbi5kYXRlPXQsbi5hcmdzPWFyZ3VtZW50cyxuZXcgXyhuKX0sTz1nO08ubD1TLE8uaT1wLE8udz1mdW5jdGlvbih0LGUpe3JldHVybiB3KHQse2xvY2FsZTplLiRMLHV0YzplLiR1LHg6ZS4keCwkb2Zmc2V0OmUuJG9mZnNldH0pfTt2YXIgXz1mdW5jdGlvbigpe2Z1bmN0aW9uIE0odCl7dGhpcy4kTD1TKHQubG9jYWxlLG51bGwsITApLHRoaXMucGFyc2UodCl9dmFyIG09TS5wcm90b3R5cGU7cmV0dXJuIG0ucGFyc2U9ZnVuY3Rpb24odCl7dGhpcy4kZD1mdW5jdGlvbih0KXt2YXIgZT10LmRhdGUsbj10LnV0YztpZihudWxsPT09ZSlyZXR1cm4gbmV3IERhdGUoTmFOKTtpZihPLnUoZSkpcmV0dXJuIG5ldyBEYXRlO2lmKGUgaW5zdGFuY2VvZiBEYXRlKXJldHVybiBuZXcgRGF0ZShlKTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmIS9aJC9pLnRlc3QoZSkpe3ZhciByPWUubWF0Y2gobCk7aWYocil7dmFyIGk9clsyXS0xfHwwLHM9KHJbN118fFwiMFwiKS5zdWJzdHJpbmcoMCwzKTtyZXR1cm4gbj9uZXcgRGF0ZShEYXRlLlVUQyhyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKSk6bmV3IERhdGUoclsxXSxpLHJbM118fDEscls0XXx8MCxyWzVdfHwwLHJbNl18fDAscyl9fXJldHVybiBuZXcgRGF0ZShlKX0odCksdGhpcy4keD10Lnh8fHt9LHRoaXMuaW5pdCgpfSxtLmluaXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLiRkO3RoaXMuJHk9dC5nZXRGdWxsWWVhcigpLHRoaXMuJE09dC5nZXRNb250aCgpLHRoaXMuJEQ9dC5nZXREYXRlKCksdGhpcy4kVz10LmdldERheSgpLHRoaXMuJEg9dC5nZXRIb3VycygpLHRoaXMuJG09dC5nZXRNaW51dGVzKCksdGhpcy4kcz10LmdldFNlY29uZHMoKSx0aGlzLiRtcz10LmdldE1pbGxpc2Vjb25kcygpfSxtLiR1dGlscz1mdW5jdGlvbigpe3JldHVybiBPfSxtLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4hKHRoaXMuJGQudG9TdHJpbmcoKT09PSQpfSxtLmlzU2FtZT1mdW5jdGlvbih0LGUpe3ZhciBuPXcodCk7cmV0dXJuIHRoaXMuc3RhcnRPZihlKTw9biYmbjw9dGhpcy5lbmRPZihlKX0sbS5pc0FmdGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCk8dGhpcy5zdGFydE9mKGUpfSxtLmlzQmVmb3JlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5kT2YoZSk8dyh0KX0sbS4kZz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE8udSh0KT90aGlzW2VdOnRoaXMuc2V0KG4sdCl9LG0udW5peD1mdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpLzFlMyl9LG0udmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLmdldFRpbWUoKX0sbS5zdGFydE9mPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcyxyPSEhTy51KGUpfHxlLGg9Ty5wKHQpLCQ9ZnVuY3Rpb24odCxlKXt2YXIgaT1PLncobi4kdT9EYXRlLlVUQyhuLiR5LGUsdCk6bmV3IERhdGUobi4keSxlLHQpLG4pO3JldHVybiByP2k6aS5lbmRPZihhKX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiBPLncobi50b0RhdGUoKVt0XS5hcHBseShuLnRvRGF0ZShcInNcIiksKHI/WzAsMCwwLDBdOlsyMyw1OSw1OSw5OTldKS5zbGljZShlKSksbil9LHk9dGhpcy4kVyxNPXRoaXMuJE0sbT10aGlzLiRELGc9XCJzZXRcIisodGhpcy4kdT9cIlVUQ1wiOlwiXCIpO3N3aXRjaChoKXtjYXNlIGM6cmV0dXJuIHI/JCgxLDApOiQoMzEsMTEpO2Nhc2UgZjpyZXR1cm4gcj8kKDEsTSk6JCgwLE0rMSk7Y2FzZSBvOnZhciB2PXRoaXMuJGxvY2FsZSgpLndlZWtTdGFydHx8MCxEPSh5PHY/eSs3OnkpLXY7cmV0dXJuICQocj9tLUQ6bSsoNi1EKSxNKTtjYXNlIGE6Y2FzZSBkOnJldHVybiBsKGcrXCJIb3Vyc1wiLDApO2Nhc2UgdTpyZXR1cm4gbChnK1wiTWludXRlc1wiLDEpO2Nhc2UgczpyZXR1cm4gbChnK1wiU2Vjb25kc1wiLDIpO2Nhc2UgaTpyZXR1cm4gbChnK1wiTWlsbGlzZWNvbmRzXCIsMyk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5jbG9uZSgpfX0sbS5lbmRPZj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGFydE9mKHQsITEpfSxtLiRzZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbixvPU8ucCh0KSxoPVwic2V0XCIrKHRoaXMuJHU/XCJVVENcIjpcIlwiKSwkPShuPXt9LG5bYV09aCtcIkRhdGVcIixuW2RdPWgrXCJEYXRlXCIsbltmXT1oK1wiTW9udGhcIixuW2NdPWgrXCJGdWxsWWVhclwiLG5bdV09aCtcIkhvdXJzXCIsbltzXT1oK1wiTWludXRlc1wiLG5baV09aCtcIlNlY29uZHNcIixuW3JdPWgrXCJNaWxsaXNlY29uZHNcIixuKVtvXSxsPW89PT1hP3RoaXMuJEQrKGUtdGhpcy4kVyk6ZTtpZihvPT09Znx8bz09PWMpe3ZhciB5PXRoaXMuY2xvbmUoKS5zZXQoZCwxKTt5LiRkWyRdKGwpLHkuaW5pdCgpLHRoaXMuJGQ9eS5zZXQoZCxNYXRoLm1pbih0aGlzLiRELHkuZGF5c0luTW9udGgoKSkpLiRkfWVsc2UgJCYmdGhpcy4kZFskXShsKTtyZXR1cm4gdGhpcy5pbml0KCksdGhpc30sbS5zZXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jbG9uZSgpLiRzZXQodCxlKX0sbS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXNbTy5wKHQpXSgpfSxtLmFkZD1mdW5jdGlvbihyLGgpe3ZhciBkLCQ9dGhpcztyPU51bWJlcihyKTt2YXIgbD1PLnAoaCkseT1mdW5jdGlvbih0KXt2YXIgZT13KCQpO3JldHVybiBPLncoZS5kYXRlKGUuZGF0ZSgpK01hdGgucm91bmQodCpyKSksJCl9O2lmKGw9PT1mKXJldHVybiB0aGlzLnNldChmLHRoaXMuJE0rcik7aWYobD09PWMpcmV0dXJuIHRoaXMuc2V0KGMsdGhpcy4keStyKTtpZihsPT09YSlyZXR1cm4geSgxKTtpZihsPT09bylyZXR1cm4geSg3KTt2YXIgTT0oZD17fSxkW3NdPWUsZFt1XT1uLGRbaV09dCxkKVtsXXx8MSxtPXRoaXMuJGQuZ2V0VGltZSgpK3IqTTtyZXR1cm4gTy53KG0sdGhpcyl9LG0uc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hZGQoLTEqdCxlKX0sbS5mb3JtYXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXRoaXMuJGxvY2FsZSgpO2lmKCF0aGlzLmlzVmFsaWQoKSlyZXR1cm4gbi5pbnZhbGlkRGF0ZXx8JDt2YXIgcj10fHxcIllZWVktTU0tRERUSEg6bW06c3NaXCIsaT1PLnoodGhpcykscz10aGlzLiRILHU9dGhpcy4kbSxhPXRoaXMuJE0sbz1uLndlZWtkYXlzLGY9bi5tb250aHMsaD1mdW5jdGlvbih0LG4saSxzKXtyZXR1cm4gdCYmKHRbbl18fHQoZSxyKSl8fGlbbl0uc2xpY2UoMCxzKX0sYz1mdW5jdGlvbih0KXtyZXR1cm4gTy5zKHMlMTJ8fDEyLHQsXCIwXCIpfSxkPW4ubWVyaWRpZW18fGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10PDEyP1wiQU1cIjpcIlBNXCI7cmV0dXJuIG4/ci50b0xvd2VyQ2FzZSgpOnJ9LGw9e1lZOlN0cmluZyh0aGlzLiR5KS5zbGljZSgtMiksWVlZWTp0aGlzLiR5LE06YSsxLE1NOk8ucyhhKzEsMixcIjBcIiksTU1NOmgobi5tb250aHNTaG9ydCxhLGYsMyksTU1NTTpoKGYsYSksRDp0aGlzLiRELEREOk8ucyh0aGlzLiRELDIsXCIwXCIpLGQ6U3RyaW5nKHRoaXMuJFcpLGRkOmgobi53ZWVrZGF5c01pbix0aGlzLiRXLG8sMiksZGRkOmgobi53ZWVrZGF5c1Nob3J0LHRoaXMuJFcsbywzKSxkZGRkOm9bdGhpcy4kV10sSDpTdHJpbmcocyksSEg6Ty5zKHMsMixcIjBcIiksaDpjKDEpLGhoOmMoMiksYTpkKHMsdSwhMCksQTpkKHMsdSwhMSksbTpTdHJpbmcodSksbW06Ty5zKHUsMixcIjBcIiksczpTdHJpbmcodGhpcy4kcyksc3M6Ty5zKHRoaXMuJHMsMixcIjBcIiksU1NTOk8ucyh0aGlzLiRtcywzLFwiMFwiKSxaOml9O3JldHVybiByLnJlcGxhY2UoeSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8bFt0XXx8aS5yZXBsYWNlKFwiOlwiLFwiXCIpfSkpfSxtLnV0Y09mZnNldD1mdW5jdGlvbigpe3JldHVybiAxNSotTWF0aC5yb3VuZCh0aGlzLiRkLmdldFRpbWV6b25lT2Zmc2V0KCkvMTUpfSxtLmRpZmY9ZnVuY3Rpb24ocixkLCQpe3ZhciBsLHk9Ty5wKGQpLE09dyhyKSxtPShNLnV0Y09mZnNldCgpLXRoaXMudXRjT2Zmc2V0KCkpKmUsZz10aGlzLU0sdj1PLm0odGhpcyxNKTtyZXR1cm4gdj0obD17fSxsW2NdPXYvMTIsbFtmXT12LGxbaF09di8zLGxbb109KGctbSkvNjA0OGU1LGxbYV09KGctbSkvODY0ZTUsbFt1XT1nL24sbFtzXT1nL2UsbFtpXT1nL3QsbClbeV18fGcsJD92Ok8uYSh2KX0sbS5kYXlzSW5Nb250aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZE9mKGYpLiREfSxtLiRsb2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gRFt0aGlzLiRMXX0sbS5sb2NhbGU9ZnVuY3Rpb24odCxlKXtpZighdClyZXR1cm4gdGhpcy4kTDt2YXIgbj10aGlzLmNsb25lKCkscj1TKHQsZSwhMCk7cmV0dXJuIHImJihuLiRMPXIpLG59LG0uY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gTy53KHRoaXMuJGQsdGhpcyl9LG0udG9EYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKX0sbS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1ZhbGlkKCk/dGhpcy50b0lTT1N0cmluZygpOm51bGx9LG0udG9JU09TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b0lTT1N0cmluZygpfSxtLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9VVENTdHJpbmcoKX0sTX0oKSxUPV8ucHJvdG90eXBlO3JldHVybiB3LnByb3RvdHlwZT1ULFtbXCIkbXNcIixyXSxbXCIkc1wiLGldLFtcIiRtXCIsc10sW1wiJEhcIix1XSxbXCIkV1wiLGFdLFtcIiRNXCIsZl0sW1wiJHlcIixjXSxbXCIkRFwiLGRdXS5mb3JFYWNoKChmdW5jdGlvbih0KXtUW3RbMV1dPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLiRnKGUsdFswXSx0WzFdKX19KSksdy5leHRlbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC4kaXx8KHQoZSxfLHcpLHQuJGk9ITApLHd9LHcubG9jYWxlPVMsdy5pc0RheWpzPXAsdy51bml4PWZ1bmN0aW9uKHQpe3JldHVybiB3KDFlMyp0KX0sdy5lbj1EW3ZdLHcuTHM9RCx3LnA9e30sd30pKTsiLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KTooZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOmV8fHNlbGYpLmRheWpzX3BsdWdpbl9hZHZhbmNlZEZvcm1hdD10KCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10LnByb3RvdHlwZSxzPW4uZm9ybWF0O3IuZW4ub3JkaW5hbD1mdW5jdGlvbihlKXt2YXIgdD1bXCJ0aFwiLFwic3RcIixcIm5kXCIsXCJyZFwiXSxyPWUlMTAwO3JldHVyblwiW1wiK2UrKHRbKHItMjApJTEwXXx8dFtyXXx8dFswXSkrXCJdXCJ9LG4uZm9ybWF0PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj10aGlzLiRsb2NhbGUoKTtpZighdGhpcy5pc1ZhbGlkKCkpcmV0dXJuIHMuYmluZCh0aGlzKShlKTt2YXIgbj10aGlzLiR1dGlscygpLGE9KGV8fFwiWVlZWS1NTS1ERFRISDptbTpzc1pcIikucmVwbGFjZSgvXFxbKFteXFxdXSspXXxRfHdvfHd3fHd8V1d8V3x6enp8enxnZ2dnfEdHR0d8RG98WHx4fGt7MSwyfXxTL2csKGZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlXCJRXCI6cmV0dXJuIE1hdGguY2VpbCgodC4kTSsxKS8zKTtjYXNlXCJEb1wiOnJldHVybiByLm9yZGluYWwodC4kRCk7Y2FzZVwiZ2dnZ1wiOnJldHVybiB0LndlZWtZZWFyKCk7Y2FzZVwiR0dHR1wiOnJldHVybiB0Lmlzb1dlZWtZZWFyKCk7Y2FzZVwid29cIjpyZXR1cm4gci5vcmRpbmFsKHQud2VlaygpLFwiV1wiKTtjYXNlXCJ3XCI6Y2FzZVwid3dcIjpyZXR1cm4gbi5zKHQud2VlaygpLFwid1wiPT09ZT8xOjIsXCIwXCIpO2Nhc2VcIldcIjpjYXNlXCJXV1wiOnJldHVybiBuLnModC5pc29XZWVrKCksXCJXXCI9PT1lPzE6MixcIjBcIik7Y2FzZVwia1wiOmNhc2VcImtrXCI6cmV0dXJuIG4ucyhTdHJpbmcoMD09PXQuJEg/MjQ6dC4kSCksXCJrXCI9PT1lPzE6MixcIjBcIik7Y2FzZVwiWFwiOnJldHVybiBNYXRoLmZsb29yKHQuJGQuZ2V0VGltZSgpLzFlMyk7Y2FzZVwieFwiOnJldHVybiB0LiRkLmdldFRpbWUoKTtjYXNlXCJ6XCI6cmV0dXJuXCJbXCIrdC5vZmZzZXROYW1lKCkrXCJdXCI7Y2FzZVwienp6XCI6cmV0dXJuXCJbXCIrdC5vZmZzZXROYW1lKFwibG9uZ1wiKStcIl1cIjtkZWZhdWx0OnJldHVybiBlfX0pKTtyZXR1cm4gcy5iaW5kKHRoaXMpKGEpfX19KSk7IiwiIWZ1bmN0aW9uKHIsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpyfHxzZWxmKS5kYXlqc19wbHVnaW5fcmVsYXRpdmVUaW1lPWUoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gZnVuY3Rpb24ocixlLHQpe3I9cnx8e307dmFyIG49ZS5wcm90b3R5cGUsbz17ZnV0dXJlOlwiaW4gJXNcIixwYXN0OlwiJXMgYWdvXCIsczpcImEgZmV3IHNlY29uZHNcIixtOlwiYSBtaW51dGVcIixtbTpcIiVkIG1pbnV0ZXNcIixoOlwiYW4gaG91clwiLGhoOlwiJWQgaG91cnNcIixkOlwiYSBkYXlcIixkZDpcIiVkIGRheXNcIixNOlwiYSBtb250aFwiLE1NOlwiJWQgbW9udGhzXCIseTpcImEgeWVhclwiLHl5OlwiJWQgeWVhcnNcIn07ZnVuY3Rpb24gaShyLGUsdCxvKXtyZXR1cm4gbi5mcm9tVG9CYXNlKHIsZSx0LG8pfXQuZW4ucmVsYXRpdmVUaW1lPW8sbi5mcm9tVG9CYXNlPWZ1bmN0aW9uKGUsbixpLGQsdSl7Zm9yKHZhciBmLGEscyxsPWkuJGxvY2FsZSgpLnJlbGF0aXZlVGltZXx8byxoPXIudGhyZXNob2xkc3x8W3tsOlwic1wiLHI6NDQsZDpcInNlY29uZFwifSx7bDpcIm1cIixyOjg5fSx7bDpcIm1tXCIscjo0NCxkOlwibWludXRlXCJ9LHtsOlwiaFwiLHI6ODl9LHtsOlwiaGhcIixyOjIxLGQ6XCJob3VyXCJ9LHtsOlwiZFwiLHI6MzV9LHtsOlwiZGRcIixyOjI1LGQ6XCJkYXlcIn0se2w6XCJNXCIscjo0NX0se2w6XCJNTVwiLHI6MTAsZDpcIm1vbnRoXCJ9LHtsOlwieVwiLHI6MTd9LHtsOlwieXlcIixkOlwieWVhclwifV0sbT1oLmxlbmd0aCxjPTA7YzxtO2MrPTEpe3ZhciB5PWhbY107eS5kJiYoZj1kP3QoZSkuZGlmZihpLHkuZCwhMCk6aS5kaWZmKGUseS5kLCEwKSk7dmFyIHA9KHIucm91bmRpbmd8fE1hdGgucm91bmQpKE1hdGguYWJzKGYpKTtpZihzPWY+MCxwPD15LnJ8fCF5LnIpe3A8PTEmJmM+MCYmKHk9aFtjLTFdKTt2YXIgdj1sW3kubF07dSYmKHA9dShcIlwiK3ApKSxhPVwic3RyaW5nXCI9PXR5cGVvZiB2P3YucmVwbGFjZShcIiVkXCIscCk6dihwLG4seS5sLHMpO2JyZWFrfX1pZihuKXJldHVybiBhO3ZhciBNPXM/bC5mdXR1cmU6bC5wYXN0O3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIE0/TShhKTpNLnJlcGxhY2UoXCIlc1wiLGEpfSxuLnRvPWZ1bmN0aW9uKHIsZSl7cmV0dXJuIGkocixlLHRoaXMsITApfSxuLmZyb209ZnVuY3Rpb24ocixlKXtyZXR1cm4gaShyLGUsdGhpcyl9O3ZhciBkPWZ1bmN0aW9uKHIpe3JldHVybiByLiR1P3QudXRjKCk6dCgpfTtuLnRvTm93PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRvKGQodGhpcykscil9LG4uZnJvbU5vdz1mdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5mcm9tKGQodGhpcykscil9fX0pKTsiLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKToodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmRheWpzX3BsdWdpbl90aW1lem9uZT1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9e3llYXI6MCxtb250aDoxLGRheToyLGhvdXI6MyxtaW51dGU6NCxzZWNvbmQ6NX0sZT17fTtyZXR1cm4gZnVuY3Rpb24obixpLG8pe3ZhciByLGE9ZnVuY3Rpb24odCxuLGkpe3ZvaWQgMD09PWkmJihpPXt9KTt2YXIgbz1uZXcgRGF0ZSh0KSxyPWZ1bmN0aW9uKHQsbil7dm9pZCAwPT09biYmKG49e30pO3ZhciBpPW4udGltZVpvbmVOYW1lfHxcInNob3J0XCIsbz10K1wifFwiK2kscj1lW29dO3JldHVybiByfHwocj1uZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIse2hvdXIxMjohMSx0aW1lWm9uZTp0LHllYXI6XCJudW1lcmljXCIsbW9udGg6XCIyLWRpZ2l0XCIsZGF5OlwiMi1kaWdpdFwiLGhvdXI6XCIyLWRpZ2l0XCIsbWludXRlOlwiMi1kaWdpdFwiLHNlY29uZDpcIjItZGlnaXRcIix0aW1lWm9uZU5hbWU6aX0pLGVbb109cikscn0obixpKTtyZXR1cm4gci5mb3JtYXRUb1BhcnRzKG8pfSx1PWZ1bmN0aW9uKGUsbil7Zm9yKHZhciBpPWEoZSxuKSxyPVtdLHU9MDt1PGkubGVuZ3RoO3UrPTEpe3ZhciBmPWlbdV0scz1mLnR5cGUsbT1mLnZhbHVlLGM9dFtzXTtjPj0wJiYocltjXT1wYXJzZUludChtLDEwKSl9dmFyIGQ9clszXSxsPTI0PT09ZD8wOmQsdj1yWzBdK1wiLVwiK3JbMV0rXCItXCIrclsyXStcIiBcIitsK1wiOlwiK3JbNF0rXCI6XCIrcls1XStcIjowMDBcIixoPStlO3JldHVybihvLnV0Yyh2KS52YWx1ZU9mKCktKGgtPWglMWUzKSkvNmU0fSxmPWkucHJvdG90eXBlO2YudHo9ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT10JiYodD1yKTt2YXIgbj10aGlzLnV0Y09mZnNldCgpLGk9dGhpcy50b0RhdGUoKSxhPWkudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLHt0aW1lWm9uZTp0fSksdT1NYXRoLnJvdW5kKChpLW5ldyBEYXRlKGEpKS8xZTMvNjApLGY9byhhKS4kc2V0KFwibWlsbGlzZWNvbmRcIix0aGlzLiRtcykudXRjT2Zmc2V0KDE1Ki1NYXRoLnJvdW5kKGkuZ2V0VGltZXpvbmVPZmZzZXQoKS8xNSktdSwhMCk7aWYoZSl7dmFyIHM9Zi51dGNPZmZzZXQoKTtmPWYuYWRkKG4tcyxcIm1pbnV0ZVwiKX1yZXR1cm4gZi4keC4kdGltZXpvbmU9dCxmfSxmLm9mZnNldE5hbWU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy4keC4kdGltZXpvbmV8fG8udHouZ3Vlc3MoKSxuPWEodGhpcy52YWx1ZU9mKCksZSx7dGltZVpvbmVOYW1lOnR9KS5maW5kKChmdW5jdGlvbih0KXtyZXR1cm5cInRpbWV6b25lbmFtZVwiPT09dC50eXBlLnRvTG93ZXJDYXNlKCl9KSk7cmV0dXJuIG4mJm4udmFsdWV9O3ZhciBzPWYuc3RhcnRPZjtmLnN0YXJ0T2Y9ZnVuY3Rpb24odCxlKXtpZighdGhpcy4keHx8IXRoaXMuJHguJHRpbWV6b25lKXJldHVybiBzLmNhbGwodGhpcyx0LGUpO3ZhciBuPW8odGhpcy5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzOlNTU1wiKSk7cmV0dXJuIHMuY2FsbChuLHQsZSkudHoodGhpcy4keC4kdGltZXpvbmUsITApfSxvLnR6PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uJiZlLGE9bnx8ZXx8cixmPXUoK28oKSxhKTtpZihcInN0cmluZ1wiIT10eXBlb2YgdClyZXR1cm4gbyh0KS50eihhKTt2YXIgcz1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC02MCplKjFlMyxvPXUoaSxuKTtpZihlPT09bylyZXR1cm5baSxlXTt2YXIgcj11KGktPTYwKihvLWUpKjFlMyxuKTtyZXR1cm4gbz09PXI/W2ksb106W3QtNjAqTWF0aC5taW4obyxyKSoxZTMsTWF0aC5tYXgobyxyKV19KG8udXRjKHQsaSkudmFsdWVPZigpLGYsYSksbT1zWzBdLGM9c1sxXSxkPW8obSkudXRjT2Zmc2V0KGMpO3JldHVybiBkLiR4LiR0aW1lem9uZT1hLGR9LG8udHouZ3Vlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lfSxvLnR6LnNldERlZmF1bHQ9ZnVuY3Rpb24odCl7cj10fX19KSk7IiwiIWZ1bmN0aW9uKHQsaSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9aSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoaSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqc19wbHVnaW5fdXRjPWkoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD1cIm1pbnV0ZVwiLGk9L1srLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2csZT0vKFsrLV18XFxkXFxkKS9nO3JldHVybiBmdW5jdGlvbihzLGYsbil7dmFyIHU9Zi5wcm90b3R5cGU7bi51dGM9ZnVuY3Rpb24odCl7dmFyIGk9e2RhdGU6dCx1dGM6ITAsYXJnczphcmd1bWVudHN9O3JldHVybiBuZXcgZihpKX0sdS51dGM9ZnVuY3Rpb24oaSl7dmFyIGU9bih0aGlzLnRvRGF0ZSgpLHtsb2NhbGU6dGhpcy4kTCx1dGM6ITB9KTtyZXR1cm4gaT9lLmFkZCh0aGlzLnV0Y09mZnNldCgpLHQpOmV9LHUubG9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLnRvRGF0ZSgpLHtsb2NhbGU6dGhpcy4kTCx1dGM6ITF9KX07dmFyIG89dS5wYXJzZTt1LnBhcnNlPWZ1bmN0aW9uKHQpe3QudXRjJiYodGhpcy4kdT0hMCksdGhpcy4kdXRpbHMoKS51KHQuJG9mZnNldCl8fCh0aGlzLiRvZmZzZXQ9dC4kb2Zmc2V0KSxvLmNhbGwodGhpcyx0KX07dmFyIHI9dS5pbml0O3UuaW5pdD1mdW5jdGlvbigpe2lmKHRoaXMuJHUpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldFVUQ0Z1bGxZZWFyKCksdGhpcy4kTT10LmdldFVUQ01vbnRoKCksdGhpcy4kRD10LmdldFVUQ0RhdGUoKSx0aGlzLiRXPXQuZ2V0VVRDRGF5KCksdGhpcy4kSD10LmdldFVUQ0hvdXJzKCksdGhpcy4kbT10LmdldFVUQ01pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0VVRDU2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0VVRDTWlsbGlzZWNvbmRzKCl9ZWxzZSByLmNhbGwodGhpcyl9O3ZhciBhPXUudXRjT2Zmc2V0O3UudXRjT2Zmc2V0PWZ1bmN0aW9uKHMsZil7dmFyIG49dGhpcy4kdXRpbHMoKS51O2lmKG4ocykpcmV0dXJuIHRoaXMuJHU/MDpuKHRoaXMuJG9mZnNldCk/YS5jYWxsKHRoaXMpOnRoaXMuJG9mZnNldDtpZihcInN0cmluZ1wiPT10eXBlb2YgcyYmKHM9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9XCJcIik7dmFyIHM9dC5tYXRjaChpKTtpZighcylyZXR1cm4gbnVsbDt2YXIgZj0oXCJcIitzWzBdKS5tYXRjaChlKXx8W1wiLVwiLDAsMF0sbj1mWzBdLHU9NjAqK2ZbMV0rICtmWzJdO3JldHVybiAwPT09dT8wOlwiK1wiPT09bj91Oi11fShzKSxudWxsPT09cykpcmV0dXJuIHRoaXM7dmFyIHU9TWF0aC5hYnMocyk8PTE2PzYwKnM6cyxvPXRoaXM7aWYoZilyZXR1cm4gby4kb2Zmc2V0PXUsby4kdT0wPT09cyxvO2lmKDAhPT1zKXt2YXIgcj10aGlzLiR1P3RoaXMudG9EYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTotMSp0aGlzLnV0Y09mZnNldCgpOyhvPXRoaXMubG9jYWwoKS5hZGQodStyLHQpKS4kb2Zmc2V0PXUsby4keC4kbG9jYWxPZmZzZXQ9cn1lbHNlIG89dGhpcy51dGMoKTtyZXR1cm4gb307dmFyIGg9dS5mb3JtYXQ7dS5mb3JtYXQ9ZnVuY3Rpb24odCl7dmFyIGk9dHx8KHRoaXMuJHU/XCJZWVlZLU1NLUREVEhIOm1tOnNzW1pdXCI6XCJcIik7cmV0dXJuIGguY2FsbCh0aGlzLGkpfSx1LnZhbHVlT2Y9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLiR1dGlscygpLnUodGhpcy4kb2Zmc2V0KT8wOnRoaXMuJG9mZnNldCsodGhpcy4keC4kbG9jYWxPZmZzZXR8fHRoaXMuJGQuZ2V0VGltZXpvbmVPZmZzZXQoKSk7cmV0dXJuIHRoaXMuJGQudmFsdWVPZigpLTZlNCp0fSx1LmlzVVRDPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLiR1fSx1LnRvSVNPU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKX0sdS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvRGF0ZSgpLnRvVVRDU3RyaW5nKCl9O3ZhciBsPXUudG9EYXRlO3UudG9EYXRlPWZ1bmN0aW9uKHQpe3JldHVyblwic1wiPT09dCYmdGhpcy4kb2Zmc2V0P24odGhpcy5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzOlNTU1wiKSkudG9EYXRlKCk6bC5jYWxsKHRoaXMpfTt2YXIgYz11LmRpZmY7dS5kaWZmPWZ1bmN0aW9uKHQsaSxlKXtpZih0JiZ0aGlzLiR1PT09dC4kdSlyZXR1cm4gYy5jYWxsKHRoaXMsdCxpLGUpO3ZhciBzPXRoaXMubG9jYWwoKSxmPW4odCkubG9jYWwoKTtyZXR1cm4gYy5jYWxsKHMsZixpLGUpfX19KSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xudmFyICRleGVjID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC9nLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIE1hcExpa2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKS5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tYXBba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMuX21hcFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwW2tleV07XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9tYXApO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tYXBba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLl9tYXBba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNYXBMaWtlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwTGlrZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5jbGFzcyBNZXNzYWdlSGFuZGxlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLm1ldGhvZHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZU1lc3NhZ2Uoc29ja2V0LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBsZXQgaXNCaW5hcnkgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgaXNCaW5hcnkgPSB0cnVlO1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgaXNCaW5hcnkgPSB0cnVlO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBpc0JpbmFyeSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhID0gXCJbXCIgKyBkYXRhLm1hcChidWYgPT4gYnVmLnRvU3RyaW5nKCkpLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjb21tb25fMS5jcmVhdGVFcnJvcigtMzI2MDAgLyogSW52YWxpZFJlcXVlc3QgKi8sIG51bGwsIFwiRW1wdHkgQXJyYXlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShyZXMpLCBpc0JpbmFyeSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbHMucHVzaCguLi5vYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbHMucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogY29tbW9uXzEuY3JlYXRlRXJyb3IoLTMyNzAwIC8qIFBhcnNlRXJyb3IgKi8sIG51bGwsIFwiSW52YWxpZCBKU09OXCIpLFxuICAgICAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkocmVzKSwgaXNCaW5hcnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBjYWxscykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fcHJvY2Vzc0NhbGwoc29ja2V0LCBjYWxsKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZXMucHVzaChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoaXNBcnJheSA/IHJlc3BvbnNlcyA6IHJlc3BvbnNlc1swXSksIGlzQmluYXJ5KTtcbiAgICB9XG4gICAgYXN5bmMgX3Byb2Nlc3NDYWxsKHNvY2tldCwgY2FsbCkge1xuICAgICAgICBjb25zdCByZXFJZCA9IGNhbGwuaWQ7XG4gICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBpZDogcmVxSWQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiByZXFJZFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGNhbGwgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsLmpzb25ycGMgIT09IFwiMi4wXCIgJiYgKHRoaXMub3B0aW9ucy5qc29ucnBjVmVyc2lvbkNoZWNrID09PSAwIC8qIFNUUklDVCAqLyB8fFxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5qc29ucnBjVmVyc2lvbkNoZWNrID09PSAxIC8qIExPT1NFICovICYmIGNhbGwuanNvbnJwYyAhPT0gdW5kZWZpbmVkKSkpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLywgbnVsbCwgXCJJbnZhbGlkIEpTT04tUlBDIFZlcnNpb25cIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tb25fMS5pc1Jlc3BvbnNlKGNhbGwpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZXNwb25zZVwiLCBzb2NrZXQsIGNhbGwpO1xuICAgICAgICAgICAgaWYgKGNhbGwuaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJtZXRob2RfcmVzcG9uc2VcIiwgc29ja2V0LCBjYWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbGwuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuZXJyb3IgPSBjb21tb25fMS5jcmVhdGVFcnJvcigtMzI2MDAgLyogSW52YWxpZFJlcXVlc3QgKi8pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvcl9yZXNwb25zZVwiLCBzb2NrZXQsIGNhbGwpO1xuICAgICAgICAgICAgaWYgKGNhbGwuZXJyb3IuY29kZSA9PT0gLTMyNzAwIC8qIFBhcnNlRXJyb3IgKi8gfHwgY2FsbC5lcnJvci5jb2RlID09PSAtMzI2MDAgLyogSW52YWxpZFJlcXVlc3QgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJub3RpZmljYXRpb25fZXJyb3JcIiwgc29ja2V0LCBjYWxsLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbGwubWV0aG9kKSB7XG4gICAgICAgICAgICByZXMuZXJyb3IgPSBjb21tb25fMS5jcmVhdGVFcnJvcigtMzI2MDEgLyogTWV0aG9kTm90Rm91bmQgKi8sIG51bGwsIFwiTWV0aG9kIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbC5tZXRob2QgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLywgbnVsbCwgXCJJbnZhbGlkIHR5cGUgb2YgbWV0aG9kIG5hbWVcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInBhcmFtc1wiIGluIGNhbGwgJiYgKHR5cGVvZiBjYWxsLnBhcmFtcyAhPT0gXCJvYmplY3RcIiB8fCBjYWxsLnBhcmFtcyA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZHMuaGFzKGNhbGwubWV0aG9kKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMSAvKiBNZXRob2ROb3RGb3VuZCAqLyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgdGhpcy5tZXRob2RzLmdldChjYWxsLm1ldGhvZCkoc29ja2V0LCBjYWxsLnBhcmFtcykgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXFJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHJlcUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVycm9yID0gY29tbW9uXzEuY3JlYXRlRXJyb3IoLTMyMDAwIC8qIFNlcnZlckVycm9yICovLCBlLm5hbWUsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1lc3NhZ2VIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzc2FnZUhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbmZpZ0RlZmF1bHRzID0gdm9pZCAwO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZShcImlzb21vcnBoaWMtd3NcIik7XG5jb25zdCBCYWNrb2ZmID0gcmVxdWlyZShcImJhY2tvMlwiKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudGVtaXR0ZXIzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5jb25zdCBNZXNzYWdlSGFuZGxlcl8xID0gcmVxdWlyZShcIi4vTWVzc2FnZUhhbmRsZXJcIik7XG5leHBvcnRzLkNvbmZpZ0RlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgcmVjb25uZWN0aW9uOiB0cnVlLFxuICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiBJbmZpbml0eSxcbiAgICByZWNvbm5lY3Rpb25EZWxheTogMTAwMCxcbiAgICByZWNvbm5lY3Rpb25EZWxheU1heDogNTAwMCxcbiAgICByZWNvbm5lY3Rpb25KaXR0ZXI6IDAuNSxcbiAgICBtZXRob2RDYWxsVGltZW91dDogMjAwMDAsXG4gICAgYXV0b0Nvbm5lY3Q6IHRydWUsXG4gICAgYnVmZmVyU2VuZGluZ01lc3NhZ2VzOiB0cnVlLFxuICAgIHF1ZXJ5OiB7fSxcbiAgICBwcm90b2NvbHM6IFwiXCJcbn0pO1xuLyoqXG4gKiBKU09OLVJQQyAyLjAgQ2xpZW50XG4gKi9cbmNsYXNzIENsaWVudCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHVyaSBUaGUgVVJJIHRvIGNvbm5lY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudXJpID0gdXJpO1xuICAgICAgICB0aGlzLnNlbmRpbmdNZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9za2lwUmVjb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0SWQgPSAwO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmV4cG9ydHMuQ29uZmlnRGVmYXVsdHMsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2JhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgICAgICAgICBtaW46IHRoaXMuY29uZmlnLnJlY29ubmVjdGlvbkRlbGF5LFxuICAgICAgICAgICAgbWF4OiB0aGlzLmNvbmZpZy5yZWNvbm5lY3Rpb25EZWxheU1heCxcbiAgICAgICAgICAgIGppdHRlcjogdGhpcy5jb25maWcucmVjb25uZWN0aW9uSml0dGVyXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcl8xLmRlZmF1bHQodGhpcy5jb25maWcpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcIm1ldGhvZF9yZXNwb25zZVwiLCAoc29ja2V0LCByZXNwb25zZSkgPT4gdGhpcy5faGFuZGxlTWV0aG9kUmVzcG9uc2UocmVzcG9uc2UpKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIub24oXCJlcnJvcl9yZXNwb25zZVwiLCAoc29ja2V0LCByZXNwb25zZSkgPT4gdGhpcy5lbWl0KFwiZXJyb3JfcmVzcG9uc2VcIiwgcmVzcG9uc2UpKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIub24oXCJub3RpZmljYXRpb25fZXJyb3JcIiwgKHNvY2tldCwgZXJyb3IpID0+IHRoaXMuZW1pdChcIm5vdGlmaWNhdGlvbl9lcnJvclwiLCBlcnJvcikpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYXV0b0Nvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKCgpID0+IHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG1ldGhvZHMoKSB7IHJldHVybiB0aGlzLl9tZXNzYWdlSGFuZGxlci5tZXRob2RzOyB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGluZ1wiKTtcbiAgICAgICAgY29uc3Qgd3MgPSB0aGlzLl93cyA9IG5ldyBXZWJTb2NrZXQodGhpcy51cmksIHRoaXMuY29uZmlnLnByb3RvY29scywgdGhpcy5jb25maWcpO1xuICAgICAgICBpZiAod3MuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9yID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKHsgY29kZSwgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3MgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoeyBkYXRhIH0pID0+IHRoaXMuX21lc3NhZ2VIYW5kbGVyLmhhbmRsZU1lc3NhZ2UodGhpcywgZGF0YSkuY2F0Y2goZSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3Mub24oXCJlcnJvclwiLCBlcnJvciA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpO1xuICAgICAgICAgICAgd3Mub24oXCJjbG9zZVwiLCAoY29kZSwgcmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBjb2RlLCByZWFzb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dzID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd3Mub24oXCJtZXNzYWdlXCIsIGRhdGEgPT4gdGhpcy5fbWVzc2FnZUhhbmRsZXIuaGFuZGxlTWVzc2FnZSh0aGlzLCBkYXRhKS5jYXRjaChlID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJlY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc2tpcFJlY29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHdzLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKCkgPT4gdGhpcy5yZWNvbm5lY3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cy5vbihcImNsb3NlXCIsICgpID0+IHRoaXMucmVjb25uZWN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh3cy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3cy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cy5vbmNlKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdzLm9mZihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3cy5vbmNlKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NlbmRCdWZmZXJlZE1lc3NhZ2VzKCk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCB0aGUgY29ubmVjdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLl9za2lwUmVjb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgLy8gY2xlYXIgbWV0aG9kIGNhbGwgdGltZW91dC5cbiAgICAgICAgZm9yIChjb25zdCBbdGltZXJdIG9mIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5jbGVhcigpO1xuICAgICAgICAvLyBjbGVhciByZWNvbm5lY3Rpb24gdGltZXIuXG4gICAgICAgIGlmICh0aGlzLl9yZWNvbm5lY3Rpb25TbGVlcFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVjb25uZWN0aW9uU2xlZXBUaW1lcik7XG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb25TbGVlcFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cyA9IHRoaXMuX3dzO1xuICAgICAgICBpZiAoIXdzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTiB8fCB3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh3cy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoKSA9PiByZXNvbHZlKCksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdzLm9uY2UoXCJjbG9zZVwiLCAoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IG51bGw7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgIGlmICh3cy5yZW1vdmVBbGxMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIC8vIGZvciBub2RlXG4gICAgICAgICAgICB3cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvciBicm93c2VyXG4gICAgICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGF0IHRoaXMgdGltZS5cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kKGRhdGEsIGJpbmFyeSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChiaW5hcnkgJiYgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNlbmRpbmdNZXNzYWdlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dzLnNlbmQoZGF0YSwgZSA9PiBlID8gdGhpcy5fYnVmZmVyU2VuZGluZ01lc3NhZ2UoZGF0YSkgOiBudWxsKTtcbiAgICB9XG4gICAgY2xlYXJTZW5kaW5nTWVzc2FnZUJ1ZmZlcigpIHtcbiAgICAgICAgdGhpcy5zZW5kaW5nTWVzc2FnZUJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBub3RpZnkobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICB9XG4gICAgY2FsbChtZXRob2QsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fY3VycmVudFJlcXVlc3RJZCsrO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGlkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJKU09OLVJQQzogbWV0aG9kIGNhbGwgdGltZW91dFwiKSk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5tZXRob2RDYWxsVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnNldChpZCwgW3RpbWVvdXQsIHJlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyAhPT0gbnVsbCAmJiB0aGlzLl93cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTjtcbiAgICB9XG4gICAgYXN5bmMgcmVjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVjb25uZWN0aW5nIHx8IHRoaXMuX3NraXBSZWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYWNrb2ZmID0gdGhpcy5fYmFja29mZjtcbiAgICAgICAgaWYgKGJhY2tvZmYuYXR0ZW1wdHMgPiB0aGlzLmNvbmZpZy5yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVjb25uZWN0X2ZhaWxlZFwiKTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gYmFja29mZi5kdXJhdGlvbigpO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHRoaXMuX3JlY29ubmVjdGlvblNsZWVwVGltZXIgPSBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvblNsZWVwVGltZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fc2tpcFJlY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInJlY29ubmVjdGluZ1wiLCBiYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuX3NraXBSZWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVjb25uZWN0X2Vycm9yXCIsIGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0ZW1wdHMgPSBiYWNrb2ZmLmF0dGVtcHRzO1xuICAgICAgICBiYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWNvbm5lY3RlZFwiLCBhdHRlbXB0cyk7XG4gICAgfVxuICAgIF9oYW5kbGVNZXRob2RSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmlkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1bmtvd25fcmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmdldChyZXNwb25zZS5pZCk7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidW5rb3duX3Jlc3BvbnNlXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmRlbGV0ZShyZXNwb25zZS5pZCk7XG4gICAgICAgIGNvbnN0IFt0aW1lciwgcmVzb2x2ZSwgcmVqZWN0XSA9IGhhbmRsZXI7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGlmIChjb21tb25fMS5pc1N1Y2Nlc3NSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2J1ZmZlclNlbmRpbmdNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJ1ZmZlclNlbmRpbmdNZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5zZW5kaW5nTWVzc2FnZUJ1ZmZlci5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZSBpcyByZWplY3RlZDogIFRoZSBzb2NrZXQgaXMgY2xvc2Ugd2l0aG91dCBtZXNzYWdlIGJ1ZmZlcmluZy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3NlbmRCdWZmZXJlZE1lc3NhZ2VzKCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLnNlbmRpbmdNZXNzYWdlQnVmZmVyO1xuICAgICAgICBjb25zdCB3cyA9IHRoaXMuX3dzO1xuICAgICAgICBmb3IgKGxldCBkYXRhID0gYnVmZmVyLnNoaWZ0KCk7IGRhdGE7IGRhdGEgPSBidWZmZXIuc2hpZnQoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB3cy5zZW5kKGRhdGEsIGUgPT4gZSA/IHJlamVjdChlKSA6IHJlc29sdmUoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIudW5zaGlmdChkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJidWZmZXJfc2VuZGluZ19lcnJvclwiLCBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRXJyb3IgPSBleHBvcnRzLmVycm9yQ29kZU1hcCA9IGV4cG9ydHMuaXNTdWNjZXNzUmVzcG9uc2UgPSBleHBvcnRzLmlzUmVzcG9uc2UgPSB2b2lkIDA7XG4vKipcbiAqIENoZWNrIHR5cGUgb2YgY2FsbCBpcyBhbiBSZXBvbnNlIG9yIG5vdFxuICogQHBhcmFtIGNhbGwgYW4gQ2FsbCBvYmplY3Qgd2hpY2ggd2lsbCBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKGNhbGwpIHtcbiAgICByZXR1cm4gXCJpZFwiIGluIGNhbGwgJiYgKFwicmVzdWx0XCIgaW4gY2FsbCB8fCBcImVycm9yXCIgaW4gY2FsbCk7XG59XG5leHBvcnRzLmlzUmVzcG9uc2UgPSBpc1Jlc3BvbnNlO1xuLyoqXG4gKiBDaGVjayB0eXBlIG9mIHJlc3BvbnNlIGlzIFN1Y2Nlc3NSZXNwb25zZSBvciBub3RcbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgYW4gUmVzcG9uc2Ugb2JqZWN0IHdoaWNoIHdpbGwgYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdWNjZXNzUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gXCJyZXN1bHRcIiBpbiByZXNwb25zZSAmJiByZXNwb25zZS5pZCAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNTdWNjZXNzUmVzcG9uc2UgPSBpc1N1Y2Nlc3NSZXNwb25zZTtcbi8qKlxuICogSlNPTi1SUEMgMi4wIEVycm9yIENvZGVzXG4gKi9cbmV4cG9ydHMuZXJyb3JDb2RlTWFwID0gbmV3IE1hcChbXG4gICAgWy0zMjcwMCwgXCJQYXJzZSBlcnJvclwiXSxcbiAgICBbLTMyNjAwLCBcIkludmFsaWQgUmVxdWVzdFwiXSxcbiAgICBbLTMyNjAxLCBcIk1ldGhvZCBub3QgZm91bmRcIl0sXG4gICAgWy0zMjYwMiwgXCJJbnZhbGlkIHBhcmFtc1wiXSxcbiAgICBbLTMyNjAzLCBcIkludGVybmFsIGVycm9yXCJdLFxuICAgIFstMzIwMDAsIFwiU2VydmVyIGVycm9yXCJdXG5dKTtcbi8qKlxuICogQ3JlYXRlcyBhIEpTT04tUlBDIDIuMCBjb21wbGlhbnQgRXJyb3IgT2JqZWN0XG4gKiBAcGFyYW0gY29kZSBBIE51bWJlciB0aGF0IGluZGljYXRlcyB0aGUgZXJyb3IgdHlwZSB0aGF0IG9jY3VycmVkLiAoSW50ZWdlcilcbiAqIEBwYXJhbSBkYXRhIEEgUHJpbWl0aXZlIG9yIFN0cnVjdHVyZWQgdmFsdWUgdGhhdCBjb250YWlucyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIGNvbnN0IGVycm9yID0ge1xuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IGV4cG9ydHMuZXJyb3JDb2RlTWFwLmdldChjb2RlKSB8fCBcIlNlcnZlciBlcnJvclwiXG4gICAgfTtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnRzLmNyZWF0ZUVycm9yID0gY3JlYXRlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudCA9IGV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xudmFyIHNlcnZlcl8xID0gcmVxdWlyZShcIi4vc2VydmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfMS5kZWZhdWx0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudGVtaXR0ZXIzXCIpO1xuY29uc3Qgd3NfMSA9IHJlcXVpcmUoXCJ3c1wiKTtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgTWVzc2FnZUhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL01lc3NhZ2VIYW5kbGVyXCIpO1xuY29uc3QgTWFwTGlrZV8xID0gcmVxdWlyZShcIi4vTWFwTGlrZVwiKTtcbi8qKlxuICogSlNPTi1SUEMgMi4wIFdlYlNvY2tldCBTZXJ2ZXJcbiAqL1xuY2xhc3MgU2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayBjYWxsYmFjayBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnQgKHdzKS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNvY2tldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2xhc3RQaW5nQXQgPSAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHBpbmdUaW1lb3V0OiA1MDAwLFxuICAgICAgICAgICAgcGluZ0ludGVydmFsOiAyNTAwMCxcbiAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICBqc29ucnBjVmVyc2lvbkNoZWNrOiAwIC8qIFNUUklDVCAqLyxcbiAgICAgICAgICAgIHV3czogZmFsc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyXzEuZGVmYXVsdCh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcImVycm9yX3Jlc3BvbnNlXCIsIChzb2NrZXQsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvcl9yZXNwb25zZVwiLCBzb2NrZXQsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KFwiZXJyb3JfcmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIub24oXCJub3RpZmljYXRpb25fZXJyb3JcIiwgKHNvY2tldCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm5vdGlmaWNhdGlvbl9lcnJvclwiLCBzb2NrZXQsIGVycm9yKTtcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KFwibm90aWZpY2F0aW9uX2Vycm9yXCIsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbWV0aG9kcygpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm1ldGhvZHM7IH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgY2FsbGJhY2sgQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50ICh3cykuXG4gICAgICovXG4gICAgb3BlbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMud3NzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgd3NgIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndzRW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLndzcyA9IG5ldyB0aGlzLm9wdGlvbnMud3NFbmdpbmUodGhpcy5vcHRpb25zLndzcywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53c3MgPSBuZXcgd3NfMS5TZXJ2ZXIodGhpcy5vcHRpb25zLndzcywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3NzLm9uY2UoXCJsaXN0ZW5pbmdcIiwgZnVuY3Rpb24gX29uTGlzdGVuaW5nV1NTKCkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KFwibGlzdGVuaW5nXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53c3Mub24oXCJjb25uZWN0aW9uXCIsIGZ1bmN0aW9uIF9vbkNvbm5lY3Rpb25XU1Mod3MsIHJlcSkge1xuICAgICAgICAgICAgbGV0IHNvY2tldCA9IG5ldyBTb2NrZXQod3MpO1xuICAgICAgICAgICAgc2VsZi5zb2NrZXRzLnNldChzb2NrZXQuaWQsIHNvY2tldCk7XG4gICAgICAgICAgICB3cy5vbmNlKFwiY2xvc2VcIiwgZnVuY3Rpb24gX29uQ2xvc2VXUygpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LndzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzb2NrZXQucm9vbXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuZGF0YS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNvY2tldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgd3MucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgd3MgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3cy5vbihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gX29uTWVzc2FnZVdTKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tZXNzYWdlSGFuZGxlci5oYW5kbGVNZXNzYWdlKHNvY2tldCwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIF9vbkVycm9ySGFuZGxlTWVzc2FnZShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3cy5vbihcInBvbmdcIiwgZnVuY3Rpb24gX29uUG9uZ1dTKCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5fcG9uZ0F0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5lbWl0KFwiY29ubmVjdGlvblwiLCBzb2NrZXQsIHJlcSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndzcy5vbihcImVycm9yXCIsIGZ1bmN0aW9uIF9vbkVycm9yV1NTKGUpIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcGluZ1RpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fcGluZy5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbnMucGluZ0ludGVydmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgc2VydmVyIGFuZCB0ZXJtaW5hdGVzIGFsbCBzb2NrZXRzLlxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BpbmdUaW1lcik7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0LnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMud3NzLmNsb3NlKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3NzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICBkZWxldGUgdGhpcy53c3M7XG4gICAgICAgIHRoaXMuc29ja2V0cy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGEgbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiZSBpbnZva2VkLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgb2YgdGhlIG1ldGhvZC5cbiAgICAgKi9cbiAgICBicm9hZGNhc3QobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChqc29uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGEgbm90aWZpY2F0aW9uIHRvIHRoZSByb29tLlxuICAgICAqIEBwYXJhbSByb29tIFRoZSBuYW1lIG9mIHRoZSByb29tLlxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiZSBpbnZva2VkLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgb2YgdGhlIG1ldGhvZC5cbiAgICAgKi9cbiAgICBub3RpZnlUbyhyb29tLCBtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQucm9vbXMuaGFzKHJvb20pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyBhIChyYXcpIG1lc3NhZ2UgdG8gdGhlIHJvb20uXG4gICAgICogQHBhcmFtIHJvb20gVGhlIG5hbWUgb2YgdGhlIHJvb20uXG4gICAgICogQHBhcmFtIGRhdGEgKHJhdykgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBzZW5kVG8ocm9vbSwgZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQucm9vbXMuaGFzKHJvb20pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBzb2NrZXRzIGluIHRoZSByb29tLlxuICAgICAqIEBwYXJhbSByb29tIFRoZSBuYW1lIG9mIHRoZSByb29tLlxuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgY29uc3Qgc29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoc29ja2V0LnJvb21zLmhhcyhyb29tKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNvY2tldHMuc2V0KHNvY2tldC5pZCwgc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ja2V0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VydmVyIGlzIG9wZW4gb3Igbm90XG4gICAgICovXG4gICAgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53c3MgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGluZyB0byBhbGwgc29ja2V0cy5cbiAgICAgKi9cbiAgICBfcGluZygpIHtcbiAgICAgICAgY29uc3QgZGVhZGxpbmUgPSB0aGlzLl9sYXN0UGluZ0F0ICsgdGhpcy5vcHRpb25zLnBpbmdUaW1lb3V0O1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQuX3BvbmdBdCA9PT0gLTEgfHwgc29ja2V0Ll9wb25nQXQgPiBkZWFkbGluZSkge1xuICAgICAgICAgICAgICAgIHNvY2tldC50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvY2tldC5fcG9uZ0F0ID0gLTE7XG4gICAgICAgICAgICBpZiAoc29ja2V0LmlzT3BlbigpKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LndzLnBpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0UGluZ0F0ID0gRGF0ZS5ub3coKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTZXJ2ZXI7XG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud3MgPSB3cztcbiAgICAgICAgdGhpcy5pZCA9IHV1aWRfMS52NCgpO1xuICAgICAgICB0aGlzLnJvb21zID0gbmV3IFNldCgpO1xuICAgICAgICAvKiogY3VzdG9tIGRhdGEgc3RvcmUgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcExpa2VfMS5kZWZhdWx0KCk7XG4gICAgICAgIC8qKiAoaW50ZXJuYWwgdXNpbmcgZm9yIGhlYXJ0YmVhdCkgKi9cbiAgICAgICAgdGhpcy5fcG9uZ0F0ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBub3RpZmljYXRpb24gdG8gdGhlIHNvY2tldC5cbiAgICAgKiBAcGFyYW0gbWV0aG9kIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gYmUgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBtZXRob2QuXG4gICAgICovXG4gICAgbm90aWZ5KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIChyYXcpIG1lc3NhZ2UgdG8gdGhlIHNvY2tldC5cbiAgICAgKiBAcGFyYW0gZGF0YSAocmF3KSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBiaW5hcnkgYmluYXJ5IGZsYWcuXG4gICAgICovXG4gICAgc2VuZChkYXRhLCBiaW5hcnkgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEsIHsgYmluYXJ5IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW5zIGEgcm9vbS4gWW91IGNhbiBqb2luIG11bHRpcGxlIHJvb21zLlxuICAgICAqIEBwYXJhbSByb29tIFRoZSBuYW1lIG9mIHRoZSByb29tIHRoYXQgd2Ugd2FudCB0byBqb2luLlxuICAgICAqL1xuICAgIGpvaW5Ubyhyb29tKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb21zLmhhcyhyb29tKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucm9vbXMuYWRkKHJvb20pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgYSByb29tLlxuICAgICAqIEBwYXJhbSByb29tIFRoZSBuYW1lIG9mIHRoZSByb29tIHRvIGxlYXZlLlxuICAgICAqL1xuICAgIGxlYXZlRnJvbShyb29tKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb21zLmhhcyhyb29tKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5yb29tcy5kZWxldGUocm9vbSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyBhbGwgdGhlIHJvb21zIHRoYXQgd2UndmUgam9pbmVkLlxuICAgICAqL1xuICAgIGxlYXZlRnJvbUFsbCgpIHtcbiAgICAgICAgdGhpcy5yb29tcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgICAqIEBwYXJhbSBjb2RlIEEgbnVtZXJpYyB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBiZWluZyBjbG9zZWQuXG4gICAgICogQHBhcmFtIHJlYXNvbiBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nLlxuICAgICAqL1xuICAgIGNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLndzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdGhpcy53cy50ZXJtaW5hdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb25uZWN0aW9uIGlzIG9wZW4gb3Igbm90XG4gICAgICovXG4gICAgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cyAhPT0gdW5kZWZpbmVkICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gd3NfMS5PUEVOO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gTG9uZztcclxuXHJcbi8qKlxyXG4gKiB3YXNtIG9wdGltaXphdGlvbnMsIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxyXG4gKi9cclxudmFyIHdhc20gPSBudWxsO1xyXG5cclxudHJ5IHtcclxuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFcclxuICBdKSksIHt9KS5leHBvcnRzO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgLy8gbm8gd2FzbSBzdXBwb3J0IDooXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICogQGV4cG9ydHMgTG9uZ1xyXG4gKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG59XHJcblxyXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4vLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4vLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuLy9cclxuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4vLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbi8vXHJcbi8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuLyoqXHJcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tSW50ID0gZnJvbUludDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xyXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgIH1cclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuXHJcbiAgICB2YXIgcDtcclxuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XHJcbiAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XHJcbiAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xyXG5cclxuLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4vLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlpFUk8gPSBaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE9ORSA9IGZyb21JbnQoMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVU9ORSA9IFVPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHg3RkZGRkZGRnwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuICcwJztcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxyXG4gICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXHJcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxyXG4gICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmhpZ2gpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuXHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgIHJlcyA9IFpFUk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cclxuICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBVT05FO1xyXG4gICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgIHJlbSA9IHRoaXM7XHJcbiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xyXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XHJcbiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMjRcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgaGkgPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmXHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbMF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1syXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbM10gPDwgMjQsXHJcbiAgICAgICAgYnl0ZXNbNF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbN10gPDwgMjQsXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1s0XSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s3XSxcclxuICAgICAgICBieXRlc1swXSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1szXSxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuIiwidmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgTWFwLnByb3RvdHlwZTtcbnZhciBtYXBTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzTWFwID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNYXAucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBtYXBTaXplID0gaGFzTWFwICYmIG1hcFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBtYXBTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBtYXBTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIG1hcEZvckVhY2ggPSBoYXNNYXAgJiYgTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZTtcbnZhciBzZXRTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzU2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTZXQucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBzZXRTaXplID0gaGFzU2V0ICYmIHNldFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBzZXRTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBzZXRTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIHNldEZvckVhY2ggPSBoYXNTZXQgJiYgU2V0LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrTWFwLnByb3RvdHlwZTtcbnZhciB3ZWFrTWFwSGFzID0gaGFzV2Vha01hcCA/IFdlYWtNYXAucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgaGFzV2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nICYmIFdlYWtTZXQucHJvdG90eXBlO1xudmFyIHdlYWtTZXRIYXMgPSBoYXNXZWFrU2V0ID8gV2Vha1NldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrUmVmID0gdHlwZW9mIFdlYWtSZWYgPT09ICdmdW5jdGlvbicgJiYgV2Vha1JlZi5wcm90b3R5cGU7XG52YXIgd2Vha1JlZkRlcmVmID0gaGFzV2Vha1JlZiA/IFdlYWtSZWYucHJvdG90eXBlLmRlcmVmIDogbnVsbDtcbnZhciBib29sZWFuVmFsdWVPZiA9IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgJG1hdGNoID0gU3RyaW5nLnByb3RvdHlwZS5tYXRjaDtcbnZhciAkc2xpY2UgPSBTdHJpbmcucHJvdG90eXBlLnNsaWNlO1xudmFyICRyZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyICR0b1VwcGVyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2U7XG52YXIgJHRvTG93ZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZTtcbnZhciAkdGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbnZhciAkY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciAkam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xudmFyICRhcnJTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciAkZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGJpZ0ludFZhbHVlT2YgPSB0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nID8gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mIDogbnVsbDtcbnZhciBnT1BTID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBzeW1Ub1N0cmluZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogbnVsbDtcbnZhciBoYXNTaGFtbWVkU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ29iamVjdCc7XG4vLyBpZSwgYGhhcy10b3N0cmluZ3RhZy9zaGFtc1xudmFyIHRvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IGhhc1NoYW1tZWRTeW1ib2xzID8gJ29iamVjdCcgOiAnc3ltYm9sJylcbiAgICA/IFN5bWJvbC50b1N0cmluZ1RhZ1xuICAgIDogbnVsbDtcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgZ1BPID0gKHR5cGVvZiBSZWZsZWN0ID09PSAnZnVuY3Rpb24nID8gUmVmbGVjdC5nZXRQcm90b3R5cGVPZiA6IE9iamVjdC5nZXRQcm90b3R5cGVPZikgfHwgKFxuICAgIFtdLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgPyBmdW5jdGlvbiAoTykge1xuICAgICAgICAgICAgcmV0dXJuIE8uX19wcm90b19fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsXG4pO1xuXG5mdW5jdGlvbiBhZGROdW1lcmljU2VwYXJhdG9yKG51bSwgc3RyKSB7XG4gICAgaWYgKFxuICAgICAgICBudW0gPT09IEluZmluaXR5XG4gICAgICAgIHx8IG51bSA9PT0gLUluZmluaXR5XG4gICAgICAgIHx8IG51bSAhPT0gbnVtXG4gICAgICAgIHx8IChudW0gJiYgbnVtID4gLTEwMDAgJiYgbnVtIDwgMTAwMClcbiAgICAgICAgfHwgJHRlc3QuY2FsbCgvZS8sIHN0cilcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgdmFyIHNlcFJlZ2V4ID0gL1swLTldKD89KD86WzAtOV17M30pKyg/IVswLTldKSkvZztcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGludCA9IG51bSA8IDAgPyAtJGZsb29yKC1udW0pIDogJGZsb29yKG51bSk7IC8vIHRydW5jKG51bSlcbiAgICAgICAgaWYgKGludCAhPT0gbnVtKSB7XG4gICAgICAgICAgICB2YXIgaW50U3RyID0gU3RyaW5nKGludCk7XG4gICAgICAgICAgICB2YXIgZGVjID0gJHNsaWNlLmNhbGwoc3RyLCBpbnRTdHIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChpbnRTdHIsIHNlcFJlZ2V4LCAnJCZfJykgKyAnLicgKyAkcmVwbGFjZS5jYWxsKCRyZXBsYWNlLmNhbGwoZGVjLCAvKFswLTldezN9KS9nLCAnJCZfJyksIC9fJC8sICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChzdHIsIHNlcFJlZ2V4LCAnJCZfJyk7XG59XG5cbnZhciB1dGlsSW5zcGVjdCA9IHJlcXVpcmUoJy4vdXRpbC5pbnNwZWN0Jyk7XG52YXIgaW5zcGVjdEN1c3RvbSA9IHV0aWxJbnNwZWN0LmN1c3RvbTtcbnZhciBpbnNwZWN0U3ltYm9sID0gaXNTeW1ib2woaW5zcGVjdEN1c3RvbSkgPyBpbnNwZWN0Q3VzdG9tIDogbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnNwZWN0XyhvYmosIG9wdGlvbnMsIGRlcHRoLCBzZWVuKSB7XG4gICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpICYmIChvcHRzLnF1b3RlU3R5bGUgIT09ICdzaW5nbGUnICYmIG9wdHMucXVvdGVTdHlsZSAhPT0gJ2RvdWJsZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcInF1b3RlU3R5bGVcIiBtdXN0IGJlIFwic2luZ2xlXCIgb3IgXCJkb3VibGVcIicpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnbWF4U3RyaW5nTGVuZ3RoJykgJiYgKHR5cGVvZiBvcHRzLm1heFN0cmluZ0xlbmd0aCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gb3B0cy5tYXhTdHJpbmdMZW5ndGggPCAwICYmIG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBJbmZpbml0eVxuICAgICAgICAgICAgOiBvcHRzLm1heFN0cmluZ0xlbmd0aCAhPT0gbnVsbFxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm1heFN0cmluZ0xlbmd0aFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIEluZmluaXR5LCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgdmFyIGN1c3RvbUluc3BlY3QgPSBoYXMob3B0cywgJ2N1c3RvbUluc3BlY3QnKSA/IG9wdHMuY3VzdG9tSW5zcGVjdCA6IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0ICE9PSAnYm9vbGVhbicgJiYgY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiY3VzdG9tSW5zcGVjdFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBgdHJ1ZWAsIGBmYWxzZWAsIG9yIGBcXCdzeW1ib2xcXCdgJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ2luZGVudCcpXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSBudWxsXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSAnXFx0J1xuICAgICAgICAmJiAhKHBhcnNlSW50KG9wdHMuaW5kZW50LCAxMCkgPT09IG9wdHMuaW5kZW50ICYmIG9wdHMuaW5kZW50ID4gMClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiaW5kZW50XCIgbXVzdCBiZSBcIlxcXFx0XCIsIGFuIGludGVnZXIgPiAwLCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgaWYgKGhhcyhvcHRzLCAnbnVtZXJpY1NlcGFyYXRvcicpICYmIHR5cGVvZiBvcHRzLm51bWVyaWNTZXBhcmF0b3IgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJudW1lcmljU2VwYXJhdG9yXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCBvciBgZmFsc2VgJyk7XG4gICAgfVxuICAgIHZhciBudW1lcmljU2VwYXJhdG9yID0gb3B0cy5udW1lcmljU2VwYXJhdG9yO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvYmogPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhvYmosIG9wdHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5IC8gb2JqID4gMCA/ICcwJyA6ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhvYmopO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBzdHIpIDogc3RyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFyIGJpZ0ludFN0ciA9IFN0cmluZyhvYmopICsgJ24nO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBiaWdJbnRTdHIpIDogYmlnSW50U3RyO1xuICAgIH1cblxuICAgIHZhciBtYXhEZXB0aCA9IHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDUgOiBvcHRzLmRlcHRoO1xuICAgIGlmICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnKSB7IGRlcHRoID0gMDsgfVxuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDAgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdbQXJyYXldJyA6ICdbT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IGdldEluZGVudChvcHRzLCBkZXB0aCk7XG5cbiAgICBpZiAodHlwZW9mIHNlZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlZW4gPSBbXTtcbiAgICB9IGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHNlZW4gPSAkYXJyU2xpY2UuY2FsbChzZWVuKTtcbiAgICAgICAgICAgIHNlZW4ucHVzaChmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9JbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdPcHRzID0ge1xuICAgICAgICAgICAgICAgIGRlcHRoOiBvcHRzLmRlcHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0cy5xdW90ZVN0eWxlID0gb3B0cy5xdW90ZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBuZXdPcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgb3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNSZWdFeHAob2JqKSkgeyAvLyBpbiBvbGRlciBlbmdpbmVzLCByZWdleGVzIGFyZSBjYWxsYWJsZVxuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPZihvYmopO1xuICAgICAgICB2YXIga2V5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgcmV0dXJuICdbRnVuY3Rpb24nICsgKG5hbWUgPyAnOiAnICsgbmFtZSA6ICcgKGFub255bW91cyknKSArICddJyArIChrZXlzLmxlbmd0aCA+IDAgPyAnIHsgJyArICRqb2luLmNhbGwoa2V5cywgJywgJykgKyAnIH0nIDogJycpO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wob2JqKSkge1xuICAgICAgICB2YXIgc3ltU3RyaW5nID0gaGFzU2hhbW1lZFN5bWJvbHMgPyAkcmVwbGFjZS5jYWxsKFN0cmluZyhvYmopLCAvXihTeW1ib2xcXCguKlxcKSlfW14pXSokLywgJyQxJykgOiBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaGFzU2hhbW1lZFN5bWJvbHMgPyBtYXJrQm94ZWQoc3ltU3RyaW5nKSA6IHN5bVN0cmluZztcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChvYmopKSB7XG4gICAgICAgIHZhciBzID0gJzwnICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpO1xuICAgICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyc1tpXS5uYW1lICsgJz0nICsgd3JhcFF1b3RlcyhxdW90ZShhdHRyc1tpXS52YWx1ZSksICdkb3VibGUnLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcbiAgICAgICAgaWYgKG9iai5jaGlsZE5vZGVzICYmIG9iai5jaGlsZE5vZGVzLmxlbmd0aCkgeyBzICs9ICcuLi4nOyB9XG4gICAgICAgIHMgKz0gJzwvJyArICR0b0xvd2VyQ2FzZS5jYWxsKFN0cmluZyhvYmoubm9kZU5hbWUpKSArICc+JztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbXSc7IH1cbiAgICAgICAgdmFyIHhzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICBpZiAoaW5kZW50ICYmICFzaW5nbGVMaW5lVmFsdWVzKHhzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGluZGVudGVkSm9pbih4cywgaW5kZW50KSArICddJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1sgJyArICRqb2luLmNhbGwoeHMsICcsICcpICsgJyBdJztcbiAgICB9XG4gICAgaWYgKGlzRXJyb3Iob2JqKSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmICghKCdjYXVzZScgaW4gRXJyb3IucHJvdG90eXBlKSAmJiAnY2F1c2UnIGluIG9iaiAmJiAhaXNFbnVtZXJhYmxlLmNhbGwob2JqLCAnY2F1c2UnKSkge1xuICAgICAgICAgICAgcmV0dXJuICd7IFsnICsgU3RyaW5nKG9iaikgKyAnXSAnICsgJGpvaW4uY2FsbCgkY29uY2F0LmNhbGwoJ1tjYXVzZV06ICcgKyBpbnNwZWN0KG9iai5jYXVzZSksIHBhcnRzKSwgJywgJykgKyAnIH0nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbJyArIFN0cmluZyhvYmopICsgJ10nOyB9XG4gICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArICRqb2luLmNhbGwocGFydHMsICcsICcpICsgJyB9JztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGN1c3RvbUluc3BlY3QpIHtcbiAgICAgICAgaWYgKGluc3BlY3RTeW1ib2wgJiYgdHlwZW9mIG9ialtpbnNwZWN0U3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJyAmJiB1dGlsSW5zcGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxJbnNwZWN0KG9iaiwgeyBkZXB0aDogbWF4RGVwdGggLSBkZXB0aCB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJyAmJiB0eXBlb2Ygb2JqLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouaW5zcGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc01hcChvYmopKSB7XG4gICAgICAgIHZhciBtYXBQYXJ0cyA9IFtdO1xuICAgICAgICBtYXBGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgbWFwUGFydHMucHVzaChpbnNwZWN0KGtleSwgb2JqLCB0cnVlKSArICcgPT4gJyArIGluc3BlY3QodmFsdWUsIG9iaikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25PZignTWFwJywgbWFwU2l6ZS5jYWxsKG9iaiksIG1hcFBhcnRzLCBpbmRlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNTZXQob2JqKSkge1xuICAgICAgICB2YXIgc2V0UGFydHMgPSBbXTtcbiAgICAgICAgc2V0Rm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRQYXJ0cy5wdXNoKGluc3BlY3QodmFsdWUsIG9iaikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25PZignU2V0Jywgc2V0U2l6ZS5jYWxsKG9iaiksIHNldFBhcnRzLCBpbmRlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrTWFwKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtNYXAnKTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha1NldChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrU2V0Jyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1JlZicpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoTnVtYmVyKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnSW50KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KGJpZ0ludFZhbHVlT2YuY2FsbChvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4ob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGJvb2xlYW5WYWx1ZU9mLmNhbGwob2JqKSk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChTdHJpbmcob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoIWlzRGF0ZShvYmopICYmICFpc1JlZ0V4cChvYmopKSB7XG4gICAgICAgIHZhciB5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgdmFyIGlzUGxhaW5PYmplY3QgPSBnUE8gPyBnUE8ob2JqKSA9PT0gT2JqZWN0LnByb3RvdHlwZSA6IG9iaiBpbnN0YW5jZW9mIE9iamVjdCB8fCBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICAgICAgdmFyIHByb3RvVGFnID0gb2JqIGluc3RhbmNlb2YgT2JqZWN0ID8gJycgOiAnbnVsbCBwcm90b3R5cGUnO1xuICAgICAgICB2YXIgc3RyaW5nVGFnID0gIWlzUGxhaW5PYmplY3QgJiYgdG9TdHJpbmdUYWcgJiYgT2JqZWN0KG9iaikgPT09IG9iaiAmJiB0b1N0cmluZ1RhZyBpbiBvYmogPyAkc2xpY2UuY2FsbCh0b1N0cihvYmopLCA4LCAtMSkgOiBwcm90b1RhZyA/ICdPYmplY3QnIDogJyc7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvclRhZyA9IGlzUGxhaW5PYmplY3QgfHwgdHlwZW9mIG9iai5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJyA/ICcnIDogb2JqLmNvbnN0cnVjdG9yLm5hbWUgPyBvYmouY29uc3RydWN0b3IubmFtZSArICcgJyA6ICcnO1xuICAgICAgICB2YXIgdGFnID0gY29uc3RydWN0b3JUYWcgKyAoc3RyaW5nVGFnIHx8IHByb3RvVGFnID8gJ1snICsgJGpvaW4uY2FsbCgkY29uY2F0LmNhbGwoW10sIHN0cmluZ1RhZyB8fCBbXSwgcHJvdG9UYWcgfHwgW10pLCAnOiAnKSArICddICcgOiAnJyk7XG4gICAgICAgIGlmICh5cy5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRhZyArICd7fSc7IH1cbiAgICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZyArICd7JyArIGluZGVudGVkSm9pbih5cywgaW5kZW50KSArICd9JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnICsgJ3sgJyArICRqb2luLmNhbGwoeXMsICcsICcpICsgJyB9JztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhvYmopO1xufTtcblxuZnVuY3Rpb24gd3JhcFF1b3RlcyhzLCBkZWZhdWx0U3R5bGUsIG9wdHMpIHtcbiAgICB2YXIgcXVvdGVDaGFyID0gKG9wdHMucXVvdGVTdHlsZSB8fCBkZWZhdWx0U3R5bGUpID09PSAnZG91YmxlJyA/ICdcIicgOiBcIidcIjtcbiAgICByZXR1cm4gcXVvdGVDaGFyICsgcyArIHF1b3RlQ2hhcjtcbn1cblxuZnVuY3Rpb24gcXVvdGUocykge1xuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKFN0cmluZyhzKSwgL1wiL2csICcmcXVvdDsnKTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBEYXRlXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNFcnJvcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEVycm9yXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cblxuLy8gU3ltYm9sIGFuZCBCaWdJbnQgZG8gaGF2ZSBTeW1ib2wudG9TdHJpbmdUYWcgYnkgc3BlYywgc28gdGhhdCBjYW4ndCBiZSB1c2VkIHRvIGVsaW1pbmF0ZSBmYWxzZSBwb3NpdGl2ZXNcbmZ1bmN0aW9uIGlzU3ltYm9sKG9iaikge1xuICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scykge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiBpbnN0YW5jZW9mIFN5bWJvbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCAhc3ltVG9TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0JpZ0ludChvYmopIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCAhYmlnSW50VmFsdWVPZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGJpZ0ludFZhbHVlT2YuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5IGluIHRoaXM7IH07XG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufVxuXG5mdW5jdGlvbiB0b1N0cihvYmopIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBuYW1lT2YoZikge1xuICAgIGlmIChmLm5hbWUpIHsgcmV0dXJuIGYubmFtZTsgfVxuICAgIHZhciBtID0gJG1hdGNoLmNhbGwoZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGYpLCAvXmZ1bmN0aW9uXFxzKihbXFx3JF0rKS8pO1xuICAgIGlmIChtKSB7IHJldHVybiBtWzFdOyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgeyByZXR1cm4geHMuaW5kZXhPZih4KTsgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0geCkgeyByZXR1cm4gaTsgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzTWFwKHgpIHtcbiAgICBpZiAoIW1hcFNpemUgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0U2l6ZS5jYWxsKHgpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIE1hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha01hcCh4KSB7XG4gICAgaWYgKCF3ZWFrTWFwSGFzIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtNYXBIYXMuY2FsbCh4LCB3ZWFrTWFwSGFzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdlYWtTZXRIYXMuY2FsbCh4LCB3ZWFrU2V0SGFzKTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXZWFrTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrUmVmKHgpIHtcbiAgICBpZiAoIXdlYWtSZWZEZXJlZiB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrUmVmRGVyZWYuY2FsbCh4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU2V0KHgpIHtcbiAgICBpZiAoIXNldFNpemUgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc2V0U2l6ZS5jYWxsKHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xuICAgICAgICB9IGNhdGNoIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFNldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha1NldCh4KSB7XG4gICAgaWYgKCF3ZWFrU2V0SGFzIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtTZXRIYXMuY2FsbCh4LCB3ZWFrU2V0SGFzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdlYWtNYXBIYXMuY2FsbCh4LCB3ZWFrTWFwSGFzKTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXZWFrU2V0OyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50KHgpIHtcbiAgICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB4Lm5vZGVOYW1lID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgeC5nZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RTdHJpbmcoc3RyLCBvcHRzKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPiBvcHRzLm1heFN0cmluZ0xlbmd0aCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gc3RyLmxlbmd0aCAtIG9wdHMubWF4U3RyaW5nTGVuZ3RoO1xuICAgICAgICB2YXIgdHJhaWxlciA9ICcuLi4gJyArIHJlbWFpbmluZyArICcgbW9yZSBjaGFyYWN0ZXInICsgKHJlbWFpbmluZyA+IDEgPyAncycgOiAnJyk7XG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKCRzbGljZS5jYWxsKHN0ciwgMCwgb3B0cy5tYXhTdHJpbmdMZW5ndGgpLCBvcHRzKSArIHRyYWlsZXI7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgdmFyIHMgPSAkcmVwbGFjZS5jYWxsKCRyZXBsYWNlLmNhbGwoc3RyLCAvKFsnXFxcXF0pL2csICdcXFxcJDEnKSwgL1tcXHgwMC1cXHgxZl0vZywgbG93Ynl0ZSk7XG4gICAgcmV0dXJuIHdyYXBRdW90ZXMocywgJ3NpbmdsZScsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBsb3dieXRlKGMpIHtcbiAgICB2YXIgbiA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgeCA9IHtcbiAgICAgICAgODogJ2InLFxuICAgICAgICA5OiAndCcsXG4gICAgICAgIDEwOiAnbicsXG4gICAgICAgIDEyOiAnZicsXG4gICAgICAgIDEzOiAncidcbiAgICB9W25dO1xuICAgIGlmICh4KSB7IHJldHVybiAnXFxcXCcgKyB4OyB9XG4gICAgcmV0dXJuICdcXFxceCcgKyAobiA8IDB4MTAgPyAnMCcgOiAnJykgKyAkdG9VcHBlckNhc2UuY2FsbChuLnRvU3RyaW5nKDE2KSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtCb3hlZChzdHIpIHtcbiAgICByZXR1cm4gJ09iamVjdCgnICsgc3RyICsgJyknO1xufVxuXG5mdW5jdGlvbiB3ZWFrQ29sbGVjdGlvbk9mKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSArICcgeyA/IH0nO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uT2YodHlwZSwgc2l6ZSwgZW50cmllcywgaW5kZW50KSB7XG4gICAgdmFyIGpvaW5lZEVudHJpZXMgPSBpbmRlbnQgPyBpbmRlbnRlZEpvaW4oZW50cmllcywgaW5kZW50KSA6ICRqb2luLmNhbGwoZW50cmllcywgJywgJyk7XG4gICAgcmV0dXJuIHR5cGUgKyAnICgnICsgc2l6ZSArICcpIHsnICsgam9pbmVkRW50cmllcyArICd9Jztcbn1cblxuZnVuY3Rpb24gc2luZ2xlTGluZVZhbHVlcyh4cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluZGV4T2YoeHNbaV0sICdcXG4nKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEluZGVudChvcHRzLCBkZXB0aCkge1xuICAgIHZhciBiYXNlSW5kZW50O1xuICAgIGlmIChvcHRzLmluZGVudCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgYmFzZUluZGVudCA9ICdcXHQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuaW5kZW50ID09PSAnbnVtYmVyJyAmJiBvcHRzLmluZGVudCA+IDApIHtcbiAgICAgICAgYmFzZUluZGVudCA9ICRqb2luLmNhbGwoQXJyYXkob3B0cy5pbmRlbnQgKyAxKSwgJyAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZTogYmFzZUluZGVudCxcbiAgICAgICAgcHJldjogJGpvaW4uY2FsbChBcnJheShkZXB0aCArIDEpLCBiYXNlSW5kZW50KVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGluZGVudGVkSm9pbih4cywgaW5kZW50KSB7XG4gICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJyc7IH1cbiAgICB2YXIgbGluZUpvaW5lciA9ICdcXG4nICsgaW5kZW50LnByZXYgKyBpbmRlbnQuYmFzZTtcbiAgICByZXR1cm4gbGluZUpvaW5lciArICRqb2luLmNhbGwoeHMsICcsJyArIGxpbmVKb2luZXIpICsgJ1xcbicgKyBpbmRlbnQucHJldjtcbn1cblxuZnVuY3Rpb24gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iaik7XG4gICAgdmFyIHhzID0gW107XG4gICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHhzLmxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4c1tpXSA9IGhhcyhvYmosIGkpID8gaW5zcGVjdChvYmpbaV0sIG9iaikgOiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3ltcyA9IHR5cGVvZiBnT1BTID09PSAnZnVuY3Rpb24nID8gZ09QUyhvYmopIDogW107XG4gICAgdmFyIHN5bU1hcDtcbiAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMpIHtcbiAgICAgICAgc3ltTWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3ltcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgc3ltTWFwWyckJyArIHN5bXNba11dID0gc3ltc1trXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBpZiAoIWhhcyhvYmosIGtleSkpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgaWYgKGlzQXJyICYmIFN0cmluZyhOdW1iZXIoa2V5KSkgPT09IGtleSAmJiBrZXkgPCBvYmoubGVuZ3RoKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scyAmJiBzeW1NYXBbJyQnICsga2V5XSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBwcmV2ZW50IHNoYW1tZWQgU3ltYm9scywgd2hpY2ggYXJlIHN0b3JlZCBhcyBzdHJpbmdzLCBmcm9tIGJlaW5nIGluY2x1ZGVkIGluIHRoZSBzdHJpbmcga2V5IHNlY3Rpb25cbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKCR0ZXN0LmNhbGwoL1teXFx3JF0vLCBrZXkpKSB7XG4gICAgICAgICAgICB4cy5wdXNoKGluc3BlY3Qoa2V5LCBvYmopICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeHMucHVzaChrZXkgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnT1BTID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ltcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltc1tqXSkpIHtcbiAgICAgICAgICAgICAgICB4cy5wdXNoKCdbJyArIGluc3BlY3Qoc3ltc1tqXSkgKyAnXTogJyArIGluc3BlY3Qob2JqW3N5bXNbal1dLCBvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geHM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyIHBlcmNlbnRUd2VudGllcyA9IC8lMjAvZztcblxudmFyIEZvcm1hdCA9IHtcbiAgICBSRkMxNzM4OiAnUkZDMTczOCcsXG4gICAgUkZDMzk4NjogJ1JGQzM5ODYnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6IEZvcm1hdC5SRkMzOTg2LFxuICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgUkZDMTczODogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZS5jYWxsKHZhbHVlLCBwZXJjZW50VHdlbnRpZXMsICcrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJGQzM5ODY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFJGQzE3Mzg6IEZvcm1hdC5SRkMxNzM4LFxuICAgIFJGQzM5ODY6IEZvcm1hdC5SRkMzOTg2XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd1Byb3RvdHlwZXM6IGZhbHNlLFxuICAgIGFsbG93U3BhcnNlOiBmYWxzZSxcbiAgICBhcnJheUxpbWl0OiAyMCxcbiAgICBjaGFyc2V0OiAndXRmLTgnLFxuICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG4gICAgY29tbWE6IGZhbHNlLFxuICAgIGRlY29kZXI6IHV0aWxzLmRlY29kZSxcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBkZXB0aDogNSxcbiAgICBpZ25vcmVRdWVyeVByZWZpeDogZmFsc2UsXG4gICAgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzOiBmYWxzZSxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMCxcbiAgICBwYXJzZUFycmF5czogdHJ1ZSxcbiAgICBwbGFpbk9iamVjdHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBpbnRlcnByZXROdW1lcmljRW50aXRpZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIyhcXGQrKTsvZywgZnVuY3Rpb24gKCQwLCBudW1iZXJTdHIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobnVtYmVyU3RyLCAxMCkpO1xuICAgIH0pO1xufTtcblxudmFyIHBhcnNlQXJyYXlWYWx1ZSA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuY29tbWEgJiYgdmFsLmluZGV4T2YoJywnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB2YWwuc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyB3aGF0IGJyb3dzZXJzIHdpbGwgc3VibWl0IHdoZW4gdGhlIOKckyBjaGFyYWN0ZXIgb2NjdXJzIGluIGFuXG4vLyBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgYm9keSBhbmQgdGhlIGVuY29kaW5nIG9mIHRoZSBwYWdlIGNvbnRhaW5pbmdcbi8vIHRoZSBmb3JtIGlzIGlzby04ODU5LTEsIG9yIHdoZW4gdGhlIHN1Ym1pdHRlZCBmb3JtIGhhcyBhbiBhY2NlcHQtY2hhcnNldFxuLy8gYXR0cmlidXRlIG9mIGlzby04ODU5LTEuIFByZXN1bWFibHkgYWxzbyB3aXRoIG90aGVyIGNoYXJzZXRzIHRoYXQgZG8gbm90IGNvbnRhaW5cbi8vIHRoZSDinJMgY2hhcmFjdGVyLCBzdWNoIGFzIHVzLWFzY2lpLlxudmFyIGlzb1NlbnRpbmVsID0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0InOyAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JylcblxuLy8gVGhlc2UgYXJlIHRoZSBwZXJjZW50LWVuY29kZWQgdXRmLTggb2N0ZXRzIHJlcHJlc2VudGluZyBhIGNoZWNrbWFyaywgaW5kaWNhdGluZyB0aGF0IHRoZSByZXF1ZXN0IGFjdHVhbGx5IGlzIHV0Zi04IGVuY29kZWQuXG52YXIgY2hhcnNldFNlbnRpbmVsID0gJ3V0Zjg9JUUyJTlDJTkzJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuXG52YXIgcGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nVmFsdWVzKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgY2xlYW5TdHIgPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID8gc3RyLnJlcGxhY2UoL15cXD8vLCAnJykgOiBzdHI7XG4gICAgdmFyIGxpbWl0ID0gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0O1xuICAgIHZhciBwYXJ0cyA9IGNsZWFuU3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBsaW1pdCk7XG4gICAgdmFyIHNraXBJbmRleCA9IC0xOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXJlIHRoZSB1dGY4IHNlbnRpbmVsIHdhcyBmb3VuZFxuICAgIHZhciBpO1xuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQ7XG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJ3V0Zjg9JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gPT09IGNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ3V0Zi04JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldID09PSBpc29TZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ2lzby04ODU5LTEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGkgPSBwYXJ0cy5sZW5ndGg7IC8vIFRoZSBlc2xpbnQgc2V0dGluZ3MgZG8gbm90IGFsbG93IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpID09PSBza2lwSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG4gICAgICAgIHZhciBwb3MgPSBicmFja2V0RXF1YWxzUG9zID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogYnJhY2tldEVxdWFsc1BvcyArIDE7XG5cbiAgICAgICAgdmFyIGtleSwgdmFsO1xuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQsIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID8gbnVsbCA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UoMCwgcG9zKSwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuICAgICAgICAgICAgdmFsID0gdXRpbHMubWF5YmVNYXAoXG4gICAgICAgICAgICAgICAgcGFyc2VBcnJheVZhbHVlKHBhcnQuc2xpY2UocG9zICsgMSksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbmNvZGVkVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlY29kZXIoZW5jb2RlZFZhbCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgJiYgb3B0aW9ucy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgJiYgY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICB2YWwgPSBpbnRlcnByZXROdW1lcmljRW50aXRpZXModmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0LmluZGV4T2YoJ1tdPScpID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IGlzQXJyYXkodmFsKSA/IFt2YWxdIDogdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1dGlscy5jb21iaW5lKG9ialtrZXldLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIHZhciBsZWFmID0gdmFsdWVzUGFyc2VkID8gdmFsIDogcGFyc2VBcnJheVZhbHVlKHZhbCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJyAmJiBvcHRpb25zLnBhcnNlQXJyYXlzKSB7XG4gICAgICAgICAgICBvYmogPSBbXS5jb25jYXQobGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBhcnNlQXJyYXlzICYmIGNsZWFuUm9vdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB7IDA6IGxlYWYgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgICAgICYmIHJvb3QgIT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIFN0cmluZyhpbmRleCkgPT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIGluZGV4ID49IDBcbiAgICAgICAgICAgICAgICAmJiAob3B0aW9ucy5wYXJzZUFycmF5cyAmJiBpbmRleCA8PSBvcHRpb25zLmFycmF5TGltaXQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgICAgICBvYmpbaW5kZXhdID0gbGVhZjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xlYW5Sb290ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gbGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWYgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYWY7XG59O1xuXG52YXIgcGFyc2VLZXlzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ0tleXMoZ2l2ZW5LZXksIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKSB7XG4gICAgaWYgKCFnaXZlbktleSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhbnNmb3JtIGRvdCBub3RhdGlvbiB0byBicmFja2V0IG5vdGF0aW9uXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuYWxsb3dEb3RzID8gZ2l2ZW5LZXkucmVwbGFjZSgvXFwuKFteLltdKykvZywgJ1skMV0nKSA6IGdpdmVuS2V5O1xuXG4gICAgLy8gVGhlIHJlZ2V4IGNodW5rc1xuXG4gICAgdmFyIGJyYWNrZXRzID0gLyhcXFtbXltcXF1dKl0pLztcbiAgICB2YXIgY2hpbGQgPSAvKFxcW1teW1xcXV0qXSkvZztcblxuICAgIC8vIEdldCB0aGUgcGFyZW50XG5cbiAgICB2YXIgc2VnbWVudCA9IG9wdGlvbnMuZGVwdGggPiAwICYmIGJyYWNrZXRzLmV4ZWMoa2V5KTtcbiAgICB2YXIgcGFyZW50ID0gc2VnbWVudCA/IGtleS5zbGljZSgwLCBzZWdtZW50LmluZGV4KSA6IGtleTtcblxuICAgIC8vIFN0YXNoIHRoZSBwYXJlbnQgaWYgaXQgZXhpc3RzXG5cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIHBsYWluIG9iamVjdHMsIG9wdGlvbmFsbHkgcHJlZml4IGtleXMgdGhhdCB3b3VsZCBvdmVyd3JpdGUgb2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgcGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMucHVzaChwYXJlbnQpO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBjaGlsZHJlbiBhcHBlbmRpbmcgdG8gdGhlIGFycmF5IHVudGlsIHdlIGhpdCBkZXB0aFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChvcHRpb25zLmRlcHRoID4gMCAmJiAoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNlZ21lbnRbMV0uc2xpY2UoMSwgLTEpKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goc2VnbWVudFsxXSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHJlbWFpbmRlciwganVzdCBhZGQgd2hhdGV2ZXIgaXMgbGVmdFxuXG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAga2V5cy5wdXNoKCdbJyArIGtleS5zbGljZShzZWdtZW50LmluZGV4KSArICddJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KGtleXMsIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKTtcbn07XG5cbnZhciBub3JtYWxpemVQYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZGVjb2RlciAhPT0gbnVsbCAmJiBvcHRzLmRlY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0cy5kZWNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmNoYXJzZXQgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuY2hhcnNldCAhPT0gJ3V0Zi04JyAmJiBvcHRzLmNoYXJzZXQgIT09ICdpc28tODg1OS0xJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICB2YXIgY2hhcnNldCA9IHR5cGVvZiBvcHRzLmNoYXJzZXQgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuY2hhcnNldCA6IG9wdHMuY2hhcnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXG4gICAgICAgIGFsbG93UHJvdG90eXBlczogdHlwZW9mIG9wdHMuYWxsb3dQcm90b3R5cGVzID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93UHJvdG90eXBlcyA6IGRlZmF1bHRzLmFsbG93UHJvdG90eXBlcyxcbiAgICAgICAgYWxsb3dTcGFyc2U6IHR5cGVvZiBvcHRzLmFsbG93U3BhcnNlID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93U3BhcnNlIDogZGVmYXVsdHMuYWxsb3dTcGFyc2UsXG4gICAgICAgIGFycmF5TGltaXQ6IHR5cGVvZiBvcHRzLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0cy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdCxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBjb21tYTogdHlwZW9mIG9wdHMuY29tbWEgPT09ICdib29sZWFuJyA/IG9wdHMuY29tbWEgOiBkZWZhdWx0cy5jb21tYSxcbiAgICAgICAgZGVjb2RlcjogdHlwZW9mIG9wdHMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXIsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRzLmRlbGltaXRlcikgPyBvcHRzLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcixcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uLCBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgZGVwdGg6ICh0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ251bWJlcicgfHwgb3B0cy5kZXB0aCA9PT0gZmFsc2UpID8gK29wdHMuZGVwdGggOiBkZWZhdWx0cy5kZXB0aCxcbiAgICAgICAgaWdub3JlUXVlcnlQcmVmaXg6IG9wdHMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWUsXG4gICAgICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogdHlwZW9mIG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID09PSAnYm9vbGVhbicgPyBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA6IGRlZmF1bHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyxcbiAgICAgICAgcGFyYW1ldGVyTGltaXQ6IHR5cGVvZiBvcHRzLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdCxcbiAgICAgICAgcGFyc2VBcnJheXM6IG9wdHMucGFyc2VBcnJheXMgIT09IGZhbHNlLFxuICAgICAgICBwbGFpbk9iamVjdHM6IHR5cGVvZiBvcHRzLnBsYWluT2JqZWN0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5wbGFpbk9iamVjdHMgOiBkZWZhdWx0cy5wbGFpbk9iamVjdHMsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKTtcblxuICAgIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBwYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMsIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbG93U3BhcnNlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLmNvbXBhY3Qob2JqKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRTaWRlQ2hhbm5lbCA9IHJlcXVpcmUoJ3NpZGUtY2hhbm5lbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgfSxcbiAgICBjb21tYTogJ2NvbW1hJyxcbiAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKHByZWZpeCwga2V5KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSxcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdChwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgc3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0O1xudmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbnZhciBwdXNoVG9BcnJheSA9IGZ1bmN0aW9uIChhcnIsIHZhbHVlT3JBcnJheSkge1xuICAgIHB1c2guYXBwbHkoYXJyLCBpc0FycmF5KHZhbHVlT3JBcnJheSkgPyB2YWx1ZU9yQXJyYXkgOiBbdmFsdWVPckFycmF5XSk7XG59O1xuXG52YXIgdG9JU08gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGRlZmF1bHRGb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWRkUXVlcnlQcmVmaXg6IGZhbHNlLFxuICAgIGFsbG93RG90czogZmFsc2UsXG4gICAgY2hhcnNldDogJ3V0Zi04JyxcbiAgICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGVuY29kZTogdHJ1ZSxcbiAgICBlbmNvZGVyOiB1dGlscy5lbmNvZGUsXG4gICAgZW5jb2RlVmFsdWVzT25seTogZmFsc2UsXG4gICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0LFxuICAgIGZvcm1hdHRlcjogZm9ybWF0cy5mb3JtYXR0ZXJzW2RlZmF1bHRGb3JtYXRdLFxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBpbmRpY2VzOiBmYWxzZSxcbiAgICBzZXJpYWxpemVEYXRlOiBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoZGF0ZSk7XG4gICAgfSxcbiAgICBza2lwTnVsbHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBpc05vbk51bGxpc2hQcmltaXRpdmUgPSBmdW5jdGlvbiBpc05vbk51bGxpc2hQcmltaXRpdmUodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZydcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYm9vbGVhbidcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdzeW1ib2wnXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYmlnaW50Jztcbn07XG5cbnZhciBzZW50aW5lbCA9IHt9O1xuXG52YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KFxuICAgIG9iamVjdCxcbiAgICBwcmVmaXgsXG4gICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICBjb21tYVJvdW5kVHJpcCxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgc2tpcE51bGxzLFxuICAgIGVuY29kZXIsXG4gICAgZmlsdGVyLFxuICAgIHNvcnQsXG4gICAgYWxsb3dEb3RzLFxuICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgZm9ybWF0LFxuICAgIGZvcm1hdHRlcixcbiAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgIGNoYXJzZXQsXG4gICAgc2lkZUNoYW5uZWxcbikge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG5cbiAgICB2YXIgdG1wU2MgPSBzaWRlQ2hhbm5lbDtcbiAgICB2YXIgc3RlcCA9IDA7XG4gICAgdmFyIGZpbmRGbGFnID0gZmFsc2U7XG4gICAgd2hpbGUgKCh0bXBTYyA9IHRtcFNjLmdldChzZW50aW5lbCkpICE9PSB2b2lkIHVuZGVmaW5lZCAmJiAhZmluZEZsYWcpIHtcbiAgICAgICAgLy8gV2hlcmUgb2JqZWN0IGxhc3QgYXBwZWFyZWQgaW4gdGhlIHJlZiB0cmVlXG4gICAgICAgIHZhciBwb3MgPSB0bXBTYy5nZXQob2JqZWN0KTtcbiAgICAgICAgc3RlcCArPSAxO1xuICAgICAgICBpZiAodHlwZW9mIHBvcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT09IHN0ZXApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ3ljbGljIG9iamVjdCB2YWx1ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5kRmxhZyA9IHRydWU7IC8vIEJyZWFrIHdoaWxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0bXBTYy5nZXQoc2VudGluZWwpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3RlcCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmogPSBmaWx0ZXIocHJlZml4LCBvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvYmogPSBzZXJpYWxpemVEYXRlKG9iaik7XG4gICAgfSBlbHNlIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzQXJyYXkob2JqKSkge1xuICAgICAgICBvYmogPSB1dGlscy5tYXliZU1hcChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc3RyaWN0TnVsbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlciAmJiAhZW5jb2RlVmFsdWVzT25seSA/IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KSA6IHByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9ICcnO1xuICAgIH1cblxuICAgIGlmIChpc05vbk51bGxpc2hQcmltaXRpdmUob2JqKSB8fCB1dGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknLCBmb3JtYXQpO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgZW5jb2RlVmFsdWVzT25seSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXNBcnJheSA9IHNwbGl0LmNhbGwoU3RyaW5nKG9iaiksICcsJyk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlc0pvaW5lZCA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzSm9pbmVkICs9IChpID09PSAwID8gJycgOiAnLCcpICsgZm9ybWF0dGVyKGVuY29kZXIodmFsdWVzQXJyYXlbaV0sIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICd2YWx1ZScsIGZvcm1hdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAoY29tbWFSb3VuZFRyaXAgJiYgaXNBcnJheShvYmopICYmIHZhbHVlc0FycmF5Lmxlbmd0aCA9PT0gMSA/ICdbXScgOiAnJykgKyAnPScgKyB2YWx1ZXNKb2luZWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIoa2V5VmFsdWUpICsgJz0nICsgZm9ybWF0dGVyKGVuY29kZXIob2JqLCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAndmFsdWUnLCBmb3JtYXQpKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIocHJlZml4KSArICc9JyArIGZvcm1hdHRlcihTdHJpbmcob2JqKSldO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIHZhciBvYmpLZXlzO1xuICAgIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzQXJyYXkob2JqKSkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGpvaW4gZWxlbWVudHMgaW5cbiAgICAgICAgb2JqS2V5cyA9IFt7IHZhbHVlOiBvYmoubGVuZ3RoID4gMCA/IG9iai5qb2luKCcsJykgfHwgbnVsbCA6IHZvaWQgdW5kZWZpbmVkIH1dO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBvYmpLZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG4gICAgfVxuXG4gICAgdmFyIGFkanVzdGVkUHJlZml4ID0gY29tbWFSb3VuZFRyaXAgJiYgaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDEgPyBwcmVmaXggKyAnW10nIDogcHJlZml4O1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmpLZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2pdO1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5LnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGtleS52YWx1ZSA6IG9ialtrZXldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleVByZWZpeCA9IGlzQXJyYXkob2JqKVxuICAgICAgICAgICAgPyB0eXBlb2YgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2Z1bmN0aW9uJyA/IGdlbmVyYXRlQXJyYXlQcmVmaXgoYWRqdXN0ZWRQcmVmaXgsIGtleSkgOiBhZGp1c3RlZFByZWZpeFxuICAgICAgICAgICAgOiBhZGp1c3RlZFByZWZpeCArIChhbGxvd0RvdHMgPyAnLicgKyBrZXkgOiAnWycgKyBrZXkgKyAnXScpO1xuXG4gICAgICAgIHNpZGVDaGFubmVsLnNldChvYmplY3QsIHN0ZXApO1xuICAgICAgICB2YXIgdmFsdWVTaWRlQ2hhbm5lbCA9IGdldFNpZGVDaGFubmVsKCk7XG4gICAgICAgIHZhbHVlU2lkZUNoYW5uZWwuc2V0KHNlbnRpbmVsLCBzaWRlQ2hhbm5lbCk7XG4gICAgICAgIHB1c2hUb0FycmF5KHZhbHVlcywgc3RyaW5naWZ5KFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBrZXlQcmVmaXgsXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgY29tbWFSb3VuZFRyaXAsXG4gICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICBlbmNvZGVyLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgY2hhcnNldCxcbiAgICAgICAgICAgIHZhbHVlU2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbnZhciBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5lbmNvZGVyICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcnNldCA9IG9wdHMuY2hhcnNldCB8fCBkZWZhdWx0cy5jaGFyc2V0O1xuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5mb3JtYXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghaGFzLmNhbGwoZm9ybWF0cy5mb3JtYXR0ZXJzLCBvcHRzLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBvcHRzLmZvcm1hdDtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgdmFyIGZpbHRlciA9IGRlZmF1bHRzLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIG9wdHMuZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGlzQXJyYXkob3B0cy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdHMuZmlsdGVyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZFF1ZXJ5UHJlZml4OiB0eXBlb2Ygb3B0cy5hZGRRdWVyeVByZWZpeCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hZGRRdWVyeVByZWZpeCA6IGRlZmF1bHRzLmFkZFF1ZXJ5UHJlZml4LFxuICAgICAgICBhbGxvd0RvdHM6IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzLFxuICAgICAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgICAgICBjaGFyc2V0U2VudGluZWw6IHR5cGVvZiBvcHRzLmNoYXJzZXRTZW50aW5lbCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaGFyc2V0U2VudGluZWwgOiBkZWZhdWx0cy5jaGFyc2V0U2VudGluZWwsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmRlbGltaXRlciA6IG9wdHMuZGVsaW1pdGVyLFxuICAgICAgICBlbmNvZGU6IHR5cGVvZiBvcHRzLmVuY29kZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGUgOiBkZWZhdWx0cy5lbmNvZGUsXG4gICAgICAgIGVuY29kZXI6IHR5cGVvZiBvcHRzLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyLFxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5OiB0eXBlb2Ygb3B0cy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICAgICAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgc2tpcE51bGxzOiB0eXBlb2Ygb3B0cy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdHMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzLFxuICAgICAgICBzb3J0OiB0eXBlb2Ygb3B0cy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0cy5zb3J0IDogbnVsbCxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpO1xuXG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5hcnJheUZvcm1hdCBpbiBhcnJheVByZWZpeEdlbmVyYXRvcnMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmFycmF5Rm9ybWF0O1xuICAgIH0gZWxzZSBpZiAob3B0cyAmJiAnaW5kaWNlcycgaW4gb3B0cykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdHMuaW5kaWNlcyA/ICdpbmRpY2VzJyA6ICdyZXBlYXQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gJ2luZGljZXMnO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZUFycmF5UHJlZml4ID0gYXJyYXlQcmVmaXhHZW5lcmF0b3JzW2FycmF5Rm9ybWF0XTtcbiAgICBpZiAob3B0cyAmJiAnY29tbWFSb3VuZFRyaXAnIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMuY29tbWFSb3VuZFRyaXAgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgY29tbWFSb3VuZFRyaXBgIG11c3QgYmUgYSBib29sZWFuLCBvciBhYnNlbnQnKTtcbiAgICB9XG4gICAgdmFyIGNvbW1hUm91bmRUcmlwID0gZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBvcHRzICYmIG9wdHMuY29tbWFSb3VuZFRyaXA7XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5za2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hUb0FycmF5KGtleXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBvcHRpb25zLnNraXBOdWxscyxcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jb2RlID8gb3B0aW9ucy5lbmNvZGVyIDogbnVsbCxcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5zb3J0LFxuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd0RvdHMsXG4gICAgICAgICAgICBvcHRpb25zLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBvcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgb3B0aW9ucy5jaGFyc2V0LFxuICAgICAgICAgICAgc2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMuYWRkUXVlcnlQcmVmaXggPT09IHRydWUgPyAnPycgOiAnJztcblxuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKSwgdGhlIFwibnVtZXJpYyBlbnRpdHlcIiByZXByZXNlbnRhdGlvbiBvZiBhIGNoZWNrbWFya1xuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG4gICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JUUyJTlDJTkzJic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgaGV4VGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgYXJyYXkucHVzaCgnJScgKyAoKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpKS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59KCkpO1xuXG52YXIgY29tcGFjdFF1ZXVlID0gZnVuY3Rpb24gY29tcGFjdFF1ZXVlKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBhcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gYXJyYXlUb09iamVjdChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucyAmJiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgIC8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogMCAqL1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgJiYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSkgfHwgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFt0YXJnZXRdLmNvbmNhdChzb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBtZXJnZVRhcmdldCA9IHRhcmdldDtcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmICFpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgbWVyZ2VUYXJnZXQgPSBhcnJheVRvT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbCh0YXJnZXQsIGkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0YXJnZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW0gJiYgdHlwZW9mIHRhcmdldEl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IG1lcmdlKHRhcmdldEl0ZW0sIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaGFzLmNhbGwoYWNjLCBrZXkpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IG1lcmdlKGFjY1trZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbWVyZ2VUYXJnZXQpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnblNpbmdsZVNvdXJjZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB0YXJnZXQpO1xufTtcblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uIChzdHIsIGRlY29kZXIsIGNoYXJzZXQpIHtcbiAgICB2YXIgc3RyV2l0aG91dFBsdXMgPSBzdHIucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAvLyB1bmVzY2FwZSBuZXZlciB0aHJvd3MsIG5vIHRyeS4uLmNhdGNoIG5lZWRlZDpcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzLnJlcGxhY2UoLyVbMC05YS1mXXsyfS9naSwgdW5lc2NhcGUpO1xuICAgIH1cbiAgICAvLyB1dGYtOFxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyV2l0aG91dFBsdXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzO1xuICAgIH1cbn07XG5cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoc3RyLCBkZWZhdWx0RW5jb2RlciwgY2hhcnNldCwga2luZCwgZm9ybWF0KSB7XG4gICAgLy8gVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQnJpYW4gV2hpdGUgKG1zY2RleCkgZm9yIHRoZSBpby5qcyBjb3JlIHF1ZXJ5c3RyaW5nIGxpYnJhcnkuXG4gICAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSBzdHI7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyaW5nID0gU3RyaW5nKHN0cik7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyUyNiUyMycgKyBwYXJzZUludCgkMC5zbGljZSgyKSwgMTYpICsgJyUzQic7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICAgICAgfHwgKGZvcm1hdCA9PT0gZm9ybWF0cy5SRkMxNzM4ICYmIChjID09PSAweDI4IHx8IGMgPT09IDB4MjkpKSAvLyAoIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXQgKz0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyBoZXhUYWJsZVtjXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4RTAgfCAoYyA+PiAxMildICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzdHJpbmcuY2hhckNvZGVBdChpKSAmIDB4M0ZGKSk7XG4gICAgICAgIC8qIGVzbGludCBvcGVyYXRvci1saW5lYnJlYWs6IFsyLCBcImJlZm9yZVwiXSAqL1xuICAgICAgICBvdXQgKz0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn07XG5cbnZhciBtYXliZU1hcCA9IGZ1bmN0aW9uIG1heWJlTWFwKHZhbCwgZm4pIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbih2YWwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21iaW5lOiBjb21iaW5lLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtYXliZU1hcDogbWF5YmVNYXAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWluc3BlY3QnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG52YXIgJFdlYWtNYXAgPSBHZXRJbnRyaW5zaWMoJyVXZWFrTWFwJScsIHRydWUpO1xudmFyICRNYXAgPSBHZXRJbnRyaW5zaWMoJyVNYXAlJywgdHJ1ZSk7XG5cbnZhciAkd2Vha01hcEdldCA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuZ2V0JywgdHJ1ZSk7XG52YXIgJHdlYWtNYXBTZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xudmFyICR3ZWFrTWFwSGFzID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcbnZhciAkbWFwR2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xudmFyICRtYXBTZXQgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuc2V0JywgdHJ1ZSk7XG52YXIgJG1hcEhhcyA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gdHJhdmVyc2VzIHRoZSBsaXN0IHJldHVybmluZyB0aGUgbm9kZSBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICogZ2l2ZW4ga2V5LlxuICpcbiAqIFRoYXQgbm9kZSBpcyBhbHNvIG1vdmVkIHRvIHRoZSBoZWFkIG9mIHRoZSBsaXN0LCBzbyB0aGF0IGlmIGl0J3MgYWNjZXNzZWRcbiAqIGFnYWluIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHdob2xlIGxpc3QuIEJ5IGRvaW5nIHNvLCBhbGwgdGhlIHJlY2VudGx5XG4gKiB1c2VkIG5vZGVzIGNhbiBiZSBhY2Nlc3NlZCByZWxhdGl2ZWx5IHF1aWNrbHkuXG4gKi9cbnZhciBsaXN0R2V0Tm9kZSA9IGZ1bmN0aW9uIChsaXN0LCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRmb3IgKHZhciBwcmV2ID0gbGlzdCwgY3VycjsgKGN1cnIgPSBwcmV2Lm5leHQpICE9PSBudWxsOyBwcmV2ID0gY3Vycikge1xuXHRcdGlmIChjdXJyLmtleSA9PT0ga2V5KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBjdXJyLm5leHQ7XG5cdFx0XHRjdXJyLm5leHQgPSBsaXN0Lm5leHQ7XG5cdFx0XHRsaXN0Lm5leHQgPSBjdXJyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0XHRyZXR1cm4gY3Vycjtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBsaXN0R2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdHJldHVybiBub2RlICYmIG5vZGUudmFsdWU7XG59O1xudmFyIGxpc3RTZXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5LCB2YWx1ZSkge1xuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdGlmIChub2RlKSB7XG5cdFx0bm9kZS52YWx1ZSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFByZXBlbmQgdGhlIG5ldyBub2RlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3Rcblx0XHRvYmplY3RzLm5leHQgPSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHRcdGtleToga2V5LFxuXHRcdFx0bmV4dDogb2JqZWN0cy5uZXh0LFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxufTtcbnZhciBsaXN0SGFzID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHRyZXR1cm4gISFsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTaWRlQ2hhbm5lbCgpIHtcblx0dmFyICR3bTtcblx0dmFyICRtO1xuXHR2YXIgJG87XG5cdHZhciBjaGFubmVsID0ge1xuXHRcdGFzc2VydDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCFjaGFubmVsLmhhcyhrZXkpKSB7XG5cdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdTaWRlIGNoYW5uZWwgZG9lcyBub3QgY29udGFpbiAnICsgaW5zcGVjdChrZXkpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldDogZnVuY3Rpb24gKGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoJHdtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICR3ZWFrTWFwR2V0KCR3bSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICgkbSkge1xuXHRcdFx0XHRcdHJldHVybiAkbWFwR2V0KCRtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRyZXR1cm4gbGlzdEdldCgkbywga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGFzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoJHdtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICR3ZWFrTWFwSGFzKCR3bSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICgkbSkge1xuXHRcdFx0XHRcdHJldHVybiAkbWFwSGFzKCRtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRyZXR1cm4gbGlzdEhhcygkbywga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCEkd20pIHtcblx0XHRcdFx0XHQkd20gPSBuZXcgJFdlYWtNYXAoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkd2Vha01hcFNldCgkd20sIGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICghJG0pIHtcblx0XHRcdFx0XHQkbSA9IG5ldyAkTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JG1hcFNldCgkbSwga2V5LCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoISRvKSB7XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQgKiBJbml0aWFsaXplIHRoZSBsaW5rZWQgbGlzdCBhcyBhbiBlbXB0eSBub2RlLCBzbyB0aGF0IHdlIGRvbid0IGhhdmVcblx0XHRcdFx0XHQgKiB0byBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2YgdGhlIGZpcnN0IG5vZGU6IHdlIGNhbiBhbHdheXMgcmVmZXIgdG9cblx0XHRcdFx0XHQgKiBpdCBhcyAocHJldmlvdXMgbm9kZSkubmV4dCwgaW5zdGVhZCBvZiBzb21ldGhpbmcgbGlrZSAobGlzdCkuaGVhZFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdCRvID0geyBrZXk6IHt9LCBuZXh0OiBudWxsIH07XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdFNldCgkbywga2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gY2hhbm5lbDtcbn07XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIHYxIH0gZnJvbSAnLi92MS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJzsiLCIvKlxuICogQnJvd3Nlci1jb21wYXRpYmxlIEphdmFTY3JpcHQgTUQ1XG4gKlxuICogTW9kaWZpY2F0aW9uIG9mIEphdmFTY3JpcHQgTUQ1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvblxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgbGVuZ3RoMzIgPSBpbnB1dC5sZW5ndGggKiAzMjtcbiAgdmFyIGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICB2YXIgeCA9IGlucHV0W2kgPj4gNV0gPj4+IGkgJSAzMiAmIDB4ZmY7XG4gICAgdmFyIGhleCA9IHBhcnNlSW50KGhleFRhYi5jaGFyQXQoeCA+Pj4gNCAmIDB4MGYpICsgaGV4VGFiLmNoYXJBdCh4ICYgMHgwZiksIDE2KTtcbiAgICBvdXRwdXQucHVzaChoZXgpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG91dHB1dCBsZW5ndGggd2l0aCBwYWRkaW5nIGFuZCBiaXQgbGVuZ3RoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRPdXRwdXRMZW5ndGgoaW5wdXRMZW5ndGg4KSB7XG4gIHJldHVybiAoaW5wdXRMZW5ndGg4ICsgNjQgPj4+IDkgPDwgNCkgKyAxNCArIDE7XG59XG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdvcmRzVG9NZDUoeCwgbGVuKSB7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgbGVuICUgMzI7XG4gIHhbZ2V0T3V0cHV0TGVuZ3RoKGxlbikgLSAxXSA9IGxlbjtcbiAgdmFyIGEgPSAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gMjcxNzMzODc4O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XG4gIHZhciBvdXRwdXQgPSBuZXcgVWludDMyQXJyYXkoZ2V0T3V0cHV0TGVuZ3RoKGxlbmd0aDgpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xuICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dFtpIC8gOF0gJiAweGZmKSA8PCBpICUgMzI7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcbiAgdmFyIGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gbXN3IDw8IDE2IHwgbHN3ICYgMHhmZmZmO1xufVxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpdFJvdGF0ZUxlZnQobnVtLCBjbnQpIHtcbiAgcmV0dXJuIG51bSA8PCBjbnQgfCBudW0gPj4+IDMyIC0gY250O1xufVxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICByZXR1cm4gc2FmZUFkZChiaXRSb3RhdGVMZWZ0KHNhZmVBZGQoc2FmZUFkZChhLCBxKSwgc2FmZUFkZCh4LCB0KSksIHMpLCBiKTtcbn1cblxuZnVuY3Rpb24gbWQ1ZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBjIHwgfmIgJiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1Z2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBkIHwgYyAmIH5kLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZDU7IiwiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgdmFyIHY7XG4gIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7IiwiLy8gQWRhcHRlZCBmcm9tIENocmlzIFZlbmVzcycgU0hBMSBjb2RlIGF0XG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL3NoYTEuaHRtbFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxufVxuXG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgcmV0dXJuIHggPDwgbiB8IHggPj4+IDMyIC0gbjtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICB2YXIgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF07XG5cbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcbiAgICBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIHZhciBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIHZhciBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gIHZhciBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBOOyArK19pKSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW19pICogNjQgKyBqICogNF0gPDwgMjQgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAzXTtcbiAgICB9XG5cbiAgICBNW19pXSA9IGFycjtcbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgKytfaTIpIHtcbiAgICB2YXIgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW19pMl1bdF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3QgPSAxNjsgX3QgPCA4MDsgKytfdCkge1xuICAgICAgV1tfdF0gPSBST1RMKFdbX3QgLSAzXSBeIFdbX3QgLSA4XSBeIFdbX3QgLSAxNF0gXiBXW190IC0gMTZdLCAxKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IEhbMF07XG4gICAgdmFyIGIgPSBIWzFdO1xuICAgIHZhciBjID0gSFsyXTtcbiAgICB2YXIgZCA9IEhbM107XG4gICAgdmFyIGUgPSBIWzRdO1xuXG4gICAgZm9yICh2YXIgX3QyID0gMDsgX3QyIDwgODA7ICsrX3QyKSB7XG4gICAgICB2YXIgcyA9IE1hdGguZmxvb3IoX3QyIC8gMjApO1xuICAgICAgdmFyIFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1tfdDJdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IEhbMF0gKyBhID4+PiAwO1xuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcbiAgICBIWzJdID0gSFsyXSArIGMgPj4+IDA7XG4gICAgSFszXSA9IEhbM10gKyBkID4+PiAwO1xuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYTE7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJzsgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcblxudmFyIF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgbmV3IEFycmF5KDE2KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICB2YXIgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwOyAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfSAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG5cblxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfSAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG5cblxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTsgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG5cbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7IC8vIGB0aW1lX2xvd2BcblxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmOyAvLyBgdGltZV9taWRgXG5cbiAgdmFyIHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgc3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiLCJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xudmFyIHYzID0gdjM1KCd2MycsIDB4MzAsIG1kNSk7XG5leHBvcnQgZGVmYXVsdCB2MzsiLCJpbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmV4cG9ydCB2YXIgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgdmFyIFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59IiwiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgc2hhMSBmcm9tICcuL3NoYTEuanMnO1xudmFyIHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd3cyBkb2VzIG5vdCB3b3JrIGluIHRoZSBicm93c2VyLiBCcm93c2VyIGNsaWVudHMgbXVzdCB1c2UgdGhlIG5hdGl2ZSAnICtcbiAgICAgICdXZWJTb2NrZXQgb2JqZWN0J1xuICApO1xufTtcbiIsIi8qIChpZ25vcmVkKSAqLyIsInZhciB1dGlsO1xuKGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgICAgICAgIC5tYXAoKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBgJyR7dmFsfSdgIDogdmFsKSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbmNvbnN0IFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcInN0cmluZ1wiLFxuICAgIFwibmFuXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwicHJvbWlzZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm1hcFwiLFxuICAgIFwic2V0XCIsXG5dKTtcbmNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBpc05hTihkYXRhKSA/IFpvZFBhcnNlZFR5cGUubmFuIDogWm9kUGFyc2VkVHlwZS5udW1iZXI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5ib29sZWFuO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5iaWdpbnQ7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuXG5jb25zdCBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuXSk7XG5jb25zdCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gW107XG4gICAgICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZXMgPSAoc3VicyA9IFtdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3VlcywgLi4uc3Vic107XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gbmV3LnRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICAgIH1cbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG4gICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmlzc3VlcywgbnVsbCwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSA9IGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gICAgfVxuICAgIGdldCBmb3JtRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgfVxufVxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcbmNvbnN0IGRlZmF1bHRFcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCl9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkICR7aXNzdWUudmFsaWRhdGlvbn1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBtb3JlIHRoYW5gfSAke2lzc3VlLm1pbmltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgZ3JlYXRlciB0aGFuICR7aXNzdWUuaW5jbHVzaXZlID8gYG9yIGVxdWFsIHRvIGAgOiBgYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYHVuZGVyYH0gJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGxlc3MgdGhhbiAke2lzc3VlLmluY2x1c2l2ZSA/IGBvciBlcXVhbCB0byBgIDogYGB9JHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmN1c3RvbTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludGVyc2VjdGlvbiByZXN1bHRzIGNvdWxkIG5vdCBiZSBtZXJnZWRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLm11bHRpcGxlT2Z9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5sZXQgb3ZlcnJpZGVFcnJvck1hcCA9IGRlZmF1bHRFcnJvck1hcDtcbmNvbnN0IHNldEVycm9yTWFwID0gKG1hcCkgPT4ge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59O1xuXG5jb25zdCBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgsIC4uLihpc3N1ZURhdGEucGF0aCB8fCBbXSldO1xuICAgIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICB9O1xuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSB8fCBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5jb25zdCBFTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICAgICAgaXNzdWVEYXRhOiBpc3N1ZURhdGEsXG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgIG92ZXJyaWRlRXJyb3JNYXAsXG4gICAgICAgICAgICBkZWZhdWx0RXJyb3JNYXAsXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogYXdhaXQgcGFpci5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IHBhaXIudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkge1xuICAgICAgICAgICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gICAgfVxufVxuY29uc3QgSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmNvbnN0IERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG5jb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xuY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcbmNvbnN0IGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcbmNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbmNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IHVuZGVmaW5lZCAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcblxudmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcblxuY2xhc3MgUGFyc2VJbnB1dExhenlQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoLCBrZXkpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGguY29uY2F0KHRoaXMuX2tleSk7XG4gICAgfVxufVxuY29uc3QgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGlzVmFsaWQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghY3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvciB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkXCIgb3IgXCJyZXF1aXJlZFwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgICB9XG4gICAgaWYgKGVycm9yTWFwKVxuICAgICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAsIGRlc2NyaXB0aW9uIH07XG4gICAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgICAgIGlmIChpc3MuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIiAmJiByZXF1aXJlZF9lcnJvcilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHJlcXVpcmVkX2Vycm9yIH07XG4gICAgICAgIGlmIChwYXJhbXMuaW52YWxpZF90eXBlX2Vycm9yKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogcGFyYW1zLmludmFsaWRfdHlwZV9lcnJvciB9O1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuY2xhc3MgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgICAgIC8qKiBBbGlhcyBvZiBzYWZlUGFyc2VBc3luYyAqL1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XG4gICAgICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLl9yZWZpbmVtZW50O1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBfZ2V0VHlwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wYXJzZUFzeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBwYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdClcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgbnVsbGlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWwoKS5udWxsYWJsZSgpO1xuICAgIH1cbiAgICBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBvcihvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSk7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZyk7XG4gICAgfVxuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQoZGVmKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuY29uc3QgY3VpZFJlZ2V4ID0gL15jW15cXHMtXXs4LH0kL2k7XG5jb25zdCB1dWlkUmVnZXggPSAvXihbYS1mMC05XXs4fS1bYS1mMC05XXs0fS1bMS01XVthLWYwLTldezN9LVthLWYwLTldezR9LVthLWYwLTldezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oKFtePD4oKVtcXF1cXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChbXjw+KClbXFxdXFwuLDs6XFxzQFxcXCJdK1xcLikrW148PigpW1xcXVxcLiw7Olxcc0BcXFwiXXsyLH0pJC9pO1xuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3JlZ2V4ID0gKHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSA9PiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIHouc3RyaW5nKCkubWluKDEpIGluc3RlYWQuXG4gICAgICAgICAqIEBzZWUge0BsaW5rIFpvZFN0cmluZy5taW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbmVtcHR5ID0gKG1lc3NhZ2UpID0+IHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgICAgIHRoaXMudHJpbSA9ICgpID0+IG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1haWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbWFpbFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVybChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXVpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXVpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICByZWdleChyZWdleCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJyZWdleFwiLFxuICAgICAgICAgICAgcmVnZXg6IHJlZ2V4LFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heExlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKGxlbiwgbWVzc2FnZSkubWF4KGxlbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInV1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZFwiKTtcbiAgICB9XG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1pbiA9IC1JbmZpbml0eTtcbiAgICAgICAgdGhpcy5fZGVmLmNoZWNrcy5tYXAoKGNoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZi5jaGVja3MubWFwKChjaCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IHBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IHBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyBNYXRoLnBvdygxMCwgZGVjQ291bnQpO1xufVxuY2xhc3MgWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBpc0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIik7XG4gICAgfVxufVxuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYmlnaW50KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmRhdGUsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbn1cblpvZERhdGUuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVuZGVmaW5lZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS51bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuZGVmaW5lZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5kZWZpbmVkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGwoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RBbnkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gdG8gcHJldmVudCBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3NlcyBmcm9tIGV4dGVuZGluZyBab2RBbnkuIHRoaXMgY2F1c2VzIGlzc3VlcyB3aXRoIGNhdGNoYWxsIGluIFpvZE9iamVjdC5cbiAgICAgICAgdGhpcy5fYW55ID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RBbnkuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQW55KHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmtub3duIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuX3Vua25vd24gPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVua25vd24uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5rbm93bixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE5ldmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmV2ZXIsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG59XG5ab2ROZXZlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROZXZlcih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RWb2lkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnZvaWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVm9pZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RWb2lkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RWb2lkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQXJyYXkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHN0YXR1cyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1pbkxlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5taW5MZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjdHguZGF0YS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlQXN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY3R4LmRhdGEubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihsZW4sIG1lc3NhZ2UpLm1heChsZW4sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBcnJheSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2RPYmplY3QgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsXG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuY29uc3QgQXVnbWVudEZhY3RvcnkgPSAoZGVmKSA9PiAoYXVnbWVudGF0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAuLi5kZWYsXG4gICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgLi4uZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIH0pLFxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLnNoYXBlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHNjaGVtYS5zaGFwZVtrZXldO1xuICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShmaWVsZFNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIHRoaXMuYXVnbWVudCA9IEF1Z21lbnRGYWN0b3J5KHRoaXMuX2RlZik7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gQXVnbWVudEZhY3RvcnkodGhpcy5fZGVmKTtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIGlmICghc2hhcGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IHBhaXIudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpc3N1ZSwgY3R4KS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoX2QgPSBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgICAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcbiAgICAgICAgLy8gKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXMobWFzaykubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRvIHNoYXBlIGlmIGtleSBjb3JyZXNwb25kcyB0byBhbiBlbGVtZW50IG9mIHRoZSBjdXJyZW50IHNoYXBlXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFwZVtrZXldKVxuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbWl0KG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodXRpbC5vYmplY3RLZXlzKG1hc2spLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVlcFBhcnRpYWwoKSB7XG4gICAgICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgICB9XG4gICAgcGFydGlhbChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5vYmplY3RLZXlzKG1hc2spLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV0ub3B0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQoKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gbmV3RmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RPYmplY3QuY3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLnZhbGlkRGlzY3JpbWluYXRvclZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCB2YWxpZERpc2NyaW1pbmF0b3JWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMub3B0aW9ucy5rZXlzKCkpO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgICAqIEhvd2V2ZXIsIGl0IG9ubHkgYWxsb3dzIGEgdW5pb24gb2Ygb2JqZWN0cywgYWxsIG9mIHdoaWNoIG5lZWQgdG8gc2hhcmUgYSBkaXNjcmltaW5hdG9yIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IG11c3RcbiAgICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXG4gICAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gdHlwZXMgYW4gYXJyYXkgb2Ygb2JqZWN0IHNjaGVtYXNcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkaXNjcmltaW5hdG9yLCB0eXBlcywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0eXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gdHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXS52YWx1ZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldChkaXNjcmltaW5hdG9yVmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkaXNjcmltaW5hdG9yIHZhbHVlIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgdGhlIHByb3ZpZGVkIHNjaGVtYXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZXJ0IHRoYXQgYWxsIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlcyBhcmUgdW5pcXVlXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZSBvZiB0aGUgZGlzY3JpbWluYXRvciB2YWx1ZXMgYXJlIG5vdCB1bmlxdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICAgIGNvbnN0IGFUeXBlID0gZ2V0UGFyc2VkVHlwZShhKTtcbiAgICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICBjb25zdCBiS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhiKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWxcbiAgICAgICAgICAgIC5vYmplY3RLZXlzKGEpXG4gICAgICAgICAgICAuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmXG4gICAgICAgICthID09PSArYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgfVxufVxuY2xhc3MgWm9kSW50ZXJzZWN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZVBhcnNlZCA9IChwYXJzZWRMZWZ0LCBwYXJzZWRSaWdodCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEaXJ0eShwYXJzZWRMZWZ0KSB8fCBpc0RpcnR5KHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBtZXJnZWQuZGF0YSB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYubGVmdC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IGhhbmRsZVBhcnNlZChsZWZ0LCByaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pLCB0aGlzLl9kZWYucmlnaHQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RJbnRlcnNlY3Rpb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RUdXBsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBjdHguZGF0YVxuICAgICAgICAgICAgLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpdGVtSW5kZXgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+ICEheCk7IC8vIGZpbHRlciBudWxsc1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xuICAgIH1cbiAgICByZXN0KHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXN0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgY3R4LmRhdGFba2V5XSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcbiAgICAgICAgaWYgKHNlY29uZCBpbnN0YW5jZW9mIFpvZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgICAgICBrZXlUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGU6IHNlY29uZCxcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgIGtleVR5cGU6IFpvZFN0cmluZy5jcmVhdGUoKSxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogZmlyc3QsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMoc2Vjb25kKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kTWFwIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVTZXQoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRTZXQuYWRkKGVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBwYXJzZWRTZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbGVtZW50cykudGhlbigoZWxlbWVudHMpID0+IGZpbmFsaXplU2V0KGVsZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxpemVTZXQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1pbihtaW5TaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pblNpemU6IHsgdmFsdWU6IG1pblNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heFNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4U2l6ZTogeyB2YWx1ZTogbWF4U2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaXplKHNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBtaW5TaXplOiBudWxsLFxuICAgICAgICBtYXhTaXplOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFNldCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlQXJnc0lzc3VlKGFyZ3MsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gT0soYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IHRoaXMuX2RlZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbiguLi5wYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgdGhpcy5fZGVmLnJldHVybnMuX2RlZi50eXBlXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKHJlc3VsdCwgcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPSygoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSB0aGlzLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oLi4ucGFyc2VkQXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gdGhpcy5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxufVxuWm9kRnVuY3Rpb24uY3JlYXRlID0gKGFyZ3MsIHJldHVybnMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICBhcmdzOiAoYXJnc1xuICAgICAgICAgICAgPyBhcmdzLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSlcbiAgICAgICAgICAgIDogWm9kVHVwbGUuY3JlYXRlKFtdKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpKSxcbiAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTGF6eSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGxhenlTY2hlbWEuX3BhcnNlKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICB9XG59XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgICAgIGdldHRlcjogZ2V0dGVyLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuY2xhc3MgWm9kRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVmLnZhbHVlcy5pbmRleE9mKGlucHV0LmRhdGEpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxufVxuWm9kRW51bS5jcmVhdGUgPSBjcmVhdGVab2RFbnVtO1xuY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXRpdmVFbnVtVmFsdWVzLmluZGV4T2YoaW5wdXQuZGF0YSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbn1cblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFByb21pc2UgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmXG4gICAgICAgICAgICBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlXG4gICAgICAgICAgICA/IGN0eC5kYXRhXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGlubmVyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbigocHJvY2Vzc2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2NcbiAgICAgICAgICAgIC8vIGVmZmVjdDogUmVmaW5lbWVudEVmZmVjdDxhbnk+XG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYmFzZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYmFzZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIC8vICAgcmV0dXJuIHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlOiBiYXNlLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGJhc2Uuc3RhdHVzID09PSBcImFib3J0ZWRcIikgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChiYXNlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgcmV0dXJuIHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlOiBiYXNlLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KSkudGhlbigocmVzdWx0KSA9PiAoeyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICAgIH1cbn1cblpvZEVmZmVjdHMuY3JlYXRlID0gKHNjaGVtYSwgZWZmZWN0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgZWZmZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChwcmVwcm9jZXNzLCBzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kT3B0aW9uYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kT3B0aW9uYWwuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGVmYXVsdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2REZWZhdWx0LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNvbnN0IGN1c3RvbSA9IChjaGVjaywgcGFyYW1zID0ge30sIGZhdGFsKSA9PiB7XG4gICAgaWYgKGNoZWNrKVxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hlY2soZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGRhdGEpIDogcGFyYW1zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucDIsIGZhdGFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpO1xufTtcbmNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG52YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKGNscywgcGFyYW1zID0ge1xuICAgIG1lc3NhZ2U6IGBJbnB1dCBub3QgaW5zdGFuY2Ugb2YgJHtjbHMubmFtZX1gLFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMsIHRydWUpO1xuY29uc3Qgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XG5jb25zdCBudW1iZXJUeXBlID0gWm9kTnVtYmVyLmNyZWF0ZTtcbmNvbnN0IG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xuY29uc3QgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XG5jb25zdCBib29sZWFuVHlwZSA9IFpvZEJvb2xlYW4uY3JlYXRlO1xuY29uc3QgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuXG52YXIgbW9kID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXRQYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlLFxuICAgIFpvZFBhcnNlZFR5cGU6IFpvZFBhcnNlZFR5cGUsXG4gICAgbWFrZUlzc3VlOiBtYWtlSXNzdWUsXG4gICAgRU1QVFlfUEFUSDogRU1QVFlfUEFUSCxcbiAgICBhZGRJc3N1ZVRvQ29udGV4dDogYWRkSXNzdWVUb0NvbnRleHQsXG4gICAgUGFyc2VTdGF0dXM6IFBhcnNlU3RhdHVzLFxuICAgIElOVkFMSUQ6IElOVkFMSUQsXG4gICAgRElSVFk6IERJUlRZLFxuICAgIE9LOiBPSyxcbiAgICBpc0Fib3J0ZWQ6IGlzQWJvcnRlZCxcbiAgICBpc0RpcnR5OiBpc0RpcnR5LFxuICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgaXNBc3luYzogaXNBc3luYyxcbiAgICBab2RUeXBlOiBab2RUeXBlLFxuICAgIFpvZFN0cmluZzogWm9kU3RyaW5nLFxuICAgIFpvZE51bWJlcjogWm9kTnVtYmVyLFxuICAgIFpvZEJpZ0ludDogWm9kQmlnSW50LFxuICAgIFpvZEJvb2xlYW46IFpvZEJvb2xlYW4sXG4gICAgWm9kRGF0ZTogWm9kRGF0ZSxcbiAgICBab2RVbmRlZmluZWQ6IFpvZFVuZGVmaW5lZCxcbiAgICBab2ROdWxsOiBab2ROdWxsLFxuICAgIFpvZEFueTogWm9kQW55LFxuICAgIFpvZFVua25vd246IFpvZFVua25vd24sXG4gICAgWm9kTmV2ZXI6IFpvZE5ldmVyLFxuICAgIFpvZFZvaWQ6IFpvZFZvaWQsXG4gICAgWm9kQXJyYXk6IFpvZEFycmF5LFxuICAgIGdldCBvYmplY3RVdGlsICgpIHsgcmV0dXJuIG9iamVjdFV0aWw7IH0sXG4gICAgWm9kT2JqZWN0OiBab2RPYmplY3QsXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxuICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgIFpvZEludGVyc2VjdGlvbjogWm9kSW50ZXJzZWN0aW9uLFxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcbiAgICBab2RSZWNvcmQ6IFpvZFJlY29yZCxcbiAgICBab2RNYXA6IFpvZE1hcCxcbiAgICBab2RTZXQ6IFpvZFNldCxcbiAgICBab2RGdW5jdGlvbjogWm9kRnVuY3Rpb24sXG4gICAgWm9kTGF6eTogWm9kTGF6eSxcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxuICAgIFpvZEVudW06IFpvZEVudW0sXG4gICAgWm9kTmF0aXZlRW51bTogWm9kTmF0aXZlRW51bSxcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxuICAgIFpvZEVmZmVjdHM6IFpvZEVmZmVjdHMsXG4gICAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxuICAgIFpvZE51bGxhYmxlOiBab2ROdWxsYWJsZSxcbiAgICBab2REZWZhdWx0OiBab2REZWZhdWx0LFxuICAgIFpvZE5hTjogWm9kTmFOLFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIFNjaGVtYTogWm9kVHlwZSxcbiAgICBab2RTY2hlbWE6IFpvZFR5cGUsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcbiAgICBhbnk6IGFueVR5cGUsXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcbiAgICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXG4gICAgZGF0ZTogZGF0ZVR5cGUsXG4gICAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcbiAgICAnZnVuY3Rpb24nOiBmdW5jdGlvblR5cGUsXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gICAgbGF6eTogbGF6eVR5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXG4gICAgbWFwOiBtYXBUeXBlLFxuICAgIG5hbjogbmFuVHlwZSxcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxuICAgICdudWxsJzogbnVsbFR5cGUsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFR5cGUsXG4gICAgb3N0cmluZzogb3N0cmluZyxcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcbiAgICBwcm9taXNlOiBwcm9taXNlVHlwZSxcbiAgICByZWNvcmQ6IHJlY29yZFR5cGUsXG4gICAgc2V0OiBzZXRUeXBlLFxuICAgIHN0cmljdE9iamVjdDogc3RyaWN0T2JqZWN0VHlwZSxcbiAgICBzdHJpbmc6IHN0cmluZ1R5cGUsXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXG4gICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZFR5cGUsXG4gICAgdW5pb246IHVuaW9uVHlwZSxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgICAndm9pZCc6IHZvaWRUeXBlLFxuICAgIFpvZElzc3VlQ29kZTogWm9kSXNzdWVDb2RlLFxuICAgIHF1b3RlbGVzc0pzb246IHF1b3RlbGVzc0pzb24sXG4gICAgWm9kRXJyb3I6IFpvZEVycm9yLFxuICAgIGRlZmF1bHRFcnJvck1hcDogZGVmYXVsdEVycm9yTWFwLFxuICAgIGdldCBvdmVycmlkZUVycm9yTWFwICgpIHsgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7IH0sXG4gICAgc2V0RXJyb3JNYXA6IHNldEVycm9yTWFwXG59KTtcblxuZXhwb3J0IHsgRElSVFksIEVNUFRZX1BBVEgsIElOVkFMSUQsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kRGF0ZSwgWm9kRGVmYXVsdCwgWm9kRGlzY3JpbWluYXRlZFVuaW9uLCBab2RFZmZlY3RzLCBab2RFbnVtLCBab2RFcnJvciwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLCBab2RGdW5jdGlvbiwgWm9kSW50ZXJzZWN0aW9uLCBab2RJc3N1ZUNvZGUsIFpvZExhenksIFpvZExpdGVyYWwsIFpvZE1hcCwgWm9kTmFOLCBab2ROYXRpdmVFbnVtLCBab2ROZXZlciwgWm9kTnVsbCwgWm9kTnVsbGFibGUsIFpvZE51bWJlciwgWm9kT2JqZWN0LCBab2RPcHRpb25hbCwgWm9kUGFyc2VkVHlwZSwgWm9kUHJvbWlzZSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZEVmZmVjdHMgYXMgWm9kVHJhbnNmb3JtZXIsIFpvZFR1cGxlLCBab2RUeXBlLCBab2RVbmRlZmluZWQsIFpvZFVuaW9uLCBab2RVbmtub3duLCBab2RWb2lkLCBhZGRJc3N1ZVRvQ29udGV4dCwgYW55VHlwZSBhcyBhbnksIGFycmF5VHlwZSBhcyBhcnJheSwgYmlnSW50VHlwZSBhcyBiaWdpbnQsIGJvb2xlYW5UeXBlIGFzIGJvb2xlYW4sIGN1c3RvbSwgZGF0ZVR5cGUgYXMgZGF0ZSwgbW9kIGFzIGRlZmF1bHQsIGRlZmF1bHRFcnJvck1hcCwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgb3ZlcnJpZGVFcnJvck1hcCwgcHJlcHJvY2Vzc1R5cGUgYXMgcHJlcHJvY2VzcywgcHJvbWlzZVR5cGUgYXMgcHJvbWlzZSwgcXVvdGVsZXNzSnNvbiwgcmVjb3JkVHlwZSBhcyByZWNvcmQsIHNldFR5cGUgYXMgc2V0LCBzZXRFcnJvck1hcCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB2b2lkVHlwZSBhcyB2b2lkLCBtb2QgYXMgeiB9O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiRHJvcGRvd24iLCJvcHRpb25zIiwic2VsZWN0ZWRPcHRpb24iLCJzZXRTZWxlY3RlZE9wdGlvbiIsImlzT3BlbiIsInNldE9wZW4iLCJkcm9wZG93biIsInRvZ2dsZURyb3Bkb3duIiwiaGFuZGxlSXRlbUNsaWNrIiwiY3VycmVuY3kiLCJoYW5kbGVDbGlja091dHNpZGUiLCJldmVudCIsImN1cnJlbnQiLCJjb250YWlucyIsInRhcmdldCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmaW5kIiwib3B0aW9uIiwibWFwIiwiaXRlbSIsImluZGV4IiwiZSIsImN1cnJlbmNpZXMiLCJjb250cmFjdCIsImRlY2ltYWxzIiwiRnJhZ21lbnQiLCJ1c2VDb250ZXh0IiwiTW9kYWwiLCJCdXR0b24iLCJBdXRoQ29udGV4dCIsIldhbGxldENvbnRleHQiLCJzdGFydFBvb2wiLCJmZXRjaEVzY3Jvd3MiLCJmaWxsRXNjcm93IiwicGFydGFrZVBvb2wiLCJmaWxsUG9vbCIsImNhbmNlbFBvb2wiLCJ1c2VOYXZpZ2F0ZSIsIkNvbnRlc3QiLCJuYXZpZ2F0ZSIsImN0eCIsIndhbGxldEN0eCIsInN1Y2Nlc3NQb3B1cCIsInNldFN1Y2Nlc3NQb3B1cCIsImVycm9yIiwic2V0RXJyb3IiLCJzdWNjZXNzIiwic2V0U3VjY2VzcyIsImNoZWNrRXJyb3IiLCJzZXRDaGVja0Vycm9yIiwibG9hZGluZyIsInNldExvYWRpbmciLCJjbG9zZVN1Y2Nlc3NQb3B1cCIsInRpdGxlIiwic2V0VGl0bGUiLCJkZXNjcmlwdGlvbiIsInNldERlc2NyaXB0aW9uIiwicG9vbFR5cGUiLCJzZXRQb29sVHlwZSIsImFtb3VudCIsInNldEFtb3VudCIsInRva2VuIiwic2V0VG9rZW4iLCJ0b2tlbnMiLCJzZXRUb2tlbnMiLCJiYWxhbmNlcyIsImxlbmd0aCIsImNoZWNrRXhjaGFuZ2UiLCJzZXRDaGVja0V4Y2hhbmdlIiwidmFsaWRhdGVGb3JtIiwiaGFuZGxlQ29udGVzdEZvcm1TdWJtaXQiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZVRyYW5zYWN0aW9uIiwic2xlZXAiLCJtaWxsaXNlY29uZHMiLCJkYXRlIiwiRGF0ZSIsIm5vdyIsImN1cnJlbnREYXRlIiwiZXhwaXJ5IiwiYXV0aG9yaXphdGlvbiIsImFjdG9yIiwiYXV0aCIsInBlcm1pc3Npb24iLCJjb250ZXN0ZXJzIiwiZnJvbU5mdHMiLCJzZXNzaW9uIiwiZXNjcm93cyIsIm15RXNjcm93cyIsImZpbHRlciIsImVzY3JvdyIsImZyb20iLCJsb29wSWQiLCJlc2Nyb3dJZCIsImlkIiwidG9TdHJpbmciLCJjb25zb2xlIiwibG9nIiwiZmV0Y2giLCJwcm9jZXNzIiwiZW52IiwiTUlYX0FQSV9VUkwiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInR5cGVfaWQiLCJlc2Nyb3dfaWQiLCJOdW1iZXIiLCJlc2Nyb3dfc3RhdHVzIiwicG9vbF90eXBlIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJ0aGVuIiwicmVzcG9uc2UiLCJqc29uIiwiZGF0YSIsInZhbGlkIiwibWVzc2FnZSIsInZhbHVlIiwiY2hlY2tlZCIsImlzTG9nZ2VkSW4iLCJwcm90b25Db25uZWN0aW9uIiwiQXBpQ2xhc3MiLCJjdXJyZW50X25ldHdvcmsiLCJhcGkiLCJjaGFpbiIsImZlZUNvbnRyYWN0IiwiZmVlUXVhbnRpdHkiLCJmZXRjaEVzY3Jvd0FsbCIsInJwYyIsImdldF90YWJsZV9yb3dzIiwiY29kZSIsInNjb3BlIiwidGFibGUiLCJpbmRleF9wb3NpdGlvbiIsImtleV90eXBlIiwibGltaXQiLCJyb3dzIiwiYWNjb3VudE5hbWUiLCJsb3dlcl9ib3VuZCIsInVwcGVyX2JvdW5kIiwiZnJvbVRva2VuIiwiZnJvbUFtb3VudCIsImFtb3VudEluIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJmcm9tUXVhbnRpdHkiLCJhY3Rpb25zIiwiYWNjb3VudCIsIm5hbWUiLCJ0byIsInF1YW50aXR5IiwibWVtbyIsImZyb21Ub2tlbnMiLCJ0cmFuc2FjdCIsInRyYW5zYWN0aW9uIiwid2lubmVycyJdLCJzb3VyY2VSb290IjoiIn0=