(self["webpackChunk"] = self["webpackChunk"] || []).push([["resources_js_pages_PurchaseItem_js"],{

/***/ "./node_modules/@bloks/constants/dist/constants.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bloks/constants/dist/constants.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ANCHOR": () => (/* binding */ ANCHOR),
/* harmony export */   "CLEOS": () => (/* binding */ CLEOS),
/* harmony export */   "CLIO": () => (/* binding */ CLIO),
/* harmony export */   "Constants": () => (/* binding */ Constants),
/* harmony export */   "DEFAULT_CHAIN": () => (/* binding */ DEFAULT_CHAIN),
/* harmony export */   "DEFAULT_SYMBOL": () => (/* binding */ DEFAULT_SYMBOL),
/* harmony export */   "DEFAULT_SYSTEM_DOMAIN": () => (/* binding */ DEFAULT_SYSTEM_DOMAIN),
/* harmony export */   "EOSAUTH": () => (/* binding */ EOSAUTH),
/* harmony export */   "EOSC": () => (/* binding */ EOSC),
/* harmony export */   "KEYCAT": () => (/* binding */ KEYCAT),
/* harmony export */   "LEDGER": () => (/* binding */ LEDGER),
/* harmony export */   "LEDGER_BLE": () => (/* binding */ LEDGER_BLE),
/* harmony export */   "LEDGER_USB": () => (/* binding */ LEDGER_USB),
/* harmony export */   "LEDGER_WEBHID": () => (/* binding */ LEDGER_WEBHID),
/* harmony export */   "LEDGER_WEBUSB": () => (/* binding */ LEDGER_WEBUSB),
/* harmony export */   "LYNX": () => (/* binding */ LYNX),
/* harmony export */   "PROTON": () => (/* binding */ PROTON),
/* harmony export */   "PROTON_WEB": () => (/* binding */ PROTON_WEB),
/* harmony export */   "SCATTER_DESKTOP": () => (/* binding */ SCATTER_DESKTOP),
/* harmony export */   "SCATTER_DESKTOP_MANUAL": () => (/* binding */ SCATTER_DESKTOP_MANUAL),
/* harmony export */   "SCATTER_EXTENSION": () => (/* binding */ SCATTER_EXTENSION),
/* harmony export */   "SIMPLEOS": () => (/* binding */ SIMPLEOS),
/* harmony export */   "SQRL": () => (/* binding */ SQRL),
/* harmony export */   "TREZOR": () => (/* binding */ TREZOR),
/* harmony export */   "WAX_CLOUD_WALLET": () => (/* binding */ WAX_CLOUD_WALLET),
/* harmony export */   "WOMBAT": () => (/* binding */ WOMBAT),
/* harmony export */   "chainInfo": () => (/* binding */ chainInfo),
/* harmony export */   "chainToNetworkConstantsMap": () => (/* binding */ chainToNetworkConstantsMap),
/* harmony export */   "constants": () => (/* binding */ constants$c),
/* harmony export */   "dapps": () => (/* binding */ dapps),
/* harmony export */   "exchanges": () => (/* binding */ exchanges),
/* harmony export */   "getContractConstants": () => (/* binding */ getContractConstants),
/* harmony export */   "historyTypesFeatures": () => (/* binding */ historyTypesFeatures)
/* harmony export */ });
var DEFAULT_SYMBOL = 'EOS';
var DEFAULT_SYSTEM_DOMAIN = 'eosio';
var DEFAULT_CHAIN = 'eos';

var getContractConstants = function getContractConstants(chain, systemDomain) {
  if (chain === void 0) {
    chain = DEFAULT_CHAIN;
  }

  if (systemDomain === void 0) {
    systemDomain = DEFAULT_SYSTEM_DOMAIN;
  }

  // Proxy Information Account
  var proxyInfo;

  if (['eos', 'bos', 'wax'].includes(chain)) {
    proxyInfo = 'regproxyinfo';
  } else if (chain === 'telos') {
    proxyInfo = 'tlsproxyinfo';
  }

  return {
    // Accounts
    EOSIO: systemDomain,
    EOSIO_TOKEN: !['fio', 'fio-test'].includes(chain) ? systemDomain + ".token" : 'fio.token',
    ACCOUNT_INFO: 'account.info',
    PROXY_INFO_ACCOUNT: proxyInfo,
    EOSIO_MSIG: systemDomain + ".msig",
    EOSIO_RAM: systemDomain + ".ram",
    EOSIO_STAKE: systemDomain + ".stake",
    EOSIO_PRODS: systemDomain + ".prods",
    EOSIO_NULL: systemDomain + ".null",
    EOSIO_RAMFEE: systemDomain + ".ramfee",
    EOSIO_VPAY: systemDomain + ".vpay",
    EOSIO_BPAY: systemDomain + ".bpay",
    EOSIO_REX: systemDomain + ".rex",
    // Params
    NEWACCOUNT_NAME_PARAM: chain.indexOf('bos') === -1 ? 'name' : 'newact',
    // Tables
    EOSIO_MSIG_APPROVALS_TABLE: 'approvals2',
    EOSIO_MSIG_PROPOSALS_TABLE: 'proposal',
    // Actions
    TRANSFER_ACTION: 'transfer',
    DELEGATE_BW_ACTION: 'delegatebw',
    UNDELEGATE_BW_ACTION: 'undelegatebw',
    VOTE_PRODUCER_ACTION: 'voteproducer',
    BUY_RAM_ACTION: 'buyram',
    BUY_RAM_BYTES_ACTION: 'buyrambyes',
    SELL_RAM_ACTION: 'sellram'
  };
};

var dapps = [{
  name: 'Alcor.exchange',
  description: 'The first self-listing DEX. With Alcor you can trade any EOS.IO tokens for system EOS tokens, atomically, without the participation of third parties! Create markets in one click, list your dapp token for one click, trade whatever you want.',
  shortDescription: 'The first self-listing DEX. With Alcor you can trade any EOS.IO tokens for system EOS tokens.',
  symbol: '',
  statistics: true,
  accounts: ['eostokensdex'],
  logo: 'https://i.ibb.co/dKDYDMc/vectorpaint.png',
  website: 'https://alcor.exchange/',
  app: 'https://alcor.exchange/',
  telegram: 'https://t.me/alcorexchange',
  medium: 'https://medium.com/@avral',
  twitter: 'https://twitter.com/avral_pro',
  github: 'https://github.com/avral/alcor-ui',
  chains: ['eos', 'wax', 'telos']
}, {
  name: 'SX',
  description: 'Building secure & reliable financial blockchain instruments',
  shortDescription: 'DeFi Swap & Flashloan',
  symbol: 'SX',
  accounts: ['swap.sx', 'vigor.sx', 'stable.sx', 'flash.sx', 'push.sx', 'network.sx', 'registry.sx', 'miner.sx', 'cross.sx', 'nav.sx', 'fee.sx', 'trade.sx', 'vaults.sx', 'proxy.sx', 'dust.sx', 'curve.sx'],
  logo: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/sx.png',
  website: 'https://github.com/stableex',
  app: 'https://xnation.io',
  telegram: 'https://t.me/xnationio',
  medium: '',
  twitter: '',
  github: 'https://github.com/stableex',
  chains: ['eos']
}, {
  name: 'EOSNameService',
  description: 'EOS Name Service is the most comprehensive platform to register premium/base EOS/WAX account names.',
  shortDescription: 'EOS/WAX Name Service',
  symbol: '',
  partner: false,
  accounts: ['names'],
  logo: 'https://avatars1.githubusercontent.com/u/73891041',
  website: 'http://eosnameservice.io',
  app: 'http://eosnameservice.io',
  telegram: 'https://t.me/eosnameservice',
  medium: '',
  twitter: 'https://twitter.com/eosnameservice',
  github: 'https://github.com/eosnameservice',
  chains: ['eos', 'wax']
}, {
  name: 'Prospectors',
  description: 'Massive Multiplayer Online Real-Time Economic Strategy Game  MINE GOLD - BUILD YOUR WORLD',
  shortDescription: 'Massive Multiplayer Online Real-Time Economic Strategy Game',
  symbol: '',
  accounts: ['prospectorsc'],
  logo: 'https://bloks.io/img/dapps/prospectors.png',
  website: 'https://prospectors.io',
  app: 'https://prospectors.io',
  telegram: 'https://t.me/prospectorsgame',
  medium: 'https://medium.com/@prospectorsgame',
  twitter: 'https://twitter.com/prospectorsgame',
  github: 'https://github.com/prospectors/public/issues',
  chains: ['eos']
}, {
  name: 'APPICS',
  description: 'APPICS is the most engaged social media dApp that makes it easy to get rewarded with cryptocurrency for your social media activity like creating & curating content. The mobile interface is intuitive to use without any prior blockchain knowledge. Get rewarded for your passion!',
  shortDescription: 'APPICS is the most engaged social media dApp - earn APX Tokens for posting, commenting, and up-voting photos & videos!',
  symbol: 'APX',
  statistics: true,
  accounts: ['appicsappics'],
  logo: 'https://i.imgur.com/Ts9CNN5.png',
  website: 'https://appics.com',
  app: 'https://appics.com',
  telegram: 'https://t.me/appics_official',
  medium: 'https://medium.com/@appics',
  twitter: 'https://twitter.com/appics_official',
  github: 'https://github.com/phenom-company/appics_eos_token',
  chains: ['eos']
}, {
  name: 'Boid',
  description: 'Contribute your excess computing resources towards important causes while earning rewards. Join a team and rank up on the social leaderboards.',
  shortDescription: 'The Social Supercomputer. Contribute your excess computing resources towards important causes.',
  symbol: '',
  accounts: ['boidcomtoken', 'boidcompower', 'boidcommint1', 'boidcompromo'],
  logo: 'https://raw.githubusercontent.com/boid-com/assets/master/boidLogo-lg.png',
  website: 'https://boid.com',
  app: 'https://app.boid.com',
  telegram: 'https://t.me/Boidcom_official',
  medium: 'https://medium.com/@boidcom',
  twitter: 'https://twitter.com/boidcom',
  github: 'https://github.com/boid-com',
  chains: ['eos']
}, {
  name: 'The Billionaire Token',
  description: 'Most other coins or tokens have some sort of mining system. Billionaire Token has the exact opposite: It features a deflationary mechanism that destroys 30% of the gambled coins. Thus the tokens become more and more rare as more and more people gamble.',
  shortDescription: 'Billionaire Token has the opposite of a mining system: It features a deflationary mechanism that destroys 30% of the gambled coins.',
  symbol: 'XBL',
  accounts: ['billionairet', 'billionraffl', 'billionburnr', 'billionbot11', 'billionbot12', 'billionbot13', 'billionbot14'],
  app: 'https://BillionaireToken.com/',
  logo: 'https://BillionaireToken.com/images/logo_big.png',
  website: 'https://BillionaireToken.com/',
  telegram: 'https://t.me/BillionaireToken',
  medium: 'https://medium.com/@billionaire_3373',
  twitter: 'https://twitter.com/BillionaireTkn',
  github: 'https://github.com/BillionaireToken',
  chains: ['eos']
}, {
  name: 'Crypto Sword & Magic',
  description: 'Crypto Sword & Magic is the first blockbuster RPG on EOS blockchain, traditional turn-based RPG raising heroes to challenge new dungeons. Game assets are recorded on Blockchain and transactions run on smart contracts',
  shortDescription: 'Crypto Sword & Magic is the first blockbuster RPG on EOS blockchain.',
  symbol: 'CSM',
  accounts: ['swordnmagicm'],
  app: 'https://www.cryptoswordandmagic.com',
  logo: 'https://bloks.io/img/dapps/cryptosnm.png',
  website: 'https://www.cryptoswordandmagic.com',
  telegram: 'https://t.me/cryptosnm_comm_en',
  medium: 'https://medium.com/@cryptoswordandmagic',
  twitter: 'https://twitter.com/sword_and_magic',
  github: '',
  chains: ['eos']
}, {
  name: 'dmail',
  description: 'Welcome to dmail Beta! We are so excited to have you participate as we launch our Beta platform. In the early stages we are covering the simplest of functionality, which is sending and receiving messages. In the very near future, we will be adding a bunch of new features which we know the community is going to ask for.',
  shortDescription: 'dmail is the first decentralized email on the blockchain',
  symbol: 'MAIL',
  statistics: true,
  accounts: ['dmaildotcobp'],
  logo: 'https://www.dmail.co/logosym_256.png',
  website: 'https://dmail.co',
  app: '',
  telegram: 'https://t.me/dmailcommunity',
  medium: 'https://medium.com/@dmail',
  twitter: 'https://twitter.com/dmaildotco',
  github: '',
  chains: ['eos', 'telos']
}, {
  name: 'Murmur',
  description: 'Murmur is a new age decentralized microblogging platform on EOS that is censorship-resistant, spam-proof and rewarding to use.',
  shortDescription: 'Murmur is a new age decentralized microblogging platform on EOS that is censorship-resistant, spam-proof and rewarding to use.',
  symbol: 'MUR',
  partner: true,
  accounts: ['murmurdappco', 'murmurtokens', 'murmurfreeac'],
  app: 'https://play.google.com/store/apps/details?id=com.murmurdapp',
  logo: 'https://bloks.io/img/dapps/murmur.png',
  website: 'http://murmurdapp.com',
  telegram: 'http://t.me/murmurdapp',
  medium: '',
  twitter: 'http://twitter.com/murmurdapp',
  github: '',
  chains: ['eos']
}, {
  name: 'Emanate',
  description: 'Emanate is EOS for the music industry. An automated, realtime music collaboration and monetisation platform.',
  shortDescription: 'Emanate is decentralised technology for the future of music',
  symbol: 'EMT',
  partner: true,
  accounts: ['emanateoneos', 'emanateissue'],
  app: 'https://emanate.live/',
  logo: 'https://bloks.io/img/dapps/emanate.png',
  website: 'https://emanate.live',
  telegram: 'https://t.me/emanateofficial',
  medium: '',
  twitter: 'https://twitter.com/emanateofficial',
  github: '',
  chains: ['eos']
}, {
  name: 'pixEOS',
  description: 'pixEOS is the first tokenized smart economy for gamers, artists and art enthusiasts.',
  shortDescription: 'pixEOS is the first tokenized smart economy for gamers, artists and art enthusiasts.',
  symbol: 'PIXEOS',
  partner: true,
  accounts: ['pixeos1token', 'pixeos1admin', 'pixeos1start'],
  app: 'https://pixeos.io',
  logo: 'https://bloks.io/img/dapps/pixeos.png',
  website: 'https://pixeos.io',
  telegram: 'https://t.me/PIXEOS',
  medium: '',
  twitter: 'https://twitter.com/eos_pix',
  github: '',
  chains: ['eos']
}, {
  name: 'Everipedia',
  description: 'The Everipedia team plans to build a modern, convenient and decentralized new encyclopedia website, and this goal will be realized with the development of blockchain technology. The new version of Everipedia under development will be based on the EOS network, which will have features such as community autonomy, shielding preventation, and contribution incentives compared to the current version of Everipedia. Founded in 2014, the business network encyclopedia Everipedia, whose name derives from the English words Everything and Encyclopedia, is owned by Everipedia.Inc and has not yet adopted blockchain technology. As of December 2017, Everipedia is the largest English encyclopedia with more than six million entries, including all English entries of Wikipedia. Everipedias requirements for attention are more relaxed, so it has more entries than Wikipedia.',
  shortDescription: 'The Everipedia team plans to build a modern, convenient and decentralized new encyclopedia.',
  symbol: 'IQ',
  partner: true,
  statistics: false,
  accounts: ['everipediaiq', 'eparticlectr'],
  logo: 'https://bloks.io/img/dapps/everipedia.jpg',
  website: '',
  app: 'https://everipedia.org',
  telegram: 'https://t.me/everipedia',
  medium: '',
  twitter: '',
  github: '',
  chains: ['eos']
}, {
  name: 'eosDAC',
  description: 'eosDAC is a Community Owned Blockproducer and a DAC enabler, born out of Dan Larimers concept of Decentralized Autonomous Communities or DACs, around which Block.one developed EOS software.  The vision of eosDAC is that EOS.IO block production should be open for everyone to contribute and benefit. To realize this vision, eosDAC is an evolving Decentralised Autonomous Community (DAC) focused on EOS.IO Block Production serving the EOS communities worldwide. In doing this, eosDAC is creating the tools and smart contracts it needs to function. It will share these with the EOS communities to help other DACs thrive on the EOS.IO blockchains.  In order to function as a DAC, eosDAC is creating open source tools and will be sharing them as a DAC Toolkit, that anyone can use, modify to setup and run a DAC.',
  shortDescription: 'eosDAC is creating open source tools and will be sharing them as a DAC Toolkit to enable DACs',
  symbol: 'EOSDAC',
  partner: false,
  statistics: false,
  accounts: ['eosdactokens', 'eosdacserver', 'eosdacthedac', 'daccustodian'],
  logo: 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/eosdac.png',
  website: '',
  app: 'members.eosdac.io',
  discord: 'https://discord.io/eosdac',
  telegram: 'https://t.me/eosdacio',
  medium: '',
  twitter: '',
  github: 'https://github.com/eosdac',
  chains: ['eos']
}, {
  name: 'DEOS Games',
  description: 'Deos Games are casino games built on EOS blockchain. Play zero edge games with our DEOS token and participate in bankroll staking.',
  shortDescription: 'Deos Games are casino games built on the EOS blockchain. Play zero edge games with DEOS token.',
  symbol: 'DEOS',
  statistics: false,
  accounts: ['thedeosgames', 'deosgameissu'],
  logo: 'https://bloks.io/img/dapps/deosgames.png',
  website: 'https://deosgames.com',
  app: 'https://app.deosgames.com',
  telegram: 'https://t.me/deosgameschat',
  medium: 'https://medium.com/deos-games',
  twitter: '',
  github: '',
  chains: ['eos']
}, {
  name: 'Chintai',
  description: 'Chintai is a community-owned, feeless, 100% on-chain, multisig decentralized token leasing platform where users can lend their EOS on the market to earn interest from other users to borrow who need access to CPU/NET bandwidth.',
  shortDescription: 'Chintai is a community-owned, feeless, 100% on-chain, multisig decentralized token leasing platform.',
  symbol: '',
  statistics: false,
  accounts: ['chintailease', 'chintaiproxy', 'bidchextoken', 'chexchexchex'],
  logo: 'https://bloks.io/img/dapps/chintai.png',
  website: 'http://chintai.io',
  app: 'https://eos.chintai.io/exchange/EOS28D',
  telegram: 'https://t.me/ChintaiEOS',
  medium: 'https://medium.com/@ChintaiEOS',
  twitter: 'https://twitter.com/chintaieos',
  github: 'https://github.com/chintai-platform',
  chains: ['eos']
}, {
  name: 'Newdex',
  description: 'Newdex is the first EOS based decentralized exchange in the world, upholding the characteristics of safe, fast and transparent, devoting to create a new-generation platform for digital assets exchange, leading the industry into an ideal new era.',
  shortDescription: 'Newdex is the first EOS based decentralized exchange in the world.',
  symbol: '',
  accounts: ['newdexpocket'],
  logo: 'https://bloks.io/img/dapps/newdex.png',
  website: 'https://newdex.io',
  app: 'https://newdex.io',
  telegram: '',
  medium: '',
  twitter: 'https://twitter.com/NewdexOfficial',
  github: '',
  chains: ['eos']
}, {
  name: 'EOS Name Swaps',
  description: 'An open-source EOS account exchange that puts the security of its users first.',
  shortDescription: 'An open-source EOS account exchange that puts the security of its users first.',
  symbol: '',
  statistics: false,
  accounts: ['eosnameswaps'],
  logo: 'https://bloks.io/img/dapps/eosnameswaps.png',
  website: 'https://www.eosnameswaps.com/',
  app: 'https://www.eosnameswaps.com/',
  telegram: 'https://t.me/eosnameswaps',
  medium: '',
  twitter: 'https://twitter.com/Starry3017Night',
  github: 'https://github.com/StarryJapanNight/eosnameswaps',
  chains: ['eos']
}];

var exchanges = {
  'Bithumb': {
    'name': 'Bithumb',
    'description': '비트코인, 이더리움, 비트코인캐시, 리플, 라이트코인, 대시, 모네로, 비트코인골드, 이오스, 이더리움클래식, 퀀텀, 제트캐시, 실시간 시세, 쉽고 안전한 거래.',
    'accounts': ['bithumbshiny'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.bithumb.com/'
  },
  'OKEx': {
    'name': 'OKEx',
    'description': 'OKEx is the leading global bitcoin exchange. Secured with bank-level SSL encryption and cold storage.',
    'accounts': ['okexoffiline'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.okex.com/'
  },
  'Bitfinex': {
    'name': 'Bitfinex',
    'description': 'Bitfinex is a full-featured spot trading platform for major digital assets & cryptocurrencies, including Bitcoin, Ethereum, EOS, Litecoin, Ripple, NEO, Monero and many more.',
    'accounts': ['bitfinexcw55', 'bitfinexcw13', 'bitfinexcw11', 'bitfinexcw24', 'bitfinexcw15', 'bitfinexcw32', 'bitfinexcw21', 'bitfinexcw31', 'bitfinexcw25', 'bitfinexcw23', 'bitfinexcw33', 'bitfinexcw22', 'bitfinexcw12', 'bitfinexcw14'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://bitfinex.com/'
  },
  'Gate.io': {
    'name': 'Gate.io',
    'description': 'Gate.io is a bitcoin exchange platform which supports BTC, LTC, Ethereum, Qtum and more blockchain assets trading.',
    'accounts': ['gateiowallet'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.gate.io/'
  },
  'Kraken': {
    'name': 'Kraken',
    'description': 'Buy, sell and margin trade Bitcoin (BTC) and Etherum (ETH) in exchange with EUR, USD, CAD, GBP, and JPY.',
    'accounts': ['krakenkraken'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.kraken.com/'
  },
  'Newdex': {
    'name': 'Newdex',
    'description': 'The first EOS based decentralized exchange in the world.',
    'accounts': ['newdexpocket'],
    'logo': '/img/exchanges/newdex.png',
    'website': 'https://newdex.io/',
    linkGenerator: function linkGenerator(token, pair) {
      return "https://newdex.io/trade/" + token.account + "-" + pair.pair_base.toLowerCase() + "-" + pair.pair_quote.toLowerCase();
    }
  },
  'DefiBox': {
    'name': 'DefiBox',
    'description': 'One-stop DeFi application platform on EOS..',
    'accounts': ['token.defi', 'swap.defi'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/token.defi-box.png',
    'website': 'https://defibox.io/',
    linkGenerator: function linkGenerator(_, __) {
      return "https://defibox.io/";
    }
  },
  'Chaince': {
    'name': 'Chaince',
    'description': 'A Superior Blockchain Asset Trading Platform Focusing on EOS Projects',
    'accounts': ['chainceoneos'],
    'logo': '/img/exchanges/chaince.png',
    'website': 'https://chaince.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://chaince.com/trade/" + pair.pair_base.toLowerCase() + pair.pair_quote.toLowerCase();
    }
  },
  'Dexeos': {
    'name': 'Dexeos',
    'description': 'The World\'s First EOS-based Decentralized Exchange',
    'accounts': ['dexeoswallet'],
    'logo': '/img/exchanges/dexeos.svg',
    'website': 'https://dexeos.io/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://dexeos.io/trade/" + pair.pair_base.toUpperCase();
    }
  },
  'Hoo': {
    'name': 'Hoo',
    'description': 'One-stop blockchain asset service platform',
    'accounts': ['hoo.com'],
    'logo': '/img/exchanges/hoo.jpg',
    'website': 'https://hoo.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://hoo.com/trade/" + pair.pair_base.toLowerCase() + "-" + pair.pair_quote.toLowerCase();
    }
  },
  'Whaleex': {
    'name': 'Whaleex',
    'description': '#1 Decentralized Exchange in the World',
    'accounts': ['whaleextrust'],
    'logo': '/img/exchanges/whaleex.png',
    'website': 'https://www.whaleex.com',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://www.whaleex.com/trade/" + pair.pair_base + "_" + pair.pair_quote;
    }
  },
  'Chainrift': {
    'name': 'Chainrift',
    'description': 'A marketplace for digital currencies',
    'accounts': [],
    'logo': '/img/exchanges/chainrift.png',
    'website': 'https://www.chainrift.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://www.chainrift.com/trading?coinpair=" + pair.pair_base + "/" + pair.pair_quote;
    }
  },
  'Eosdaq': {
    'name': 'EOSDAQ',
    'description': 'A Standard of On-Chain DEX',
    'accounts': [],
    'logo': '/img/exchanges/eosdaq.png',
    'website': 'https://www.eosdaq.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://eosdaq.com/exchange/" + pair.pair_base + "_" + pair.pair_quote;
    }
  },
  'BigONE': {
    'name': 'BigONE',
    'description': 'A Standard of On-Chain DEX',
    'accounts': [],
    'logo': '/img/exchanges/bigONE.jpg',
    'website': 'https://big.one',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://big.one/trade/" + pair.pair_base + "-" + pair.pair_quote;
    }
  },
  'YOLO': {
    'name': 'YOLO',
    'description': 'Instant Token Swaps on EOS',
    'accounts': [],
    'logo': '/img/exchanges/yolo.png',
    'website': 'https://yoloswap.com',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://yoloswap.com/swap/" + pair.pair_quote.toLowerCase() + "-" + pair.pair_base.toLowerCase();
    }
  },
  'Bancor': {
    'name': 'Bancor',
    'description': 'Instant Liquidity.',
    'accounts': [],
    'logo': '/img/exchanges/bancor.png',
    'website': 'https://bancor.network',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://www.bancor.network/token/" + pair.pair_base;
    }
  },
  'Alcor': {
    'name': 'Alcor',
    'description': 'The first self-listing decentralized exchange',
    'accounts': [],
    'logo': '/img/exchanges/alcor.png',
    'website': 'https://alcor.exchange',
    linkGenerator: function linkGenerator(_, __) {
      return "https://www.alcor.exchange/markets";
    }
  },
  'Defis.Network': {
    'name': 'Defis.Network',
    'description': 'An open finance network that integrates a series of DeFi protocols',
    'accounts': [],
    'logo': '/img/exchanges/defis-uncache.png',
    'website': 'https://defis.network',
    linkGenerator: function linkGenerator(_, __) {
      return "https://apps.defis.network/";
    }
  },
  'DolphinSwap': {
    'name': 'DolphinSwap',
    'description': 'DolphinSwap',
    'accounts': [],
    'logo': '/img/exchanges/dolphinswap.png',
    'website': 'https://dolphinswap.io/exchange',
    linkGenerator: function linkGenerator(_, __) {
      return 'https://dolphinswap.io/exchange';
    }
  },
  'Proton': {
    'name': 'ProtonSwap',
    'description': 'ProtonSwap',
    'accounts': [],
    'logo': '/img/exchanges/protonswap.png',
    'website': 'https://protonswap.com',
    linkGenerator: function linkGenerator(_, __) {
      return 'https://protonswap.com';
    }
  },
  'Coingecko': {
    'name': 'CoinGecko',
    'description': 'CoinGecko',
    'accounts': [],
    'logo': '/img/exchanges/coingecko.png',
    'website': 'https://coingecko.com',
    linkGenerator: function linkGenerator(_, __) {
      return 'https://coingecko.com';
    }
  }
};

var SCATTER_DESKTOP = 'ScatterSockets';
var SCATTER_DESKTOP_MANUAL = 'ScatterSocketsManual';
var SCATTER_EXTENSION = 'ScatterExtension';
var LEDGER = 'ledger';
var LEDGER_USB = 'TransportU2F';
var LEDGER_BLE = 'TransportWebBLE';
var LEDGER_WEBUSB = 'TransportWebusb';
var LEDGER_WEBHID = 'TransportWebHID';
var LYNX = 'lynx';
var PROTON = 'proton';
var PROTON_WEB = 'protonweb';
var ANCHOR = 'anchor';
var SIMPLEOS = 'simpleos';
var EOSAUTH = 'eosauth';
var CLEOS = 'cleos';
var EOSC = 'eosc';
var CLIO = 'clio';
var KEYCAT = 'keycat';
var TREZOR = 'trezor';
var SQRL = 'sqrl';
var WOMBAT = 'wombat';
var WAX_CLOUD_WALLET = 'WaxCW';

var historyTypesFeatures = {
  "native": {
    name: 'native',
    actionFilter: false,
    tokenFilter: false,
    dateFilter: false,
    contractActionFilter: false,
    total: 0
  },
  dfuse: {
    name: 'dfuse',
    actionFilter: true,
    tokenFilter: true,
    dateFilter: true,
    contractActionFilter: true,
    total: 4
  },
  hyperion: {
    name: 'hyperion',
    actionFilter: true,
    tokenFilter: true,
    dateFilter: true,
    contractActionFilter: true,
    total: 3
  }
};

var _chainInfo;

var chainInfo = (_chainInfo = {}, _chainInfo['proton-test'] = {
  key: 'proton-test',
  text: 'Proton Testnet',
  value: 'https://testnet.protonscan.io',
  image: '/img/chains/proton.png',
  testnet: true
}, _chainInfo.local = {
  key: 'local',
  text: 'Local Testnet',
  value: 'https://local.bloks.io',
  image: '/img/chains/local.png',
  testnet: true
}, _chainInfo['wax-test'] = {
  key: 'wax-test',
  text: 'WAX Testnet',
  value: 'https://wax-test.bloks.io',
  image: '/img/chains/wax.png',
  testnet: true
}, _chainInfo['fio-test'] = {
  key: 'fio-test',
  text: 'FIO Testnet',
  value: 'https://fio-test.bloks.io',
  image: '/img/chains/fio.png',
  testnet: true
}, _chainInfo.jungle3 = {
  key: 'jungle3',
  text: 'Jungle3 Testnet',
  value: 'https://jungle3.bloks.io',
  image: '/img/chains/jungle.png',
  testnet: true
}, _chainInfo.kylin = {
  key: 'kylin',
  text: 'Kylin Testnet',
  value: 'https://kylin.bloks.io',
  image: '/img/chains/kylin.png',
  testnet: true
}, _chainInfo.proton = {
  key: 'proton',
  text: 'Proton',
  value: 'https://protonscan.io',
  image: '/img/chains/proton.png'
}, _chainInfo.eos = {
  key: 'eos',
  text: 'EOS',
  value: 'https://bloks.io',
  image: '/img/chains/eos.png'
}, _chainInfo.wax = {
  key: 'wax',
  text: 'WAX',
  value: 'https://wax.bloks.io',
  image: '/img/chains/wax.png'
}, _chainInfo.fio = {
  key: 'fio',
  text: 'FIO',
  value: 'https://fio.bloks.io',
  image: '/img/chains/fio.png'
}, _chainInfo);

var getCommonConstants = function getCommonConstants(chain) {
  return {
    MAX_RPC_SYNC_SECONDS_BEHIND: 20,
    IMAGE_PROXY: 'https://www.api.bloks.io/image-proxy',
    WRAP_CONTRACT: 'proton.wrap',
    BLOKS_API: 'https://www.api.bloks.io',
    ESR_PROTOCOL: chain === 'proton' ? 'proton' : 'proton-dev',
    METAL_PROTON_ENDPOINT: chain === 'proton' ? 'https://api.protonchain.com' : 'https://api-dev.protonchain.com',
    SWAP_URL: chain === 'proton' ? 'https://otc.protonswap.com' : 'https://otc-test.protonswap.com',
    WRAP_SERVER_URL: chain === 'proton' ? 'https://www.api.bloks.io/proton-wrap-public2' : 'https://www.api.bloks.io/proton-wrap-testnet-public2'
  };
};

var generateProviderEndpoints = function generateProviderEndpoints(chainId, actionEndpoints) {
  return [{
    chainId: chainId,
    port: 443,
    protocol: 'https',
    host: actionEndpoints[0].substr(8),
    httpEndpoint: actionEndpoints[0],
    blockchain: 'eos'
  }];
};

var DEFAULT_ENDPOINTS = ['https://eos.greymass.com', 'https://eos.eoscafeblock.com', 'https://api.main.alohaeos.com', 'https://api.eossweden.org'];
var ACTIONS_ENDPOINTS = ['https://eos.greymass.com'];
var TRANSACTIONS_ENDPOINTS = ['https://eos.greymass.com', 'https://api.eossweden.org'];
var ALOHA_PROXY_URL = 'https://www.alohaeos.com/vote/proxy';
var API_URL = 'https://www.api.bloks.io';
var ATOMICASSETS_API = 'https://eos.api.atomicassets.io';
var BLOKS_PROXY = 'bloksioproxy';
var CHAIN = 'eos';
var CHAIN_ID = 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906';
var CHAIN_START_DATE = /*#__PURE__*/new Date('2018-06-08');
var CORE_PRECISION = 4;
var CORE_SYMBOL = 'EOS';
var DISPLAY_CHAIN = 'EOS';
var DOMAIN_TITLE = 'EOS Bloks.io';
var HISTORY_TYPES = ['native', 'hyperion'];
var HYPERION_URL = 'https://eos.hyperion.eosrio.io';
var KEY_PREFIX = 'EOS';
var LIGHT_API = 'https://api.light.xeos.me';
var NFTS_ENABLED = true;
var PROVIDER_ENDPOINTS = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID, ACTIONS_ENDPOINTS);
var REX_ENABLED = true;
var SIMPLEASSETS_API = 'https://eos.api.simpleassets.io';
var SUPPORTS_FREE_CPU = true;
var SUPPORTS_RENTBW = true;
var VOTING_ENABLED = true;
var constants = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS,
  ALOHA_PROXY_URL: ALOHA_PROXY_URL,
  API_URL: API_URL,
  ATOMICASSETS_API: ATOMICASSETS_API,
  BLOKS_PROXY: BLOKS_PROXY,
  CHAIN: CHAIN,
  CHAIN_ID: CHAIN_ID,
  CHAIN_START_DATE: CHAIN_START_DATE,
  CORE_PRECISION: CORE_PRECISION,
  CORE_SYMBOL: CORE_SYMBOL,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS,
  DISPLAY_CHAIN: DISPLAY_CHAIN,
  DOMAIN_TITLE: DOMAIN_TITLE,
  HISTORY_TYPES: HISTORY_TYPES,
  HYPERION_URL: HYPERION_URL,
  KEY_PREFIX: KEY_PREFIX,
  LIGHT_API: LIGHT_API,
  NFTS_ENABLED: NFTS_ENABLED,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS,
  REX_ENABLED: REX_ENABLED,
  SIMPLEASSETS_API: SIMPLEASSETS_API,
  SUPPORTS_FREE_CPU: SUPPORTS_FREE_CPU,
  SUPPORTS_RENTBW: SUPPORTS_RENTBW,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS,
  VOTING_ENABLED: VOTING_ENABLED
};

var DEFAULT_ENDPOINTS$1 = ['https://wax.greymass.com', 'https://wax.eoscafeblock.com', 'https://api.waxsweden.org', 'https://chain.wax.io', 'https://wax.eosrio.io'];
var ACTIONS_ENDPOINTS$1 = ['https://wax.greymass.com', 'https://api.waxsweden.org', 'https://wax.eosrio.io', 'https://chain.wax.io'];
var TRANSACTIONS_ENDPOINTS$1 = ['https://wax.greymass.com', 'https://api.waxsweden.org', 'https://wax.eosrio.io', 'https://chain.wax.io'];
var ALOHA_PROXY_URL$1 = 'https://www.alohaeos.com/vote/proxy/waxmain';
var API_URL$1 = 'https://www.api.bloks.io/wax';
var ATOMICASSETS_API$1 = 'https://wax.api.atomicassets.io';
var BLOKS_PROXY$1 = 'bloksioproxy';
var CHAIN$1 = 'wax';
var CHAIN_ID$1 = '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4';
var CHAIN_START_DATE$1 = /*#__PURE__*/new Date('2019-06-24');
var CORE_PRECISION$1 = 8;
var CORE_SYMBOL$1 = 'WAX';
var DISPLAY_CHAIN$1 = 'WAX';
var DOMAIN_TITLE$1 = 'WAX | Bloks.io';
var HISTORY_TYPES$1 = ['native', 'hyperion'];
var HYPERION_URL$1 = 'https://wax.eosrio.io';
var KEY_PREFIX$1 = 'EOS';
var LIGHT_API$1 = 'https://lightapi.eosamsterdam.net';
var NFTS_ENABLED$1 = true;
var PROVIDER_ENDPOINTS$1 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$1, ACTIONS_ENDPOINTS$1);
var SIMPLEASSETS_API$1 = 'https://wax.api.simpleassets.io';
var VOTING_ENABLED$1 = true;
var constants$1 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$1,
  ALOHA_PROXY_URL: ALOHA_PROXY_URL$1,
  API_URL: API_URL$1,
  ATOMICASSETS_API: ATOMICASSETS_API$1,
  BLOKS_PROXY: BLOKS_PROXY$1,
  CHAIN: CHAIN$1,
  CHAIN_ID: CHAIN_ID$1,
  CHAIN_START_DATE: CHAIN_START_DATE$1,
  CORE_PRECISION: CORE_PRECISION$1,
  CORE_SYMBOL: CORE_SYMBOL$1,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$1,
  DISPLAY_CHAIN: DISPLAY_CHAIN$1,
  DOMAIN_TITLE: DOMAIN_TITLE$1,
  HISTORY_TYPES: HISTORY_TYPES$1,
  HYPERION_URL: HYPERION_URL$1,
  KEY_PREFIX: KEY_PREFIX$1,
  LIGHT_API: LIGHT_API$1,
  NFTS_ENABLED: NFTS_ENABLED$1,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$1,
  SIMPLEASSETS_API: SIMPLEASSETS_API$1,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$1,
  VOTING_ENABLED: VOTING_ENABLED$1
};

var DEFAULT_ENDPOINTS$2 = ['https://proton.greymass.com', 'https://proton.cryptolions.io', 'https://proton.eosusa.news', "https://frankfurt.protondata.net"];
var TRANSACTIONS_ENDPOINTS$2 = ['https://proton.greymass.com', 'https://proton.cryptolions.io'];
var ACTIONS_ENDPOINTS$2 = ['https://proton.greymass.com'];
var API_URL$2 = 'https://www.api.bloks.io/proton';
var ATOMICASSETS_API$2 = 'https://proton.api.atomicassets.io';
var CHAIN$2 = 'proton';
var CHAIN_ID$2 = '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0';
var CHAIN_START_DATE$2 = /*#__PURE__*/new Date('Apr 22, 2020');
var CORE_PRECISION$2 = 4;
var CORE_SYMBOL$2 = 'XPR';
var DISPLAY_CHAIN$2 = 'Proton';
var DOMAIN_TITLE$2 = 'ProtonScan';
var HISTORY_TYPES$2 = ['native', 'hyperion'];
var HYPERION_URL$2 = 'http://proton.pink.gg';
var KEY_PREFIX$2 = 'EOS';
var LIGHT_API$2 = 'https://lightapi.eosamsterdam.net';
var MAX_VOTES = 4;
var NFTS_ENABLED$2 = true;
var PROVIDER_ENDPOINTS$2 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$2, ACTIONS_ENDPOINTS$2);
var VOTING_ENABLED$2 = true;
var constants$2 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$2,
  API_URL: API_URL$2,
  ATOMICASSETS_API: ATOMICASSETS_API$2,
  CHAIN: CHAIN$2,
  CHAIN_ID: CHAIN_ID$2,
  CHAIN_START_DATE: CHAIN_START_DATE$2,
  CORE_PRECISION: CORE_PRECISION$2,
  CORE_SYMBOL: CORE_SYMBOL$2,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$2,
  DISPLAY_CHAIN: DISPLAY_CHAIN$2,
  DOMAIN_TITLE: DOMAIN_TITLE$2,
  HISTORY_TYPES: HISTORY_TYPES$2,
  HYPERION_URL: HYPERION_URL$2,
  KEY_PREFIX: KEY_PREFIX$2,
  LIGHT_API: LIGHT_API$2,
  MAX_VOTES: MAX_VOTES,
  NFTS_ENABLED: NFTS_ENABLED$2,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$2,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$2,
  VOTING_ENABLED: VOTING_ENABLED$2
};

var DEFAULT_ENDPOINTS$3 = ['https://fio.greymass.com', 'https://fio.eossweden.org', 'https://fio.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$3 = ['https://fio.greymass.com', 'https://fio.eossweden.org', 'https://fio.eosusa.news'];
var ACTIONS_ENDPOINTS$3 = ['https://fio.greymass.com', 'https://fio.eossweden.org', 'https://fio.eosusa.news'];
var ALOHA_PROXY_URL$2 = 'https://www.alohaeos.com/vote/proxy/fiomain';
var API_URL$3 = 'https://www.api.bloks.io/fio';
var CHAIN$3 = 'fio';
var CHAIN_ID$3 = '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c';
var CHAIN_START_DATE$3 = /*#__PURE__*/new Date('Mar 24, 2020');
var CORE_PRECISION$3 = 9;
var CORE_SYMBOL$3 = 'FIO';
var DISABLE_MEMO = true;
var DISPLAY_CHAIN$3 = 'FIO';
var DOMAIN_TITLE$3 = 'FIO Bloks.io';
var FIO_FEES_ACCOUNT = 'fees@bloks';
var HISTORY_TYPES$3 = ['native', 'hyperion'];
var HYPERION_URL$3 = 'https://fio.eossweden.org';
var KEY_PREFIX$3 = 'FIO';
var PROVIDER_ENDPOINTS$3 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$3, ACTIONS_ENDPOINTS$3);
var VOTING_ENABLED$3 = true;
var constants$3 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$3,
  ALOHA_PROXY_URL: ALOHA_PROXY_URL$2,
  API_URL: API_URL$3,
  CHAIN: CHAIN$3,
  CHAIN_ID: CHAIN_ID$3,
  CHAIN_START_DATE: CHAIN_START_DATE$3,
  CORE_PRECISION: CORE_PRECISION$3,
  CORE_SYMBOL: CORE_SYMBOL$3,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$3,
  DISABLE_MEMO: DISABLE_MEMO,
  DISPLAY_CHAIN: DISPLAY_CHAIN$3,
  DOMAIN_TITLE: DOMAIN_TITLE$3,
  FIO_FEES_ACCOUNT: FIO_FEES_ACCOUNT,
  HISTORY_TYPES: HISTORY_TYPES$3,
  HYPERION_URL: HYPERION_URL$3,
  KEY_PREFIX: KEY_PREFIX$3,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$3,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$3,
  VOTING_ENABLED: VOTING_ENABLED$3
};

var DEFAULT_ENDPOINTS$4 = [];
var ACTIONS_ENDPOINTS$4 = [];
var TRANSACTIONS_ENDPOINTS$4 = [];
var API_URL$4 = '';
var CHAIN$4 = 'local';
var CHAIN_ID$4 = '';
var CHAIN_START_DATE$4 = undefined;
var CORE_PRECISION$4 = 4;
var CORE_SYMBOL$4 = 'EOS';
var DISPLAY_CHAIN$4 = 'Local';
var DOMAIN_TITLE$4 = 'Local Bloks.io';
var HISTORY_TYPES$4 = ['native'];
var KEY_PREFIX$4 = 'EOS';
var PROVIDER_ENDPOINTS$4 = [];
var VOTING_ENABLED$4 = true;
var constants$4 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$4,
  API_URL: API_URL$4,
  CHAIN: CHAIN$4,
  CHAIN_ID: CHAIN_ID$4,
  CHAIN_START_DATE: CHAIN_START_DATE$4,
  CORE_PRECISION: CORE_PRECISION$4,
  CORE_SYMBOL: CORE_SYMBOL$4,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$4,
  DISPLAY_CHAIN: DISPLAY_CHAIN$4,
  DOMAIN_TITLE: DOMAIN_TITLE$4,
  HISTORY_TYPES: HISTORY_TYPES$4,
  KEY_PREFIX: KEY_PREFIX$4,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$4,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$4,
  VOTING_ENABLED: VOTING_ENABLED$4
};

var DEFAULT_ENDPOINTS$5 = [// 'https://jungleapi.eossweden.org',
'https://api.jungle.alohaeos.com', 'https://jungle2.cryptolions.io', 'https://jungle.eosphere.io', 'https://eos-jungle.eosblocksmith.io'];
var ACTIONS_ENDPOINTS$5 = ['https://jungle.eossweden.org'];
var TRANSACTIONS_ENDPOINTS$5 = ['https://jungle.eossweden.org'];
var API_URL$5 = 'https://www.api.bloks.io/jungle';
var BLOKS_PROXY$2 = 'blokspartner';
var CHAIN$5 = 'jungle';
var CHAIN_ID$5 = 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473';
var CHAIN_START_DATE$5 = /*#__PURE__*/new Date('Nov 23, 2018');
var CORE_PRECISION$5 = 4;
var CORE_SYMBOL$5 = 'EOS';
var DISPLAY_CHAIN$5 = 'Jungle';
var DOMAIN_TITLE$5 = 'Jungle Bloks.io';
var HISTORY_TYPES$5 = ['hyperion', 'native'];
var HYPERION_URL$4 = 'https://jungle2.cryptolions.io';
var KEY_PREFIX$5 = 'EOS';
var LIGHT_API$3 = 'https://lightapi.eosgeneva.io';
var NFTS_ENABLED$3 = true;
var PROVIDER_ENDPOINTS$5 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$5, ACTIONS_ENDPOINTS$5);
var REX_ENABLED$1 = true;
var VOTING_ENABLED$5 = true;
var constants$5 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$5,
  API_URL: API_URL$5,
  BLOKS_PROXY: BLOKS_PROXY$2,
  CHAIN: CHAIN$5,
  CHAIN_ID: CHAIN_ID$5,
  CHAIN_START_DATE: CHAIN_START_DATE$5,
  CORE_PRECISION: CORE_PRECISION$5,
  CORE_SYMBOL: CORE_SYMBOL$5,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$5,
  DISPLAY_CHAIN: DISPLAY_CHAIN$5,
  DOMAIN_TITLE: DOMAIN_TITLE$5,
  HISTORY_TYPES: HISTORY_TYPES$5,
  HYPERION_URL: HYPERION_URL$4,
  KEY_PREFIX: KEY_PREFIX$5,
  LIGHT_API: LIGHT_API$3,
  NFTS_ENABLED: NFTS_ENABLED$3,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$5,
  REX_ENABLED: REX_ENABLED$1,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$5,
  VOTING_ENABLED: VOTING_ENABLED$5
};

var DEFAULT_ENDPOINTS$6 = ['https://jungle3.cryptolions.io', 'https://api.jungle3.alohaeos.com', 'https://jungle3.eosusa.news'];
var ACTIONS_ENDPOINTS$6 = ['https://jungle3.cryptolions.io', 'https://jungle3.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$6 = ['https://jungle3.cryptolions.io', 'https://jungle3.eosusa.news'];
var API_URL$6 = 'https://www.api.bloks.io/jungle3';
var CHAIN$6 = 'jungle3';
var CHAIN_ID$6 = '2a02a0053e5a8cf73a56ba0fda11e4d92e0238a4a2aa74fccf46d5a910746840';
var CHAIN_START_DATE$6 = /*#__PURE__*/new Date('Feb 19, 2020');
var CORE_PRECISION$6 = 4;
var CORE_SYMBOL$6 = 'EOS';
var DISPLAY_CHAIN$6 = 'Jungle 3';
var DOMAIN_TITLE$6 = 'Jungle 3 Bloks.io';
var HISTORY_TYPES$6 = ['hyperion'];
var HYPERION_URL$5 = 'https://jungle3.cryptolions.io';
var KEY_PREFIX$6 = 'EOS';
var PROVIDER_ENDPOINTS$6 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$6, ACTIONS_ENDPOINTS$6);
var REX_ENABLED$2 = true;
var SUPPORTS_RENTBW$1 = true;
var VOTING_ENABLED$6 = true;
var constants$6 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$6,
  API_URL: API_URL$6,
  CHAIN: CHAIN$6,
  CHAIN_ID: CHAIN_ID$6,
  CHAIN_START_DATE: CHAIN_START_DATE$6,
  CORE_PRECISION: CORE_PRECISION$6,
  CORE_SYMBOL: CORE_SYMBOL$6,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$6,
  DISPLAY_CHAIN: DISPLAY_CHAIN$6,
  DOMAIN_TITLE: DOMAIN_TITLE$6,
  HISTORY_TYPES: HISTORY_TYPES$6,
  HYPERION_URL: HYPERION_URL$5,
  KEY_PREFIX: KEY_PREFIX$6,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$6,
  REX_ENABLED: REX_ENABLED$2,
  SUPPORTS_RENTBW: SUPPORTS_RENTBW$1,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$6,
  VOTING_ENABLED: VOTING_ENABLED$6
};

var DEFAULT_ENDPOINTS$7 = ['https://kylin.eosn.io'];
var ACTIONS_ENDPOINTS$7 = ['https://kylin.eosn.io'];
var TRANSACTIONS_ENDPOINTS$7 = ['https://kylin.eosn.io'];
var API_URL$7 = 'https://www.api.bloks.io/kylin';
var BLOKS_PROXY$3 = 'blokspartner';
var CHAIN$7 = 'kylin';
var CHAIN_ID$7 = '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191';
var CHAIN_START_DATE$7 = /*#__PURE__*/new Date('Jul 10, 2018');
var CORE_PRECISION$7 = 4;
var CORE_SYMBOL$7 = 'EOS';
var DISPLAY_CHAIN$7 = 'Kylin';
var DOMAIN_TITLE$7 = 'Kylin Bloks.io';
var HISTORY_TYPES$7 = ['hyperion', 'native'];
var HYPERION_URL$6 = 'https://kylin.eosusa.news';
var KEY_PREFIX$7 = 'EOS';
var PROVIDER_ENDPOINTS$7 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$7, ACTIONS_ENDPOINTS$7);
var VOTING_ENABLED$7 = true;
var constants$7 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$7,
  API_URL: API_URL$7,
  BLOKS_PROXY: BLOKS_PROXY$3,
  CHAIN: CHAIN$7,
  CHAIN_ID: CHAIN_ID$7,
  CHAIN_START_DATE: CHAIN_START_DATE$7,
  CORE_PRECISION: CORE_PRECISION$7,
  CORE_SYMBOL: CORE_SYMBOL$7,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$7,
  DISPLAY_CHAIN: DISPLAY_CHAIN$7,
  DOMAIN_TITLE: DOMAIN_TITLE$7,
  HISTORY_TYPES: HISTORY_TYPES$7,
  HYPERION_URL: HYPERION_URL$6,
  KEY_PREFIX: KEY_PREFIX$7,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$7,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$7,
  VOTING_ENABLED: VOTING_ENABLED$7
};

var DEFAULT_ENDPOINTS$8 = ['https://www.api.bloks.io/eos-test-node'];
var ACTIONS_ENDPOINTS$8 = ['https://www.api.bloks.io/eos-test-node'];
var TRANSACTIONS_ENDPOINTS$8 = ['https://www.api.bloks.io/eos-test-node'];
var API_URL$8 = 'https://www.api.bloks.io/eos-test';
var CHAIN$8 = 'eos-test';
var CHAIN_ID$8 = '0db13ab9b321c37c0ba8481cb4681c2788b622c3abfd1f12f0e5353d44ba6e72';
var CHAIN_START_DATE$8 = /*#__PURE__*/new Date('2020-01-14');
var CORE_PRECISION$8 = 4;
var CORE_SYMBOL$8 = 'TNT';
var DISPLAY_CHAIN$8 = 'EOSIO Test';
var DOMAIN_TITLE$8 = 'Bloks.io';
var HISTORY_TYPES$8 = ['native'];
var KEY_PREFIX$8 = 'EOS';
var PROVIDER_ENDPOINTS$8 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$8, ACTIONS_ENDPOINTS$8);
var constants$8 = {
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$8,
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$8,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$8,
  API_URL: API_URL$8,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$8,
  CORE_SYMBOL: CORE_SYMBOL$8,
  CHAIN: CHAIN$8,
  DISPLAY_CHAIN: DISPLAY_CHAIN$8,
  HISTORY_TYPES: HISTORY_TYPES$8,
  CHAIN_ID: CHAIN_ID$8,
  DOMAIN_TITLE: DOMAIN_TITLE$8,
  CHAIN_START_DATE: CHAIN_START_DATE$8,
  KEY_PREFIX: KEY_PREFIX$8,
  CORE_PRECISION: CORE_PRECISION$8
};

var DEFAULT_ENDPOINTS$9 = ['https://protontestnet.greymass.com', 'https://proton-testnet.eoscafeblock.com', 'https://testnet.protonchain.com', 'https://test.proton.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$9 = ['https://protontestnet.greymass.com', 'https://testnet.protonchain.com', 'https://test.proton.eosusa.news'];
var ACTIONS_ENDPOINTS$9 = ['https://protontestnet.greymass.com', 'https://testnet.protonchain.com', 'https://test.proton.eosusa.news'];
var API_URL$9 = 'https://www.api.bloks.io/proton-test';
var ATOMICASSETS_API$3 = 'https://test.proton.api.atomicassets.io';
var CHAIN$9 = 'proton-test';
var CHAIN_ID$9 = '71ee83bcf52142d61019d95f9cc5427ba6a0d7ff8accd9e2088ae2abeaf3d3dd';
var CHAIN_START_DATE$9 = /*#__PURE__*/new Date('April 3, 2020');
var CORE_PRECISION$9 = 4;
var CORE_SYMBOL$9 = 'XPR';
var DISPLAY_CHAIN$9 = 'Proton-T';
var DOMAIN_TITLE$9 = 'Proton Testnet';
var HISTORY_TYPES$9 = ['hyperion', 'native'];
var HYPERION_URL$7 = 'https://testnet.proton.pink.gg';
var KEY_PREFIX$9 = 'EOS';
var MAX_VOTES$1 = 4;
var PROVIDER_ENDPOINTS$9 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$9, ACTIONS_ENDPOINTS$9);
var VOTING_ENABLED$8 = true;
var constants$9 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$9,
  API_URL: API_URL$9,
  ATOMICASSETS_API: ATOMICASSETS_API$3,
  CHAIN: CHAIN$9,
  CHAIN_ID: CHAIN_ID$9,
  CHAIN_START_DATE: CHAIN_START_DATE$9,
  CORE_PRECISION: CORE_PRECISION$9,
  CORE_SYMBOL: CORE_SYMBOL$9,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$9,
  DISPLAY_CHAIN: DISPLAY_CHAIN$9,
  DOMAIN_TITLE: DOMAIN_TITLE$9,
  HISTORY_TYPES: HISTORY_TYPES$9,
  HYPERION_URL: HYPERION_URL$7,
  KEY_PREFIX: KEY_PREFIX$9,
  MAX_VOTES: MAX_VOTES$1,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$9,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$9,
  VOTING_ENABLED: VOTING_ENABLED$8
};

var DEFAULT_ENDPOINTS$a = ['https://testnet.wax.eosdetroit.io', 'https://testnet.wax.pink.gg', 'https://testnet.waxsweden.org'];
var TRANSACTIONS_ENDPOINTS$a = ['https://testnet.wax.eosdetroit.io', 'https://testnet.wax.pink.gg', 'https://testnet.waxsweden.org'];
var ACTIONS_ENDPOINTS$a = ['https://testnet.wax.eosdetroit.io', 'https://testnet.wax.pink.gg', 'https://testnet.waxsweden.org'];
var API_URL$a = 'https://www.api.bloks.io/wax-test';
var ATOMICASSETS_API$4 = 'https://test.wax.api.atomicassets.io';
var CHAIN$a = 'wax-test';
var CHAIN_ID$a = 'f16b1833c747c43682f4386fca9cbb327929334a762755ebec17f6f23c9b8a12';
var CHAIN_START_DATE$a = /*#__PURE__*/new Date('Dec 5, 2019');
var CORE_PRECISION$a = 8;
var CORE_SYMBOL$a = 'WAX';
var DISPLAY_CHAIN$a = 'WAX-T';
var DOMAIN_TITLE$a = 'WAX Testnet Bloks.io';
var HISTORY_TYPES$a = ['native', 'hyperion'];
var HYPERION_URL$8 = 'https://testnet.waxsweden.org';
var KEY_PREFIX$a = 'EOS';
var LIGHT_API$4 = 'https://testnet-lightapi.eosams.xeos.me';
var PROVIDER_ENDPOINTS$a = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$a, ACTIONS_ENDPOINTS$a);
var constants$a = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$a,
  API_URL: API_URL$a,
  ATOMICASSETS_API: ATOMICASSETS_API$4,
  CHAIN: CHAIN$a,
  CHAIN_ID: CHAIN_ID$a,
  CHAIN_START_DATE: CHAIN_START_DATE$a,
  CORE_PRECISION: CORE_PRECISION$a,
  CORE_SYMBOL: CORE_SYMBOL$a,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$a,
  DISPLAY_CHAIN: DISPLAY_CHAIN$a,
  DOMAIN_TITLE: DOMAIN_TITLE$a,
  HISTORY_TYPES: HISTORY_TYPES$a,
  HYPERION_URL: HYPERION_URL$8,
  KEY_PREFIX: KEY_PREFIX$a,
  LIGHT_API: LIGHT_API$4,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$a,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$a
};

var DEFAULT_ENDPOINTS$b = ['https://fiotestnet.greymass.com', 'https://test.fio.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$b = ['https://fiotestnet.greymass.com', 'https://test.fio.eosusa.news'];
var ACTIONS_ENDPOINTS$b = ['https://fiotestnet.greymass.com', 'https://test.fio.eosusa.news'];
var API_URL$b = 'https://www.api.bloks.io/fio-test';
var CHAIN$b = 'fio-test';
var CHAIN_ID$b = 'b20901380af44ef59c5918439a1f9a41d83669020319a80574b804a5f95cbd7e';
var CHAIN_START_DATE$b = /*#__PURE__*/new Date('Mar 10, 2020');
var CORE_PRECISION$b = 9;
var CORE_SYMBOL$b = 'FIO';
var DISABLE_MEMO$1 = true;
var DISPLAY_CHAIN$b = 'FIO Test';
var DOMAIN_TITLE$b = 'FIO Test Bloks.io';
var HISTORY_TYPES$b = ['native', 'hyperion'];
var HYPERION_URL$9 = 'https://test.fio.eosusa.news';
var KEY_PREFIX$b = 'FIO';
var PROVIDER_ENDPOINTS$b = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$b, ACTIONS_ENDPOINTS$b);
var VOTING_ENABLED$9 = true;
var constants$b = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$b,
  API_URL: API_URL$b,
  CHAIN: CHAIN$b,
  CHAIN_ID: CHAIN_ID$b,
  CHAIN_START_DATE: CHAIN_START_DATE$b,
  CORE_PRECISION: CORE_PRECISION$b,
  CORE_SYMBOL: CORE_SYMBOL$b,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$b,
  DISABLE_MEMO: DISABLE_MEMO$1,
  DISPLAY_CHAIN: DISPLAY_CHAIN$b,
  DOMAIN_TITLE: DOMAIN_TITLE$b,
  HISTORY_TYPES: HISTORY_TYPES$b,
  HYPERION_URL: HYPERION_URL$9,
  KEY_PREFIX: KEY_PREFIX$b,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$b,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$b,
  VOTING_ENABLED: VOTING_ENABLED$9
};

var _chainToNetworkConsta;

var chainToNetworkConstantsMap = (_chainToNetworkConsta = {
  eos: constants,
  wax: constants$1,
  proton: constants$2,
  local: constants$4,
  jungle: constants$5,
  jungle3: constants$6,
  kylin: constants$7,
  fio: constants$3
}, _chainToNetworkConsta['eos-test'] = constants$8, _chainToNetworkConsta['proton-test'] = constants$9, _chainToNetworkConsta['wax-test'] = constants$a, _chainToNetworkConsta['fio-test'] = constants$b, _chainToNetworkConsta);
var Constants = /*#__PURE__*/function () {
  function Constants() {
    if (!!Constants.instance) {
      return Constants.instance;
    }
  }

  var _proto = Constants.prototype;

  _proto.initialize = function initialize(chain) {
    if (!chain || !chainToNetworkConstantsMap[chain]) {
      chain = DEFAULT_CHAIN;
    }

    this.setNetwork(chain);
    this.setCommon(chain);
  };

  _proto.setNetwork = function setNetwork(chain) {
    // const networkConstants = await import(`'./networks/${chain}`)
    var networkConstants = chainToNetworkConstantsMap[chain];
    this.setConstants(networkConstants);
    this.setContract(chain, networkConstants.SYSTEM_DOMAIN);
  };

  _proto.setCommon = function setCommon(chain) {
    var commonConstants = getCommonConstants(chain);
    this.setConstants(commonConstants);
  };

  _proto.setContract = function setContract(chain, systemDomain) {
    if (systemDomain === void 0) {
      systemDomain = DEFAULT_SYSTEM_DOMAIN;
    }

    var contractConstants = getContractConstants(chain, systemDomain);
    this.setConstants(contractConstants);
  };

  _proto.setConstants = function setConstants(newConstants) {
    for (var _i = 0, _Object$entries = Object.entries(newConstants); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];
      this[key] = value;
    }
  };

  return Constants;
}();
var constants$c = /*#__PURE__*/new Constants();


//# sourceMappingURL=constants.esm.js.map


/***/ }),

/***/ "./node_modules/@bloks/numbers/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@bloks/numbers/dist/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



if (false) {} else {
  module.exports = __webpack_require__(/*! ./numbers.cjs.development.js */ "./node_modules/@bloks/numbers/dist/numbers.cjs.development.js")
}


/***/ }),

/***/ "./node_modules/@bloks/numbers/dist/numbers.cjs.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bloks/numbers/dist/numbers.cjs.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bignumber_js = __webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js");
var numbro = _interopDefault(__webpack_require__(/*! @jafri/numbro */ "./node_modules/@jafri/numbro/dist/numbro.min.js"));
var dayjs = _interopDefault(__webpack_require__(/*! dayjs */ "./node_modules/dayjs/dayjs.min.js"));
var relativeTimePlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/relativeTime */ "./node_modules/dayjs/plugin/relativeTime.js"));
var utcPlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/utc */ "./node_modules/dayjs/plugin/utc.js"));
var timezonePlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/timezone */ "./node_modules/dayjs/plugin/timezone.js"));
var advancedFormatPlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/advancedFormat */ "./node_modules/dayjs/plugin/advancedFormat.js"));

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var assert = function assert(isTrue, error) {
  if (isTrue) {
    return;
  } else {
    throw new Error(error);
  }
};

(function (Maths) {
  var Operations;

  (function (Operations) {
    Operations["PLUS"] = "plus";
    Operations["MULTIPLY"] = "multipliedBy";
    Operations["DIVIDE"] = "dividedBy";
    Operations["MINUS"] = "minus";
  })(Operations = Maths.Operations || (Maths.Operations = {}));
})(exports.Maths || (exports.Maths = {}));

var Asset = /*#__PURE__*/function () {
  function Asset(asset) {
    this.symbol = new Symbol$1({
      code: asset.code,
      precision: asset.precision
    });
    this.amount = new bignumber_js.BigNumber(asset.amount);
  }

  Asset.fromString = function fromString(asset) {
    var _asset$split = asset.split(' '),
        amount = _asset$split[0],
        code = _asset$split[1];

    var precision = (amount.split('.')[1] || []).length;
    return new Asset({
      code: code,
      precision: precision,
      amount: new bignumber_js.BigNumber(amount)
    });
  };

  Asset.fromSymbol = function fromSymbol(_ref) {
    var symbol = _ref.symbol,
        amount = _ref.amount;

    if (!(symbol instanceof Symbol$1)) {
      throw new Error('Invalid symbol');
    }

    return new Asset({
      code: symbol.code,
      precision: symbol.precision,
      amount: amount
    });
  };

  var _proto = Asset.prototype;

  _proto.isEqualTo = function isEqualTo(asset) {
    return this.isLooselyEqualTo(asset) && this.amount == asset.amount;
  };

  _proto.isLooselyEqualTo = function isLooselyEqualTo(asset) {
    return this.symbol.isEqualTo(asset.symbol);
  };

  _proto.toString = function toString() {
    return new bignumber_js.BigNumber(this.amount).toFixed(this.symbol.precision, bignumber_js.BigNumber.ROUND_DOWN) + " " + this.symbol.code;
  };

  _proto.modifyAmount = function modifyAmount(x, method) {
    var amount = new bignumber_js.BigNumber(0);

    if (typeof x === "number" || bignumber_js.BigNumber.isBigNumber(x)) {
      amount = new bignumber_js.BigNumber(x);
    }

    if (x instanceof Asset) {
      assert(this.isLooselyEqualTo(x), "invalid symbol");
      amount = new bignumber_js.BigNumber(x.amount);
    }

    return Asset.fromSymbol({
      symbol: this.symbol,
      amount: this.amount[method](amount)
    });
  };

  _proto.plus = function plus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.PLUS);
  };

  _proto.minus = function minus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MINUS);
  };

  _proto.multipliedBy = function multipliedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MULTIPLY);
  };

  _proto.dividedBy = function dividedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.DIVIDE);
  };

  _createClass(Asset, [{
    key: "integerAmount",
    get: function get() {
      var factor = Math.pow(10, this.symbol.precision);
      return this.amount.multipliedBy(factor);
    }
  }]);

  return Asset;
}();
var ExtendedAsset = /*#__PURE__*/function () {
  function ExtendedAsset(extendedAsset) {
    if (!(extendedAsset.quantity instanceof Asset)) {
      throw new Error('Invalid quantity');
    }

    this.quantity = extendedAsset.quantity;
    this.contract = extendedAsset.contract;
  }

  ExtendedAsset.fromRaw = function fromRaw(_ref2) {
    var quantity = _ref2.quantity,
        contract = _ref2.contract;
    return new ExtendedAsset({
      quantity: Asset.fromString(quantity),
      contract: contract
    });
  };

  ExtendedAsset.fromExtendedSymbol = function fromExtendedSymbol(symbol, amount) {
    if (!(symbol instanceof ExtendedSymbol)) {
      throw new Error('Invalid extended symbol');
    }

    return new ExtendedAsset({
      quantity: Asset.fromSymbol({
        symbol: symbol.sym,
        amount: amount
      }),
      contract: symbol.contract
    });
  };

  var _proto2 = ExtendedAsset.prototype;

  _proto2.isEqualTo = function isEqualTo(extendedAsset) {
    return this.contract === extendedAsset.contract && this.quantity.isEqualTo(extendedAsset.quantity);
  };

  _proto2.isLooselyEqualTo = function isLooselyEqualTo(extendedAsset) {
    return this.contract === extendedAsset.contract && this.quantity.isLooselyEqualTo(extendedAsset.quantity);
  };

  _proto2.toString = function toString() {
    return this.quantity.toString() + "@" + this.contract;
  };

  _proto2.toExtendedSymbol = function toExtendedSymbol() {
    return new ExtendedSymbol(this.quantity.symbol, this.contract);
  };

  _proto2.modifyAmount = function modifyAmount(x, method) {
    var amount = new bignumber_js.BigNumber(0);

    if (x instanceof ExtendedAsset) {
      assert(this.isLooselyEqualTo(x), "invalid contract or symbol");
      amount = x.quantity;
    } else {
      amount = x;
    }

    return new ExtendedAsset({
      contract: this.contract,
      quantity: this.quantity.modifyAmount(amount, method)
    });
  };

  _proto2.plus = function plus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.PLUS);
  };

  _proto2.minus = function minus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MINUS);
  };

  _proto2.multipliedBy = function multipliedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MULTIPLY);
  };

  _proto2.dividedBy = function dividedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.DIVIDE);
  };

  return ExtendedAsset;
}();
var Symbol$1 = /*#__PURE__*/function () {
  function Symbol(symbol) {
    this.precision = symbol.precision;
    this.code = symbol.code;
  }

  Symbol.fromString = function fromString(symbol) {
    var _symbol$split = symbol.split(','),
        precision = _symbol$split[0],
        code = _symbol$split[1];

    return new Symbol({
      precision: +precision,
      code: code
    });
  };

  var _proto3 = Symbol.prototype;

  _proto3.isEqualTo = function isEqualTo(symbol) {
    return this.code === symbol.code && this.precision === symbol.precision;
  };

  _proto3.toString = function toString() {
    return this.precision + "," + this.code;
  };

  return Symbol;
}();
var ExtendedSymbol = /*#__PURE__*/function () {
  function ExtendedSymbol(sym, contract) {
    this.sym = sym;
    this.contract = contract;
  }

  ExtendedSymbol.fromRaw = function fromRaw(_ref3) {
    var sym = _ref3.sym,
        contract = _ref3.contract;
    return new ExtendedSymbol(Symbol$1.fromString(sym), contract);
  };

  var _proto4 = ExtendedSymbol.prototype;

  _proto4.isEqualTo = function isEqualTo(extendedSymbol) {
    return this.sym.isEqualTo(extendedSymbol.sym) && this.contract === extendedSymbol.contract;
  };

  _proto4.toString = function toString() {
    return this.sym.toString() + "@" + this.contract;
  };

  return ExtendedSymbol;
}();

var currencyMap = {
  // Fiat
  GBP: {
    symbol: '£',
    precision: 2
  },
  EUR: {
    symbol: '€',
    precision: 2
  },
  JPY: {
    symbol: '¥',
    precision: 0
  },
  CAD: {
    symbol: 'CA$',
    precision: 2
  },
  USD: {
    symbol: '$',
    precision: 2
  },
  INR: {
    symbol: '₹',
    precision: 2
  },
  CNY: {
    symbol: 'CN¥',
    precision: 2
  },
  HKD: {
    symbol: 'HK$',
    precision: 2
  },
  KRW: {
    symbol: '₩',
    precision: 0
  },
  AUD: {
    symbol: 'AUD$',
    precision: 2
  },
  SAR: {
    symbol: 'SR',
    precision: 2
  },
  // Crypto
  ETH: {
    symbol: 'Ξ',
    precision: 4
  },
  BTC: {
    symbol: '₿',
    precision: 8
  },
  EOS: {
    symbol: 'EOS',
    precision: 4
  }
};
var assetFormat = {
  decimalSeparator: '.',
  groupSeparator: ',',
  groupSize: 3
};

function toBN(number) {
  return new bignumber_js.BigNumber(number);
}
function numberToAmount(number, precision, round) {
  if (round === void 0) {
    round = bignumber_js.BigNumber.ROUND_DOWN;
  }

  if (number === undefined || typeof number === "number" && isNaN(number)) {
    number = 0;
  }

  return new bignumber_js.BigNumber(number).toFixed(precision, round);
}
function numberToAmountFormatted(number, precision, round) {
  if (round === void 0) {
    round = bignumber_js.BigNumber.ROUND_DOWN;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  return new bignumber_js.BigNumber(number).toFormat(precision, round, assetFormat);
}
function calculatePercentage(balance, percentage, precision) {
  var _final = new bignumber_js.BigNumber(balance).multipliedBy(percentage);

  return numberToAmount(_final, precision, bignumber_js.BigNumber.ROUND_DOWN);
}
function eosDisplayFormatting(value, symbol, precision) {
  return numberToAmountFormatted(value, precision) + " " + symbol;
}
function numberToEos(number, symbol, precision) {
  return numberToAmount(number, precision) + " " + symbol;
}
function numberToEosRoundUp(number, symbol, precision) {
  return numberToAmount(number, precision, bignumber_js.BigNumber.ROUND_UP) + " " + symbol;
}
function parseRex(rex) {
  return new bignumber_js.BigNumber(rex).dividedBy(10000);
}
/**
 * Converts USD to { symbol: "USD", precision: 4 }
 * @param {*} currency
 */

function currencyToSymbol(currency) {
  return currencyMap[currency];
}
/**
 * Converts "1000.0000 EOS" to { amount: 1000, symbol: { code: "EOS", precision: 4 }}
 * @param {*} quantity
 */

function split(quantity) {
  var _quantity$split = quantity.split(' '),
      amount = _quantity$split[0],
      code = _quantity$split[1];

  var precision = (amount.split('.')[1] || []).length;
  return {
    amount: +amount,
    symbol: {
      code: code,
      precision: precision
    }
  };
}
function toNumbro(number) {
  return numbro(number);
}
/**
 * Converts 1000 to "1000.0000 EOS"
 * @param {*} asset
 */

function numberToAsset(number, symbol, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  var amount = numbro(number).format({
    thousandSeparated: false,
    mantissa: precision,
    trimMantissa: trimMantissa
  });
  return amount + " " + symbol;
}
/**
 * DISPLAY FUNCTIONS
 */

/**
 * Converts 1000 to 1,000
 * @param {*} number
 */

function displayNumber(number, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  return numbro(number).format({
    thousandSeparated: true,
    trimMantissa: trimMantissa
  });
}
/**
 * Converts 1000 to $1,000 USD
 * @param {*} number
 */

function displayNumberAsCurrency(_ref) {
  var number = _ref.number,
      precision = _ref.precision,
      _ref$average = _ref.average,
      average = _ref$average === void 0 ? false : _ref$average,
      _ref$lowPrecision = _ref.lowPrecision,
      lowPrecision = _ref$lowPrecision === void 0 ? true : _ref$lowPrecision,
      _ref$trimMantissa = _ref.trimMantissa,
      trimMantissa = _ref$trimMantissa === void 0 ? false : _ref$trimMantissa,
      _ref$currency = _ref.currency,
      currency = _ref$currency === void 0 ? 'USD' : _ref$currency;

  if (!currencyMap[currency]) {
    throw new Error('Unsupported currency');
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  var _currencyMap$currency = currencyMap[currency],
      symbol = _currencyMap$currency.symbol,
      defaultPrecision = _currencyMap$currency.precision;
  var format = {
    thousandSeparated: true,
    mantissa: precision !== undefined ? precision : defaultPrecision,
    trimMantissa: trimMantissa,
    average: average
  };

  if (average) {
    format.lowPrecision = lowPrecision;
  }

  var formattedNumber = numbro(number).format(format);
  return "" + symbol + formattedNumber;
}
/**
 * Converts "1000.0000 EOS" to "1,000.0000 EOS"
 * @param {*} asset
 */

function displayAsset(asset) {
  var _split = split(asset),
      amount = _split.amount,
      code = _split.symbol.code;

  return displayNumber(amount) + " " + code;
}
/**
 * Converts 1000 to 1,000.0000
 * @param {*} number
 */

function displayNumberAsAmount(number, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  return numbro(number).format({
    thousandSeparated: true,
    mantissa: precision,
    trimMantissa: trimMantissa
  });
}
/**
 * Converts 1000 to "1,000.0000 EOS"
 * @param {*} number
 */

function displayNumberAsAsset(number, symbol, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  var amount = numbro(number).format({
    thousandSeparated: true,
    mantissa: precision,
    trimMantissa: trimMantissa
  });
  return amount + " " + symbol;
}
/**
 * Converts 10000000 to "1,000.0000 EOS"
 * @param {*} number
 */

function displayRawNumberAsAsset(number, symbol, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  return displayNumberAsAsset(number / Math.pow(10, precision), symbol, precision, trimMantissa);
}

bignumber_js.BigNumber.set({
  ROUNDING_MODE: 1
});
function add() {
  var start = new bignumber_js.BigNumber(0);

  for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
    numbers[_key] = arguments[_key];
  }

  if (numbers.length) {
    for (var _iterator = _createForOfIteratorHelperLoose(numbers), _step; !(_step = _iterator()).done;) {
      var number = _step.value;
      start = start.plus(number);
    }
  }

  return start;
}
function substract(a, b) {
  return new bignumber_js.BigNumber(a).minus(b);
}
function multiply(a, b) {
  return new bignumber_js.BigNumber(a).multipliedBy(b);
}
function divide(a, b) {
  return new bignumber_js.BigNumber(a).dividedBy(b);
}

function bytesToKB(bytes) {
  if (bytes === void 0) {
    bytes = 0;
  }

  return numbro(bytes / 1024).format({
    thousandSeparated: false,
    mantissa: 2
  });
}
function parseNetAndRam(bytes) {
  var parsedValue = 0;
  var parsedText = '';

  if (bytes < 1024) {
    parsedValue = bytes;
    parsedText = 'Bytes';
  } else if (bytes < 1048576) {
    parsedValue = bytes / 1024;
    parsedText = 'KB';
  } else if (bytes < 1073741824) {
    parsedValue = bytes / 1048576;
    parsedText = 'MB';
  } else if (bytes < 1099511627776) {
    parsedValue = bytes / 1073741824;
    parsedText = 'GB';
  } else if (bytes < 1125899906842624) {
    parsedValue = bytes / 1099511627776;
    parsedText = 'TB';
  }

  return displayNumberAsAmount(parsedValue, 2, true) + " " + parsedText;
}
function parseCpu(us) {
  var parsedValue = 0;
  var parsedText = '';

  if (us < 1000) {
    parsedValue = us;
    parsedText = 'µs';
  } else if (us < 1000000) {
    parsedValue = us / 1000;
    parsedText = 'ms';
  } else if (us < 60000000) {
    parsedValue = us / 1000000;
    parsedText = 's';
  } else if (us < 3600000000) {
    parsedValue = us / 60000000;
    parsedText = 'min';
  } else if (us < 3600000000000) {
    parsedValue = us / 3600000000;
    parsedText = 'hours';
  } else {
    parsedValue = us / 86400000000;
    parsedText = 'days';
  }

  return displayNumberAsAmount(parsedValue, 2, true) + " " + parsedText;
}

dayjs.extend(relativeTimePlugin);
dayjs.extend(utcPlugin);
dayjs.extend(timezonePlugin);
dayjs.extend(advancedFormatPlugin);
var COMMON_DATE_FORMAT = 'MMM-DD-YYYY, hh:mm:ss A';
/**
 * Time utilities
 */

function time(date) {
  return dayjs(date);
}
function utcTime(date) {
  return dayjs(date).utc();
}
function utcTimeToLocal(date) {
  return dayjs(date).local();
}
function unixTime(unixTimestamp) {
  return dayjs.unix(unixTimestamp);
}
function formatDate(date, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return dayjs(date).format(format);
}
function formatDateLocal(date, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return dayjs(date).utc().format(format);
}
function timestampToDate(timestamp) {
  return new Date(timestamp);
}
function utcTimestampToDate(timestamp) {
  timestamp = timestamp.slice(-1) === 'Z' ? timestamp : timestamp + 'Z';
  return new Date(timestamp);
}
function timestampFromNow(timestamp) {
  return time(timestamp).fromNow();
}
function utcTimestampFromNow(timestamp) {
  timestamp = timestamp.slice(-1) === 'Z' ? timestamp : timestamp + 'Z';
  return time(timestamp).fromNow();
}
function parseTimestamp(timestamp, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return formatDate(timestampToDate(timestamp), format);
}
function parseUtcTimestamp(timestamp, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return formatDate(utcTimestampToDate(timestamp), format);
}
function inFuture(date, utc) {
  if (utc === void 0) {
    utc = false;
  }

  return utc ? utcTime(date).isAfter(utcTime()) : time(date).isAfter(time());
}
function inPast(date, utc) {
  if (utc === void 0) {
    utc = false;
  }

  return utc ? utcTime(date).isBefore(utcTime()) : time(date).isBefore(time());
}
function isSameDay(start, end) {
  if (end === void 0) {
    end = time();
  }

  return dayjs(start).isSame(dayjs(end), 'day');
} // Seconds till now if second param empty

function secondsFrom(start, end) {
  if (end === void 0) {
    end = time();
  }

  return dayjs(start).diff(dayjs(end), 'second');
}
function millisecondsFrom(start, end) {
  if (end === void 0) {
    end = time();
  }

  return dayjs(start).diff(dayjs(end));
}
/**
 * Specific to EOS
 */

function startDate(startDate, days) {
  if (days === void 0) {
    days = 3;
  }

  return dayjs(startDate).clone().subtract(days, 'days');
}
function formatStartDate(startTimestamp) {
  return startDate(startTimestamp).format('MMM-DD-YYYY, hh:mm:ss A');
}
function endDate(endDate, days) {
  if (days === void 0) {
    days = 3;
  }

  return dayjs(endDate).clone().add(days, 'days');
}
function formatEndDate(endTimestamp) {
  return endDate(endTimestamp).format('MMM-DD-YYYY, hh:mm:ss A');
}
function dateToUtcTimePoint(date) {
  if (date === void 0) {
    date = time();
  }

  return dayjs(date).utc().format('YYYY-MM-DDTHH:mm:ss.SSS');
}
var emptyTimePoint = '1970-01-01T00:00:00.000';
function parseSeconds(seconds) {
  var days = 0;
  var hours = 0;
  var minutes = 0;
  var parsedDate = ''; // Days

  if (seconds > 86400) {
    days += Math.floor(seconds / 86400);
    seconds -= days * 86400;
    parsedDate += days.toFixed(0) + " " + (days === 1 ? 'Day' : 'Days') + " ";
  } // Hours


  if (seconds > 3600) {
    hours += Math.floor(seconds / 3600);
    seconds -= hours * 3600;
    parsedDate += hours.toFixed(0) + " " + (hours === 1 ? 'Hour' : 'Hours') + " ";
  } // Minutes


  if (seconds > 60) {
    minutes += Math.floor(seconds / 60);
    seconds -= minutes * 60;
    parsedDate += minutes.toFixed(0) + " " + (minutes === 1 ? 'Minute' : 'Minutes') + " ";
  } // Seconds


  if (seconds > 0) {
    parsedDate += seconds.toFixed(0) + " Seconds ";
  }

  return parsedDate;
}

exports.Asset = Asset;
exports.ExtendedAsset = ExtendedAsset;
exports.ExtendedSymbol = ExtendedSymbol;
exports.Symbol = Symbol$1;
exports.add = add;
exports.bytesToKB = bytesToKB;
exports.calculatePercentage = calculatePercentage;
exports.currencyToSymbol = currencyToSymbol;
exports.dateToUtcTimePoint = dateToUtcTimePoint;
exports.displayAsset = displayAsset;
exports.displayNumber = displayNumber;
exports.displayNumberAsAmount = displayNumberAsAmount;
exports.displayNumberAsAsset = displayNumberAsAsset;
exports.displayNumberAsCurrency = displayNumberAsCurrency;
exports.displayRawNumberAsAsset = displayRawNumberAsAsset;
exports.divide = divide;
exports.emptyTimePoint = emptyTimePoint;
exports.endDate = endDate;
exports.eosDisplayFormatting = eosDisplayFormatting;
exports.formatDate = formatDate;
exports.formatDateLocal = formatDateLocal;
exports.formatEndDate = formatEndDate;
exports.formatStartDate = formatStartDate;
exports.inFuture = inFuture;
exports.inPast = inPast;
exports.isSameDay = isSameDay;
exports.millisecondsFrom = millisecondsFrom;
exports.multiply = multiply;
exports.numberToAmount = numberToAmount;
exports.numberToAmountFormatted = numberToAmountFormatted;
exports.numberToAsset = numberToAsset;
exports.numberToEos = numberToEos;
exports.numberToEosRoundUp = numberToEosRoundUp;
exports.parseCpu = parseCpu;
exports.parseNetAndRam = parseNetAndRam;
exports.parseRex = parseRex;
exports.parseSeconds = parseSeconds;
exports.parseTimestamp = parseTimestamp;
exports.parseUtcTimestamp = parseUtcTimestamp;
exports.secondsFrom = secondsFrom;
exports.split = split;
exports.startDate = startDate;
exports.substract = substract;
exports.time = time;
exports.timestampFromNow = timestampFromNow;
exports.timestampToDate = timestampToDate;
exports.toBN = toBN;
exports.toNumbro = toNumbro;
exports.unixTime = unixTime;
exports.utcTime = utcTime;
exports.utcTimeToLocal = utcTimeToLocal;
exports.utcTimestampFromNow = utcTimestampFromNow;
exports.utcTimestampToDate = utcTimestampToDate;
//# sourceMappingURL=numbers.cjs.development.js.map


/***/ }),

/***/ "./node_modules/@bloks/utils/dist/utils.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/@bloks/utils/dist/utils.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DbopOp": () => (/* binding */ DbopOp),
/* harmony export */   "Nft": () => (/* binding */ Nft),
/* harmony export */   "bytesToString": () => (/* binding */ bytesToString),
/* harmony export */   "charidx": () => (/* binding */ charidx),
/* harmony export */   "cloneDeepArrayOfObj": () => (/* binding */ cloneDeepArrayOfObj),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "decodeName": () => (/* binding */ decodeName),
/* harmony export */   "dfuseDepthFirstExtract": () => (/* binding */ dfuseDepthFirstExtract),
/* harmony export */   "dfuseTransformDeferredAction": () => (/* binding */ dfuseTransformDeferredAction),
/* harmony export */   "dfuseTransformDeferredTransaction": () => (/* binding */ dfuseTransformDeferredTransaction),
/* harmony export */   "dfuseTransformGetActions": () => (/* binding */ dfuseTransformGetActions),
/* harmony export */   "dfuseTransformTrace": () => (/* binding */ dfuseTransformTrace),
/* harmony export */   "dfuseTransformTransaction": () => (/* binding */ dfuseTransformTransaction),
/* harmony export */   "dfuseTransformTransactionResult": () => (/* binding */ dfuseTransformTransactionResult),
/* harmony export */   "encodeName": () => (/* binding */ encodeName),
/* harmony export */   "fioKeyToActor": () => (/* binding */ fioKeyToActor),
/* harmony export */   "hexToUint8Array": () => (/* binding */ hexToUint8Array),
/* harmony export */   "historyTransformDeferredAction": () => (/* binding */ historyTransformDeferredAction),
/* harmony export */   "historyTransformDeferredTransaction": () => (/* binding */ historyTransformDeferredTransaction),
/* harmony export */   "historyTransformFlatTraces": () => (/* binding */ historyTransformFlatTraces),
/* harmony export */   "historyTransformRecursiveTrace": () => (/* binding */ historyTransformRecursiveTrace),
/* harmony export */   "historyTransformTransaction": () => (/* binding */ historyTransformTransaction),
/* harmony export */   "hyperionTransformFlatTraces": () => (/* binding */ hyperionTransformFlatTraces),
/* harmony export */   "hyperionTransformGetActions": () => (/* binding */ hyperionTransformGetActions),
/* harmony export */   "hyperionTransformTransaction": () => (/* binding */ hyperionTransformTransaction),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "nativeTransformGetActions": () => (/* binding */ nativeTransformGetActions),
/* harmony export */   "parseAaNft": () => (/* binding */ parseAaNft),
/* harmony export */   "parseSaNft": () => (/* binding */ parseSaNft),
/* harmony export */   "sha": () => (/* binding */ sha),
/* harmony export */   "string_to_uint128_hash": () => (/* binding */ string_to_uint128_hash),
/* harmony export */   "urlBuilder": () => (/* binding */ urlBuilder),
/* harmony export */   "wait": () => (/* binding */ wait)
/* harmony export */ });
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fast_text_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-text-encoding */ "./node_modules/fast-text-encoding/text.min.js");
/* harmony import */ var fast_text_encoding__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_text_encoding__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(qs__WEBPACK_IMPORTED_MODULE_2__);




function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function cloneDeepArrayOfObj(array) {
  return [].concat(array).map(function (i) {
    return _extends({}, i);
  });
}

var charmap = '.12345abcdefghijklmnopqrstuvwxyz';
function charidx(ch) {
  var idx = charmap.indexOf(ch);

  if (idx === -1) {
    throw new TypeError("Invalid character: '" + ch + "'");
  }

  return idx;
}
function encodeName(name, littleEndian) {
  if (littleEndian === void 0) {
    littleEndian = false;
  }

  if (typeof name !== 'string') {
    throw new TypeError('name parameter is a required string');
  }

  if (name.length > 12) {
    throw new TypeError('A name can be up to 12 characters long');
  }

  var bitstr = '';

  for (var i = 0; i <= 12; i++) {
    // process all 64 bits (even if name is short)
    var c = i < name.length ? charidx(name[i]) : 0;
    var bitlen = i < 12 ? 5 : 4;
    var bits = Number(c).toString(2);

    if (bits.length > bitlen) {
      throw new TypeError('Invalid name ' + name);
    }

    bits = '0'.repeat(bitlen - bits.length) + bits;
    bitstr += bits;
  }

  var value = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(bitstr, true, 2); // convert to LITTLE_ENDIAN

  var leHex = '';
  var bytes = littleEndian ? value.toBytesLE() : value.toBytesBE();

  for (var _iterator = _createForOfIteratorHelperLoose(bytes), _step; !(_step = _iterator()).done;) {
    var b = _step.value;
    var n = Number(b).toString(16);
    leHex += (n.length === 1 ? '0' : '') + n;
  }

  var ulName = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(leHex, true, 16).toString(); // console.log('encodeName', name, value.toString(), ulName.toString(), JSON.stringify(bitstr.split(/(.....)/).slice(1)))

  return ulName.toString();
}
function decodeName(encodedName, littleEndian) {
  if (littleEndian === void 0) {
    littleEndian = true;
  }

  var value = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(encodedName); // convert from LITTLE_ENDIAN

  var beHex = '';
  var bytes = littleEndian ? value.toBytesLE() : value.toBytesBE();

  for (var _iterator2 = _createForOfIteratorHelperLoose(bytes), _step2; !(_step2 = _iterator2()).done;) {
    var b = _step2.value;
    var n = Number(b).toString(16);
    beHex += (n.length === 1 ? '0' : '') + n;
  }

  beHex += '0'.repeat(16 - beHex.length);
  var fiveBits = long__WEBPACK_IMPORTED_MODULE_0___default().fromNumber(0x1f, true);
  var fourBits = long__WEBPACK_IMPORTED_MODULE_0___default().fromNumber(0x0f, true);
  var beValue = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(beHex, true, 16);
  var str = '';
  var tmp = beValue;

  for (var i = 0; i <= 12; i++) {
    var c = charmap[tmp.and(i === 0 ? fourBits : fiveBits)];
    str = c + str;
    tmp = tmp.shiftRight(i === 0 ? 4 : 5);
  }

  str = str.replace(/\.+$/, ''); // remove trailing dots (all of them)
  // console.log('decodeName', str, beValue.toString(), value.toString(), JSON.stringify(beValue.toString(2).split(/(.....)/).slice(1)))

  return str;
}
/**
 * FIO SPECIFIC
 * @param key FIO
 */

var shorten_key = function shorten_key(key) {
  var res = new (long__WEBPACK_IMPORTED_MODULE_0___default())(0, 0, true);
  var i = 1; // Ignore key head

  var len = 0;

  while (len <= 12) {
    if (i >= 33) throw new Error('FIO: i too large');
    var trimmed_char = key[i] & (len == 12 ? 0x0f : 0x1f);

    if (trimmed_char == 0) {
      i++;
      continue;
    } // Skip a zero and move to next


    var shuffle = len == 12 ? 0 : 5 * (12 - len) - 1;
    res = res.or(long__WEBPACK_IMPORTED_MODULE_0___default().fromNumber(shift(trimmed_char, shuffle), true));
    len++;
    i++;
  }

  return res;
};

function shift(number, shift) {
  return number * Math.pow(2, shift);
}

var fioKeyToActor = function fioKeyToActor(key, stringToPublicKey) {
  var pubKey = stringToPublicKey(key, 'FIO').data;
  var shortenedPubKey = shorten_key(pubKey);
  var decodedName = decodeName(shortenedPubKey.toString(), false);
  return decodedName.substr(0, 12);
}; // convert bytes to a String

function bytesToString(bytes) {
  if (typeof bytes === 'string') {
    return bytes;
  }

  return bytes.reduce(function (acc, _byte) {
    return acc + String.fromCharCode(_byte);
  }, '');
}
/**
 * Checks if string
 */

function isString(string) {
  return Object.prototype.toString.call(string) === '[object String]';
}
/**
 *
 * @param message Sha256
 */

function sha(_x, _x2, _x3) {
  return _sha.apply(this, arguments);
}
/**
 * FIO function
 *
 * @param str example: coinomi
 * @returns returns: 968ba84617b73b8e2a73b59170976f41
 */

function _sha() {
  _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(message, binaryRepresentationOfHex, type) {
    var encodedMessage, matched, mapped, hashBuffer, hashArray, hashHex;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (binaryRepresentationOfHex === void 0) {
              binaryRepresentationOfHex = false;
            }

            if (type === void 0) {
              type = 'SHA-256';
            }

            if (!binaryRepresentationOfHex) {
              _context.next = 10;
              break;
            }

            matched = message.match(/[\da-f]{2}/gi);

            if (matched) {
              _context.next = 6;
              break;
            }

            throw Error('Empty message');

          case 6:
            mapped = matched.map(function (h) {
              return parseInt(h, 16);
            });
            encodedMessage = new Uint8Array(mapped);
            _context.next = 11;
            break;

          case 10:
            encodedMessage = new TextEncoder().encode(message);

          case 11:
            _context.next = 13;
            return crypto.subtle.digest(type, encodedMessage);

          case 13:
            hashBuffer = _context.sent;
            // hash the message
            hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array

            hashHex = hashArray.map(function (b) {
              return b.toString(16).padStart(2, '0');
            }).join(''); // convert bytes to hex string

            return _context.abrupt("return", hashHex);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _sha.apply(this, arguments);
}

function string_to_uint128_hash(_x4) {
  return _string_to_uint128_hash.apply(this, arguments);
}

function _string_to_uint128_hash() {
  _string_to_uint128_hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(str) {
    var hexBytes;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return sha(str, false, 'SHA-1');

          case 2:
            hexBytes = _context2.sent.match(/../g);

            if (!hexBytes) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", hexBytes.slice(0, -4).reverse().join(''));

          case 7:
            return _context2.abrupt("return", 0);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _string_to_uint128_hash.apply(this, arguments);
}

function nativeTransformGetActions(result, constants) {
  result.actions = result.actions.map(function (action) {
    if (action['action_trace']['act']['account'] === constants.EOSIO && action['action_trace']['act']['name'] === 'claimrewards' && action['action_trace']['inline_traces']) {
      var totalAmount = 0;
      var totalSymbol = '';

      for (var _iterator = _createForOfIteratorHelperLoose(action['action_trace']['inline_traces']), _step; !(_step = _iterator()).done;) {
        var inline_trace = _step.value;

        if (inline_trace['act']['data']['from'] === constants.EOSIO_VPAY || inline_trace['act']['data']['from'] === constants.EOSIO_BPAY) {
          var _inline_trace$act$dat = inline_trace['act']['data']['quantity'].split(' '),
              amount = _inline_trace$act$dat[0],
              symbol = _inline_trace$act$dat[1];

          totalAmount += Number(amount);
          totalSymbol = symbol;
        }
      }

      action['action_trace']['act']['data']['quantity'] = totalAmount.toFixed(constants.CORE_PRECISION) + " " + totalSymbol;
    }

    return action;
  }).reverse();
  result.numOfTxLoaded = result.actions.length;
  return result;
}
function hyperionTransformGetActions(_ref) {
  var query_time = _ref.query_time,
      lib = _ref.lib,
      actions = _ref.actions,
      _ref$total = _ref.total,
      relation = _ref$total.relation,
      value = _ref$total.value;
  var transformedActions = [];
  var act_digest = 0;

  for (var _iterator2 = _createForOfIteratorHelperLoose(actions), _step2; !(_step2 = _iterator2()).done;) {
    var action = _step2.value;
    action.receipt = {
      act_digest: act_digest++
    };
    action.block_time = action['@timestamp']; // Set quantity

    if (action.act.data && action.act.data.amount && action.act.data.symbol) {
      action.act.data.quantity = action.act.data.amount + " " + action.act.data.symbol;
    }

    transformedActions.push({
      action_trace: action
    });
  }

  return {
    lib: lib,
    actions: transformedActions,
    query_time: query_time,
    numOfTxLoaded: actions.length,
    total: {
      relation: relation,
      value: value
    }
  };
}
function dfuseTransformGetActions(_ref2, accountName, constants) {
  var transactions = _ref2.transactions,
      cursor = _ref2.cursor;

  // Error checking
  if (!transactions) {
    return {
      cursor: cursor,
      actions: [],
      numOfTxLoaded: 0
    };
  }

  var actions = [];

  for (var _iterator3 = _createForOfIteratorHelperLoose(transactions), _step3; !(_step3 = _iterator3()).done;) {
    var transaction = _step3.value;
    var lifecycle = transaction.lifecycle,
        action_idx = transaction.action_idx; // GRAPHQL -> DOesnt give action_idx since its match

    if (!action_idx) {
      actions = actions.concat(lifecycle['execution_trace']['action_traces'].map(function (action) {
        return {
          action_trace: action
        };
      }).reverse());
      continue;
    }

    var current_idx = 0;

    for (var _iterator4 = _createForOfIteratorHelperLoose(lifecycle['execution_trace']['action_traces']), _step4; !(_step4 = _iterator4()).done;) {
      var action_trace = _step4.value;
      // Fix holes
      if (!action_trace['inline_traces']) action_trace['inline_traces'] = []; // BP CLAIM REWARDS

      if (action_trace['act']['account'] === constants.EOSIO && action_trace['act']['name'] === 'claimrewards') {
        var totalAmount = 0;
        var totalSymbol = '';

        for (var _iterator5 = _createForOfIteratorHelperLoose(action_trace['inline_traces']), _step5; !(_step5 = _iterator5()).done;) {
          var inline_trace = _step5.value;

          if (inline_trace['act']['data']['from'] === constants.EOSIO_VPAY || inline_trace['act']['data']['from'] === constants.EOSIO_BPAY) {
            actions.push({
              action_trace: inline_trace
            });

            var _inline_trace$act$dat2 = inline_trace['act']['data']['quantity'].split(' '),
                amount = _inline_trace$act$dat2[0],
                symbol = _inline_trace$act$dat2[1];

            totalAmount += Number(amount);
            totalSymbol = symbol;
          }
        }

        action_trace['act']['data']['quantity'] = totalAmount.toFixed(constants.CORE_PRECISION) + " " + totalSymbol;
        delete action_trace.inline_traces;
        actions.push({
          action_trace: action_trace
        }); // REX sell
      } else if (action_trace['act']['account'] === constants.EOSIO && action_trace['act']['name'] === 'sellrex') {
        for (var _iterator6 = _createForOfIteratorHelperLoose(action_trace['inline_traces']), _step6; !(_step6 = _iterator6()).done;) {
          var _inline_trace = _step6.value;

          if (_inline_trace['act']['account'] === constants.EOSIO_REX || _inline_trace['act']['name'] === 'sellresult') {
            actions.push({
              action_trace: _inline_trace
            });
          }
        }

        delete action_trace.inline_traces;
        actions.push({
          action_trace: action_trace
        });
      } else {
        // This is done for ordering of TX
        var local_actions = [];
        current_idx = dfuseExtractActions(accountName, action_trace, local_actions, action_idx, current_idx);
        actions = actions.concat(local_actions.reverse());
      }

      current_idx++;
    }
  }

  return {
    cursor: cursor,
    actions: actions,
    numOfTxLoaded: transactions.length
  };
}

function dfuseExtractActions(accountName, action, traces, action_idx, current_idx) {
  if (action_idx.includes(current_idx)) {
    traces.push({
      action_trace: action
    });
  }

  if (action['inline_traces']) {
    for (var _iterator7 = _createForOfIteratorHelperLoose(action['inline_traces']), _step7; !(_step7 = _iterator7()).done;) {
      var inline_trace = _step7.value;
      current_idx++;
      current_idx = dfuseExtractActions(accountName, inline_trace, traces, action_idx, current_idx);
    }

    delete action['inline_traces'];
  }

  return current_idx;
}

function dfuseDepthFirstExtract(result) {
  var transactions = result.transactions,
      cursor = result.cursor;
  var actions = [];

  if (transactions) {
    for (var _iterator8 = _createForOfIteratorHelperLoose(transactions), _step8; !(_step8 = _iterator8()).done;) {
      var transaction = _step8.value;
      var lifecycle = transaction.lifecycle,
          action_idx = transaction.action_idx;
      var traces = lifecycle['execution_trace']['action_traces'];
      var current_idx = 0;

      for (var _iterator9 = _createForOfIteratorHelperLoose(traces), _step9; !(_step9 = _iterator9()).done;) {
        var trace = _step9.value;
        current_idx = dfuseDepthFirstExtractHelper(trace, lifecycle['dbops'], actions, action_idx, current_idx);
        current_idx++;
      }
    }
  }

  return {
    actions: actions,
    cursor: cursor
  };
}

function dfuseDepthFirstExtractHelper(action, dbops, allActions, action_idx, currentIdx) {
  if (action_idx && action_idx.includes(currentIdx)) {
    allActions.push({
      action_trace: action,
      dbops: dbops.filter(function (op) {
        return op.action_idx === currentIdx;
      })
    });
  }

  if (action['inline_traces']) {
    for (var _iterator10 = _createForOfIteratorHelperLoose(action['inline_traces']), _step10; !(_step10 = _iterator10()).done;) {
      var trace = _step10.value;
      currentIdx = dfuseDepthFirstExtractHelper(trace, dbops, allActions, action_idx, ++currentIdx);
    }
  }

  return currentIdx;
}

function hyperionTransformFlatTraces(traces) {
  var tracesByOrdinal = traces.reduce(function (acc, trace) {
    acc[trace.action_ordinal] = _extends({}, trace, {
      traces: [],
      account_ram_deltas: trace.account_ram_deltas,
      receivers: trace.notified
    });
    return acc;
  }, {});

  for (var _iterator11 = _createForOfIteratorHelperLoose(traces.sort(function (a, b) {
    return b.action_ordinal - a.action_ordinal;
  })), _step11; !(_step11 = _iterator11()).done;) {
    var trace = _step11.value;

    // Skip top level actions
    if (trace.creator_action_ordinal === 0 || !tracesByOrdinal[trace.creator_action_ordinal]) {
      continue;
    }

    var currentInlineTraces = tracesByOrdinal[trace.creator_action_ordinal].traces || [];
    var newInlineTraces = [tracesByOrdinal[trace.action_ordinal]];
    delete tracesByOrdinal[trace.action_ordinal];
    tracesByOrdinal[trace.creator_action_ordinal].traces = newInlineTraces.concat(currentInlineTraces);
  }

  var result = Object.values(tracesByOrdinal);
  return result;
}
function hyperionTransformTransaction(transaction) {
  var actions = transaction.actions,
      lib = transaction.lib,
      trx_id = transaction.trx_id;
  var firstAction = actions[0]; // Parent only on < 1.8

  var transformedActions = firstAction.parent ? actions.filter(function (trace) {
    return trace.parent === 0;
  }) : actions;
  var traces = hyperionTransformFlatTraces(actions);
  return {
    status: 'Executed',
    cpu_usage: firstAction.cpu_usage_us,
    net_usage: firstAction.net_usage_words * 8,
    id: trx_id,
    block_time: firstAction['@timestamp'],
    block_num: firstAction['block_num'],
    delay_sec: 'N/A',
    expiration: 'N/A',
    lib: lib,
    actions: transformedActions,
    traces: traces
  };
}
function dfuseTransformTrace(_ref3) {
  var trace = _ref3.trace,
      _ref3$dbops = _ref3.dbops,
      dbops = _ref3$dbops === void 0 ? [] : _ref3$dbops,
      _ref3$ramops = _ref3.ramops,
      ramops = _ref3$ramops === void 0 ? [] : _ref3$ramops,
      _ref3$index = _ref3.index,
      index = _ref3$index === void 0 ? 0 : _ref3$index;
  var transformed = {
    act: trace.act,
    account_ram_deltas: trace.account_ram_deltas,
    receivers: [trace.receipt.receiver],
    act_digest: trace.receipt.act_digest,
    dbops: (dbops || []).filter(function (op) {
      return op.action_idx === index;
    }),
    ramops: (ramops || []).filter(function (op) {
      return op.action_idx === index;
    }),
    traces: []
  };

  if (trace.inline_traces && trace.inline_traces.length) {
    trace.inline_traces.map(function (itrace) {
      index++; // If TX data is different

      if (itrace.act.hex_data !== transformed.act.hex_data || itrace.act.name !== transformed.act.name || itrace.act.account !== transformed.act.account) {
        transformed.traces.push(dfuseTransformTrace({
          trace: itrace,
          index: index,
          ramops: ramops,
          dbops: dbops
        })); // Hex data is same, but still add in inline
      } else {
        if (itrace.inline_traces && itrace.inline_traces.length) {
          for (var _iterator12 = _createForOfIteratorHelperLoose(itrace.inline_traces), _step12; !(_step12 = _iterator12()).done;) {
            var iitrace = _step12.value;
            index++;
            transformed.traces.push(dfuseTransformTrace({
              trace: iitrace,
              index: index,
              ramops: ramops,
              dbops: dbops
            }));
          }
        } // Add Receivers even if not different


        if (!transformed.receivers.includes(itrace.receipt.receiver)) {
          transformed.receivers.push(itrace.receipt.receiver);
        } // Add db ops and ram ops even if not different


        transformed.dbops = transformed.dbops.concat((dbops || []).filter(function (op) {
          return op.action_idx === index;
        }));
        transformed.ramops = transformed.ramops.concat((ramops || []).filter(function (op) {
          return op.action_idx === index;
        }));
      }
    });
  }

  return transformed;
}
function dfuseTransformTransaction(result) {
  var execution_trace = result.execution_trace,
      transaction = result.transaction,
      ramops = result.ramops,
      dbops = result.dbops,
      created_by = result.created_by;
  var count = 0;
  var actions = (execution_trace['action_traces'] || []).map(function (trace) {
    var transformedTrace = dfuseTransformTrace({
      trace: trace,
      ramops: ramops,
      dbops: dbops,
      index: count
    }); // Increment counts

    var traceCount = inlineTraceCountHelper([trace]);
    count += traceCount;
    return transformedTrace;
  });
  return {
    status: execution_trace.receipt.status,
    cpu_usage: execution_trace.receipt.cpu_usage_us,
    net_usage: execution_trace.receipt.net_usage_words * 8,
    id: execution_trace.id,
    block_time: execution_trace.block_time,
    block_num: execution_trace.block_num,
    delay_sec: transaction.delay_sec,
    expiration: transaction.expiration,
    created_by: created_by,
    actions: actions,
    traces: actions
  };
}
function dfuseTransformDeferredAction(action) {
  return {
    act: _extends({}, action),
    account_ram_deltas: [],
    receivers: [],
    act_digest: '',
    traces: []
  };
}
function dfuseTransformDeferredTransaction(result) {
  var actions = result.transaction.actions.map(dfuseTransformDeferredAction);
  return {
    id: result.id,
    status: 'deferred',
    dfuse_status: result.transaction_status,
    sender: result.created_by.sender,
    payer: result.created_by.payer,
    published: result.created_by.published_at,
    delay_until: result.created_by.delay_until,
    expiration: result.transaction.expiration,
    delay_sec: result.transaction.delay_sec,
    actions: actions,
    traces: actions
  };
}
function dfuseTransformTransactionResult(result) {
  return result.execution_trace ? dfuseTransformTransaction(result) : dfuseTransformDeferredTransaction(result);
}
function historyTransformDeferredAction(action) {
  return _extends({}, action, {
    account_ram_deltas: [],
    receiver: '',
    act_digest: '',
    traces: []
  });
}
function historyTransformDeferredTransaction(transaction) {
  return {
    id: transaction.trx_id,
    status: 'deferred',
    sender: transaction.sender,
    payer: transaction.payer,
    published: transaction.published,
    expiration: transaction.expiration,
    delay_until: transaction.delay_until,
    delay_sec: transaction.transaction.delay_sec,
    actions: transaction.transaction.actions,
    traces: transaction.transaction.actions.map(function (action) {
      return historyTransformDeferredAction(action);
    })
  };
}
function historyTransformRecursiveTrace(action) {
  var transformed = {
    act: action.act,
    account_ram_deltas: action.account_ram_deltas || [],
    receivers: [action.receipt.receiver],
    act_digest: action.receipt.act_digest,
    traces: []
  };

  if (action.inline_traces && action.inline_traces.length) {
    action.inline_traces.forEach(function (trace) {
      var sameAsParent = trace.receipt.act_digest === action.receipt.act_digest; // Actions done in response to notification -> Add in inline traces

      if (sameAsParent && trace.inline_traces && trace.inline_traces.length) {
        transformed.traces = transformed.traces.concat(trace.inline_traces.map(historyTransformRecursiveTrace));

        if (!transformed.receivers.includes(trace.receipt.receiver)) {
          transformed.receivers.push(trace.receipt.receiver);
        } // Normal action

      } else if (!sameAsParent) {
        transformed.traces.push(historyTransformRecursiveTrace(trace)); // Normal notification
      } else {
        if (!transformed.receivers.includes(trace.receipt.receiver)) {
          transformed.receivers.push(trace.receipt.receiver);
        }
      }
    });
  }

  return transformed;
}
function historyTransformFlatTraces(traces) {
  var tracesByOrdinal = traces.reduce(function (acc, trace) {
    acc[trace.action_ordinal] = trace;
    return acc;
  }, {});

  for (var _iterator13 = _createForOfIteratorHelperLoose(traces.sort(function (a, b) {
    return b.action_ordinal - a.action_ordinal;
  })), _step13; !(_step13 = _iterator13()).done;) {
    var trace = _step13.value;

    // Skip top level actions
    if (trace.creator_action_ordinal === 0) {
      continue;
    }

    var currentInlineTraces = tracesByOrdinal[trace.creator_action_ordinal].inline_traces || [];
    var newInlineTraces = [tracesByOrdinal[trace.action_ordinal]];
    tracesByOrdinal[trace.creator_action_ordinal].inline_traces = newInlineTraces.concat(currentInlineTraces);
  }

  var result = Object.values(tracesByOrdinal).filter(function (trace) {
    return trace.creator_action_ordinal === 0;
  }).map(function (trace) {
    return _extends({}, trace, {
      receivers: [trace.receipt.receiver],
      act_digest: trace.receipt.act_digest
    });
  });
  return result;
}

function findIfSameTx(inline_traces, act) {
  var match = false;

  for (var _iterator14 = _createForOfIteratorHelperLoose(inline_traces), _step14; !(_step14 = _iterator14()).done;) {
    var trace = _step14.value;

    if (trace.act.hex_data === act.hex_data && trace.act.name === act.name && trace.act.account === act.account || findIfSameTx(trace.inline_traces, act)) {
      return true;
    }
  }

  return match;
}

function inlineTraceCountHelper(traces) {
  return traces.reduce(function (acc, trace) {
    return acc + 1 + inlineTraceCountHelper(trace.inline_traces || []);
  }, 0);
}

function historyTransformTransaction(transaction) {
  if (transaction.trx) {
    var actions = [];
    var delay_sec;
    var expiration;
    var traces; // >= 1.8 traces

    if (transaction.traces && transaction.traces.length && 'creator_action_ordinal' in transaction.traces[0]) {
      traces = historyTransformFlatTraces(transaction.traces).map(historyTransformRecursiveTrace);
      actions = transaction.traces.filter(function (trace) {
        return trace.creator_action_ordinal === 0;
      }); // 1.7 and under nodeos
    } else {
      var _loop = function _loop() {
        var _step15$value = _step15.value,
            i = _step15$value[0],
            action = _step15$value[1];
        var tempTraces = transaction.traces.slice();
        tempTraces.splice(i, i + 1);
        var foundSameHex = tempTraces.find(function (trace) {
          return findIfSameTx(trace.inline_traces.slice(), action.act);
        });

        if (!foundSameHex) {
          actions.push(action);
        }
      };

      for (var _iterator15 = _createForOfIteratorHelperLoose(transaction.traces.entries()), _step15; !(_step15 = _iterator15()).done;) {
        _loop();
      }

      traces = actions.map(function (action) {
        return historyTransformRecursiveTrace(action);
      }); // Normal not deferred TX

      if (transaction.trx.trx) {
        delay_sec = transaction.trx.trx.delay_sec;
        expiration = transaction.trx.trx.expiration; // Deferred TX
      } else {
        delay_sec = 'N/A';
        expiration = 'N/A';
      } // Fix for empty array (hex data fucked up) WTF?


      if (transaction.traces.length > 0 && actions.length === 0) {
        actions = [];
        var counter = 0;
        var i = 0;

        for (var _iterator16 = _createForOfIteratorHelperLoose(transaction.traces), _step16; !(_step16 = _iterator16()).done;) {
          var _tx = _step16.value;

          if (i >= counter) {
            actions.push(_tx);
          }

          counter += inlineTraceCountHelper(_tx.inline_traces);
          i++;
        }

        traces = actions.map(function (action) {
          return historyTransformRecursiveTrace(action);
        });
      } // Fix for empty trace (block hint used?)


      if (transaction.traces.length === 0 && actions.length === 0 && transaction.trx.trx && transaction.trx.trx.actions && transaction.trx.trx.actions.length) {
        traces = transaction.trx.trx.actions.map(function (action) {
          return {
            act: action,
            account_ram_deltas: [],
            receivers: action.authorization.map(function (auth) {
              return auth.actor;
            }),
            act_digest: '',
            traces: []
          };
        });
        actions = traces;
      }
    } // For display


    var extraFields = _extends({}, transaction, transaction.trx.receipt, transaction.trx.trx || {});

    var tx = _extends({}, extraFields, {
      status: transaction.trx.receipt.status,
      cpu_usage: transaction.trx.receipt.cpu_usage_us,
      net_usage: transaction.trx.receipt.net_usage_words * 8,
      id: transaction.id,
      block_time: transaction.block_time,
      block_num: transaction.block_num,
      delay_sec: delay_sec,
      expiration: expiration,
      actions: actions,
      traces: traces
    });

    return tx; // MEETONE history
  } else if (transaction.action_traces) {
    return dfuseTransformTransaction(transaction); // On block
  } else {
    var _traces = transaction.traces.map(function (trace) {
      return historyTransformRecursiveTrace(trace);
    });

    return {
      status: 'executed',
      cpu_usage: 0,
      net_usage: 0,
      id: transaction.id,
      block_time: transaction.block_time,
      block_num: transaction.block_num,
      delay_sec: 0,
      expiration: 0,
      actions: _traces,
      traces: _traces
    };
  }
}

function hexToUint8Array(hex) {
  if (typeof hex !== 'string') {
    throw new Error('Expected string containing hex digits');
  }

  if (hex.length % 2) {
    throw new Error('Odd number of hex digits');
  }

  var l = hex.length / 2;
  var result = new Uint8Array(l);

  for (var i = 0; i < l; ++i) {
    var x = parseInt(hex.substr(i * 2, 2), 16);

    if (Number.isNaN(x)) {
      throw new Error('Expected hex string');
    }

    result[i] = x;
  }

  return result;
}

function urlBuilder(url, id, params) {
  params = params || {};

  if (typeof id !== 'undefined' && id !== null) {
    url += "/" + encodeURIComponent(id);
  }

  if (Object.keys(params).length !== 0) {
    var queryString = qs__WEBPACK_IMPORTED_MODULE_2___default().stringify(params);
    url += "?" + queryString;
  }

  return url;
}

function copy(text) {
  var selected = false;
  var el = document.createElement('textarea');
  el.value = text;
  el.setAttribute('readonly', '');
  el.style.position = 'absolute';
  el.style.left = '-9999px';
  document.body.appendChild(el);
  var selection = document.getSelection();

  if (selection && selection.rangeCount > 0) {
    selected = selection.getRangeAt(0);
  }

  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);

  if (selection && selected) {
    selection.removeAllRanges();
    selection.addRange(selected);
  }
}

var Nft = function Nft(_ref) {
  var idata = _ref.idata,
      mdata = _ref.mdata,
      name = _ref.name,
      image = _ref.image,
      video = _ref.video,
      model = _ref.model,
      audio = _ref.audio,
      stage = _ref.stage,
      skybox = _ref.skybox,
      pdf = _ref.pdf,
      id = _ref.id,
      contract = _ref.contract,
      link = _ref.link,
      owner = _ref.owner,
      author = _ref.author,
      collection = _ref.collection,
      mint = _ref.mint,
      edition_size = _ref.edition_size;
  this.idata = idata;
  this.mdata = mdata;
  this.name = name;
  this.image = image;
  this.video = video;
  this.model = model;
  this.audio = audio;
  this.stage = stage;
  this.skybox = skybox;
  this.pdf = pdf;
  this.id = id;
  this.contract = contract;
  this.link = link;
  this.owner = owner;
  this.author = author;
  this.collection = collection;
  this.mint = mint;
  this.edition_size = edition_size;
};

function parseIpfs(imageUrl) {
  if (!imageUrl) {
    return imageUrl;
  }

  if (imageUrl.substring(0, 2) === 'Qm') {
    imageUrl = "https://cloudflare-ipfs.com/ipfs/" + imageUrl;
  }

  return imageUrl;
}

function parseSaNft(nft) {
  var name = nft.idata && nft.idata.name || nft.mdata && nft.mdata.name;
  var imageUrl = parseIpfs(nft.idata && (nft.idata.img || nft.idata.image) || nft.mdata && (nft.mdata.img || nft.mdata.img));
  var videoUrl = parseIpfs(nft.idata && nft.idata.video || nft.mdata && nft.mdata.video);
  var audioUrl = parseIpfs(nft.idata && nft.idata.audio || nft.mdata && nft.mdata.audio);
  var modelUrl = parseIpfs(nft.idata && nft.idata.model || nft.mdata && nft.mdata.model);
  var stageUrl = parseIpfs(nft.idata && nft.idata.stage || nft.mdata && nft.mdata.stage);
  var pdfUrl = parseIpfs(nft.idata && nft.idata.pdf || nft.mdata && nft.mdata.pdf);
  var skyboxUrl = parseIpfs(nft.idata && nft.idata.skybox || nft.mdata && nft.mdata.skybox);
  var nftObj = new Nft({
    idata: nft.idata,
    mdata: nft.mdata,
    name: name,
    image: imageUrl,
    video: videoUrl,
    model: modelUrl,
    audio: audioUrl,
    stage: stageUrl,
    skybox: skyboxUrl,
    pdf: pdfUrl,
    id: nft.assetId,
    contract: 'simpleassets',
    link: "/nft/" + nft.assetId,
    owner: nft.owner,
    author: nft.author,
    mint: nft.extra && nft.extra.mintNumber,
    collection: nft.category,
    edition_size: nft.extra && nft.extra.totalMinted
  });
  return nftObj;
}
function parseAaNft(nft) {
  var imageUrl = parseIpfs(nft.data.img || nft.data.image);
  var videoUrl = parseIpfs(nft.data.video);
  var audioUrl = parseIpfs(nft.data.audio);
  var modelUrl = parseIpfs(nft.data.model);
  var stageUrl = parseIpfs(nft.data.stage);
  var skyboxUrl = parseIpfs(nft.data.skybox);
  var pdfUrl = parseIpfs(nft.data.pdf);
  var idata = nft.immutable_data;

  if (nft.template && nft.template.immutable_data) {
    idata = _extends({}, idata, nft.template.immutable_data);
  }

  var nftObj = new Nft({
    idata: idata,
    mdata: nft.mutable_data,
    name: nft.name || nft.data.name || nft.asset_id,
    image: imageUrl,
    video: videoUrl,
    model: modelUrl,
    audio: audioUrl,
    stage: stageUrl,
    skybox: skyboxUrl,
    pdf: pdfUrl,
    id: nft.asset_id,
    contract: 'atomicassets',
    link: "/nft/" + nft.asset_id,
    owner: nft.owner,
    author: nft.collection.author,
    collection: nft.collection.collection_name,
    mint: nft.template_mint ? +nft.template_mint : undefined,
    edition_size: nft.template ? +nft.template.max_supply || +nft.template.issued_supply : undefined
  });
  return nftObj;
}

function wait(_x) {
  return _wait.apply(this, arguments);
}

function _wait() {
  _wait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ms) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new Promise(function (resolve) {
              setTimeout(resolve, ms);
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _wait.apply(this, arguments);
}

/**
 * Native
 */
var DbopOp;

(function (DbopOp) {
  DbopOp["Ins"] = "INS";
  DbopOp["Rem"] = "REM";
  DbopOp["Upd"] = "UPD";
})(DbopOp || (DbopOp = {}));


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./node_modules/@jafri/numbro/dist/numbro.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jafri/numbro/dist/numbro.min.js ***!
  \*******************************************************/
/***/ ((module) => {

!function(e){if(true)module.exports=e();else {}}(function(){return function a(o,u,c){function s(t,e){if(!u[t]){if(!o[t]){var r=undefined;if(!e&&r)return require(t,!0);if(l)return l(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=u[t]={exports:{}};o[t][0].call(i.exports,function(e){return s(o[t][1][e]||e)},i,i.exports,a,o,u,c)}return u[t].exports}for(var l=undefined,e=0;e<c.length;e++)s(c[e]);return s}({1:[function(e,r,t){!function(e){"use strict";var t,C=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,T=Math.ceil,U=Math.floor,R="[BigNumber Error] ",I=R+"Number primitive has more than 15 significant digits: ",$=1e14,G=14,V=9007199254740991,q=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],Z=1e7,z=1e9;function W(e){var t=0|e;return 0<e||e===t?t:t-1}function H(e){for(var t,r,n=1,i=e.length,a=e[0]+"";n<i;){for(t=e[n++]+"",r=G-t.length;r--;t="0"+t);a+=t}for(i=a.length;48===a.charCodeAt(--i););return a.slice(0,i+1||1)}function Y(e,t){var r,n,i=e.c,a=t.c,o=e.s,u=t.s,c=e.e,s=t.e;if(!o||!u)return null;if(r=i&&!i[0],n=a&&!a[0],r||n)return r?n?0:-u:o;if(o!=u)return o;if(r=o<0,n=c==s,!i||!a)return n?0:!i^r?1:-1;if(!n)return s<c^r?1:-1;for(u=(c=i.length)<(s=a.length)?c:s,o=0;o<u;o++)if(i[o]!=a[o])return i[o]>a[o]^r?1:-1;return c==s?0:s<c^r?1:-1}function K(e,t,r,n){if(e<t||r<e||e!==U(e))throw Error(R+(n||"Argument")+("number"==typeof e?e<t||r<e?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function J(e){var t=e.c.length-1;return W(e.e/G)==t&&e.c[t]%2!=0}function X(e,t){return(1<e.length?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function Q(e,t,r){var n,i;if(t<0){for(i=r+".";++t;i+=r);e=i+e}else if(++t>(n=e.length)){for(i=r,t-=n;--t;i+=r);e+=i}else t<n&&(e=e.slice(0,t)+"."+e.slice(t));return e}(t=function e(t){var v,f,p,r,s,m,o,u,c,l,g,n=A.prototype={constructor:A,toString:null,valueOf:null},h=new A(1),y=20,b=4,d=-7,w=21,S=-1e7,x=1e7,O=!1,a=1,N=0,B={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:" ",suffix:""},M="0123456789abcdefghijklmnopqrstuvwxyz";function A(e,t){var r,n,i,a,o,u,c,s,l=this;if(!(l instanceof A))return new A(e,t);if(null==t){if(e&&!0===e._isBigNumber)return l.s=e.s,void(!e.c||e.e>x?l.c=l.e=null:e.e<S?l.c=[l.e=0]:(l.e=e.e,l.c=e.c.slice()));if((u="number"==typeof e)&&0*e==0){if(l.s=1/e<0?(e=-e,-1):1,e===~~e){for(a=0,o=e;10<=o;o/=10,a++);return void(x<a?l.c=l.e=null:(l.e=a,l.c=[e]))}s=String(e)}else{if(!C.test(s=String(e)))return p(l,s,u);l.s=45==s.charCodeAt(0)?(s=s.slice(1),-1):1}-1<(a=s.indexOf("."))&&(s=s.replace(".","")),0<(o=s.search(/e/i))?(a<0&&(a=o),a+=+s.slice(o+1),s=s.substring(0,o)):a<0&&(a=s.length)}else{if(K(t,2,M.length,"Base"),10==t)return P(l=new A(e),y+l.e+1,b);if(s=String(e),u="number"==typeof e){if(0*e!=0)return p(l,s,u,t);if(l.s=1/e<0?(s=s.slice(1),-1):1,A.DEBUG&&15<s.replace(/^0\.0*|\./,"").length)throw Error(I+e)}else l.s=45===s.charCodeAt(0)?(s=s.slice(1),-1):1;for(r=M.slice(0,t),a=o=0,c=s.length;o<c;o++)if(r.indexOf(n=s.charAt(o))<0){if("."==n){if(a<o){a=c;continue}}else if(!i&&(s==s.toUpperCase()&&(s=s.toLowerCase())||s==s.toLowerCase()&&(s=s.toUpperCase()))){i=!0,o=-1,a=0;continue}return p(l,String(e),u,t)}u=!1,-1<(a=(s=f(s,t,10,l.s)).indexOf("."))?s=s.replace(".",""):a=s.length}for(o=0;48===s.charCodeAt(o);o++);for(c=s.length;48===s.charCodeAt(--c););if(s=s.slice(o,++c)){if(c-=o,u&&A.DEBUG&&15<c&&(V<e||e!==U(e)))throw Error(I+l.s*e);if((a=a-o-1)>x)l.c=l.e=null;else if(a<S)l.c=[l.e=0];else{if(l.e=a,l.c=[],o=(a+1)%G,a<0&&(o+=G),o<c){for(o&&l.c.push(+s.slice(0,o)),c-=G;o<c;)l.c.push(+s.slice(o,o+=G));o=G-(s=s.slice(o)).length}else o-=c;for(;o--;s+="0");l.c.push(+s)}}else l.c=[l.e=0]}function D(e,t,r,n){for(var i,a,o=[0],u=0,c=e.length;u<c;){for(a=o.length;a--;o[a]*=t);for(o[0]+=n.indexOf(e.charAt(u++)),i=0;i<o.length;i++)o[i]>r-1&&(null==o[i+1]&&(o[i+1]=0),o[i+1]+=o[i]/r|0,o[i]%=r)}return o.reverse()}function E(e,t,r){var n,i,a,o,u=0,c=e.length,s=t%Z,l=t/Z|0;for(e=e.slice();c--;)u=((i=s*(a=e[c]%Z)+(n=l*a+(o=e[c]/Z|0)*s)%Z*Z+u)/r|0)+(n/Z|0)+l*o,e[c]=i%r;return u&&(e=[u].concat(e)),e}function F(e,t,r,n){var i,a;if(r!=n)a=n<r?1:-1;else for(i=a=0;i<r;i++)if(e[i]!=t[i]){a=e[i]>t[i]?1:-1;break}return a}function k(e,t,r,n){for(var i=0;r--;)e[r]-=i,i=e[r]<t[r]?1:0,e[r]=i*n+e[r]-t[r];for(;!e[0]&&1<e.length;e.splice(0,1));}function i(e,t,r,n){var i,a,o,u,c;if(null==r?r=b:K(r,0,8),!e.c)return e.toString();if(i=e.c[0],o=e.e,null==t)c=H(e.c),c=1==n||2==n&&(o<=d||w<=o)?X(c,o):Q(c,o,"0");else if(a=(e=P(new A(e),t,r)).e,u=(c=H(e.c)).length,1==n||2==n&&(t<=a||a<=d)){for(;u<t;c+="0",u++);c=X(c,a)}else if(t-=o,c=Q(c,a,"0"),u<a+1){if(0<--t)for(c+=".";t--;c+="0");}else if(0<(t+=a-u))for(a+1==u&&(c+=".");t--;c+="0");return e.s<0&&i?"-"+c:c}function _(e,t){for(var r,n=1,i=new A(e[0]);n<e.length;n++){if(!(r=new A(e[n])).s){i=r;break}t.call(i,r)&&(i=r)}return i}function L(e,t,r){for(var n=1,i=t.length;!t[--i];t.pop());for(i=t[0];10<=i;i/=10,n++);return(r=n+r*G-1)>x?e.c=e.e=null:r<S?e.c=[e.e=0]:(e.e=r,e.c=t),e}function P(e,t,r,n){var i,a,o,u,c,s,l,f=e.c,p=q;if(f){e:{for(i=1,u=f[0];10<=u;u/=10,i++);if((a=t-i)<0)a+=G,o=t,l=(c=f[s=0])/p[i-o-1]%10|0;else if((s=T((a+1)/G))>=f.length){if(!n)break e;for(;f.length<=s;f.push(0));c=l=0,o=(a%=G)-G+(i=1)}else{for(c=u=f[s],i=1;10<=u;u/=10,i++);l=(o=(a%=G)-G+i)<0?0:c/p[i-o-1]%10|0}if(n=n||t<0||null!=f[s+1]||(o<0?c:c%p[i-o-1]),n=r<4?(l||n)&&(0==r||r==(e.s<0?3:2)):5<l||5==l&&(4==r||n||6==r&&(0<a?0<o?c/p[i-o]:0:f[s-1])%10&1||r==(e.s<0?8:7)),t<1||!f[0])return f.length=0,n?(t-=e.e+1,f[0]=p[(G-t%G)%G],e.e=-t||0):f[0]=e.e=0,e;if(0==a?(f.length=s,u=1,s--):(f.length=s+1,u=p[G-a],f[s]=0<o?U(c/p[i-o]%p[o])*u:0),n)for(;;){if(0==s){for(a=1,o=f[0];10<=o;o/=10,a++);for(o=f[0]+=u,u=1;10<=o;o/=10,u++);a!=u&&(e.e++,f[0]==$&&(f[0]=1));break}if(f[s]+=u,f[s]!=$)break;f[s--]=0,u=1}for(a=f.length;0===f[--a];f.pop());}e.e>x?e.c=e.e=null:e.e<S&&(e.c=[e.e=0])}return e}function j(e){var t,r=e.e;return null===r?e.toString():(t=H(e.c),t=r<=d||w<=r?X(t,r):Q(t,r,"0"),e.s<0?"-"+t:t)}return A.clone=e,A.ROUND_UP=0,A.ROUND_DOWN=1,A.ROUND_CEIL=2,A.ROUND_FLOOR=3,A.ROUND_HALF_UP=4,A.ROUND_HALF_DOWN=5,A.ROUND_HALF_EVEN=6,A.ROUND_HALF_CEIL=7,A.ROUND_HALF_FLOOR=8,A.EUCLID=9,A.config=A.set=function(e){var t,r;if(null!=e){if("object"!=typeof e)throw Error(R+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(K(r=e[t],0,z,t),y=r),e.hasOwnProperty(t="ROUNDING_MODE")&&(K(r=e[t],0,8,t),b=r),e.hasOwnProperty(t="EXPONENTIAL_AT")&&((r=e[t])&&r.pop?(K(r[0],-z,0,t),K(r[1],0,z,t),d=r[0],w=r[1]):(K(r,-z,z,t),d=-(w=r<0?-r:r))),e.hasOwnProperty(t="RANGE"))if((r=e[t])&&r.pop)K(r[0],-z,-1,t),K(r[1],1,z,t),S=r[0],x=r[1];else{if(K(r,-z,z,t),!r)throw Error(R+t+" cannot be zero: "+r);S=-(x=r<0?-r:r)}if(e.hasOwnProperty(t="CRYPTO")){if((r=e[t])!==!!r)throw Error(R+t+" not true or false: "+r);if(r){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw O=!r,Error(R+"crypto unavailable");O=r}else O=r}if(e.hasOwnProperty(t="MODULO_MODE")&&(K(r=e[t],0,9,t),a=r),e.hasOwnProperty(t="POW_PRECISION")&&(K(r=e[t],0,z,t),N=r),e.hasOwnProperty(t="FORMAT")){if("object"!=typeof(r=e[t]))throw Error(R+t+" not an object: "+r);B=r}if(e.hasOwnProperty(t="ALPHABET")){if("string"!=typeof(r=e[t])||/^.?$|[+\-.\s]|(.).*\1/.test(r))throw Error(R+t+" invalid: "+r);M=r}}return{DECIMAL_PLACES:y,ROUNDING_MODE:b,EXPONENTIAL_AT:[d,w],RANGE:[S,x],CRYPTO:O,MODULO_MODE:a,POW_PRECISION:N,FORMAT:B,ALPHABET:M}},A.isBigNumber=function(e){if(!e||!0!==e._isBigNumber)return!1;if(!A.DEBUG)return!0;var t,r,n=e.c,i=e.e,a=e.s;e:if("[object Array]"=={}.toString.call(n)){if((1===a||-1===a)&&-z<=i&&i<=z&&i===U(i)){if(0===n[0]){if(0===i&&1===n.length)return!0;break e}if((t=(i+1)%G)<1&&(t+=G),String(n[0]).length==t){for(t=0;t<n.length;t++)if((r=n[t])<0||$<=r||r!==U(r))break e;if(0!==r)return!0}}}else if(null===n&&null===i&&(null===a||1===a||-1===a))return!0;throw Error(R+"Invalid BigNumber: "+e)},A.maximum=A.max=function(){return _(arguments,n.lt)},A.minimum=A.min=function(){return _(arguments,n.gt)},A.random=(r=9007199254740992,s=Math.random()*r&2097151?function(){return U(Math.random()*r)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var t,r,n,i,a,o=0,u=[],c=new A(h);if(null==e?e=y:K(e,0,z),i=T(e/G),O)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(i*=2));o<i;)9e15<=(a=131072*t[o]+(t[o+1]>>>11))?(r=crypto.getRandomValues(new Uint32Array(2)),t[o]=r[0],t[o+1]=r[1]):(u.push(a%1e14),o+=2);o=i/2}else{if(!crypto.randomBytes)throw O=!1,Error(R+"crypto unavailable");for(t=crypto.randomBytes(i*=7);o<i;)9e15<=(a=281474976710656*(31&t[o])+1099511627776*t[o+1]+4294967296*t[o+2]+16777216*t[o+3]+(t[o+4]<<16)+(t[o+5]<<8)+t[o+6])?crypto.randomBytes(7).copy(t,o):(u.push(a%1e14),o+=7);o=i/7}if(!O)for(;o<i;)(a=s())<9e15&&(u[o++]=a%1e14);for(i=u[--o],e%=G,i&&e&&(a=q[G-e],u[o]=U(i/a)*a);0===u[o];u.pop(),o--);if(o<0)u=[n=0];else{for(n=-1;0===u[0];u.splice(0,1),n-=G);for(o=1,a=u[0];10<=a;a/=10,o++);o<G&&(n-=G-o)}return c.e=n,c.c=u,c}),A.sum=function(){for(var e=1,t=arguments,r=new A(t[0]);e<t.length;)r=r.plus(t[e++]);return r},m="0123456789",f=function(e,t,r,n,i){var a,o,u,c,s,l,f,p,g=e.indexOf("."),d=y,h=b;for(0<=g&&(c=N,N=0,e=e.replace(".",""),l=(p=new A(t)).pow(e.length-g),N=c,p.c=D(Q(H(l.c),l.e,"0"),10,r,m),p.e=p.c.length),u=c=(f=D(e,t,r,i?(a=M,m):(a=m,M))).length;0==f[--c];f.pop());if(!f[0])return a.charAt(0);if(g<0?--u:(l.c=f,l.e=u,l.s=n,f=(l=v(l,p,d,h,r)).c,s=l.r,u=l.e),g=f[o=u+d+1],c=r/2,s=s||o<0||null!=f[o+1],s=h<4?(null!=g||s)&&(0==h||h==(l.s<0?3:2)):c<g||g==c&&(4==h||s||6==h&&1&f[o-1]||h==(l.s<0?8:7)),o<1||!f[0])e=s?Q(a.charAt(1),-d,a.charAt(0)):a.charAt(0);else{if(f.length=o,s)for(--r;++f[--o]>r;)f[o]=0,o||(++u,f=[1].concat(f));for(c=f.length;!f[--c];);for(g=0,e="";g<=c;e+=a.charAt(f[g++]));e=Q(e,u,a.charAt(0))}return e},v=function(e,t,r,n,i){var a,o,u,c,s,l,f,p,g,d,h,v,m,y,b,w,S,x=e.s==t.s?1:-1,O=e.c,N=t.c;if(!(O&&O[0]&&N&&N[0]))return new A(e.s&&t.s&&(O?!N||O[0]!=N[0]:N)?O&&0==O[0]||!N?0*x:x/0:NaN);for(g=(p=new A(x)).c=[],x=r+(o=e.e-t.e)+1,i||(i=$,o=W(e.e/G)-W(t.e/G),x=x/G|0),u=0;N[u]==(O[u]||0);u++);if(N[u]>(O[u]||0)&&o--,x<0)g.push(1),c=!0;else{for(y=O.length,w=N.length,x+=2,1<(s=U(i/(N[u=0]+1)))&&(N=E(N,s,i),O=E(O,s,i),w=N.length,y=O.length),m=w,h=(d=O.slice(0,w)).length;h<w;d[h++]=0);S=N.slice(),S=[0].concat(S),b=N[0],N[1]>=i/2&&b++;do{if(s=0,(a=F(N,d,w,h))<0){if(v=d[0],w!=h&&(v=v*i+(d[1]||0)),1<(s=U(v/b)))for(i<=s&&(s=i-1),f=(l=E(N,s,i)).length,h=d.length;1==F(l,d,f,h);)s--,k(l,w<f?S:N,f,i),f=l.length,a=1;else 0==s&&(a=s=1),f=(l=N.slice()).length;if(f<h&&(l=[0].concat(l)),k(d,l,h,i),h=d.length,-1==a)for(;F(N,d,w,h)<1;)s++,k(d,w<h?S:N,h,i),h=d.length}else 0===a&&(s++,d=[0]);g[u++]=s,d[0]?d[h++]=O[m]||0:(d=[O[m]],h=1)}while((m++<y||null!=d[0])&&x--);c=null!=d[0],g[0]||g.splice(0,1)}if(i==$){for(u=1,x=g[0];10<=x;x/=10,u++);P(p,r+(p.e=u+o*G-1)+1,n,c)}else p.e=o,p.r=+c;return p},o=/^(-?)0([xbo])(?=\w[\w.]*$)/i,u=/^([^.]+)\.$/,c=/^\.([^.]+)$/,l=/^-?(Infinity|NaN)$/,g=/^\s*\+(?=[\w.])|^\s+|\s+$/g,p=function(e,t,r,n){var i,a=r?t:t.replace(g,"");if(l.test(a))e.s=isNaN(a)?null:a<0?-1:1;else{if(!r&&(a=a.replace(o,function(e,t,r){return i="x"==(r=r.toLowerCase())?16:"b"==r?2:8,n&&n!=i?e:t}),n&&(i=n,a=a.replace(u,"$1").replace(c,"0.$1")),t!=a))return new A(a,i);if(A.DEBUG)throw Error(R+"Not a"+(n?" base "+n:"")+" number: "+t);e.s=null}e.c=e.e=null},n.absoluteValue=n.abs=function(){var e=new A(this);return e.s<0&&(e.s=1),e},n.comparedTo=function(e,t){return Y(this,new A(e,t))},n.decimalPlaces=n.dp=function(e,t){var r,n,i;if(null!=e)return K(e,0,z),null==t?t=b:K(t,0,8),P(new A(this),e+this.e+1,t);if(!(r=this.c))return null;if(n=((i=r.length-1)-W(this.e/G))*G,i=r[i])for(;i%10==0;i/=10,n--);return n<0&&(n=0),n},n.dividedBy=n.div=function(e,t){return v(this,new A(e,t),y,b)},n.dividedToIntegerBy=n.idiv=function(e,t){return v(this,new A(e,t),0,1)},n.exponentiatedBy=n.pow=function(e,t){var r,n,i,a,o,u,c,s,l=this;if((e=new A(e)).c&&!e.isInteger())throw Error(R+"Exponent not an integer: "+j(e));if(null!=t&&(t=new A(t)),o=14<e.e,!l.c||!l.c[0]||1==l.c[0]&&!l.e&&1==l.c.length||!e.c||!e.c[0])return s=new A(Math.pow(+j(l),o?2-J(e):+j(e))),t?s.mod(t):s;if(u=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new A(NaN);(n=!u&&l.isInteger()&&t.isInteger())&&(l=l.mod(t))}else{if(9<e.e&&(0<l.e||l.e<-1||(0==l.e?1<l.c[0]||o&&24e7<=l.c[1]:l.c[0]<8e13||o&&l.c[0]<=9999975e7)))return a=l.s<0&&J(e)?-0:0,-1<l.e&&(a=1/a),new A(u?1/a:a);N&&(a=T(N/G+2))}for(c=o?(r=new A(.5),u&&(e.s=1),J(e)):(i=Math.abs(+j(e)))%2,s=new A(h);;){if(c){if(!(s=s.times(l)).c)break;a?s.c.length>a&&(s.c.length=a):n&&(s=s.mod(t))}if(i){if(0===(i=U(i/2)))break;c=i%2}else if(P(e=e.times(r),e.e+1,1),14<e.e)c=J(e);else{if(0==(i=+j(e)))break;c=i%2}l=l.times(l),a?l.c&&l.c.length>a&&(l.c.length=a):n&&(l=l.mod(t))}return n?s:(u&&(s=h.div(s)),t?s.mod(t):a?P(s,N,b,void 0):s)},n.integerValue=function(e){var t=new A(this);return null==e?e=b:K(e,0,8),P(t,t.e+1,e)},n.isEqualTo=n.eq=function(e,t){return 0===Y(this,new A(e,t))},n.isFinite=function(){return!!this.c},n.isGreaterThan=n.gt=function(e,t){return 0<Y(this,new A(e,t))},n.isGreaterThanOrEqualTo=n.gte=function(e,t){return 1===(t=Y(this,new A(e,t)))||0===t},n.isInteger=function(){return!!this.c&&W(this.e/G)>this.c.length-2},n.isLessThan=n.lt=function(e,t){return Y(this,new A(e,t))<0},n.isLessThanOrEqualTo=n.lte=function(e,t){return-1===(t=Y(this,new A(e,t)))||0===t},n.isNaN=function(){return!this.s},n.isNegative=function(){return this.s<0},n.isPositive=function(){return 0<this.s},n.isZero=function(){return!!this.c&&0==this.c[0]},n.minus=function(e,t){var r,n,i,a,o=this,u=o.s;if(t=(e=new A(e,t)).s,!u||!t)return new A(NaN);if(u!=t)return e.s=-t,o.plus(e);var c=o.e/G,s=e.e/G,l=o.c,f=e.c;if(!c||!s){if(!l||!f)return l?(e.s=-t,e):new A(f?o:NaN);if(!l[0]||!f[0])return f[0]?(e.s=-t,e):new A(l[0]?o:3==b?-0:0)}if(c=W(c),s=W(s),l=l.slice(),u=c-s){for((i=(a=u<0)?(u=-u,l):(s=c,f)).reverse(),t=u;t--;i.push(0));i.reverse()}else for(n=(a=(u=l.length)<(t=f.length))?u:t,u=t=0;t<n;t++)if(l[t]!=f[t]){a=l[t]<f[t];break}if(a&&(i=l,l=f,f=i,e.s=-e.s),0<(t=(n=f.length)-(r=l.length)))for(;t--;l[r++]=0);for(t=$-1;u<n;){if(l[--n]<f[n]){for(r=n;r&&!l[--r];l[r]=t);--l[r],l[n]+=$}l[n]-=f[n]}for(;0==l[0];l.splice(0,1),--s);return l[0]?L(e,l,s):(e.s=3==b?-1:1,e.c=[e.e=0],e)},n.modulo=n.mod=function(e,t){var r,n,i=this;return e=new A(e,t),!i.c||!e.s||e.c&&!e.c[0]?new A(NaN):!e.c||i.c&&!i.c[0]?new A(i):(9==a?(n=e.s,e.s=1,r=v(i,e,0,3),e.s=n,r.s*=n):r=v(i,e,0,a),(e=i.minus(r.times(e))).c[0]||1!=a||(e.s=i.s),e)},n.multipliedBy=n.times=function(e,t){var r,n,i,a,o,u,c,s,l,f,p,g,d,h,v,m=this,y=m.c,b=(e=new A(e,t)).c;if(!(y&&b&&y[0]&&b[0]))return!m.s||!e.s||y&&!y[0]&&!b||b&&!b[0]&&!y?e.c=e.e=e.s=null:(e.s*=m.s,y&&b?(e.c=[0],e.e=0):e.c=e.e=null),e;for(n=W(m.e/G)+W(e.e/G),e.s*=m.s,(c=y.length)<(f=b.length)&&(d=y,y=b,b=d,i=c,c=f,f=i),i=c+f,d=[];i--;d.push(0));for(h=$,v=Z,i=f;0<=--i;){for(r=0,p=b[i]%v,g=b[i]/v|0,a=i+(o=c);i<a;)r=((s=p*(s=y[--o]%v)+(u=g*s+(l=y[o]/v|0)*p)%v*v+d[a]+r)/h|0)+(u/v|0)+g*l,d[a--]=s%h;d[a]=r}return r?++n:d.splice(0,1),L(e,d,n)},n.negated=function(){var e=new A(this);return e.s=-e.s||null,e},n.plus=function(e,t){var r,n=this,i=n.s;if(t=(e=new A(e,t)).s,!i||!t)return new A(NaN);if(i!=t)return e.s=-t,n.minus(e);var a=n.e/G,o=e.e/G,u=n.c,c=e.c;if(!a||!o){if(!u||!c)return new A(i/0);if(!u[0]||!c[0])return c[0]?e:new A(u[0]?n:0*i)}if(a=W(a),o=W(o),u=u.slice(),i=a-o){for((r=0<i?(o=a,c):(i=-i,u)).reverse();i--;r.push(0));r.reverse()}for((i=u.length)-(t=c.length)<0&&(r=c,c=u,u=r,t=i),i=0;t;)i=(u[--t]=u[t]+c[t]+i)/$|0,u[t]=$===u[t]?0:u[t]%$;return i&&(u=[i].concat(u),++o),L(e,u,o)},n.precision=n.sd=function(e,t){var r,n,i;if(null!=e&&e!==!!e)return K(e,1,z),null==t?t=b:K(t,0,8),P(new A(this),e,t);if(!(r=this.c))return null;if(n=(i=r.length-1)*G+1,i=r[i]){for(;i%10==0;i/=10,n--);for(i=r[0];10<=i;i/=10,n++);}return e&&this.e+1>n&&(n=this.e+1),n},n.shiftedBy=function(e){return K(e,-V,V),this.times("1e"+e)},n.squareRoot=n.sqrt=function(){var e,t,r,n,i,a=this,o=a.c,u=a.s,c=a.e,s=y+4,l=new A("0.5");if(1!==u||!o||!o[0])return new A(!u||u<0&&(!o||o[0])?NaN:o?a:1/0);if((r=0==(u=Math.sqrt(+j(a)))||u==1/0?(((t=H(o)).length+c)%2==0&&(t+="0"),u=Math.sqrt(+t),c=W((c+1)/2)-(c<0||c%2),new A(t=u==1/0?"5e"+c:(t=u.toExponential()).slice(0,t.indexOf("e")+1)+c)):new A(u+"")).c[0])for((u=(c=r.e)+s)<3&&(u=0);;)if(i=r,r=l.times(i.plus(v(a,i,s,1))),H(i.c).slice(0,u)===(t=H(r.c)).slice(0,u)){if(r.e<c&&--u,"9999"!=(t=t.slice(u-3,u+1))&&(n||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(P(r,r.e+y+2,1),e=!r.times(r).eq(a));break}if(!n&&(P(i,i.e+y+2,0),i.times(i).eq(a))){r=i;break}s+=4,u+=4,n=1}return P(r,r.e+y+1,b,e)},n.toExponential=function(e,t){return null!=e&&(K(e,0,z),e++),i(this,e,t,1)},n.toFixed=function(e,t){return null!=e&&(K(e,0,z),e=e+this.e+1),i(this,e,t)},n.toFormat=function(e,t,r){var n;if(null==r)null!=e&&t&&"object"==typeof t?(r=t,t=null):e&&"object"==typeof e?(r=e,e=t=null):r=B;else if("object"!=typeof r)throw Error(R+"Argument not an object: "+r);if(n=this.toFixed(e,t),this.c){var i,a=n.split("."),o=+r.groupSize,u=+r.secondaryGroupSize,c=r.groupSeparator||"",s=a[0],l=a[1],f=this.s<0,p=f?s.slice(1):s,g=p.length;if(u&&(i=o,o=u,g-=u=i),0<o&&0<g){for(i=g%o||o,s=p.substr(0,i);i<g;i+=o)s+=c+p.substr(i,o);0<u&&(s+=c+p.slice(i)),f&&(s="-"+s)}n=l?s+(r.decimalSeparator||"")+((u=+r.fractionGroupSize)?l.replace(new RegExp("\\d{"+u+"}\\B","g"),"$&"+(r.fractionGroupSeparator||"")):l):s}return(r.prefix||"")+n+(r.suffix||"")},n.toFraction=function(e){var t,r,n,i,a,o,u,c,s,l,f,p,g=this,d=g.c;if(null!=e&&(!(u=new A(e)).isInteger()&&(u.c||1!==u.s)||u.lt(h)))throw Error(R+"Argument "+(u.isInteger()?"out of range: ":"not an integer: ")+j(u));if(!d)return new A(g);for(t=new A(h),s=r=new A(h),n=c=new A(h),p=H(d),a=t.e=p.length-g.e-1,t.c[0]=q[(o=a%G)<0?G+o:o],e=!e||0<u.comparedTo(t)?0<a?t:s:u,o=x,x=1/0,u=new A(p),c.c[0]=0;l=v(u,t,0,1),1!=(i=r.plus(l.times(n))).comparedTo(e);)r=n,n=i,s=c.plus(l.times(i=s)),c=i,t=u.minus(l.times(i=t)),u=i;return i=v(e.minus(r),n,0,1),c=c.plus(i.times(s)),r=r.plus(i.times(n)),c.s=s.s=g.s,f=v(s,n,a*=2,b).minus(g).abs().comparedTo(v(c,r,a,b).minus(g).abs())<1?[s,n]:[c,r],x=o,f},n.toNumber=function(){return+j(this)},n.toPrecision=function(e,t){return null!=e&&K(e,1,z),i(this,e,t,2)},n.toString=function(e){var t,r=this,n=r.s,i=r.e;return null===i?n?(t="Infinity",n<0&&(t="-"+t)):t="NaN":(t=null==e?i<=d||w<=i?X(H(r.c),i):Q(H(r.c),i,"0"):10===e?Q(H((r=P(new A(r),y+i+1,b)).c),r.e,"0"):(K(e,2,M.length,"Base"),f(Q(H(r.c),i,"0"),10,e,n,!0)),n<0&&r.c[0]&&(t="-"+t)),t},n.valueOf=n.toJSON=function(){return j(this)},n._isBigNumber=!0,null!=t&&A.set(t),A}()).default=t.BigNumber=t,void 0!==r&&r.exports?r.exports=t:(e=e||("undefined"!=typeof self&&self?self:window)).BigNumber=t}(this)},{}],2:[function(e,t,r){"use strict";t.exports={languageTag:"en-US",delimiters:{thousands:",",decimal:"."},abbreviations:{thousand:"k",million:"m",billion:"b",trillion:"t"},spaceSeparated:!1,ordinal:function(e){var t=e%10;return 1==~~(e%100/10)?"th":1==t?"st":2==t?"nd":3==t?"rd":"th"},bytes:{binarySuffixes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],decimalSuffixes:["B","KB","MB","GB","TB","PB","EB","ZB","YB"]},currency:{symbol:"$",position:"prefix",code:"USD"},currencyFormat:{thousandSeparated:!0,totalLength:4,spaceSeparated:!0,spaceSeparatedCurrency:!0},formats:{fourDigits:{totalLength:4,spaceSeparated:!0},fullWithTwoDecimals:{output:"currency",thousandSeparated:!0,mantissa:2},fullWithTwoDecimalsNoCurrency:{thousandSeparated:!0,mantissa:2},fullWithNoDecimals:{output:"currency",thousandSeparated:!0,mantissa:0}}}},{}],3:[function(e,t,r){"use strict";function I(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var r=[],n=!0,i=!1,a=void 0;try{for(var o,u=e[Symbol.iterator]();!(n=(o=u.next()).done)&&(r.push(o.value),!t||r.length!==t);n=!0);}catch(e){i=!0,a=e}finally{try{n||null==u.return||u.return()}finally{if(i)throw a}}return r}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var $=e("./globalState"),o=e("./validating"),u=e("./parsing"),G={trillion:Math.pow(10,12),billion:Math.pow(10,9),million:Math.pow(10,6),thousand:Math.pow(10,3)},V={totalLength:0,characteristic:0,forceAverage:!1,average:!1,mantissa:-1,optionalMantissa:!0,thousandSeparated:!1,spaceSeparated:!1,negative:"sign",forceSign:!1,roundingFunction:Math.round,spaceSeparatedAbbreviation:!1},n=$.currentBytes(),d=n.binarySuffixes,h=n.decimalSuffixes,i={general:{scale:1024,suffixes:h,marker:"bd"},binary:{scale:1024,suffixes:d,marker:"b"},decimal:{scale:1e3,suffixes:h,marker:"d"}};function a(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=2<arguments.length?arguments[2]:void 0;if("string"==typeof t&&(t=u.parseFormat(t)),!o.validateFormat(t))return"ERROR: invalid format";var n=t.prefix||"",i=t.postfix||"",a=function(e,t,r){switch(t.output){case"currency":return t=c(t,$.currentCurrencyDefaultFormat()),function(e,t,r){var n=r.currentCurrency(),i=Object.assign({},V,t),a=void 0,o="",u=!!i.totalLength||!!i.forceAverage||i.average,c=t.currencyPosition||n.position,s=t.currencySymbol||n.symbol,l=void 0!==i.spaceSeparatedCurrency?i.spaceSeparatedCurrency:i.spaceSeparated;void 0===t.lowPrecision&&(t.lowPrecision=!1);l&&(o=" ");"infix"===c&&(a=o+s+o);var f=m({instance:e,providedFormat:t,state:r,decimalSeparator:a});"prefix"===c&&(f=e._value<0&&"sign"===i.negative?"-".concat(o).concat(s).concat(f.slice(1)):0<e._value&&i.forceSign?"+".concat(o).concat(s).concat(f.slice(1)):s+o+f);c&&"postfix"!==c||(o=!i.spaceSeparatedAbbreviation&&u?"":o,f=f+o+s);return f}(e,t,$);case"percent":return t=c(t,$.currentPercentageDefaultFormat()),function(e,t,r,n){var i=t.prefixSymbol,a=m({instance:n(100*e._value),providedFormat:t,state:r}),o=Object.assign({},V,t);if(i)return"%".concat(o.spaceSeparated?" ":"").concat(a);return"".concat(a).concat(o.spaceSeparated?" ":"","%")}(e,t,$,r);case"byte":return t=c(t,$.currentByteDefaultFormat()),function(e,t,r,n){var i=t.base||"binary",a=Object.assign({},V,t),o=r.currentBytes(),u=o.binarySuffixes,c=o.decimalSuffixes,s={general:{scale:1024,suffixes:c||h,marker:"bd"},binary:{scale:1024,suffixes:u||d,marker:"b"},decimal:{scale:1e3,suffixes:c||h,marker:"d"}}[i],l=v(e._value,s.suffixes,s.scale),f=l.value,p=l.suffix,g=m({instance:n(f),providedFormat:t,state:r,defaults:r.currentByteDefaultFormat()});return"".concat(g).concat(a.spaceSeparated?" ":"").concat(p)}(e,t,$,r);case"time":return t=c(t,$.currentTimeDefaultFormat()),function(e){var t=Math.floor(e._value/60/60),r=Math.floor((e._value-60*t*60)/60),n=Math.round(e._value-60*t*60-60*r);return"".concat(t,":").concat(r<10?"0":"").concat(r,":").concat(n<10?"0":"").concat(n)}(e);case"ordinal":return t=c(t,$.currentOrdinalDefaultFormat()),function(e,t,r){var n=r.currentOrdinal(),i=Object.assign({},V,t),a=m({instance:e,providedFormat:t,state:r}),o=n(e._value);return"".concat(a).concat(i.spaceSeparated?" ":"").concat(o)}(e,t,$);case"number":default:return m({instance:e,providedFormat:t,numbro:r})}}(e,t,r);return a=(a=n+a)+i}function v(e,t,r){var n=t[0],i=Math.abs(e);if(r<=i){for(var a=1;a<t.length;++a){var o=Math.pow(r,a),u=Math.pow(r,a+1);if(o<=i&&i<u){n=t[a],e/=o;break}}n===t[0]&&(e/=Math.pow(r,t.length-1),n=t[t.length-1])}return{value:e,suffix:n}}function p(e){for(var t="",r=0;r<e;r++)t+="0";return t}function q(e,t,r){var n=2<arguments.length&&void 0!==r?r:Math.round;return-1!==e.toString().indexOf("e")?function(e,t){var r=e.toString(),n=I(r.split("e"),2),i=n[0],a=n[1],o=I(i.split("."),2),u=o[0],c=o[1],s=void 0===c?"":c;if(0<+a)r=u+s+p(a-s.length);else{var l=".";l=+u<0?"-0".concat(l):"0".concat(l);var f=(p(-a-1)+Math.abs(u)+s).substr(0,t);f.length<t&&(f+=p(t-f.length)),r=l+f}return 0<+a&&0<t&&(r+=".".concat(p(t))),r}(e,t):(n(+"".concat(e,"e+").concat(t))/Math.pow(10,t)).toFixed(t)}function Z(e,t,r,n,i){var a=n.currentDelimiters(),o=a.thousands;i=i||a.decimal;var u=a.thousandsSize||3,c=e.toString(),s=c.split(".")[0],l=c.split(".")[1],f=t<0&&0===s.indexOf("-");r&&(f&&(s=s.slice(1)),function(e,t){for(var r=[],n=0,i=e;0<i;i--)n===t&&(r.unshift(i),n=0),n++;return r}(s.length,u).forEach(function(e,t){s=s.slice(0,e+t)+o+s.slice(e+t)}),f&&(s="-".concat(s)));return c=l?s+i+l:s}function m(e){var t=e.instance,r=e.providedFormat,n=e.state,i=void 0===n?$:n,a=e.decimalSeparator,o=e.defaults,u=void 0===o?i.currentDefaults():o,c=t._value;if(0===c&&i.hasZeroFormat())return i.getZeroFormat();if(!isFinite(c))return c.toString();var s,l,f,p,g,d,h,v,m=Object.assign({},V,u,r),y=m.totalLength,b=y?0:m.characteristic,w=m.optionalCharacteristic,S=m.forceAverage,x=m.lowPrecision,O=!!y||!!S||m.average,N=y?-1:O&&void 0===r.mantissa?0:m.mantissa,B=!y&&(void 0===r.optionalMantissa?-1===N:m.optionalMantissa),M=m.trimMantissa,A=m.thousandSeparated,D=m.spaceSeparated,E=m.negative,F=m.forceSign,k=m.exponential,_=m.roundingFunction,L="";if(O){var P=function(e){var t=e.value,r=e.forceAverage,n=e.lowPrecision,i=void 0===n||n,a=e.abbreviations,o=e.spaceSeparated,u=void 0!==o&&o,c=e.totalLength,s=void 0===c?0:c,l=e.roundingFunction,f=void 0===l?Math.round:l,p="",g=Math.abs(t),d=-1;if(r&&a[r]&&G[r]?(p=a[r],t/=G[r]):g>=G.trillion||i&&1===f(g/G.trillion)?(p=a.trillion,t/=G.trillion):g<G.trillion&&g>=G.billion||i&&1===f(g/G.billion)?(p=a.billion,t/=G.billion):g<G.billion&&g>=G.million||i&&1===f(g/G.million)?(p=a.million,t/=G.million):(g<G.million&&g>=G.thousand||i&&1===f(g/G.thousand))&&(p=a.thousand,t/=G.thousand),p=p&&(u?" ":"")+p,s){var h=t<0,v=t.toString().split(".")[0],m=h?v.length-1:v.length;d=Math.max(s-m,0)}return{value:t,abbreviation:p,mantissaPrecision:d}}({value:c,forceAverage:S,lowPrecision:x,abbreviations:i.currentAbbreviations(),spaceSeparated:D,roundingFunction:_,totalLength:y});c=P.value,L+=P.abbreviation,y&&(N=P.mantissaPrecision)}if(k){var j=(l=(s={value:c,characteristicPrecision:b}).value,f=s.characteristicPrecision,p=void 0===f?0:f,g=I(l.toExponential().split("e"),2),d=g[0],h=g[1],v=+d,p&&1<p&&(v*=Math.pow(10,p-1),h=0<=(h-=p-1)?"+".concat(h):h),{value:v,abbreviation:"e".concat(h)});c=j.value,L=j.abbreviation+L}var C,T,U,R=function(e,t,r,n,i,a){if(-1===n)return e;var o=q(t,n,a),u=I(o.toString().split("."),2),c=u[0],s=u[1],l=void 0===s?"":s;if(l.match(/^0+$/)&&(r||i))return c;var f=l.match(/0+$/);return i&&f?"".concat(c,".").concat(l.toString().slice(0,f.index)):o.toString()}(c.toString(),c,B,N,M,_);return R=Z(R=function(e,t,r,n){var i=e,a=I(i.toString().split("."),2),o=a[0],u=a[1];if(o.match(/^-?0$/)&&r)return u?"".concat(o.replace("0",""),".").concat(u):o.replace("0","");var c=t<0&&0===o.indexOf("-");if(c&&(o=o.slice(1),i=i.slice(1)),o.length<n)for(var s=n-o.length,l=0;l<s;l++)i="0".concat(i);return c&&(i="-".concat(i)),i.toString()}(R,c,w,b),c,A,i,a),(O||k)&&(R=R+L),(F||c<0)&&(C=R,U=E,R=0===(T=c)?C:0==+C?C.replace("-",""):0<T?"+".concat(C):"sign"===U?C:"(".concat(C.replace("-",""),")")),R}function c(e,t){if(!e)return t;var r=Object.keys(e);return 1===r.length&&"output"===r[0]?t:e}t.exports=function(n){return{format:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return a.apply(void 0,t.concat([n]))},getByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=i.general;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getBinaryByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=i.binary;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getDecimalByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=i.decimal;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},formatOrDefault:c}}},{"./globalState":4,"./parsing":8,"./validating":10}],4:[function(e,t,r){"use strict";var i=e("./en-US"),n=e("./validating"),a=e("./parsing"),o={},u=void 0,c={},s=null,l={};function f(e){u=e}function p(){return c[u]}o.languages=function(){return Object.assign({},c)},o.currentLanguage=function(){return u},o.currentBytes=function(){return p().bytes||{}},o.currentCurrency=function(){return p().currency},o.currentAbbreviations=function(){return p().abbreviations},o.currentDelimiters=function(){return p().delimiters},o.currentOrdinal=function(){return p().ordinal},o.currentDefaults=function(){return Object.assign({},p().defaults,l)},o.currentOrdinalDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().ordinalFormat)},o.currentByteDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().byteFormat)},o.currentPercentageDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().percentageFormat)},o.currentCurrencyDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().currencyFormat)},o.currentTimeDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().timeFormat)},o.setDefaults=function(e){e=a.parseFormat(e),n.validateFormat(e)&&(l=e)},o.getZeroFormat=function(){return s},o.setZeroFormat=function(e){return s="string"==typeof e?e:null},o.hasZeroFormat=function(){return null!==s},o.languageData=function(e){if(e){if(c[e])return c[e];throw new Error('Unknown tag "'.concat(e,'"'))}return p()},o.registerLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1];if(!n.validateLanguage(e))throw new Error("Invalid language data");c[e.languageTag]=e,t&&f(e.languageTag)},o.setLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:i.languageTag;if(!c[e]){var r=e.split("-")[0],n=Object.keys(c).find(function(e){return e.split("-")[0]===r});return c[n]?void f(n):void f(t)}f(e)},o.registerLanguage(i),u=i.languageTag,t.exports=o},{"./en-US":2,"./parsing":8,"./validating":10}],5:[function(n,e,t){"use strict";e.exports=function(t){return{loadLanguagesInNode:function(e){return r=t,void e.forEach(function(t){var e=void 0;try{e=n("../languages/".concat(t))}catch(e){console.error('Unable to load "'.concat(t,'". No matching language file found.'))}e&&r.registerLanguage(e)});var r}}}},{}],6:[function(e,t,r){"use strict";var c=e("bignumber.js");function a(e,t,r){var n=new c(e._value),i=t;return r.isNumbro(t)&&(i=t._value),i=new c(i),e._value=n.minus(i).toNumber(),e}t.exports=function(u){return{add:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.plus(o).toNumber(),r;var r,n,i,a,o},subtract:function(e,t){return a(e,t,u)},multiply:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.times(o).toNumber(),r;var r,n,i,a,o},divide:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.dividedBy(o).toNumber(),r;var r,n,i,a,o},set:function(e,t){return r=e,i=n=t,u.isNumbro(n)&&(i=n._value),r._value=i,r;var r,n,i},difference:function(e,t){return r=t,a(i=(n=u)(e._value),r,n),Math.abs(i._value);var r,n,i},BigNumber:c}}},{"bignumber.js":1}],7:[function(e,t,r){"use strict";function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var a=e("./globalState"),n=e("./validating"),o=e("./loading")(g),u=e("./unformatting"),c=e("./formatting")(g),s=e("./manipulating")(g),l=e("./parsing"),f=function(){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._value=e}var e,r,n;return e=t,(r=[{key:"clone",value:function(){return g(this._value)}},{key:"format",value:function(e){var t=0<arguments.length&&void 0!==e?e:{};return c.format(this,t)}},{key:"formatCurrency",value:function(e){return"string"==typeof e&&(e=l.parseFormat(e)),(e=c.formatOrDefault(e,a.currentCurrencyDefaultFormat())).output="currency",c.format(this,e)}},{key:"formatTime",value:function(e){var t=0<arguments.length&&void 0!==e?e:{};return t.output="time",c.format(this,t)}},{key:"binaryByteUnits",value:function(){return c.getBinaryByteUnit(this)}},{key:"decimalByteUnits",value:function(){return c.getDecimalByteUnit(this)}},{key:"byteUnits",value:function(){return c.getByteUnit(this)}},{key:"difference",value:function(e){return s.difference(this,e)}},{key:"add",value:function(e){return s.add(this,e)}},{key:"subtract",value:function(e){return s.subtract(this,e)}},{key:"multiply",value:function(e){return s.multiply(this,e)}},{key:"divide",value:function(e){return s.divide(this,e)}},{key:"set",value:function(e){return s.set(this,p(e))}},{key:"value",value:function(){return this._value}},{key:"valueOf",value:function(){return this._value}}])&&i(e.prototype,r),n&&i(e,n),t}();function p(e){var t=e;return g.isNumbro(e)?t=e._value:"string"==typeof e?t=g.unformat(e):isNaN(e)&&(t=NaN),t}function g(e){return new f(p(e))}g.version="2.3.2",g.isNumbro=function(e){return e instanceof f},g.language=a.currentLanguage,g.registerLanguage=a.registerLanguage,g.setLanguage=a.setLanguage,g.languages=a.languages,g.languageData=a.languageData,g.zeroFormat=a.setZeroFormat,g.defaultFormat=a.currentDefaults,g.setDefaults=a.setDefaults,g.defaultCurrencyFormat=a.currentCurrencyDefaultFormat,g.validate=n.validate,g.loadLanguagesInNode=o.loadLanguagesInNode,g.unformat=u.unformat,g.BigNumber=s.BigNumber,t.exports=g},{"./formatting":3,"./globalState":4,"./loading":5,"./manipulating":6,"./parsing":8,"./unformatting":9,"./validating":10}],8:[function(e,t,r){"use strict";t.exports={parseFormat:function(e){var t,r,n,i,a,o,u,c,s,l,f,p,g,d,h,v,m,y,b,w,S,x,O=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return"string"!=typeof e?e:(r=O,e=(n=(t=e).match(/^{([^}]*)}/))?(r.prefix=n[1],t.slice(n[0].length)):t,a=O,function(e,t){if(-1===e.indexOf("$")){if(-1===e.indexOf("%"))return-1!==e.indexOf("bd")?(t.output="byte",t.base="general"):-1!==e.indexOf("b")?(t.output="byte",t.base="binary"):-1!==e.indexOf("d")?(t.output="byte",t.base="decimal"):-1===e.indexOf(":")?-1!==e.indexOf("o")&&(t.output="ordinal"):t.output="time";t.output="percent"}else t.output="currency"}(e=(o=(i=e).match(/{([^}]*)}$/))?(a.postfix=o[1],i.slice(0,-o[0].length)):i,O),u=O,(c=e.match(/[1-9]+[0-9]*/))&&(u.totalLength=+c[0]),s=O,(l=e.split(".")[0].match(/0+/))&&(s.characteristic=l[0].length),function(e,t){if(-1!==e.indexOf(".")){var r=e.split(".")[0];t.optionalCharacteristic=-1===r.indexOf("0")}}(e,O),f=O,-1!==e.indexOf("a")&&(f.average=!0),g=O,-1!==(p=e).indexOf("K")?g.forceAverage="thousand":-1!==p.indexOf("M")?g.forceAverage="million":-1!==p.indexOf("B")?g.forceAverage="billion":-1!==p.indexOf("T")&&(g.forceAverage="trillion"),function(e,t){var r=e.split(".")[1];if(r){var n=r.match(/0+/);n&&(t.mantissa=n[0].length)}}(e,O),h=O,(d=e).match(/\[\.]/)?h.optionalMantissa=!0:d.match(/\./)&&(h.optionalMantissa=!1),v=O,(m=e.split(".")[1])&&(v.trimMantissa=-1!==m.indexOf("[")),y=O,-1!==e.indexOf(",")&&(y.thousandSeparated=!0),b=O,-1!==e.indexOf(" ")&&(b.spaceSeparated=!0,b.spaceSeparatedCurrency=!0,(b.average||b.forceAverage)&&(b.spaceSeparatedAbbreviation=!0)),S=O,(w=e).match(/^\+?\([^)]*\)$/)&&(S.negative="parenthesis"),w.match(/^\+?-/)&&(S.negative="sign"),x=O,e.match(/^\+/)&&(x.forceSign=!0),O)}}},{}],9:[function(p,e,t){"use strict";var M=[{key:"ZiB",factor:Math.pow(1024,7)},{key:"ZB",factor:Math.pow(1e3,7)},{key:"YiB",factor:Math.pow(1024,8)},{key:"YB",factor:Math.pow(1e3,8)},{key:"TiB",factor:Math.pow(1024,4)},{key:"TB",factor:Math.pow(1e3,4)},{key:"PiB",factor:Math.pow(1024,5)},{key:"PB",factor:Math.pow(1e3,5)},{key:"MiB",factor:Math.pow(1024,2)},{key:"MB",factor:Math.pow(1e3,2)},{key:"KiB",factor:Math.pow(1024,1)},{key:"KB",factor:Math.pow(1e3,1)},{key:"GiB",factor:Math.pow(1024,3)},{key:"GB",factor:Math.pow(1e3,3)},{key:"EiB",factor:Math.pow(1024,6)},{key:"EB",factor:Math.pow(1e3,6)},{key:"B",factor:1}];function A(e){return e.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function g(e,t,r,n,i,a,o){var u=2<arguments.length&&void 0!==r?r:"",c=3<arguments.length?n:void 0,s=4<arguments.length?i:void 0,l=5<arguments.length?a:void 0,f=6<arguments.length?o:void 0;if(""!==e)return e===s?0:function e(t,r,n,i,a,o,u){var c=2<arguments.length&&void 0!==n?n:"",s=3<arguments.length?i:void 0,l=4<arguments.length?a:void 0,f=5<arguments.length?o:void 0,p=6<arguments.length?u:void 0;if(!isNaN(+t))return+t;var g="",d=t.replace(/(^[^(]*)\((.*)\)([^)]*$)/,"$1$2$3");if(d!==t)return-1*e(d,r,c,s,l,f,p);for(var h=0;h<M.length;h++){var v=M[h];if((g=t.replace(RegExp("([0-9 ])(".concat(v.key,")$")),"$1"))!==t)return e(g,r,c,s,l,f,p)*v.factor}if((g=t.replace("%",""))!==t)return e(g,r,c,s,l,f,p)/100;var m=parseFloat(t);if(!isNaN(m)){var y=s(m);if(y&&"."!==y&&(g=t.replace(new RegExp("".concat(A(y),"$")),""))!==t)return e(g,r,c,s,l,f,p);var b={};Object.keys(f).forEach(function(e){b[f[e]]=e});for(var w=Object.keys(b).sort().reverse(),S=w.length,x=0;x<S;x++){var O=w[x],N=b[O];if((g=t.replace(O,""))!==t){var B=void 0;switch(N){case"thousand":B=Math.pow(10,3);break;case"million":B=Math.pow(10,6);break;case"billion":B=Math.pow(10,9);break;case"trillion":B=Math.pow(10,12)}return e(g,r,c,s,l,f,p)*B}}}}(function(e,t,r){var n=2<arguments.length&&void 0!==r?r:"",i=e.replace(n,"");return i=(i=i.replace(new RegExp("([0-9])".concat(A(t.thousands),"([0-9])"),"g"),"$1$2")).replace(t.decimal,".")}(e,t,u),t,u,c,s,l,f)}e.exports={unformat:function(e,t){var r,n,i,a=p("./globalState"),o=a.currentDelimiters(),u=a.currentCurrency().symbol,c=a.currentOrdinal(),s=a.getZeroFormat(),l=a.currentAbbreviations(),f=void 0;if("string"==typeof e)f=function(e,t){if(e.indexOf(":")&&":"!==t.thousands){var r=e.split(":");if(3===r.length){var n=+r[0],i=+r[1],a=+r[2];return!isNaN(n)&&!isNaN(i)&&!isNaN(a)}}}(e,o)?(r=e.split(":"),n=+r[0],i=+r[1],+r[2]+60*i+3600*n):g(e,o,u,c,s,l,t);else{if("number"!=typeof e)return;f=e}if(void 0!==f)return f}}},{"./globalState":4}],10:[function(e,t,r){"use strict";function n(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function f(e){return(f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var i=e("./unformatting"),a=/^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/,p={output:{type:"string",validValues:["currency","percent","byte","time","ordinal","number"]},base:{type:"string",validValues:["decimal","binary","general"],restriction:function(e,t){return"byte"===t.output},message:"`base` must be provided only when the output is `byte`",mandatory:function(e){return"byte"===e.output}},characteristic:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},prefix:"string",postfix:"string",forceAverage:{type:"string",validValues:["trillion","billion","million","thousand"]},average:"boolean",lowPrecision:{type:"boolean",restriction:function(e,t){return!0===t.average},message:"`lowPrecision` must be provided only when the option `average` is set"},currencyPosition:{type:"string",validValues:["prefix","infix","postfix"]},currencySymbol:"string",totalLength:{type:"number",restrictions:[{restriction:function(e){return 0<=e},message:"value must be positive"},{restriction:function(e,t){return!t.exponential},message:"`totalLength` is incompatible with `exponential`"}]},mantissa:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},optionalMantissa:"boolean",trimMantissa:"boolean",roundingFunction:"function",optionalCharacteristic:"boolean",thousandSeparated:"boolean",spaceSeparated:"boolean",spaceSeparatedCurrency:"boolean",spaceSeparatedAbbreviation:"boolean",abbreviations:{type:"object",children:{thousand:"string",million:"string",billion:"string",trillion:"string"}},negative:{type:"string",validValues:["sign","parenthesis"]},forceSign:"boolean",exponential:{type:"boolean"},prefixSymbol:{type:"boolean",restriction:function(e,t){return"percent"===t.output},message:"`prefixSymbol` can be provided only when the output is `percent`"}},o={languageTag:{type:"string",mandatory:!0,restriction:function(e){return e.match(a)},message:"the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)"},delimiters:{type:"object",children:{thousands:"string",decimal:"string",thousandsSize:"number"},mandatory:!0},abbreviations:{type:"object",children:{thousand:{type:"string",mandatory:!0},million:{type:"string",mandatory:!0},billion:{type:"string",mandatory:!0},trillion:{type:"string",mandatory:!0}},mandatory:!0},spaceSeparated:"boolean",spaceSeparatedCurrency:"boolean",ordinal:{type:"function",mandatory:!0},bytes:{type:"object",children:{binarySuffixes:"object",decimalSuffixes:"object"}},currency:{type:"object",children:{symbol:"string",position:"string",code:"string"},mandatory:!0},defaults:"format",ordinalFormat:"format",byteFormat:"format",percentageFormat:"format",currencyFormat:"format",timeDefaults:"format",formats:{type:"object",children:{fourDigits:{type:"format",mandatory:!0},fullWithTwoDecimals:{type:"format",mandatory:!0},fullWithTwoDecimalsNoCurrency:{type:"format",mandatory:!0},fullWithNoDecimals:{type:"format",mandatory:!0}}}};function u(e){return void 0!==i.unformat(e)}function g(c,s,l,e){var t=3<arguments.length&&void 0!==e&&e,r=Object.keys(c).map(function(e){if(!s[e])return console.error("".concat(l," Invalid key: ").concat(e)),!1;var t=c[e],r=s[e];if("string"==typeof r&&(r={type:r}),"format"===r.type){if(!g(t,p,"[Validate ".concat(e,"]"),!0))return!1}else if(f(t)!==r.type)return console.error("".concat(l," ").concat(e,' type mismatched: "').concat(r.type,'" expected, "').concat(f(t),'" provided')),!1;if(r.restrictions&&r.restrictions.length)for(var n=r.restrictions.length,i=0;i<n;i++){var a=r.restrictions[i],o=a.restriction,u=a.message;if(!o(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(u)),!1}if(r.restriction&&!r.restriction(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(r.message)),!1;if(r.validValues&&-1===r.validValues.indexOf(t))return console.error("".concat(l," ").concat(e," invalid value: must be among ").concat(JSON.stringify(r.validValues),', "').concat(t,'" provided')),!1;if(r.children&&!g(t,r.children,"[Validate ".concat(e,"]")))return!1;return!0});return t||r.push.apply(r,n(Object.keys(s).map(function(e){var t=s[e];if("string"==typeof t&&(t={type:t}),t.mandatory){var r=t.mandatory;if("function"==typeof r&&(r=r(c)),r&&void 0===c[e])return console.error("".concat(l,' Missing mandatory key "').concat(e,'"')),!1}return!0}))),r.reduce(function(e,t){return e&&t},!0)}function c(e){return g(e,p,"[Validate format]")}t.exports={validate:function(e,t){var r=u(e),n=c(t);return r&&n},validateFormat:c,validateInput:u,validateLanguage:function(e){return g(e,o,"[Validate language]")}}},{"./unformatting":9}]},{},[7])(7)});
//# sourceMappingURL=numbro.min.js.map


/***/ }),

/***/ "./node_modules/@proton/api/dist/api.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/@proton/api/dist/api.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiClass": () => (/* binding */ ApiClass),
/* harmony export */   "KycStatus": () => (/* binding */ KycStatus)
/* harmony export */ });
/* harmony import */ var _proton_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @proton/js */ "./node_modules/@proton/js/dist/index.js");
/* harmony import */ var _bloks_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bloks/constants */ "./node_modules/@bloks/constants/dist/constants.esm.js");
/* harmony import */ var _proton_hyperion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @proton/hyperion */ "./node_modules/@proton/hyperion/dist/index.js");
/* harmony import */ var _proton_hyperion__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_proton_hyperion__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _proton_light_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @proton/light-api */ "./node_modules/@proton/light-api/dist/index.js");
/* harmony import */ var _proton_light_api__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_proton_light_api__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _bloks_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @bloks/utils */ "./node_modules/@bloks/utils/dist/utils.esm.js");
/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js");
/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js");
/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _proton_wrap_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @proton/wrap-constants */ "./node_modules/@proton/wrap-constants/dist/wrap-constants.esm.js");
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! zod */ "./node_modules/zod/lib/index.mjs");
/* harmony import */ var _bloks_numbers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @bloks/numbers */ "./node_modules/@bloks/numbers/dist/index.js");











function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function getAccount(_x) {
  return _getAccount.apply(this, arguments);
}

function _getAccount() {
  _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName) {
    var _this = this;

    var account;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_account(accountName);

          case 3:
            account = _context.sent;
            account.permissions = account.permissions.map(function (permission) {
              permission.required_auth.keys = permission.required_auth.keys.map(function (key) {
                if (key.key.indexOf(_this.constants.KEY_PREFIX) !== -1) {
                  key.key = _proton_js__WEBPACK_IMPORTED_MODULE_0__.Numeric.convertLegacyPublicKey(key.key, _this.constants.KEY_PREFIX);
                }

                return key;
              });
              return permission;
            });
            return _context.abrupt("return", account);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getAccount.apply(this, arguments);
}

function searchAccount(_x2, _x3) {
  return _searchAccount.apply(this, arguments);
}

function _searchAccount() {
  _searchAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(query, limit) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(!query || !/(^[a-zA-Z12345.]+$)/.test(query))) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt("return", []);

          case 2:
            if (!(query.indexOf('.') === 0)) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", []);

          case 4:
            _context2.prev = 4;
            query = query.trim().toLowerCase();
            _context2.next = 8;
            return this.rpc.get_table_by_scope({
              json: true,
              code: this.constants.EOSIO,
              limit: limit,
              lower_bound: query,
              table: 'userres',
              upper_bound: "" + query + (query.length < 12 ? 'z'.repeat(12 - query.length) : '')
            });

          case 8:
            _yield$this$rpc$get_t = _context2.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context2.abrupt("return", rows.map(function (row) {
              return row.scope;
            }));

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](4);
            console.log(_context2.t0);
            return _context2.abrupt("return", []);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[4, 13]]);
  }));
  return _searchAccount.apply(this, arguments);
}

function getGravatar(_x4) {
  return _getGravatar.apply(this, arguments);
}

function _getGravatar() {
  _getGravatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!(this.constants.CHAIN === 'eos')) {
              _context3.next = 7;
              break;
            }

            _context3.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.ACCOUNT_INFO,
              scope: this.constants.ACCOUNT_INFO,
              table: 'accounts',
              table_key: '',
              key_type: 'name',
              lower_bound: account,
              index_position: 1,
              limit: 1
            });

          case 3:
            result = _context3.sent;
            return _context3.abrupt("return", result.rows.length > 0 && result.rows[0].account_name === account ? result.rows[0] : undefined);

          case 7:
            return _context3.abrupt("return", undefined);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getGravatar.apply(this, arguments);
}

function getParent(_x5) {
  return _getParent.apply(this, arguments);
}

function _getParent() {
  _getParent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!this.constants.HISTORY_TYPES.includes('hyperion')) {
              _context4.next = 8;
              break;
            }

            if (!this.constants.HYPERION_URL) {
              _context4.next = 5;
              break;
            }

            return _context4.abrupt("return", this.hyperion.get_creator(account));

          case 5:
            return _context4.abrupt("return", this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'hyperion', {
              type: 'get_creator',
              account: account
            })));

          case 6:
            _context4.next = 9;
            break;

          case 8:
            return _context4.abrupt("return", null);

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getParent.apply(this, arguments);
}

function getAccountLightData(_x6) {
  return _getAccountLightData.apply(this, arguments);
}

function _getAccountLightData() {
  _getAccountLightData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(accountName) {
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (this.lightApi) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return", undefined);

          case 2:
            _context5.prev = 2;
            _context5.next = 5;
            return this.lightApi.get_account_info(accountName);

          case 5:
            return _context5.abrupt("return", _context5.sent);

          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](2);
            console.log(_context5.t0);
            return _context5.abrupt("return", undefined);

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[2, 8]]);
  }));
  return _getAccountLightData.apply(this, arguments);
}

function getActionsFromNative(_x, _x2, _x3, _x4) {
  return _getActionsFromNative.apply(this, arguments);
}

function _getActionsFromNative() {
  _getActionsFromNative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName, actionSkip, actionsPerPage, historyType) {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (historyType === void 0) {
              historyType = 'native';
            }

            console.log('Fetching actions from:', historyType);
            console.log('Fetch Params:', 'actionSkip', actionSkip, 'actionsPerPage', actionsPerPage); // Request

            _context.next = 5;
            return this.actionsRpc.history_get_actions(accountName, actionSkip, actionsPerPage);

          case 5:
            result = _context.sent;

            if (result) {
              _context.next = 8;
              break;
            }

            throw new Error('Could not retrieve actions');

          case 8:
            if (!(historyType === 'native')) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.nativeTransformGetActions)(result, this.constants));

          case 10:
            return _context.abrupt("return", []);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getActionsFromNative.apply(this, arguments);
}

function getActions(_x5, _x6, _x7) {
  return _getActions.apply(this, arguments);
}

function _getActions() {
  _getActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(accountName, historyType, _temp) {
    var _ref, _ref$actionsPerPage, actionsPerPage, _ref$actionSkip, actionSkip, _ref$sortDirection, sortDirection, _ref$dfuseCursorStack, dfuseCursorStack, tokenFilter, actionFilters, contractFilter, actionFilter, start, end, result, inputCursor;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref = _temp === void 0 ? {} : _temp, _ref$actionsPerPage = _ref.actionsPerPage, actionsPerPage = _ref$actionsPerPage === void 0 ? 100 : _ref$actionsPerPage, _ref$actionSkip = _ref.actionSkip, actionSkip = _ref$actionSkip === void 0 ? 0 : _ref$actionSkip, _ref$sortDirection = _ref.sortDirection, sortDirection = _ref$sortDirection === void 0 ? 'desc' : _ref$sortDirection, _ref$dfuseCursorStack = _ref.dfuseCursorStack, dfuseCursorStack = _ref$dfuseCursorStack === void 0 ? [] : _ref$dfuseCursorStack, tokenFilter = _ref.tokenFilter, actionFilters = _ref.actionFilters, contractFilter = _ref.contractFilter, actionFilter = _ref.actionFilter, start = _ref.start, end = _ref.end;

            if (!start) {
              start = this.constants.CHAIN_START_DATE;
            } // Fallback for history type


            console.log(this.constants.HISTORY_TYPES);

            if (!historyType && this.constants.HISTORY_TYPES.length) {
              historyType = this.constants.HISTORY_TYPES[0];
            } // Fix for firefox and IE and safari


            if (start && end) {
              start = start || this.constants.CHAIN_START_DATE ? new Date(start || this.constants.CHAIN_START_DATE).toISOString() : undefined;
              end = new Date(end || new Date()).toISOString();
            } else {
              start = undefined;
              end = undefined;
            }

            if (!(historyType === 'dfuse')) {
              _context2.next = 12;
              break;
            }

            inputCursor = dfuseCursorStack.length > 0 ? dfuseCursorStack[dfuseCursorStack.length - 1] : '';
            _context2.next = 9;
            return this.getActionsFromDfuse(accountName, {
              limit: actionsPerPage,
              cursor: inputCursor,
              direction: sortDirection,
              query: '',
              after: start,
              before: end,
              tokenFilter: tokenFilter,
              actionFilters: actionFilters,
              contractFilter: contractFilter,
              actionFilter: actionFilter
            });

          case 9:
            result = _context2.sent;
            _context2.next = 21;
            break;

          case 12:
            if (!(historyType === 'hyperion')) {
              _context2.next = 18;
              break;
            }

            _context2.next = 15;
            return this.getActionsFromHyperion(accountName, {
              skip: Math.abs(actionSkip) - 1,
              limit: actionsPerPage,
              sort: sortDirection,
              after: start,
              before: end,
              tokenFilter: tokenFilter,
              actionFilters: actionFilters,
              contractFilter: contractFilter,
              actionFilter: actionFilter
            });

          case 15:
            result = _context2.sent;
            _context2.next = 21;
            break;

          case 18:
            _context2.next = 20;
            return this.getActionsFromNative(accountName, actionSkip, -actionsPerPage, 'native');

          case 20:
            result = _context2.sent;

          case 21:
            return _context2.abrupt("return", result);

          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getActions.apply(this, arguments);
}

function getActionsFromDfuse(_x8, _x9) {
  return _getActionsFromDfuse.apply(this, arguments);
}

function _getActionsFromDfuse() {
  _getActionsFromDfuse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(accountName, _temp2) {
    var _ref2, before, after, _ref2$limit, limit, cursor, query, _ref2$direction, direction, tokenFilter, actionFilters, contractFilter, actionFilter, _ref2$type, type, q, _tokenFilter$split, tokenContract, tokenfilter, actionFiltersLocal, actionFiltersQuery, result;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _ref2 = _temp2 === void 0 ? {} : _temp2, before = _ref2.before, after = _ref2.after, _ref2$limit = _ref2.limit, limit = _ref2$limit === void 0 ? 25 : _ref2$limit, cursor = _ref2.cursor, query = _ref2.query, _ref2$direction = _ref2.direction, direction = _ref2$direction === void 0 ? 'desc' : _ref2$direction, tokenFilter = _ref2.tokenFilter, actionFilters = _ref2.actionFilters, contractFilter = _ref2.contractFilter, actionFilter = _ref2.actionFilter, _ref2$type = _ref2.type, type = _ref2$type === void 0 ? 'search_transactions_graphql' : _ref2$type;
            q = query || "(auth:" + accountName + " OR\n                    receiver:" + accountName + " OR\n                    data.to:" + accountName + " OR\n                    data.from:" + accountName + " OR\n                    data.receiver:" + accountName + ")";

            if (tokenFilter) {
              _tokenFilter$split = tokenFilter.split(' '), tokenContract = _tokenFilter$split[1];
              tokenfilter = "account:" + tokenContract;
              q = q + " " + tokenfilter;
            }

            if (actionFilters) {
              actionFiltersLocal = Object.entries(actionFilters).reduce(function (filters, _ref4) {
                var value = _ref4[1];
                return value.isActive ? filters.concat(value) : filters;
              }, []);

              if (actionFiltersLocal.length) {
                actionFiltersQuery = actionFiltersLocal.map(function (filter) {
                  return filter.dfuseQuery(accountName);
                }).join(' OR '); // Wrap around the action filters

                if (actionFiltersQuery.search('OR') !== -1) {
                  actionFiltersQuery = "(" + actionFiltersQuery + ")";
                } // Set the action filters


                q = q + " " + actionFiltersQuery;
              }

              if (contractFilter) {
                q = q + " account:" + contractFilter;
              }

              if (actionFilter) {
                q = q + " action:" + actionFilter;
              }
            }

            _context3.next = 6;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'dfuse', {
              type: type,
              q: q,
              options: Object.assign({}, {
                sort: direction,
                cursor: cursor,
                limit: limit,
                withReversible: true,
                before: before,
                after: after,
                code: 1
              })
            }));

          case 6:
            result = _context3.sent;

            if (result) {
              _context3.next = 9;
              break;
            }

            throw new Error('Could not retrieve actions');

          case 9:
            return _context3.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.dfuseTransformGetActions)(result, accountName, this.constants));

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getActionsFromDfuse.apply(this, arguments);
}

function getActionsFromHyperion(_x10, _x11) {
  return _getActionsFromHyperion.apply(this, arguments);
}

function _getActionsFromHyperion() {
  _getActionsFromHyperion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account, _temp3) {
    var _ref3, skip, limit, sort, after, before, filter, tokenFilter, actionFilters, contractFilter, actionFilter, params, result, _tokenFilter$split2, tokenContract, actionFiltersLocal, _iterator, _step, eachFilter, uniqueContracts;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _ref3 = _temp3 === void 0 ? {} : _temp3, skip = _ref3.skip, limit = _ref3.limit, sort = _ref3.sort, after = _ref3.after, before = _ref3.before, filter = _ref3.filter, tokenFilter = _ref3.tokenFilter, actionFilters = _ref3.actionFilters, contractFilter = _ref3.contractFilter, actionFilter = _ref3.actionFilter;
            // Initialize
            params = {
              filter: filter,
              skip: skip,
              limit: limit,
              sort: sort,
              after: after,
              before: before
            };
            console.log('Fetching actions from Hyperion');

            // Token filter, we would only receive undefined or *:action
            if (tokenFilter) {
              _tokenFilter$split2 = tokenFilter.split(' '), tokenContract = _tokenFilter$split2[1];

              if (params.filter) {
                params.filter = params.filter.replace('*', tokenContract);
              } else {
                params.filter = tokenContract + ":*";
              }
            }

            if (actionFilters) {
              actionFiltersLocal = Object.entries(actionFilters).reduce(function (filters, _ref5) {
                var value = _ref5[1];
                return value.isActive ? filters.concat(value) : filters;
              }, []);

              if (actionFiltersLocal.length) {
                for (_iterator = _createForOfIteratorHelperLoose(actionFiltersLocal); !(_step = _iterator()).done;) {
                  eachFilter = _step.value;
                  eachFilter.hyperionQuery(account, params);
                }

                console.log(params);
              }
            } // Actions contract filters


            if (contractFilter) {
              if (params.filter) {
                params.filter = params.filter.split(',').map(function (filter) {
                  return contractFilter + ":" + filter.split(':')[1];
                }).join(',');
              } else {
                params.filter = contractFilter + ":*";
              }
            }

            if (actionFilter) {
              if (params.filter) {
                uniqueContracts = Array.from(new Set(params.filter.split(',').map(function (filter) {
                  return filter.split(':')[0];
                })));
                params.filter = uniqueContracts.map(function (contract) {
                  return contract + ":" + actionFilter;
                }).join(',');
              } else {
                params.filter = "*:" + actionFilter;
              }
            } // If hyperion URL provided, do it client side


            if (!this.constants.HYPERION_URL) {
              _context4.next = 13;
              break;
            }

            _context4.next = 10;
            return this.hyperion.get_actions(account, Object.assign({}, params));

          case 10:
            result = _context4.sent;
            _context4.next = 16;
            break;

          case 13:
            _context4.next = 15;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'hyperion', {
              type: 'get_actions',
              account: account,
              options: Object.assign({}, params)
            }));

          case 15:
            result = _context4.sent;

          case 16:
            if (result) {
              _context4.next = 18;
              break;
            }

            throw new Error('Could not retrieve actions');

          case 18:
            return _context4.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.hyperionTransformGetActions)(result));

          case 19:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getActionsFromHyperion.apply(this, arguments);
}

function getDappStats() {
  return _getDappStats.apply(this, arguments);
}

function _getDappStats() {
  _getDappStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1,
              scope: '......2ke1.o4',
              table: 'statext'
            });

          case 3:
            result = _context.sent;

            if (!(!result || !result.rows || !result.rows.length)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", {});

          case 8:
            return _context.abrupt("return", result.rows[0]);

          case 9:
            _context.next = 15;
            break;

          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", {});

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 11]]);
  }));
  return _getDappStats.apply(this, arguments);
}

function getDspPackages() {
  return _getDspPackages.apply(this, arguments);
}

function _getDspPackages() {
  _getDspPackages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var result;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 500,
              scope: 'dappservices',
              table: 'package'
            });

          case 3:
            result = _context2.sent;
            return _context2.abrupt("return", result && result.rows && result.rows.length ? result.rows : []);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            console.log(_context2.t0);
            return _context2.abrupt("return", []);

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 7]]);
  }));
  return _getDspPackages.apply(this, arguments);
}

function getDapphodlBalance(_x) {
  return _getDapphodlBalance.apply(this, arguments);
}

function _getDapphodlBalance() {
  _getDapphodlBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappairhodl1',
              json: true,
              limit: 1,
              scope: account,
              table: 'accounts'
            });

          case 3:
            result = _context3.sent;
            return _context3.abrupt("return", result && result.rows && result.rows.length ? result.rows[0] : {});

          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](0);
            return _context3.abrupt("return", {});

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 7]]);
  }));
  return _getDapphodlBalance.apply(this, arguments);
}

function getDappBalance(_x2) {
  return _getDappBalance.apply(this, arguments);
}

function _getDappBalance() {
  _getDappBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1,
              scope: account,
              table: 'accounts'
            });

          case 3:
            result = _context4.sent;
            return _context4.abrupt("return", result && result.rows && result.rows.length ? result.rows[0] : {});

          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](0);
            return _context4.abrupt("return", {});

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 7]]);
  }));
  return _getDappBalance.apply(this, arguments);
}

function getDappStakes(_x3) {
  return _getDappStakes.apply(this, arguments);
}

function _getDappStakes() {
  _getDappStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 100,
              scope: account,
              table: 'staking'
            });

          case 3:
            result = _context5.sent;
            return _context5.abrupt("return", result && result.rows && result.rows.length ? result.rows.map(function (row) {
              row.scope = account;
              return row;
            }) : []);

          case 7:
            _context5.prev = 7;
            _context5.t0 = _context5["catch"](0);
            return _context5.abrupt("return", []);

          case 10:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 7]]);
  }));
  return _getDappStakes.apply(this, arguments);
}

function getDapphodlStakes(_x4, _x5) {
  return _getDapphodlStakes.apply(this, arguments);
}

function _getDapphodlStakes() {
  _getDapphodlStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(account, lower_bound) {
    var result, rows;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (lower_bound === void 0) {
              lower_bound = '';
            }

            _context6.prev = 1;
            _context6.next = 4;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1000,
              scope: 'dappairhodl1',
              table: 'staking',
              lower_bound: lower_bound
            });

          case 4:
            result = _context6.sent;

            if (result) {
              _context6.next = 7;
              break;
            }

            return _context6.abrupt("return", []);

          case 7:
            rows = result.rows;

            if (!result.more) {
              _context6.next = 14;
              break;
            }

            _context6.t0 = rows;
            _context6.next = 12;
            return this.getDapphodlStakes(account, +rows[rows.length - 1].id + 1);

          case 12:
            _context6.t1 = _context6.sent;
            rows = _context6.t0.concat.call(_context6.t0, _context6.t1);

          case 14:
            return _context6.abrupt("return", rows.filter(function (row) {
              return row.account === account;
            }).map(function (row) {
              row.scope = 'dappairhodl1';
              return row;
            }));

          case 17:
            _context6.prev = 17;
            _context6.t2 = _context6["catch"](1);
            return _context6.abrupt("return", []);

          case 20:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[1, 17]]);
  }));
  return _getDapphodlStakes.apply(this, arguments);
}

function getDappUnstakes(_x6) {
  return _getDappUnstakes.apply(this, arguments);
}

function _getDappUnstakes() {
  _getDappUnstakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 100,
              scope: account,
              table: 'refunds'
            });

          case 3:
            result = _context7.sent;
            return _context7.abrupt("return", result && result.rows && result.rows.length ? result.rows.map(function (row) {
              row.scope = account;
              return row;
            }) : []);

          case 7:
            _context7.prev = 7;
            _context7.t0 = _context7["catch"](0);
            return _context7.abrupt("return", []);

          case 10:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 7]]);
  }));
  return _getDappUnstakes.apply(this, arguments);
}

function getDapphodlUnstakes(_x7) {
  return _getDapphodlUnstakes.apply(this, arguments);
}

function _getDapphodlUnstakes() {
  _getDapphodlUnstakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(account) {
    var result, rows;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1000,
              scope: 'dappairhodl1',
              table: 'refunds'
            });

          case 3:
            result = _context8.sent;

            if (result) {
              _context8.next = 6;
              break;
            }

            return _context8.abrupt("return", []);

          case 6:
            rows = result.rows;

            if (!result.more) {
              _context8.next = 13;
              break;
            }

            _context8.t0 = rows;
            _context8.next = 11;
            return this.getDapphodlUnstakes(account);

          case 11:
            _context8.t1 = _context8.sent;
            rows = _context8.t0.concat.call(_context8.t0, _context8.t1);

          case 13:
            return _context8.abrupt("return", rows.filter(function (row) {
              return row.account === account;
            }).map(function (row) {
              row.scope = 'dappairhodl1';
              return row;
            }));

          case 16:
            _context8.prev = 16;
            _context8.t2 = _context8["catch"](0);
            return _context8.abrupt("return", []);

          case 19:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[0, 16]]);
  }));
  return _getDapphodlUnstakes.apply(this, arguments);
}

var http = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var path, method, body, headers, data, response;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            path = _ref.path, method = _ref.method, body = _ref.body, headers = _ref.headers;
            _context.prev = 1;
            _context.next = 4;
            return cross_fetch__WEBPACK_IMPORTED_MODULE_5___default()(path, {
              method: method,
              body: body,
              headers: headers || {
                'Content-Type': 'application/json'
              }
            });

          case 4:
            response = _context.sent;
            _context.next = 7;
            return response.json();

          case 7:
            data = _context.sent;
            _context.next = 13;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);

          case 13:
            if (response && response.ok) {
              _context.next = 15;
              break;
            }

            throw new _proton_js__WEBPACK_IMPORTED_MODULE_0__.RpcError(data || 'Error');

          case 15:
            return _context.abrupt("return", data);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 10]]);
  }));

  return function http(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var get = /*#__PURE__*/function () {
  var _ref3 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, headers) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return http({
              path: path,
              method: 'GET',
              headers: headers
            });

          case 2:
            return _context2.abrupt("return", _context2.sent);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function get(_x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}();
var post = /*#__PURE__*/function () {
  var _ref4 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path, body) {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return http({
              path: path,
              method: 'POST',
              body: JSON.stringify(body)
            });

          case 2:
            return _context3.abrupt("return", _context3.sent);

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function post(_x4, _x5) {
    return _ref4.apply(this, arguments);
  };
}();

function getFIOVoter(_x) {
  return _getFIOVoter.apply(this, arguments);
}

function _getFIOVoter() {
  _getFIOVoter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              upper_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'voters',
              key_type: 'i64',
              index_position: 3,
              limit: 1
            });

          case 3:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context.abrupt("return", rows.length ? rows[0] : undefined);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getFIOVoter.apply(this, arguments);
}

function getFIOAddressByName(_x2) {
  return _getFIOAddressByName.apply(this, arguments);
}

function _getFIOAddressByName() {
  _getFIOAddressByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name) {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.t0 = this.rpc;
            _context2.next = 4;
            return (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.string_to_uint128_hash)(name);

          case 4:
            _context2.t1 = _context2.sent;
            _context2.t2 = '0x' + _context2.t1;
            _context2.t3 = {
              code: 'fio.address',
              scope: 'fio.address',
              table: 'fionames',
              lower_bound: _context2.t2,
              limit: 1,
              key_type: 'i128',
              index_position: 5
            };
            _context2.next = 9;
            return _context2.t0.get_table_rows.call(_context2.t0, _context2.t3);

          case 9:
            _yield$this$rpc$get_t2 = _context2.sent;
            rows = _yield$this$rpc$get_t2.rows;

            if (!(rows && rows.length && rows[0].name === name)) {
              _context2.next = 15;
              break;
            }

            return _context2.abrupt("return", rows[0]);

          case 15:
            return _context2.abrupt("return", undefined);

          case 16:
            _context2.next = 22;
            break;

          case 18:
            _context2.prev = 18;
            _context2.t4 = _context2["catch"](0);
            console.log(_context2.t4);
            return _context2.abrupt("return", undefined);

          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 18]]);
  }));
  return _getFIOAddressByName.apply(this, arguments);
}

function getNFTsByFioAddress(_x3) {
  return _getNFTsByFioAddress.apply(this, arguments);
}

function _getNFTsByFioAddress() {
  _getNFTsByFioAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(name) {
    var _yield$this$rpc$get_n, nfts;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return this.rpc.get_nfts_fio_address(name);

          case 3:
            _yield$this$rpc$get_n = _context3.sent;
            nfts = _yield$this$rpc$get_n.nfts;

            if (!(nfts && nfts.length)) {
              _context3.next = 9;
              break;
            }

            return _context3.abrupt("return", nfts);

          case 9:
            return _context3.abrupt("return", []);

          case 10:
            _context3.next = 16;
            break;

          case 12:
            _context3.prev = 12;
            _context3.t0 = _context3["catch"](0);
            console.log(_context3.t0);
            return _context3.abrupt("return", []);

          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 12]]);
  }));
  return _getNFTsByFioAddress.apply(this, arguments);
}

function getFIODomainByName(_x4) {
  return _getFIODomainByName.apply(this, arguments);
}

function _getFIODomainByName() {
  _getFIODomainByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(name) {
    var _yield$this$rpc$get_t3, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.t0 = this.rpc;
            _context4.next = 4;
            return (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.string_to_uint128_hash)(name);

          case 4:
            _context4.t1 = _context4.sent;
            _context4.t2 = '0x' + _context4.t1;
            _context4.t3 = {
              code: 'fio.address',
              scope: 'fio.address',
              table: 'domains',
              lower_bound: _context4.t2,
              limit: 1,
              key_type: 'i128',
              index_position: 4
            };
            _context4.next = 9;
            return _context4.t0.get_table_rows.call(_context4.t0, _context4.t3);

          case 9:
            _yield$this$rpc$get_t3 = _context4.sent;
            rows = _yield$this$rpc$get_t3.rows;

            if (!(rows && rows.length && rows[0].name === name)) {
              _context4.next = 15;
              break;
            }

            return _context4.abrupt("return", rows[0]);

          case 15:
            return _context4.abrupt("return", undefined);

          case 16:
            _context4.next = 22;
            break;

          case 18:
            _context4.prev = 18;
            _context4.t4 = _context4["catch"](0);
            console.log(_context4.t4);
            return _context4.abrupt("return", undefined);

          case 22:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 18]]);
  }));
  return _getFIODomainByName.apply(this, arguments);
}

function getDomains(_x5, _x6) {
  return _getDomains.apply(this, arguments);
}

function _getDomains() {
  _getDomains = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(limit, upper_bound) {
    var _yield$this$rpc$get_t4, rows;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (limit === void 0) {
              limit = -1;
            }

            _context5.prev = 1;
            _context5.next = 4;
            return this.rpc.get_table_rows({
              code: 'fio.address',
              scope: 'fio.address',
              table: 'domains',
              reverse: true,
              upper_bound: upper_bound,
              limit: limit
            });

          case 4:
            _yield$this$rpc$get_t4 = _context5.sent;
            rows = _yield$this$rpc$get_t4.rows;

            if (!(rows && rows.length)) {
              _context5.next = 10;
              break;
            }

            return _context5.abrupt("return", rows);

          case 10:
            return _context5.abrupt("return", []);

          case 11:
            _context5.next = 17;
            break;

          case 13:
            _context5.prev = 13;
            _context5.t0 = _context5["catch"](1);
            console.log(_context5.t0);
            return _context5.abrupt("return", []);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[1, 13]]);
  }));
  return _getDomains.apply(this, arguments);
}

function getAddresses(_x7, _x8) {
  return _getAddresses.apply(this, arguments);
}

function _getAddresses() {
  _getAddresses = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(limit, upper_bound) {
    var _yield$this$rpc$get_t5, rows;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (limit === void 0) {
              limit = -1;
            }

            _context6.prev = 1;
            _context6.next = 4;
            return this.rpc.get_table_rows({
              code: 'fio.address',
              scope: 'fio.address',
              table: 'fionames',
              reverse: true,
              upper_bound: upper_bound,
              limit: limit
            });

          case 4:
            _yield$this$rpc$get_t5 = _context6.sent;
            rows = _yield$this$rpc$get_t5.rows;

            if (!(rows && rows.length)) {
              _context6.next = 10;
              break;
            }

            return _context6.abrupt("return", rows);

          case 10:
            return _context6.abrupt("return", []);

          case 11:
            _context6.next = 17;
            break;

          case 13:
            _context6.prev = 13;
            _context6.t0 = _context6["catch"](1);
            console.log(_context6.t0);
            return _context6.abrupt("return", []);

          case 17:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[1, 13]]);
  }));
  return _getAddresses.apply(this, arguments);
}

function getFIOProducers(_x9) {
  return _getFIOProducers.apply(this, arguments);
}

function _getFIOProducers() {
  _getFIOProducers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(limit) {
    var _yield$this$rpc$get_t6, rows;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'producers',
              reverse: true,
              limit: limit
            });

          case 3:
            _yield$this$rpc$get_t6 = _context7.sent;
            rows = _yield$this$rpc$get_t6.rows;

            if (!(rows && rows.length)) {
              _context7.next = 9;
              break;
            }

            return _context7.abrupt("return", rows);

          case 9:
            return _context7.abrupt("return", []);

          case 10:
            _context7.next = 16;
            break;

          case 12:
            _context7.prev = 12;
            _context7.t0 = _context7["catch"](0);
            console.log(_context7.t0);
            return _context7.abrupt("return", []);

          case 16:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 12]]);
  }));
  return _getFIOProducers.apply(this, arguments);
}

function getFIOBalance(_x10) {
  return _getFIOBalance.apply(this, arguments);
}

function _getFIOBalance() {
  _getFIOBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(fio_public_key) {
    var balance;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return this.rpc.fetch('/v1/chain/get_fio_balance', {
              fio_public_key: fio_public_key
            });

          case 3:
            balance = _context8.sent;

            if (!balance) {
              _context8.next = 8;
              break;
            }

            return _context8.abrupt("return", balance);

          case 8:
            return _context8.abrupt("return", null);

          case 9:
            _context8.next = 15;
            break;

          case 11:
            _context8.prev = 11;
            _context8.t0 = _context8["catch"](0);
            console.log(_context8.t0);
            return _context8.abrupt("return", null);

          case 15:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[0, 11]]);
  }));
  return _getFIOBalance.apply(this, arguments);
}

function getFIOSupplyBreakdown() {
  return _getFIOSupplyBreakdown.apply(this, arguments);
}

function _getFIOSupplyBreakdown() {
  _getFIOSupplyBreakdown = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
    var tokenRes, supply, bpRewardRes, bpRewards, bpBucketRes, bpBucket, totalBp, circulating, totalLocked;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.rpc.get_table_rows({
              code: "fio.token",
              scope: "FIO",
              table: "stat"
            });

          case 2:
            tokenRes = _context9.sent;
            supply = +tokenRes.rows[0].supply.split(' ')[0];
            _context9.next = 6;
            return this.rpc.get_table_rows({
              code: "fio.treasury",
              scope: "fio.treasury",
              table: "bprewards"
            });

          case 6:
            bpRewardRes = _context9.sent;
            bpRewards = bpRewardRes.rows[0].rewards / Math.pow(10, this.constants.CORE_PRECISION);
            _context9.next = 10;
            return this.rpc.get_table_rows({
              code: "fio.treasury",
              scope: "fio.treasury",
              table: "bpbucketpool"
            });

          case 10:
            bpBucketRes = _context9.sent;
            bpBucket = bpBucketRes.rows[0].rewards / Math.pow(10, this.constants.CORE_PRECISION);
            totalBp = bpRewards + bpBucket; // const totalLocked = baseLocked + totalBp
            // const circulating = supply - totalLocked

            _context9.next = 15;
            return this.get('https://fioprotocol.io/circulating');

          case 15:
            circulating = _context9.sent;
            totalLocked = supply - +circulating;
            return _context9.abrupt("return", {
              supply: supply,
              totalLocked: totalLocked,
              bpRewards: bpRewards,
              bpBucket: bpBucket,
              totalBp: totalBp,
              circulating: circulating
            });

          case 18:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this);
  }));
  return _getFIOSupplyBreakdown.apply(this, arguments);
}

function getFIOFees() {
  return _getFIOFees.apply(this, arguments);
}

function _getFIOFees() {
  _getFIOFees = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            return _context10.abrupt("return", this.rpc.get_table_rows({
              code: 'fio.fee',
              scope: 'fio.fee',
              table: 'fiofees',
              limit: -1
            }).then(function (result) {
              return result.rows;
            })["catch"](function (_) {
              return [];
            }));

          case 1:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, this);
  }));
  return _getFIOFees.apply(this, arguments);
}

function addFIOFeeToActions(_x11, _x12) {
  return _addFIOFeeToActions.apply(this, arguments);
}

function _addFIOFeeToActions() {
  _addFIOFeeToActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(actions, actor) {
    var _this = this;

    var fioFeesMap, fees, modifiedActions, _loop, _iterator, _step;

    return _regeneratorRuntime().wrap(function _callee11$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            fioFeesMap = {
              'eosio::deleteauth': 'auth_delete',
              'eosio::linkauth': 'auth_link',
              'eosio::regproducer': 'register_producer',
              'eosio::regproxy': 'register_proxy',
              'eosio::unregprod': 'unregister_producer',
              'eosio::unregproxy': 'unregister_proxy',
              'eosio::updateauth': 'auth_update',
              'eosio::voteproducer': 'vote_producer',
              'eosio::voteproxy': 'proxy_vote',
              'fio.token::trnsfiopubky': 'transfer_tokens_pub_key',
              'fio.address::addaddress': 'add_pub_address',
              'fio.address::regaddress': 'register_fio_address',
              'fio.address::regdomain': 'register_fio_domain',
              'fio.address::renewaddress': 'renew_fio_address',
              'fio.address::renewdomain': 'renew_fio_domain',
              'fio.address::setdomainpub': 'set_fio_domain_public',
              'eosio.msig::approve': 'msig_approve',
              'eosio.msig::cancel': 'msig_cancel',
              'eosio.msig::exec': 'msig_exec',
              'eosio.msig::invalidate': 'msig_invalidate',
              'eosio.msig::propose': 'msig_propose',
              'eosio.msig::unapprove': 'msig_approve',
              'fio.reqobt::newfundsreq': 'new_funds_request',
              'fio.reqobt::rejectfndreq': 'reject_funds_request',
              'fio.reqobt::cancelfndreq': 'cancelfndreq',
              'fio.reqobt::recordobt': 'record_obt_data',
              'fio.reqobt::newpubaddreq': 'new_pub_address_request',
              'fio.reqobt::relpubadd': 'release_pub_address',
              'fio.reqobt::rejectaddreq': 'reject_pub_address_request',
              'fio.reqobt::canceladdreq': 'cancel_pub_address_request',
              'fio.lock::trnsloctoks': 'transfer_locked_tokens',
              'fio.lock::locktokens': 'lock_tokens',
              'fio.address::remaddress': 'remove_pub_address',
              'fio.address::remalladdr': 'remove_all_pub_addresses',
              'fio.address::burnaddress': 'burn_fio_address',
              'fio.address::xferdomain': 'transfer_fio_domain',
              'fio.address::xferaddress': 'transfer_fio_address'
            };
            _context12.next = 3;
            return this.getFIOFees();

          case 3:
            fees = _context12.sent;
            modifiedActions = [];
            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
              var action, _yield$_this$api$getC, _yield$_this$api$getC2, abiActions, abiStructs, relevantAction, relevantStruct, maxFeeField, endpoint, relevantFee, actorField, tpidField, addressField, addresses;

              return _regeneratorRuntime().wrap(function _loop$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      action = _step.value;
                      _context11.next = 3;
                      return _this.api.getCachedAbi(action.account);

                    case 3:
                      _yield$_this$api$getC = _context11.sent;
                      _yield$_this$api$getC2 = _yield$_this$api$getC.abi;
                      abiActions = _yield$_this$api$getC2.actions;
                      abiStructs = _yield$_this$api$getC2.structs;
                      relevantAction = abiActions.find(function (abiAction) {
                        return abiAction.name === action.name;
                      });

                      if (!relevantAction) {
                        _context11.next = 23;
                        break;
                      }

                      relevantStruct = abiStructs.find(function (abiStruct) {
                        return abiStruct.name === relevantAction.type;
                      });

                      if (!relevantStruct) {
                        _context11.next = 23;
                        break;
                      }

                      maxFeeField = relevantStruct.fields.find(function (field) {
                        return field.name === "max_fee";
                      });

                      if (maxFeeField && action.data.max_fee === undefined) {
                        endpoint = fioFeesMap[action.account + "::" + action.name];

                        if (endpoint) {
                          relevantFee = fees.find(function (fee) {
                            return fee.end_point === endpoint;
                          });

                          if (relevantFee) {
                            action.data.max_fee = relevantFee.suf_amount;
                          } else {
                            action.data.max_fee = 0;
                          }
                        }
                      }

                      actorField = relevantStruct.fields.find(function (field) {
                        return field.name === "actor";
                      });

                      if (actorField && action.data.actor === undefined) {
                        action.data.actor = actor;
                      }

                      tpidField = relevantStruct.fields.find(function (field) {
                        return field.name === "tpid";
                      });

                      if (tpidField && action.data.tpid === undefined) {
                        action.data.tpid = _this.constants.FIO_FEES_ACCOUNT;
                      }

                      addressField = relevantStruct.fields.find(function (field) {
                        return field.name === "fio_address";
                      });

                      if (!(addressField && action.data.fio_address === undefined)) {
                        _context11.next = 23;
                        break;
                      }

                      _context11.next = 21;
                      return _this.getFIOAddresses(actor);

                    case 21:
                      addresses = _context11.sent;

                      if (addresses.length) {
                        action.data.fio_address = addresses[0].name;
                      }

                    case 23:
                      modifiedActions.push(action);

                    case 24:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _loop);
            });
            _iterator = _createForOfIteratorHelperLoose(actions);

          case 7:
            if ((_step = _iterator()).done) {
              _context12.next = 11;
              break;
            }

            return _context12.delegateYield(_loop(), "t0", 9);

          case 9:
            _context12.next = 7;
            break;

          case 11:
            return _context12.abrupt("return", modifiedActions);

          case 12:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee11, this);
  }));
  return _addFIOFeeToActions.apply(this, arguments);
}

function getFIOAddresses(account) {
  return this.rpc.get_table_rows({
    code: 'fio.address',
    scope: 'fio.address',
    table: 'fionames',
    key_type: 'i64',
    limit: -1,
    lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
    upper_bound: new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)).plus(1).toString(),
    index_position: 4
  }).then(function (result) {
    if (result.rows.length > 0) {
      return result.rows.filter(function (row) {
        return row.owner_account === account;
      });
    } else {
      return [];
    }
  })["catch"](function (_) {
    return [];
  });
}
function getFIODomains(account) {
  return this.rpc.get_table_rows({
    code: 'fio.address',
    scope: 'fio.address',
    table: 'domains',
    key_type: 'i64',
    limit: -1,
    lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
    upper_bound: new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)).plus(1).toString(),
    index_position: 2
  }).then(function (result) {
    if (result.rows.length > 0) {
      return result.rows.filter(function (row) {
        return row.account === account;
      });
    } else {
      return [];
    }
  })["catch"](function (_) {
    return [];
  });
}
function getFIOAddressesAndDomains(fio_public_key) {
  return post(this.constants.DEFAULT_ENDPOINTS[0] + "/v1/get_fio_names", {
    fio_public_key: fio_public_key
  });
}

function getAllMsigs() {
  return _getAllMsigs.apply(this, arguments);
}

function _getAllMsigs() {
  _getAllMsigs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$this$get, tables, rows, lower_bound, result;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!this.constants.HISTORY_TYPES.includes('dfuse')) {
              _context.next = 9;
              break;
            }

            _context.next = 3;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'dfuse', {
              type: 'state_scope_pipeline',
              account: this.constants.EOSIO_MSIG,
              table: this.constants.EOSIO_MSIG_PROPOSALS_TABLE,
              options: {}
            }));

          case 3:
            _yield$this$get = _context.sent;
            tables = _yield$this$get.tables;
            tables = tables.map(function (table) {
              table.rows = table.rows.sort(function (a, b) {
                return b.block - a.block;
              });
              table.highestBlock = table.rows[0].block;
              return table;
            }).sort(function (a, b) {
              return b.highestBlock - a.highestBlock;
            });
            return _context.abrupt("return", tables);

          case 9:
            rows = [];
            lower_bound = '';

          case 11:
            _context.next = 13;
            return this.rpc.get_table_by_scope({
              json: true,
              code: 'eosio.msig',
              limit: 100,
              lower_bound: lower_bound,
              table: 'proposal',
              upper_bound: ''
            });

          case 13:
            result = _context.sent;
            lower_bound = result.more;
            rows = rows.concat(result.rows);

          case 16:
            if (lower_bound) {
              _context.next = 11;
              break;
            }

          case 17:
            return _context.abrupt("return", rows.map(function (row) {
              return {
                scope: row.scope,
                rows: Array(row.count).fill({
                  key: ''
                })
              };
            }));

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getAllMsigs.apply(this, arguments);
}

function getMsigProposal(_x, _x2) {
  return _getMsigProposal.apply(this, arguments);
}

function _getMsigProposal() {
  _getMsigProposal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(accountName, proposalName) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: 'eosio.msig',
              scope: accountName,
              limit: 1,
              lower_bound: proposalName,
              table: 'proposal'
            });

          case 2:
            _yield$this$rpc$get_t = _context2.sent;
            rows = _yield$this$rpc$get_t.rows;

            if (!(rows && rows.length && rows[0].proposal_name === proposalName)) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return", rows[0]);

          case 8:
            return _context2.abrupt("return", undefined);

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getMsigProposal.apply(this, arguments);
}

function parsePackedMsigActions(_x3) {
  return _parsePackedMsigActions.apply(this, arguments);
}

function _parsePackedMsigActions() {
  _parsePackedMsigActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(packedActions) {
    var actions, _iterator, _step, action;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            actions = [];
            _iterator = _createForOfIteratorHelperLoose(packedActions);

          case 2:
            if ((_step = _iterator()).done) {
              _context3.next = 15;
              break;
            }

            action = _step.value;

            if (!(action.account === this.constants.EOSIO_MSIG && action.name === 'propose')) {
              _context3.next = 8;
              break;
            }

            _context3.next = 7;
            return this.api.deserializeActionsSync(action.data.trx.actions);

          case 7:
            action.data.trx.actions = _context3.sent;

          case 8:
            if (!(action.account === this.constants.EOSIO && action.name === 'setabi')) {
              _context3.next = 12;
              break;
            }

            _context3.next = 11;
            return this.api.rawAbiToJson((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.hexToUint8Array)(action.data.abi));

          case 11:
            action.data.abi = _context3.sent;

          case 12:
            actions.push(action);

          case 13:
            _context3.next = 2;
            break;

          case 15:
            actions = actions.map(function (action) {
              return {
                action_trace: {
                  act: action
                }
              };
            });
            return _context3.abrupt("return", actions);

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _parsePackedMsigActions.apply(this, arguments);
}

function parsePackedMsig(_x4) {
  return _parsePackedMsig.apply(this, arguments);
}

function _parsePackedMsig() {
  _parsePackedMsig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(packed_transaction) {
    var tx;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.api.deserializeTransactionWithActions(packed_transaction);

          case 3:
            tx = _context4.sent;
            _context4.next = 6;
            return this.parsePackedMsigActions(tx.actions);

          case 6:
            tx.actions = _context4.sent;
            return _context4.abrupt("return", tx);

          case 10:
            _context4.prev = 10;
            _context4.t0 = _context4["catch"](0);
            console.log('Error parsing packed msig');
            console.log(_context4.t0);

          case 14:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 10]]);
  }));
  return _parsePackedMsig.apply(this, arguments);
}

function getFullMsigProposal(_x5, _x6) {
  return _getFullMsigProposal.apply(this, arguments);
}

function _getFullMsigProposal() {
  _getFullMsigProposal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account_name, proposal_name) {
    var result;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO_MSIG,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account_name, false),
              table: this.constants.EOSIO_MSIG_PROPOSALS_TABLE,
              table_key: '',
              key_type: 'name',
              lower_bound: proposal_name,
              index_position: 1,
              limit: 1
            });

          case 3:
            result = _context5.sent;

            if (!(result && result.rows && result.rows.length)) {
              _context5.next = 8;
              break;
            }

            _context5.next = 7;
            return this.parsePackedMsig(result.rows[0].packed_transaction);

          case 7:
            return _context5.abrupt("return", _context5.sent);

          case 8:
            _context5.next = 13;
            break;

          case 10:
            _context5.prev = 10;
            _context5.t0 = _context5["catch"](0);
            console.log(_context5.t0);

          case 13:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 10]]);
  }));
  return _getFullMsigProposal.apply(this, arguments);
}

function getMsigApprovals(_x7, _x8) {
  return _getMsigApprovals.apply(this, arguments);
}

function _getMsigApprovals() {
  _getMsigApprovals = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(account, table) {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            _context6.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO_MSIG,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: table,
              limit: -1
            });

          case 3:
            _yield$this$rpc$get_t2 = _context6.sent;
            rows = _yield$this$rpc$get_t2.rows;
            return _context6.abrupt("return", rows);

          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](0);
            console.log(_context6.t0);
            return _context6.abrupt("return", []);

          case 12:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[0, 8]]);
  }));
  return _getMsigApprovals.apply(this, arguments);
}

function getAccountsMsigProposals(_x9) {
  return _getAccountsMsigProposals.apply(this, arguments);
}

function _getAccountsMsigProposals() {
  _getAccountsMsigProposals = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(account) {
    var promises, _yield$Promise$all, rows2, rows1;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            promises = [this.getMsigApprovals(account, this.constants.EOSIO_MSIG_APPROVALS_TABLE)];

            if (this.constants.EOSIO_MSIG_APPROVALS_TABLE === 'approvals2') {
              promises.push(this.getMsigApprovals(account, 'approvals'));
            }

            _context7.next = 5;
            return Promise.all(promises);

          case 5:
            _yield$Promise$all = _context7.sent;
            rows2 = _yield$Promise$all[0];
            rows1 = _yield$Promise$all[1];
            return _context7.abrupt("return", rows2.concat(rows1));

          case 11:
            _context7.prev = 11;
            _context7.t0 = _context7["catch"](0);
            console.log(_context7.t0);
            return _context7.abrupt("return", []);

          case 15:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 11]]);
  }));
  return _getAccountsMsigProposals.apply(this, arguments);
}

function hyperionGetMsig(_x10) {
  return _hyperionGetMsig.apply(this, arguments);
}

function _hyperionGetMsig() {
  _hyperionGetMsig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(msigFilters) {
    var res, executionTransaction, transaction, proposal, _yield$Promise$all2, actionsRes, actionsRes2, relevantAction, tx;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (this.hyperion) {
              _context8.next = 2;
              break;
            }

            return _context8.abrupt("return", undefined);

          case 2:
            _context8.next = 4;
            return this.hyperion.get_proposals(msigFilters);

          case 4:
            res = _context8.sent;

            if (!(res && res.proposals && res.proposals.length)) {
              _context8.next = 22;
              break;
            }

            proposal = res.proposals[0];
            _context8.next = 9;
            return Promise.all([this.hyperion.get_actions(this.constants.EOSIO_MSIG, {
              block_num: proposal.block_num,
              limit: 1
            }), this.hyperion.get_deltas(this.constants.EOSIO_MSIG, msigFilters.proposer, 'proposal', undefined, {
              block_num: proposal.block_num
            })]);

          case 9:
            _yield$Promise$all2 = _context8.sent;
            actionsRes = _yield$Promise$all2[0];
            actionsRes2 = _yield$Promise$all2[1];

            if (actionsRes && actionsRes.actions && actionsRes.actions.length) {
              relevantAction = actionsRes.actions.find(function (action) {
                return action.act.data.proposal_name === msigFilters.proposal;
              });

              if (relevantAction) {
                executionTransaction = {
                  payer: relevantAction.act.data.executer || relevantAction.act.data.canceler,
                  trx_id: relevantAction.trx_id,
                  published_at: relevantAction.timestamp,
                  cancelled: relevantAction.act.name === 'cancel'
                };
              }
            }

            if (!(actionsRes2 && actionsRes2.deltas && actionsRes2.deltas.length)) {
              _context8.next = 19;
              break;
            }

            tx = actionsRes2.deltas[0].data.transaction;
            _context8.next = 17;
            return this.parsePackedMsigActions(tx.actions);

          case 17:
            tx.actions = _context8.sent;
            transaction = tx;

          case 19:
            return _context8.abrupt("return", {
              approvals: proposal,
              transaction: transaction,
              executionTransaction: executionTransaction
            });

          case 22:
            return _context8.abrupt("return", undefined);

          case 23:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));
  return _hyperionGetMsig.apply(this, arguments);
}

function getVoter(_x) {
  return _getVoter.apply(this, arguments);
}

function _getVoter() {
  _getVoter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              upper_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'voters',
              limit: 1
            });

          case 3:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context.abrupt("return", rows.length ? rows[0] : undefined);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getVoter.apply(this, arguments);
}

function getProxies() {
  return _getProxies.apply(this, arguments);
}

function _getProxies() {
  _getProxies = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var _this = this;

    var _yield$this$get, proxies, _yield$this$hyperion$, voters;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(this.constants.ALOHA_PROXY_URL !== '')) {
              _context2.next = 8;
              break;
            }

            _context2.next = 3;
            return this.get(this.constants.ALOHA_PROXY_URL + "?output=json");

          case 3:
            _yield$this$get = _context2.sent;
            proxies = _yield$this$get.proxies;
            return _context2.abrupt("return", proxies);

          case 8:
            _context2.next = 10;
            return this.hyperion.get_voters({
              proxy: true,
              limit: 1000
            });

          case 10:
            _yield$this$hyperion$ = _context2.sent;
            voters = _yield$this$hyperion$.voters;
            return _context2.abrupt("return", voters.map(function (voter, index) {
              return _extends({}, voter, {
                weight: voter.weight / Math.pow(10, _this.constants.CORE_PRECISION),
                rank: index + 1
              });
            }));

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getProxies.apply(this, arguments);
}

function getVoters(_x2) {
  return _getVoters.apply(this, arguments);
}

function _getVoters() {
  _getVoters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(producer) {
    var _this2 = this;

    var _yield$this$hyperion$2, voters, voteWeight;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!this.hyperion) {
              _context3.next = 9;
              break;
            }

            _context3.next = 3;
            return this.hyperion.get_voters({
              producer: producer,
              limit: 100
            });

          case 3:
            _yield$this$hyperion$2 = _context3.sent;
            voters = _yield$this$hyperion$2.voters;
            voteWeight = this.calculateVoteWeight();
            return _context3.abrupt("return", voters.map(function (voter) {
              return _extends({}, voter, {
                vote: _this2.weightedVoteToNumber(voter.weight, voteWeight)
              });
            }));

          case 9:
            return _context3.abrupt("return", undefined);

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getVoters.apply(this, arguments);
}

function calculateVoteWeight() {
  var decayWeeks = this.constants.CHAIN === 'wax' ? 13 : 52;
  var timestamp_epoch = 946684800000;
  var dates = Date.now() / 1000 - timestamp_epoch / 1000;
  var weight = Math.floor(dates / (86400 * 7)) / decayWeeks;
  return Math.pow(2, weight);
}
function weightedVoteToNumber(weightedVote, voteWeight) {
  if (!voteWeight) {
    voteWeight = this.calculateVoteWeight();
  }

  return +weightedVote / voteWeight / Math.pow(10, this.constants.CORE_PRECISION);
}
function getProxyData(_x3) {
  return _getProxyData.apply(this, arguments);
}

function _getProxyData() {
  _getProxyData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(accountName) {
    var _yield$this$get2, proxy;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(this.constants.ALOHA_PROXY_URL !== '')) {
              _context4.next = 8;
              break;
            }

            _context4.next = 3;
            return this.get(this.constants.ALOHA_PROXY_URL + "/" + accountName + "?output=json");

          case 3:
            _yield$this$get2 = _context4.sent;
            proxy = _yield$this$get2.proxy;
            return _context4.abrupt("return", proxy);

          case 8:
            return _context4.abrupt("return", undefined);

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getProxyData.apply(this, arguments);
}

function getProducersLocal() {
  return _getProducersLocal.apply(this, arguments);
}

function _getProducersLocal() {
  _getProducersLocal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var more, rows, result, lower_bound;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            more = true;
            rows = [];
            result = null;
            lower_bound = null;

          case 4:
            _context5.next = 6;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'producers',
              lower_bound: lower_bound,
              index_position: 1,
              key_type: 'i64',
              limit: 100
            });

          case 6:
            result = _context5.sent;
            more = result.more;
            rows = rows.concat(result.rows);
            lower_bound = new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(rows[rows.length - 1].owner, false)).plus(1).toString();

          case 10:
            if (more) {
              _context5.next = 4;
              break;
            }

          case 11:
            return _context5.abrupt("return", rows);

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _getProducersLocal.apply(this, arguments);
}

function getProducers(_x4, _x5, _x6) {
  return _getProducers.apply(this, arguments);
}

function _getProducers() {
  _getProducers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(pageNum, perPage, local) {
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (pageNum === void 0) {
              pageNum = 1;
            }

            if (perPage === void 0) {
              perPage = 50;
            }

            if (local === void 0) {
              local = false;
            }

            if (!(this.constants.API_URL !== '' && !local)) {
              _context6.next = 9;
              break;
            }

            _context6.next = 6;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'producers', {
              pageNum: pageNum,
              perPage: perPage
            }));

          case 6:
            return _context6.abrupt("return", _context6.sent);

          case 9:
            return _context6.abrupt("return", this.getProducersLocal());

          case 10:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _getProducers.apply(this, arguments);
}

function getChainTable() {
  return _getChainTable.apply(this, arguments);
}

function _getChainTable() {
  _getChainTable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'global',
              limit: 1
            });

          case 2:
            _yield$this$rpc$get_t2 = _context7.sent;
            rows = _yield$this$rpc$get_t2.rows;
            return _context7.abrupt("return", rows[0]);

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _getChainTable.apply(this, arguments);
}

var KycStatus;

(function (KycStatus) {
  KycStatus["FAILED"] = "FAILED";
  KycStatus["UNSUBMITTED"] = "UNSUBMITTED";
  KycStatus["PENDING"] = "PENDING";
  KycStatus["PASSED"] = "PASSED";
})(KycStatus || (KycStatus = {}));

var countryOptions = [{
  key: 'AF',
  value: 'AF',
  flag: 'af',
  text: 'Afghanistan'
}, {
  key: 'AX',
  value: 'AX',
  flag: 'ax',
  text: 'Aland Islands'
}, {
  key: 'AL',
  value: 'AL',
  flag: 'al',
  text: 'Albania'
}, {
  key: 'DZ',
  value: 'DZ',
  flag: 'dz',
  text: 'Algeria'
}, {
  key: 'AS',
  value: 'AS',
  flag: 'as',
  text: 'American Samoa'
}, {
  key: 'AD',
  value: 'AD',
  flag: 'ad',
  text: 'Andorra'
}, {
  key: 'AO',
  value: 'AO',
  flag: 'ao',
  text: 'Angola'
}, {
  key: 'AI',
  value: 'AI',
  flag: 'ai',
  text: 'Anguilla'
}, {
  key: 'AG',
  value: 'AG',
  flag: 'ag',
  text: 'Antigua'
}, {
  key: 'AR',
  value: 'AR',
  flag: 'ar',
  text: 'Argentina'
}, {
  key: 'AM',
  value: 'AM',
  flag: 'am',
  text: 'Armenia'
}, {
  key: 'AW',
  value: 'AW',
  flag: 'aw',
  text: 'Aruba'
}, {
  key: 'AU',
  value: 'AU',
  flag: 'au',
  text: 'Australia'
}, {
  key: 'AT',
  value: 'AT',
  flag: 'at',
  text: 'Austria'
}, {
  key: 'AZ',
  value: 'AZ',
  flag: 'az',
  text: 'Azerbaijan'
}, {
  key: 'BS',
  value: 'BS',
  flag: 'bs',
  text: 'Bahamas'
}, {
  key: 'BH',
  value: 'BH',
  flag: 'bh',
  text: 'Bahrain'
}, {
  key: 'BD',
  value: 'BD',
  flag: 'bd',
  text: 'Bangladesh'
}, {
  key: 'BB',
  value: 'BB',
  flag: 'bb',
  text: 'Barbados'
}, {
  key: 'BY',
  value: 'BY',
  flag: 'by',
  text: 'Belarus'
}, {
  key: 'BE',
  value: 'BE',
  flag: 'be',
  text: 'Belgium'
}, {
  key: 'BZ',
  value: 'BZ',
  flag: 'bz',
  text: 'Belize'
}, {
  key: 'BJ',
  value: 'BJ',
  flag: 'bj',
  text: 'Benin'
}, {
  key: 'BM',
  value: 'BM',
  flag: 'bm',
  text: 'Bermuda'
}, {
  key: 'BT',
  value: 'BT',
  flag: 'bt',
  text: 'Bhutan'
}, {
  key: 'BO',
  value: 'BO',
  flag: 'bo',
  text: 'Bolivia'
}, {
  key: 'BA',
  value: 'BA',
  flag: 'ba',
  text: 'Bosnia'
}, {
  key: 'BW',
  value: 'BW',
  flag: 'bw',
  text: 'Botswana'
}, {
  key: 'BV',
  value: 'BV',
  flag: 'bv',
  text: 'Bouvet Island'
}, {
  key: 'BR',
  value: 'BR',
  flag: 'br',
  text: 'Brazil'
}, {
  key: 'VG',
  value: 'VG',
  flag: 'vg',
  text: 'British Virgin Islands'
}, {
  key: 'BN',
  value: 'BN',
  flag: 'bn',
  text: 'Brunei'
}, {
  key: 'BG',
  value: 'BG',
  flag: 'bg',
  text: 'Bulgaria'
}, {
  key: 'BF',
  value: 'BF',
  flag: 'bf',
  text: 'Burkina Faso'
}, {
  key: 'BI',
  value: 'BI',
  flag: 'bi',
  text: 'Burundi'
}, {
  key: 'TC',
  value: 'TC',
  flag: 'tc',
  text: 'Caicos Islands'
}, {
  key: 'KH',
  value: 'KH',
  flag: 'kh',
  text: 'Cambodia'
}, {
  key: 'CM',
  value: 'CM',
  flag: 'cm',
  text: 'Cameroon'
}, {
  key: 'CA',
  value: 'CA',
  flag: 'ca',
  text: 'Canada'
}, {
  key: 'CV',
  value: 'CV',
  flag: 'cv',
  text: 'Cape Verde'
}, {
  key: 'KY',
  value: 'KY',
  flag: 'ky',
  text: 'Cayman Islands'
}, {
  key: 'CF',
  value: 'CF',
  flag: 'cf',
  text: 'Central African Republic'
}, {
  key: 'TD',
  value: 'TD',
  flag: 'td',
  text: 'Chad'
}, {
  key: 'CL',
  value: 'CL',
  flag: 'cl',
  text: 'Chile'
}, {
  key: 'CN',
  value: 'CN',
  flag: 'cn',
  text: 'China'
}, {
  key: 'CX',
  value: 'CX',
  flag: 'cx',
  text: 'Christmas Island'
}, {
  key: 'CC',
  value: 'CC',
  flag: 'cc',
  text: 'Cocos Islands'
}, {
  key: 'CO',
  value: 'CO',
  flag: 'co',
  text: 'Colombia'
}, {
  key: 'KM',
  value: 'KM',
  flag: 'km',
  text: 'Comoros'
}, {
  key: 'CG',
  value: 'CG',
  flag: 'cg',
  text: 'Congo Brazzaville'
}, {
  key: 'CD',
  value: 'CD',
  flag: 'cd',
  text: 'Congo'
}, {
  key: 'CK',
  value: 'CK',
  flag: 'ck',
  text: 'Cook Islands'
}, {
  key: 'CR',
  value: 'CR',
  flag: 'cr',
  text: 'Costa Rica'
}, {
  key: 'CI',
  value: 'CI',
  flag: 'ci',
  text: 'Cote Divoire'
}, {
  key: 'HR',
  value: 'HR',
  flag: 'hr',
  text: 'Croatia'
}, {
  key: 'CU',
  value: 'CU',
  flag: 'cu',
  text: 'Cuba'
}, {
  key: 'CY',
  value: 'CY',
  flag: 'cy',
  text: 'Cyprus'
}, {
  key: 'CZ',
  value: 'CZ',
  flag: 'cz',
  text: 'Czech Republic'
}, {
  key: 'DK',
  value: 'DK',
  flag: 'dk',
  text: 'Denmark'
}, {
  key: 'DJ',
  value: 'DJ',
  flag: 'dj',
  text: 'Djibouti'
}, {
  key: 'DM',
  value: 'DM',
  flag: 'dm',
  text: 'Dominica'
}, {
  key: 'DO',
  value: 'DO',
  flag: 'do',
  text: 'Dominican Republic'
}, {
  key: 'EC',
  value: 'EC',
  flag: 'ec',
  text: 'Ecuador'
}, {
  key: 'EG',
  value: 'EG',
  flag: 'eg',
  text: 'Egypt'
}, {
  key: 'SV',
  value: 'SV',
  flag: 'sv',
  text: 'El Salvador'
}, {
  key: 'GB',
  value: 'GB',
  flag: 'gb',
  text: 'England'
}, {
  key: 'GQ',
  value: 'GQ',
  flag: 'gq',
  text: 'Equatorial Guinea'
}, {
  key: 'ER',
  value: 'ER',
  flag: 'er',
  text: 'Eritrea'
}, {
  key: 'EE',
  value: 'EE',
  flag: 'ee',
  text: 'Estonia'
}, {
  key: 'ET',
  value: 'ET',
  flag: 'et',
  text: 'Ethiopia'
}, {
  key: 'EU',
  value: 'EU',
  flag: 'eu',
  text: 'European Union'
}, {
  key: 'FK',
  value: 'FK',
  flag: 'fk',
  text: 'Falkland Islands'
}, {
  key: 'FO',
  value: 'FO',
  flag: 'fo',
  text: 'Faroe Islands'
}, {
  key: 'FJ',
  value: 'FJ',
  flag: 'fj',
  text: 'Fiji'
}, {
  key: 'FI',
  value: 'FI',
  flag: 'fi',
  text: 'Finland'
}, {
  key: 'FR',
  value: 'FR',
  flag: 'fr',
  text: 'France'
}, {
  key: 'GF',
  value: 'GF',
  flag: 'gf',
  text: 'French Guiana'
}, {
  key: 'PF',
  value: 'PF',
  flag: 'pf',
  text: 'French Polynesia'
}, {
  key: 'TF',
  value: 'TF',
  flag: 'tf',
  text: 'French Territories'
}, {
  key: 'GA',
  value: 'GA',
  flag: 'ga',
  text: 'Gabon'
}, {
  key: 'GM',
  value: 'GM',
  flag: 'gm',
  text: 'Gambia'
}, {
  key: 'GE',
  value: 'GE',
  flag: 'ge',
  text: 'Georgia'
}, {
  key: 'DE',
  value: 'DE',
  flag: 'de',
  text: 'Germany'
}, {
  key: 'GH',
  value: 'GH',
  flag: 'gh',
  text: 'Ghana'
}, {
  key: 'GI',
  value: 'GI',
  flag: 'gi',
  text: 'Gibraltar'
}, {
  key: 'GR',
  value: 'GR',
  flag: 'gr',
  text: 'Greece'
}, {
  key: 'GL',
  value: 'GL',
  flag: 'gl',
  text: 'Greenland'
}, {
  key: 'GD',
  value: 'GD',
  flag: 'gd',
  text: 'Grenada'
}, {
  key: 'GP',
  value: 'GP',
  flag: 'gp',
  text: 'Guadeloupe'
}, {
  key: 'GU',
  value: 'GU',
  flag: 'gu',
  text: 'Guam'
}, {
  key: 'GT',
  value: 'GT',
  flag: 'gt',
  text: 'Guatemala'
}, {
  key: 'GW',
  value: 'GW',
  flag: 'gw',
  text: 'Guinea-Bissau'
}, {
  key: 'GN',
  value: 'GN',
  flag: 'gn',
  text: 'Guinea'
}, {
  key: 'GY',
  value: 'GY',
  flag: 'gy',
  text: 'Guyana'
}, {
  key: 'HT',
  value: 'HT',
  flag: 'ht',
  text: 'Haiti'
}, {
  key: 'HM',
  value: 'HM',
  flag: 'hm',
  text: 'Heard Island'
}, {
  key: 'HN',
  value: 'HN',
  flag: 'hn',
  text: 'Honduras'
}, {
  key: 'HK',
  value: 'HK',
  flag: 'hk',
  text: 'Hong Kong'
}, {
  key: 'HU',
  value: 'HU',
  flag: 'hu',
  text: 'Hungary'
}, {
  key: 'IS',
  value: 'IS',
  flag: 'is',
  text: 'Iceland'
}, {
  key: 'IN',
  value: 'IN',
  flag: 'in',
  text: 'India'
}, {
  key: 'IO',
  value: 'IO',
  flag: 'io',
  text: 'Indian Ocean Territory'
}, {
  key: 'ID',
  value: 'ID',
  flag: 'id',
  text: 'Indonesia'
}, {
  key: 'IR',
  value: 'IR',
  flag: 'ir',
  text: 'Iran'
}, {
  key: 'IQ',
  value: 'IQ',
  flag: 'iq',
  text: 'Iraq'
}, {
  key: 'IE',
  value: 'IE',
  flag: 'ie',
  text: 'Ireland'
}, {
  key: 'IL',
  value: 'IL',
  flag: 'il',
  text: 'Israel'
}, {
  key: 'IT',
  value: 'IT',
  flag: 'it',
  text: 'Italy'
}, {
  key: 'JM',
  value: 'JM',
  flag: 'jm',
  text: 'Jamaica'
}, {
  key: 'JP',
  value: 'JP',
  flag: 'jp',
  text: 'Japan'
}, {
  key: 'JO',
  value: 'JO',
  flag: 'jo',
  text: 'Jordan'
}, {
  key: 'KZ',
  value: 'KZ',
  flag: 'kz',
  text: 'Kazakhstan'
}, {
  key: 'KE',
  value: 'KE',
  flag: 'ke',
  text: 'Kenya'
}, {
  key: 'KI',
  value: 'KI',
  flag: 'ki',
  text: 'Kiribati'
}, {
  key: 'KW',
  value: 'KW',
  flag: 'kw',
  text: 'Kuwait'
}, {
  key: 'KG',
  value: 'KG',
  flag: 'kg',
  text: 'Kyrgyzstan'
}, {
  key: 'LA',
  value: 'LA',
  flag: 'la',
  text: 'Laos'
}, {
  key: 'LV',
  value: 'LV',
  flag: 'lv',
  text: 'Latvia'
}, {
  key: 'LB',
  value: 'LB',
  flag: 'lb',
  text: 'Lebanon'
}, {
  key: 'LS',
  value: 'LS',
  flag: 'ls',
  text: 'Lesotho'
}, {
  key: 'LR',
  value: 'LR',
  flag: 'lr',
  text: 'Liberia'
}, {
  key: 'LY',
  value: 'LY',
  flag: 'ly',
  text: 'Libya'
}, {
  key: 'LI',
  value: 'LI',
  flag: 'li',
  text: 'Liechtenstein'
}, {
  key: 'LT',
  value: 'LT',
  flag: 'lt',
  text: 'Lithuania'
}, {
  key: 'LU',
  value: 'LU',
  flag: 'lu',
  text: 'Luxembourg'
}, {
  key: 'MO',
  value: 'MO',
  flag: 'mo',
  text: 'Macau'
}, {
  key: 'MK',
  value: 'MK',
  flag: 'mk',
  text: 'Macedonia'
}, {
  key: 'MG',
  value: 'MG',
  flag: 'mg',
  text: 'Madagascar'
}, {
  key: 'MW',
  value: 'MW',
  flag: 'mw',
  text: 'Malawi'
}, {
  key: 'MY',
  value: 'MY',
  flag: 'my',
  text: 'Malaysia'
}, {
  key: 'MV',
  value: 'MV',
  flag: 'mv',
  text: 'Maldives'
}, {
  key: 'ML',
  value: 'ML',
  flag: 'ml',
  text: 'Mali'
}, {
  key: 'MT',
  value: 'MT',
  flag: 'mt',
  text: 'Malta'
}, {
  key: 'MH',
  value: 'MH',
  flag: 'mh',
  text: 'Marshall Islands'
}, {
  key: 'MQ',
  value: 'MQ',
  flag: 'mq',
  text: 'Martinique'
}, {
  key: 'MR',
  value: 'MR',
  flag: 'mr',
  text: 'Mauritania'
}, {
  key: 'MU',
  value: 'MU',
  flag: 'mu',
  text: 'Mauritius'
}, {
  key: 'YT',
  value: 'YT',
  flag: 'yt',
  text: 'Mayotte'
}, {
  key: 'MX',
  value: 'MX',
  flag: 'mx',
  text: 'Mexico'
}, {
  key: 'FM',
  value: 'FM',
  flag: 'fm',
  text: 'Micronesia'
}, {
  key: 'MD',
  value: 'MD',
  flag: 'md',
  text: 'Moldova'
}, {
  key: 'MC',
  value: 'MC',
  flag: 'mc',
  text: 'Monaco'
}, {
  key: 'MN',
  value: 'MN',
  flag: 'mn',
  text: 'Mongolia'
}, {
  key: 'ME',
  value: 'ME',
  flag: 'me',
  text: 'Montenegro'
}, {
  key: 'MS',
  value: 'MS',
  flag: 'ms',
  text: 'Montserrat'
}, {
  key: 'MA',
  value: 'MA',
  flag: 'ma',
  text: 'Morocco'
}, {
  key: 'MZ',
  value: 'MZ',
  flag: 'mz',
  text: 'Mozambique'
}, {
  key: 'NA',
  value: 'NA',
  flag: 'na',
  text: 'Namibia'
}, {
  key: 'NR',
  value: 'NR',
  flag: 'nr',
  text: 'Nauru'
}, {
  key: 'NP',
  value: 'NP',
  flag: 'np',
  text: 'Nepal'
}, {
  key: 'AN',
  value: 'AN',
  flag: 'an',
  text: 'Netherlands Antilles'
}, {
  key: 'NL',
  value: 'NL',
  flag: 'nl',
  text: 'Netherlands'
}, {
  key: 'NC',
  value: 'NC',
  flag: 'nc',
  text: 'New Caledonia'
}, {
  key: 'PG',
  value: 'PG',
  flag: 'pg',
  text: 'New Guinea'
}, {
  key: 'NZ',
  value: 'NZ',
  flag: 'nz',
  text: 'New Zealand'
}, {
  key: 'NI',
  value: 'NI',
  flag: 'ni',
  text: 'Nicaragua'
}, {
  key: 'NE',
  value: 'NE',
  flag: 'ne',
  text: 'Niger'
}, {
  key: 'NG',
  value: 'NG',
  flag: 'ng',
  text: 'Nigeria'
}, {
  key: 'NU',
  value: 'NU',
  flag: 'nu',
  text: 'Niue'
}, {
  key: 'NF',
  value: 'NF',
  flag: 'nf',
  text: 'Norfolk Island'
}, {
  key: 'KP',
  value: 'KP',
  flag: 'kp',
  text: 'North Korea'
}, {
  key: 'MP',
  value: 'MP',
  flag: 'mp',
  text: 'Northern Mariana Islands'
}, {
  key: 'NO',
  value: 'NO',
  flag: 'no',
  text: 'Norway'
}, {
  key: 'OM',
  value: 'OM',
  flag: 'om',
  text: 'Oman'
}, {
  key: 'PK',
  value: 'PK',
  flag: 'pk',
  text: 'Pakistan'
}, {
  key: 'PW',
  value: 'PW',
  flag: 'pw',
  text: 'Palau'
}, {
  key: 'PS',
  value: 'PS',
  flag: 'ps',
  text: 'Palestine'
}, {
  key: 'PA',
  value: 'PA',
  flag: 'pa',
  text: 'Panama'
}, {
  key: 'PY',
  value: 'PY',
  flag: 'py',
  text: 'Paraguay'
}, {
  key: 'PE',
  value: 'PE',
  flag: 'pe',
  text: 'Peru'
}, {
  key: 'PH',
  value: 'PH',
  flag: 'ph',
  text: 'Philippines'
}, {
  key: 'PN',
  value: 'PN',
  flag: 'pn',
  text: 'Pitcairn Islands'
}, {
  key: 'PL',
  value: 'PL',
  flag: 'pl',
  text: 'Poland'
}, {
  key: 'PT',
  value: 'PT',
  flag: 'pt',
  text: 'Portugal'
}, {
  key: 'PR',
  value: 'PR',
  flag: 'pr',
  text: 'Puerto Rico'
}, {
  key: 'QA',
  value: 'QA',
  flag: 'qa',
  text: 'Qatar'
}, {
  key: 'RE',
  value: 'RE',
  flag: 're',
  text: 'Reunion'
}, {
  key: 'RO',
  value: 'RO',
  flag: 'ro',
  text: 'Romania'
}, {
  key: 'RU',
  value: 'RU',
  flag: 'ru',
  text: 'Russia'
}, {
  key: 'RW',
  value: 'RW',
  flag: 'rw',
  text: 'Rwanda'
}, {
  key: 'SH',
  value: 'SH',
  flag: 'sh',
  text: 'Saint Helena'
}, {
  key: 'KN',
  value: 'KN',
  flag: 'kn',
  text: 'Saint Kitts and Nevis'
}, {
  key: 'LC',
  value: 'LC',
  flag: 'lc',
  text: 'Saint Lucia'
}, {
  key: 'PM',
  value: 'PM',
  flag: 'pm',
  text: 'Saint Pierre'
}, {
  key: 'VC',
  value: 'VC',
  flag: 'vc',
  text: 'Saint Vincent'
}, {
  key: 'WS',
  value: 'WS',
  flag: 'ws',
  text: 'Samoa'
}, {
  key: 'SM',
  value: 'SM',
  flag: 'sm',
  text: 'San Marino'
}, {
  key: 'GS',
  value: 'GS',
  flag: 'gs',
  text: 'Sandwich Islands'
}, {
  key: 'ST',
  value: 'ST',
  flag: 'st',
  text: 'Sao Tome'
}, {
  key: 'SA',
  value: 'SA',
  flag: 'sa',
  text: 'Saudi Arabia'
}, {
  key: 'SN',
  value: 'SN',
  flag: 'sn',
  text: 'Senegal'
}, {
  key: 'CS',
  value: 'CS',
  flag: 'cs',
  text: 'Serbia'
}, {
  key: 'RS',
  value: 'RS',
  flag: 'rs',
  text: 'Serbia'
}, {
  key: 'SC',
  value: 'SC',
  flag: 'sc',
  text: 'Seychelles'
}, {
  key: 'SL',
  value: 'SL',
  flag: 'sl',
  text: 'Sierra Leone'
}, {
  key: 'SG',
  value: 'SG',
  flag: 'sg',
  text: 'Singapore'
}, {
  key: 'SK',
  value: 'SK',
  flag: 'sk',
  text: 'Slovakia'
}, {
  key: 'SI',
  value: 'SI',
  flag: 'si',
  text: 'Slovenia'
}, {
  key: 'SB',
  value: 'SB',
  flag: 'sb',
  text: 'Solomon Islands'
}, {
  key: 'SO',
  value: 'SO',
  flag: 'so',
  text: 'Somalia'
}, {
  key: 'ZA',
  value: 'ZA',
  flag: 'za',
  text: 'South Africa'
}, {
  key: 'KR',
  value: 'KR',
  flag: 'kr',
  text: 'South Korea'
}, {
  key: 'ES',
  value: 'ES',
  flag: 'es',
  text: 'Spain'
}, {
  key: 'LK',
  value: 'LK',
  flag: 'lk',
  text: 'Sri Lanka'
}, {
  key: 'SD',
  value: 'SD',
  flag: 'sd',
  text: 'Sudan'
}, {
  key: 'SR',
  value: 'SR',
  flag: 'sr',
  text: 'Suriname'
}, {
  key: 'SJ',
  value: 'SJ',
  flag: 'sj',
  text: 'Svalbard'
}, {
  key: 'SZ',
  value: 'SZ',
  flag: 'sz',
  text: 'Swaziland'
}, {
  key: 'SE',
  value: 'SE',
  flag: 'se',
  text: 'Sweden'
}, {
  key: 'CH',
  value: 'CH',
  flag: 'ch',
  text: 'Switzerland'
}, {
  key: 'SY',
  value: 'SY',
  flag: 'sy',
  text: 'Syria'
}, {
  key: 'TW',
  value: 'TW',
  flag: 'tw',
  text: 'Taiwan'
}, {
  key: 'TJ',
  value: 'TJ',
  flag: 'tj',
  text: 'Tajikistan'
}, {
  key: 'TZ',
  value: 'TZ',
  flag: 'tz',
  text: 'Tanzania'
}, {
  key: 'TH',
  value: 'TH',
  flag: 'th',
  text: 'Thailand'
}, {
  key: 'TL',
  value: 'TL',
  flag: 'tl',
  text: 'Timorleste'
}, {
  key: 'TG',
  value: 'TG',
  flag: 'tg',
  text: 'Togo'
}, {
  key: 'TK',
  value: 'TK',
  flag: 'tk',
  text: 'Tokelau'
}, {
  key: 'TO',
  value: 'TO',
  flag: 'to',
  text: 'Tonga'
}, {
  key: 'TT',
  value: 'TT',
  flag: 'tt',
  text: 'Trinidad'
}, {
  key: 'TN',
  value: 'TN',
  flag: 'tn',
  text: 'Tunisia'
}, {
  key: 'TR',
  value: 'TR',
  flag: 'tr',
  text: 'Turkey'
}, {
  key: 'TM',
  value: 'TM',
  flag: 'tm',
  text: 'Turkmenistan'
}, {
  key: 'TV',
  value: 'TV',
  flag: 'tv',
  text: 'Tuvalu'
}, {
  key: 'UG',
  value: 'UG',
  flag: 'ug',
  text: 'Uganda'
}, {
  key: 'UA',
  value: 'UA',
  flag: 'ua',
  text: 'Ukraine'
}, {
  key: 'AE',
  value: 'AE',
  flag: 'ae',
  text: 'United Arab Emirates'
}, {
  key: 'US',
  value: 'US',
  flag: 'us',
  text: 'United States'
}, {
  key: 'UY',
  value: 'UY',
  flag: 'uy',
  text: 'Uruguay'
}, {
  key: 'UM',
  value: 'UM',
  flag: 'um',
  text: 'Us Minor Islands'
}, {
  key: 'VI',
  value: 'VI',
  flag: 'vi',
  text: 'Us Virgin Islands'
}, {
  key: 'UZ',
  value: 'UZ',
  flag: 'uz',
  text: 'Uzbekistan'
}, {
  key: 'VU',
  value: 'VU',
  flag: 'vu',
  text: 'Vanuatu'
}, {
  key: 'VA',
  value: 'VA',
  flag: 'va',
  text: 'Vatican City'
}, {
  key: 'VE',
  value: 'VE',
  flag: 've',
  text: 'Venezuela'
}, {
  key: 'VN',
  value: 'VN',
  flag: 'vn',
  text: 'Vietnam'
}, {
  key: 'WF',
  value: 'WF',
  flag: 'wf',
  text: 'Wallis and Futuna'
}, {
  key: 'EH',
  value: 'EH',
  flag: 'eh',
  text: 'Western Sahara'
}, {
  key: 'YE',
  value: 'YE',
  flag: 'ye',
  text: 'Yemen'
}, {
  key: 'ZM',
  value: 'ZM',
  flag: 'zm',
  text: 'Zambia'
}, {
  key: 'ZW',
  value: 'ZW',
  flag: 'zw',
  text: 'Zimbabwe'
}];

function fetchKycCountries(_x) {
  return _fetchKycCountries.apply(this, arguments);
}
/**
 * FAILED
 * UNSUBMITTED
 * PENDING
 * PASSED
 */

function _fetchKycCountries() {
  _fetchKycCountries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var chain, url, _yield$this$get, countries, countriesById;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            chain = _ref.chain;
            url = this.constants.BLOKS_API + "/" + chain + "/kyc?type=countries&chain=" + chain;
            _context.next = 4;
            return this.get(url);

          case 4:
            _yield$this$get = _context.sent;
            countries = _yield$this$get.content;
            countriesById = countries.reduce(function (acc, country) {
              acc[country.id] = country;
              return acc;
            }, {});
            return _context.abrupt("return", countryOptions.filter(function (countryOption) {
              return countriesById[countryOption.key];
            }));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _fetchKycCountries.apply(this, arguments);
}

function checkUserKycStatus(_x2) {
  return _checkUserKycStatus.apply(this, arguments);
}

function _checkUserKycStatus() {
  _checkUserKycStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref2) {
    var _this = this;

    var chain, actor, expectedTier;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            chain = _ref2.chain, actor = _ref2.actor, expectedTier = _ref2.expectedTier;

            if (!(!chain || !actor || !expectedTier)) {
              _context4.next = 3;
              break;
            }

            throw new Error('Invalid parameters');

          case 3:
            return _context4.abrupt("return", new Promise( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject) {
                var getStatus;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        // Get all KYC records for user
                        getStatus = /*#__PURE__*/function () {
                          var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                            var _yield$_this$rpc$isLi, userInfo, url, kyc, matchedTier, status;

                            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                              while (1) {
                                switch (_context2.prev = _context2.next) {
                                  case 0:
                                    _context2.next = 2;
                                    return _this.rpc.isLightKYCVerified(actor);

                                  case 2:
                                    _yield$_this$rpc$isLi = _context2.sent;
                                    userInfo = _yield$_this$rpc$isLi[0];

                                    if (!(userInfo && userInfo.isLightKYCVerified)) {
                                      _context2.next = 6;
                                      break;
                                    }

                                    return _context2.abrupt("return", resolve(KycStatus.PASSED));

                                  case 6:
                                    url = _this.constants.BLOKS_API + "/" + chain + "/kyc?type=status&chain=" + chain + "&actor=" + actor;
                                    _context2.next = 9;
                                    return _this.get(url);

                                  case 9:
                                    kyc = _context2.sent;

                                    if (!(!kyc || !kyc.length)) {
                                      _context2.next = 12;
                                      break;
                                    }

                                    return _context2.abrupt("return", reject(new Error('Could not fetch KYC record')));

                                  case 12:
                                    // Find relevant KYC record
                                    matchedTier = kyc.find(function (_ref5) {
                                      var tier = _ref5.tier;
                                      return tier === String(expectedTier);
                                    });

                                    if (matchedTier) {
                                      _context2.next = 15;
                                      break;
                                    }

                                    return _context2.abrupt("return", reject(new Error('No kyc data matching tier found')));

                                  case 15:
                                    // Unwrap kyc data
                                    status = matchedTier.status;

                                    if (matchedTier.status) {
                                      _context2.next = 18;
                                      break;
                                    }

                                    return _context2.abrupt("return", reject(new Error('KYC Status not found')));

                                  case 18:
                                    if (!(status === KycStatus.PENDING)) {
                                      _context2.next = 22;
                                      break;
                                    }

                                    setTimeout(function () {
                                      return getStatus();
                                    }, 1000 * 2);
                                    _context2.next = 23;
                                    break;

                                  case 22:
                                    return _context2.abrupt("return", resolve(status));

                                  case 23:
                                  case "end":
                                    return _context2.stop();
                                }
                              }
                            }, _callee2);
                          }));

                          return function getStatus() {
                            return _ref4.apply(this, arguments);
                          };
                        }();

                        getStatus();

                      case 2:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x4, _x5) {
                return _ref3.apply(this, arguments);
              };
            }()));

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _checkUserKycStatus.apply(this, arguments);
}

function applyForKyc(_x3) {
  return _applyForKyc.apply(this, arguments);
}

function _applyForKyc() {
  _applyForKyc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(params) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            url = this.constants.BLOKS_API + "/" + params.chain + "/kyc";
            _context5.next = 3;
            return this.post(url, _extends({
              type: 'apply'
            }, params));

          case 3:
            data = _context5.sent;

            if (!data) {
              _context5.next = 8;
              break;
            }

            return _context5.abrupt("return", data);

          case 8:
            throw new Error('Could not apply for KYC');

          case 9:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _applyForKyc.apply(this, arguments);
}

var chainInfoParser = /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.object({
  chainId: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  explorerUrl: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  explorerName: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  resourceTokenSymbol: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  resourceTokenContract: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  systemTokenSymbol: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  systemTokenContract: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  rpcEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string()),
  actionsRpcEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string()),
  hyperionEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string()),
  lightEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string())
});

function getChainInfo() {
  return _getChainInfo.apply(this, arguments);
}

function _getChainInfo() {
  _getChainInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = this.constants.CHAIN === 'proton-test' ? 'https://raw.githubusercontent.com/ProtonProtocol/chain-info/main/testnet.json' : 'https://raw.githubusercontent.com/ProtonProtocol/chain-info/main/mainnet.json';
            _context.prev = 1;
            _context.next = 4;
            return this.get(url, {});

          case 4:
            data = _context.sent;
            return _context.abrupt("return", chainInfoParser.parse(data));

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 8]]);
  }));
  return _getChainInfo.apply(this, arguments);
}

function getTokenPrices() {
  return _getTokenPrices.apply(this, arguments);
}

function _getTokenPrices() {
  _getTokenPrices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v1/chain/exchange-rates/info";
            _context2.prev = 1;
            _context2.next = 4;
            return this.get(url);

          case 4:
            data = _context2.sent;
            return _context2.abrupt("return", _proton_wrap_constants__WEBPACK_IMPORTED_MODULE_7__.exchangeRatesParser.parse(data));

          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](1);
            throw new Error("Could not fetch exchange rates");

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[1, 8]]);
  }));
  return _getTokenPrices.apply(this, arguments);
}

function getWithdrawalFee(_x) {
  return _getWithdrawalFee.apply(this, arguments);
}

function _getWithdrawalFee() {
  _getWithdrawalFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref) {
    var currency, network, url, data;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            currency = _ref.currency, network = _ref.network;
            url = this.constants.METAL_PROTON_ENDPOINT + "/v1/swaps/calculate-estimated-fee";
            _context3.prev = 2;
            _context3.next = 5;
            return this.post(url, {
              currency: currency,
              network: network
            });

          case 5:
            data = _context3.sent;
            return _context3.abrupt("return", _proton_wrap_constants__WEBPACK_IMPORTED_MODULE_7__.withdrawalFeeQuoteParser.parse(data));

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            console.log(_context3.t0);
            return _context3.abrupt("return", undefined);

          case 13:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[2, 9]]);
  }));
  return _getWithdrawalFee.apply(this, arguments);
}

function currentLocation() {
  return _currentLocation.apply(this, arguments);
}

function _currentLocation() {
  _currentLocation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    var url;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v1/kyc/ip-info";
            _context4.next = 3;
            return this.get(url);

          case 3:
            return _context4.abrupt("return", _context4.sent);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _currentLocation.apply(this, arguments);
}

function getAvailableFeatures(_x2) {
  return _getAvailableFeatures.apply(this, arguments);
}

function _getAvailableFeatures() {
  _getAvailableFeatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var url;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + ("/v2/kyc/by-chain-account/" + account + "/available-features");
            _context5.next = 3;
            return this.get(url);

          case 3:
            return _context5.abrupt("return", _context5.sent);

          case 4:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _getAvailableFeatures.apply(this, arguments);
}

function createAccount(_x3) {
  return _createAccount.apply(this, arguments);
}

function _createAccount() {
  _createAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v2/users/create";
            _context6.next = 3;
            return this.post(url, params);

          case 3:
            data = _context6.sent;
            return _context6.abrupt("return", data);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _createAccount.apply(this, arguments);
}

function loginAccount(_x4) {
  return _loginAccount.apply(this, arguments);
}

function _loginAccount() {
  _loginAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(params) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v2/users/login";
            _context7.next = 3;
            return this.post(url, params);

          case 3:
            data = _context7.sent;
            return _context7.abrupt("return", data);

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _loginAccount.apply(this, arguments);
}

function otcQuote(_x) {
  return _otcQuote.apply(this, arguments);
}

function _otcQuote() {
  _otcQuote = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = this.constants.SWAP_URL + ("/v1/quote/" + body.baseSymbol + "/" + body.baseAmount + "/" + body.quoteSymbol);
            _context.next = 3;
            return this.get(url);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _otcQuote.apply(this, arguments);
}

function otcOrder(_x2) {
  return _otcOrder.apply(this, arguments);
}

function _otcOrder() {
  _otcOrder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id) {
    var url;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = this.constants.SWAP_URL + ("/v1/order/" + id);
            _context2.next = 3;
            return this.get(url);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _otcOrder.apply(this, arguments);
}

function generateAddress(_x) {
  return _generateAddress.apply(this, arguments);
}

function _generateAddress() {
  _generateAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + '/address/generate';
            _context.next = 3;
            return this.post(url, body);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _generateAddress.apply(this, arguments);
}

function deleteAddress(_x2) {
  return _deleteAddress.apply(this, arguments);
}

function _deleteAddress() {
  _deleteAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + '/address/delete';
            _context2.next = 3;
            return this.post(url, body);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _deleteAddress.apply(this, arguments);
}

function withdrawMetal(_x3) {
  return _withdrawMetal.apply(this, arguments);
}

function _withdrawMetal() {
  _withdrawMetal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + '/withdraw';
            _context3.next = 3;
            return this.post(url, body);

          case 3:
            return _context3.abrupt("return", _context3.sent);

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _withdrawMetal.apply(this, arguments);
}

function withdrawalHistoryMetal(_x4) {
  return _withdrawalHistoryMetal.apply(this, arguments);
}

function _withdrawalHistoryMetal() {
  _withdrawalHistoryMetal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var url;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + ("/withdrawals/" + account);
            _context4.next = 3;
            return this.get(url);

          case 3:
            return _context4.abrupt("return", _context4.sent);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _withdrawalHistoryMetal.apply(this, arguments);
}

function getXprTotalStakedAndApr() {
  return _getXprTotalStakedAndApr.apply(this, arguments);
}

function _getXprTotalStakedAndApr() {
  _getXprTotalStakedAndApr = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$Promise$all, supply, totalStakedUnparsed, _yield$Promise$all$, continuous_rate, inflation_pay_factor, votepay_factor, additionalInflation, new_tokens, to_yieldfarms, bpandsavings, to_producers, to_producers_block, to_producers_vote, savings, to_savings, to_consortium, totalStaked, apr;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return Promise.all([this.getTokenSupply(this.constants.EOSIO_TOKEN, this.constants.CORE_SYMBOL), this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'globalsd',
              limit: 1
            }).then(function (res) {
              return res.rows[0];
            }), this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'global4',
              limit: 1
            }).then(function (res) {
              return res.rows[0];
            })]);

          case 3:
            _yield$Promise$all = _context.sent;
            supply = _yield$Promise$all[0].supply;
            totalStakedUnparsed = _yield$Promise$all[1].totalrstaked;
            _yield$Promise$all$ = _yield$Promise$all[2];
            continuous_rate = _yield$Promise$all$.continuous_rate;
            inflation_pay_factor = _yield$Promise$all$.inflation_pay_factor;
            votepay_factor = _yield$Promise$all$.votepay_factor;
            additionalInflation = +continuous_rate * supply;
            new_tokens = additionalInflation;
            to_yieldfarms = new_tokens / 4;
            bpandsavings = new_tokens - to_yieldfarms;
            to_producers = bpandsavings * (10000 / inflation_pay_factor);
            to_producers_block = to_producers * (10000 / votepay_factor);
            to_producers_vote = to_producers - to_producers_block;
            savings = bpandsavings - to_producers;
            to_savings = 2 * savings / 3;
            to_consortium = savings - to_savings;
            totalStaked = +totalStakedUnparsed / Math.pow(10, this.constants.CORE_PRECISION);
            apr = to_savings / totalStaked * 100;
            return _context.abrupt("return", {
              supply: supply,
              yieldFarming: to_yieldfarms,
              producers: to_producers,
              producersBlock: to_producers_block,
              producersVote: to_producers_vote,
              consortium: to_consortium,
              staking: to_savings,
              totalStaked: totalStaked,
              apr: apr
            });

          case 25:
            _context.prev = 25;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", 0);

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 25]]);
  }));
  return _getXprTotalStakedAndApr.apply(this, arguments);
}

function getXprVoter(_x) {
  return _getXprVoter.apply(this, arguments);
}

function _getXprVoter() {
  _getXprVoter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'votersxpr',
              limit: 1
            });

          case 3:
            _yield$this$rpc$get_t = _context2.sent;
            rows = _yield$this$rpc$get_t.rows;

            if (!(rows && rows.length && rows[0].owner === account)) {
              _context2.next = 9;
              break;
            }

            return _context2.abrupt("return", rows[0]);

          case 9:
            return _context2.abrupt("return", undefined);

          case 10:
            _context2.next = 16;
            break;

          case 12:
            _context2.prev = 12;
            _context2.t0 = _context2["catch"](0);
            console.log(_context2.t0);
            return _context2.abrupt("return", undefined);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 12]]);
  }));
  return _getXprVoter.apply(this, arguments);
}

function getXprAccountStakes(_x2) {
  return _getXprAccountStakes.apply(this, arguments);
}

function _getXprAccountStakes() {
  _getXprAccountStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var stakes, _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            stakes = [];
            _context3.prev = 1;
            _context3.next = 4;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'delxpr',
              limit: -1
            });

          case 4:
            _yield$this$rpc$get_t2 = _context3.sent;
            rows = _yield$this$rpc$get_t2.rows;

            if (rows && rows.length) {
              stakes = rows;
            }

            _context3.next = 12;
            break;

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](1);
            console.log(_context3.t0);

          case 12:
            return _context3.abrupt("return", stakes);

          case 13:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[1, 9]]);
  }));
  return _getXprAccountStakes.apply(this, arguments);
}

function getXprAccountRefund(_x3) {
  return _getXprAccountRefund.apply(this, arguments);
}

function _getXprAccountRefund() {
  _getXprAccountRefund = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var refund, _yield$this$rpc$get_t3, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'refundsxpr',
              limit: -1
            });

          case 3:
            _yield$this$rpc$get_t3 = _context4.sent;
            rows = _yield$this$rpc$get_t3.rows;

            if (rows && rows.length) {
              refund = rows[0];
              refund.quantity = +refund.quantity.split(' ')[0];
            }

            _context4.next = 11;
            break;

          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](0);
            console.log(_context4.t0);

          case 11:
            return _context4.abrupt("return", refund);

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 8]]);
  }));
  return _getXprAccountRefund.apply(this, arguments);
}

function getXprOracleData(_x4) {
  return _getXprOracleData.apply(this, arguments);
}

function _getXprOracleData() {
  _getXprOracleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(oracleIndex) {
    var _yield$this$rpc$get_t4, rows;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'data',
              limit: 1,
              lower_bound: oracleIndex,
              upper_bound: oracleIndex
            });

          case 3:
            _yield$this$rpc$get_t4 = _context5.sent;
            rows = _yield$this$rpc$get_t4.rows;

            if (!(rows && rows.length)) {
              _context5.next = 9;
              break;
            }

            return _context5.abrupt("return", rows[0]);

          case 9:
            return _context5.abrupt("return", undefined);

          case 10:
            _context5.next = 16;
            break;

          case 12:
            _context5.prev = 12;
            _context5.t0 = _context5["catch"](0);
            console.log(_context5.t0);
            return _context5.abrupt("return", undefined);

          case 16:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 12]]);
  }));
  return _getXprOracleData.apply(this, arguments);
}

function getAllOracleFeeds(_x5) {
  return _getAllOracleFeeds.apply(this, arguments);
}

function _getAllOracleFeeds() {
  _getAllOracleFeeds = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(lower_bound) {
    var _yield$this$rpc$get_t5, rows, more, next_key, restOfRows;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (lower_bound === void 0) {
              lower_bound = undefined;
            }

            _context6.prev = 1;
            _context6.next = 4;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'feeds',
              limit: -1,
              lower_bound: lower_bound
            });

          case 4:
            _yield$this$rpc$get_t5 = _context6.sent;
            rows = _yield$this$rpc$get_t5.rows;
            more = _yield$this$rpc$get_t5.more;
            next_key = _yield$this$rpc$get_t5.next_key;

            if (!more) {
              _context6.next = 15;
              break;
            }

            _context6.next = 11;
            return this.getAllOracleFeeds(next_key);

          case 11:
            restOfRows = _context6.sent;
            return _context6.abrupt("return", rows.concat(restOfRows));

          case 15:
            return _context6.abrupt("return", rows);

          case 16:
            _context6.next = 22;
            break;

          case 18:
            _context6.prev = 18;
            _context6.t0 = _context6["catch"](1);
            console.log(_context6.t0);
            return _context6.abrupt("return", []);

          case 22:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[1, 18]]);
  }));
  return _getAllOracleFeeds.apply(this, arguments);
}

function getSpecificOracleData(_x6) {
  return _getSpecificOracleData.apply(this, arguments);
} // pub

function _getSpecificOracleData() {
  _getSpecificOracleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(feed_index) {
    var _yield$this$rpc$get_t6, rows;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'data',
              limit: -1,
              lower_bound: feed_index,
              upper_bound: feed_index
            });

          case 3:
            _yield$this$rpc$get_t6 = _context7.sent;
            rows = _yield$this$rpc$get_t6.rows;

            if (!(rows && rows.length && rows[0].feed_index === feed_index)) {
              _context7.next = 7;
              break;
            }

            return _context7.abrupt("return", rows[0]);

          case 7:
            _context7.next = 12;
            break;

          case 9:
            _context7.prev = 9;
            _context7.t0 = _context7["catch"](0);
            console.log(_context7.t0);

          case 12:
            return _context7.abrupt("return", undefined);

          case 13:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 9]]);
  }));
  return _getSpecificOracleData.apply(this, arguments);
}

function getAllOracleData(_x7) {
  return _getAllOracleData.apply(this, arguments);
}

function _getAllOracleData() {
  _getAllOracleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(lower_bound) {
    var _yield$this$rpc$get_t7, rows, more, next_key;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'data',
              limit: -1,
              lower_bound: lower_bound
            });

          case 3:
            _yield$this$rpc$get_t7 = _context8.sent;
            rows = _yield$this$rpc$get_t7.rows;
            more = _yield$this$rpc$get_t7.more;
            next_key = _yield$this$rpc$get_t7.next_key;

            if (!more) {
              _context8.next = 13;
              break;
            }

            _context8.t0 = rows;
            _context8.next = 11;
            return this.getAllOracleData(next_key);

          case 11:
            _context8.t1 = _context8.sent;
            rows = _context8.t0.concat.call(_context8.t0, _context8.t1);

          case 13:
            return _context8.abrupt("return", rows);

          case 16:
            _context8.prev = 16;
            _context8.t2 = _context8["catch"](0);
            console.log(_context8.t2);
            return _context8.abrupt("return", []);

          case 20:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[0, 16]]);
  }));
  return _getAllOracleData.apply(this, arguments);
}

function getProtonAvatars(_x8, _x9) {
  return _getProtonAvatars.apply(this, arguments);
}

function _getProtonAvatars() {
  _getProtonAvatars = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(account, limit) {
    var result;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (limit === void 0) {
              limit = 10;
            }

            if (!(this.constants.CHAIN.indexOf('proton') !== -1)) {
              _context9.next = 12;
              break;
            }

            _context9.prev = 2;
            _context9.next = 5;
            return this.rpc.get_table_rows({
              json: true,
              code: 'eosio.proton',
              scope: 'eosio.proton',
              table: 'usersinfo',
              table_key: '',
              key_type: 'i64',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 1,
              limit: limit
            });

          case 5:
            result = _context9.sent;
            return _context9.abrupt("return", result.rows);

          case 9:
            _context9.prev = 9;
            _context9.t0 = _context9["catch"](2);
            console.log('getProtonAvatar error', _context9.t0);

          case 12:
            return _context9.abrupt("return", []);

          case 13:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this, [[2, 9]]);
  }));
  return _getProtonAvatars.apply(this, arguments);
}

function getProtonAvatar(_x10) {
  return _getProtonAvatar.apply(this, arguments);
}

function _getProtonAvatar() {
  _getProtonAvatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            if (!(this.constants.CHAIN.indexOf('proton') !== -1)) {
              _context10.next = 11;
              break;
            }

            _context10.prev = 1;
            _context10.next = 4;
            return this.rpc.get_table_rows({
              json: true,
              code: 'eosio.proton',
              scope: 'eosio.proton',
              table: 'usersinfo',
              table_key: '',
              key_type: 'i64',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 1,
              limit: 1
            });

          case 4:
            result = _context10.sent;
            return _context10.abrupt("return", result.rows.length > 0 && result.rows[0].acc === account ? result.rows[0] : undefined);

          case 8:
            _context10.prev = 8;
            _context10.t0 = _context10["catch"](1);
            console.log('getProtonAvatar error', _context10.t0);

          case 11:
            return _context10.abrupt("return", undefined);

          case 12:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, this, [[1, 8]]);
  }));
  return _getProtonAvatar.apply(this, arguments);
}

function getRentbwState() {
  return _getRentbwState.apply(this, arguments);
}

function _getRentbwState() {
  _getRentbwState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: 0,
              table: 'powup.state',
              limit: 1
            });

          case 2:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context.abrupt("return", rows[0]);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getRentbwState.apply(this, arguments);
}

function delegatedBandwidth(_x, _x2) {
  return _delegatedBandwidth.apply(this, arguments);
}

function _delegatedBandwidth() {
  _delegatedBandwidth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account, lower_bound) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'delband',
              table_key: '',
              limit: -1,
              lower_bound: lower_bound,
              key_type: 'i64',
              index_position: 1
            }));

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _delegatedBandwidth.apply(this, arguments);
}

function getAccountDelegatedBandwidth(_x3) {
  return _getAccountDelegatedBandwidth.apply(this, arguments);
}

function _getAccountDelegatedBandwidth() {
  _getAccountDelegatedBandwidth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var more, rows, result, lower_bound;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            more = true;
            rows = [];
            result = null;
            lower_bound = '';
            _context3.prev = 4;

          case 5:
            _context3.next = 7;
            return this.delegatedBandwidth(account, lower_bound);

          case 7:
            result = _context3.sent;
            more = result.more;
            rows = rows.concat(result.rows);

            if (more) {
              lower_bound = new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(rows[rows.length - 1].to, false)).plus(1).toString();
            }

          case 11:
            if (more) {
              _context3.next = 5;
              break;
            }

          case 12:
            _context3.next = 17;
            break;

          case 14:
            _context3.prev = 14;
            _context3.t0 = _context3["catch"](4);
            console.log(_context3.t0);

          case 17:
            return _context3.abrupt("return", rows);

          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[4, 14]]);
  }));
  return _getAccountDelegatedBandwidth.apply(this, arguments);
}

function getAccountResources(_x4) {
  return _getAccountResources.apply(this, arguments);
}

function _getAccountResources() {
  _getAccountResources = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'userres',
              table_key: '',
              limit: 1
            });

          case 2:
            _yield$this$rpc$get_t2 = _context4.sent;
            rows = _yield$this$rpc$get_t2.rows;
            return _context4.abrupt("return", rows[0]);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getAccountResources.apply(this, arguments);
}

function getRamPriceInEos() {
  return _getRamPriceInEos.apply(this, arguments);
}

function _getRamPriceInEos() {
  _getRamPriceInEos = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var ram, baseString, base, quoteString, quote, price, ramPriceEos;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rammarket',
              table_key: '',
              limit: 10
            });

          case 3:
            ram = _context5.sent;
            // Amount of RAM bytes in use
            baseString = ram.rows[0].base.balance;
            base = +baseString.substr(0, baseString.indexOf(' ')); // Amount of EOS in the RAM collector

            quoteString = ram.rows[0].quote.balance;
            quote = quoteString.substr(0, quoteString.indexOf(' ')); // Price in kb

            price = quote / base;
            ramPriceEos = Number(price.toFixed(8)) * 1024;
            return _context5.abrupt("return", ramPriceEos);

          case 13:
            _context5.prev = 13;
            _context5.t0 = _context5["catch"](0);
            console.log(_context5.t0);

          case 16:
            return _context5.abrupt("return", 0);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 13]]);
  }));
  return _getRamPriceInEos.apply(this, arguments);
}

function getEosTopStakes(_x) {
  return _getEosTopStakes.apply(this, arguments);
}

function _getEosTopStakes() {
  _getEosTopStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(limit) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (limit === void 0) {
              limit = 500;
            }

            return _context.abrupt("return", this.lightApi.get_topstake(limit));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getEosTopStakes.apply(this, arguments);
}

function getEosTopRams(_x2) {
  return _getEosTopRams.apply(this, arguments);
}

function _getEosTopRams() {
  _getEosTopRams = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(limit) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (limit === void 0) {
              limit = 500;
            }

            return _context2.abrupt("return", this.lightApi.get_topram(limit));

          case 2:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getEosTopRams.apply(this, arguments);
}

function getCurrentNameBids(_x3, _x4) {
  return _getCurrentNameBids.apply(this, arguments);
}

function _getCurrentNameBids() {
  _getCurrentNameBids = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(lower_bound, upper_bound) {
    var _yield$this$rpc$get_t, rows, more, next_key;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (lower_bound === void 0) {
              lower_bound = '';
            }

            if (upper_bound === void 0) {
              upper_bound = '';
            }

            _context3.next = 4;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'namebids',
              key_type: 'i64',
              lower_bound: lower_bound && lower_bound.length <= 12 ? (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(lower_bound, true) : lower_bound,
              upper_bound: upper_bound && upper_bound.length <= 12 ? (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(upper_bound, true) : upper_bound,
              index_position: 1,
              limit: -1
            });

          case 4:
            _yield$this$rpc$get_t = _context3.sent;
            rows = _yield$this$rpc$get_t.rows;
            more = _yield$this$rpc$get_t.more;
            next_key = _yield$this$rpc$get_t.next_key;

            if (!more) {
              _context3.next = 14;
              break;
            }

            _context3.t0 = rows;
            _context3.next = 12;
            return this.getCurrentNameBids(next_key, upper_bound);

          case 12:
            _context3.t1 = _context3.sent;
            rows = _context3.t0.concat.call(_context3.t0, _context3.t1);

          case 14:
            return _context3.abrupt("return", rows);

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getCurrentNameBids.apply(this, arguments);
}

var chainToRexMap = {
  jungle: 'jungle',
  bos: 'bos',
  eos: 'mainnet',
  telos: 'telos'
};
function getRexQueued(_x) {
  return _getRexQueued.apply(this, arguments);
}

function _getRexQueued() {
  _getRexQueued = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexqueue',
              limit: 1,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)
            });

          case 3:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;

            if (!(rows && rows.length && rows[0].owner === account)) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return", rows[0]);

          case 7:
            _context.next = 12;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);

          case 12:
            return _context.abrupt("return", undefined);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 9]]);
  }));
  return _getRexQueued.apply(this, arguments);
}

function getRexPool() {
  return _getRexPool.apply(this, arguments);
}

function _getRexPool() {
  _getRexPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var _yield$this$rpc$get_t2, rows, pool, assetToNumber, total_lent, total_lendable, total_unlent, total_rex, total_rent, lent_percent, rex_price, resource_price;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexpool'
            });

          case 2:
            _yield$this$rpc$get_t2 = _context2.sent;
            rows = _yield$this$rpc$get_t2.rows;
            pool = rows[0];

            assetToNumber = function assetToNumber(asset) {
              return Number(asset.split(' ')[0]);
            };

            total_lent = assetToNumber(pool.total_lent);
            total_lendable = assetToNumber(pool.total_lendable);
            total_unlent = assetToNumber(pool.total_unlent);
            total_rex = assetToNumber(pool.total_rex);
            total_rent = assetToNumber(pool.total_rent);
            lent_percent = (0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.multiply)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.divide)(total_lent, total_lendable), 100);
            rex_price = +(0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.divide)(total_lendable, total_rex);
            resource_price = +(0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.divide)(total_unlent, total_rent + 1);
            return _context2.abrupt("return", {
              version: pool.version,
              namebid_proceeds: assetToNumber(pool.namebid_proceeds),
              loan_num: pool.loan_num,
              total_lent: total_lent,
              total_unlent: total_unlent,
              total_rent: total_rent,
              total_lendable: total_lendable,
              total_rex: total_rex,
              lent_percent: lent_percent,
              rex_price: rex_price,
              resource_price: resource_price
            });

          case 15:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getRexPool.apply(this, arguments);
}

function getRexBalance(_x2) {
  return _getRexBalance.apply(this, arguments);
}

function _getRexBalance() {
  _getRexBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var _yield$this$rpc$get_t3, rows, bal;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexbal',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)
            });

          case 2:
            _yield$this$rpc$get_t3 = _context3.sent;
            rows = _yield$this$rpc$get_t3.rows;
            bal = rows[0];
            return _context3.abrupt("return", bal.owner === account ? bal : undefined);

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getRexBalance.apply(this, arguments);
}

function getRexCpuLoans(_x3) {
  return _getRexCpuLoans.apply(this, arguments);
}

function _getRexCpuLoans() {
  _getRexCpuLoans = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var _yield$this$rpc$get_t4, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'cpuloan',
              table_key: 'byowner',
              key_type: 'i64',
              limit: 100,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 3
            });

          case 2:
            _yield$this$rpc$get_t4 = _context4.sent;
            rows = _yield$this$rpc$get_t4.rows;
            return _context4.abrupt("return", rows.filter(function (row) {
              return row.from === account;
            }));

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getRexCpuLoans.apply(this, arguments);
}

function getRexNetLoans(_x4) {
  return _getRexNetLoans.apply(this, arguments);
}

function _getRexNetLoans() {
  _getRexNetLoans = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var _yield$this$rpc$get_t5, rows;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'netloan',
              table_key: 'byowner',
              key_type: 'i64',
              limit: 100,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 3
            });

          case 2:
            _yield$this$rpc$get_t5 = _context5.sent;
            rows = _yield$this$rpc$get_t5.rows;
            return _context5.abrupt("return", rows.filter(function (row) {
              return row.from === account;
            }));

          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _getRexNetLoans.apply(this, arguments);
}

function getEosDepositedIntoRex(_x5) {
  return _getEosDepositedIntoRex.apply(this, arguments);
}

function _getEosDepositedIntoRex() {
  _getEosDepositedIntoRex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(account) {
    var _yield$this$rpc$get_t6, rows, row;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexfund',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)
            });

          case 2:
            _yield$this$rpc$get_t6 = _context6.sent;
            rows = _yield$this$rpc$get_t6.rows;
            row = rows[0];
            return _context6.abrupt("return", row.owner === account ? Number(row.balance.split(' ')[0]) : 0);

          case 6:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _getEosDepositedIntoRex.apply(this, arguments);
}

function getRexReturnRate(_x6) {
  return _getRexReturnRate.apply(this, arguments);
}

function _getRexReturnRate() {
  _getRexReturnRate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(type) {
    var chain, _yield$this$post, data;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (type === void 0) {
              type = 'mpr';
            }

            chain = chainToRexMap[this.constants.CHAIN];

            if (!chain) {
              _context7.next = 14;
              break;
            }

            _context7.next = 5;
            return this.post('https://www.api.bloks.io/graphql/v1alpha1/graphql', {
              query: "query {\n        " + chain + "_" + type + " {\n          " + type + "\n        }\n      }",
              variables: null
            });

          case 5:
            _yield$this$post = _context7.sent;
            data = _yield$this$post.data;

            if (!data) {
              _context7.next = 11;
              break;
            }

            return _context7.abrupt("return", Math.abs(data[chain + "_" + type][0][type]));

          case 11:
            return _context7.abrupt("return", 0);

          case 12:
            _context7.next = 15;
            break;

          case 14:
            return _context7.abrupt("return", 0);

          case 15:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _getRexReturnRate.apply(this, arguments);
}

function getRexPriceChart() {
  return _getRexPriceChart.apply(this, arguments);
}

function _getRexPriceChart() {
  _getRexPriceChart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
    var chain, current_time, seven_days_ago, _yield$this$post2, data;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            chain = chainToRexMap[this.constants.CHAIN];

            if (!chain) {
              _context8.next = 15;
              break;
            }

            current_time = (0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.formatDate)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.utcTime)());
            seven_days_ago = (0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.formatDate)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.utcTime)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.startDate)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.time)(), 7)));
            _context8.next = 6;
            return this.post('https://www.api.bloks.io/graphql/v1alpha1/graphql', {
              query: "query {\n        " + chain + "_pricechart(args: {\n          from_time: \"" + seven_days_ago + "\",\n          to_time: \"" + current_time + "\"\n        }) {\n          t\n          o\n          h\n          l\n          c\n        }\n      }",
              variables: null
            });

          case 6:
            _yield$this$post2 = _context8.sent;
            data = _yield$this$post2.data;

            if (!data) {
              _context8.next = 12;
              break;
            }

            return _context8.abrupt("return", data[chain + "_pricechart"]);

          case 12:
            return _context8.abrupt("return", []);

          case 13:
            _context8.next = 16;
            break;

          case 15:
            return _context8.abrupt("return", {
              actions: []
            });

          case 16:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));
  return _getRexPriceChart.apply(this, arguments);
}

function getEosBalance(_x) {
  return _getEosBalance.apply(this, arguments);
}

function _getEosBalance() {
  _getEosBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName) {
    var _yield$this$rpc$get_c, balance;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.rpc.get_currency_balance(this.constants.EOSIO_TOKEN, accountName, this.constants.CORE_SYMBOL);

          case 2:
            _yield$this$rpc$get_c = _context.sent;
            balance = _yield$this$rpc$get_c[0];
            return _context.abrupt("return", balance);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getEosBalance.apply(this, arguments);
}

function getTokenBalance(_x2, _x3, _x4) {
  return _getTokenBalance.apply(this, arguments);
} // Get Account Tokens

function _getTokenBalance() {
  _getTokenBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(contract, accountName, symbol) {
    var result;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_currency_balance(contract, accountName, symbol)["catch"](function (err) {
              return console.log(err);
            });

          case 2:
            result = _context2.sent;

            if (!(result && result.length)) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", result[0]);

          case 7:
            return _context2.abrupt("return", null);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getTokenBalance.apply(this, arguments);
}

function getAccountTokens(_x5) {
  return _getAccountTokens.apply(this, arguments);
}

function _getAccountTokens() {
  _getAccountTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(accountName) {
    var accountBalances;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (accountBalances) {
              _context3.next = 4;
              break;
            }

            _context3.next = 3;
            return this.lightGetTokens(accountName);

          case 3:
            accountBalances = _context3.sent;

          case 4:
            if (accountBalances) {
              _context3.next = 8;
              break;
            }

            _context3.next = 7;
            return this.hyperionGetTokensForAccount(accountName);

          case 7:
            accountBalances = _context3.sent;

          case 8:
            return _context3.abrupt("return", accountBalances || []);

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getAccountTokens.apply(this, arguments);
}

function lightGetTokens(_x6) {
  return _lightGetTokens.apply(this, arguments);
}

function _lightGetTokens() {
  _lightGetTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var _yield$this$lightApi$, balances;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.lightApi.get_balances(account);

          case 3:
            _yield$this$lightApi$ = _context4.sent;
            balances = _yield$this$lightApi$.balances;
            return _context4.abrupt("return", balances.map(function (balance) {
              return {
                currency: balance.currency,
                amount: Number(balance.amount),
                contract: balance.contract,
                decimals: Number(balance.decimals)
              };
            }));

          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](0);
            console.log('lightGetTokens error', _context4.t0);
            return _context4.abrupt("return", undefined);

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 8]]);
  }));
  return _lightGetTokens.apply(this, arguments);
}

function hyperionGetTokensForAccount(_x7) {
  return _hyperionGetTokensForAccount.apply(this, arguments);
}

function _hyperionGetTokensForAccount() {
  _hyperionGetTokensForAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var _yield$this$hyperion$, tokens;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.hyperion.get_tokens(account);

          case 3:
            _yield$this$hyperion$ = _context5.sent;
            tokens = _yield$this$hyperion$.tokens;
            return _context5.abrupt("return", tokens.map(function (token) {
              return {
                currency: token.symbol,
                amount: Number(token.amount),
                contract: token.contract,
                decimals: Number(token.precision)
              };
            }));

          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](0);
            console.log('hyperionGetTokensForAccount error', _context5.t0);
            return _context5.abrupt("return", undefined);

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 8]]);
  }));
  return _hyperionGetTokensForAccount.apply(this, arguments);
}

function getTokenSupply(_x8, _x9) {
  return _getTokenSupply.apply(this, arguments);
}

function _getTokenSupply() {
  _getTokenSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(contract, symbol) {
    var stats, _stats$symbol, supply, max_supply;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            _context6.next = 3;
            return this.rpc.get_currency_stats(contract, symbol);

          case 3:
            stats = _context6.sent;
            _stats$symbol = stats[symbol], supply = _stats$symbol.supply, max_supply = _stats$symbol.max_supply;
            return _context6.abrupt("return", {
              supply: supply ? +supply.split(' ')[0] : 0,
              max_supply: max_supply ? +max_supply.split(' ')[0] : 0
            });

          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](0);
            console.log(_context6.t0);
            return _context6.abrupt("return", {
              supply: 0,
              max_supply: 0
            });

          case 12:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[0, 8]]);
  }));
  return _getTokenSupply.apply(this, arguments);
}

function getHistoryTransaction(_x, _x2) {
  return _getHistoryTransaction.apply(this, arguments);
}

function _getHistoryTransaction() {
  _getHistoryTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(txId, blockHint) {
    var eosTransactions, tx;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (blockHint === void 0) {
              blockHint = 0;
            }

            eosTransactions = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc(this.constants.TRANSACTIONS_ENDPOINTS);
            _context.next = 4;
            return eosTransactions.history_get_transaction(txId, blockHint);

          case 4:
            tx = _context.sent;

            if (tx) {
              _context.next = 7;
              break;
            }

            throw new Error('TX not found');

          case 7:
            return _context.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.historyTransformTransaction)(tx));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getHistoryTransaction.apply(this, arguments);
}

function getDeferredTransaction(_x3) {
  return _getDeferredTransaction.apply(this, arguments);
}

function _getDeferredTransaction() {
  _getDeferredTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(txId) {
    var _yield$this$rpc$get_s, transactions;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_scheduled_transactions(true, txId, 1);

          case 2:
            _yield$this$rpc$get_s = _context2.sent;
            transactions = _yield$this$rpc$get_s.transactions;

            if (!(transactions.length > 0 && transactions[0].trx_id.substring(0, 6) === txId.substring(0, 6))) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.historyTransformDeferredTransaction)(transactions[0]));

          case 6:
            return _context2.abrupt("return", {});

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getDeferredTransaction.apply(this, arguments);
}

function getHyperionTransaction(_x4) {
  return _getHyperionTransaction.apply(this, arguments);
}

function _getHyperionTransaction() {
  _getHyperionTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id) {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!this.constants.HYPERION_URL) {
              _context3.next = 6;
              break;
            }

            _context3.next = 3;
            return this.hyperion.get_transaction(id);

          case 3:
            result = _context3.sent;
            _context3.next = 9;
            break;

          case 6:
            _context3.next = 8;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'hyperion', {
              type: 'get_transaction',
              id: id,
              options: {}
            }));

          case 8:
            result = _context3.sent;

          case 9:
            if (!(!result || !result.actions || !result.actions.length)) {
              _context3.next = 11;
              break;
            }

            throw new Error('TX not found');

          case 11:
            return _context3.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.hyperionTransformTransaction)(result));

          case 12:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getHyperionTransaction.apply(this, arguments);
}

function generateTransactionSettings(_x5, _x6, _x7) {
  return _generateTransactionSettings.apply(this, arguments);
}

function _generateTransactionSettings() {
  _generateTransactionSettings = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(expireSeconds, blocksBehind, delaySec) {
    var info, refBlock, result;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (expireSeconds === void 0) {
              expireSeconds = 3000;
            }

            if (blocksBehind === void 0) {
              blocksBehind = 12;
            }

            if (delaySec === void 0) {
              delaySec = 0;
            }

            _context4.next = 5;
            return this.rpc.get_info();

          case 5:
            info = _context4.sent;
            result = {};

            if (!info) {
              _context4.next = 12;
              break;
            }

            _context4.next = 10;
            return this.rpc.get_block(info.head_block_num - blocksBehind);

          case 10:
            refBlock = _context4.sent;
            result = _proton_js__WEBPACK_IMPORTED_MODULE_0__.Serialize.transactionHeader(refBlock, expireSeconds);

          case 12:
            return _context4.abrupt("return", _extends({
              max_net_usage_words: 0,
              max_cpu_usage_ms: 0,
              delay_sec: delaySec,
              context_free_actions: [],
              actions: [],
              transaction_extensions: []
            }, result));

          case 13:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _generateTransactionSettings.apply(this, arguments);
}

function getControlledAccounts(accountName) {
  if (this.constants.HISTORY_TYPES.includes('native')) {
    return this.actionsRpc.history_get_controlled_accounts(accountName);
  } else if (this.constants.HISTORY_TYPES.includes('hyperion')) {
    var actionsRpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc([this.constants.HYPERION_URL]);
    return actionsRpc.history_get_controlled_accounts(accountName);
  } else {
    return [];
  }
}
function getPermissionLinks(_x) {
  return _getPermissionLinks.apply(this, arguments);
}

function _getPermissionLinks() {
  _getPermissionLinks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var lightAccount, _yield$this$get, linked_permissions, _yield$this$hyperion$, links;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!this.constants.LIGHT_API) {
              _context.next = 12;
              break;
            }

            _context.prev = 1;
            _context.next = 4;
            return this.getAccountLightData(account);

          case 4:
            lightAccount = _context.sent;

            if (!lightAccount) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return", lightAccount.linkauth.map(function (auth) {
              return {
                action: auth.type,
                contract: auth.code,
                permission_name: auth.requirement
              };
            }));

          case 7:
            _context.next = 12;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);

          case 12:
            if (!this.constants.HISTORY_TYPES.includes('dfuse')) {
              _context.next = 25;
              break;
            }

            _context.prev = 13;
            _context.next = 16;
            return this.get(this.constants.API_URL + "/dfuse?type=state_permission_links&account=" + account);

          case 16:
            _yield$this$get = _context.sent;
            linked_permissions = _yield$this$get.linked_permissions;

            if (!linked_permissions) {
              _context.next = 20;
              break;
            }

            return _context.abrupt("return", linked_permissions);

          case 20:
            _context.next = 25;
            break;

          case 22:
            _context.prev = 22;
            _context.t1 = _context["catch"](13);
            console.log(_context.t1);

          case 25:
            if (!this.constants.HISTORY_TYPES.includes('hyperion')) {
              _context.next = 37;
              break;
            }

            _context.prev = 26;
            _context.next = 29;
            return this.hyperion.get_links(account);

          case 29:
            _yield$this$hyperion$ = _context.sent;
            links = _yield$this$hyperion$.links;
            return _context.abrupt("return", links.map(function (link) {
              return {
                action: link.action,
                contract: link.code,
                permission_name: link.permission
              };
            }));

          case 34:
            _context.prev = 34;
            _context.t2 = _context["catch"](26);
            console.log(_context.t2);

          case 37:
            console.log('Permission links not available on chain');
            return _context.abrupt("return", []);

          case 39:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 9], [13, 22], [26, 34]]);
  }));
  return _getPermissionLinks.apply(this, arguments);
}

function dfuseGetKeyAccounts(_x2) {
  return _dfuseGetKeyAccounts.apply(this, arguments);
}

function _dfuseGetKeyAccounts() {
  _dfuseGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {
    var _yield$this$get2, account_names;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.get(this.constants.API_URL + "/dfuse?type=state_key_accounts&publicKey=" + key);

          case 3:
            _yield$this$get2 = _context2.sent;
            account_names = _yield$this$get2.account_names;
            return _context2.abrupt("return", account_names && account_names.length ? account_names : []);

          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](0);
            console.log(_context2.t0);
            console.log('No dfuse accounts found associated with key:', key);
            return _context2.abrupt("return", []);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 8]]);
  }));
  return _dfuseGetKeyAccounts.apply(this, arguments);
}

function nativeGetKeyAccounts(_x3) {
  return _nativeGetKeyAccounts.apply(this, arguments);
}

function _nativeGetKeyAccounts() {
  _nativeGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {
    var keyAccounts, fioAccount, _yield$this$rpc$get_a, accounts;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            keyAccounts = [];

            if (!['fio', 'fio-test'].includes(this.constants.CHAIN)) {
              _context3.next = 7;
              break;
            }

            fioAccount = (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.fioKeyToActor)(key.replace('EOS', 'FIO'), _proton_js__WEBPACK_IMPORTED_MODULE_0__.Numeric.stringToPublicKey);

            if (keyAccounts.indexOf(fioAccount) === -1) {
              keyAccounts.push(fioAccount);
            }

            _context3.next = 12;
            break;

          case 7:
            _context3.next = 9;
            return this.rpc.get_accounts_by_authorizers([], [key]);

          case 9:
            _yield$this$rpc$get_a = _context3.sent;
            accounts = _yield$this$rpc$get_a.accounts;
            keyAccounts = Array.from(new Set(accounts.map(function (account) {
              return account.account_name;
            })));

          case 12:
            return _context3.abrupt("return", keyAccounts);

          case 15:
            _context3.prev = 15;
            _context3.t0 = _context3["catch"](0);
            console.log(_context3.t0);
            throw _context3.t0;

          case 19:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 15]]);
  }));
  return _nativeGetKeyAccounts.apply(this, arguments);
}

function hyperionGetKeyAccounts(_x4) {
  return _hyperionGetKeyAccounts.apply(this, arguments);
}

function _hyperionGetKeyAccounts() {
  _hyperionGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key) {
    var legacyPublicKey, _yield$this$hyperion$2, account_names;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (this.hyperion) {
              _context4.next = 2;
              break;
            }

            throw new Error('Hyperion API not supported');

          case 2:
            legacyPublicKey = _proton_js__WEBPACK_IMPORTED_MODULE_0__.Key.PublicKey.fromString(key).toLegacyString();
            _context4.next = 5;
            return this.hyperion.get_key_accounts(legacyPublicKey);

          case 5:
            _yield$this$hyperion$2 = _context4.sent;
            account_names = _yield$this$hyperion$2.account_names;

            if (!(account_names && account_names.length)) {
              _context4.next = 11;
              break;
            }

            return _context4.abrupt("return", account_names);

          case 11:
            throw new Error('No keys found');

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _hyperionGetKeyAccounts.apply(this, arguments);
}

function lightGetKeyAccounts(_x5) {
  return _lightGetKeyAccounts.apply(this, arguments);
}

function _lightGetKeyAccounts() {
  _lightGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {
    var lightChain, accountsByChain, accounts;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (this.lightApi) {
              _context5.next = 2;
              break;
            }

            throw new Error('Light API not supported');

          case 2:
            lightChain = this.constants.CHAIN.toLowerCase().replace('-', '');
            _context5.next = 5;
            return this.lightApi.get_key_accounts(key);

          case 5:
            accountsByChain = _context5.sent;
            accounts = accountsByChain[lightChain].accounts;
            return _context5.abrupt("return", Array.from(new Set(Object.keys(accounts))));

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _lightGetKeyAccounts.apply(this, arguments);
}

function getKeyAccountsByType(_x6, _x7) {
  return _getKeyAccountsByType.apply(this, arguments);
}
/**
 * Tries all histories to get keys.
 * @param {*} key
 */

function _getKeyAccountsByType() {
  _getKeyAccountsByType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key, type) {
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.t0 = type;
            _context6.next = _context6.t0 === 'dfuse' ? 3 : _context6.t0 === 'native' ? 6 : _context6.t0 === 'hyperion' ? 9 : _context6.t0 === 'light' ? 12 : 12;
            break;

          case 3:
            _context6.next = 5;
            return this.dfuseGetKeyAccounts(key);

          case 5:
            return _context6.abrupt("return", _context6.sent);

          case 6:
            _context6.next = 8;
            return this.nativeGetKeyAccounts(key);

          case 8:
            return _context6.abrupt("return", _context6.sent);

          case 9:
            _context6.next = 11;
            return this.hyperionGetKeyAccounts(key);

          case 11:
            return _context6.abrupt("return", _context6.sent);

          case 12:
            _context6.next = 14;
            return this.lightGetKeyAccounts(key);

          case 14:
            return _context6.abrupt("return", _context6.sent);

          case 15:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _getKeyAccountsByType.apply(this, arguments);
}

function getKeyAccounts(_x8) {
  return _getKeyAccounts.apply(this, arguments);
}

function _getKeyAccounts() {
  _getKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(key) {
    var _i, _arr, historyType, res;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (key.startsWith('FIO')) {
              key = key.replace('FIO', 'EOS');
            }

            _i = 0, _arr = [this.constants.HISTORY_TYPES[0], 'light'].concat(this.constants.HISTORY_TYPES.slice(1));

          case 2:
            if (!(_i < _arr.length)) {
              _context7.next = 19;
              break;
            }

            historyType = _arr[_i];
            _context7.prev = 4;
            _context7.next = 7;
            return this.getKeyAccountsByType(key, historyType);

          case 7:
            res = _context7.sent;

            if (!res) {
              _context7.next = 10;
              break;
            }

            return _context7.abrupt("return", res);

          case 10:
            _context7.next = 16;
            break;

          case 12:
            _context7.prev = 12;
            _context7.t0 = _context7["catch"](4);
            console.log(_context7.t0);
            return _context7.abrupt("continue", 16);

          case 16:
            _i++;
            _context7.next = 2;
            break;

          case 19:
            return _context7.abrupt("return", []);

          case 20:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[4, 12]]);
  }));
  return _getKeyAccounts.apply(this, arguments);
}

function getKeyAccountsForAllChains(_x9) {
  return _getKeyAccountsForAllChains.apply(this, arguments);
}
/**
 * Recursively resolves all required permissions
 * @param accountName
 * @param permission
 */

function _getKeyAccountsForAllChains() {
  _getKeyAccountsForAllChains = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(key) {
    var keyAccounts, combined;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (this.lightApi) {
              _context8.next = 2;
              break;
            }

            throw new Error('Light API not supported');

          case 2:
            _context8.prev = 2;
            _context8.next = 5;
            return this.lightApi.get_all_key_accounts(key);

          case 5:
            keyAccounts = _context8.sent;
            combined = keyAccounts.reduce(function (acc, obj) {
              return _extends({}, acc, obj);
            }, {});
            return _context8.abrupt("return", Object.entries(combined).reduce(function (acc, _ref) {
              var chain = _ref[0],
                  accountsByName = _ref[1].accounts;
              var accounts = Object.keys(accountsByName);

              if (accounts.length) {
                acc.push({
                  chain: chain,
                  accounts: accounts
                });
              }

              return acc;
            }, []));

          case 10:
            _context8.prev = 10;
            _context8.t0 = _context8["catch"](2);
            console.log(_context8.t0);
            return _context8.abrupt("return", []);

          case 14:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[2, 10]]);
  }));
  return _getKeyAccountsForAllChains.apply(this, arguments);
}

function getRequiredAccounts(_x10, _x11, _x12, _x13, _x14) {
  return _getRequiredAccounts.apply(this, arguments);
}

function _getRequiredAccounts() {
  _getRequiredAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(accountName, permissionName, allPermissions, currentLevel, maxLevel) {
    var accountInfo, _iterator, _step, permission, accounts, producers, _iterator2, _step2, account;

    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (allPermissions === void 0) {
              allPermissions = [];
            }

            if (currentLevel === void 0) {
              currentLevel = 1;
            }

            if (maxLevel === void 0) {
              maxLevel = 2;
            }

            _context9.next = 5;
            return this.getAccount(accountName);

          case 5:
            accountInfo = _context9.sent;
            _iterator = _createForOfIteratorHelperLoose(accountInfo.permissions);

          case 7:
            if ((_step = _iterator()).done) {
              _context9.next = 31;
              break;
            }

            permission = _step.value;

            if (!(permission.perm_name === permissionName)) {
              _context9.next = 29;
              break;
            }

            // Get all account (e.g. gyy, hartono, thompson)
            accounts = [];

            if (!(accountName === 'eosio' && ['owner', 'active'].includes(permission.perm_name))) {
              _context9.next = 16;
              break;
            }

            _context9.next = 14;
            return this.getProducersLocal();

          case 14:
            producers = _context9.sent;
            accounts = producers.map(function (producer) {
              return {
                actor: producer.owner,
                permission: 'active'
              };
            });

          case 16:
            if (!accounts.length) {
              accounts = permission.required_auth.accounts.map(function (account) {
                return account.permission;
              });
            }

            if (!accounts.length) {
              allPermissions.push({
                actor: accountName,
                permission: permissionName
              });
            } // For each account (e.g. hartono)


            _iterator2 = _createForOfIteratorHelperLoose(accounts);

          case 19:
            if ((_step2 = _iterator2()).done) {
              _context9.next = 29;
              break;
            }

            account = _step2.value;

            if (!(currentLevel < maxLevel)) {
              _context9.next = 26;
              break;
            }

            _context9.next = 24;
            return this.getRequiredAccounts(account.actor, account.permission, allPermissions, ++currentLevel, maxLevel);

          case 24:
            _context9.next = 27;
            break;

          case 26:
            allPermissions.push({
              actor: account.actor,
              permission: account.permission
            });

          case 27:
            _context9.next = 19;
            break;

          case 29:
            _context9.next = 7;
            break;

          case 31:
            return _context9.abrupt("return", allPermissions);

          case 32:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this);
  }));
  return _getRequiredAccounts.apply(this, arguments);
}

function getUsersFromKeys(_x15) {
  return _getUsersFromKeys.apply(this, arguments);
}

function _getUsersFromKeys() {
  _getUsersFromKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(keys) {
    var _this = this;

    var users, promises;
    return _regeneratorRuntime().wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            users = [];
            promises = keys.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(key) {
                var account_names, promises2;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        _context11.next = 2;
                        return _this.getKeyAccounts(key);

                      case 2:
                        account_names = _context11.sent;
                        promises2 = account_names.map( /*#__PURE__*/function () {
                          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(account) {
                            var accountInfo, _iterator3, _step3, permission;

                            return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                              while (1) {
                                switch (_context10.prev = _context10.next) {
                                  case 0:
                                    _context10.next = 2;
                                    return _this.getAccount(account);

                                  case 2:
                                    accountInfo = _context10.sent;

                                    // For every permission, add to array
                                    for (_iterator3 = _createForOfIteratorHelperLoose(accountInfo.permissions); !(_step3 = _iterator3()).done;) {
                                      permission = _step3.value;

                                      // If key exists
                                      if (permission.required_auth.keys.find(function (permKey) {
                                        return permKey.key === key;
                                      })) {
                                        users.push({
                                          actor: account,
                                          permission: permission.perm_name,
                                          publicKey: key
                                        });
                                      }
                                    }

                                  case 4:
                                  case "end":
                                    return _context10.stop();
                                }
                              }
                            }, _callee10);
                          }));

                          return function (_x17) {
                            return _ref3.apply(this, arguments);
                          };
                        }());
                        _context11.next = 6;
                        return Promise.all(promises2);

                      case 6:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee11);
              }));

              return function (_x16) {
                return _ref2.apply(this, arguments);
              };
            }());
            _context12.next = 4;
            return Promise.all(promises);

          case 4:
            return _context12.abrupt("return", users);

          case 5:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));
  return _getUsersFromKeys.apply(this, arguments);
}

var ApiClass = /*#__PURE__*/function () {
  function ApiClass(chain) {
    this.rpc = undefined;
    this.actionsRpc = undefined;
    this.api = undefined;
    this.hyperion = undefined;
    this.lightApi = undefined;
    this.isInitialized = false;
    this.constants = undefined;
    this.http = http;
    this.get = get;
    this.post = post;
    this.getAccount = getAccount;
    this.getGravatar = getGravatar;
    this.searchAccount = searchAccount;
    this.getParent = getParent;
    this.getAccountLightData = getAccountLightData;
    this.getActionsFromNative = getActionsFromNative;
    this.getActions = getActions;
    this.getActionsFromDfuse = getActionsFromDfuse;
    this.getActionsFromHyperion = getActionsFromHyperion;
    this.getDappStats = getDappStats;
    this.getDspPackages = getDspPackages;
    this.getDapphodlBalance = getDapphodlBalance;
    this.getDappBalance = getDappBalance;
    this.getDappStakes = getDappStakes;
    this.getDapphodlStakes = getDapphodlStakes;
    this.getDappUnstakes = getDappUnstakes;
    this.getDapphodlUnstakes = getDapphodlUnstakes;
    this.getFIOVoter = getFIOVoter;
    this.getFIOAddressByName = getFIOAddressByName;
    this.getFIODomainByName = getFIODomainByName;
    this.getNFTsByFioAddress = getNFTsByFioAddress;
    this.getDomains = getDomains;
    this.getAddresses = getAddresses;
    this.getFIOProducers = getFIOProducers;
    this.getFIOSupplyBreakdown = getFIOSupplyBreakdown;
    this.getFIOFees = getFIOFees;
    this.addFIOFeeToActions = addFIOFeeToActions;
    this.getFIOAddresses = getFIOAddresses;
    this.getFIODomains = getFIODomains;
    this.getFIOAddressesAndDomains = getFIOAddressesAndDomains;
    this.getFIOBalance = getFIOBalance;
    this.getControlledAccounts = getControlledAccounts;
    this.getPermissionLinks = getPermissionLinks;
    this.dfuseGetKeyAccounts = dfuseGetKeyAccounts;
    this.nativeGetKeyAccounts = nativeGetKeyAccounts;
    this.hyperionGetKeyAccounts = hyperionGetKeyAccounts;
    this.lightGetKeyAccounts = lightGetKeyAccounts;
    this.getKeyAccountsByType = getKeyAccountsByType;
    this.getKeyAccounts = getKeyAccounts;
    this.getKeyAccountsForAllChains = getKeyAccountsForAllChains;
    this.getRequiredAccounts = getRequiredAccounts;
    this.getUsersFromKeys = getUsersFromKeys;
    this.getAllMsigs = getAllMsigs;
    this.parsePackedMsigActions = parsePackedMsigActions;
    this.parsePackedMsig = parsePackedMsig;
    this.getFullMsigProposal = getFullMsigProposal;
    this.getMsigApprovals = getMsigApprovals;
    this.getAccountsMsigProposals = getAccountsMsigProposals;
    this.hyperionGetMsig = hyperionGetMsig;
    this.getMsigProposal = getMsigProposal;
    this.getRentbwState = getRentbwState;
    this.delegatedBandwidth = delegatedBandwidth;
    this.getAccountDelegatedBandwidth = getAccountDelegatedBandwidth;
    this.getAccountResources = getAccountResources;
    this.getRamPriceInEos = getRamPriceInEos;
    this.getRexQueued = getRexQueued;
    this.getRexPool = getRexPool;
    this.getRexBalance = getRexBalance;
    this.getRexCpuLoans = getRexCpuLoans;
    this.getRexNetLoans = getRexNetLoans;
    this.getEosDepositedIntoRex = getEosDepositedIntoRex;
    this.getRexReturnRate = getRexReturnRate;
    this.getRexPriceChart = getRexPriceChart;
    this.getEosTopStakes = getEosTopStakes;
    this.getEosTopRams = getEosTopRams;
    this.getCurrentNameBids = getCurrentNameBids;
    this.getEosBalance = getEosBalance;
    this.getTokenBalance = getTokenBalance;
    this.hyperionGetTokensForAccount = hyperionGetTokensForAccount;
    this.getTokenSupply = getTokenSupply;
    this.lightGetTokens = lightGetTokens;
    this.getAccountTokens = getAccountTokens;
    this.getHistoryTransaction = getHistoryTransaction;
    this.getDeferredTransaction = getDeferredTransaction;
    this.getHyperionTransaction = getHyperionTransaction;
    this.generateTransactionSettings = generateTransactionSettings;
    this.getProxies = getProxies;
    this.getVoters = getVoters;
    this.calculateVoteWeight = calculateVoteWeight;
    this.weightedVoteToNumber = weightedVoteToNumber;
    this.getProxyData = getProxyData;
    this.getVoter = getVoter;
    this.getProducers = getProducers;
    this.getProducersLocal = getProducersLocal;
    this.getChainTable = getChainTable;
    this.fetchKycCountries = fetchKycCountries;
    this.checkUserKycStatus = checkUserKycStatus;
    this.applyForKyc = applyForKyc;
    this.currentLocation = currentLocation;
    this.getAvailableFeatures = getAvailableFeatures;
    this.otcQuote = otcQuote;
    this.otcOrder = otcOrder;
    this.generateAddress = generateAddress;
    this.deleteAddress = deleteAddress;
    this.withdrawMetal = withdrawMetal;
    this.withdrawalHistoryMetal = withdrawalHistoryMetal;
    this.getTokenPrices = getTokenPrices;
    this.getWithdrawalFee = getWithdrawalFee;
    this.getChainInfo = getChainInfo;
    this.createAccount = createAccount;
    this.loginAccount = loginAccount;
    this.getXprTotalStakedAndApr = getXprTotalStakedAndApr;
    this.getXprVoter = getXprVoter;
    this.getXprAccountStakes = getXprAccountStakes;
    this.getXprAccountRefund = getXprAccountRefund;
    this.getXprOracleData = getXprOracleData;
    this.getAllOracleFeeds = getAllOracleFeeds;
    this.getAllOracleData = getAllOracleData;
    this.getSpecificOracleData = getSpecificOracleData;
    this.getProtonAvatar = getProtonAvatar;
    this.getProtonAvatars = getProtonAvatars;

    if (chain) {
      _bloks_constants__WEBPACK_IMPORTED_MODULE_1__.constants.initialize(chain);
      this.initialize(_bloks_constants__WEBPACK_IMPORTED_MODULE_1__.constants);
    }
  }

  var _proto = ApiClass.prototype;

  _proto.initialize = function initialize(constants, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        rpcEndpoints = _ref.rpcEndpoints,
        actionsRpcEndpoints = _ref.actionsRpcEndpoints,
        lightEndpoint = _ref.lightEndpoint,
        hyperionEndpoint = _ref.hyperionEndpoint;

    this.constants = constants;
    this.rpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc(rpcEndpoints || this.constants.DEFAULT_ENDPOINTS);
    this.actionsRpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc(actionsRpcEndpoints || this.constants.ACTIONS_ENDPOINTS);
    this.api = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.Api({
      rpc: this.rpc
    });
    var lightUrl = lightEndpoint || this.constants.LIGHT_API;

    if (lightUrl) {
      this.lightApi = new _proton_light_api__WEBPACK_IMPORTED_MODULE_3__.JsonRpc(this.constants.CHAIN.toLowerCase().replace('-', ''), {
        endpoint: lightUrl
      });
    }

    var hyperionUrl = hyperionEndpoint || this.constants.HYPERION_URL;

    if (hyperionUrl) {
      this.hyperion = new _proton_hyperion__WEBPACK_IMPORTED_MODULE_2__.JsonRpc(hyperionUrl);
    }

    this.isInitialized = true;
  };

  return ApiClass;
}();


//# sourceMappingURL=api.esm.js.map


/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TypeScript Definitions
__exportStar(__webpack_require__(/*! ./src/types/action_trace */ "./node_modules/@proton/hyperion/dist/src/types/action_trace.js"), exports);
__exportStar(__webpack_require__(/*! ./src/types/api */ "./node_modules/@proton/hyperion/dist/src/types/api.js"), exports);
// Hyperion API
__exportStar(__webpack_require__(/*! ./src/jsonrpc */ "./node_modules/@proton/hyperion/dist/src/jsonrpc.js"), exports);
__exportStar(__webpack_require__(/*! ./src/endpoints */ "./node_modules/@proton/hyperion/dist/src/endpoints.js"), exports);
__exportStar(__webpack_require__(/*! ./src/rpcerror */ "./node_modules/@proton/hyperion/dist/src/rpcerror.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/endpoints.js":
/*!*************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/endpoints.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.V2_GET_TRANSFERS = exports.V2_GET_TRANSACTION = exports.V2_GET_TRANSACTED_ACCOUNTS = exports.V2_GET_DELTAS = exports.V2_GET_CREATOR = exports.V2_GET_CREATED_ACCOUNTS = exports.V2_GET_ACTIONS = exports.V2_GET_ABI_SNAPSHOT = exports.V2_GET_PROPOSALS = exports.V2_GET_LINKS = exports.V2_GET_VOTERS = exports.V2_GET_TOKENS = exports.V2_GET_KEY_ACCOUNTS = exports.V2_ALIVE = void 0;
// State
exports.V2_ALIVE = "/v2/state/alive";
exports.V2_GET_KEY_ACCOUNTS = "/v2/state/get_key_accounts";
exports.V2_GET_TOKENS = "/v2/state/get_tokens";
exports.V2_GET_VOTERS = "/v2/state/get_voters";
exports.V2_GET_LINKS = "/v2/state/get_links";
exports.V2_GET_PROPOSALS = "/v2/state/get_proposals";
// History
exports.V2_GET_ABI_SNAPSHOT = "/v2/history/get_abi_snapshot";
exports.V2_GET_ACTIONS = "/v2/history/get_actions";
exports.V2_GET_CREATED_ACCOUNTS = "/v2/history/get_created_accounts";
exports.V2_GET_CREATOR = "/v2/history/get_creator";
exports.V2_GET_DELTAS = "/v2/history/get_deltas";
exports.V2_GET_TRANSACTED_ACCOUNTS = "/v2/history/get_transacted_accounts";
exports.V2_GET_TRANSACTION = "/v2/history/get_transaction";
exports.V2_GET_TRANSFERS = "/v2/history/get_transfers";
//# sourceMappingURL=endpoints.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/jsonrpc.js":
/*!***********************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/jsonrpc.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpc = void 0;
var endpoints_1 = __webpack_require__(/*! ./endpoints */ "./node_modules/@proton/hyperion/dist/src/endpoints.js");
var rpcerror_1 = __webpack_require__(/*! ./rpcerror */ "./node_modules/@proton/hyperion/dist/src/rpcerror.js");
var cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
function queryParams(params) {
    var entries = [];
    for (var _i = 0, _a = Object.keys(params); _i < _a.length; _i++) {
        var key = _a[_i];
        var value = params[key];
        if (value !== undefined) {
            entries.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
        }
    }
    return entries.join("&");
}
function fetchWithTimeout(resource, options) {
    return __awaiter(this, void 0, void 0, function () {
        var timeout, controller, id, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    timeout = options.timeout;
                    controller = new AbortController();
                    id = setTimeout(function () { return controller.abort(); }, timeout);
                    return [4 /*yield*/, (0, cross_fetch_1.default)(resource, __assign(__assign({}, (options || {})), { signal: controller.signal }))];
                case 1:
                    response = _a.sent();
                    clearTimeout(id);
                    return [2 /*return*/, response];
            }
        });
    });
}
/**
 * JsonRpc
 *
 * @param {string} endpoint hyperion endpoint
 * @example
 *
 * const endpoint = "https://br.eosrio.io"
 * const rpc = new JsonRpc(endpoint, { fetch })
 */
var JsonRpc = /** @class */ (function () {
    function JsonRpc(endpoint, args) {
        if (args === void 0) { args = {}; }
        this.timeout = 8000;
        this.endpoint = endpoint;
        if (args.timeout) {
            this.timeout = args.timeout;
        }
    }
    /**
     * post
     *
     * POST `body` to `endpoint + path`.
     * Throws detailed error information in `RpcError` when available.
     *
     * @private
     */
    JsonRpc.prototype.post = function (path, body) {
        return __awaiter(this, void 0, void 0, function () {
            var response, json, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, fetchWithTimeout(this.endpoint + path, {
                                body: JSON.stringify(body),
                                method: "POST",
                                timeout: this.timeout
                            })];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.json()];
                    case 2:
                        json = _a.sent();
                        if (json.processed && json.processed.except) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        e_1.isFetchError = true;
                        throw e_1;
                    case 4:
                        if (!response.ok) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * get
     *
     * GET `params` to `endpoint + path`.
     * Throws detailed error information in `RpcError` when available.
     *
     * @private
     */
    JsonRpc.prototype.get = function (path, params) {
        return __awaiter(this, void 0, void 0, function () {
            var response, json, url, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endpoint + path + "?" + queryParams(params);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, fetchWithTimeout(url, {
                                method: "GET",
                                timeout: this.timeout
                            })];
                    case 2:
                        response = _a.sent();
                        if (response.status !== 200) {
                            throw new rpcerror_1.RpcStatusError(response);
                        }
                        return [4 /*yield*/, response.json()];
                    case 3:
                        json = _a.sent();
                        if (json.processed && json.processed.except) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_2 = _a.sent();
                        e_2.isFetchError = true;
                        throw e_2;
                    case 5:
                        if (!response.ok) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * [GET /v2/state/alive](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_alive)
     *
     * simple server healthcheck
     *
     * @returns {Promise<Alive>} alive
     * @example
     *
     * const response = await rpc.alive();
     * console.log(response);
     * // => {"status": "OK"}
     */
    JsonRpc.prototype.alive = function () {
        return this.get(endpoints_1.V2_ALIVE, {});
    };
    /**
     * [GET /v2/history/get_abi_snapshot](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_abi_snapshot)
     *
     * fetch contract abi at specific block
     *
     * @param {string} contract contract account
     * @param {number} number target block
     * @returns {Promise<GetAbiSnapshot>} abi snapshot
     * @example
     *
     * const response = await rpc.get_abi_snapshot("eosio", 200);
     * console.log(response.version);
     * // => "eosio::abi/1.0"
     *
     * for (const table of response.tables) {
     *     console.log(table);
     *     // => { name: 'producers', index_type: 'i64', key_names: [ 'owner' ], key_types: [ 'uint64' ], type: 'producer_info' }
     * }
     */
    JsonRpc.prototype.get_abi_snapshot = function (contract, block) {
        var params = {
            contract: contract,
            block: block,
        };
        return this.get(endpoints_1.V2_GET_ABI_SNAPSHOT, params);
    };
    /**
     * [GET /v2/state/get_voters](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_voters)
     *
     * get voters
     *
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.producer] filter by voted producer (comma separated)
     * @param {boolean} [options.proxy] true or false
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @returns {Promise<GetVoters>} voters
     * @example
     *
     * const response = await rpc.get_voters({ producer: "eoscafeblock", limit: 100 });
     * console.log(response.voters);
     * // => "[{
     * //   "account": "guzdkmrtgage",
     * //   "weight": 78434695236505280,
     * //   "last_vote": 64804768
     * // }]"
     */
    JsonRpc.prototype.get_voters = function (options) {
        return this.get(endpoints_1.V2_GET_VOTERS, options);
    };
    /**
     * [GET /v2/state/get_links](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_links)
     *
     * get voters
     *
     * @param {string} [account] account to get links for
     * @returns {Promise<GetLinks>} links
     * @example
     *
     * const response = await rpc.get_links("eoscafeblock");
     * console.log(response.links);
     * // => "[{
     * "block_num":26088072,
     * "timestamp":"2019-11-22T23:17:42.000",
     * "account":"eosriobrazil",
     * "permission":"claim2",
     * "code":"eosio",
     * "action":"voteproducer"
     * }]"
     */
    JsonRpc.prototype.get_links = function (account) {
        return this.get(endpoints_1.V2_GET_LINKS, { account: account });
    };
    /**
     * [GET /v2/state/get_proposals](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_proposals)
     *
     * get proposals
     *
     * @param {string} [account] account to get proposals for
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.proposer] filter by proposer
     * @param {string} [options.proposal] filter by proposal name
     * @param {string} [options.account] filter by either requested or provided account
     * @param {string} [options.requested] filter by requested account
     * @param {string} [options.provided] filter by provided account
     * @param {string} [options.track] total results to track (count) [number or true]
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @returns {Promise<GetProposals>} proposals
     */
    JsonRpc.prototype.get_proposals = function (options) {
        return this.get(endpoints_1.V2_GET_PROPOSALS, options);
    };
    /**
     * [GET /v2/history/get_actions](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_actions)
     *
     * get actions based on notified account
     *
     * @param {string} account notified account
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.filter] code::name filter
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @param {string} [options.sort] sort direction
     * @param {string} [options.after] filter after specified date (ISO8601)
     * @param {string} [options.before] filter before specified date (ISO8601)
     * @param {string} [options.transfer_to] transfer filter to
     * @param {string} [options.transfer_from]  transfer filter from
     * @param {string} [options.transfer_symbol]  transfer filter symbol
     * @param {string} [options.act_name]  act name
     * @param {string} [options.act_account]  act account
     * @returns {Promise<GetActions>} get actions
     * @example
     *
     * const response = await rpc.get_actions("eoscafeblock", {
     *     filter: "eosio.token:*",
     *     skip: 100,
     *     limit: 100,
     * });
     *
     * for (const action of response.actions) {
     *     console.log(action);
     *     // => { act: { account: 'eosio.token', name: 'transfer', ... } }
     * }
     */
    JsonRpc.prototype.get_actions = function (account, options) {
        if (options === void 0) { options = {}; }
        var params = Object.assign({}, { account: account }, options);
        return this.get(endpoints_1.V2_GET_ACTIONS, params);
    };
    /**
     * [GET /v2/history/get_created_accounts](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_created_accounts)
     *
     * get created accounts
     *
     * @param {string} account created account
     * @returns {Promise<GetCreatedAccounts>} get creator
     * @example
     *
     * const response = await rpc.get_created_accounts("eosnationftw");
     * console.log(response);
     * // => {"accounts": [{"name":"eosnationdsp","trx_id":"728d4a4da36a98d9048080461dacaf975ad083e8158ef84edea60cc755ab2c1a","timestamp":"2019-02-28T22:36:45.000"}, ... ]}
     */
    JsonRpc.prototype.get_created_accounts = function (account) {
        var params = {
            account: account,
        };
        return this.get(endpoints_1.V2_GET_CREATED_ACCOUNTS, params);
    };
    /**
     * [GET /v2/history/get_creator](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_creator)
     *
     * get creator
     *
     * @param {string} account created account
     * @returns {Promise<GetCreator>} get creator
     * @example
     *
     * const response = await rpc.get_creator("eosnationftw");
     * console.log(response);
     * // => { account: 'eosnationftw', creator: 'gyztcmrvgqge', timestamp: '2018-06-10T13:06:43.500', ... }
     */
    JsonRpc.prototype.get_creator = function (account) {
        var params = {
            account: account,
        };
        return this.get(endpoints_1.V2_GET_CREATOR, params);
    };
    /**
     * [GET /v2/history/get_deltas](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_deltas)
     *
     * get deltas
     *
     * @param {string} code contract account
     * @param {string} scope table scope
     * @param {string} table table name
     * @param {string} payer payer account
     * @returns {Promise<GetDeltas>} get deltas
     * @example
     *
     * const response = await rpc.get_deltas("eosio.token", "eosnationftw", "accounts", "eosnationftw");
     * console.log(response);
     * // => { "query_time": 19, "total": { "value": 486, "relation": "eq" }, "deltas": [ ... ] }
     */
    JsonRpc.prototype.get_deltas = function (code, scope, table, payer, options) {
        var params = Object.assign({}, options, {
            code: code,
            scope: scope,
            table: table,
            payer: payer,
        });
        return this.get(endpoints_1.V2_GET_DELTAS, params);
    };
    /**
     * [GET/v2/state/get_key_accounts](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_key_accounts)
     *
     * get account by public key
     *
     * @param {string} public_key Contract account targeted by the action.
     * @returns {Promise<GetKeyAccounts>} key accounts
     * @example
     *
     * const response = await rpc.get_key_accounts("EOS5Mto3Km6BCVxowb6LkkFaT9oaUwLVgswgcxvY4Qgc4rhHry4Tv");
     * console.log(response.account_names);
     * // => [ 'eoscafeblock' ]
     */
    JsonRpc.prototype.get_key_accounts = function (public_key) {
        var params = {
            public_key: public_key,
        };
        return this.get(endpoints_1.V2_GET_KEY_ACCOUNTS, params);
    };
    /**
     * [GET /v2/state/get_tokens](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_tokens)
     *
     * get tokens
     *
     * @param {string} account account
     * @returns {Promise<GetTokens>} get tokens
     * @example
     *
     * const response = await rpc.get_tokens("eosnationftw");
     * for (const token of response.tokens) {
     *     console.log(token);
     *     // => { symbol: 'ZOS', precision: 4, amount: 140, contract: 'zosdiscounts' }
     * }
     */
    JsonRpc.prototype.get_tokens = function (account) {
        var params = {
            account: account,
        };
        return this.get(endpoints_1.V2_GET_TOKENS, params);
    };
    /**
     * [GET /v2/history/get_transacted_accounts](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_transacted_accounts)
     *
     * get all account that interacted with the source account provided
     *
     * @param {string} account source account
     * @param {string} direction search direction (in, out or both)
     * @returns {Promise<GetTransactedAccounts>} transacted accounts
     * @example
     *
     * const response = await rpc.get_transacted_accounts("eoscafeblock", "in");
     * console.log(response);
     * // => { query_time: 268, account: 'eoscafeblock', total_in: 1092369.1827, inputs: [ ... ] }
     */
    JsonRpc.prototype.get_transacted_accounts = function (account, direction, options) {
        if (options === void 0) { options = {}; }
        var params = Object.assign({}, { account: account, direction: direction }, options);
        return this.get(endpoints_1.V2_GET_TRANSACTED_ACCOUNTS, params);
    };
    /**
     * [GET /v2/history/get_transaction](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_transaction)
     *
     * get all actions belonging to the same transaction
     *
     * @param {string} id transaction id
     * @returns {Promise<GetTransaction>} transaction
     * @example
     *
     * const response = await rpc.get_transaction("42dacd5722001b734be46a2140917e06cd21d42425f927f506c07b4388b07f62");
     * for (const action of response.actions) {
     *     console.log(action);
     *     // => { act: { account: 'eosio', name: 'buyrambytes', ... }}
     * }
     */
    JsonRpc.prototype.get_transaction = function (id) {
        var params = {
            id: id,
        };
        return this.get(endpoints_1.V2_GET_TRANSACTION, params);
    };
    /**
     * [GET /v2/history/get_transfers](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_transfers)
     *
     * get token transfers utilizing the eosio.token standard
     *
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.from] source account
     * @param {string} [options.to] destination account
     * @param {string} [options.symbol] token symbol
     * @param {string} [options.contract] token contract
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @param {string} [options.after] filter after specified date (ISO8601)
     * @param {string} [options.before] filter before specified date (ISO8601)
     * @returns {Promise<GetTransfers>} transfers
     * @example
     *
     * const response = await rpc.get_transfers({to: "eosnewyorkio"});
     * for (const action of response.actions) {
     *     console.log(action.act.data);
     *     // => { from: 'eosio.bpay', to: 'eosnewyorkio', amount: 326.524, symbol: 'EOS', memo: 'producer block pay' }
     * }
     */
    JsonRpc.prototype.get_transfers = function (options) {
        if (options === void 0) { options = {}; }
        var params = Object.assign({}, options);
        return this.get(endpoints_1.V2_GET_TRANSFERS, params);
    };
    return JsonRpc;
}());
exports.JsonRpc = JsonRpc;
//# sourceMappingURL=jsonrpc.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/rpcerror.js":
/*!************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/rpcerror.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcStatusError = exports.RpcError = void 0;
/**
 * @private
 * @module RPC-Error
 *
 * copyright defined in eosjs/LICENSE.txt
 */
var RpcError = /** @class */ (function (_super) {
    __extends(RpcError, _super);
    function RpcError(json) {
        var _this = this;
        if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
        }
        else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
        }
        else {
            _this = _super.call(this, json.message) || this;
        }
        Object.setPrototypeOf(_this, RpcError.prototype);
        _this.json = json;
        return _this;
    }
    return RpcError;
}(Error));
exports.RpcError = RpcError;
/**
 * @private
 */
var RpcStatusError = /** @class */ (function (_super) {
    __extends(RpcStatusError, _super);
    function RpcStatusError(response) {
        var _this = this;
        if (response.status === 405) {
            _this = _super.call(this, response.statusText) || this;
        }
        else {
            _this = _super.call(this) || this;
        }
        Object.setPrototypeOf(_this, RpcStatusError.prototype);
        _this.response = response;
        return _this;
    }
    return RpcStatusError;
}(Error));
exports.RpcStatusError = RpcStatusError;
//# sourceMappingURL=rpcerror.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/types/action_trace.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/types/action_trace.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=action_trace.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/types/api.js":
/*!*************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/types/api.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TypeScript Definitions
__exportStar(__webpack_require__(/*! ./src/types/api */ "./node_modules/@proton/light-api/dist/src/types/api.js"), exports);
// Light API
__exportStar(__webpack_require__(/*! ./src/jsonrpc */ "./node_modules/@proton/light-api/dist/src/jsonrpc.js"), exports);
__exportStar(__webpack_require__(/*! ./src/endpoints */ "./node_modules/@proton/light-api/dist/src/endpoints.js"), exports);
__exportStar(__webpack_require__(/*! ./src/rpcerror */ "./node_modules/@proton/light-api/dist/src/rpcerror.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/endpoints.js":
/*!**************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/endpoints.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GET_ACCOUNTS_FROM_KEYS = exports.GET_TOKEN_HOLDERS = exports.GET_TOKEN_HOLDER_COUNT = exports.GET_CODEHASH = exports.GET_TOPSTAKE = exports.GET_TOPRAM = exports.GET_USERCOUNT = exports.GET_TOPHOLDERS = exports.GET_TOKEN_BALANCE = exports.GET_SYNC_INFO = exports.GET_NETWORKS = exports.GET_KEY_ACCOUNTS = exports.GET_BALANCES = exports.GET_ACCOUNT_INFO = exports.GET_ACCOUNT = void 0;
exports.GET_ACCOUNT = "/api/account";
exports.GET_ACCOUNT_INFO = "/api/accinfo";
exports.GET_BALANCES = "/api/balances";
exports.GET_KEY_ACCOUNTS = "/api/key";
exports.GET_NETWORKS = "/api/networks";
exports.GET_SYNC_INFO = "/api/sync";
exports.GET_TOKEN_BALANCE = "/api/tokenbalance";
exports.GET_TOPHOLDERS = "/api/topholders";
exports.GET_USERCOUNT = "/api/usercount";
exports.GET_TOPRAM = "/api/topram";
exports.GET_TOPSTAKE = "/api/topstake";
exports.GET_CODEHASH = "/api/codehash";
exports.GET_TOKEN_HOLDER_COUNT = "/api/holdercount";
exports.GET_TOKEN_HOLDERS = "get_token_holders";
exports.GET_ACCOUNTS_FROM_KEYS = "get_accounts_from_keys";
//# sourceMappingURL=endpoints.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/jsonrpc.js":
/*!************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/jsonrpc.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpc = void 0;
var endpoints_1 = __webpack_require__(/*! ./endpoints */ "./node_modules/@proton/light-api/dist/src/endpoints.js");
var rpcerror_1 = __webpack_require__(/*! ./rpcerror */ "./node_modules/@proton/light-api/dist/src/rpcerror.js");
var cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
var jsonrpc2_ws_1 = __webpack_require__(/*! jsonrpc2-ws */ "./node_modules/jsonrpc2-ws/lib/index.js");
var chainToEndpoint = {
    eos: "https://api.light.xeos.me",
    telos: "https://api.light.xeos.me",
    jungle: "https://lightapi.eosgeneva.io",
    bos: "https://lightapi.eosamsterdam.net",
    instar: "https://lightapi.eosamsterdam.net",
    proton: "https://proton.light-api.net",
    wax: "https://lightapi.eosamsterdam.net",
    worbli: "https://lightapi.eosamsterdam.net",
    xec: "https://lightapi.eosamsterdam.net",
    protontest: "https://testnet-lightapi.eosams.xeos.me",
    telostest: "https://testnet-lightapi.eosams.xeos.me",
    waxtest: "https://testnet-lightapi.eosams.xeos.me",
    coffe: "https://hyperion.coffe.io",
};
function fetchWithTimeout(resource, options) {
    return __awaiter(this, void 0, void 0, function () {
        var timeout, controller, id, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    timeout = options.timeout;
                    controller = new AbortController();
                    id = setTimeout(function () { return controller.abort(); }, timeout);
                    return [4 /*yield*/, (0, cross_fetch_1.default)(resource, __assign(__assign({}, (options || {})), { signal: controller.signal }))];
                case 1:
                    response = _a.sent();
                    clearTimeout(id);
                    return [2 /*return*/, response];
            }
        });
    });
}
/**
 * JsonRpc
 *
 * @param {string} endpoint LIGHT API endpoint
 * @example
 *
 * const rpc = new JsonRpc("proton")
 */
var JsonRpc = /** @class */ (function () {
    function JsonRpc(chain, args) {
        if (args === void 0) { args = {}; }
        this.timeout = 5000;
        this.wsRequestId = 100;
        this.chain = chain;
        this.endpoint = args.endpoint || chainToEndpoint[chain];
        this.wsClient = new jsonrpc2_ws_1.Client(this.endpoint.replace('https:', 'wss:') + '/wsapi');
        if (!this.endpoint) {
            throw new Error("Chain ".concat(chain, " does not have a default endpoint, provide one in args"));
        }
        if (args.timeout) {
            this.timeout = args.timeout;
        }
    }
    /**
     * get
     *
     * GET `params` to `endpoint + path`.
     * Throws detailed error information in `RpcError` when available.
     *
     * @private
     */
    JsonRpc.prototype.get = function (path, endpoint) {
        if (endpoint === void 0) { endpoint = this.endpoint; }
        return __awaiter(this, void 0, void 0, function () {
            var response, json, url, text, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = endpoint + path;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, fetchWithTimeout(url, {
                                method: "GET",
                                timeout: this.timeout,
                            })];
                    case 2:
                        response = _a.sent();
                        if (response.status !== 200) {
                            throw new rpcerror_1.RpcStatusError(response);
                        }
                        return [4 /*yield*/, response.text()];
                    case 3:
                        text = _a.sent();
                        try {
                            json = JSON.parse(text);
                            if (json.processed && json.processed.except) {
                                throw new rpcerror_1.RpcError(json);
                            }
                        }
                        catch (_b) {
                            json = text;
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        e_1.isFetchError = true;
                        throw e_1;
                    case 5:
                        if (!response.ok) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * [GET /api/account]
     *
     * Retrieve all token balances, resources and authorization information for an account:
     *
     * @param {string} accountName name of account
     * @returns {Promise<GetAccount>} account
     */
    JsonRpc.prototype.get_account = function (accountName) {
        var url = "".concat(endpoints_1.GET_ACCOUNT, "/").concat(this.chain, "/").concat(accountName);
        return this.get(url);
    };
    /**
     * [GET /api/accinfo]
     *
     * Retrieve all resources and authorization information for an account:
     *
     * @param {string} accountName name of account
     * @returns {Promise<GetAccountInfo>} account
     */
    JsonRpc.prototype.get_account_info = function (accountName) {
        var url = "".concat(endpoints_1.GET_ACCOUNT_INFO, "/").concat(this.chain, "/").concat(accountName);
        return this.get(url);
    };
    /**
     * [GET /api/balances]
     *
     * Retrieve only token balances for an account
     *
     * @param {string} accountName name of account
     * @returns {Promise<GetBalances>} balances
     */
    JsonRpc.prototype.get_balances = function (accountName) {
        var url = "".concat(endpoints_1.GET_BALANCES, "/").concat(this.chain, "/").concat(accountName);
        return this.get(url);
    };
    /**
     * [GET /api/key]
     *
     * Retrieve all accounts in all known EOS networks dependent on a public key:
     *
     * @param {string} key public key
     * @returns {Promise<GetKeyAccounts[]>} accounts per network
     */
    JsonRpc.prototype.get_all_key_accounts = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = __spreadArray([], __read(new Set(Object.values(chainToEndpoint))), false).map(function (endpoint) {
                            var url = "".concat(endpoints_1.GET_KEY_ACCOUNTS, "/").concat(key);
                            return _this.get(url, endpoint);
                        });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * [GET /api/key]
     *
     * Retrieve all accounts in network
     *
     * @param {string} key public key
     * @returns {Promise<GetKeyAccounts>} accounts
     */
    JsonRpc.prototype.get_key_accounts = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                url = "".concat(endpoints_1.GET_KEY_ACCOUNTS, "/").concat(key);
                return [2 /*return*/, this.get(url)];
            });
        });
    };
    /**
     * [GET /api/networks]
     *
     * Retrieve all accounts in all known EOS networks dependent on a public key:
     *
     * @returns {Promise<GetNetworks>} accounts
     */
    JsonRpc.prototype.get_networks = function () {
        return this.get(endpoints_1.GET_NETWORKS);
    };
    /**
     * [GET /api/sync]
     *
     * returns a plain text with delay in seconds that this server's blockchain database is behind the real time, and a status: OK if the delay is within 180 seconds, or 'OUT_OF_SYNC' otherwise.
     *
     * @returns {Promise<string>} get sync
     */
    JsonRpc.prototype.get_sync_info = function () {
        var url = "".concat(endpoints_1.GET_SYNC_INFO, "/").concat(this.chain);
        return this.get(url);
    };
    /**
     * [GET /api/tokenbalance]
     *
     *  returns a plain text with numeric output indicating the token balance. Zero is returned if the token is not present or does not exist.
     *
     * @param {string} account owner of token
     * @param {string} contract token contract
     * @param {string} token token symbol
     * @returns {Promise<string>} token balance
     */
    JsonRpc.prototype.get_token_balance = function (account, contract, token) {
        var url = "".concat(endpoints_1.GET_TOKEN_BALANCE, "/").concat(this.chain, "/").concat(account, "/").concat(contract, "/").concat(token);
        return this.get(url);
    };
    /**
     * [GET /api/topholders]
     *
     * returns top NUM holders of a specified token in a JSON array containing arrays of (account, amount) pairs. NUM must not be less than 10 or more than 1000.
     *
     * @param {string} contract token contract
     * @param {string} token token symbol
     * @param {string} num number of top holders (min 10, max 1000)
     *
     * @returns {Promise<string>} token balance
     */
    JsonRpc.prototype.get_topholders = function (contract, token, num) {
        var url = "".concat(endpoints_1.GET_TOPHOLDERS, "/").concat(this.chain, "/").concat(contract, "/").concat(token, "/").concat(num);
        return this.get(url);
    };
    /**
     * [GET /api/usercount]
     *
     * returns a plain text with total number of accounts in the network.
     *
     * @returns {Promise<string>} token balance
     */
    JsonRpc.prototype.get_usercount = function () {
        var url = "".concat(endpoints_1.GET_USERCOUNT, "/").concat(this.chain);
        return this.get(url);
    };
    /**
     * [GET /api/topram]
     *
     * returns top NUM RAM buyers in a JSON array containing arrays of (account, bytes) pairs. NUM must not be less than 10 or more than 1000.
     *
     * @param {string} num number of top holders (min 10, max 1000)
     *
     * @returns {Promise<GetTopRam>} top ram holders
     */
    JsonRpc.prototype.get_topram = function (num) {
        var url = "".concat(endpoints_1.GET_TOPRAM, "/").concat(this.chain, "/").concat(num);
        return this.get(url);
    };
    /**
     * [GET /api/topstake]
     *
     * returns top NUM RAM buyers in a JSON array containing arrays of (account, bytes) pairs. NUM must not be less than 10 or more than 1000.
     *
     * @param {string} num returns top NUM stake holders by sum of CPU and Net stakes, in a JSON array containing arrays of (account, cpu_weight, net_weight) tuples. NUM must not be less than 10 or more than 1000.
     *
     * @returns {Promise<GetTopStake>} top stake holders
     */
    JsonRpc.prototype.get_topstake = function (num) {
        var url = "".concat(endpoints_1.GET_TOPSTAKE, "/").concat(this.chain, "/").concat(num);
        return this.get(url);
    };
    /**
     * [GET /api/codehash]
     *
     * retrieves all accounts in all known EOS networks by contract hash.
     *
     * @param {string} num returns top NUM stake holders by sum of CPU and Net stakes, in a JSON array containing arrays of (account, cpu_weight, net_weight) tuples. NUM must not be less than 10 or more than 1000.
     *
     * @returns {Promise<GetCodehash>} accounts
     */
    JsonRpc.prototype.get_codehash = function (hash) {
        var url = "".concat(endpoints_1.GET_CODEHASH, "/").concat(hash);
        return this.get(url);
    };
    /**
     * [GET /api/holdercount]
     *
     * returns a plaintext integer indicating the number of accounts with positive balance for a specified token.
     *
     * @param {string} contract token contract
     * @param {string} token token symbol
     *
     * @returns {Promise<number>} count
     */
    JsonRpc.prototype.get_tokenholder_count = function (contract, token) {
        var url = "".concat(endpoints_1.GET_TOKEN_HOLDER_COUNT, "/").concat(this.chain, "/").concat(contract, "/").concat(token);
        return this.get(url);
    };
    /**
     * [WS get_token_holders]
     *
     * Get all token holders of a contract and symbol
     *
     * @param contract token contract
     * @param token token symbol
     * @returns
     */
    JsonRpc.prototype.get_token_holders = function (contract, token) {
        var _this = this;
        var reqId = ++this.wsRequestId;
        var balances = [];
        return new Promise(function (resolve, reject) {
            _this.wsClient.on('error', function (err) { return reject(err); });
            _this.wsClient.methods.set('reqdata', function (_, params) {
                if (params.end) {
                    resolve(balances);
                }
                balances.push({
                    account: params.data.account,
                    amount: +params.data.amount,
                });
            });
            try {
                _this.wsClient.call(endpoints_1.GET_TOKEN_HOLDERS, {
                    reqid: reqId,
                    network: _this.chain,
                    contract: contract,
                    currency: token,
                });
            }
            catch (err) {
                reject(err);
                return;
            }
        });
    };
    /**
     * [WS get_accounts_from_keys]
     *
     * Get all token holders of a contract and symbol
     *
     * @param keys[] array of keys
     * @returns
     */
    JsonRpc.prototype.get_accounts_from_keys = function (keys) {
        var _this = this;
        var reqId = ++this.wsRequestId;
        var accounts = [];
        return new Promise(function (resolve, reject) {
            _this.wsClient.on('error', function (err) { return reject(err); });
            _this.wsClient.methods.set('reqdata', function (_, params) {
                if (params.end) {
                    resolve(accounts);
                }
                accounts.push({
                    account_name: params.data.account_name,
                    perm: params.data.perm,
                    weight: +params.data.weight,
                    pubkey: params.data.pubkey,
                });
            });
            try {
                _this.wsClient.call(endpoints_1.GET_ACCOUNTS_FROM_KEYS, {
                    reqid: reqId,
                    network: _this.chain,
                    keys: keys,
                });
            }
            catch (err) {
                reject(err);
                return;
            }
        });
    };
    return JsonRpc;
}());
exports.JsonRpc = JsonRpc;
//# sourceMappingURL=jsonrpc.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/rpcerror.js":
/*!*************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/rpcerror.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcStatusError = exports.RpcError = void 0;
/**
 * @private
 * @module RPC-Error
 *
 * copyright defined in eosjs/LICENSE.txt
 */
var RpcError = /** @class */ (function (_super) {
    __extends(RpcError, _super);
    function RpcError(json) {
        var _this = this;
        if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
        }
        else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
        }
        else {
            _this = _super.call(this, json.message) || this;
        }
        Object.setPrototypeOf(_this, RpcError.prototype);
        _this.json = json;
        return _this;
    }
    return RpcError;
}(Error));
exports.RpcError = RpcError;
/**
 * @private
 */
var RpcStatusError = /** @class */ (function (_super) {
    __extends(RpcStatusError, _super);
    function RpcStatusError(response) {
        var _this = this;
        if (response.status === 405) {
            _this = _super.call(this, response.statusText) || this;
        }
        else {
            _this = _super.call(this) || this;
        }
        Object.setPrototypeOf(_this, RpcStatusError.prototype);
        _this.response = response;
        return _this;
    }
    return RpcStatusError;
}(Error));
exports.RpcStatusError = RpcStatusError;
//# sourceMappingURL=rpcerror.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/types/api.js":
/*!**************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/types/api.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/dist/wrap-constants.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/dist/wrap-constants.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Chains": () => (/* binding */ Chains),
/* harmony export */   "ExtendedAssetParser": () => (/* binding */ ExtendedAssetParser),
/* harmony export */   "Networks": () => (/* binding */ Networks),
/* harmony export */   "Status": () => (/* binding */ Status),
/* harmony export */   "Type": () => (/* binding */ Type),
/* harmony export */   "WRAP_AUTH_ACTION": () => (/* binding */ WRAP_AUTH_ACTION),
/* harmony export */   "WRAP_CONTRACT": () => (/* binding */ WRAP_CONTRACT),
/* harmony export */   "accountParser": () => (/* binding */ accountParser),
/* harmony export */   "addressParser": () => (/* binding */ addressParser),
/* harmony export */   "authorizationParser": () => (/* binding */ authorizationParser),
/* harmony export */   "authorizationsParser": () => (/* binding */ authorizationsParser),
/* harmony export */   "baseActionParser": () => (/* binding */ baseActionParser),
/* harmony export */   "baseActionSerializedParser": () => (/* binding */ baseActionSerializedParser),
/* harmony export */   "createAbstractAuthParser": () => (/* binding */ createAbstractAuthParser),
/* harmony export */   "depositBodyParser": () => (/* binding */ depositBodyParser),
/* harmony export */   "exchangeRateParser": () => (/* binding */ exchangeRateParser),
/* harmony export */   "exchangeRatesParser": () => (/* binding */ exchangeRatesParser),
/* harmony export */   "explorerLinkByChain": () => (/* binding */ explorerLinkByChain),
/* harmony export */   "generateAddressBodyParser": () => (/* binding */ generateAddressBodyParser),
/* harmony export */   "generateAddressResponse": () => (/* binding */ generateAddressResponse),
/* harmony export */   "generateAuthParser": () => (/* binding */ generateAuthParser),
/* harmony export */   "initializeCoins": () => (/* binding */ initializeCoins),
/* harmony export */   "initializeConstants": () => (/* binding */ initializeConstants),
/* harmony export */   "isSameToken": () => (/* binding */ isSameToken),
/* harmony export */   "otcOrderResponseParser": () => (/* binding */ otcOrderResponseParser),
/* harmony export */   "otcQuoteBodyParser": () => (/* binding */ otcQuoteBodyParser),
/* harmony export */   "otcQuoteResponseParser": () => (/* binding */ otcQuoteResponseParser),
/* harmony export */   "rateParser": () => (/* binding */ rateParser),
/* harmony export */   "similarChains": () => (/* binding */ similarChains),
/* harmony export */   "singleActionTransactionParser": () => (/* binding */ singleActionTransactionParser),
/* harmony export */   "transactionParser": () => (/* binding */ transactionParser),
/* harmony export */   "webauthActionParser": () => (/* binding */ webauthActionParser),
/* harmony export */   "withdrawBodyParser": () => (/* binding */ withdrawBodyParser),
/* harmony export */   "withdrawHistoryMetalResponseParser": () => (/* binding */ withdrawHistoryMetalResponseParser),
/* harmony export */   "withdrawHistoryMetalSwapParser": () => (/* binding */ withdrawHistoryMetalSwapParser),
/* harmony export */   "withdrawMetalResponseParser": () => (/* binding */ withdrawMetalResponseParser),
/* harmony export */   "withdrawalFeeQuoteParser": () => (/* binding */ withdrawalFeeQuoteParser),
/* harmony export */   "wrapParser": () => (/* binding */ wrapParser),
/* harmony export */   "wrapSetConfParser": () => (/* binding */ wrapSetConfParser),
/* harmony export */   "wrapStartParser": () => (/* binding */ wrapStartParser)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js");
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zod__WEBPACK_IMPORTED_MODULE_0__);


var _similarChains, _explorerLinkByChain;

var Chains;

(function (Chains) {
  Chains["BitcoinMainnet"] = "Bitcoin";
  Chains["BitcoinTestnet"] = "Bitcoin (Testnet)";
  Chains["EthereumMainnet"] = "Ethereum";
  Chains["EthereumRopsten"] = "Ethereum (Ropsten)";
  Chains["LitecoinMainnet"] = "Litecoin";
  Chains["LitecoinTestnet"] = "Litecoin (Testnet)";
  Chains["BitcoinCashMainnet"] = "Bitcoin Cash";
  Chains["BitcoinCashTestnet"] = "Bitcoin Cash (Testnet)";
  Chains["StellarMainnet"] = "Stellar";
  Chains["StellarTestnet"] = "Stellar (Testnet)";
  Chains["ProtonMainnet"] = "Proton";
  Chains["ProtonTestnet"] = "Proton (Testnet)";
  Chains["PolkadotMainnet"] = "Polkadot";
  Chains["BinanceBEP2"] = "Binance (BEP2)";
  Chains["BinanceBEP20"] = "Binance (BEP20)";
  Chains["EosMainnet"] = "EOS";
  Chains["EosTestnet"] = "EOS (Jungle Testnet)";
  Chains["HederaMainnet"] = "Hedera (Mainnet)";
  Chains["HederaTestnet"] = "Hedera (Testnet)";
  Chains["DogeMainnet"] = "Dogecoin";
  Chains["CardanoMainnet"] = "Cardano";
  Chains["AvalancheXChain"] = "Avalanche X-Chain";
  Chains["AvalancheCChain"] = "Avalanche C-Chain";
  Chains["PolygonMainnet"] = "Polygon";
  Chains["TerraMainnet"] = "Terra";
})(Chains || (Chains = {}));

var Networks;

(function (Networks) {
  Networks["Mainnet"] = "mainnet";
  Networks["Testnet"] = "testnet";
  Networks["Ropsten"] = "ropsten";
  Networks["ERC20"] = "erc20";
  Networks["BEP20"] = "bep20";
  Networks["XLM"] = "xlm";
})(Networks || (Networks = {}));

var similarChains = (_similarChains = {}, _similarChains[Chains.EthereumMainnet] = [Chains.BinanceBEP20], _similarChains[Chains.BinanceBEP20] = [Chains.EthereumMainnet], _similarChains);
var explorerLinkByChain = (_explorerLinkByChain = {}, _explorerLinkByChain[Chains.BitcoinMainnet] = function (txid) {
  return "https://blockchain.com/btc/tx/" + txid;
}, _explorerLinkByChain[Chains.BitcoinTestnet] = function (txid) {
  return "https://blockstream.info/testnet/tx/" + txid;
}, _explorerLinkByChain[Chains.EthereumMainnet] = function (txid) {
  return "https://etherscan.io/tx/" + txid;
}, _explorerLinkByChain[Chains.EthereumRopsten] = function (txid) {
  return "https://ropsten.etherscan.io/tx/" + txid;
}, _explorerLinkByChain[Chains.LitecoinMainnet] = function (txid) {
  return "https://blockchair.com/litecoin/transaction/" + txid;
}, _explorerLinkByChain[Chains.LitecoinTestnet] = function (txid) {
  return "https://blockexplorer.one/litecoin/testnet/blockHash/" + txid;
}, _explorerLinkByChain[Chains.BitcoinCashMainnet] = function (txid) {
  return "https://blockchair.com/bitcoin-cash/transaction/" + txid;
}, _explorerLinkByChain[Chains.BitcoinCashTestnet] = function (txid) {
  return "https://blockexplorer.one/bitcoin-cash/testnet/blockHash/" + txid;
}, _explorerLinkByChain[Chains.StellarMainnet] = function (txid) {
  return "https://blockchair.com/stellar/transaction/" + txid;
}, _explorerLinkByChain[Chains.StellarTestnet] = function (txid) {
  return "https://testnet.steexp.com/tx/" + txid;
}, _explorerLinkByChain[Chains.ProtonMainnet] = function (txid) {
  return "https://proton.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.ProtonTestnet] = function (txid) {
  return "https://proton-test.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.PolkadotMainnet] = function (txid) {
  return "https://polkadot.subscan.io/extrinsic/" + txid;
}, _explorerLinkByChain[Chains.BinanceBEP2] = function (txid) {
  return "https://binance.mintscan.io/txs/" + txid;
}, _explorerLinkByChain[Chains.BinanceBEP20] = function (txid) {
  return "https://bscscan.com/tx/" + txid;
}, _explorerLinkByChain[Chains.EosMainnet] = function (txid) {
  return "https://bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.EosTestnet] = function (txid) {
  return "https://jungle.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.HederaMainnet] = function (txid) {
  return "https://app.dragonglass.me/transactions/" + txid;
}, _explorerLinkByChain[Chains.HederaTestnet] = function (txid) {
  return "https://testnet.dragonglass.me/transactions/" + txid;
}, _explorerLinkByChain[Chains.DogeMainnet] = function (txid) {
  return "https://blockchair.com/dogecoin/transaction/" + txid;
}, _explorerLinkByChain[Chains.CardanoMainnet] = function (txid) {
  return "https://explorer.cardano.org/en/transaction?id=" + txid;
}, _explorerLinkByChain[Chains.AvalancheXChain] = function (txid) {
  return "https://avascan.info/blockchain/x/tx/" + txid;
}, _explorerLinkByChain[Chains.AvalancheCChain] = function (txid) {
  return "https://snowtrace.io/tx/" + txid;
}, _explorerLinkByChain[Chains.PolygonMainnet] = function (txid) {
  return "https://polygonscan.com/tx/" + txid;
}, _explorerLinkByChain[Chains.TerraMainnet] = function (txid) {
  return "https://terra.stake.id/?#/tx/" + txid;
}, _explorerLinkByChain);
var initializeCoins = function initializeCoins(protonChain) {
  var IS_MAINNET = protonChain === 'proton';
  var IS_TESTNET = protonChain === 'proton-test';
  var coins = [{
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Proton',
    coin: 'XPR',
    xtokenSymbol: 'XPR',
    xtokenPrecision: 4,
    xtokenContract: 'eosio.token',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'XPR-ERC20',
      symbol: 'XPR',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 4,
      contract: '0xD7EFB00D12C2C13131FD319336FDF952525DA2AF',
      hasWithdrawMemo: false
    }, {
      wallet: 'XPR-BEP20',
      symbol: 'XPR',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 4,
      contract: '0x5DE3939B2F811A61D830E6F52D13B066881412AB',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/eosio-tokenXPR.png',
    coingeckoId: 'proton'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'USD Coin',
    coin: 'USDC',
    xtokenSymbol: 'XUSDC',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'USDC',
      symbol: 'USDC',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 6,
      contract: '0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48',
      hasWithdrawMemo: false
    }, {
      wallet: 'USDC-BEP20',
      symbol: 'USDC',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: '0x8AC76A51CC950D9822D68B83FE1AD97B32CD580D',
      hasWithdrawMemo: false
    }, {
      wallet: 'USDC-XLM',
      symbol: 'USDC',
      chain: Chains.StellarMainnet,
      network: Networks.XLM,
      precision: 7,
      contract: undefined,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'USDC',
      symbol: 'USDC',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 6,
      contract: '0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUSDC.png',
    coingeckoId: 'usd-coin'
  }, {
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Metal',
    coin: 'MTL',
    xtokenSymbol: 'XMT',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'MTL',
      symbol: 'MTL',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 8,
      contract: '0xF433089366899D83A9F26A773D59EC7ECF30355E',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXMT.png',
    coingeckoId: 'metal'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'Bitcoin',
    coin: 'BTC',
    xtokenSymbol: 'XBTC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BTC',
      symbol: 'BTC',
      chain: Chains.BitcoinMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'BTC',
      symbol: 'BTC',
      chain: Chains.BitcoinTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXBTC.png',
    coingeckoId: 'bitcoin'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'Ethereum',
    coin: 'ETH',
    xtokenSymbol: 'XETH',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'ETH',
      symbol: 'ETH',
      chain: Chains.EthereumMainnet,
      network: Networks.Mainnet,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'ETH',
      symbol: 'ETH',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXETH.png',
    coingeckoId: 'ethereum'
  }, {
    allowSwap: true,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Loan',
    coin: 'LOAN',
    xtokenSymbol: 'LOAN',
    xtokenPrecision: 4,
    xtokenContract: 'loan.token',
    wallets: [],
    image: 'https://www.protonchain.com/images/tokens/loan.tokenLOAN.png',
    coingeckoId: 'proton-loan'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Tether',
    coin: 'USDT',
    xtokenSymbol: 'XUSDT',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'USDT',
      symbol: 'USDT',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 6,
      contract: '0xDAC17F958D2EE523A2206206994597C13D831EC7',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'USDT',
      symbol: 'USDT',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 6,
      contract: '0xDAC17F958D2EE523A2206206994597C13D831EC7',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUSDT.png',
    coingeckoId: 'tether'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'TrueUSD',
    coin: 'TUSD',
    xtokenSymbol: 'XTUSD',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'TUSD',
      symbol: 'TUSD',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x0000000000085D4780B73119B644AE5ECD22B376',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXTUSD.png',
    coingeckoId: 'true-usd'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Paxos Standard',
    coin: 'PAX',
    xtokenSymbol: 'XPAX',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'PAX',
      symbol: 'PAX',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x8E870D67F660D95D5BE530380D0EC0BD388289E1',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXPAX.png',
    coingeckoId: 'usdp'
  }, {
    allowSwap: false,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Paxos Gold',
    coin: 'PAXG',
    xtokenSymbol: 'XPAXG',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'PAXG',
      symbol: 'PAXG',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x45804880DE22913DAFE09F4980848ECE6ECBAF78',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'PAXG',
      symbol: 'PAXG',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x45804880DE22913DAFE09F4980848ECE6ECBAF78',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXPAXG.png',
    coingeckoId: 'pax-gold'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Uniswap',
    coin: 'UNI',
    xtokenSymbol: 'XUNI',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'UNI',
      symbol: 'UNI',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x1F9840A85D5AF5BF1D1762F925BDADDC4201F984',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'UNI',
      symbol: 'UNI',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x1F9840A85D5AF5BF1D1762F925BDADDC4201F984',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUNI.png',
    coingeckoId: 'uniswap'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: '1INCH',
    coin: '1INCH',
    xtokenSymbol: 'XINCH',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: '1INCH',
      symbol: '1INCH',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x111111111117DC0AA78B770FA6A738034120C302',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXINCH.png',
    coingeckoId: '1inch'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Chainlink',
    coin: 'LINK',
    xtokenSymbol: 'XLINK',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LINK',
      symbol: 'LINK',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x514910771AF9CA656AF840DFF83E8264ECF986CA',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXLINK.png',
    coingeckoId: 'chainlink'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Litecoin',
    coin: 'LTC',
    xtokenSymbol: 'XLTC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LTC',
      symbol: 'LTC',
      chain: Chains.LitecoinMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'LTC',
      symbol: 'LTC',
      chain: Chains.LitecoinTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXLTC.png',
    coingeckoId: 'litecoin'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Bitcoin Cash',
    coin: 'BCH',
    xtokenSymbol: 'XBCH',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BCH',
      symbol: 'BCH',
      chain: Chains.BitcoinCashMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'BCH',
      symbol: 'BCH',
      chain: Chains.BitcoinCashTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXBCH.png',
    coingeckoId: 'bitcoin-cash'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Stellar',
    coin: 'XLM',
    xtokenSymbol: 'XXLM',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'XLM',
      symbol: 'XLM',
      chain: Chains.StellarMainnet,
      network: Networks.Mainnet,
      precision: 7,
      contract: undefined,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'XLM',
      symbol: 'XLM',
      chain: Chains.StellarTestnet,
      network: Networks.Testnet,
      precision: 7,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXXLM.png',
    coingeckoId: 'stellar'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Sense',
    coin: 'SENSE',
    xtokenSymbol: 'XSENSE',
    xtokenPrecision: 4,
    xtokenContract: 'sense',
    wallets: [],
    image: 'https://www.protonchain.com/images/tokens/senseXSENSE.png',
    coingeckoId: 'sense'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Polkadot',
    coin: 'DOT',
    xtokenSymbol: 'XDOT',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'DOT',
      symbol: 'DOT',
      chain: Chains.PolkadotMainnet,
      network: Networks.Mainnet,
      precision: 10,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXDOT.png',
    coingeckoId: 'polkadot'
  }, {
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Binance Coin',
    coin: 'BNB',
    xtokenSymbol: 'XBNB',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BNB',
      symbol: 'BNB',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXBNB.png',
    coingeckoId: 'binancecoin'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'EOS',
    coin: 'EOS',
    xtokenSymbol: 'XEOS',
    xtokenPrecision: 4,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'EOS',
      symbol: 'EOS',
      chain: Chains.EosMainnet,
      network: Networks.Mainnet,
      precision: 4,
      contract: undefined,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'EOS',
      symbol: 'EOS',
      chain: Chains.EosTestnet,
      network: Networks.Testnet,
      precision: 4,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXEOS.png',
    coingeckoId: 'eos'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Dogecoin',
    coin: 'DOGE',
    xtokenSymbol: 'XDOGE',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'DOGE',
      symbol: 'DOGE',
      chain: Chains.DogeMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXDOGE.png',
    coingeckoId: 'dogecoin'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Cardano',
    coin: 'ADA',
    xtokenSymbol: 'XADA',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'ADA',
      symbol: 'ADA',
      chain: Chains.CardanoMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXADA.png',
    coingeckoId: 'cardano'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Avalanche',
    coin: 'AVAX',
    xtokenSymbol: 'XAVAX',
    xtokenPrecision: 9,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'AVAX',
      symbol: 'AVAX',
      chain: Chains.AvalancheXChain,
      network: Networks.Mainnet,
      precision: 9,
      contract: undefined,
      hasWithdrawMemo: false
    }, {
      wallet: 'AVAX',
      symbol: 'AVAX',
      chain: Chains.AvalancheCChain,
      network: Networks.Mainnet,
      precision: 9,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXAVAX.png',
    coingeckoId: 'avalanche-2'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Polygon',
    coin: 'MATIC',
    xtokenSymbol: 'XMATIC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'MATIC',
      symbol: 'MATIC',
      chain: Chains.PolygonMainnet,
      network: Networks.Mainnet,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXMATIC.png',
    coingeckoId: 'matic-network'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Luna',
    coin: 'LUNA',
    xtokenSymbol: 'XLUNA',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LUNA',
      symbol: 'LUNA',
      chain: Chains.TerraMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXLUNA.png',
    coingeckoId: 'terra-luna'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'TerraUSD',
    coin: 'UST',
    xtokenSymbol: 'XUST',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'UST',
      symbol: 'UST',
      chain: Chains.TerraMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUST.png',
    coingeckoId: 'terrausd'
  }, {
    allowSwap: false,
    allowBridge: IS_TESTNET,
    allowLend: false,
    allowBorrow: false,
    name: 'HBAR',
    coin: 'HBAR',
    xtokenSymbol: 'XHBAR',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_TESTNET ? [{
      wallet: 'HBAR',
      symbol: 'HBAR',
      chain: Chains.HederaTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXHBAR.png',
    coingeckoId: 'hedera-hashgraph'
  }]; // Validation

  var walletWithDuplicateChains = coins.find(function (coin) {
    var chains = coin.wallets.map(function (wallet) {
      return wallet.chain;
    });
    return new Set(chains).size !== chains.length;
  });

  if (walletWithDuplicateChains) {
    throw new Error("Coin " + walletWithDuplicateChains.coin + " has duplicate chains in wallet");
  }

  return {
    allCoins: coins,
    swapCoins: coins.filter(function (coin) {
      return coin.allowSwap;
    }),
    bridgeCoins: coins.filter(function (coin) {
      return coin.allowBridge;
    }),
    lendCoins: coins.filter(function (coin) {
      return coin.allowLend;
    }),
    borrowCoins: coins.filter(function (coin) {
      return coin.allowBorrow;
    }),
    loanCoins: coins.filter(function (coin) {
      return coin.allowLend || coin.allowBorrow;
    }),
    allEnabledCoins: coins.filter(function (coin) {
      return coin.allowSwap || coin.allowBridge;
    })
  };
};

var accountParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().regex(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
var authorizationParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  actor: accountParser,
  permission: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var authorizationsParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(authorizationParser).min(1);
var ExtendedAssetParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  quantity: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  contract: accountParser
});

var rawTransactionParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  expiration: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  ref_block_num: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  ref_block_prefix: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  max_net_usage_words: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  max_cpu_usage_ms: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  delay_sec: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  context_free_actions: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)( /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.any)()),
  transaction_extensions: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)( /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.any)())
});
var baseActionParser = function baseActionParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    account: contract === '*' ? accountParser : (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(contract),
    name: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(action),
    data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)(data),
    authorization: authorizationsParser
  });
};
var baseActionSerializedParser = function baseActionSerializedParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    account: contract === '*' ? accountParser : (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(contract),
    name: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(action),
    data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().or((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)(data)),
    authorization: authorizationsParser
  });
};
var webauthActionParser = function webauthActionParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    account: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)('webauthn'),
    name: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)('exec'),
    data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
      account: accountParser,
      key: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
        key: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)((0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().or((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
          modulus: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
          exponent: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
        }))),
        user_presence: (0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
        rpid: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
      }),
      nonce: (0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
      permissions: authorizationsParser,
      signature: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
        auth_data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
        client_json: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
        signature: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
      }),
      trx: rawTransactionParser.merge((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
        actions: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(baseActionSerializedParser(contract, action, data)).length(1)
      }))
    }),
    authorization: authorizationsParser
  });
};
var singleActionTransactionParser = function singleActionTransactionParser(contract, action, data) {
  var baseAction = baseActionParser(contract, action, data);
  var webauthAction = webauthActionParser(contract, action, data);
  return rawTransactionParser.merge((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    actions: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(baseAction.or(webauthAction)).length(1)
  }));
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var WRAP_CONTRACT = 'proton.wrap';
var WRAP_AUTH_ACTION = 'generateauth';
var initializeConstants = function initializeConstants(chain) {
  var _initializeCoins = initializeCoins(chain),
      swapCoins = _initializeCoins.swapCoins,
      bridgeCoins = _initializeCoins.bridgeCoins,
      allEnabledCoins = _initializeCoins.allEnabledCoins,
      allCoins = _initializeCoins.allCoins,
      lendCoins = _initializeCoins.lendCoins,
      borrowCoins = _initializeCoins.borrowCoins,
      loanCoins = _initializeCoins.loanCoins;

  var constants = {
    SWAP_CONTRACT: 'proton.swaps',
    FEE_FACTOR: 10000,
    GOOGLE_MAPS_KEY: 'AIzaSyDb2_CrK032kSIqBXbkdwmaLKWELl0SxVs',
    SWAP_URL: chain === 'proton' ? 'https://otc.protonswap.com' : 'https://otc-test.protonswap.com',
    WRAP_SERVER_URL: chain === 'proton' ? 'https://www.api.bloks.io/proton-wrap-public2' : 'https://www.api.bloks.io/proton-wrap-testnet-public2',
    WRAP_CONTRACT: WRAP_CONTRACT,
    WRAP_ACTIONS: {
      SAVE_ADDRESS: 'saveaddress2',
      DELETE_ADDRESS: 'deladdress2',
      WRAP_START: 'wrapstart2',
      WRAP_FINISH: 'wrapfinish2',
      WRAP_PROCESS: 'wrapprocess2',
      WRAP_SET_CONF: 'wrapsetconf2'
    },
    WRAP_TABLES: {
      ADDRESSES: 'addresses2',
      WRAPS: 'wraps2'
    },
    ADDRESSES_INDEXES: {
      BY_ACCOUNT: 2,
      BY_ADDR_HASH: 3
    },
    WRAPS_INDEXES: {
      BY_ACCOUNT: 2,
      BY_STATUS: 3,
      BY_WRAP_HASH: 4
    },
    WRAP_PROCESS_TIMER: 5000,
    FARM_CONTRACT: 'yield.farms',
    WEBHOOK_PERMISSION: 'webhook',
    PUBLIC_PERMISSION: 'public',
    LIGHT_PERMISSION: 'light',
    WRAP_AUTH_ACTION: WRAP_AUTH_ACTION,
    METAL_ENDPOINT: chain === 'proton' ? 'https://cirrus.metalpay.com' : 'https://cirrus-dev.metalpay.com',
    METAL_PROTON_ENDPOINT: chain === 'proton' ? 'https://api.protonchain.com' : 'https://api-dev.protonchain.com',
    PROTON_ENDPOINTS: chain === 'proton' ? ['https://proton.greymass.com', 'https://proton.eoscafeblock.com', 'https://proton.cryptolions.io', 'https://proton.eosusa.news'] : ['https://testnet.protonchain.com'],
    CHAIN_ID: chain === 'proton' ? '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0' : '71ee83bcf52142d61019d95f9cc5427ba6a0d7ff8accd9e2088ae2abeaf3d3dd',
    CHAIN: chain,
    SWAP_COINS: swapCoins,
    BRIDGE_COINS: bridgeCoins,
    ALL_ENABLED_COINS: allEnabledCoins,
    LEND_COINS: lendCoins,
    BORROW_COINS: borrowCoins,
    LOAN_COINS: loanCoins,
    ALL_COINS: allCoins,
    findBridgeCoinWalletByXtokenAndChain: function findBridgeCoinWalletByXtokenAndChain(xtokenSymbol, chain) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.xtokenSymbol === xtokenSymbol;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.chain === chain;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    },
    findBridgeCoinWallet: function findBridgeCoinWallet(coin, wallet) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.coin === coin;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.wallet === wallet;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    },
    findBridgeCoinNetwork: function findBridgeCoinNetwork(coin, network) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.coin === coin;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.network === network;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    }
  };
  return constants;
};

var createAbstractAuthParser = function createAbstractAuthParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    signer: authorizationParser,
    signatures: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)((0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()).length(1),
    transaction: singleActionTransactionParser(contract, action, data)
  });
};
var generateAuthData = {
  time: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  protonAccount: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
};
var generateAuthParser = /*#__PURE__*/createAbstractAuthParser(WRAP_CONTRACT, WRAP_AUTH_ACTION, generateAuthData);

var addressParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  index: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  account: accountParser,
  chain: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address_hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var generateAddressBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  coin: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
}).merge(generateAuthParser);
var generateAddressResponse = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  coin: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  memo: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});

var rateParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  counterCurrency: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  price: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  priceChangePercent: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  marketCap: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  volume: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  timestamp: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});
var exchangeRateParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  contract: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  symbol: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  rank: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  rates: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(rateParser)
});
var exchangeRatesParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(exchangeRateParser);

var Type;

(function (Type) {
  Type["RECEIVE"] = "receive";
  Type["SEND"] = "send";
})(Type || (Type = {}));

var depositBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  type: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.nativeEnum)(Type),
  hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  coin: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var transactionParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  value: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  valueString: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  type: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.nativeEnum)(Type),
  state: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  blockHash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional().nullable(),
  blockHeight: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)().optional().nullable()
});

var otcOrderResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  success: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.boolean)(),
  transaction_id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  errormsg: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});
var otcQuoteBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  baseAmount: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  baseSymbol: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  quoteSymbol: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var otcQuoteResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  success: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.boolean)(),
  token: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  qty: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  errormsg: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});

var withdrawData = {
  from: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().refine(function (val) {
    return val !== WRAP_CONTRACT;
  }, {
    message: WRAP_CONTRACT + " must be receiver"
  }),
  to: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(WRAP_CONTRACT),
  quantity: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  memo: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
};
var withdrawBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  signer: authorizationParser,
  signatures: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)((0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()).length(1),
  transaction: /*#__PURE__*/singleActionTransactionParser('*', 'transfer', withdrawData),
  quoteId: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  provider: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});
var withdrawMetalResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  success: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.boolean)(),
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var withdrawalFeeQuoteParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  quoteId: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  estimatedFee: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  currency: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  network: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});

var withdrawHistoryMetalSwapParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  status: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  amount: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  currency: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  network: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  created: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  withdrawalAddress: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  withdrawalHash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});
var withdrawHistoryMetalResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  swaps: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(withdrawHistoryMetalSwapParser),
  page: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  pageSize: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  numberOfElements: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  totalPages: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  totalElements: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});

var Status;

(function (Status) {
  Status["PENDING"] = "pending";
  Status["SUCCESS"] = "success";
  Status["FAIL"] = "fail";
  Status["PROCESSING"] = "processing";
})(Status || (Status = {}));

var wrapStartParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  balance: ExtendedAssetParser,
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  txid: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  chain: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  deposit_address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});
var wrapSetConfParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  wrap_hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});
var wrapParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  index: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  proton_account: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  balance: ExtendedAssetParser,
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  txid: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  chain: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  deposit_address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  status: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.nativeEnum)(Status),
  finish_txid: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wrap_hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});

var isSameToken = function isSameToken(token1, token2) {
  return token1.xtokenSymbol === token2.xtokenSymbol && token1.xtokenPrecision === token2.xtokenPrecision && token1.xtokenContract === token2.xtokenContract;
};


//# sourceMappingURL=wrap-constants.esm.js.map


/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
exports.ZodErrorCode = util_1.util.arrayToEnum([
    'invalid_type',
    'nonempty_array_is_empty',
    'custom_error',
    'invalid_union',
    'invalid_literal_value',
    'invalid_enum_value',
    'unrecognized_keys',
    'invalid_arguments',
    'invalid_return_type',
    'invalid_date',
    'invalid_string',
    'too_small',
    'too_big',
]);
exports.quotelessJson = function (obj) {
    var json = JSON.stringify(obj, null, 2); // {"name":"John Smith"}
    return json.replace(/"([^"]+)":/g, '$1:');
};
var ZodError = /** @class */ (function (_super) {
    __extends(ZodError, _super);
    function ZodError(errors) {
        var _newTarget = this.constructor;
        var _this = _super.call(this) || this;
        _this.errors = [];
        _this.addError = function (sub) {
            _this.errors = _this.errors.concat([sub]);
        };
        _this.addErrors = function (subs) {
            if (subs === void 0) { subs = []; }
            _this.errors = _this.errors.concat(subs);
        };
        _this.flatten = function () {
            var fieldErrors = {};
            var formErrors = [];
            for (var _i = 0, _a = _this.errors; _i < _a.length; _i++) {
                var sub = _a[_i];
                if (sub.path.length > 0) {
                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                    fieldErrors[sub.path[0]].push(sub.message);
                }
                else {
                    formErrors.push(sub.message);
                }
            }
            return { formErrors: formErrors, fieldErrors: fieldErrors };
        };
        // restore prototype chain
        var actualProto = _newTarget.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(_this, actualProto);
        }
        else {
            _this.__proto__ = actualProto;
        }
        _this.errors = errors;
        return _this;
    }
    Object.defineProperty(ZodError.prototype, "message", {
        get: function () {
            // return JSON.stringify(this.errors, null, 2);
            var errorMessage = [
                this.errors.length + " validation issue(s)",
                '',
            ];
            for (var _i = 0, _a = this.errors; _i < _a.length; _i++) {
                var err = _a[_i];
                var pathString = err.path.join('.') || '[[root]]';
                errorMessage.push("  Issue #" + this.errors.indexOf(err) + ": " + err.code + " at " + pathString);
                errorMessage.push("  " + err.message);
                errorMessage.push('');
            }
            return errorMessage.join('\n');
            // return quotelessJson(this);
            // .map(({ path, message }) => {
            //   return path.length ? `${path.join('./index')}: ${message}` : `${message}`;
            // })
            // .join('\n');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodError.prototype, "isEmpty", {
        get: function () {
            return this.errors.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodError.prototype, "formErrors", {
        get: function () {
            return this.flatten();
        },
        enumerable: true,
        configurable: true
    });
    ZodError.create = function (errors) {
        var error = new ZodError(errors);
        return error;
    };
    return ZodError;
}(Error));
exports.ZodError = ZodError;
//# sourceMappingURL=ZodError.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/codegen.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/codegen.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./index */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js"));
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
var isOptional = function (schema) {
    var def = schema._def;
    if (def.t === z.ZodTypes.undefined)
        return true;
    else if (def.t === z.ZodTypes.intersection) {
        return isOptional(def.right) && isOptional(def.left);
    }
    else if (def.t === z.ZodTypes.union) {
        return def.options.map(isOptional).some(function (x) { return x === true; });
    }
    return false;
};
var ZodCodeGenerator = /** @class */ (function () {
    function ZodCodeGenerator() {
        var _this = this;
        this.seen = [];
        this.serial = 0;
        this.randomId = function () {
            return "IZod" + _this.serial++;
        };
        this.findBySchema = function (schema) {
            return _this.seen.find(function (s) { return s.schema === schema; });
        };
        this.findById = function (id) {
            var found = _this.seen.find(function (s) { return s.id === id; });
            if (!found)
                throw new Error("Unfound ID: " + id);
            return found;
        };
        this.dump = function () {
            return "\ntype Identity<T> = T;\n\n" + _this.seen
                .map(function (item) { return "type " + item.id + " = Identity<" + item.type + ">;"; })
                .join('\n\n') + "\n";
        };
        this.setType = function (id, type) {
            var found = _this.findById(id);
            found.type = type;
            return found;
        };
        this.generate = function (schema) {
            var found = _this.findBySchema(schema);
            if (found)
                return found;
            var def = schema._def;
            var id = _this.randomId();
            var ty = {
                schema: schema,
                id: id,
                type: "__INCOMPLETE__",
            };
            _this.seen.push(ty);
            switch (def.t) {
                case z.ZodTypes.string:
                    return _this.setType(id, "string");
                case z.ZodTypes.number:
                    return _this.setType(id, "number");
                case z.ZodTypes.bigint:
                    return _this.setType(id, "bigint");
                case z.ZodTypes.boolean:
                    return _this.setType(id, "boolean");
                case z.ZodTypes.date:
                    return _this.setType(id, "Date");
                case z.ZodTypes.undefined:
                    return _this.setType(id, "undefined");
                case z.ZodTypes.null:
                    return _this.setType(id, "null");
                case z.ZodTypes.any:
                    return _this.setType(id, "any");
                case z.ZodTypes.unknown:
                    return _this.setType(id, "unknown");
                case z.ZodTypes.void:
                    return _this.setType(id, "void");
                case z.ZodTypes.literal:
                    var val = def.value;
                    var literalType = typeof val === 'string' ? "\"" + val + "\"" : "" + val;
                    return _this.setType(id, literalType);
                case z.ZodTypes.enum:
                    return _this.setType(id, def.values.map(function (v) { return "\"" + v + "\""; }).join(' | '));
                case z.ZodTypes.object:
                    var objectLines = [];
                    var shape = def.shape();
                    for (var key in shape) {
                        var childSchema = shape[key];
                        var childType = _this.generate(childSchema);
                        var OPTKEY = isOptional(childSchema) ? '?' : '';
                        objectLines.push("" + key + OPTKEY + ": " + childType.id);
                    }
                    var baseStruct = "{\n" + objectLines
                        .map(function (line) { return "  " + line + ";"; })
                        .join('\n') + "\n}";
                    _this.setType(id, "" + baseStruct);
                    break;
                case z.ZodTypes.tuple:
                    var tupleLines = [];
                    for (var _i = 0, _a = def.items; _i < _a.length; _i++) {
                        var elSchema = _a[_i];
                        var elType = _this.generate(elSchema);
                        tupleLines.push(elType.id);
                    }
                    var baseTuple = "[\n" + tupleLines
                        .map(function (line) { return "  " + line + ","; })
                        .join('\n') + "\n]";
                    return _this.setType(id, "" + baseTuple);
                case z.ZodTypes.array:
                    return _this.setType(id, _this.generate(def.type).id + "[]");
                case z.ZodTypes.function:
                    var args = _this.generate(def.args);
                    var returns = _this.generate(def.returns);
                    return _this.setType(id, "(...args: " + args.id + ")=>" + returns.id);
                case z.ZodTypes.promise:
                    var promValue = _this.generate(def.type);
                    return _this.setType(id, "Promise<" + promValue.id + ">");
                case z.ZodTypes.union:
                    var unionLines = [];
                    for (var _b = 0, _c = def.options; _b < _c.length; _b++) {
                        var elSchema = _c[_b];
                        var elType = _this.generate(elSchema);
                        unionLines.push(elType.id);
                    }
                    return _this.setType(id, unionLines.join(" | "));
                case z.ZodTypes.intersection:
                    return _this.setType(id, _this.generate(def.left).id + " & " + _this.generate(def.right).id);
                case z.ZodTypes.record:
                    return _this.setType(id, "{[k:string]: " + _this.generate(def.valueType).id + "}");
                case z.ZodTypes.lazy:
                    var lazyType = def.getter();
                    return _this.setType(id, _this.generate(lazyType).id);
                case z.ZodTypes.nativeEnum:
                    // const lazyType = def.getter();
                    return _this.setType(id, 'asdf');
                case z.ZodTypes.keyof:
                    // const lazyType = def.getter();
                    return _this.setType(id, "keyof [" + def.values
                        .map(function (val) { return (typeof val === 'string' ? "\"" + val + "\"" : val); })
                        .join(', ') + "]");
                default:
                    util_1.util.assertNever(def);
            }
            return _this.findById(id);
        };
    }
    ZodCodeGenerator.create = function () { return new ZodCodeGenerator(); };
    return ZodCodeGenerator;
}());
exports.ZodCodeGenerator = ZodCodeGenerator;
//# sourceMappingURL=codegen.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/defaultErrorMap.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/defaultErrorMap.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ZodError_1 = __webpack_require__(/*! ./ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
exports.defaultErrorMap = function (error, _ctx) {
    var message;
    switch (error.code) {
        case ZodError_1.ZodErrorCode.invalid_type:
            if (error.received === 'undefined') {
                message = 'Required';
            }
            else {
                message = "Expected " + error.expected + ", received " + error.received;
            }
            break;
        case ZodError_1.ZodErrorCode.nonempty_array_is_empty:
            message = "List must contain at least one item";
            break;
        case ZodError_1.ZodErrorCode.unrecognized_keys:
            message = "Unrecognized key(s) in object: " + error.keys.map(function (k) { return "'" + k + "'"; }).join(', ');
            break;
        case ZodError_1.ZodErrorCode.invalid_union:
            message = "Invalid input";
            break;
        // case ZodErrorCode.invalid_tuple_length:
        //   message = `Expected list of ${error.expected} items, received ${error.received} items`;
        //   break;
        case ZodError_1.ZodErrorCode.invalid_literal_value:
            message = "Input must be \"" + error.expected + "\"";
            break;
        case ZodError_1.ZodErrorCode.invalid_enum_value:
            message = "Input must be one of these values: " + error.options.join(', ');
            break;
        case ZodError_1.ZodErrorCode.invalid_arguments:
            message = "Invalid function arguments";
            break;
        case ZodError_1.ZodErrorCode.invalid_return_type:
            message = "Invalid function return type";
            break;
        case ZodError_1.ZodErrorCode.invalid_date:
            message = "Invalid date";
            break;
        // case ZodErrorCode.too_small:
        //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
        //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
        //   break;
        // case ZodErrorCode.too_big:
        //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
        //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
        //   break;
        case ZodError_1.ZodErrorCode.invalid_string:
            if (error.validation !== 'regex')
                message = "Invalid " + error.validation;
            else
                message = 'Invalid';
            break;
        // case ZodErrorCode.invalid_url:
        //   message = 'Invalid URL.';
        //   break;
        // case ZodErrorCode.invalid_uuid:
        //   message = 'Invalid UUID.';
        //   break;
        case ZodError_1.ZodErrorCode.too_small:
            if (error.type === 'array')
                message = "Should have " + (error.inclusive ? "at least" : "more than") + " " + error.minimum + " items";
            else if (error.type === 'string')
                message = "Should be " + (error.inclusive ? "at least" : "over") + " " + error.minimum + " characters";
            else if (error.type === 'number')
                message = "Value should be greater than " + (error.inclusive ? "or equal to " : "") + error.minimum;
            else
                message = 'Invalid input';
            break;
        case ZodError_1.ZodErrorCode.too_big:
            if (error.type === 'array')
                message = "Should have " + (error.inclusive ? "at most" : "less than") + " " + error.maximum + " items";
            else if (error.type === 'string')
                message = "Should be " + (error.inclusive ? "at most" : "under") + " " + error.maximum + " characters long";
            else if (error.type === 'number')
                message = "Value should be less than " + (error.inclusive ? "or equal to " : "") + error.maximum;
            else
                message = 'Invalid input';
            break;
        case ZodError_1.ZodErrorCode.custom_error:
            message = "Invalid input.";
            break;
        default:
            message = "Invalid input.";
            util_1.util.assertNever(error);
    }
    return { message: message };
    // return `Invalid input.`;
};
//# sourceMappingURL=defaultErrorMap.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = function (message) { return (typeof message === 'string' ? { message: message } : message || {}); };
})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));
//# sourceMappingURL=errorUtil.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/objectUtil.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/objectUtil.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_1 = __webpack_require__(/*! ../types/base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js");
var intersection_1 = __webpack_require__(/*! ../types/intersection */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js");
var object_1 = __webpack_require__(/*! ../types/object */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js");
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = function (first, second) {
        var firstKeys = Object.keys(first);
        var secondKeys = Object.keys(second);
        var sharedKeys = firstKeys.filter(function (k) { return secondKeys.indexOf(k) !== -1; });
        var sharedShape = {};
        for (var _i = 0, sharedKeys_1 = sharedKeys; _i < sharedKeys_1.length; _i++) {
            var k = sharedKeys_1[_i];
            sharedShape[k] = intersection_1.ZodIntersection.create(first[k], second[k]);
        }
        return __assign({}, first, second, sharedShape);
    };
    objectUtil.mergeObjects = function (first) { return function (second) {
        var mergedShape = objectUtil.mergeShapes(first._def.shape(), second._def.shape());
        var merged = new object_1.ZodObject({
            t: base_1.ZodTypes.object,
            checks: (first._def.checks || []).concat((second._def.checks || [])),
            params: {
                strict: first.params.strict && second.params.strict,
            },
            shape: function () { return mergedShape; },
        });
        return merged;
    }; };
})(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
//# sourceMappingURL=objectUtil.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var util;
(function (util) {
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = function (items) {
        var obj = {};
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = function (obj) {
        var validKeys = Object.keys(obj).filter(function (k) { return typeof obj[obj[k]] !== 'number'; });
        var filtered = {};
        for (var _i = 0, validKeys_1 = validKeys; _i < validKeys_1.length; _i++) {
            var k = validKeys_1[_i];
            filtered[k] = obj[k];
        }
        return util.getValues(filtered);
    };
    util.getValues = function (obj) {
        return Object.keys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectValues = function (obj) {
        return Object.keys(obj).map(function (e) {
            return obj[e];
        });
    };
})(util = exports.util || (exports.util = {}));
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* ZOD */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
var string_1 = __webpack_require__(/*! ./types/string */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/string.js");
exports.ZodString = string_1.ZodString;
var number_1 = __webpack_require__(/*! ./types/number */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/number.js");
exports.ZodNumber = number_1.ZodNumber;
var bigint_1 = __webpack_require__(/*! ./types/bigint */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/bigint.js");
exports.ZodBigInt = bigint_1.ZodBigInt;
var boolean_1 = __webpack_require__(/*! ./types/boolean */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/boolean.js");
exports.ZodBoolean = boolean_1.ZodBoolean;
var date_1 = __webpack_require__(/*! ./types/date */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/date.js");
exports.ZodDate = date_1.ZodDate;
var undefined_1 = __webpack_require__(/*! ./types/undefined */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/undefined.js");
exports.ZodUndefined = undefined_1.ZodUndefined;
var null_1 = __webpack_require__(/*! ./types/null */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/null.js");
exports.ZodNull = null_1.ZodNull;
var any_1 = __webpack_require__(/*! ./types/any */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/any.js");
exports.ZodAny = any_1.ZodAny;
var unknown_1 = __webpack_require__(/*! ./types/unknown */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js");
exports.ZodUnknown = unknown_1.ZodUnknown;
var void_1 = __webpack_require__(/*! ./types/void */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/void.js");
exports.ZodVoid = void_1.ZodVoid;
var array_1 = __webpack_require__(/*! ./types/array */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/array.js");
exports.ZodArray = array_1.ZodArray;
var object_1 = __webpack_require__(/*! ./types/object */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js");
exports.ZodObject = object_1.ZodObject;
var union_1 = __webpack_require__(/*! ./types/union */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/union.js");
exports.ZodUnion = union_1.ZodUnion;
var intersection_1 = __webpack_require__(/*! ./types/intersection */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js");
exports.ZodIntersection = intersection_1.ZodIntersection;
var tuple_1 = __webpack_require__(/*! ./types/tuple */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js");
exports.ZodTuple = tuple_1.ZodTuple;
var record_1 = __webpack_require__(/*! ./types/record */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/record.js");
exports.ZodRecord = record_1.ZodRecord;
var function_1 = __webpack_require__(/*! ./types/function */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/function.js");
exports.ZodFunction = function_1.ZodFunction;
var lazy_1 = __webpack_require__(/*! ./types/lazy */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/lazy.js");
exports.ZodLazy = lazy_1.ZodLazy;
var literal_1 = __webpack_require__(/*! ./types/literal */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/literal.js");
exports.ZodLiteral = literal_1.ZodLiteral;
var enum_1 = __webpack_require__(/*! ./types/enum */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/enum.js");
exports.ZodEnum = enum_1.ZodEnum;
var nativeEnum_1 = __webpack_require__(/*! ./types/nativeEnum */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/nativeEnum.js");
exports.ZodNativeEnum = nativeEnum_1.ZodNativeEnum;
var keyof_1 = __webpack_require__(/*! ./types/keyof */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/keyof.js");
var promise_1 = __webpack_require__(/*! ./types/promise */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/promise.js");
exports.ZodPromise = promise_1.ZodPromise;
var base_1 = __webpack_require__(/*! ./types/base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js");
exports.ZodType = base_1.ZodType;
exports.Schema = base_1.ZodType;
exports.ZodSchema = base_1.ZodType;
exports.ZodTypes = base_1.ZodTypes;
// import { ZodError, ZodErrorCode, ZodInvalidTypeError,
// ZodNonEmptyArrayIsEmptyError,
// ZodUnrecognizedKeysError,
// ZodInvalidUnionError,
// ZodInvalidLiteralValueError,
// ZodInvalidEnumValueError,
// ZodInvalidArgumentsError,
// ZodInvalidReturnTypeError,
// ZodInvalidDateError,
// ZodInvalidStringError,
// ZodTooSmallError,
// ZodTooBigError,
// ZodCustomError } from './ZodError';
var parser_1 = __webpack_require__(/*! ./parser */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js");
exports.ZodParsedType = parser_1.ZodParsedType;
var codegen_1 = __webpack_require__(/*! ./codegen */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/codegen.js");
exports.ZodCodeGenerator = codegen_1.ZodCodeGenerator;
var stringType = string_1.ZodString.create;
exports.string = stringType;
var numberType = number_1.ZodNumber.create;
exports.number = numberType;
var bigIntType = bigint_1.ZodBigInt.create;
exports.bigint = bigIntType;
var booleanType = boolean_1.ZodBoolean.create;
exports.boolean = booleanType;
var dateType = date_1.ZodDate.create;
exports.date = dateType;
var undefinedType = undefined_1.ZodUndefined.create;
exports.undefined = undefinedType;
var nullType = null_1.ZodNull.create;
exports["null"] = nullType;
var anyType = any_1.ZodAny.create;
exports.any = anyType;
var unknownType = unknown_1.ZodUnknown.create;
exports.unknown = unknownType;
var voidType = void_1.ZodVoid.create;
exports["void"] = voidType;
var arrayType = array_1.ZodArray.create;
exports.array = arrayType;
var objectType = object_1.ZodObject.create;
exports.object = objectType;
var unionType = union_1.ZodUnion.create;
exports.union = unionType;
var intersectionType = intersection_1.ZodIntersection.create;
exports.intersection = intersectionType;
var tupleType = tuple_1.ZodTuple.create;
exports.tuple = tupleType;
var recordType = record_1.ZodRecord.create;
exports.record = recordType;
var functionType = function_1.ZodFunction.create;
exports["function"] = functionType;
var lazyType = lazy_1.ZodLazy.create;
exports.lazy = lazyType;
var literalType = literal_1.ZodLiteral.create;
exports.literal = literalType;
var enumType = enum_1.ZodEnum.create;
exports["enum"] = enumType;
var nativeEnumType = nativeEnum_1.ZodNativeEnum.create;
exports.nativeEnum = nativeEnumType;
var promiseType = promise_1.ZodPromise.create;
exports.promise = promiseType;
var keyofType = keyof_1.ZodKeyof.create;
exports.keyof = keyofType;
var ostring = function () { return stringType().optional(); };
exports.ostring = ostring;
var onumber = function () { return numberType().optional(); };
exports.onumber = onumber;
var oboolean = function () { return booleanType().optional(); };
exports.oboolean = oboolean;
var codegen = codegen_1.ZodCodeGenerator.create;
exports.codegen = codegen;
exports.custom = function (check, params) { return anyType().refine(check, params); };
var instanceOfType = function (cls, params) {
    if (params === void 0) { params = {
        message: "Input not instance of " + cls.name,
    }; }
    return exports.custom(function (data) { return data instanceof cls; }, params);
};
exports["instanceof"] = instanceOfType;
exports.late = {
    object: object_1.ZodObject.lazycreate,
};
__export(__webpack_require__(/*! ./ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/isScalar.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/isScalar.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./index */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js"));
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
exports.isScalar = function (schema, params) {
    if (params === void 0) { params = { root: true }; }
    var def = schema._def;
    var returnValue = false;
    switch (def.t) {
        case z.ZodTypes.string:
            returnValue = true;
            break;
        case z.ZodTypes.number:
            returnValue = true;
            break;
        case z.ZodTypes.bigint:
            returnValue = true;
            break;
        case z.ZodTypes.boolean:
            returnValue = true;
            break;
        case z.ZodTypes.undefined:
            returnValue = true;
            break;
        case z.ZodTypes.null:
            returnValue = true;
            break;
        case z.ZodTypes.any:
            returnValue = false;
            break;
        case z.ZodTypes.unknown:
            returnValue = false;
            break;
        case z.ZodTypes.void:
            returnValue = false;
            break;
        case z.ZodTypes.array:
            if (params.root === false)
                return false;
            returnValue = exports.isScalar(def.type, { root: false });
            break;
        case z.ZodTypes.object:
            returnValue = false;
            break;
        case z.ZodTypes.union:
            returnValue = def.options.every(function (x) { return exports.isScalar(x); });
            break;
        case z.ZodTypes.intersection:
            returnValue = exports.isScalar(def.left) && exports.isScalar(def.right);
            break;
        case z.ZodTypes.tuple:
            returnValue = false;
            break;
        case z.ZodTypes.lazy:
            returnValue = exports.isScalar(def.getter());
            break;
        case z.ZodTypes.literal:
            returnValue = true;
            break;
        case z.ZodTypes.enum:
            returnValue = true;
            break;
        case z.ZodTypes.nativeEnum:
            returnValue = true;
            break;
        case z.ZodTypes.function:
            returnValue = false;
            break;
        case z.ZodTypes.record:
            returnValue = false;
            break;
        case z.ZodTypes.date:
            returnValue = true;
            break;
        case z.ZodTypes.promise:
            returnValue = false;
            break;
        case z.ZodTypes.keyof:
            returnValue = true;
            break;
        default:
            util_1.util.assertNever(def);
        // returnValue = false; break;
    }
    return returnValue;
};
//# sourceMappingURL=isScalar.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var _this = this;
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./types/base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodError_1 = __webpack_require__(/*! ./ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
var defaultErrorMap_1 = __webpack_require__(/*! ./defaultErrorMap */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/defaultErrorMap.js");
exports.getParsedType = function (data) {
    if (typeof data === 'string')
        return 'string';
    if (typeof data === 'number') {
        if (Number.isNaN(data))
            return 'nan';
        return 'number';
    }
    if (typeof data === 'boolean')
        return 'boolean';
    if (typeof data === 'bigint')
        return 'bigint';
    if (typeof data === 'symbol')
        return 'symbol';
    if (data instanceof Date)
        return 'date';
    if (typeof data === 'function')
        return 'function';
    if (data === undefined)
        return 'undefined';
    if (typeof data === 'undefined')
        return 'undefined';
    if (typeof data === 'object') {
        if (Array.isArray(data))
            return 'array';
        if (!data)
            return 'null';
        if (data.then &&
            typeof data.then === 'function' &&
            data.catch &&
            typeof data.catch === 'function') {
            return 'promise';
        }
        return 'object';
    }
    return 'unknown';
};
exports.ZodParsedType = util_1.util.arrayToEnum([
    'string',
    'nan',
    'number',
    'integer',
    'boolean',
    'date',
    'bigint',
    'symbol',
    'function',
    'undefined',
    'null',
    'array',
    'object',
    'unknown',
    'promise',
    'void',
]);
exports.find = function (arr, checker) {
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var item = arr_1[_i];
        if (checker(item))
            return item;
    }
    return undefined;
};
var makeError = function (params, obj, errorData) {
    var errorArg = __assign({}, errorData, { path: params.path.concat((errorData.path || [])) });
    var ctxArg = { data: obj };
    var defaultError = defaultErrorMap_1.defaultErrorMap === params.errorMap
        ? { message: "Invalid value." }
        : defaultErrorMap_1.defaultErrorMap(errorArg, __assign({}, ctxArg, { defaultError: "Invalid value." }));
    return __assign({}, errorData, { path: params.path.concat((errorData.path || [])), message: errorData.message ||
            params.errorMap(errorArg, __assign({}, ctxArg, { defaultError: defaultError.message })).message });
};
exports.ZodParser = function (schemaDef) { return function (obj, baseParams) {
    if (baseParams === void 0) { baseParams = { seen: [], errorMap: defaultErrorMap_1.defaultErrorMap, path: [] }; }
    var params = {
        seen: baseParams.seen || [],
        path: baseParams.path || [],
        errorMap: baseParams.errorMap || defaultErrorMap_1.defaultErrorMap,
    };
    var def = schemaDef;
    var parsedType = exports.getParsedType(obj);
    var schemaSeen = exports.find(params.seen, function (x) { return x.schema === schemaDef; });
    var isNonprimitive = ['array', 'object'].indexOf(parsedType) !== -1;
    if (isNonprimitive) {
        if (schemaSeen) {
            var found = exports.find(schemaSeen.objects, function (x) { return x.data === obj; });
            if (found) {
                if (found.error) {
                    throw found.error;
                }
                found.times = found.times + 1;
                if (found.times > 5 && isNonprimitive) {
                    return Symbol('recursion depth exceeded.');
                }
                else if (found.times > 2) {
                }
            }
            else {
                //
                schemaSeen.objects.push(obj);
            }
        }
        else {
            params.seen.push({
                schema: schemaDef,
                objects: [{ data: obj, error: undefined, times: 1 }],
            });
        }
    }
    // const setError = (error: Error) => {
    //   const schemaSeen = params.seen.find(x => x.schema === schemaDef);
    //   if (schemaSeen) {
    //     const found = schemaSeen.objects.find(x => x.data === obj);
    //     if (found) {
    //       found.error = error;
    //     }
    //   }
    // };
    var error = new ZodError_1.ZodError([]);
    var returnValue = obj;
    switch (def.t) {
        case z.ZodTypes.string:
            if (parsedType !== exports.ZodParsedType.string) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.string,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.number:
            if (parsedType !== exports.ZodParsedType.number) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.number,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            if (Number.isNaN(obj)) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.number,
                    received: exports.ZodParsedType.nan,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.bigint:
            if (parsedType !== exports.ZodParsedType.bigint) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.number,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.boolean:
            if (parsedType !== exports.ZodParsedType.boolean) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.boolean,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.undefined:
            if (parsedType !== exports.ZodParsedType.undefined) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.undefined,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.null:
            if (parsedType !== exports.ZodParsedType.null) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.null,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.any:
            break;
        case z.ZodTypes.unknown:
            break;
        case z.ZodTypes.void:
            if (parsedType !== exports.ZodParsedType.undefined &&
                parsedType !== exports.ZodParsedType.null) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.void,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.array:
            if (parsedType !== exports.ZodParsedType.array) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.array,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            var data = obj;
            if (def.nonempty === true && obj.length === 0) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.nonempty_array_is_empty,
                }));
                // setError(error);
                throw error;
            }
            data.map(function (item, i) {
                try {
                    var parsedItem = def.type.parse(item, __assign({}, params, { path: params.path.concat([i]) }));
                    return parsedItem;
                }
                catch (err) {
                    var zerr = err;
                    error.addErrors(zerr.errors);
                }
            });
            if (!error.isEmpty) {
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.object:
            if (parsedType !== exports.ZodParsedType.object) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.object,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            var shape = def.shape();
            if (def.params.strict) {
                var shapeKeys_1 = Object.keys(shape);
                var objKeys = Object.keys(obj);
                var extraKeys = objKeys.filter(function (k) { return shapeKeys_1.indexOf(k) === -1; });
                if (extraKeys.length) {
                    error.addError(makeError(params, obj, {
                        code: ZodError_1.ZodErrorCode.unrecognized_keys,
                        keys: extraKeys,
                    }));
                }
            }
            for (var key in shape) {
                try {
                    def
                        .shape()[key].parse(obj[key], __assign({}, params, { path: params.path.concat([key]) }));
                }
                catch (err) {
                    var zerr = err;
                    error.addErrors(zerr.errors);
                }
            }
            break;
        case z.ZodTypes.union:
            var isValid = false;
            var unionErrors = [];
            for (var _i = 0, _a = def.options; _i < _a.length; _i++) {
                var option = _a[_i];
                try {
                    option.parse(obj, params);
                    isValid = true;
                }
                catch (err) {
                    unionErrors.push(err);
                }
            }
            if (!isValid) {
                var filteredErrors = unionErrors.filter(function (err) {
                    return err.errors[0].code !== 'invalid_type';
                });
                if (filteredErrors.length === 1) {
                    error.addErrors(filteredErrors[0].errors);
                }
                else {
                    error.addError(makeError(params, obj, {
                        code: ZodError_1.ZodErrorCode.invalid_union,
                        unionErrors: unionErrors,
                    }));
                }
            }
            break;
        case z.ZodTypes.intersection:
            try {
                def.left.parse(obj, params);
            }
            catch (err) {
                error.addErrors(err.errors);
            }
            try {
                def.right.parse(obj, params);
            }
            catch (err) {
                error.addErrors(err.errors);
            }
            break;
        case z.ZodTypes.tuple:
            if (parsedType !== exports.ZodParsedType.array) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.array,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            if (obj.length > def.items.length) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.too_big,
                    maximum: def.items.length,
                    inclusive: true,
                    type: 'array',
                }));
            }
            else if (obj.length < def.items.length) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.too_small,
                    minimum: def.items.length,
                    inclusive: true,
                    type: 'array',
                }));
            }
            var parsedTuple = [];
            var tupleData = obj;
            for (var index in tupleData) {
                var item = tupleData[index];
                var itemParser = def.items[index];
                try {
                    parsedTuple.push(itemParser.parse(item, __assign({}, params, { path: params.path.concat([index]) })));
                }
                catch (err) {
                    error.addErrors(err.errors);
                }
            }
            break;
        case z.ZodTypes.lazy:
            var lazySchema = def.getter();
            lazySchema.parse(obj, params);
            break;
        case z.ZodTypes.literal:
            if (obj !== def.value) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_literal_value,
                    expected: def.value,
                }));
            }
            break;
        case z.ZodTypes.enum:
            if (def.values.indexOf(obj) === -1) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_enum_value,
                    options: def.values,
                }));
            }
            break;
        case z.ZodTypes.nativeEnum:
            if (util_1.util.getValidEnumValues(def.values).indexOf(obj) === -1) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_enum_value,
                    options: util_1.util.getValues(def.values),
                }));
            }
            break;
        case z.ZodTypes.keyof:
            if (util_1.util.getValidEnumValues(def.values).indexOf(obj) === -1) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_enum_value,
                    options: util_1.util.getValues(def.values),
                }));
            }
            break;
        case z.ZodTypes.function:
            if (parsedType !== exports.ZodParsedType.function) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.function,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            var validatedFunc = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    def.args.parse(args);
                }
                catch (err) {
                    if (err instanceof ZodError_1.ZodError) {
                        var argsError = new ZodError_1.ZodError([]);
                        argsError.addError(makeError(params, obj, {
                            code: ZodError_1.ZodErrorCode.invalid_arguments,
                            argumentsError: err,
                        }));
                        throw argsError;
                    }
                    throw err;
                }
                var result = obj.apply(void 0, args);
                try {
                    return def.returns.parse(result);
                }
                catch (err) {
                    if (err instanceof ZodError_1.ZodError) {
                        var returnsError = new ZodError_1.ZodError([]);
                        returnsError.addError(makeError(params, obj, {
                            code: ZodError_1.ZodErrorCode.invalid_return_type,
                            returnTypeError: err,
                        }));
                        throw returnsError;
                    }
                    throw err;
                }
            };
            return validatedFunc;
        case z.ZodTypes.record:
            if (parsedType !== exports.ZodParsedType.object) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.object,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            for (var key in obj) {
                try {
                    def.valueType.parse(obj[key], __assign({}, params, { path: params.path.concat([key]) }));
                }
                catch (err) {
                    error.addErrors(err.errors);
                }
            }
            break;
        case z.ZodTypes.date:
            if (!(obj instanceof Date)) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.date,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            if (isNaN(obj.getTime())) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_date,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.promise:
            if (parsedType !== exports.ZodParsedType.promise) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.promise,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            return new Promise(function (res, rej) { return __awaiter(_this, void 0, void 0, function () {
                var objValue, parsed;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, obj];
                        case 1:
                            objValue = _a.sent();
                            try {
                                parsed = def.type.parse(objValue, params);
                                res(parsed);
                            }
                            catch (err) {
                                rej(err);
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
        default:
            util_1.util.assertNever(def);
    }
    var customChecks = def.checks || [];
    for (var _b = 0, customChecks_1 = customChecks; _b < customChecks_1.length; _b++) {
        var check = customChecks_1[_b];
        if (!check.check(returnValue)) {
            var checkMethod = check.check, noMethodCheck = __rest(check, ["check"]);
            error.addError(makeError(params, obj, noMethodCheck));
        }
    }
    if (!error.isEmpty) {
        // setError(error);
        throw error;
    }
    return returnValue;
}; };
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/any.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/any.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodAny = /** @class */ (function (_super) {
    __extends(ZodAny, _super);
    function ZodAny() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodAny.create = function () {
        return new ZodAny({
            t: z.ZodTypes.any,
        });
    };
    return ZodAny;
}(z.ZodType));
exports.ZodAny = ZodAny;
//# sourceMappingURL=any.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/array.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/array.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
// import { ZodUndefined } from './undefined';
// import { ZodNull } from './null';
// import { ZodUnion } from './union';
var ZodError_1 = __webpack_require__(/*! ../ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var ZodArray = /** @class */ (function (_super) {
    __extends(ZodArray, _super);
    function ZodArray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                nonempty: _this._def.nonempty,
                type: _this._def.type.toJSON(),
            };
        };
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.min = function (minLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: ZodError_1.ZodErrorCode.too_small, type: 'array', inclusive: true, minimum: minLength }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.max = function (maxLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: ZodError_1.ZodErrorCode.too_big, type: 'array', inclusive: true, maximum: maxLength }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.length = function (len, message) { return _this.min(len, { message: message }).max(len, { message: message }); };
        _this.nonempty = function () {
            return new ZodNonEmptyArray(__assign({}, _this._def, { nonempty: true }));
        };
        return _this;
    }
    Object.defineProperty(ZodArray.prototype, "element", {
        get: function () {
            return this._def.type;
        },
        enumerable: true,
        configurable: true
    });
    ZodArray.create = function (schema) {
        return new ZodArray({
            t: z.ZodTypes.array,
            type: schema,
            nonempty: false,
        });
    };
    return ZodArray;
}(z.ZodType));
exports.ZodArray = ZodArray;
var ZodNonEmptyArray = /** @class */ (function (_super) {
    __extends(ZodNonEmptyArray, _super);
    function ZodNonEmptyArray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                type: _this._def.type.toJSON(),
            };
        };
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.min = function (minLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: ZodError_1.ZodErrorCode.too_small, minimum: minLength, type: 'array', inclusive: true }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.max = function (maxLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: ZodError_1.ZodErrorCode.too_big, maximum: maxLength, type: 'array', inclusive: true }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.length = function (len, message) { return _this.min(len, { message: message }).max(len, { message: message }); };
        return _this;
    }
    return ZodNonEmptyArray;
}(z.ZodType));
exports.ZodNonEmptyArray = ZodNonEmptyArray;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var parser_1 = __webpack_require__(/*! ../parser */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js");
var index_1 = __webpack_require__(/*! ../index */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js");
var ZodTypes;
(function (ZodTypes) {
    ZodTypes["string"] = "string";
    ZodTypes["number"] = "number";
    ZodTypes["bigint"] = "bigint";
    ZodTypes["boolean"] = "boolean";
    ZodTypes["date"] = "date";
    ZodTypes["undefined"] = "undefined";
    ZodTypes["null"] = "null";
    ZodTypes["array"] = "array";
    ZodTypes["object"] = "object";
    ZodTypes["union"] = "union";
    ZodTypes["intersection"] = "intersection";
    ZodTypes["tuple"] = "tuple";
    ZodTypes["record"] = "record";
    ZodTypes["function"] = "function";
    ZodTypes["lazy"] = "lazy";
    ZodTypes["literal"] = "literal";
    ZodTypes["enum"] = "enum";
    ZodTypes["nativeEnum"] = "nativeEnum";
    ZodTypes["promise"] = "promise";
    ZodTypes["any"] = "any";
    ZodTypes["unknown"] = "unknown";
    ZodTypes["void"] = "void";
    ZodTypes["keyof"] = "keyof";
})(ZodTypes = exports.ZodTypes || (exports.ZodTypes = {}));
var ZodType = /** @class */ (function () {
    function ZodType(def) {
        var _this = this;
        this.safeParse = function (data, params) {
            try {
                var parsed = _this.parse(data, params);
                return {
                    success: true,
                    data: parsed,
                };
            }
            catch (err) {
                if (err instanceof index_1.ZodError) {
                    return {
                        success: false,
                        error: err,
                    };
                }
                throw err;
            }
        };
        this.parseAsync = function (value, params) {
            return new Promise(function (res, rej) {
                try {
                    var parsed = _this.parse(value, params);
                    return res(parsed);
                }
                catch (err) {
                    return rej(err);
                }
            });
        };
        this.refine = function (check, message) {
            if (message === void 0) { message = 'Invalid value.'; }
            if (typeof message === 'string') {
                return _this.refinement({ check: check, message: message });
            }
            return _this.refinement(__assign({ check: check }, message));
        };
        this.refinement = function (refinement) {
            return _this._refinement(__assign({ code: index_1.ZodErrorCode.custom_error }, refinement));
        };
        this._refinement = function (refinement) {
            return new _this.constructor(__assign({}, _this._def, { checks: (_this._def.checks || []).concat([refinement]) }));
        };
        //  abstract // opt optional: () => any;
        this.optional = function () {
            return index_1.ZodUnion.create([_this, index_1.ZodUndefined.create()]);
        };
        this.nullable = function () {
            return index_1.ZodUnion.create([_this, index_1.ZodNull.create()]);
        };
        this.array = function () { return index_1.ZodArray.create(_this); };
        this.or = function (arg) {
            return index_1.ZodUnion.create([_this, arg]);
        };
        this._def = def;
        this.parse = parser_1.ZodParser(def);
    }
    ZodType.prototype.is = function (u) {
        try {
            this.parse(u);
            return true;
        }
        catch (err) {
            return false;
        }
    };
    ZodType.prototype.check = function (u) {
        try {
            this.parse(u);
            return true;
        }
        catch (err) {
            return false;
        }
    };
    return ZodType;
}());
exports.ZodType = ZodType;
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/bigint.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/bigint.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodBigInt = /** @class */ (function (_super) {
    __extends(ZodBigInt, _super);
    function ZodBigInt() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodBigInt.create = function () {
        return new ZodBigInt({
            t: z.ZodTypes.bigint,
        });
    };
    return ZodBigInt;
}(z.ZodType));
exports.ZodBigInt = ZodBigInt;
//# sourceMappingURL=bigint.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/boolean.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/boolean.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodBoolean = /** @class */ (function (_super) {
    __extends(ZodBoolean, _super);
    function ZodBoolean() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodBoolean.create = function () {
        return new ZodBoolean({
            t: z.ZodTypes.boolean,
        });
    };
    return ZodBoolean;
}(z.ZodType));
exports.ZodBoolean = ZodBoolean;
//# sourceMappingURL=boolean.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/date.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/date.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodDate = /** @class */ (function (_super) {
    __extends(ZodDate, _super);
    function ZodDate() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodDate.create = function () {
        return new ZodDate({
            t: z.ZodTypes.date,
        });
    };
    return ZodDate;
}(z.ZodType));
exports.ZodDate = ZodDate;
//# sourceMappingURL=date.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/enum.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/enum.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodEnum = /** @class */ (function (_super) {
    __extends(ZodEnum, _super);
    function ZodEnum() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    Object.defineProperty(ZodEnum.prototype, "options", {
        get: function () {
            return this._def.values;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodEnum.prototype, "enum", {
        get: function () {
            var enumValues = {};
            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {
                var val = _a[_i];
                enumValues[val] = val;
            }
            return enumValues;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodEnum.prototype, "Values", {
        get: function () {
            var enumValues = {};
            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {
                var val = _a[_i];
                enumValues[val] = val;
            }
            return enumValues;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodEnum.prototype, "Enum", {
        get: function () {
            var enumValues = {};
            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {
                var val = _a[_i];
                enumValues[val] = val;
            }
            return enumValues;
        },
        enumerable: true,
        configurable: true
    });
    ZodEnum.create = function (values) {
        return new ZodEnum({
            t: z.ZodTypes.enum,
            values: values,
        });
    };
    return ZodEnum;
}(z.ZodType));
exports.ZodEnum = ZodEnum;
//# sourceMappingURL=enum.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/function.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/function.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js");
var unknown_1 = __webpack_require__(/*! ./unknown */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js");
var ZodFunction = /** @class */ (function (_super) {
    __extends(ZodFunction, _super);
    function ZodFunction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.args = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return new ZodFunction(__assign({}, _this._def, { args: tuple_1.ZodTuple.create(items) }));
        };
        _this.returns = function (returnType) {
            return new ZodFunction(__assign({}, _this._def, { returns: returnType }));
        };
        _this.implement = function (func) {
            var validatedFunc = _this.parse(func);
            return validatedFunc;
        };
        _this.validate = _this.implement;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                args: _this._def.args.toJSON(),
                returns: _this._def.returns.toJSON(),
            };
        };
        return _this;
    }
    ZodFunction.create = function (args, returns) {
        return new ZodFunction({
            t: z.ZodTypes.function,
            args: args || tuple_1.ZodTuple.create([]),
            returns: returns || unknown_1.ZodUnknown.create(),
        });
    };
    return ZodFunction;
}(z.ZodType));
exports.ZodFunction = ZodFunction;
//# sourceMappingURL=function.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodIntersection = /** @class */ (function (_super) {
    __extends(ZodIntersection, _super);
    function ZodIntersection() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return ({
            t: _this._def.t,
            left: _this._def.left.toJSON(),
            right: _this._def.right.toJSON(),
        }); };
        return _this;
    }
    ZodIntersection.create = function (left, right) {
        return new ZodIntersection({
            t: z.ZodTypes.intersection,
            left: left,
            right: right,
        });
    };
    return ZodIntersection;
}(z.ZodType));
exports.ZodIntersection = ZodIntersection;
//# sourceMappingURL=intersection.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/keyof.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/keyof.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodKeyof = /** @class */ (function (_super) {
    __extends(ZodKeyof, _super);
    function ZodKeyof() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return ({
            t: _this._def.t,
            values: _this._def.values.map(function (x) { return x.toString(); }),
        }); };
        return _this;
    }
    ZodKeyof.create = function (object) {
        return new ZodKeyof({
            t: z.ZodTypes.keyof,
            // Note that this cast is not correct in the general case
            // See e.g. https://github.com/Microsoft/TypeScript/issues/12870
            values: Object.keys(object),
        });
    };
    return ZodKeyof;
}(z.ZodType));
exports.ZodKeyof = ZodKeyof;
//# sourceMappingURL=keyof.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/lazy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/lazy.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodLazy = /** @class */ (function (_super) {
    __extends(ZodLazy, _super);
    function ZodLazy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () {
            throw new Error("Can't JSONify recursive structure");
        };
        return _this;
    }
    Object.defineProperty(ZodLazy.prototype, "schema", {
        get: function () {
            return this._def.getter();
        },
        enumerable: true,
        configurable: true
    });
    ZodLazy.create = function (getter) {
        return new ZodLazy({
            t: z.ZodTypes.lazy,
            getter: getter,
        });
    };
    return ZodLazy;
}(z.ZodType));
exports.ZodLazy = ZodLazy;
//# sourceMappingURL=lazy.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/literal.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/literal.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodLiteral = /** @class */ (function (_super) {
    __extends(ZodLiteral, _super);
    function ZodLiteral() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodLiteral.create = function (value) {
        return new ZodLiteral({
            t: z.ZodTypes.literal,
            value: value,
        });
    };
    return ZodLiteral;
}(z.ZodType));
exports.ZodLiteral = ZodLiteral;
//# sourceMappingURL=literal.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/nativeEnum.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/nativeEnum.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodNativeEnum = /** @class */ (function (_super) {
    __extends(ZodNativeEnum, _super);
    function ZodNativeEnum() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodNativeEnum.create = function (values) {
        return new ZodNativeEnum({
            t: z.ZodTypes.nativeEnum,
            values: values,
        });
    };
    return ZodNativeEnum;
}(z.ZodType));
exports.ZodNativeEnum = ZodNativeEnum;
//# sourceMappingURL=nativeEnum.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/null.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/null.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodNull = /** @class */ (function (_super) {
    __extends(ZodNull, _super);
    function ZodNull() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodNull.create = function () {
        return new ZodNull({
            t: z.ZodTypes.null,
        });
    };
    return ZodNull;
}(z.ZodType));
exports.ZodNull = ZodNull;
//# sourceMappingURL=null.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/number.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/number.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
// import { ZodUndefined } from './undefined';
// import { ZodNull } from './null';
// import { ZodUnion } from './union';
var ZodError_1 = __webpack_require__(/*! ../ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var errorUtil_1 = __webpack_require__(/*! ../helpers/errorUtil */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js");
var ZodNumber = /** @class */ (function (_super) {
    __extends(ZodNumber, _super);
    function ZodNumber() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        _this.min = function (minimum, message) {
            return _this._refinement(__assign({ check: function (data) { return data >= minimum; }, code: ZodError_1.ZodErrorCode.too_small, minimum: minimum, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.max = function (maximum, message) {
            return _this._refinement(__assign({ check: function (data) { return data <= maximum; }, code: ZodError_1.ZodErrorCode.too_big, maximum: maximum, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.int = function (message) {
            return _this._refinement(__assign({ check: function (data) { return Number.isInteger(data); }, code: ZodError_1.ZodErrorCode.invalid_type, expected: 'integer', received: 'number' }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.positive = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data > 0; }, code: ZodError_1.ZodErrorCode.too_small, minimum: 0, type: 'number', inclusive: false }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.negative = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data < 0; }, code: ZodError_1.ZodErrorCode.too_big, maximum: 0, type: 'number', inclusive: false }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.nonpositive = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data <= 0; }, code: ZodError_1.ZodErrorCode.too_big, maximum: 0, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.nonnegative = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data >= 0; }, code: ZodError_1.ZodErrorCode.too_small, minimum: 0, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        return _this;
    }
    ZodNumber.create = function () {
        return new ZodNumber({
            t: z.ZodTypes.number,
        });
    };
    return ZodNumber;
}(z.ZodType));
exports.ZodNumber = ZodNumber;
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var objectUtil_1 = __webpack_require__(/*! ../helpers/objectUtil */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/objectUtil.js");
var isScalar_1 = __webpack_require__(/*! ../isScalar */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/isScalar.js");
var AugmentFactory = function (def) { return function (augmentation) {
    return new ZodObject(__assign({}, def, { shape: function () { return (__assign({}, def.shape(), augmentation)); } }));
}; };
var objectDefToJson = function (def) { return ({
    t: def.t,
    shape: Object.assign({}, Object.keys(def.shape()).map(function (k) {
        var _a;
        return (_a = {},
            _a[k] = def.shape()[k].toJSON(),
            _a);
    })),
}); };
var ZodObject = /** @class */ (function (_super) {
    __extends(ZodObject, _super);
    function ZodObject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return objectDefToJson(_this._def); };
        _this.nonstrict = function () {
            return new ZodObject({
                shape: _this._def.shape,
                t: z.ZodTypes.object,
                params: __assign({}, _this._params, { strict: false }),
            });
        };
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.augment = AugmentFactory(_this._def);
        _this.extend = AugmentFactory(_this._def);
        /**
         * Prior to zod@1.0.12 there was a bug in the
         * inferred type of merged objects. Please
         * upgrade if you are experiencing issues.
         */
        _this.merge = objectUtil_1.objectUtil.mergeObjects(_this);
        _this.pick = function (mask) {
            var shape = {};
            Object.keys(mask).map(function (key) {
                shape[key] = _this.shape[key];
            });
            return new ZodObject(__assign({}, _this._def, { shape: function () { return shape; } }));
        };
        _this.omit = function (mask) {
            var shape = {};
            Object.keys(_this.shape).map(function (key) {
                if (Object.keys(mask).indexOf(key) === -1) {
                    shape[key] = _this.shape[key];
                }
            });
            return new ZodObject(__assign({}, _this._def, { shape: function () { return shape; } }));
        };
        _this.partial = function () {
            var newShape = {};
            for (var key in _this.shape) {
                newShape[key] = _this.shape[key].optional();
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        _this.primitives = function () {
            var newShape = {};
            for (var key in _this.shape) {
                if (isScalar_1.isScalar(_this.shape[key])) {
                    newShape[key] = _this.shape[key];
                }
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        _this.nonprimitives = function () {
            var newShape = {};
            for (var key in _this.shape) {
                if (!isScalar_1.isScalar(_this.shape[key])) {
                    newShape[key] = _this.shape[key];
                }
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        _this.deepPartial = function () {
            var newShape = {};
            for (var key in _this.shape) {
                var fieldSchema = _this.shape[key];
                if (fieldSchema instanceof ZodObject) {
                    newShape[key] = fieldSchema.deepPartial().optional();
                }
                else {
                    newShape[key] = _this.shape[key].optional();
                }
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        return _this;
    }
    Object.defineProperty(ZodObject.prototype, "shape", {
        get: function () {
            return this._def.shape();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodObject.prototype, "params", {
        get: function () {
            return this._def.params;
        },
        enumerable: true,
        configurable: true
    });
    ZodObject.create = function (shape) {
        return new ZodObject({
            t: z.ZodTypes.object,
            shape: function () { return shape; },
            params: {
                strict: true,
            },
        });
    };
    ZodObject.lazycreate = function (shape) {
        return new ZodObject({
            t: z.ZodTypes.object,
            shape: shape,
            params: {
                strict: true,
            },
        });
    };
    return ZodObject;
}(z.ZodType));
exports.ZodObject = ZodObject;
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/promise.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/promise.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodPromise = /** @class */ (function (_super) {
    __extends(ZodPromise, _super);
    function ZodPromise() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                type: _this._def.type.toJSON(),
            };
        };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodPromise.create = function (schema) {
        return new ZodPromise({
            t: z.ZodTypes.promise,
            type: schema,
        });
    };
    return ZodPromise;
}(z.ZodType));
exports.ZodPromise = ZodPromise;
//# sourceMappingURL=promise.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/record.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/record.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodRecord = /** @class */ (function (_super) {
    __extends(ZodRecord, _super);
    function ZodRecord() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return ({
            t: _this._def.t,
            valueType: _this._def.valueType.toJSON(),
        }); };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodRecord.create = function (valueType) {
        return new ZodRecord({
            t: z.ZodTypes.record,
            valueType: valueType,
        });
    };
    return ZodRecord;
}(z.ZodType));
exports.ZodRecord = ZodRecord;
//# sourceMappingURL=record.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/string.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/string.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
// import { ZodUndefined } from './undefined';
// import { ZodNull } from './null';
// import { ZodUnion } from './union';
var ZodError_1 = __webpack_require__(/*! ../ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var errorUtil_1 = __webpack_require__(/*! ../helpers/errorUtil */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js");
var emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
var uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/i;
var ZodString = /** @class */ (function (_super) {
    __extends(ZodString, _super);
    function ZodString() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        _this.min = function (minLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: ZodError_1.ZodErrorCode.too_small, minimum: minLength, type: 'string', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.max = function (maxLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: ZodError_1.ZodErrorCode.too_big, maximum: maxLength, type: 'string', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this._regex = function (regex, validation, message) {
            return _this._refinement(__assign({ validation: validation, code: ZodError_1.ZodErrorCode.invalid_string, check: function (data) { return regex.test(data); } }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.email = function (message) {
            return _this._regex(emailRegex, 'email', message);
        };
        _this.url = function (message) {
            return _this._refinement(__assign({ check: function (data) {
                    try {
                        new URL(data);
                        return true;
                    }
                    catch (_a) {
                        return false;
                    }
                }, code: ZodError_1.ZodErrorCode.invalid_string, validation: 'url' }, errorUtil_1.errorUtil.errToObj(message)));
        };
        // url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
        _this.uuid = function (message) {
            return _this._regex(uuidRegex, 'uuid', message);
        };
        _this.regex = function (regexp, message) {
            return _this._regex(regexp, 'regex', message);
        };
        _this.nonempty = function (message) {
            return _this.min(1, errorUtil_1.errorUtil.errToObj(message));
        };
        return _this;
    }
    ZodString.prototype.length = function (len, message) {
        return this.min(len, message).max(len, message);
    };
    ZodString.create = function () {
        return new ZodString({
            t: z.ZodTypes.string,
            validation: {},
        });
    };
    return ZodString;
}(z.ZodType));
exports.ZodString = ZodString;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodTuple = /** @class */ (function (_super) {
    __extends(ZodTuple, _super);
    function ZodTuple() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return ({
            t: _this._def.t,
            items: _this._def.items.map(function (item) { return item.toJSON(); }),
        }); };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodTuple.create = function (schemas) {
        return new ZodTuple({
            t: z.ZodTypes.tuple,
            items: schemas,
        });
    };
    return ZodTuple;
}(z.ZodType));
exports.ZodTuple = ZodTuple;
//# sourceMappingURL=tuple.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/undefined.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/undefined.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodUndefined = /** @class */ (function (_super) {
    __extends(ZodUndefined, _super);
    function ZodUndefined() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodUndefined.create = function () {
        return new ZodUndefined({
            t: z.ZodTypes.undefined,
        });
    };
    return ZodUndefined;
}(z.ZodType));
exports.ZodUndefined = ZodUndefined;
//# sourceMappingURL=undefined.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/union.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/union.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodUnion = /** @class */ (function (_super) {
    __extends(ZodUnion, _super);
    function ZodUnion() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return ({
            t: _this._def.t,
            options: _this._def.options.map(function (x) { return x.toJSON(); }),
        }); };
        return _this;
    }
    // distribute = <F extends (arg: T[number]) => z.ZodTypeAny>(f: F): ZodUnion<{ [k in keyof T]: ReturnType<F> }> => {
    //   return ZodUnion.create(this._def.options.map(f) as any);
    // };
    ZodUnion.create = function (types) {
        return new ZodUnion({
            t: z.ZodTypes.union,
            options: types,
        });
    };
    return ZodUnion;
}(z.ZodType));
exports.ZodUnion = ZodUnion;
//# sourceMappingURL=union.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodUnknown = /** @class */ (function (_super) {
    __extends(ZodUnknown, _super);
    function ZodUnknown() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodUnknown.create = function () {
        return new ZodUnknown({
            t: z.ZodTypes.unknown,
        });
    };
    return ZodUnknown;
}(z.ZodType));
exports.ZodUnknown = ZodUnknown;
//# sourceMappingURL=unknown.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/void.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/void.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodVoid = /** @class */ (function (_super) {
    __extends(ZodVoid, _super);
    function ZodVoid() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodVoid.create = function () {
        return new ZodVoid({
            t: z.ZodTypes.void,
        });
    };
    return ZodVoid;
}(z.ZodType));
exports.ZodVoid = ZodVoid;
//# sourceMappingURL=void.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pkg = __webpack_require__(/*! ./../../package.json */ "./node_modules/axios/package.json");

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./resources/js/components/ui/CurrencyDropdown.js":
/*!********************************************************!*\
  !*** ./resources/js/components/ui/CurrencyDropdown.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





var Dropdown = function Dropdown(_ref) {
  var _options$find;

  var options = _ref.options,
      selectedOption = _ref.selectedOption,
      setSelectedOption = _ref.setSelectedOption;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState2 = _slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setOpen = _useState2[1];

  var dropdown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null); // Open/Close on click of dropdown header

  var toggleDropdown = function toggleDropdown() {
    return setOpen(!isOpen);
  }; // Update selected option, close dropdown


  var handleItemClick = function handleItemClick(currency) {
    setSelectedOption(currency);
    setOpen(false);
  }; // Close dropdown when clicked outside


  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    function handleClickOutside(event) {
      if (dropdown.current && !dropdown.current.contains(event.target)) {
        setOpen(false);
      }
    }

    document.addEventListener("mousedown", handleClickOutside);
    return function () {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [dropdown]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
    className: "dropdown",
    ref: dropdown,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "dropdown-header",
      onClick: toggleDropdown,
      children: selectedOption ? (_options$find = options.find(function (option) {
        return option.currency === selectedOption.currency;
      })) === null || _options$find === void 0 ? void 0 : _options$find.currency : "select a token"
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "dropdown-body ".concat(isOpen && "open"),
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("ul", {
        children: (options || []).map(function (item, index) {
          return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("li", {
            className: "dropdown-item",
            id: item.currency,
            onClick: function onClick(e) {
              handleItemClick(item);
            },
            children: item.currency
          }, item.currency);
        })
      })
    })]
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dropdown);

/***/ }),

/***/ "./resources/js/components/ui/ImagesUpload.js":
/*!****************************************************!*\
  !*** ./resources/js/components/ui/ImagesUpload.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Button */ "./resources/js/components/ui/Button.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






var ImagesUpload = function ImagesUpload(_ref) {
  var setFileFields = _ref.setFileFields;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]),
      _useState2 = _slicedToArray(_useState, 2),
      filesPreviewArray = _useState2[0],
      setFilesPreviewArray = _useState2[1];

  var fileUploadField = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  var handleFilesField = function handleFilesField(event) {
    var filesList = event.target.files;
    var tempArray = [];

    for (var i = 0; i < filesList.length; i++) {
      tempArray.push(URL.createObjectURL(filesList[i]));
    }

    setFileFields(filesList);
    setFilesPreviewArray(tempArray);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [filesPreviewArray.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
      className: "form-row images-array",
      children: (filesPreviewArray || []).map(function (url, index) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("img", {
          src: url,
          alt: ""
        }, index);
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
      className: "form-row",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("input", {
        type: "file",
        accept: "image/*",
        multiple: true,
        id: "purchase-images",
        ref: fileUploadField,
        onChange: function onChange(event) {
          return handleFilesField(event);
        },
        className: "hidden"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
        onClick: function onClick() {
          return fileUploadField.current.click();
        },
        children: "Upload Images (upto 10)"
      })]
    }), filesPreviewArray.length > 10 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
      className: "form-row error",
      children: "You can upload upto 10 images only!"
    })]
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImagesUpload);

/***/ }),

/***/ "./resources/js/constants/CurrencyList.js":
/*!************************************************!*\
  !*** ./resources/js/constants/CurrencyList.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "currencies": () => (/* binding */ currencies)
/* harmony export */ });
// Options list for dropdown
var currencies = [{
  currency: "XPR",
  contract: "eosio.token",
  decimals: "4"
}, {
  decimals: "4",
  contract: "loan.token",
  currency: "LOAN"
}, {
  currency: "FOOBAR",
  contract: "xtokens",
  decimals: "6"
}, {
  decimals: "4",
  contract: "storex",
  currency: "STRX"
}, {
  currency: "BTCL",
  contract: "wrapper",
  decimals: "8"
}, {
  currency: "XADA",
  decimals: "6",
  contract: "xtokens"
}, {
  currency: "XBCH",
  contract: "xtokens",
  decimals: "8"
}, {
  contract: "xtokens",
  decimals: "8",
  currency: "XBNB"
}, {
  currency: "XBTC",
  contract: "xtokens",
  decimals: "8"
}, {
  currency: "XBUSD",
  contract: "xtokens",
  decimals: "6"
}, {
  currency: "XDOGE",
  contract: "xtokens",
  decimals: "6"
}, {
  contract: "xtokens",
  decimals: "8",
  currency: "XDOT"
}, {
  decimals: "4",
  contract: "xtokens",
  currency: "XEOS"
}, {
  contract: "xtokens",
  decimals: "8",
  currency: "XETH"
}, {
  currency: "XLTC",
  contract: "xtokens",
  decimals: "8"
}, {
  decimals: "6",
  contract: "xtokens",
  currency: "XLUNA"
}, {
  contract: "xtokens",
  decimals: "6",
  currency: "XMDA"
}, {
  currency: "XMT",
  decimals: "8",
  contract: "xtokens"
}, {
  currency: "XPAX",
  contract: "xtokens",
  decimals: "6"
}, {
  currency: "XPAXG",
  contract: "xtokens",
  decimals: "8"
}, {
  currency: "XSOL",
  contract: "xtokens",
  decimals: "6"
}, {
  currency: "XTUSD",
  contract: "xtokens",
  decimals: "6"
}, {
  contract: "xtokens",
  decimals: "6",
  currency: "XUNI"
}, {
  currency: "XUSDC",
  contract: "xtokens",
  decimals: "6"
}, {
  contract: "xtokens",
  decimals: "6",
  currency: "XUSDT"
}, {
  contract: "xtokens",
  decimals: "6",
  currency: "XUST"
}, {
  currency: "XXRP",
  contract: "xtokens",
  decimals: "6"
}, {
  contract: "realestatese",
  currency: "MESSAGE",
  decimals: "4"
}];

/***/ }),

/***/ "./resources/js/pages/PurchaseItem.js":
/*!********************************************!*\
  !*** ./resources/js/pages/PurchaseItem.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _components_ui_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/ui/Button */ "./resources/js/components/ui/Button.js");
/* harmony import */ var _components_ui_Modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/ui/Modal */ "./resources/js/components/ui/Modal.js");
/* harmony import */ var _store_auth_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/auth-context */ "./resources/js/store/auth-context.js");
/* harmony import */ var _components_ui_ImagesUpload__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/ui/ImagesUpload */ "./resources/js/components/ui/ImagesUpload.js");
/* harmony import */ var _components_ui_CurrencyDropdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/ui/CurrencyDropdown */ "./resources/js/components/ui/CurrencyDropdown.js");
/* harmony import */ var _constants_CurrencyList__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants/CurrencyList */ "./resources/js/constants/CurrencyList.js");
/* harmony import */ var _store_wallet_context__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../store/wallet-context */ "./resources/js/store/wallet-context.js");
/* harmony import */ var _sdk_easyescrowSDK__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../sdk/easyescrowSDK */ "./resources/js/sdk/easyescrowSDK.js");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }














var PurchaseItem = function PurchaseItem() {
  var navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_10__.useNavigate)();
  var ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_store_auth_context__WEBPACK_IMPORTED_MODULE_3__["default"]);
  var walletCtx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_store_wallet_context__WEBPACK_IMPORTED_MODULE_7__["default"]);

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState2 = _slicedToArray(_useState, 2),
      successPopup = _useState2[0],
      setSuccessPopup = _useState2[1];

  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState4 = _slicedToArray(_useState3, 2),
      error = _useState4[0],
      setError = _useState4[1];

  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState6 = _slicedToArray(_useState5, 2),
      success = _useState6[0],
      setSuccess = _useState6[1];

  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState8 = _slicedToArray(_useState7, 2),
      checkError = _useState8[0],
      setCheckError = _useState8[1];

  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState10 = _slicedToArray(_useState9, 2),
      loading = _useState10[0],
      setLoading = _useState10[1];

  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]),
      _useState12 = _slicedToArray(_useState11, 2),
      fileFields = _useState12[0],
      setFileFields = _useState12[1];

  var _useState13 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState14 = _slicedToArray(_useState13, 2),
      amountError = _useState14[0],
      setAmountError = _useState14[1];

  var closeSuccessPopup = function closeSuccessPopup() {
    setSuccessPopup(false);
    navigate("/transactions");
  };

  var _useState15 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState16 = _slicedToArray(_useState15, 2),
      title = _useState16[0],
      setTitle = _useState16[1];

  var _useState17 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState18 = _slicedToArray(_useState17, 2),
      description = _useState18[0],
      setDescription = _useState18[1];

  var _useState19 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState20 = _slicedToArray(_useState19, 2),
      amount = _useState20[0],
      setAmount = _useState20[1];

  var _useState21 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    currency: "Select a token",
    amount: "0"
  }),
      _useState22 = _slicedToArray(_useState21, 2),
      token = _useState22[0],
      setToken = _useState22[1];

  var _useState23 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([{
    currency: "Select a token",
    amount: "0"
  }]),
      _useState24 = _slicedToArray(_useState23, 2),
      tokens = _useState24[0],
      setTokens = _useState24[1];

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (walletCtx.balances != [] && walletCtx.balances.length > 0) {
      setToken(walletCtx.balances[0]);
      setTokens(walletCtx.balances);
    }
  }, [walletCtx.balances]);

  var _useState25 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("immediately"),
      _useState26 = _slicedToArray(_useState25, 2),
      transferDate = _useState26[0],
      setTransferDate = _useState26[1];

  var _useState27 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(""),
      _useState28 = _slicedToArray(_useState27, 2),
      sellerName = _useState28[0],
      setSellerName = _useState28[1];

  var _useState29 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState30 = _slicedToArray(_useState29, 2),
      checkExchange = _useState30[0],
      setCheckExchange = _useState30[1];

  var handlePurchaseFormSubmit = function handlePurchaseFormSubmit(event) {
    event.preventDefault();
    if (validateTransactionForm()) handelExchange();
  }; //Validate Form


  var validateTransactionForm = function validateTransactionForm() {
    if (fileFields.length > 10) return false;

    if (title == "" || description == "" || amount == "" || token.currency == "" || sellerName == "") {
      setError("All fields are required.");
      return false;
    } else if (!checkExchange) {
      setError("");
      setCheckError("Please tick the checkbox to confirm exchange");
      return false;
    } else if (parseFloat(token.amount) < parseFloat(amount)) {
      setAmountError("Insufficient amount ".concat(token.currency, " in your wallet"));
    } else {
      setError("");
      setCheckError("");
      return true;
    }
  };

  var sleep = function sleep(milliseconds) {
    var date = Date.now();
    var currentDate = null;

    do {
      currentDate = Date.now();
    } while (currentDate - date < milliseconds);
  };

  var handelExchange = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var formData, _ret;

      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                var authorization, deliverType, typeId, tradeToToken, tradeToAmount, expiry, escrows, myEscrows, loopId, escrowId, _iterator, _step, file;

                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        setLoading(true);
                        authorization = [{
                          actor: ctx.auth.actor,
                          permission: ctx.auth.permission
                        }];
                        deliverType = 0;

                        if (transferDate == "immediately") {
                          deliverType = 1;
                        } else if (transferDate == "delivery") {
                          deliverType = 2;
                        }

                        typeId = 3;
                        tradeToToken = null;
                        tradeToAmount = null;
                        expiry = 0;
                        _context.next = 10;
                        return (0,_sdk_easyescrowSDK__WEBPACK_IMPORTED_MODULE_8__.startEscrow)(typeId, ctx.auth.actor, sellerName, token, tradeToToken, amount, tradeToAmount, deliverType, expiry, authorization, walletCtx.session);

                      case 10:
                        sleep(2000);
                        _context.next = 13;
                        return (0,_sdk_easyescrowSDK__WEBPACK_IMPORTED_MODULE_8__.fetchEscrows)(ctx.auth.actor);

                      case 13:
                        escrows = _context.sent;
                        myEscrows = escrows.filter(function (escrow) {
                          return escrow.from == ctx.auth.actor && typeId == 3;
                        });
                        loopId = 2;

                        if (myEscrows.length) {
                          _context.next = 25;
                          break;
                        }

                      case 17:
                        if (!(!myEscrows.length && loopId)) {
                          _context.next = 25;
                          break;
                        }

                        sleep(2000);
                        _context.next = 21;
                        return (0,_sdk_easyescrowSDK__WEBPACK_IMPORTED_MODULE_8__.fetchEscrows)(ctx.auth.actor);

                      case 21:
                        myEscrows = escrows.filter(function (escrow) {
                          return escrow.from == ctx.auth.actor && typeId == 3;
                        });
                        loopId--;
                        _context.next = 17;
                        break;

                      case 25:
                        escrowId = "0";

                        if (!myEscrows.length) {
                          _context.next = 30;
                          break;
                        }

                        escrowId = myEscrows[myEscrows.length - 1].id.toString();
                        _context.next = 32;
                        break;

                      case 30:
                        setLoading(false);
                        return _context.abrupt("return", {
                          v: void 0
                        });

                      case 32:
                        console.log("my", myEscrows);
                        formData = new FormData();
                        formData.append("type_id", 3);
                        formData.append("amount", amount);
                        formData.append("token", token.currency);
                        formData.append("trade_username", sellerName);
                        formData.append("title", title);
                        formData.append("description", description);
                        formData.append("transfer_type", transferDate);
                        formData.append("escrow_id", Number(escrowId));
                        formData.append("escrow_status", "ready");
                        _iterator = _createForOfIteratorHelper(fileFields);

                        try {
                          for (_iterator.s(); !(_step = _iterator.n()).done;) {
                            file = _step.value;
                            formData.append("image[]", file);
                          } // await startPurchase(
                          //     ctx.auth.actor,
                          //     myEscrows[myEscrows.length - 1].fromTokens[0],
                          //     authorization,
                          //     walletCtx.session
                          // );
                          // await fillEscrow(
                          //     escrowId,
                          //     3,
                          //     ctx.auth.actor,
                          //     null,
                          //     authorization,
                          //     walletCtx.session
                          // );
                          // await negoPurchase(
                          //     22,
                          //     typeId,
                          //     "escrowuser2",
                          //     ctx.auth.actor,
                          //     token,
                          //     null,
                          //     amount,
                          //     null,
                          //     deliverType,
                          //     expiry,
                          //     authorization,
                          //     walletCtx.session
                          // );
                          // console.log("----- Form Array -----");
                          // console.log(fileFields);
                          // console.log("----- Form Data -----");
                          // for (var pair of formData.entries()) {
                          //     console.log(pair[0] + ": " + pair[1]);
                          // }
                          // fetch(`${process.env.MIX_API_URL}/user/addescrow`, {
                          //     method: "POST",
                          //     body: formData,
                          //     headers: {
                          //         Authorization: "Bearer " + ctx.walletName,
                          //     },
                          // })
                          //     .then((response) => {
                          //         if (response.ok) return response.json();
                          //         throw response.status + ": " + response.statusText;
                          //     })
                          //     .then((data) => {
                          //         //console.log(data);
                          //         if (data.valid) {
                          //             setSuccessPopup(true);
                          //             setSuccess(data.message);
                          //         } else {
                          //             setError(data.message);
                          //         }
                          //         setLoading(false);
                          //     })
                          //     .catch((error) => {
                          //         setError(error);
                          //         setLoading(false);
                          //     });

                        } catch (err) {
                          _iterator.e(err);
                        } finally {
                          _iterator.f();
                        }

                      case 45:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              })(), "t0", 2);

            case 2:
              _ret = _context2.t0;

              if (!(_typeof(_ret) === "object")) {
                _context2.next = 5;
                break;
              }

              return _context2.abrupt("return", _ret.v);

            case 5:
              _context2.next = 11;
              break;

            case 7:
              _context2.prev = 7;
              _context2.t1 = _context2["catch"](0);
              console.log("ERROR", _context2.t1);
              setLoading(false);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[0, 7]]);
    }));

    return function handelExchange() {
      return _ref.apply(this, arguments);
    };
  }();

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("main", {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
        className: "container banner-inner",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("h1", {
          children: "Purchase an Item"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("h3", {
          children: "This escrow allows any user to easily utilize a smart contract to verify and pay for any item with select cryptocurrencies"
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
        className: "container block",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("form", {
          onSubmit: handlePurchaseFormSubmit,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("label", {
              htmlFor: "purchase-title",
              children: "Add a title for the item to purchase"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("input", {
              type: "text",
              id: "purchase-title",
              value: title,
              onChange: function onChange(event) {
                return setTitle(event.target.value);
              }
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("label", {
              htmlFor: "purchase-desc",
              children: "Description of purchase"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("textarea", {
              id: "purchase-desc",
              value: description,
              onChange: function onChange(event) {
                return setDescription(event.target.value);
              }
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_components_ui_ImagesUpload__WEBPACK_IMPORTED_MODULE_4__["default"], {
            setFileFields: setFileFields
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("label", {
              htmlFor: "purchase-amount",
              children: "Enter a numerical amount of tokens as the purchase price:"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("input", {
              type: "number",
              step: "0.01",
              id: "purchase-amount",
              value: amount,
              onChange: function onChange(event) {
                return setAmount(event.target.value);
              }
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("label", {
              htmlFor: "purchase_token",
              children: "Select a token:"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_components_ui_CurrencyDropdown__WEBPACK_IMPORTED_MODULE_5__["default"], {
              options: tokens,
              selectedOption: token,
              setSelectedOption: setToken
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("label", {
              htmlFor: "purchase_token",
              children: "Transfer Date:"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
              className: "radio",
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("input", {
                type: "radio",
                id: "immediately",
                name: "purchase-date",
                value: "immediately",
                checked: transferDate == "immediately",
                onChange: function onChange() {
                  return setTransferDate("immediately");
                }
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("label", {
                htmlFor: "immediately",
                children: "Immediately"
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
              className: "radio",
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("input", {
                type: "radio",
                id: "on-delivery",
                name: "purchase-date",
                value: "on delivery",
                checked: transferDate == "delivery",
                onChange: function onChange() {
                  return setTransferDate("delivery");
                }
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("label", {
                htmlFor: "on-delivery",
                children: "Upon Delivery of Purchased Item"
              })]
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "form-row",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("label", {
              htmlFor: "seller-name",
              children: "Enter the Proton @name of the seller:"
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
              className: "input-group",
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("span", {
                className: "input-group-text",
                children: "@"
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("input", {
                type: "text",
                id: "seller-name",
                value: sellerName,
                onChange: function onChange(event) {
                  return setSellerName(event.target.value);
                }
              })]
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "form-row",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("p", {
              children: "Please confirm the following proposed purchase"
            })
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "form-row confirm-check",
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("input", {
              type: "checkbox",
              id: "crypto_exchange",
              name: "crypto_exchange",
              value: checkExchange,
              onChange: function onChange(event) {
                return setCheckExchange(event.target.checked);
              }
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("label", {
              htmlFor: "crypto_exchange",
              children: "Please confirm this transaction and ".concat(amount || "(token numerical amount)", " ").concat(token.currency || "(token name)", " will be moved out of your Proton wallet into the EasyEscrow Smart Contract. @").concat(sellerName || "(second user)", " will be notified to review this transaction.")
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "form-row",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("p", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("small", {
                children: "If this is correct please confirm and your crypto will be moved out of your Proton wallet into the EasyEscrow Smart Contract."
              })
            })
          }), checkError !== "" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "form-row error",
            children: checkError
          }), error !== "" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "form-row error",
            children: error
          }), amountError !== "" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "form-row error",
            children: amountError
          }), ctx.isLoggedIn && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "form-row",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_components_ui_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
              label: "Confirm",
              type: "submit",
              loading: loading
            })
          }), !ctx.isLoggedIn && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "form-row",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_components_ui_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
              label: "Login",
              onClick: /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return walletCtx.protonConnection();

                      case 2:
                        return _context3.abrupt("return", _context3.sent);

                      case 3:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              })),
              loading: loading
            })
          })]
        })
      })]
    }), successPopup && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_components_ui_Modal__WEBPACK_IMPORTED_MODULE_2__["default"], {
      hidePopup: function hidePopup() {
        return setSuccessPopup(false);
      },
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("h3", {
          className: "modal-header",
          children: "Purchase an Item"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
          className: "form-row success",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("p", {
            children: success
          })
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
          className: "modal-confirm",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_components_ui_Button__WEBPACK_IMPORTED_MODULE_1__["default"], {
            label: "Continue",
            onClick: closeSuccessPopup
          })
        })]
      })
    })]
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PurchaseItem);

/***/ }),

/***/ "./resources/js/sdk/easyescrowSDK.js":
/*!*******************************************!*\
  !*** ./resources/js/sdk/easyescrowSDK.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cancelEscrow": () => (/* binding */ cancelEscrow),
/* harmony export */   "fetchEscrowAll": () => (/* binding */ fetchEscrowAll),
/* harmony export */   "fetchEscrows": () => (/* binding */ fetchEscrows),
/* harmony export */   "fillEscrow": () => (/* binding */ fillEscrow),
/* harmony export */   "negoPurchase": () => (/* binding */ negoPurchase),
/* harmony export */   "startEscrow": () => (/* binding */ startEscrow),
/* harmony export */   "startPurchase": () => (/* binding */ startPurchase)
/* harmony export */ });
/* harmony import */ var _proton_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @proton/api */ "./node_modules/@proton/api/dist/api.esm.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants_networks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/networks.js */ "./resources/js/constants/networks.js");
/* harmony import */ var _protonAPI_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./protonAPI.js */ "./resources/js/sdk/protonAPI.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

//Use API to save transaction details




var api = new _proton_api__WEBPACK_IMPORTED_MODULE_0__.ApiClass(_constants_networks_js__WEBPACK_IMPORTED_MODULE_2__.current_network.chain);
var contract = "easyescrow2";
var feeContract = "xtokens";
var feeQuantity = "0.250000 XUSDC";
function fetchEscrowAll() {
  return _fetchEscrowAll.apply(this, arguments);
}

function _fetchEscrowAll() {
  _fetchEscrowAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var _yield$api$rpc$get_ta, rows;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return api.rpc.get_table_rows({
              code: contract,
              scope: contract,
              table: "escrows",
              index_position: 2,
              key_type: "i64",
              limit: -1
            });

          case 2:
            _yield$api$rpc$get_ta = _context3.sent;
            rows = _yield$api$rpc$get_ta.rows;
            return _context3.abrupt("return", rows);

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _fetchEscrowAll.apply(this, arguments);
}

function fetchEscrows(_x) {
  return _fetchEscrows.apply(this, arguments);
}

function _fetchEscrows() {
  _fetchEscrows = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(accountName) {
    var _yield$api$rpc$get_ta2, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return api.rpc.get_table_rows({
              code: contract,
              scope: contract,
              table: "escrows",
              index_position: 2,
              key_type: "i64",
              lower_bound: accountName,
              upper_bound: accountName,
              limit: -1
            });

          case 2:
            _yield$api$rpc$get_ta2 = _context4.sent;
            rows = _yield$api$rpc$get_ta2.rows;
            return _context4.abrupt("return", rows);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _fetchEscrows.apply(this, arguments);
}

function startEscrow(_x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12) {
  return _startEscrow.apply(this, arguments);
}

function _startEscrow() {
  _startEscrow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(typeId, from, to, fromToken, toToken, fromAmount, toAmount, deliverType, expiry, authorization, session) {
    var amountIn, fromQuantity, actions, amountOut, toQuantity, memo;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            amountIn = parseFloat(fromAmount).toFixed(Number(fromToken.decimals)).toString();
            fromQuantity = amountIn + " " + fromToken.currency;
            actions = [];

            if (typeId == 1) {
              amountOut = parseFloat(toAmount).toFixed(Number(toToken.decimals)).toString();
              toQuantity = amountOut + " " + toToken.currency;
              actions = [{
                account: feeContract,
                name: "transfer",
                data: {
                  from: from,
                  to: contract,
                  quantity: feeQuantity,
                  memo: "".concat(from, " deposit a fee for exchange.")
                },
                authorization: authorization
              }, {
                account: fromToken.contract,
                name: "transfer",
                data: {
                  from: from,
                  to: contract,
                  quantity: fromQuantity,
                  memo: "".concat(from, " deposit for exchange.")
                },
                authorization: authorization
              }, {
                account: contract,
                name: "startescrow",
                data: {
                  typeId: typeId,
                  from: from,
                  to: to,
                  fromTokens: [{
                    contract: fromToken.contract,
                    quantity: fromQuantity
                  }],
                  fromNfts: [],
                  toTokens: [{
                    contract: toToken.contract,
                    quantity: toQuantity
                  }],
                  toNfts: [],
                  deliverType: deliverType,
                  expiry: expiry
                },
                authorization: authorization
              }];
            } else if (typeId == 2) {
              actions = [{
                account: feeContract,
                name: "transfer",
                data: {
                  from: from,
                  to: contract,
                  quantity: feeQuantity,
                  memo: "".concat(from, " deposit a fee for a gift.")
                },
                authorization: authorization
              }, {
                account: fromToken.contract,
                name: "transfer",
                data: {
                  from: from,
                  to: contract,
                  quantity: fromQuantity,
                  memo: "".concat(from, " deposit for a gift")
                },
                authorization: authorization
              }, {
                account: contract,
                name: "startescrow",
                data: {
                  typeId: typeId,
                  from: from,
                  to: to,
                  fromTokens: [{
                    contract: fromToken.contract,
                    quantity: fromQuantity
                  }],
                  fromNfts: [],
                  toTokens: [],
                  toNfts: [],
                  deliverType: deliverType,
                  expiry: Math.floor(expiry / 1000)
                },
                authorization: authorization
              }];
            } else if (typeId == 3 || typeId == 4) {
              memo = "".concat(from, " deposited for Purchase Item.");

              if (typeId == 4) {
                memo = "".concat(from, " deposited for Purchase Service.");
              } //in this case only store to proton db. not send coin


              actions = [{
                account: contract,
                name: "startescrow",
                data: {
                  typeId: typeId,
                  from: from,
                  to: to,
                  fromTokens: [{
                    contract: fromToken.contract,
                    quantity: fromQuantity
                  }],
                  fromNfts: [],
                  toTokens: [],
                  toNfts: [],
                  deliverType: deliverType,
                  expiry: expiry
                },
                authorization: authorization
              }];
            }

            _context5.next = 6;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 6:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _startEscrow.apply(this, arguments);
}

function fillEscrow(_x13, _x14, _x15, _x16, _x17, _x18) {
  return _fillEscrow.apply(this, arguments);
}

function _fillEscrow() {
  _fillEscrow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(escrowId, typeId, actor, toToken, authorization, session) {
    var actions, contractauth, result;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            actions = [];

            if (!(typeId == 1)) {
              _context6.next = 5;
              break;
            }

            actions = [{
              account: feeContract,
              name: "transfer",
              data: {
                from: actor,
                to: contract,
                quantity: feeQuantity,
                memo: "".concat(actor, " deposit a fee for exchange.")
              },
              authorization: authorization
            }, {
              account: toToken.contract,
              name: "transfer",
              data: {
                from: actor,
                to: contract,
                quantity: toToken.quantity,
                memo: "".concat(actor, " deposit for exchange.")
              },
              authorization: authorization
            }, {
              account: contract,
              name: "fillescrow",
              data: {
                actor: actor,
                id: escrowId.toString()
              },
              authorization: authorization
            }];
            _context6.next = 22;
            break;

          case 5:
            if (!(typeId == 2)) {
              _context6.next = 21;
              break;
            }

            contractauth = [{
              actor: contract,
              permission: "active"
            }];
            actions = [{
              account: contract,
              name: "fillescrow",
              data: {
                actor: actor,
                id: escrowId.toString()
              },
              authorization: contractauth
            }];
            _context6.prev = 8;
            _context6.next = 11;
            return (0,_protonAPI_js__WEBPACK_IMPORTED_MODULE_3__.transact)(actions);

          case 11:
            result = _context6.sent;
            console.log("result", result);
            return _context6.abrupt("return", result);

          case 16:
            _context6.prev = 16;
            _context6.t0 = _context6["catch"](8);
            console.error("error here??", _context6.t0);

          case 19:
            _context6.next = 22;
            break;

          case 21:
            if (typeId == 3 || typeId == 4) {
              actions = [{
                account: contract,
                name: "fillescrow",
                data: {
                  actor: actor,
                  id: escrowId.toString()
                },
                authorization: authorization
              }];
            }

          case 22:
            if (!(typeId != 2)) {
              _context6.next = 25;
              break;
            }

            _context6.next = 25;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 25:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[8, 16]]);
  }));
  return _fillEscrow.apply(this, arguments);
}

function cancelEscrow(_x19, _x20, _x21, _x22) {
  return _cancelEscrow.apply(this, arguments);
}

function _cancelEscrow() {
  _cancelEscrow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(escrowId, actor, authorization, session) {
    var actions;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            actions = [{
              account: contract,
              name: "cancelescrow",
              data: {
                actor: actor,
                id: escrowId.toString()
              },
              authorization: authorization
            }];
            _context7.next = 3;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _cancelEscrow.apply(this, arguments);
}

function startPurchase(_x23, _x24, _x25, _x26) {
  return _startPurchase.apply(this, arguments);
}

function _startPurchase() {
  _startPurchase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(from, token, authorization, session) {
    var actions;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            actions = [{
              account: feeContract,
              name: "transfer",
              data: {
                from: from,
                to: contract,
                quantity: feeQuantity,
                memo: "".concat(from, " deposit a fee for a purchase.")
              },
              authorization: authorization
            }, {
              account: token.contract,
              name: "transfer",
              data: {
                from: from,
                to: contract,
                quantity: token.quantity,
                memo: "".concat(from, " deposit for purchase.")
              },
              authorization: authorization
            }];
            _context8.next = 3;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 3:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _startPurchase.apply(this, arguments);
}

function negoPurchase(_x27, _x28, _x29, _x30, _x31, _x32, _x33, _x34, _x35, _x36, _x37, _x38) {
  return _negoPurchase.apply(this, arguments);
}

function _negoPurchase() {
  _negoPurchase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(escrowId, typeId, from, to, fromToken, toToken, fromAmount, toAmount, deliverType, expiry, authorization, session) {
    var amountIn, fromQuantity, actions;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            amountIn = parseFloat(fromAmount).toFixed(Number(fromToken.decimals)).toString();
            fromQuantity = amountIn + " " + fromToken.currency;
            actions = [{
              account: contract,
              name: "negopurchase",
              data: {
                escrowId: escrowId,
                typeId: typeId,
                from: from,
                to: to,
                fromTokens: [{
                  contract: fromToken.contract,
                  quantity: fromQuantity
                }],
                fromNfts: [],
                toTokens: [],
                toNfts: [],
                deliverType: deliverType,
                expiry: expiry
              },
              authorization: authorization
            }];
            _context9.next = 5;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 5:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _negoPurchase.apply(this, arguments);
}

var tablerows = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var protonrows, _iterator, _step, _loop;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return fetchEscrowAll();

          case 2:
            protonrows = _context2.sent;
            console.log(protonrows);

            if (Object.keys(protonrows).length != 0) {
              _iterator = _createForOfIteratorHelper(protonrows);

              try {
                _loop = function _loop() {
                  var obj = _step.value;
                  var newdatetenminutes = new Date();
                  var difference = newdatetenminutes.getMinutes() - 10;
                  newdatetenminutes.setMinutes(difference);
                  var timestamp = obj.expiry * 1000;
                  var date = new Date(timestamp);

                  if (date > newdatetenminutes && date <= new Date()) {
                    var giftresponsecall = /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                        var giftresponse, res, datas;
                        return _regeneratorRuntime().wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _context.next = 2;
                                return fillEscrow(obj.id, 2, obj.from, null, null, null);

                              case 2:
                                giftresponse = _context.sent;

                                if (giftresponse) {
                                  res = {
                                    escrow_id: obj.id,
                                    type_id: 2
                                  };
                                  datas = JSON.stringify(res);
                                  axios__WEBPACK_IMPORTED_MODULE_1___default()({
                                    method: "post",
                                    url: "https://easyescrow.io/api/user/gift-update-status",
                                    data: datas,
                                    config: {
                                      headers: {
                                        "Content-Type": "application/json"
                                      }
                                    }
                                  }).then(function (response) {
                                    console.log(response.data.response);
                                  })["catch"](function (response) {
                                    console.log(response);
                                  });
                                } else {
                                  console.log(giftresponse);
                                }

                              case 4:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function giftresponsecall() {
                        return _ref2.apply(this, arguments);
                      };
                    }();

                    console.log("current date", new Date());
                    console.log("calling fill gift function");
                    console.log("running escrow", obj.id);
                    console.log("running escrow date", date);
                    giftresponsecall();
                  } else {
                    console.log("skip escrow", obj.id);
                    console.log("skip escrow date", date);
                    console.log("current date", new Date());
                  }
                };

                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  _loop();
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            } else {
              console.log("no rows found");
            }

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function tablerows() {
    return _ref.apply(this, arguments);
  };
}();

tablerows(); // const history = await api.getActionsFromHyperion(ctx.auth.actor, {
//     limit: 10,
//     skip: 0,
//     sort: "desc",
//     filter: contract*",
// });
// console.log("History", history);

/***/ }),

/***/ "./resources/js/sdk/protonAPI.js":
/*!***************************************!*\
  !*** ./resources/js/sdk/protonAPI.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "api": () => (/* binding */ api),
/* harmony export */   "rpc": () => (/* binding */ rpc),
/* harmony export */   "transact": () => (/* binding */ transact)
/* harmony export */ });
/* harmony import */ var _proton_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @proton/js */ "./node_modules/@proton/js/dist/index.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants_networks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/networks */ "./resources/js/constants/networks.js");



var rpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc([_constants_networks__WEBPACK_IMPORTED_MODULE_2__.current_network.endpoint], {
  fetch: (node_fetch__WEBPACK_IMPORTED_MODULE_1___default())
});
var api = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.Api({
  rpc: rpc,
  signatureProvider: new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsSignatureProvider(["PVT_K1_2Sg3jdbgAfc8fJct2MVHpUjRWJvtDhitxD5p59warXSQrXXWA3"])
});
function transact(actions) {
  console.log("come here, then why?");
  api.transact({
    actions: actions
  }, {
    blocksBehind: 300,
    expireSeconds: 3000
  });
}

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/***/ ((module) => {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  // Node.js and other environments that support module.exports.
  } else {}
})(this);


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/dayjs/dayjs.min.js":
/*!*****************************************!*\
  !*** ./node_modules/dayjs/dayjs.min.js ***!
  \*****************************************/
/***/ (function(module) {

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},v="en",D={};D[v]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return v;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(v=i),i||!r&&v},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var v=this.$locale().weekStart||0,D=(y<v?y+7:y)-v;return $(r?m-D:m+(6-D),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,v=O.m(this,M);return v=(l={},l[c]=v/12,l[f]=v,l[h]=v/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?v:O.a(v)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[v],w.Ls=D,w.p={},w}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/advancedFormat.js":
/*!*****************************************************!*\
  !*** ./node_modules/dayjs/plugin/advancedFormat.js ***!
  \*****************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(function(){"use strict";return function(e,t,r){var n=t.prototype,s=n.format;r.en.ordinal=function(e){var t=["th","st","nd","rd"],r=e%100;return"["+e+(t[(r-20)%10]||t[r]||t[0])+"]"},n.format=function(e){var t=this,r=this.$locale();if(!this.isValid())return s.bind(this)(e);var n=this.$utils(),a=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return r.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return r.ordinal(t.week(),"W");case"w":case"ww":return n.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return n.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return n.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return"["+t.offsetName()+"]";case"zzz":return"["+t.offsetName("long")+"]";default:return e}}));return s.bind(this)(a)}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/relativeTime.js":
/*!***************************************************!*\
  !*** ./node_modules/dayjs/plugin/relativeTime.js ***!
  \***************************************************/
/***/ (function(module) {

!function(r,e){ true?module.exports=e():0}(this,(function(){"use strict";return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return"function"==typeof M?M(a):M.replace("%s",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/timezone.js":
/*!***********************************************!*\
  !*** ./node_modules/dayjs/plugin/timezone.js ***!
  \***********************************************/
/***/ (function(module) {

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||"short",o=t+"|"+i,r=e[o];return r||(r=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:t,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],l=24===d?0:d,v=r[0]+"-"+r[1]+"-"+r[2]+" "+l+":"+r[4]+":"+r[5]+":000",h=+e;return(o.utc(v).valueOf()-(h-=h%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n=this.utcOffset(),i=this.toDate(),a=i.toLocaleString("en-US",{timeZone:t}),u=Math.round((i-new Date(a))/1e3/60),f=o(a).$set("millisecond",this.$ms).utcOffset(15*-Math.round(i.getTimezoneOffset()/15)-u,!0);if(e){var s=f.utcOffset();f=f.add(n-s,"minute")}return f.$x.$timezone=t,f},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return"timezonename"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format("YYYY-MM-DD HH:mm:ss:SSS"));return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if("string"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/utc.js":
/*!******************************************!*\
  !*** ./node_modules/dayjs/plugin/utc.js ***!
  \******************************************/
/***/ (function(module) {

!function(t,i){ true?module.exports=i():0}(this,(function(){"use strict";var t="minute",i=/[+-]\d\d(?::?\d\d)?/g,e=/([+-]|\d\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t)};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else r.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if("string"==typeof s&&(s=function(t){void 0===t&&(t="");var s=t.match(i);if(!s)return null;var f=(""+s[0]).match(e)||["-",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:"+"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return"s"===t&&this.$offset?n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/g, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/MapLike.js":
/*!*************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/MapLike.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class MapLike {
    constructor() {
        this._map = {};
    }
    get size() {
        return this.keys().length;
    }
    clear() {
        for (const key in this._map) {
            delete this._map[key];
        }
    }
    delete(key) {
        if (this.has(key)) {
            return delete this._map[key];
        }
        return false;
    }
    get(key) {
        return this._map[key];
    }
    has(key) {
        return this._map[key] !== undefined;
    }
    keys() {
        return Object.keys(this._map);
    }
    set(key, value) {
        this._map[key] = value;
        return this;
    }
    values() {
        const values = [];
        for (const key in this._map) {
            values.push(this._map[key]);
        }
        return values;
    }
}
exports["default"] = MapLike;
//# sourceMappingURL=MapLike.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/MessageHandler.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/MessageHandler.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/jsonrpc2-ws/lib/common.js");
const EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
class MessageHandler extends EventEmitter {
    constructor(options) {
        super();
        this.options = options;
        this.methods = new Map();
    }
    async handleMessage(socket, data) {
        const calls = [];
        const responses = [];
        let isBinary = false;
        let isArray = false;
        if (data instanceof ArrayBuffer) {
            isBinary = true;
            data = Buffer.from(data).toString();
        }
        else if (data instanceof Buffer) {
            isBinary = true;
            data = data.toString();
        }
        else if (Array.isArray(data)) {
            isBinary = true;
            data = "[" + data.map(buf => buf.toString()).join(",") + "]";
        }
        try {
            const obj = JSON.parse(data);
            if (Array.isArray(obj)) {
                isArray = true;
                if (obj.length === 0) {
                    const res = {
                        jsonrpc: "2.0",
                        error: common_1.createError(-32600 /* InvalidRequest */, null, "Empty Array"),
                        id: null
                    };
                    socket.send(JSON.stringify(res), isBinary);
                    return;
                }
                calls.push(...obj);
            }
            else {
                calls.push(obj);
            }
        }
        catch (e) {
            const res = {
                jsonrpc: "2.0",
                error: common_1.createError(-32700 /* ParseError */, null, "Invalid JSON"),
                id: null
            };
            socket.send(JSON.stringify(res), isBinary);
            return;
        }
        for (const call of calls) {
            const res = await this._processCall(socket, call);
            if (res) {
                responses.push(res);
            }
        }
        if (responses.length === 0) {
            return;
        }
        socket.send(JSON.stringify(isArray ? responses : responses[0]), isBinary);
    }
    async _processCall(socket, call) {
        const reqId = call.id;
        const res = {
            jsonrpc: "2.0",
            id: reqId === undefined ? null : reqId
        };
        if (typeof call !== "object") {
            res.error = common_1.createError(-32600 /* InvalidRequest */);
            return res;
        }
        if (call.jsonrpc !== "2.0" && (this.options.jsonrpcVersionCheck === 0 /* STRICT */ ||
            (this.options.jsonrpcVersionCheck === 1 /* LOOSE */ && call.jsonrpc !== undefined))) {
            res.error = common_1.createError(-32600 /* InvalidRequest */, null, "Invalid JSON-RPC Version");
            return res;
        }
        if (common_1.isResponse(call)) {
            this.emit("response", socket, call);
            if (call.id !== null) {
                this.emit("method_response", socket, call);
                return;
            }
            if (!call.error) {
                res.error = common_1.createError(-32600 /* InvalidRequest */);
                return res;
            }
            this.emit("error_response", socket, call);
            if (call.error.code === -32700 /* ParseError */ || call.error.code === -32600 /* InvalidRequest */) {
                return;
            }
            this.emit("notification_error", socket, call.error);
            return;
        }
        if (!call.method) {
            res.error = common_1.createError(-32601 /* MethodNotFound */, null, "Method not specified");
            return res;
        }
        if (typeof call.method !== "string") {
            res.error = common_1.createError(-32600 /* InvalidRequest */, null, "Invalid type of method name");
            return res;
        }
        if ("params" in call && (typeof call.params !== "object" || call.params === null)) {
            res.error = common_1.createError(-32600 /* InvalidRequest */);
            return res;
        }
        if (this.methods.has(call.method) === false) {
            res.error = common_1.createError(-32601 /* MethodNotFound */);
            return res;
        }
        try {
            res.result = await this.methods.get(call.method)(socket, call.params) || null;
            if (reqId === undefined) {
                return;
            }
            return res;
        }
        catch (e) {
            if (reqId === undefined) {
                return;
            }
            if (e instanceof Error) {
                res.error = common_1.createError(-32000 /* ServerError */, e.name, e.message);
            }
            else {
                res.error = e;
            }
            return res;
        }
    }
}
exports["default"] = MessageHandler;
//# sourceMappingURL=MessageHandler.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/client.js":
/*!************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/client.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigDefaults = void 0;
const WebSocket = __webpack_require__(/*! isomorphic-ws */ "./node_modules/isomorphic-ws/browser.js");
const Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");
const EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/jsonrpc2-ws/lib/common.js");
const MessageHandler_1 = __webpack_require__(/*! ./MessageHandler */ "./node_modules/jsonrpc2-ws/lib/MessageHandler.js");
exports.ConfigDefaults = Object.freeze({
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    reconnectionJitter: 0.5,
    methodCallTimeout: 20000,
    autoConnect: true,
    bufferSendingMessages: true,
    query: {},
    protocols: ""
});
/**
 * JSON-RPC 2.0 Client
 */
class Client extends EventEmitter {
    /**
     * Create an instance
     * @param uri The URI to connect.
     * @param options Options
     */
    constructor(uri, options = {}) {
        super();
        this.uri = uri;
        this.sendingMessageBuffer = [];
        this._reconnecting = false;
        this._responseHandlers = new Map();
        this._skipReconnection = false;
        this._currentRequestId = 0;
        this.config = {
            ...exports.ConfigDefaults,
            ...options
        };
        this._backoff = new Backoff({
            min: this.config.reconnectionDelay,
            max: this.config.reconnectionDelayMax,
            jitter: this.config.reconnectionJitter
        });
        this._messageHandler = new MessageHandler_1.default(this.config);
        this._messageHandler.on("method_response", (socket, response) => this._handleMethodResponse(response));
        this._messageHandler.on("error_response", (socket, response) => this.emit("error_response", response));
        this._messageHandler.on("notification_error", (socket, error) => this.emit("notification_error", error));
        if (this.config.autoConnect) {
            this.connect().catch(() => void 0);
        }
    }
    get methods() { return this._messageHandler.methods; }
    /**
     * Connect to the server
     */
    async connect() {
        if (this._ws) {
            return;
        }
        this.emit("connecting");
        const ws = this._ws = new WebSocket(this.uri, this.config.protocols, this.config);
        if (ws.addEventListener) {
            ws.addEventListener("error", error => this.emit("error", error));
            ws.addEventListener("close", ({ code, reason }) => {
                this.emit("close");
                this.emit("disconnect", code, reason);
                this._ws = null;
            });
            ws.addEventListener("message", ({ data }) => this._messageHandler.handleMessage(this, data).catch(e => this.emit("error", e)));
        }
        else {
            ws.on("error", error => this.emit("error", error));
            ws.on("close", (code, reason) => {
                this.emit("close");
                this.emit("disconnect", code, reason);
                this._ws = null;
            });
            ws.on("message", data => this._messageHandler.handleMessage(this, data).catch(e => this.emit("error", e)));
        }
        if (this.config.reconnection) {
            this._skipReconnection = false;
            if (ws.addEventListener) {
                ws.addEventListener("close", () => this.reconnect());
            }
            else {
                ws.on("close", () => this.reconnect());
            }
        }
        await new Promise((resolve, reject) => {
            if (ws.addEventListener) {
                ws.addEventListener("open", () => {
                    ws.removeEventListener("error", reject);
                    resolve();
                }, { once: true });
                ws.addEventListener("error", reject, { once: true });
            }
            else {
                ws.once("open", () => {
                    ws.off("error", reject);
                    resolve();
                });
                ws.once("error", reject);
            }
        });
        await this._sendBufferedMessages();
        this.emit("connected");
    }
    /**
     * Disconnect the connection if it exists
     */
    async disconnect() {
        this._skipReconnection = true;
        this._reconnecting = false;
        this._backoff.reset();
        // clear method call timeout.
        for (const [timer] of this._responseHandlers) {
            clearTimeout(timer);
        }
        this._responseHandlers.clear();
        // clear reconnection timer.
        if (this._reconnectionSleepTimer) {
            clearTimeout(this._reconnectionSleepTimer);
            this._reconnectionSleepTimer = null;
        }
        const ws = this._ws;
        if (!ws) {
            return Promise.resolve();
        }
        let promise;
        if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            promise = new Promise(resolve => {
                if (ws.addEventListener) {
                    ws.addEventListener("close", () => resolve(), { once: true });
                }
                else {
                    ws.once("close", () => resolve());
                }
            });
            ws.close();
        }
        else {
            promise = Promise.resolve();
        }
        this._ws = null;
        await promise;
        if (ws.removeAllListeners) {
            // for node
            ws.removeAllListeners();
        }
        else {
            // for browser
            // not necessary at this time.
        }
    }
    send(data, binary = false) {
        if (binary && typeof data === "string") {
            data = Buffer.from(data).buffer;
        }
        if (!this.isConnected()) {
            this._bufferSendingMessage(data);
            return;
        }
        this._ws.send(data, e => e ? this._bufferSendingMessage(data) : null);
    }
    clearSendingMessageBuffer() {
        this.sendingMessageBuffer.length = 0;
    }
    notify(method, params) {
        const data = {
            jsonrpc: "2.0",
            method,
            params
        };
        this.send(JSON.stringify(data));
    }
    call(method, params = {}) {
        const id = this._currentRequestId++;
        const data = {
            jsonrpc: "2.0",
            method,
            params,
            id
        };
        this.send(JSON.stringify(data));
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this._responseHandlers.delete(id);
                reject(new Error("JSON-RPC: method call timeout"));
            }, this.config.methodCallTimeout);
            this._responseHandlers.set(id, [timeout, resolve, reject]);
        });
    }
    isConnected() {
        return this._ws !== null && this._ws.readyState === WebSocket.OPEN;
    }
    async reconnect() {
        if (this._reconnecting || this._skipReconnection) {
            return;
        }
        const backoff = this._backoff;
        if (backoff.attempts > this.config.reconnectionAttempts) {
            this.emit("reconnect_failed");
            this.disconnect();
            return;
        }
        const delay = backoff.duration();
        this._reconnecting = true;
        await new Promise(resolve => this._reconnectionSleepTimer = setTimeout(resolve, delay));
        this._reconnectionSleepTimer = null;
        if (this._skipReconnection) {
            return;
        }
        this.emit("reconnecting", backoff.attempts);
        if (this._skipReconnection) {
            return;
        }
        try {
            await this.connect();
        }
        catch (err) {
            this._reconnecting = false;
            this.reconnect();
            this.emit("reconnect_error", err);
            return;
        }
        const attempts = backoff.attempts;
        backoff.reset();
        this._reconnecting = false;
        this.emit("reconnected", attempts);
    }
    _handleMethodResponse(response) {
        if (typeof response.id === "string") {
            this.emit("unkown_response", response);
            return;
        }
        const handler = this._responseHandlers.get(response.id);
        if (!handler) {
            this.emit("unkown_response", response);
            return;
        }
        this._responseHandlers.delete(response.id);
        const [timer, resolve, reject] = handler;
        clearTimeout(timer);
        if (common_1.isSuccessResponse(response)) {
            resolve(response.result);
        }
        else {
            reject(response.error);
        }
    }
    _bufferSendingMessage(data) {
        if (this.config.bufferSendingMessages) {
            this.sendingMessageBuffer.push(data);
        }
        else {
            throw new Error("Message is rejected:  The socket is close without message buffering.");
        }
    }
    async _sendBufferedMessages() {
        const buffer = this.sendingMessageBuffer;
        const ws = this._ws;
        for (let data = buffer.shift(); data; data = buffer.shift()) {
            try {
                await new Promise((resolve, reject) => ws.send(data, e => e ? reject(e) : resolve()));
            }
            catch (e) {
                buffer.unshift(data);
                this.emit("buffer_sending_error", e);
                break;
            }
        }
    }
}
exports["default"] = Client;
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/common.js":
/*!************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/common.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createError = exports.errorCodeMap = exports.isSuccessResponse = exports.isResponse = void 0;
/**
 * Check type of call is an Reponse or not
 * @param call an Call object which will be checked.
 */
function isResponse(call) {
    return "id" in call && ("result" in call || "error" in call);
}
exports.isResponse = isResponse;
/**
 * Check type of response is SuccessResponse or not
 *
 * @param response an Response object which will be checked.
 */
function isSuccessResponse(response) {
    return "result" in response && response.id !== null;
}
exports.isSuccessResponse = isSuccessResponse;
/**
 * JSON-RPC 2.0 Error Codes
 */
exports.errorCodeMap = new Map([
    [-32700, "Parse error"],
    [-32600, "Invalid Request"],
    [-32601, "Method not found"],
    [-32602, "Invalid params"],
    [-32603, "Internal error"],
    [-32000, "Server error"]
]);
/**
 * Creates a JSON-RPC 2.0 compliant Error Object
 * @param code A Number that indicates the error type that occurred. (Integer)
 * @param data A Primitive or Structured value that contains additional information about the error.
 */
function createError(code, message, data) {
    const error = {
        code: code,
        message: message || exports.errorCodeMap.get(code) || "Server error"
    };
    if (data !== undefined) {
        error.data = data;
    }
    return error;
}
exports.createError = createError;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = exports.Server = void 0;
var server_1 = __webpack_require__(/*! ./server */ "./node_modules/jsonrpc2-ws/lib/server.js");
Object.defineProperty(exports, "Server", ({ enumerable: true, get: function () { return server_1.default; } }));
var client_1 = __webpack_require__(/*! ./client */ "./node_modules/jsonrpc2-ws/lib/client.js");
Object.defineProperty(exports, "Client", ({ enumerable: true, get: function () { return client_1.default; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/server.js":
/*!************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Socket = void 0;
const EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
const ws_1 = __webpack_require__(/*! ws */ "./node_modules/ws/browser.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const MessageHandler_1 = __webpack_require__(/*! ./MessageHandler */ "./node_modules/jsonrpc2-ws/lib/MessageHandler.js");
const MapLike_1 = __webpack_require__(/*! ./MapLike */ "./node_modules/jsonrpc2-ws/lib/MapLike.js");
/**
 * JSON-RPC 2.0 WebSocket Server
 */
class Server extends EventEmitter {
    /**
     * Create a instance.
     * @param options
     * @param callback callback A listener for the `listening` event (ws).
     */
    constructor(options, callback) {
        super();
        this.sockets = new Map();
        this._lastPingAt = 0;
        this.options = Object.assign({
            pingTimeout: 5000,
            pingInterval: 25000,
            open: true,
            jsonrpcVersionCheck: 0 /* STRICT */,
            uws: false
        }, options);
        this._messageHandler = new MessageHandler_1.default(this.options);
        this._messageHandler.on("error_response", (socket, response) => {
            this.emit("error_response", socket, response);
            socket.emit("error_response", response);
        });
        this._messageHandler.on("notification_error", (socket, error) => {
            this.emit("notification_error", socket, error);
            socket.emit("notification_error", error);
        });
        if (this.options.open) {
            this.open(callback);
        }
    }
    get methods() { return this._messageHandler.methods; }
    /**
     * Create
     * @param callback callback A listener for the `listening` event (ws).
     */
    open(callback) {
        const self = this;
        if (this.wss) {
            throw new Error("`ws` has already been created");
        }
        if (this.options.wsEngine) {
            this.wss = new this.options.wsEngine(this.options.wss, callback);
        }
        else {
            this.wss = new ws_1.Server(this.options.wss, callback);
        }
        this.wss.once("listening", function _onListeningWSS() {
            self.emit("listening");
        });
        this.wss.on("connection", function _onConnectionWSS(ws, req) {
            let socket = new Socket(ws);
            self.sockets.set(socket.id, socket);
            ws.once("close", function _onCloseWS() {
                self.sockets.delete(socket.id);
                socket.emit("close");
                socket.removeAllListeners();
                socket.ws = null;
                socket.rooms.clear();
                socket.data.clear();
                socket = null;
                ws.removeAllListeners();
                ws = null;
            });
            ws.on("message", function _onMessageWS(data) {
                self._messageHandler.handleMessage(socket, data)
                    .catch(function _onErrorHandleMessage(e) {
                    self.emit("error", e);
                });
            });
            ws.on("pong", function _onPongWS() {
                socket._pongAt = Date.now();
            });
            self.emit("connection", socket, req);
        });
        this.wss.on("error", function _onErrorWSS(e) {
            self.emit("error", e);
        });
        this._pingTimer = setInterval(this._ping.bind(this), this.options.pingInterval);
        return this;
    }
    /**
     * Closes the server and terminates all sockets.
     */
    async close() {
        clearInterval(this._pingTimer);
        for (const socket of this.sockets.values()) {
            socket.terminate();
        }
        await new Promise((resolve, reject) => {
            this.wss.close(err => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
        this.wss.removeAllListeners();
        delete this.wss;
        this.sockets.clear();
    }
    /**
     * Broadcasts a notification.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    broadcast(method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        const json = JSON.stringify(data);
        for (const socket of this.sockets.values()) {
            socket.send(json);
        }
    }
    /**
     * Broadcasts a notification to the room.
     * @param room The name of the room.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notifyTo(room, method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        const json = JSON.stringify(data);
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                socket.send(json);
            }
        }
    }
    /**
     * Broadcasts a (raw) message to the room.
     * @param room The name of the room.
     * @param data (raw) message.
     */
    sendTo(room, data) {
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                socket.send(data);
            }
        }
    }
    /**
     * Get all sockets in the room.
     * @param room The name of the room.
     */
    in(room) {
        const sockets = new Map();
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                sockets.set(socket.id, socket);
            }
        }
        return sockets;
    }
    /**
     * Server is open or not
     */
    isOpen() {
        return this.wss !== undefined;
    }
    /**
     * Ping to all sockets.
     */
    _ping() {
        const deadline = this._lastPingAt + this.options.pingTimeout;
        for (const socket of this.sockets.values()) {
            if (socket._pongAt === -1 || socket._pongAt > deadline) {
                socket.terminate();
                continue;
            }
            socket._pongAt = -1;
            if (socket.isOpen()) {
                socket.ws.ping();
            }
        }
        this._lastPingAt = Date.now();
    }
}
exports["default"] = Server;
class Socket extends EventEmitter {
    constructor(ws) {
        super();
        this.ws = ws;
        this.id = uuid_1.v4();
        this.rooms = new Set();
        /** custom data store */
        this.data = new MapLike_1.default();
        /** (internal using for heartbeat) */
        this._pongAt = 0;
    }
    /**
     * Sends a notification to the socket.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notify(method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        this.send(JSON.stringify(data));
    }
    /**
     * Sends a (raw) message to the socket.
     * @param data (raw) message.
     * @param binary binary flag.
     */
    send(data, binary = false) {
        if (this.isOpen()) {
            this.ws.send(data, { binary });
        }
    }
    /**
     * Joins a room. You can join multiple rooms.
     * @param room The name of the room that we want to join.
     */
    joinTo(room) {
        if (this.rooms.has(room) === false) {
            this.rooms.add(room);
            return true;
        }
        return false;
    }
    /**
     * Leaves a room.
     * @param room The name of the room to leave.
     */
    leaveFrom(room) {
        if (this.rooms.has(room) === true) {
            this.rooms.delete(room);
            return true;
        }
        return false;
    }
    /**
     * Leaves all the rooms that we've joined.
     */
    leaveFromAll() {
        this.rooms.clear();
    }
    /**
     * Initiate a closing handshake.
     * @param code A numeric value indicating the status code explaining why the connection is being closed.
     * @param reason A human-readable string explaining why the connection is closing.
     */
    close(code, reason) {
        this.ws.close(code, reason);
    }
    /**
     * Forcibly close the connection.
     */
    terminate() {
        this.ws.terminate();
    }
    /**
     * Get the connection is open or not
     */
    isOpen() {
        return this.ws !== undefined && this.ws.readyState === ws_1.OPEN;
    }
}
exports.Socket = Socket;
//# sourceMappingURL=server.js.map

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
if (global.fetch) {
	exports["default"] = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(/*! ./util.inspect */ "?2128");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== '__proto__') {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var split = String.prototype.split;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            if (generateArrayPrefix === 'comma' && encodeValuesOnly) {
                var valuesArray = split.call(String(obj), ',');
                var valuesJoined = '';
                for (var i = 0; i < valuesArray.length; ++i) {
                    valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults.encoder, charset, 'value', format));
                }
                return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? '[]' : '') + '=' + valuesJoined];
            }
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        /* eslint operator-linebreak: [2, "before"] */
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NIL": () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "parse": () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "stringify": () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "v1": () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "v3": () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "v4": () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "v5": () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "validate": () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "version": () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/esm-browser/v1.js");
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/esm-browser/v3.js");
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/esm-browser/nil.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/esm-browser/version.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");










/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/esm-browser/md5.js");


var v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ ((module) => {

"use strict";


module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ }),

/***/ "?2128":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DIRTY": () => (/* binding */ DIRTY),
/* harmony export */   "EMPTY_PATH": () => (/* binding */ EMPTY_PATH),
/* harmony export */   "INVALID": () => (/* binding */ INVALID),
/* harmony export */   "OK": () => (/* binding */ OK),
/* harmony export */   "ParseStatus": () => (/* binding */ ParseStatus),
/* harmony export */   "Schema": () => (/* binding */ ZodType),
/* harmony export */   "ZodAny": () => (/* binding */ ZodAny),
/* harmony export */   "ZodArray": () => (/* binding */ ZodArray),
/* harmony export */   "ZodBigInt": () => (/* binding */ ZodBigInt),
/* harmony export */   "ZodBoolean": () => (/* binding */ ZodBoolean),
/* harmony export */   "ZodDate": () => (/* binding */ ZodDate),
/* harmony export */   "ZodDefault": () => (/* binding */ ZodDefault),
/* harmony export */   "ZodDiscriminatedUnion": () => (/* binding */ ZodDiscriminatedUnion),
/* harmony export */   "ZodEffects": () => (/* binding */ ZodEffects),
/* harmony export */   "ZodEnum": () => (/* binding */ ZodEnum),
/* harmony export */   "ZodError": () => (/* binding */ ZodError),
/* harmony export */   "ZodFirstPartyTypeKind": () => (/* binding */ ZodFirstPartyTypeKind),
/* harmony export */   "ZodFunction": () => (/* binding */ ZodFunction),
/* harmony export */   "ZodIntersection": () => (/* binding */ ZodIntersection),
/* harmony export */   "ZodIssueCode": () => (/* binding */ ZodIssueCode),
/* harmony export */   "ZodLazy": () => (/* binding */ ZodLazy),
/* harmony export */   "ZodLiteral": () => (/* binding */ ZodLiteral),
/* harmony export */   "ZodMap": () => (/* binding */ ZodMap),
/* harmony export */   "ZodNaN": () => (/* binding */ ZodNaN),
/* harmony export */   "ZodNativeEnum": () => (/* binding */ ZodNativeEnum),
/* harmony export */   "ZodNever": () => (/* binding */ ZodNever),
/* harmony export */   "ZodNull": () => (/* binding */ ZodNull),
/* harmony export */   "ZodNullable": () => (/* binding */ ZodNullable),
/* harmony export */   "ZodNumber": () => (/* binding */ ZodNumber),
/* harmony export */   "ZodObject": () => (/* binding */ ZodObject),
/* harmony export */   "ZodOptional": () => (/* binding */ ZodOptional),
/* harmony export */   "ZodParsedType": () => (/* binding */ ZodParsedType),
/* harmony export */   "ZodPromise": () => (/* binding */ ZodPromise),
/* harmony export */   "ZodRecord": () => (/* binding */ ZodRecord),
/* harmony export */   "ZodSchema": () => (/* binding */ ZodType),
/* harmony export */   "ZodSet": () => (/* binding */ ZodSet),
/* harmony export */   "ZodString": () => (/* binding */ ZodString),
/* harmony export */   "ZodTransformer": () => (/* binding */ ZodEffects),
/* harmony export */   "ZodTuple": () => (/* binding */ ZodTuple),
/* harmony export */   "ZodType": () => (/* binding */ ZodType),
/* harmony export */   "ZodUndefined": () => (/* binding */ ZodUndefined),
/* harmony export */   "ZodUnion": () => (/* binding */ ZodUnion),
/* harmony export */   "ZodUnknown": () => (/* binding */ ZodUnknown),
/* harmony export */   "ZodVoid": () => (/* binding */ ZodVoid),
/* harmony export */   "addIssueToContext": () => (/* binding */ addIssueToContext),
/* harmony export */   "any": () => (/* binding */ anyType),
/* harmony export */   "array": () => (/* binding */ arrayType),
/* harmony export */   "bigint": () => (/* binding */ bigIntType),
/* harmony export */   "boolean": () => (/* binding */ booleanType),
/* harmony export */   "custom": () => (/* binding */ custom),
/* harmony export */   "date": () => (/* binding */ dateType),
/* harmony export */   "default": () => (/* binding */ mod),
/* harmony export */   "defaultErrorMap": () => (/* binding */ defaultErrorMap),
/* harmony export */   "discriminatedUnion": () => (/* binding */ discriminatedUnionType),
/* harmony export */   "effect": () => (/* binding */ effectsType),
/* harmony export */   "enum": () => (/* binding */ enumType),
/* harmony export */   "function": () => (/* binding */ functionType),
/* harmony export */   "getParsedType": () => (/* binding */ getParsedType),
/* harmony export */   "instanceof": () => (/* binding */ instanceOfType),
/* harmony export */   "intersection": () => (/* binding */ intersectionType),
/* harmony export */   "isAborted": () => (/* binding */ isAborted),
/* harmony export */   "isAsync": () => (/* binding */ isAsync),
/* harmony export */   "isDirty": () => (/* binding */ isDirty),
/* harmony export */   "isValid": () => (/* binding */ isValid),
/* harmony export */   "late": () => (/* binding */ late),
/* harmony export */   "lazy": () => (/* binding */ lazyType),
/* harmony export */   "literal": () => (/* binding */ literalType),
/* harmony export */   "makeIssue": () => (/* binding */ makeIssue),
/* harmony export */   "map": () => (/* binding */ mapType),
/* harmony export */   "nan": () => (/* binding */ nanType),
/* harmony export */   "nativeEnum": () => (/* binding */ nativeEnumType),
/* harmony export */   "never": () => (/* binding */ neverType),
/* harmony export */   "null": () => (/* binding */ nullType),
/* harmony export */   "nullable": () => (/* binding */ nullableType),
/* harmony export */   "number": () => (/* binding */ numberType),
/* harmony export */   "object": () => (/* binding */ objectType),
/* harmony export */   "objectUtil": () => (/* binding */ objectUtil),
/* harmony export */   "oboolean": () => (/* binding */ oboolean),
/* harmony export */   "onumber": () => (/* binding */ onumber),
/* harmony export */   "optional": () => (/* binding */ optionalType),
/* harmony export */   "ostring": () => (/* binding */ ostring),
/* harmony export */   "overrideErrorMap": () => (/* binding */ overrideErrorMap),
/* harmony export */   "preprocess": () => (/* binding */ preprocessType),
/* harmony export */   "promise": () => (/* binding */ promiseType),
/* harmony export */   "quotelessJson": () => (/* binding */ quotelessJson),
/* harmony export */   "record": () => (/* binding */ recordType),
/* harmony export */   "set": () => (/* binding */ setType),
/* harmony export */   "setErrorMap": () => (/* binding */ setErrorMap),
/* harmony export */   "strictObject": () => (/* binding */ strictObjectType),
/* harmony export */   "string": () => (/* binding */ stringType),
/* harmony export */   "transformer": () => (/* binding */ effectsType),
/* harmony export */   "tuple": () => (/* binding */ tupleType),
/* harmony export */   "undefined": () => (/* binding */ undefinedType),
/* harmony export */   "union": () => (/* binding */ unionType),
/* harmony export */   "unknown": () => (/* binding */ unknownType),
/* harmony export */   "void": () => (/* binding */ voidType),
/* harmony export */   "z": () => (/* binding */ mod)
/* harmony export */ });
var util;
(function (util) {
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
})(util || (util = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, null, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};
const defaultErrorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (issue.validation !== "regex")
                message = `Invalid ${issue.validation}`;
            else
                message = "Invalid";
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return { message };
};
let overrideErrorMap = defaultErrorMap;
const setErrorMap = (map) => {
    overrideErrorMap = map;
};

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideErrorMap,
            defaultErrorMap,
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== undefined && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        return this._path.concat(this._key);
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        const error = new ZodError(ctx.common.issues);
        return { success: false, error };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined" && required_error)
            return { message: required_error };
        if (params.invalid_type_error)
            return { message: params.invalid_type_error };
        return { message: ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this.superRefine = this._refinement;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.default = this.default.bind(this);
        this.describe = this.describe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    optional() {
        return ZodOptional.create(this);
    }
    nullable() {
        return ZodNullable.create(this);
    }
    nullish() {
        return this.optional().nullable();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this);
    }
    or(option) {
        return ZodUnion.create([this, option]);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming);
    }
    transform(transform) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
// eslint-disable-next-line
const emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class ZodString extends ZodType {
    constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this.min(len, message).max(len, message);
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get minLength() {
        let min = -Infinity;
        this._def.checks.map((ch) => {
            if (ch.kind === "min") {
                if (min === null || ch.value > min) {
                    min = ch.value;
                }
            }
        });
        return min;
    }
    get maxLength() {
        let max = null;
        this._def.checks.map((ch) => {
            if (ch.kind === "max") {
                if (max === null || ch.value < max) {
                    max = ch.value;
                }
            }
        });
        return max;
    }
}
ZodString.create = (params) => {
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int");
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBigInt.create = (params) => {
    return new ZodBigInt({
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        return {
            status: "valid",
            value: new Date(input.data.getTime()),
        };
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all(ctx.data.map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = ctx.data.map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return this.min(len, message).max(len, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodObject      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second,
        };
    };
})(objectUtil || (objectUtil = {}));
const AugmentFactory = (def) => (augmentation) => {
    return new ZodObject({
        ...def,
        shape: () => ({
            ...def.shape(),
            ...augmentation,
        }),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return ZodArray.create(deepPartialify(schema.element));
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        this.augment = AugmentFactory(this._def);
        this.extend = AugmentFactory(this._def);
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        // const mergedShape = objectUtil.mergeShapes(
        //   this._def.shape(),
        //   merging._def.shape()
        // );
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).map((key) => {
            // only add to shape if key corresponds to an element of the current shape
            if (this.shape[key])
                shape[key] = this.shape[key];
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).map((key) => {
            if (util.objectKeys(mask).indexOf(key) === -1) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        if (mask) {
            util.objectKeys(this.shape).map((key) => {
                if (util.objectKeys(mask).indexOf(key) === -1) {
                    newShape[key] = this.shape[key];
                }
                else {
                    newShape[key] = this.shape[key].optional();
                }
            });
            return new ZodObject({
                ...this._def,
                shape: () => newShape,
            });
        }
        else {
            for (const key in this.shape) {
                const fieldSchema = this.shape[key];
                newShape[key] = fieldSchema.optional();
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required() {
        const newShape = {};
        for (const key in this.shape) {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
            }
            newShape[key] = newField;
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.options.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: this.validDiscriminatorValues,
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get validDiscriminatorValues() {
        return Array.from(this.options.keys());
    }
    get options() {
        return this._def.options;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, types, params) {
        // Get all the valid discriminator values
        const options = new Map();
        try {
            types.forEach((type) => {
                const discriminatorValue = type.shape[discriminator].value;
                options.set(discriminatorValue, type);
            });
        }
        catch (e) {
            throw new Error("The discriminator value could not be extracted from all the provided schemas");
        }
        // Assert that all the discriminator values are unique
        if (options.size !== types.length) {
            throw new Error("Some of the discriminator values are not unique");
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                type: "array",
            });
            status.dirty();
        }
        const items = ctx.data
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    overrideErrorMap,
                    defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    overrideErrorMap,
                    defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            return OK(async (...args) => {
                const error = new ZodError([]);
                const parsedArgs = await this._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await fn(...parsedArgs);
                const parsedReturns = await this._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            return OK((...args) => {
                const parsedArgs = this._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = fn(...parsedArgs.data);
                const parsedReturns = this._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
}
ZodFunction.create = (args, returns, params) => {
    return new ZodFunction({
        args: (args
            ? args.rest(ZodUnknown.create())
            : ZodTuple.create([]).rest(ZodUnknown.create())),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params),
    });
};
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                // if (base.status === "aborted") return INVALID;
                // if (base.status === "dirty") {
                //   return { status: "dirty", value: base.value };
                // }
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    // if (base.status === "aborted") return INVALID;
                    // if (base.status === "dirty") {
                    //   return { status: "dirty", value: base.value };
                    // }
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const custom = (check, params = {}, fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            if (!check(data)) {
                const p = typeof params === "function" ? params(data) : params;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal });
            }
        });
    return ZodAny.create();
};
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params, true);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();

var mod = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getParsedType: getParsedType,
    ZodParsedType: ZodParsedType,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    ZodType: ZodType,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    get objectUtil () { return objectUtil; },
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodNaN: ZodNaN,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError,
    defaultErrorMap: defaultErrorMap,
    get overrideErrorMap () { return overrideErrorMap; },
    setErrorMap: setErrorMap
});




/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvcmVzb3VyY2VzX2pzX3BhZ2VzX1B1cmNoYXNlSXRlbV9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsTUFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsNkJBQTZCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFNGI7QUFDNWI7Ozs7Ozs7Ozs7Ozs7QUMvcUNZOztBQUVaLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx5SUFBd0Q7QUFDMUQ7Ozs7Ozs7Ozs7OztBQ1BhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsZ0NBQWdDOztBQUVoQyxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBYztBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyxzRUFBZTtBQUNwRCw0QkFBNEIsbUJBQU8sQ0FBQyxnREFBTztBQUMzQyx5Q0FBeUMsbUJBQU8sQ0FBQyw4RUFBMkI7QUFDNUUsZ0NBQWdDLG1CQUFPLENBQUMsNERBQWtCO0FBQzFELHFDQUFxQyxtQkFBTyxDQUFDLHNFQUF1QjtBQUNwRSwyQ0FBMkMsbUJBQU8sQ0FBQyxrRkFBNkI7O0FBRWhGO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5REFBeUQ7QUFDNUQsQ0FBQyxvQkFBb0IsYUFBYSxLQUFLOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RCxXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEUsNEJBQTRCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdK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REFBZTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCOztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1REFBdUQsd0RBQVU7QUFDakU7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSwrR0FBK0c7O0FBRS9HO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsK0dBQStHOztBQUUvRztBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdEQUFROztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQywyQkFBMkIsd0RBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9FQUFzQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9FQUFzQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckMsMkJBQTJCLHdEQUFVO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxlQUFlO0FBQ2YsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1EQUFTLENBQUMsd0RBQVU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix3REFBVTtBQUN0QztBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQztBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQztBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsbURBQVMsQ0FBQyx3REFBVTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSx3REFBVTtBQUMvRSxxRUFBcUUsd0RBQVU7QUFDL0U7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckMsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVEsQ0FBQyxzREFBTTtBQUMxQyx5QkFBeUIsc0RBQU07QUFDL0IsOEJBQThCLHNEQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQyxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckM7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckMsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQyxtQ0FBbUMsU0FBUztBQUMvRztBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBEQUFVLENBQUMsdURBQU87QUFDN0MsNkJBQTZCLDBEQUFVLENBQUMsdURBQU8sQ0FBQyx5REFBUyxDQUFDLG9EQUFJO0FBQzlEO0FBQ0E7QUFDQSw2QkFBNkIsMENBQTBDLDBHQUEwRyxHQUFHLDRFQUE0RSxTQUFTO0FBQ3pRO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQywrQ0FBTztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkMseUVBQTJCOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsaUZBQW1DOztBQUVqRjtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsd0RBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsMEVBQTRCOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixtRUFBMkI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHlCQUF5QiwrQ0FBTztBQUNoQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLDJEQUFhLDRCQUE0QixpRUFBeUI7O0FBRTNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIsZ0VBQXdCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGlDQUFpQywyQ0FBTSxxQkFBcUIsS0FBSztBQUNqRSx1Q0FBdUMsMkNBQU07QUFDN0M7QUFDQSwyQkFBMkIsMkNBQU07QUFDakMsQ0FBQztBQUNELHdDQUF3QywwQ0FBSztBQUM3Qyx1Q0FBdUMsMkNBQU07QUFDN0MseUJBQXlCLDJDQUFNO0FBQy9CO0FBQ0EsQ0FBQzs7QUFFRCx3Q0FBd0MsMkNBQU07QUFDOUMsMkJBQTJCLDJDQUFNO0FBQ2pDLDhCQUE4QiwyQ0FBTTtBQUNwQyxpQ0FBaUMsMkNBQU07QUFDdkMsb0NBQW9DLDJDQUFNO0FBQzFDLGlDQUFpQywyQ0FBTTtBQUN2QywwQkFBMEIsMkNBQU07QUFDaEMscUNBQXFDLDBDQUFLLGVBQWUsd0NBQUc7QUFDNUQsdUNBQXVDLDBDQUFLLGVBQWUsd0NBQUc7QUFDOUQsQ0FBQztBQUNEO0FBQ0EsU0FBUywyQ0FBTTtBQUNmLGdEQUFnRCw0Q0FBTztBQUN2RCxVQUFVLDRDQUFPO0FBQ2pCLFVBQVUsMkNBQU07QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFNBQVMsMkNBQU07QUFDZixnREFBZ0QsNENBQU87QUFDdkQsVUFBVSw0Q0FBTztBQUNqQixVQUFVLDJDQUFNLE1BQU0sMkNBQU07QUFDNUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFNBQVMsMkNBQU07QUFDZixhQUFhLDRDQUFPO0FBQ3BCLFVBQVUsNENBQU87QUFDakIsVUFBVSwyQ0FBTTtBQUNoQjtBQUNBLFdBQVcsMkNBQU07QUFDakIsYUFBYSwwQ0FBSyxDQUFDLDJDQUFNLE1BQU0sMkNBQU07QUFDckMsbUJBQW1CLDJDQUFNO0FBQ3pCLG9CQUFvQiwyQ0FBTTtBQUMxQixTQUFTO0FBQ1QsdUJBQXVCLDJDQUFNO0FBQzdCLGNBQWMsMkNBQU07QUFDcEIsT0FBTztBQUNQLGFBQWEsMkNBQU07QUFDbkI7QUFDQSxpQkFBaUIsMkNBQU07QUFDdkIsbUJBQW1CLDJDQUFNO0FBQ3pCLHFCQUFxQiwyQ0FBTTtBQUMzQixtQkFBbUIsMkNBQU07QUFDekIsT0FBTztBQUNQLHNDQUFzQywyQ0FBTTtBQUM1QyxpQkFBaUIsMENBQUs7QUFDdEIsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQ0FBTTtBQUMxQyxhQUFhLDBDQUFLO0FBQ2xCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3QkFBd0I7QUFDeEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3QkFBd0I7QUFDeEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDJDQUFNO0FBQ2Y7QUFDQSxnQkFBZ0IsMENBQUssQ0FBQywyQ0FBTTtBQUM1QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLDJDQUFNO0FBQzNCLDhCQUE4QiwyQ0FBTTtBQUNwQztBQUNBOztBQUVBLGlDQUFpQywyQ0FBTTtBQUN2QyxzQkFBc0IsMkNBQU07QUFDNUI7QUFDQSxzQkFBc0IsMkNBQU07QUFDNUIsd0JBQXdCLDJDQUFNO0FBQzlCLDZCQUE2QiwyQ0FBTTtBQUNuQyxDQUFDO0FBQ0QsNkNBQTZDLDJDQUFNO0FBQ25ELFFBQVEsMkNBQU07QUFDZCxVQUFVLDJDQUFNO0FBQ2hCLENBQUM7QUFDRCwyQ0FBMkMsMkNBQU07QUFDakQsbUJBQW1CLDJDQUFNO0FBQ3pCLHdCQUF3QiwyQ0FBTTtBQUM5QixxQkFBcUIsMkNBQU07QUFDM0IsdUJBQXVCLDJDQUFNO0FBQzdCLHFCQUFxQiwyQ0FBTTtBQUMzQixDQUFDOztBQUVELDhCQUE4QiwyQ0FBTTtBQUNwQyxnQ0FBZ0MsMkNBQU07QUFDdEMsc0JBQXNCLDJDQUFNO0FBQzVCLG1DQUFtQywyQ0FBTTtBQUN6QywwQkFBMEIsMkNBQU07QUFDaEMsdUJBQXVCLDJDQUFNO0FBQzdCLDBCQUEwQiwyQ0FBTTtBQUNoQyxDQUFDO0FBQ0Qsc0NBQXNDLDJDQUFNO0FBQzVDLHlCQUF5QiwyQ0FBTTtBQUMvQix1QkFBdUIsMkNBQU07QUFDN0IscUJBQXFCLDJDQUFNO0FBQzNCLHNCQUFzQiwwQ0FBSztBQUMzQixDQUFDO0FBQ0QsdUNBQXVDLDBDQUFLOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFckIscUNBQXFDLDJDQUFNO0FBQzNDLG1CQUFtQiwyQ0FBTTtBQUN6QixxQkFBcUIsK0NBQVU7QUFDL0IscUJBQXFCLDJDQUFNO0FBQzNCLHFCQUFxQiwyQ0FBTTtBQUMzQix1QkFBdUIsMkNBQU07QUFDN0IsQ0FBQztBQUNELHFDQUFxQywyQ0FBTTtBQUMzQyxtQkFBbUIsMkNBQU07QUFDekIsdUJBQXVCLDJDQUFNO0FBQzdCLHNCQUFzQiwyQ0FBTTtBQUM1Qiw0QkFBNEIsMkNBQU07QUFDbEMsd0JBQXdCLDJDQUFNO0FBQzlCLHFCQUFxQiwrQ0FBVTtBQUMvQixzQkFBc0IsMkNBQU07QUFDNUIsOEJBQThCLDJDQUFNO0FBQ3BDLHFCQUFxQiwyQ0FBTTtBQUMzQiwwQkFBMEIsMkNBQU07QUFDaEMsNEJBQTRCLDJDQUFNO0FBQ2xDLENBQUM7O0FBRUQsMENBQTBDLDJDQUFNO0FBQ2hELHdCQUF3Qiw0Q0FBTztBQUMvQiwrQkFBK0IsMkNBQU07QUFDckMseUJBQXlCLDJDQUFNO0FBQy9CLENBQUM7QUFDRCxzQ0FBc0MsMkNBQU07QUFDNUMsMkJBQTJCLDJDQUFNO0FBQ2pDLDJCQUEyQiwyQ0FBTTtBQUNqQyw0QkFBNEIsMkNBQU07QUFDbEMsQ0FBQztBQUNELDBDQUEwQywyQ0FBTTtBQUNoRCx3QkFBd0IsNENBQU87QUFDL0Isc0JBQXNCLDJDQUFNO0FBQzVCLG9CQUFvQiwyQ0FBTTtBQUMxQix5QkFBeUIsMkNBQU07QUFDL0IsQ0FBQzs7QUFFRDtBQUNBLHFCQUFxQiwyQ0FBTTtBQUMzQjtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxtQkFBbUIsNENBQU87QUFDMUIseUJBQXlCLDJDQUFNO0FBQy9CLHFCQUFxQiwyQ0FBTTtBQUMzQjtBQUNBLHNDQUFzQywyQ0FBTTtBQUM1QztBQUNBLDJCQUEyQiwwQ0FBSyxDQUFDLDJDQUFNO0FBQ3ZDO0FBQ0Esd0JBQXdCLDJDQUFNO0FBQzlCLHlCQUF5QiwyQ0FBTTtBQUMvQixDQUFDO0FBQ0QsK0NBQStDLDJDQUFNO0FBQ3JELHdCQUF3Qiw0Q0FBTztBQUMvQixtQkFBbUIsMkNBQU07QUFDekIsQ0FBQztBQUNELDRDQUE0QywyQ0FBTTtBQUNsRCx3QkFBd0IsMkNBQU07QUFDOUIsNkJBQTZCLDJDQUFNO0FBQ25DLHlCQUF5QiwyQ0FBTTtBQUMvQix3QkFBd0IsMkNBQU07QUFDOUIsQ0FBQzs7QUFFRCxrREFBa0QsMkNBQU07QUFDeEQsbUJBQW1CLDJDQUFNO0FBQ3pCLHVCQUF1QiwyQ0FBTTtBQUM3Qix1QkFBdUIsMkNBQU07QUFDN0IseUJBQXlCLDJDQUFNO0FBQy9CLHdCQUF3QiwyQ0FBTTtBQUM5Qix3QkFBd0IsMkNBQU07QUFDOUIsa0NBQWtDLDJDQUFNO0FBQ3hDLCtCQUErQiwyQ0FBTTtBQUNyQyxDQUFDO0FBQ0Qsc0RBQXNELDJDQUFNO0FBQzVELHNCQUFzQiwwQ0FBSztBQUMzQixxQkFBcUIsMkNBQU07QUFDM0IseUJBQXlCLDJDQUFNO0FBQy9CLGlDQUFpQywyQ0FBTTtBQUN2QywyQkFBMkIsMkNBQU07QUFDakMsOEJBQThCLDJDQUFNO0FBQ3BDLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCOztBQUV6QixtQ0FBbUMsMkNBQU07QUFDekM7QUFDQSxtQkFBbUIsMkNBQU07QUFDekIscUJBQXFCLDJDQUFNO0FBQzNCLHNCQUFzQiwyQ0FBTTtBQUM1QixnQ0FBZ0MsMkNBQU07QUFDdEMsOEJBQThCLDJDQUFNO0FBQ3BDLENBQUM7QUFDRCxxQ0FBcUMsMkNBQU07QUFDM0MsMEJBQTBCLDJDQUFNO0FBQ2hDLDhCQUE4QiwyQ0FBTTtBQUNwQyxDQUFDO0FBQ0QsOEJBQThCLDJDQUFNO0FBQ3BDLHNCQUFzQiwyQ0FBTTtBQUM1QiwrQkFBK0IsMkNBQU07QUFDckM7QUFDQSxtQkFBbUIsMkNBQU07QUFDekIscUJBQXFCLDJDQUFNO0FBQzNCLHNCQUFzQiwyQ0FBTTtBQUM1QixnQ0FBZ0MsMkNBQU07QUFDdEMsdUJBQXVCLCtDQUFVO0FBQ2pDLDRCQUE0QiwyQ0FBTTtBQUNsQywwQkFBMEIsMkNBQU07QUFDaEMsOEJBQThCLDJDQUFNO0FBQ3BDLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVreUI7QUFDbHlCOzs7Ozs7Ozs7Ozs7QUM3b0NhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHNHQUFnQjtBQUNyQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMseUNBQXlDLHFCQUFxQixJQUFJLFFBQVEsT0FBTyxRQUFRO0FBQ3pGLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCOzs7Ozs7Ozs7OztBQ3ZIYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLHdGQUFTO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxzR0FBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRTtBQUNBO0FBQ0EsdURBQXVELHFCQUFxQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHVDQUF1QywyREFBMkQsSUFBSTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUseUJBQXlCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QywrQ0FBK0MsdUJBQXVCLElBQUk7QUFDMUUsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxREFBcUQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDZEQUE2RDtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLENBQUM7QUFDRCx3QkFBd0I7QUFDeEI7Ozs7Ozs7Ozs7O0FDNUphO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLDhGQUFZO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxzR0FBZ0I7QUFDckMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsdUJBQXVCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixnQkFBZ0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGVBQWUsRUFBRSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxlQUFlLEVBQUUsWUFBWTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUZhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDLG1CQUFtQixlQUFlO0FBQ3hILENBQUMsb0NBQW9DLGlCQUFpQixLQUFLO0FBQzNEOzs7Ozs7Ozs7OztBQ05hO0FBQ2I7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG1HQUFlO0FBQ3BDLHFCQUFxQixtQkFBTyxDQUFDLG1IQUF1QjtBQUNwRCxlQUFlLG1CQUFPLENBQUMsdUdBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0NBQXNDO0FBQy9GO0FBQ0Esb0RBQW9ELDBCQUEwQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlDQUFpQyxxQkFBcUI7QUFDdEQsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDs7Ozs7Ozs7Ozs7QUMxQ2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHlDQUF5QztBQUN4RztBQUNBLGtEQUFrRCx5QkFBeUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUMsMEJBQTBCLFlBQVksS0FBSztBQUM1Qzs7Ozs7Ozs7Ozs7QUNwQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsc0dBQWdCO0FBQ3ZDLGlCQUFpQjtBQUNqQixlQUFlLG1CQUFPLENBQUMsc0dBQWdCO0FBQ3ZDLGlCQUFpQjtBQUNqQixlQUFlLG1CQUFPLENBQUMsc0dBQWdCO0FBQ3ZDLGlCQUFpQjtBQUNqQixnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBaUI7QUFDekMsa0JBQWtCO0FBQ2xCLGFBQWEsbUJBQU8sQ0FBQyxrR0FBYztBQUNuQyxlQUFlO0FBQ2Ysa0JBQWtCLG1CQUFPLENBQUMsNEdBQW1CO0FBQzdDLG9CQUFvQjtBQUNwQixhQUFhLG1CQUFPLENBQUMsa0dBQWM7QUFDbkMsZUFBZTtBQUNmLFlBQVksbUJBQU8sQ0FBQyxnR0FBYTtBQUNqQyxjQUFjO0FBQ2QsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQWlCO0FBQ3pDLGtCQUFrQjtBQUNsQixhQUFhLG1CQUFPLENBQUMsa0dBQWM7QUFDbkMsZUFBZTtBQUNmLGNBQWMsbUJBQU8sQ0FBQyxvR0FBZTtBQUNyQyxnQkFBZ0I7QUFDaEIsZUFBZSxtQkFBTyxDQUFDLHNHQUFnQjtBQUN2QyxpQkFBaUI7QUFDakIsY0FBYyxtQkFBTyxDQUFDLG9HQUFlO0FBQ3JDLGdCQUFnQjtBQUNoQixxQkFBcUIsbUJBQU8sQ0FBQyxrSEFBc0I7QUFDbkQsdUJBQXVCO0FBQ3ZCLGNBQWMsbUJBQU8sQ0FBQyxvR0FBZTtBQUNyQyxnQkFBZ0I7QUFDaEIsZUFBZSxtQkFBTyxDQUFDLHNHQUFnQjtBQUN2QyxpQkFBaUI7QUFDakIsaUJBQWlCLG1CQUFPLENBQUMsMEdBQWtCO0FBQzNDLG1CQUFtQjtBQUNuQixhQUFhLG1CQUFPLENBQUMsa0dBQWM7QUFDbkMsZUFBZTtBQUNmLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFpQjtBQUN6QyxrQkFBa0I7QUFDbEIsYUFBYSxtQkFBTyxDQUFDLGtHQUFjO0FBQ25DLGVBQWU7QUFDZixtQkFBbUIsbUJBQU8sQ0FBQyw4R0FBb0I7QUFDL0MscUJBQXFCO0FBQ3JCLGNBQWMsbUJBQU8sQ0FBQyxvR0FBZTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBaUI7QUFDekMsa0JBQWtCO0FBQ2xCLGFBQWEsbUJBQU8sQ0FBQyxrR0FBYztBQUNuQyxlQUFlO0FBQ2YsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsZUFBZSxtQkFBTyxDQUFDLDBGQUFVO0FBQ2pDLHFCQUFxQjtBQUNyQixnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBVztBQUNuQyx3QkFBd0I7QUFDeEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxZQUFZO0FBQ1o7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFZO0FBQ1o7QUFDQSxXQUFXO0FBQ1g7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFZO0FBQ1o7QUFDQSxhQUFhO0FBQ2I7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxtQkFBZ0I7QUFDaEI7QUFDQSxZQUFZO0FBQ1o7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFZO0FBQ1o7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLGVBQWU7QUFDZiw0QkFBNEI7QUFDNUIsZUFBZTtBQUNmLDZCQUE2QjtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQSxlQUFlO0FBQ2YsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDRDQUE0Qyw2QkFBNkI7QUFDekU7QUFDQSxxQkFBa0I7QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsOEZBQVk7QUFDN0I7Ozs7Ozs7Ozs7O0FDM0lhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsd0ZBQVM7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLHNHQUFnQjtBQUNyQyxnQkFBZ0I7QUFDaEIsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw2QkFBNkI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdGYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLGtHQUFjO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLDhGQUFZO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxzR0FBZ0I7QUFDckMsd0JBQXdCLG1CQUFPLENBQUMsNEdBQW1CO0FBQ25ELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWUsa0RBQWtEO0FBQy9GLG1CQUFtQjtBQUNuQjtBQUNBLFlBQVk7QUFDWixpRUFBaUUsWUFBWSxnQ0FBZ0M7QUFDN0csc0JBQXNCLGVBQWU7QUFDckMsaURBQWlELFlBQVksb0NBQW9DLFlBQVk7QUFDN0c7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdDQUFnQztBQUM5RjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usd0JBQXdCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVDQUF1QztBQUNuRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFlBQVksK0JBQStCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHVDQUF1QztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFlBQVksaUNBQWlDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsWUFBWSxtQ0FBbUM7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFlBQVksaUNBQWlDO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNEJBQTRCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xsQmE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLDRGQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYztBQUNkOzs7Ozs7Ozs7OztBQ3hDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQyxZQUFZLGVBQWU7QUFDM0IsWUFBWSxVQUFVO0FBQ3RCLFlBQVksV0FBVztBQUN2QixpQkFBaUIsbUJBQU8sQ0FBQywrRkFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QixrQ0FBa0MsK0ZBQStGLG1DQUFtQyxtQkFBbUI7QUFDaFE7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUIsa0NBQWtDLDZGQUE2RixtQ0FBbUMsbUJBQW1CO0FBQzlQO0FBQ0EsaURBQWlELHdCQUF3QixrQkFBa0IsYUFBYSxrQkFBa0I7QUFDMUg7QUFDQSxtREFBbUQsZ0JBQWdCLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QixrQ0FBa0MsK0ZBQStGLG1DQUFtQyxtQkFBbUI7QUFDaFE7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUIsa0NBQWtDLDZGQUE2RixtQ0FBbUMsbUJBQW1CO0FBQzlQO0FBQ0EsaURBQWlELHdCQUF3QixrQkFBa0IsYUFBYSxrQkFBa0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QjtBQUN4Qjs7Ozs7Ozs7Ozs7QUN4R2E7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsMkZBQVc7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLHlGQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0MsZ0JBQWdCLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSwwQ0FBMEMsZ0NBQWdDO0FBQzFFO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBLGdEQUFnRCx5Q0FBeUM7QUFDekY7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0Isd0RBQXdEO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmOzs7Ozs7Ozs7OztBQ3pIYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsNEZBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakI7Ozs7Ozs7Ozs7O0FDeENhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjs7Ozs7Ozs7Ozs7QUN4Q2E7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLDRGQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmOzs7Ozs7Ozs7OztBQ3hDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsNEZBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWU7QUFDZjs7Ozs7Ozs7Ozs7QUNwRmE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsNEZBQVE7QUFDckMsY0FBYyxtQkFBTyxDQUFDLDhGQUFTO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLGtHQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0Isc0NBQXNDO0FBQ3BHO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLHFCQUFxQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQjtBQUNuQjs7Ozs7Ozs7Ozs7QUM1RWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLDRGQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7Ozs7Ozs7Ozs7O0FDOUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxnQkFBZ0I7QUFDaEI7Ozs7Ozs7Ozs7O0FDNUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxlQUFlO0FBQ2Y7Ozs7Ozs7Ozs7O0FDbERhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCOzs7Ozs7Ozs7OztBQ3pDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsNEZBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCOzs7Ozs7Ozs7OztBQ3ZDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsNEZBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxlQUFlO0FBQ2Y7Ozs7Ozs7Ozs7O0FDeENhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLDRGQUFRO0FBQ3JDLFlBQVksZUFBZTtBQUMzQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxXQUFXO0FBQ3ZCLGlCQUFpQixtQkFBTyxDQUFDLCtGQUFhO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLGlIQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxnREFBZ0QseUJBQXlCLHlCQUF5Qiw4RkFBOEY7QUFDaE07QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUIseUJBQXlCLDRGQUE0RjtBQUM5TDtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QixnQ0FBZ0MsdUZBQXVGO0FBQ2hNO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLGtCQUFrQix5RkFBeUY7QUFDcEw7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUIsa0JBQWtCLHVGQUF1RjtBQUNsTDtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QixtQkFBbUIsc0ZBQXNGO0FBQ2xMO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLG1CQUFtQix3RkFBd0Y7QUFDcEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCOzs7Ozs7Ozs7OztBQzdFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyxtSEFBdUI7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQWE7QUFDdEMsc0NBQXNDO0FBQ3RDLG9DQUFvQyxTQUFTLHFCQUFxQixtQkFBbUIsa0NBQWtDO0FBQ3ZIO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQixlQUFlO0FBQ3JFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNENBQTRDLGdCQUFnQixxQkFBcUIsaUJBQWlCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDRDQUE0QyxnQkFBZ0IscUJBQXFCLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCLHFCQUFxQixvQkFBb0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0IscUJBQXFCLG9CQUFvQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQixxQkFBcUIsb0JBQW9CO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0IscUJBQXFCLG9CQUFvQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakI7Ozs7Ozs7Ozs7O0FDakthO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0I7QUFDbEI7Ozs7Ozs7Ozs7O0FDOUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakI7Ozs7Ozs7Ozs7O0FDNUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLDRGQUFRO0FBQ3JDLFlBQVksZUFBZTtBQUMzQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxXQUFXO0FBQ3ZCLGlCQUFpQixtQkFBTyxDQUFDLCtGQUFhO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLGlIQUFzQjtBQUNoRCx1REFBdUQsR0FBRyxtRkFBbUYsR0FBRztBQUNoSiwyQkFBMkIsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLGtCQUFrQixFQUFFLFVBQVUsR0FBRztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxnREFBZ0QseUJBQXlCLGtDQUFrQyxnR0FBZ0c7QUFDM007QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUIsa0NBQWtDLDhGQUE4RjtBQUN6TTtBQUNBO0FBQ0EsZ0RBQWdELCtGQUErRiw0QkFBNEI7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFBbUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCOzs7Ozs7Ozs7OztBQy9GYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsNEZBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSwwREFBMEQsdUJBQXVCO0FBQ2pGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCOzs7Ozs7Ozs7OztBQzVDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsNEZBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7Ozs7Ozs7Ozs7O0FDeENhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSwyREFBMkQsb0JBQW9CO0FBQy9FLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUZBQW1GLCtCQUErQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxnQkFBZ0I7QUFDaEI7Ozs7Ozs7Ozs7O0FDL0NhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjs7Ozs7Ozs7Ozs7QUN4Q2E7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLDRGQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmOzs7Ozs7Ozs7O0FDeENBLDRGQUF1Qzs7Ozs7Ozs7Ozs7QUNBMUI7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxpRUFBa0I7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHlFQUFzQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsMkVBQXVCO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLDZFQUF1QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDdEQsc0JBQXNCLG1CQUFPLENBQUMseUZBQThCO0FBQzVELGtCQUFrQixtQkFBTyxDQUFDLHlFQUFxQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7O0FDNUxhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3QixXQUFXLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyw0REFBYztBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLHdEQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrRUFBaUI7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0VBQWtCOztBQUV6QztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGdGQUF3Qjs7QUFFckQ7O0FBRUE7QUFDQSx5QkFBc0I7Ozs7Ozs7Ozs7OztBQ3ZEVDs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2xCYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsMkRBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDeERhOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyx5RUFBcUI7QUFDNUMseUJBQXlCLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDJFQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBc0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7OztBQ25KYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7Ozs7Ozs7Ozs7QUNyRGE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsbUZBQTBCO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLCtFQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuQmE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMscUVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqQmE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZO0FBQ2hDLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFpQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsdUVBQW9CO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyx5REFBYTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7O0FDakZhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxtREFBVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQkFBMkI7QUFDM0IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDdEZhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeEJhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTtBQUNoQyxlQUFlLG1CQUFPLENBQUMsMkRBQWU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEIsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsa0RBQVM7QUFDN0IsMEJBQTBCLG1CQUFPLENBQUMsOEZBQStCO0FBQ2pFLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFxQjs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ3RDLElBQUksZ0JBQWdCLE9BQU8sbURBQW1ELE9BQU87QUFDckY7QUFDQSxjQUFjLG1CQUFPLENBQUMsaUVBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7Ozs7Ozs7Ozs7QUNySWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNWYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDckVhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDYmE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDLFNBQVM7O0FBRVQ7QUFDQSw0REFBNEQsd0JBQXdCO0FBQ3BGO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7OztBQ3BEYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1ZhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7OztBQ25FYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbURBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7O0FDWGE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7Ozs7Ozs7Ozs7QUNwRGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFCYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsK0RBQXNCOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeEdhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxnRUFBZ0I7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLG9DQUFvQyxtREFBbUQsR0FBRyxHQUFHO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsTUFBTTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsRUFBRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0UWE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsMERBQWM7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLCtDQUFTO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxtREFBVztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnRUFBZ0U7QUFDckYsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyVWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLG1EQUFXOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0EsQ0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQStDO0FBQy9FO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDO0FBQzlFO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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QTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBLG1DQUFtQyw2Q0FBNkM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QkFBMEI7QUFDeEQ7QUFDQSxDQUFDOztBQUV1aUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJsb2tzL2NvbnN0YW50cy9kaXN0L2NvbnN0YW50cy5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BibG9rcy9udW1iZXJzL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BibG9rcy9udW1iZXJzL2Rpc3QvbnVtYmVycy5janMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BibG9rcy91dGlscy9kaXN0L3V0aWxzLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGphZnJpL251bWJyby9kaXN0L251bWJyby5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vYXBpL2Rpc3QvYXBpLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9oeXBlcmlvbi9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2h5cGVyaW9uL2Rpc3Qvc3JjL2VuZHBvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9oeXBlcmlvbi9kaXN0L3NyYy9qc29ucnBjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2h5cGVyaW9uL2Rpc3Qvc3JjL3JwY2Vycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2h5cGVyaW9uL2Rpc3Qvc3JjL3R5cGVzL2FjdGlvbl90cmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9oeXBlcmlvbi9kaXN0L3NyYy90eXBlcy9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vbGlnaHQtYXBpL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vbGlnaHQtYXBpL2Rpc3Qvc3JjL2VuZHBvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9saWdodC1hcGkvZGlzdC9zcmMvanNvbnJwYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9saWdodC1hcGkvZGlzdC9zcmMvcnBjZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vbGlnaHQtYXBpL2Rpc3Qvc3JjL3R5cGVzL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9kaXN0L3dyYXAtY29uc3RhbnRzLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvWm9kRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL2NvZGVnZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL2RlZmF1bHRFcnJvck1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvaGVscGVycy9lcnJvclV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL2hlbHBlcnMvb2JqZWN0VXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvaGVscGVycy91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvaXNTY2FsYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvYW55LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvYmlnaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9ib29sZWFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9kYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9lbnVtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvaW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvbGF6eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvbGl0ZXJhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvbmF0aXZlRW51bS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvbnVsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvbnVtYmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3JlY29yZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy90dXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvdW5kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy91bmlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvdW5rbm93bi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvdm9pZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvdWkvQ3VycmVuY3lEcm9wZG93bi5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy91aS9JbWFnZXNVcGxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbnN0YW50cy9DdXJyZW5jeUxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL3BhZ2VzL1B1cmNoYXNlSXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc2RrL2Vhc3llc2Nyb3dTREsuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL3Nkay9wcm90b25BUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhY2tvMi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXlqcy9kYXlqcy5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RheWpzL3BsdWdpbi9hZHZhbmNlZEZvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL3JlbGF0aXZlVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL3RpbWV6b25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXlqcy9wbHVnaW4vdXRjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25ycGMyLXdzL2xpYi9NYXBMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc29ucnBjMi13cy9saWIvTWVzc2FnZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25ycGMyLXdzL2xpYi9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25ycGMyLXdzL2xpYi9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25ycGMyLXdzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbnJwYzItd3MvbGliL3NlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NpZGUtY2hhbm5lbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbWQ1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zaGExLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92My5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vaWdub3JlZHxGOlxcTmV3X2NsaWVudHNcXFdhZGUtUHJvdG9uXFxFYXN5RXNjcm93XFxub2RlX21vZHVsZXNcXG9iamVjdC1pbnNwZWN0fC4vdXRpbC5pbnNwZWN0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96b2QvbGliL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgREVGQVVMVF9TWU1CT0wgPSAnRU9TJztcbnZhciBERUZBVUxUX1NZU1RFTV9ET01BSU4gPSAnZW9zaW8nO1xudmFyIERFRkFVTFRfQ0hBSU4gPSAnZW9zJztcblxudmFyIGdldENvbnRyYWN0Q29uc3RhbnRzID0gZnVuY3Rpb24gZ2V0Q29udHJhY3RDb25zdGFudHMoY2hhaW4sIHN5c3RlbURvbWFpbikge1xuICBpZiAoY2hhaW4gPT09IHZvaWQgMCkge1xuICAgIGNoYWluID0gREVGQVVMVF9DSEFJTjtcbiAgfVxuXG4gIGlmIChzeXN0ZW1Eb21haW4gPT09IHZvaWQgMCkge1xuICAgIHN5c3RlbURvbWFpbiA9IERFRkFVTFRfU1lTVEVNX0RPTUFJTjtcbiAgfVxuXG4gIC8vIFByb3h5IEluZm9ybWF0aW9uIEFjY291bnRcbiAgdmFyIHByb3h5SW5mbztcblxuICBpZiAoWydlb3MnLCAnYm9zJywgJ3dheCddLmluY2x1ZGVzKGNoYWluKSkge1xuICAgIHByb3h5SW5mbyA9ICdyZWdwcm94eWluZm8nO1xuICB9IGVsc2UgaWYgKGNoYWluID09PSAndGVsb3MnKSB7XG4gICAgcHJveHlJbmZvID0gJ3Rsc3Byb3h5aW5mbyc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIEFjY291bnRzXG4gICAgRU9TSU86IHN5c3RlbURvbWFpbixcbiAgICBFT1NJT19UT0tFTjogIVsnZmlvJywgJ2Zpby10ZXN0J10uaW5jbHVkZXMoY2hhaW4pID8gc3lzdGVtRG9tYWluICsgXCIudG9rZW5cIiA6ICdmaW8udG9rZW4nLFxuICAgIEFDQ09VTlRfSU5GTzogJ2FjY291bnQuaW5mbycsXG4gICAgUFJPWFlfSU5GT19BQ0NPVU5UOiBwcm94eUluZm8sXG4gICAgRU9TSU9fTVNJRzogc3lzdGVtRG9tYWluICsgXCIubXNpZ1wiLFxuICAgIEVPU0lPX1JBTTogc3lzdGVtRG9tYWluICsgXCIucmFtXCIsXG4gICAgRU9TSU9fU1RBS0U6IHN5c3RlbURvbWFpbiArIFwiLnN0YWtlXCIsXG4gICAgRU9TSU9fUFJPRFM6IHN5c3RlbURvbWFpbiArIFwiLnByb2RzXCIsXG4gICAgRU9TSU9fTlVMTDogc3lzdGVtRG9tYWluICsgXCIubnVsbFwiLFxuICAgIEVPU0lPX1JBTUZFRTogc3lzdGVtRG9tYWluICsgXCIucmFtZmVlXCIsXG4gICAgRU9TSU9fVlBBWTogc3lzdGVtRG9tYWluICsgXCIudnBheVwiLFxuICAgIEVPU0lPX0JQQVk6IHN5c3RlbURvbWFpbiArIFwiLmJwYXlcIixcbiAgICBFT1NJT19SRVg6IHN5c3RlbURvbWFpbiArIFwiLnJleFwiLFxuICAgIC8vIFBhcmFtc1xuICAgIE5FV0FDQ09VTlRfTkFNRV9QQVJBTTogY2hhaW4uaW5kZXhPZignYm9zJykgPT09IC0xID8gJ25hbWUnIDogJ25ld2FjdCcsXG4gICAgLy8gVGFibGVzXG4gICAgRU9TSU9fTVNJR19BUFBST1ZBTFNfVEFCTEU6ICdhcHByb3ZhbHMyJyxcbiAgICBFT1NJT19NU0lHX1BST1BPU0FMU19UQUJMRTogJ3Byb3Bvc2FsJyxcbiAgICAvLyBBY3Rpb25zXG4gICAgVFJBTlNGRVJfQUNUSU9OOiAndHJhbnNmZXInLFxuICAgIERFTEVHQVRFX0JXX0FDVElPTjogJ2RlbGVnYXRlYncnLFxuICAgIFVOREVMRUdBVEVfQldfQUNUSU9OOiAndW5kZWxlZ2F0ZWJ3JyxcbiAgICBWT1RFX1BST0RVQ0VSX0FDVElPTjogJ3ZvdGVwcm9kdWNlcicsXG4gICAgQlVZX1JBTV9BQ1RJT046ICdidXlyYW0nLFxuICAgIEJVWV9SQU1fQllURVNfQUNUSU9OOiAnYnV5cmFtYnllcycsXG4gICAgU0VMTF9SQU1fQUNUSU9OOiAnc2VsbHJhbSdcbiAgfTtcbn07XG5cbnZhciBkYXBwcyA9IFt7XG4gIG5hbWU6ICdBbGNvci5leGNoYW5nZScsXG4gIGRlc2NyaXB0aW9uOiAnVGhlIGZpcnN0IHNlbGYtbGlzdGluZyBERVguIFdpdGggQWxjb3IgeW91IGNhbiB0cmFkZSBhbnkgRU9TLklPIHRva2VucyBmb3Igc3lzdGVtIEVPUyB0b2tlbnMsIGF0b21pY2FsbHksIHdpdGhvdXQgdGhlIHBhcnRpY2lwYXRpb24gb2YgdGhpcmQgcGFydGllcyEgQ3JlYXRlIG1hcmtldHMgaW4gb25lIGNsaWNrLCBsaXN0IHlvdXIgZGFwcCB0b2tlbiBmb3Igb25lIGNsaWNrLCB0cmFkZSB3aGF0ZXZlciB5b3Ugd2FudC4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnVGhlIGZpcnN0IHNlbGYtbGlzdGluZyBERVguIFdpdGggQWxjb3IgeW91IGNhbiB0cmFkZSBhbnkgRU9TLklPIHRva2VucyBmb3Igc3lzdGVtIEVPUyB0b2tlbnMuJyxcbiAgc3ltYm9sOiAnJyxcbiAgc3RhdGlzdGljczogdHJ1ZSxcbiAgYWNjb3VudHM6IFsnZW9zdG9rZW5zZGV4J10sXG4gIGxvZ286ICdodHRwczovL2kuaWJiLmNvL2RLRFlETWMvdmVjdG9ycGFpbnQucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vYWxjb3IuZXhjaGFuZ2UvJyxcbiAgYXBwOiAnaHR0cHM6Ly9hbGNvci5leGNoYW5nZS8nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9hbGNvcmV4Y2hhbmdlJyxcbiAgbWVkaXVtOiAnaHR0cHM6Ly9tZWRpdW0uY29tL0BhdnJhbCcsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL2F2cmFsX3BybycsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9hdnJhbC9hbGNvci11aScsXG4gIGNoYWluczogWydlb3MnLCAnd2F4JywgJ3RlbG9zJ11cbn0sIHtcbiAgbmFtZTogJ1NYJyxcbiAgZGVzY3JpcHRpb246ICdCdWlsZGluZyBzZWN1cmUgJiByZWxpYWJsZSBmaW5hbmNpYWwgYmxvY2tjaGFpbiBpbnN0cnVtZW50cycsXG4gIHNob3J0RGVzY3JpcHRpb246ICdEZUZpIFN3YXAgJiBGbGFzaGxvYW4nLFxuICBzeW1ib2w6ICdTWCcsXG4gIGFjY291bnRzOiBbJ3N3YXAuc3gnLCAndmlnb3Iuc3gnLCAnc3RhYmxlLnN4JywgJ2ZsYXNoLnN4JywgJ3B1c2guc3gnLCAnbmV0d29yay5zeCcsICdyZWdpc3RyeS5zeCcsICdtaW5lci5zeCcsICdjcm9zcy5zeCcsICduYXYuc3gnLCAnZmVlLnN4JywgJ3RyYWRlLnN4JywgJ3ZhdWx0cy5zeCcsICdwcm94eS5zeCcsICdkdXN0LnN4JywgJ2N1cnZlLnN4J10sXG4gIGxvZ286ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZW9zY2FmZS9lb3MtYWlyZHJvcHMvbWFzdGVyL2xvZ29zL3N4LnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL2dpdGh1Yi5jb20vc3RhYmxlZXgnLFxuICBhcHA6ICdodHRwczovL3huYXRpb24uaW8nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS94bmF0aW9uaW8nLFxuICBtZWRpdW06ICcnLFxuICB0d2l0dGVyOiAnJyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL3N0YWJsZWV4JyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdFT1NOYW1lU2VydmljZScsXG4gIGRlc2NyaXB0aW9uOiAnRU9TIE5hbWUgU2VydmljZSBpcyB0aGUgbW9zdCBjb21wcmVoZW5zaXZlIHBsYXRmb3JtIHRvIHJlZ2lzdGVyIHByZW1pdW0vYmFzZSBFT1MvV0FYIGFjY291bnQgbmFtZXMuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ0VPUy9XQVggTmFtZSBTZXJ2aWNlJyxcbiAgc3ltYm9sOiAnJyxcbiAgcGFydG5lcjogZmFsc2UsXG4gIGFjY291bnRzOiBbJ25hbWVzJ10sXG4gIGxvZ286ICdodHRwczovL2F2YXRhcnMxLmdpdGh1YnVzZXJjb250ZW50LmNvbS91LzczODkxMDQxJyxcbiAgd2Vic2l0ZTogJ2h0dHA6Ly9lb3NuYW1lc2VydmljZS5pbycsXG4gIGFwcDogJ2h0dHA6Ly9lb3NuYW1lc2VydmljZS5pbycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2Vvc25hbWVzZXJ2aWNlJyxcbiAgbWVkaXVtOiAnJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vZW9zbmFtZXNlcnZpY2UnLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vZW9zbmFtZXNlcnZpY2UnLFxuICBjaGFpbnM6IFsnZW9zJywgJ3dheCddXG59LCB7XG4gIG5hbWU6ICdQcm9zcGVjdG9ycycsXG4gIGRlc2NyaXB0aW9uOiAnTWFzc2l2ZSBNdWx0aXBsYXllciBPbmxpbmUgUmVhbC1UaW1lIEVjb25vbWljIFN0cmF0ZWd5IEdhbWUgIE1JTkUgR09MRCAtIEJVSUxEIFlPVVIgV09STEQnLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnTWFzc2l2ZSBNdWx0aXBsYXllciBPbmxpbmUgUmVhbC1UaW1lIEVjb25vbWljIFN0cmF0ZWd5IEdhbWUnLFxuICBzeW1ib2w6ICcnLFxuICBhY2NvdW50czogWydwcm9zcGVjdG9yc2MnXSxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL3Byb3NwZWN0b3JzLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL3Byb3NwZWN0b3JzLmlvJyxcbiAgYXBwOiAnaHR0cHM6Ly9wcm9zcGVjdG9ycy5pbycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL3Byb3NwZWN0b3JzZ2FtZScsXG4gIG1lZGl1bTogJ2h0dHBzOi8vbWVkaXVtLmNvbS9AcHJvc3BlY3RvcnNnYW1lJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vcHJvc3BlY3RvcnNnYW1lJyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL3Byb3NwZWN0b3JzL3B1YmxpYy9pc3N1ZXMnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ0FQUElDUycsXG4gIGRlc2NyaXB0aW9uOiAnQVBQSUNTIGlzIHRoZSBtb3N0IGVuZ2FnZWQgc29jaWFsIG1lZGlhIGRBcHAgdGhhdCBtYWtlcyBpdCBlYXN5IHRvIGdldCByZXdhcmRlZCB3aXRoIGNyeXB0b2N1cnJlbmN5IGZvciB5b3VyIHNvY2lhbCBtZWRpYSBhY3Rpdml0eSBsaWtlIGNyZWF0aW5nICYgY3VyYXRpbmcgY29udGVudC4gVGhlIG1vYmlsZSBpbnRlcmZhY2UgaXMgaW50dWl0aXZlIHRvIHVzZSB3aXRob3V0IGFueSBwcmlvciBibG9ja2NoYWluIGtub3dsZWRnZS4gR2V0IHJld2FyZGVkIGZvciB5b3VyIHBhc3Npb24hJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ0FQUElDUyBpcyB0aGUgbW9zdCBlbmdhZ2VkIHNvY2lhbCBtZWRpYSBkQXBwIC0gZWFybiBBUFggVG9rZW5zIGZvciBwb3N0aW5nLCBjb21tZW50aW5nLCBhbmQgdXAtdm90aW5nIHBob3RvcyAmIHZpZGVvcyEnLFxuICBzeW1ib2w6ICdBUFgnLFxuICBzdGF0aXN0aWNzOiB0cnVlLFxuICBhY2NvdW50czogWydhcHBpY3NhcHBpY3MnXSxcbiAgbG9nbzogJ2h0dHBzOi8vaS5pbWd1ci5jb20vVHM5Q05ONS5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9hcHBpY3MuY29tJyxcbiAgYXBwOiAnaHR0cHM6Ly9hcHBpY3MuY29tJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvYXBwaWNzX29mZmljaWFsJyxcbiAgbWVkaXVtOiAnaHR0cHM6Ly9tZWRpdW0uY29tL0BhcHBpY3MnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9hcHBpY3Nfb2ZmaWNpYWwnLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vcGhlbm9tLWNvbXBhbnkvYXBwaWNzX2Vvc190b2tlbicsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnQm9pZCcsXG4gIGRlc2NyaXB0aW9uOiAnQ29udHJpYnV0ZSB5b3VyIGV4Y2VzcyBjb21wdXRpbmcgcmVzb3VyY2VzIHRvd2FyZHMgaW1wb3J0YW50IGNhdXNlcyB3aGlsZSBlYXJuaW5nIHJld2FyZHMuIEpvaW4gYSB0ZWFtIGFuZCByYW5rIHVwIG9uIHRoZSBzb2NpYWwgbGVhZGVyYm9hcmRzLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdUaGUgU29jaWFsIFN1cGVyY29tcHV0ZXIuIENvbnRyaWJ1dGUgeW91ciBleGNlc3MgY29tcHV0aW5nIHJlc291cmNlcyB0b3dhcmRzIGltcG9ydGFudCBjYXVzZXMuJyxcbiAgc3ltYm9sOiAnJyxcbiAgYWNjb3VudHM6IFsnYm9pZGNvbXRva2VuJywgJ2JvaWRjb21wb3dlcicsICdib2lkY29tbWludDEnLCAnYm9pZGNvbXByb21vJ10sXG4gIGxvZ286ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYm9pZC1jb20vYXNzZXRzL21hc3Rlci9ib2lkTG9nby1sZy5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9ib2lkLmNvbScsXG4gIGFwcDogJ2h0dHBzOi8vYXBwLmJvaWQuY29tJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvQm9pZGNvbV9vZmZpY2lhbCcsXG4gIG1lZGl1bTogJ2h0dHBzOi8vbWVkaXVtLmNvbS9AYm9pZGNvbScsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL2JvaWRjb20nLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vYm9pZC1jb20nLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ1RoZSBCaWxsaW9uYWlyZSBUb2tlbicsXG4gIGRlc2NyaXB0aW9uOiAnTW9zdCBvdGhlciBjb2lucyBvciB0b2tlbnMgaGF2ZSBzb21lIHNvcnQgb2YgbWluaW5nIHN5c3RlbS4gQmlsbGlvbmFpcmUgVG9rZW4gaGFzIHRoZSBleGFjdCBvcHBvc2l0ZTogSXQgZmVhdHVyZXMgYSBkZWZsYXRpb25hcnkgbWVjaGFuaXNtIHRoYXQgZGVzdHJveXMgMzAlIG9mIHRoZSBnYW1ibGVkIGNvaW5zLiBUaHVzIHRoZSB0b2tlbnMgYmVjb21lIG1vcmUgYW5kIG1vcmUgcmFyZSBhcyBtb3JlIGFuZCBtb3JlIHBlb3BsZSBnYW1ibGUuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ0JpbGxpb25haXJlIFRva2VuIGhhcyB0aGUgb3Bwb3NpdGUgb2YgYSBtaW5pbmcgc3lzdGVtOiBJdCBmZWF0dXJlcyBhIGRlZmxhdGlvbmFyeSBtZWNoYW5pc20gdGhhdCBkZXN0cm95cyAzMCUgb2YgdGhlIGdhbWJsZWQgY29pbnMuJyxcbiAgc3ltYm9sOiAnWEJMJyxcbiAgYWNjb3VudHM6IFsnYmlsbGlvbmFpcmV0JywgJ2JpbGxpb25yYWZmbCcsICdiaWxsaW9uYnVybnInLCAnYmlsbGlvbmJvdDExJywgJ2JpbGxpb25ib3QxMicsICdiaWxsaW9uYm90MTMnLCAnYmlsbGlvbmJvdDE0J10sXG4gIGFwcDogJ2h0dHBzOi8vQmlsbGlvbmFpcmVUb2tlbi5jb20vJyxcbiAgbG9nbzogJ2h0dHBzOi8vQmlsbGlvbmFpcmVUb2tlbi5jb20vaW1hZ2VzL2xvZ29fYmlnLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL0JpbGxpb25haXJlVG9rZW4uY29tLycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL0JpbGxpb25haXJlVG9rZW4nLFxuICBtZWRpdW06ICdodHRwczovL21lZGl1bS5jb20vQGJpbGxpb25haXJlXzMzNzMnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9CaWxsaW9uYWlyZVRrbicsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9CaWxsaW9uYWlyZVRva2VuJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdDcnlwdG8gU3dvcmQgJiBNYWdpYycsXG4gIGRlc2NyaXB0aW9uOiAnQ3J5cHRvIFN3b3JkICYgTWFnaWMgaXMgdGhlIGZpcnN0IGJsb2NrYnVzdGVyIFJQRyBvbiBFT1MgYmxvY2tjaGFpbiwgdHJhZGl0aW9uYWwgdHVybi1iYXNlZCBSUEcgcmFpc2luZyBoZXJvZXMgdG8gY2hhbGxlbmdlIG5ldyBkdW5nZW9ucy4gR2FtZSBhc3NldHMgYXJlIHJlY29yZGVkIG9uIEJsb2NrY2hhaW4gYW5kIHRyYW5zYWN0aW9ucyBydW4gb24gc21hcnQgY29udHJhY3RzJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ0NyeXB0byBTd29yZCAmIE1hZ2ljIGlzIHRoZSBmaXJzdCBibG9ja2J1c3RlciBSUEcgb24gRU9TIGJsb2NrY2hhaW4uJyxcbiAgc3ltYm9sOiAnQ1NNJyxcbiAgYWNjb3VudHM6IFsnc3dvcmRubWFnaWNtJ10sXG4gIGFwcDogJ2h0dHBzOi8vd3d3LmNyeXB0b3N3b3JkYW5kbWFnaWMuY29tJyxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL2NyeXB0b3NubS5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly93d3cuY3J5cHRvc3dvcmRhbmRtYWdpYy5jb20nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9jcnlwdG9zbm1fY29tbV9lbicsXG4gIG1lZGl1bTogJ2h0dHBzOi8vbWVkaXVtLmNvbS9AY3J5cHRvc3dvcmRhbmRtYWdpYycsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL3N3b3JkX2FuZF9tYWdpYycsXG4gIGdpdGh1YjogJycsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnZG1haWwnLFxuICBkZXNjcmlwdGlvbjogJ1dlbGNvbWUgdG8gZG1haWwgQmV0YSEgV2UgYXJlIHNvIGV4Y2l0ZWQgdG8gaGF2ZSB5b3UgcGFydGljaXBhdGUgYXMgd2UgbGF1bmNoIG91ciBCZXRhIHBsYXRmb3JtLiBJbiB0aGUgZWFybHkgc3RhZ2VzIHdlIGFyZSBjb3ZlcmluZyB0aGUgc2ltcGxlc3Qgb2YgZnVuY3Rpb25hbGl0eSwgd2hpY2ggaXMgc2VuZGluZyBhbmQgcmVjZWl2aW5nIG1lc3NhZ2VzLiBJbiB0aGUgdmVyeSBuZWFyIGZ1dHVyZSwgd2Ugd2lsbCBiZSBhZGRpbmcgYSBidW5jaCBvZiBuZXcgZmVhdHVyZXMgd2hpY2ggd2Uga25vdyB0aGUgY29tbXVuaXR5IGlzIGdvaW5nIHRvIGFzayBmb3IuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ2RtYWlsIGlzIHRoZSBmaXJzdCBkZWNlbnRyYWxpemVkIGVtYWlsIG9uIHRoZSBibG9ja2NoYWluJyxcbiAgc3ltYm9sOiAnTUFJTCcsXG4gIHN0YXRpc3RpY3M6IHRydWUsXG4gIGFjY291bnRzOiBbJ2RtYWlsZG90Y29icCddLFxuICBsb2dvOiAnaHR0cHM6Ly93d3cuZG1haWwuY28vbG9nb3N5bV8yNTYucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vZG1haWwuY28nLFxuICBhcHA6ICcnLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9kbWFpbGNvbW11bml0eScsXG4gIG1lZGl1bTogJ2h0dHBzOi8vbWVkaXVtLmNvbS9AZG1haWwnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9kbWFpbGRvdGNvJyxcbiAgZ2l0aHViOiAnJyxcbiAgY2hhaW5zOiBbJ2VvcycsICd0ZWxvcyddXG59LCB7XG4gIG5hbWU6ICdNdXJtdXInLFxuICBkZXNjcmlwdGlvbjogJ011cm11ciBpcyBhIG5ldyBhZ2UgZGVjZW50cmFsaXplZCBtaWNyb2Jsb2dnaW5nIHBsYXRmb3JtIG9uIEVPUyB0aGF0IGlzIGNlbnNvcnNoaXAtcmVzaXN0YW50LCBzcGFtLXByb29mIGFuZCByZXdhcmRpbmcgdG8gdXNlLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdNdXJtdXIgaXMgYSBuZXcgYWdlIGRlY2VudHJhbGl6ZWQgbWljcm9ibG9nZ2luZyBwbGF0Zm9ybSBvbiBFT1MgdGhhdCBpcyBjZW5zb3JzaGlwLXJlc2lzdGFudCwgc3BhbS1wcm9vZiBhbmQgcmV3YXJkaW5nIHRvIHVzZS4nLFxuICBzeW1ib2w6ICdNVVInLFxuICBwYXJ0bmVyOiB0cnVlLFxuICBhY2NvdW50czogWydtdXJtdXJkYXBwY28nLCAnbXVybXVydG9rZW5zJywgJ211cm11cmZyZWVhYyddLFxuICBhcHA6ICdodHRwczovL3BsYXkuZ29vZ2xlLmNvbS9zdG9yZS9hcHBzL2RldGFpbHM/aWQ9Y29tLm11cm11cmRhcHAnLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvbXVybXVyLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwOi8vbXVybXVyZGFwcC5jb20nLFxuICB0ZWxlZ3JhbTogJ2h0dHA6Ly90Lm1lL211cm11cmRhcHAnLFxuICBtZWRpdW06ICcnLFxuICB0d2l0dGVyOiAnaHR0cDovL3R3aXR0ZXIuY29tL211cm11cmRhcHAnLFxuICBnaXRodWI6ICcnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ0VtYW5hdGUnLFxuICBkZXNjcmlwdGlvbjogJ0VtYW5hdGUgaXMgRU9TIGZvciB0aGUgbXVzaWMgaW5kdXN0cnkuIEFuIGF1dG9tYXRlZCwgcmVhbHRpbWUgbXVzaWMgY29sbGFib3JhdGlvbiBhbmQgbW9uZXRpc2F0aW9uIHBsYXRmb3JtLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdFbWFuYXRlIGlzIGRlY2VudHJhbGlzZWQgdGVjaG5vbG9neSBmb3IgdGhlIGZ1dHVyZSBvZiBtdXNpYycsXG4gIHN5bWJvbDogJ0VNVCcsXG4gIHBhcnRuZXI6IHRydWUsXG4gIGFjY291bnRzOiBbJ2VtYW5hdGVvbmVvcycsICdlbWFuYXRlaXNzdWUnXSxcbiAgYXBwOiAnaHR0cHM6Ly9lbWFuYXRlLmxpdmUvJyxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL2VtYW5hdGUucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vZW1hbmF0ZS5saXZlJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvZW1hbmF0ZW9mZmljaWFsJyxcbiAgbWVkaXVtOiAnJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vZW1hbmF0ZW9mZmljaWFsJyxcbiAgZ2l0aHViOiAnJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdwaXhFT1MnLFxuICBkZXNjcmlwdGlvbjogJ3BpeEVPUyBpcyB0aGUgZmlyc3QgdG9rZW5pemVkIHNtYXJ0IGVjb25vbXkgZm9yIGdhbWVycywgYXJ0aXN0cyBhbmQgYXJ0IGVudGh1c2lhc3RzLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdwaXhFT1MgaXMgdGhlIGZpcnN0IHRva2VuaXplZCBzbWFydCBlY29ub215IGZvciBnYW1lcnMsIGFydGlzdHMgYW5kIGFydCBlbnRodXNpYXN0cy4nLFxuICBzeW1ib2w6ICdQSVhFT1MnLFxuICBwYXJ0bmVyOiB0cnVlLFxuICBhY2NvdW50czogWydwaXhlb3MxdG9rZW4nLCAncGl4ZW9zMWFkbWluJywgJ3BpeGVvczFzdGFydCddLFxuICBhcHA6ICdodHRwczovL3BpeGVvcy5pbycsXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9waXhlb3MucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vcGl4ZW9zLmlvJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvUElYRU9TJyxcbiAgbWVkaXVtOiAnJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vZW9zX3BpeCcsXG4gIGdpdGh1YjogJycsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnRXZlcmlwZWRpYScsXG4gIGRlc2NyaXB0aW9uOiAnVGhlIEV2ZXJpcGVkaWEgdGVhbSBwbGFucyB0byBidWlsZCBhIG1vZGVybiwgY29udmVuaWVudCBhbmQgZGVjZW50cmFsaXplZCBuZXcgZW5jeWNsb3BlZGlhIHdlYnNpdGUsIGFuZCB0aGlzIGdvYWwgd2lsbCBiZSByZWFsaXplZCB3aXRoIHRoZSBkZXZlbG9wbWVudCBvZiBibG9ja2NoYWluIHRlY2hub2xvZ3kuIFRoZSBuZXcgdmVyc2lvbiBvZiBFdmVyaXBlZGlhIHVuZGVyIGRldmVsb3BtZW50IHdpbGwgYmUgYmFzZWQgb24gdGhlIEVPUyBuZXR3b3JrLCB3aGljaCB3aWxsIGhhdmUgZmVhdHVyZXMgc3VjaCBhcyBjb21tdW5pdHkgYXV0b25vbXksIHNoaWVsZGluZyBwcmV2ZW50YXRpb24sIGFuZCBjb250cmlidXRpb24gaW5jZW50aXZlcyBjb21wYXJlZCB0byB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIEV2ZXJpcGVkaWEuIEZvdW5kZWQgaW4gMjAxNCwgdGhlIGJ1c2luZXNzIG5ldHdvcmsgZW5jeWNsb3BlZGlhIEV2ZXJpcGVkaWEsIHdob3NlIG5hbWUgZGVyaXZlcyBmcm9tIHRoZSBFbmdsaXNoIHdvcmRzIEV2ZXJ5dGhpbmcgYW5kIEVuY3ljbG9wZWRpYSwgaXMgb3duZWQgYnkgRXZlcmlwZWRpYS5JbmMgYW5kIGhhcyBub3QgeWV0IGFkb3B0ZWQgYmxvY2tjaGFpbiB0ZWNobm9sb2d5LiBBcyBvZiBEZWNlbWJlciAyMDE3LCBFdmVyaXBlZGlhIGlzIHRoZSBsYXJnZXN0IEVuZ2xpc2ggZW5jeWNsb3BlZGlhIHdpdGggbW9yZSB0aGFuIHNpeCBtaWxsaW9uIGVudHJpZXMsIGluY2x1ZGluZyBhbGwgRW5nbGlzaCBlbnRyaWVzIG9mIFdpa2lwZWRpYS4gRXZlcmlwZWRpYXMgcmVxdWlyZW1lbnRzIGZvciBhdHRlbnRpb24gYXJlIG1vcmUgcmVsYXhlZCwgc28gaXQgaGFzIG1vcmUgZW50cmllcyB0aGFuIFdpa2lwZWRpYS4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnVGhlIEV2ZXJpcGVkaWEgdGVhbSBwbGFucyB0byBidWlsZCBhIG1vZGVybiwgY29udmVuaWVudCBhbmQgZGVjZW50cmFsaXplZCBuZXcgZW5jeWNsb3BlZGlhLicsXG4gIHN5bWJvbDogJ0lRJyxcbiAgcGFydG5lcjogdHJ1ZSxcbiAgc3RhdGlzdGljczogZmFsc2UsXG4gIGFjY291bnRzOiBbJ2V2ZXJpcGVkaWFpcScsICdlcGFydGljbGVjdHInXSxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL2V2ZXJpcGVkaWEuanBnJyxcbiAgd2Vic2l0ZTogJycsXG4gIGFwcDogJ2h0dHBzOi8vZXZlcmlwZWRpYS5vcmcnLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9ldmVyaXBlZGlhJyxcbiAgbWVkaXVtOiAnJyxcbiAgdHdpdHRlcjogJycsXG4gIGdpdGh1YjogJycsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnZW9zREFDJyxcbiAgZGVzY3JpcHRpb246ICdlb3NEQUMgaXMgYSBDb21tdW5pdHkgT3duZWQgQmxvY2twcm9kdWNlciBhbmQgYSBEQUMgZW5hYmxlciwgYm9ybiBvdXQgb2YgRGFuIExhcmltZXJzIGNvbmNlcHQgb2YgRGVjZW50cmFsaXplZCBBdXRvbm9tb3VzIENvbW11bml0aWVzIG9yIERBQ3MsIGFyb3VuZCB3aGljaCBCbG9jay5vbmUgZGV2ZWxvcGVkIEVPUyBzb2Z0d2FyZS4gIFRoZSB2aXNpb24gb2YgZW9zREFDIGlzIHRoYXQgRU9TLklPIGJsb2NrIHByb2R1Y3Rpb24gc2hvdWxkIGJlIG9wZW4gZm9yIGV2ZXJ5b25lIHRvIGNvbnRyaWJ1dGUgYW5kIGJlbmVmaXQuIFRvIHJlYWxpemUgdGhpcyB2aXNpb24sIGVvc0RBQyBpcyBhbiBldm9sdmluZyBEZWNlbnRyYWxpc2VkIEF1dG9ub21vdXMgQ29tbXVuaXR5IChEQUMpIGZvY3VzZWQgb24gRU9TLklPIEJsb2NrIFByb2R1Y3Rpb24gc2VydmluZyB0aGUgRU9TIGNvbW11bml0aWVzIHdvcmxkd2lkZS4gSW4gZG9pbmcgdGhpcywgZW9zREFDIGlzIGNyZWF0aW5nIHRoZSB0b29scyBhbmQgc21hcnQgY29udHJhY3RzIGl0IG5lZWRzIHRvIGZ1bmN0aW9uLiBJdCB3aWxsIHNoYXJlIHRoZXNlIHdpdGggdGhlIEVPUyBjb21tdW5pdGllcyB0byBoZWxwIG90aGVyIERBQ3MgdGhyaXZlIG9uIHRoZSBFT1MuSU8gYmxvY2tjaGFpbnMuICBJbiBvcmRlciB0byBmdW5jdGlvbiBhcyBhIERBQywgZW9zREFDIGlzIGNyZWF0aW5nIG9wZW4gc291cmNlIHRvb2xzIGFuZCB3aWxsIGJlIHNoYXJpbmcgdGhlbSBhcyBhIERBQyBUb29sa2l0LCB0aGF0IGFueW9uZSBjYW4gdXNlLCBtb2RpZnkgdG8gc2V0dXAgYW5kIHJ1biBhIERBQy4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnZW9zREFDIGlzIGNyZWF0aW5nIG9wZW4gc291cmNlIHRvb2xzIGFuZCB3aWxsIGJlIHNoYXJpbmcgdGhlbSBhcyBhIERBQyBUb29sa2l0IHRvIGVuYWJsZSBEQUNzJyxcbiAgc3ltYm9sOiAnRU9TREFDJyxcbiAgcGFydG5lcjogZmFsc2UsXG4gIHN0YXRpc3RpY3M6IGZhbHNlLFxuICBhY2NvdW50czogWydlb3NkYWN0b2tlbnMnLCAnZW9zZGFjc2VydmVyJywgJ2Vvc2RhY3RoZWRhYycsICdkYWNjdXN0b2RpYW4nXSxcbiAgbG9nbzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lb3NjYWZlL2Vvcy1kYXBwcy9tYXN0ZXIvbG9nb3MvZW9zZGFjLnBuZycsXG4gIHdlYnNpdGU6ICcnLFxuICBhcHA6ICdtZW1iZXJzLmVvc2RhYy5pbycsXG4gIGRpc2NvcmQ6ICdodHRwczovL2Rpc2NvcmQuaW8vZW9zZGFjJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvZW9zZGFjaW8nLFxuICBtZWRpdW06ICcnLFxuICB0d2l0dGVyOiAnJyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL2Vvc2RhYycsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnREVPUyBHYW1lcycsXG4gIGRlc2NyaXB0aW9uOiAnRGVvcyBHYW1lcyBhcmUgY2FzaW5vIGdhbWVzIGJ1aWx0IG9uIEVPUyBibG9ja2NoYWluLiBQbGF5IHplcm8gZWRnZSBnYW1lcyB3aXRoIG91ciBERU9TIHRva2VuIGFuZCBwYXJ0aWNpcGF0ZSBpbiBiYW5rcm9sbCBzdGFraW5nLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdEZW9zIEdhbWVzIGFyZSBjYXNpbm8gZ2FtZXMgYnVpbHQgb24gdGhlIEVPUyBibG9ja2NoYWluLiBQbGF5IHplcm8gZWRnZSBnYW1lcyB3aXRoIERFT1MgdG9rZW4uJyxcbiAgc3ltYm9sOiAnREVPUycsXG4gIHN0YXRpc3RpY3M6IGZhbHNlLFxuICBhY2NvdW50czogWyd0aGVkZW9zZ2FtZXMnLCAnZGVvc2dhbWVpc3N1J10sXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9kZW9zZ2FtZXMucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vZGVvc2dhbWVzLmNvbScsXG4gIGFwcDogJ2h0dHBzOi8vYXBwLmRlb3NnYW1lcy5jb20nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9kZW9zZ2FtZXNjaGF0JyxcbiAgbWVkaXVtOiAnaHR0cHM6Ly9tZWRpdW0uY29tL2Rlb3MtZ2FtZXMnLFxuICB0d2l0dGVyOiAnJyxcbiAgZ2l0aHViOiAnJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdDaGludGFpJyxcbiAgZGVzY3JpcHRpb246ICdDaGludGFpIGlzIGEgY29tbXVuaXR5LW93bmVkLCBmZWVsZXNzLCAxMDAlIG9uLWNoYWluLCBtdWx0aXNpZyBkZWNlbnRyYWxpemVkIHRva2VuIGxlYXNpbmcgcGxhdGZvcm0gd2hlcmUgdXNlcnMgY2FuIGxlbmQgdGhlaXIgRU9TIG9uIHRoZSBtYXJrZXQgdG8gZWFybiBpbnRlcmVzdCBmcm9tIG90aGVyIHVzZXJzIHRvIGJvcnJvdyB3aG8gbmVlZCBhY2Nlc3MgdG8gQ1BVL05FVCBiYW5kd2lkdGguJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ0NoaW50YWkgaXMgYSBjb21tdW5pdHktb3duZWQsIGZlZWxlc3MsIDEwMCUgb24tY2hhaW4sIG11bHRpc2lnIGRlY2VudHJhbGl6ZWQgdG9rZW4gbGVhc2luZyBwbGF0Zm9ybS4nLFxuICBzeW1ib2w6ICcnLFxuICBzdGF0aXN0aWNzOiBmYWxzZSxcbiAgYWNjb3VudHM6IFsnY2hpbnRhaWxlYXNlJywgJ2NoaW50YWlwcm94eScsICdiaWRjaGV4dG9rZW4nLCAnY2hleGNoZXhjaGV4J10sXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9jaGludGFpLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwOi8vY2hpbnRhaS5pbycsXG4gIGFwcDogJ2h0dHBzOi8vZW9zLmNoaW50YWkuaW8vZXhjaGFuZ2UvRU9TMjhEJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvQ2hpbnRhaUVPUycsXG4gIG1lZGl1bTogJ2h0dHBzOi8vbWVkaXVtLmNvbS9AQ2hpbnRhaUVPUycsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL2NoaW50YWllb3MnLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vY2hpbnRhaS1wbGF0Zm9ybScsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnTmV3ZGV4JyxcbiAgZGVzY3JpcHRpb246ICdOZXdkZXggaXMgdGhlIGZpcnN0IEVPUyBiYXNlZCBkZWNlbnRyYWxpemVkIGV4Y2hhbmdlIGluIHRoZSB3b3JsZCwgdXBob2xkaW5nIHRoZSBjaGFyYWN0ZXJpc3RpY3Mgb2Ygc2FmZSwgZmFzdCBhbmQgdHJhbnNwYXJlbnQsIGRldm90aW5nIHRvIGNyZWF0ZSBhIG5ldy1nZW5lcmF0aW9uIHBsYXRmb3JtIGZvciBkaWdpdGFsIGFzc2V0cyBleGNoYW5nZSwgbGVhZGluZyB0aGUgaW5kdXN0cnkgaW50byBhbiBpZGVhbCBuZXcgZXJhLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdOZXdkZXggaXMgdGhlIGZpcnN0IEVPUyBiYXNlZCBkZWNlbnRyYWxpemVkIGV4Y2hhbmdlIGluIHRoZSB3b3JsZC4nLFxuICBzeW1ib2w6ICcnLFxuICBhY2NvdW50czogWyduZXdkZXhwb2NrZXQnXSxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL25ld2RleC5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9uZXdkZXguaW8nLFxuICBhcHA6ICdodHRwczovL25ld2RleC5pbycsXG4gIHRlbGVncmFtOiAnJyxcbiAgbWVkaXVtOiAnJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vTmV3ZGV4T2ZmaWNpYWwnLFxuICBnaXRodWI6ICcnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ0VPUyBOYW1lIFN3YXBzJyxcbiAgZGVzY3JpcHRpb246ICdBbiBvcGVuLXNvdXJjZSBFT1MgYWNjb3VudCBleGNoYW5nZSB0aGF0IHB1dHMgdGhlIHNlY3VyaXR5IG9mIGl0cyB1c2VycyBmaXJzdC4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnQW4gb3Blbi1zb3VyY2UgRU9TIGFjY291bnQgZXhjaGFuZ2UgdGhhdCBwdXRzIHRoZSBzZWN1cml0eSBvZiBpdHMgdXNlcnMgZmlyc3QuJyxcbiAgc3ltYm9sOiAnJyxcbiAgc3RhdGlzdGljczogZmFsc2UsXG4gIGFjY291bnRzOiBbJ2Vvc25hbWVzd2FwcyddLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvZW9zbmFtZXN3YXBzLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL3d3dy5lb3NuYW1lc3dhcHMuY29tLycsXG4gIGFwcDogJ2h0dHBzOi8vd3d3LmVvc25hbWVzd2Fwcy5jb20vJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvZW9zbmFtZXN3YXBzJyxcbiAgbWVkaXVtOiAnJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vU3RhcnJ5MzAxN05pZ2h0JyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL1N0YXJyeUphcGFuTmlnaHQvZW9zbmFtZXN3YXBzJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59XTtcblxudmFyIGV4Y2hhbmdlcyA9IHtcbiAgJ0JpdGh1bWInOiB7XG4gICAgJ25hbWUnOiAnQml0aHVtYicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ+u5hO2KuOy9lOyduCwg7J20642U66as7JuALCDruYTtirjsvZTsnbjsupDsi5wsIOumrO2UjCwg65287J207Yq47L2U7J24LCDrjIDsi5wsIOuqqOuEpOuhnCwg67mE7Yq47L2U7J246rOo65OcLCDsnbTsmKTsiqQsIOydtOuNlOumrOybgO2BtOuemOyLnSwg7YCA7YWALCDsoJztirjsupDsi5wsIOyLpOyLnOqwhCDsi5zshLgsIOyJveqzoCDslYjsoITtlZwg6rGw656YLicsXG4gICAgJ2FjY291bnRzJzogWydiaXRodW1ic2hpbnknXSxcbiAgICAnbG9nbyc6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZW9zY2FmZS9lb3MtZGFwcHMvbWFzdGVyL2xvZ29zL3BsYWNlaG9sZGVyLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly93d3cuYml0aHVtYi5jb20vJ1xuICB9LFxuICAnT0tFeCc6IHtcbiAgICAnbmFtZSc6ICdPS0V4JyxcbiAgICAnZGVzY3JpcHRpb24nOiAnT0tFeCBpcyB0aGUgbGVhZGluZyBnbG9iYWwgYml0Y29pbiBleGNoYW5nZS4gU2VjdXJlZCB3aXRoIGJhbmstbGV2ZWwgU1NMIGVuY3J5cHRpb24gYW5kIGNvbGQgc3RvcmFnZS4nLFxuICAgICdhY2NvdW50cyc6IFsnb2tleG9mZmlsaW5lJ10sXG4gICAgJ2xvZ28nOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Vvc2NhZmUvZW9zLWRhcHBzL21hc3Rlci9sb2dvcy9wbGFjZWhvbGRlci5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vd3d3Lm9rZXguY29tLydcbiAgfSxcbiAgJ0JpdGZpbmV4Jzoge1xuICAgICduYW1lJzogJ0JpdGZpbmV4JyxcbiAgICAnZGVzY3JpcHRpb24nOiAnQml0ZmluZXggaXMgYSBmdWxsLWZlYXR1cmVkIHNwb3QgdHJhZGluZyBwbGF0Zm9ybSBmb3IgbWFqb3IgZGlnaXRhbCBhc3NldHMgJiBjcnlwdG9jdXJyZW5jaWVzLCBpbmNsdWRpbmcgQml0Y29pbiwgRXRoZXJldW0sIEVPUywgTGl0ZWNvaW4sIFJpcHBsZSwgTkVPLCBNb25lcm8gYW5kIG1hbnkgbW9yZS4nLFxuICAgICdhY2NvdW50cyc6IFsnYml0ZmluZXhjdzU1JywgJ2JpdGZpbmV4Y3cxMycsICdiaXRmaW5leGN3MTEnLCAnYml0ZmluZXhjdzI0JywgJ2JpdGZpbmV4Y3cxNScsICdiaXRmaW5leGN3MzInLCAnYml0ZmluZXhjdzIxJywgJ2JpdGZpbmV4Y3czMScsICdiaXRmaW5leGN3MjUnLCAnYml0ZmluZXhjdzIzJywgJ2JpdGZpbmV4Y3czMycsICdiaXRmaW5leGN3MjInLCAnYml0ZmluZXhjdzEyJywgJ2JpdGZpbmV4Y3cxNCddLFxuICAgICdsb2dvJzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lb3NjYWZlL2Vvcy1kYXBwcy9tYXN0ZXIvbG9nb3MvcGxhY2Vob2xkZXIucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2JpdGZpbmV4LmNvbS8nXG4gIH0sXG4gICdHYXRlLmlvJzoge1xuICAgICduYW1lJzogJ0dhdGUuaW8nLFxuICAgICdkZXNjcmlwdGlvbic6ICdHYXRlLmlvIGlzIGEgYml0Y29pbiBleGNoYW5nZSBwbGF0Zm9ybSB3aGljaCBzdXBwb3J0cyBCVEMsIExUQywgRXRoZXJldW0sIFF0dW0gYW5kIG1vcmUgYmxvY2tjaGFpbiBhc3NldHMgdHJhZGluZy4nLFxuICAgICdhY2NvdW50cyc6IFsnZ2F0ZWlvd2FsbGV0J10sXG4gICAgJ2xvZ28nOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Vvc2NhZmUvZW9zLWRhcHBzL21hc3Rlci9sb2dvcy9wbGFjZWhvbGRlci5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vd3d3LmdhdGUuaW8vJ1xuICB9LFxuICAnS3Jha2VuJzoge1xuICAgICduYW1lJzogJ0tyYWtlbicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0J1eSwgc2VsbCBhbmQgbWFyZ2luIHRyYWRlIEJpdGNvaW4gKEJUQykgYW5kIEV0aGVydW0gKEVUSCkgaW4gZXhjaGFuZ2Ugd2l0aCBFVVIsIFVTRCwgQ0FELCBHQlAsIGFuZCBKUFkuJyxcbiAgICAnYWNjb3VudHMnOiBbJ2tyYWtlbmtyYWtlbiddLFxuICAgICdsb2dvJzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lb3NjYWZlL2Vvcy1kYXBwcy9tYXN0ZXIvbG9nb3MvcGxhY2Vob2xkZXIucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL3d3dy5rcmFrZW4uY29tLydcbiAgfSxcbiAgJ05ld2RleCc6IHtcbiAgICAnbmFtZSc6ICdOZXdkZXgnLFxuICAgICdkZXNjcmlwdGlvbic6ICdUaGUgZmlyc3QgRU9TIGJhc2VkIGRlY2VudHJhbGl6ZWQgZXhjaGFuZ2UgaW4gdGhlIHdvcmxkLicsXG4gICAgJ2FjY291bnRzJzogWyduZXdkZXhwb2NrZXQnXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9uZXdkZXgucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL25ld2RleC5pby8nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IodG9rZW4sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vbmV3ZGV4LmlvL3RyYWRlL1wiICsgdG9rZW4uYWNjb3VudCArIFwiLVwiICsgcGFpci5wYWlyX2Jhc2UudG9Mb3dlckNhc2UoKSArIFwiLVwiICsgcGFpci5wYWlyX3F1b3RlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuICAnRGVmaUJveCc6IHtcbiAgICAnbmFtZSc6ICdEZWZpQm94JyxcbiAgICAnZGVzY3JpcHRpb24nOiAnT25lLXN0b3AgRGVGaSBhcHBsaWNhdGlvbiBwbGF0Zm9ybSBvbiBFT1MuLicsXG4gICAgJ2FjY291bnRzJzogWyd0b2tlbi5kZWZpJywgJ3N3YXAuZGVmaSddLFxuICAgICdsb2dvJzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lb3NjYWZlL2Vvcy1haXJkcm9wcy9tYXN0ZXIvbG9nb3MvdG9rZW4uZGVmaS1ib3gucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2RlZmlib3guaW8vJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIF9fKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL2RlZmlib3guaW8vXCI7XG4gICAgfVxuICB9LFxuICAnQ2hhaW5jZSc6IHtcbiAgICAnbmFtZSc6ICdDaGFpbmNlJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnQSBTdXBlcmlvciBCbG9ja2NoYWluIEFzc2V0IFRyYWRpbmcgUGxhdGZvcm0gRm9jdXNpbmcgb24gRU9TIFByb2plY3RzJyxcbiAgICAnYWNjb3VudHMnOiBbJ2NoYWluY2VvbmVvcyddLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2NoYWluY2UucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2NoYWluY2UuY29tLycsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL2NoYWluY2UuY29tL3RyYWRlL1wiICsgcGFpci5wYWlyX2Jhc2UudG9Mb3dlckNhc2UoKSArIHBhaXIucGFpcl9xdW90ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSxcbiAgJ0RleGVvcyc6IHtcbiAgICAnbmFtZSc6ICdEZXhlb3MnLFxuICAgICdkZXNjcmlwdGlvbic6ICdUaGUgV29ybGRcXCdzIEZpcnN0IEVPUy1iYXNlZCBEZWNlbnRyYWxpemVkIEV4Y2hhbmdlJyxcbiAgICAnYWNjb3VudHMnOiBbJ2RleGVvc3dhbGxldCddLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2RleGVvcy5zdmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vZGV4ZW9zLmlvLycsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL2RleGVvcy5pby90cmFkZS9cIiArIHBhaXIucGFpcl9iYXNlLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuICAnSG9vJzoge1xuICAgICduYW1lJzogJ0hvbycsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ09uZS1zdG9wIGJsb2NrY2hhaW4gYXNzZXQgc2VydmljZSBwbGF0Zm9ybScsXG4gICAgJ2FjY291bnRzJzogWydob28uY29tJ10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvaG9vLmpwZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9ob28uY29tLycsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL2hvby5jb20vdHJhZGUvXCIgKyBwYWlyLnBhaXJfYmFzZS50b0xvd2VyQ2FzZSgpICsgXCItXCIgKyBwYWlyLnBhaXJfcXVvdGUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0sXG4gICdXaGFsZWV4Jzoge1xuICAgICduYW1lJzogJ1doYWxlZXgnLFxuICAgICdkZXNjcmlwdGlvbic6ICcjMSBEZWNlbnRyYWxpemVkIEV4Y2hhbmdlIGluIHRoZSBXb3JsZCcsXG4gICAgJ2FjY291bnRzJzogWyd3aGFsZWV4dHJ1c3QnXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy93aGFsZWV4LnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly93d3cud2hhbGVleC5jb20nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly93d3cud2hhbGVleC5jb20vdHJhZGUvXCIgKyBwYWlyLnBhaXJfYmFzZSArIFwiX1wiICsgcGFpci5wYWlyX3F1b3RlO1xuICAgIH1cbiAgfSxcbiAgJ0NoYWlucmlmdCc6IHtcbiAgICAnbmFtZSc6ICdDaGFpbnJpZnQnLFxuICAgICdkZXNjcmlwdGlvbic6ICdBIG1hcmtldHBsYWNlIGZvciBkaWdpdGFsIGN1cnJlbmNpZXMnLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2NoYWlucmlmdC5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vd3d3LmNoYWlucmlmdC5jb20vJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vd3d3LmNoYWlucmlmdC5jb20vdHJhZGluZz9jb2lucGFpcj1cIiArIHBhaXIucGFpcl9iYXNlICsgXCIvXCIgKyBwYWlyLnBhaXJfcXVvdGU7XG4gICAgfVxuICB9LFxuICAnRW9zZGFxJzoge1xuICAgICduYW1lJzogJ0VPU0RBUScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0EgU3RhbmRhcmQgb2YgT24tQ2hhaW4gREVYJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9lb3NkYXEucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL3d3dy5lb3NkYXEuY29tLycsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL2Vvc2RhcS5jb20vZXhjaGFuZ2UvXCIgKyBwYWlyLnBhaXJfYmFzZSArIFwiX1wiICsgcGFpci5wYWlyX3F1b3RlO1xuICAgIH1cbiAgfSxcbiAgJ0JpZ09ORSc6IHtcbiAgICAnbmFtZSc6ICdCaWdPTkUnLFxuICAgICdkZXNjcmlwdGlvbic6ICdBIFN0YW5kYXJkIG9mIE9uLUNoYWluIERFWCcsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvYmlnT05FLmpwZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9iaWcub25lJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vYmlnLm9uZS90cmFkZS9cIiArIHBhaXIucGFpcl9iYXNlICsgXCItXCIgKyBwYWlyLnBhaXJfcXVvdGU7XG4gICAgfVxuICB9LFxuICAnWU9MTyc6IHtcbiAgICAnbmFtZSc6ICdZT0xPJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnSW5zdGFudCBUb2tlbiBTd2FwcyBvbiBFT1MnLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL3lvbG8ucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL3lvbG9zd2FwLmNvbScsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL3lvbG9zd2FwLmNvbS9zd2FwL1wiICsgcGFpci5wYWlyX3F1b3RlLnRvTG93ZXJDYXNlKCkgKyBcIi1cIiArIHBhaXIucGFpcl9iYXNlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuICAnQmFuY29yJzoge1xuICAgICduYW1lJzogJ0JhbmNvcicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0luc3RhbnQgTGlxdWlkaXR5LicsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvYmFuY29yLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9iYW5jb3IubmV0d29yaycsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL3d3dy5iYW5jb3IubmV0d29yay90b2tlbi9cIiArIHBhaXIucGFpcl9iYXNlO1xuICAgIH1cbiAgfSxcbiAgJ0FsY29yJzoge1xuICAgICduYW1lJzogJ0FsY29yJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnVGhlIGZpcnN0IHNlbGYtbGlzdGluZyBkZWNlbnRyYWxpemVkIGV4Y2hhbmdlJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9hbGNvci5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vYWxjb3IuZXhjaGFuZ2UnLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgX18pIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vd3d3LmFsY29yLmV4Y2hhbmdlL21hcmtldHNcIjtcbiAgICB9XG4gIH0sXG4gICdEZWZpcy5OZXR3b3JrJzoge1xuICAgICduYW1lJzogJ0RlZmlzLk5ldHdvcmsnLFxuICAgICdkZXNjcmlwdGlvbic6ICdBbiBvcGVuIGZpbmFuY2UgbmV0d29yayB0aGF0IGludGVncmF0ZXMgYSBzZXJpZXMgb2YgRGVGaSBwcm90b2NvbHMnLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2RlZmlzLXVuY2FjaGUucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2RlZmlzLm5ldHdvcmsnLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgX18pIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vYXBwcy5kZWZpcy5uZXR3b3JrL1wiO1xuICAgIH1cbiAgfSxcbiAgJ0RvbHBoaW5Td2FwJzoge1xuICAgICduYW1lJzogJ0RvbHBoaW5Td2FwJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnRG9scGhpblN3YXAnLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2RvbHBoaW5zd2FwLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9kb2xwaGluc3dhcC5pby9leGNoYW5nZScsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBfXykge1xuICAgICAgcmV0dXJuICdodHRwczovL2RvbHBoaW5zd2FwLmlvL2V4Y2hhbmdlJztcbiAgICB9XG4gIH0sXG4gICdQcm90b24nOiB7XG4gICAgJ25hbWUnOiAnUHJvdG9uU3dhcCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ1Byb3RvblN3YXAnLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL3Byb3RvbnN3YXAucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL3Byb3RvbnN3YXAuY29tJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIF9fKSB7XG4gICAgICByZXR1cm4gJ2h0dHBzOi8vcHJvdG9uc3dhcC5jb20nO1xuICAgIH1cbiAgfSxcbiAgJ0NvaW5nZWNrbyc6IHtcbiAgICAnbmFtZSc6ICdDb2luR2Vja28nLFxuICAgICdkZXNjcmlwdGlvbic6ICdDb2luR2Vja28nLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2NvaW5nZWNrby5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vY29pbmdlY2tvLmNvbScsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBfXykge1xuICAgICAgcmV0dXJuICdodHRwczovL2NvaW5nZWNrby5jb20nO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFNDQVRURVJfREVTS1RPUCA9ICdTY2F0dGVyU29ja2V0cyc7XG52YXIgU0NBVFRFUl9ERVNLVE9QX01BTlVBTCA9ICdTY2F0dGVyU29ja2V0c01hbnVhbCc7XG52YXIgU0NBVFRFUl9FWFRFTlNJT04gPSAnU2NhdHRlckV4dGVuc2lvbic7XG52YXIgTEVER0VSID0gJ2xlZGdlcic7XG52YXIgTEVER0VSX1VTQiA9ICdUcmFuc3BvcnRVMkYnO1xudmFyIExFREdFUl9CTEUgPSAnVHJhbnNwb3J0V2ViQkxFJztcbnZhciBMRURHRVJfV0VCVVNCID0gJ1RyYW5zcG9ydFdlYnVzYic7XG52YXIgTEVER0VSX1dFQkhJRCA9ICdUcmFuc3BvcnRXZWJISUQnO1xudmFyIExZTlggPSAnbHlueCc7XG52YXIgUFJPVE9OID0gJ3Byb3Rvbic7XG52YXIgUFJPVE9OX1dFQiA9ICdwcm90b253ZWInO1xudmFyIEFOQ0hPUiA9ICdhbmNob3InO1xudmFyIFNJTVBMRU9TID0gJ3NpbXBsZW9zJztcbnZhciBFT1NBVVRIID0gJ2Vvc2F1dGgnO1xudmFyIENMRU9TID0gJ2NsZW9zJztcbnZhciBFT1NDID0gJ2Vvc2MnO1xudmFyIENMSU8gPSAnY2xpbyc7XG52YXIgS0VZQ0FUID0gJ2tleWNhdCc7XG52YXIgVFJFWk9SID0gJ3RyZXpvcic7XG52YXIgU1FSTCA9ICdzcXJsJztcbnZhciBXT01CQVQgPSAnd29tYmF0JztcbnZhciBXQVhfQ0xPVURfV0FMTEVUID0gJ1dheENXJztcblxudmFyIGhpc3RvcnlUeXBlc0ZlYXR1cmVzID0ge1xuICBcIm5hdGl2ZVwiOiB7XG4gICAgbmFtZTogJ25hdGl2ZScsXG4gICAgYWN0aW9uRmlsdGVyOiBmYWxzZSxcbiAgICB0b2tlbkZpbHRlcjogZmFsc2UsXG4gICAgZGF0ZUZpbHRlcjogZmFsc2UsXG4gICAgY29udHJhY3RBY3Rpb25GaWx0ZXI6IGZhbHNlLFxuICAgIHRvdGFsOiAwXG4gIH0sXG4gIGRmdXNlOiB7XG4gICAgbmFtZTogJ2RmdXNlJyxcbiAgICBhY3Rpb25GaWx0ZXI6IHRydWUsXG4gICAgdG9rZW5GaWx0ZXI6IHRydWUsXG4gICAgZGF0ZUZpbHRlcjogdHJ1ZSxcbiAgICBjb250cmFjdEFjdGlvbkZpbHRlcjogdHJ1ZSxcbiAgICB0b3RhbDogNFxuICB9LFxuICBoeXBlcmlvbjoge1xuICAgIG5hbWU6ICdoeXBlcmlvbicsXG4gICAgYWN0aW9uRmlsdGVyOiB0cnVlLFxuICAgIHRva2VuRmlsdGVyOiB0cnVlLFxuICAgIGRhdGVGaWx0ZXI6IHRydWUsXG4gICAgY29udHJhY3RBY3Rpb25GaWx0ZXI6IHRydWUsXG4gICAgdG90YWw6IDNcbiAgfVxufTtcblxudmFyIF9jaGFpbkluZm87XG5cbnZhciBjaGFpbkluZm8gPSAoX2NoYWluSW5mbyA9IHt9LCBfY2hhaW5JbmZvWydwcm90b24tdGVzdCddID0ge1xuICBrZXk6ICdwcm90b24tdGVzdCcsXG4gIHRleHQ6ICdQcm90b24gVGVzdG5ldCcsXG4gIHZhbHVlOiAnaHR0cHM6Ly90ZXN0bmV0LnByb3RvbnNjYW4uaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL3Byb3Rvbi5wbmcnLFxuICB0ZXN0bmV0OiB0cnVlXG59LCBfY2hhaW5JbmZvLmxvY2FsID0ge1xuICBrZXk6ICdsb2NhbCcsXG4gIHRleHQ6ICdMb2NhbCBUZXN0bmV0JyxcbiAgdmFsdWU6ICdodHRwczovL2xvY2FsLmJsb2tzLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy9sb2NhbC5wbmcnLFxuICB0ZXN0bmV0OiB0cnVlXG59LCBfY2hhaW5JbmZvWyd3YXgtdGVzdCddID0ge1xuICBrZXk6ICd3YXgtdGVzdCcsXG4gIHRleHQ6ICdXQVggVGVzdG5ldCcsXG4gIHZhbHVlOiAnaHR0cHM6Ly93YXgtdGVzdC5ibG9rcy5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMvd2F4LnBuZycsXG4gIHRlc3RuZXQ6IHRydWVcbn0sIF9jaGFpbkluZm9bJ2Zpby10ZXN0J10gPSB7XG4gIGtleTogJ2Zpby10ZXN0JyxcbiAgdGV4dDogJ0ZJTyBUZXN0bmV0JyxcbiAgdmFsdWU6ICdodHRwczovL2Zpby10ZXN0LmJsb2tzLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy9maW8ucG5nJyxcbiAgdGVzdG5ldDogdHJ1ZVxufSwgX2NoYWluSW5mby5qdW5nbGUzID0ge1xuICBrZXk6ICdqdW5nbGUzJyxcbiAgdGV4dDogJ0p1bmdsZTMgVGVzdG5ldCcsXG4gIHZhbHVlOiAnaHR0cHM6Ly9qdW5nbGUzLmJsb2tzLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy9qdW5nbGUucG5nJyxcbiAgdGVzdG5ldDogdHJ1ZVxufSwgX2NoYWluSW5mby5reWxpbiA9IHtcbiAga2V5OiAna3lsaW4nLFxuICB0ZXh0OiAnS3lsaW4gVGVzdG5ldCcsXG4gIHZhbHVlOiAnaHR0cHM6Ly9reWxpbi5ibG9rcy5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMva3lsaW4ucG5nJyxcbiAgdGVzdG5ldDogdHJ1ZVxufSwgX2NoYWluSW5mby5wcm90b24gPSB7XG4gIGtleTogJ3Byb3RvbicsXG4gIHRleHQ6ICdQcm90b24nLFxuICB2YWx1ZTogJ2h0dHBzOi8vcHJvdG9uc2Nhbi5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMvcHJvdG9uLnBuZydcbn0sIF9jaGFpbkluZm8uZW9zID0ge1xuICBrZXk6ICdlb3MnLFxuICB0ZXh0OiAnRU9TJyxcbiAgdmFsdWU6ICdodHRwczovL2Jsb2tzLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy9lb3MucG5nJ1xufSwgX2NoYWluSW5mby53YXggPSB7XG4gIGtleTogJ3dheCcsXG4gIHRleHQ6ICdXQVgnLFxuICB2YWx1ZTogJ2h0dHBzOi8vd2F4LmJsb2tzLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy93YXgucG5nJ1xufSwgX2NoYWluSW5mby5maW8gPSB7XG4gIGtleTogJ2ZpbycsXG4gIHRleHQ6ICdGSU8nLFxuICB2YWx1ZTogJ2h0dHBzOi8vZmlvLmJsb2tzLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy9maW8ucG5nJ1xufSwgX2NoYWluSW5mbyk7XG5cbnZhciBnZXRDb21tb25Db25zdGFudHMgPSBmdW5jdGlvbiBnZXRDb21tb25Db25zdGFudHMoY2hhaW4pIHtcbiAgcmV0dXJuIHtcbiAgICBNQVhfUlBDX1NZTkNfU0VDT05EU19CRUhJTkQ6IDIwLFxuICAgIElNQUdFX1BST1hZOiAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2ltYWdlLXByb3h5JyxcbiAgICBXUkFQX0NPTlRSQUNUOiAncHJvdG9uLndyYXAnLFxuICAgIEJMT0tTX0FQSTogJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pbycsXG4gICAgRVNSX1BST1RPQ09MOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyAncHJvdG9uJyA6ICdwcm90b24tZGV2JyxcbiAgICBNRVRBTF9QUk9UT05fRU5EUE9JTlQ6IGNoYWluID09PSAncHJvdG9uJyA/ICdodHRwczovL2FwaS5wcm90b25jaGFpbi5jb20nIDogJ2h0dHBzOi8vYXBpLWRldi5wcm90b25jaGFpbi5jb20nLFxuICAgIFNXQVBfVVJMOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyAnaHR0cHM6Ly9vdGMucHJvdG9uc3dhcC5jb20nIDogJ2h0dHBzOi8vb3RjLXRlc3QucHJvdG9uc3dhcC5jb20nLFxuICAgIFdSQVBfU0VSVkVSX1VSTDogY2hhaW4gPT09ICdwcm90b24nID8gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9wcm90b24td3JhcC1wdWJsaWMyJyA6ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vcHJvdG9uLXdyYXAtdGVzdG5ldC1wdWJsaWMyJ1xuICB9O1xufTtcblxudmFyIGdlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMgPSBmdW5jdGlvbiBnZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKGNoYWluSWQsIGFjdGlvbkVuZHBvaW50cykge1xuICByZXR1cm4gW3tcbiAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgIHBvcnQ6IDQ0MyxcbiAgICBwcm90b2NvbDogJ2h0dHBzJyxcbiAgICBob3N0OiBhY3Rpb25FbmRwb2ludHNbMF0uc3Vic3RyKDgpLFxuICAgIGh0dHBFbmRwb2ludDogYWN0aW9uRW5kcG9pbnRzWzBdLFxuICAgIGJsb2NrY2hhaW46ICdlb3MnXG4gIH1dO1xufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTID0gWydodHRwczovL2Vvcy5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9lb3MuZW9zY2FmZWJsb2NrLmNvbScsICdodHRwczovL2FwaS5tYWluLmFsb2hhZW9zLmNvbScsICdodHRwczovL2FwaS5lb3Nzd2VkZW4ub3JnJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMgPSBbJ2h0dHBzOi8vZW9zLmdyZXltYXNzLmNvbSddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMgPSBbJ2h0dHBzOi8vZW9zLmdyZXltYXNzLmNvbScsICdodHRwczovL2FwaS5lb3Nzd2VkZW4ub3JnJ107XG52YXIgQUxPSEFfUFJPWFlfVVJMID0gJ2h0dHBzOi8vd3d3LmFsb2hhZW9zLmNvbS92b3RlL3Byb3h5JztcbnZhciBBUElfVVJMID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pbyc7XG52YXIgQVRPTUlDQVNTRVRTX0FQSSA9ICdodHRwczovL2Vvcy5hcGkuYXRvbWljYXNzZXRzLmlvJztcbnZhciBCTE9LU19QUk9YWSA9ICdibG9rc2lvcHJveHknO1xudmFyIENIQUlOID0gJ2Vvcyc7XG52YXIgQ0hBSU5fSUQgPSAnYWNhMzc2ZjIwNmI4ZmMyNWE2ZWQ0NGRiZGM2NjU0N2MzNmM2YzMzZTNhMTE5ZmZiZWFlZjk0MzY0MmYwZTkwNic7XG52YXIgQ0hBSU5fU1RBUlRfREFURSA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnMjAxOC0wNi0wOCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OID0gNDtcbnZhciBDT1JFX1NZTUJPTCA9ICdFT1MnO1xudmFyIERJU1BMQVlfQ0hBSU4gPSAnRU9TJztcbnZhciBET01BSU5fVElUTEUgPSAnRU9TIEJsb2tzLmlvJztcbnZhciBISVNUT1JZX1RZUEVTID0gWyduYXRpdmUnLCAnaHlwZXJpb24nXTtcbnZhciBIWVBFUklPTl9VUkwgPSAnaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvJztcbnZhciBLRVlfUFJFRklYID0gJ0VPUyc7XG52YXIgTElHSFRfQVBJID0gJ2h0dHBzOi8vYXBpLmxpZ2h0Lnhlb3MubWUnO1xudmFyIE5GVFNfRU5BQkxFRCA9IHRydWU7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQsIEFDVElPTlNfRU5EUE9JTlRTKTtcbnZhciBSRVhfRU5BQkxFRCA9IHRydWU7XG52YXIgU0lNUExFQVNTRVRTX0FQSSA9ICdodHRwczovL2Vvcy5hcGkuc2ltcGxlYXNzZXRzLmlvJztcbnZhciBTVVBQT1JUU19GUkVFX0NQVSA9IHRydWU7XG52YXIgU1VQUE9SVFNfUkVOVEJXID0gdHJ1ZTtcbnZhciBWT1RJTkdfRU5BQkxFRCA9IHRydWU7XG52YXIgY29uc3RhbnRzID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMsXG4gIEFMT0hBX1BST1hZX1VSTDogQUxPSEFfUFJPWFlfVVJMLFxuICBBUElfVVJMOiBBUElfVVJMLFxuICBBVE9NSUNBU1NFVFNfQVBJOiBBVE9NSUNBU1NFVFNfQVBJLFxuICBCTE9LU19QUk9YWTogQkxPS1NfUFJPWFksXG4gIENIQUlOOiBDSEFJTixcbiAgQ0hBSU5fSUQ6IENIQUlOX0lELFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFLFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04sXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCxcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTLFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOLFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSxcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyxcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgsXG4gIExJR0hUX0FQSTogTElHSFRfQVBJLFxuICBORlRTX0VOQUJMRUQ6IE5GVFNfRU5BQkxFRCxcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMsXG4gIFJFWF9FTkFCTEVEOiBSRVhfRU5BQkxFRCxcbiAgU0lNUExFQVNTRVRTX0FQSTogU0lNUExFQVNTRVRTX0FQSSxcbiAgU1VQUE9SVFNfRlJFRV9DUFU6IFNVUFBPUlRTX0ZSRUVfQ1BVLFxuICBTVVBQT1JUU19SRU5UQlc6IFNVUFBPUlRTX1JFTlRCVyxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyxcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEXG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkMSA9IFsnaHR0cHM6Ly93YXguZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vd2F4LmVvc2NhZmVibG9jay5jb20nLCAnaHR0cHM6Ly9hcGkud2F4c3dlZGVuLm9yZycsICdodHRwczovL2NoYWluLndheC5pbycsICdodHRwczovL3dheC5lb3NyaW8uaW8nXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyQxID0gWydodHRwczovL3dheC5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9hcGkud2F4c3dlZGVuLm9yZycsICdodHRwczovL3dheC5lb3NyaW8uaW8nLCAnaHR0cHM6Ly9jaGFpbi53YXguaW8nXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDEgPSBbJ2h0dHBzOi8vd2F4LmdyZXltYXNzLmNvbScsICdodHRwczovL2FwaS53YXhzd2VkZW4ub3JnJywgJ2h0dHBzOi8vd2F4LmVvc3Jpby5pbycsICdodHRwczovL2NoYWluLndheC5pbyddO1xudmFyIEFMT0hBX1BST1hZX1VSTCQxID0gJ2h0dHBzOi8vd3d3LmFsb2hhZW9zLmNvbS92b3RlL3Byb3h5L3dheG1haW4nO1xudmFyIEFQSV9VUkwkMSA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vd2F4JztcbnZhciBBVE9NSUNBU1NFVFNfQVBJJDEgPSAnaHR0cHM6Ly93YXguYXBpLmF0b21pY2Fzc2V0cy5pbyc7XG52YXIgQkxPS1NfUFJPWFkkMSA9ICdibG9rc2lvcHJveHknO1xudmFyIENIQUlOJDEgPSAnd2F4JztcbnZhciBDSEFJTl9JRCQxID0gJzEwNjQ0ODdiM2NkMWE4OTdjZTAzYWU1YjZhODY1NjUxNzQ3ZTJlMTUyMDkwZjk5YzFkMTlkNDRlMDFhZWE1YTQnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkMSA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnMjAxOS0wNi0yNCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OJDEgPSA4O1xudmFyIENPUkVfU1lNQk9MJDEgPSAnV0FYJztcbnZhciBESVNQTEFZX0NIQUlOJDEgPSAnV0FYJztcbnZhciBET01BSU5fVElUTEUkMSA9ICdXQVggfCBCbG9rcy5pbyc7XG52YXIgSElTVE9SWV9UWVBFUyQxID0gWyduYXRpdmUnLCAnaHlwZXJpb24nXTtcbnZhciBIWVBFUklPTl9VUkwkMSA9ICdodHRwczovL3dheC5lb3NyaW8uaW8nO1xudmFyIEtFWV9QUkVGSVgkMSA9ICdFT1MnO1xudmFyIExJR0hUX0FQSSQxID0gJ2h0dHBzOi8vbGlnaHRhcGkuZW9zYW1zdGVyZGFtLm5ldCc7XG52YXIgTkZUU19FTkFCTEVEJDEgPSB0cnVlO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyQxID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkMSwgQUNUSU9OU19FTkRQT0lOVFMkMSk7XG52YXIgU0lNUExFQVNTRVRTX0FQSSQxID0gJ2h0dHBzOi8vd2F4LmFwaS5zaW1wbGVhc3NldHMuaW8nO1xudmFyIFZPVElOR19FTkFCTEVEJDEgPSB0cnVlO1xudmFyIGNvbnN0YW50cyQxID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkMSxcbiAgQUxPSEFfUFJPWFlfVVJMOiBBTE9IQV9QUk9YWV9VUkwkMSxcbiAgQVBJX1VSTDogQVBJX1VSTCQxLFxuICBBVE9NSUNBU1NFVFNfQVBJOiBBVE9NSUNBU1NFVFNfQVBJJDEsXG4gIEJMT0tTX1BST1hZOiBCTE9LU19QUk9YWSQxLFxuICBDSEFJTjogQ0hBSU4kMSxcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJDEsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkMSxcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJDEsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCQxLFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkMSxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiQxLFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSQxLFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJDEsXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMJDEsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkMSxcbiAgTElHSFRfQVBJOiBMSUdIVF9BUEkkMSxcbiAgTkZUU19FTkFCTEVEOiBORlRTX0VOQUJMRUQkMSxcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkMSxcbiAgU0lNUExFQVNTRVRTX0FQSTogU0lNUExFQVNTRVRTX0FQSSQxLFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDEsXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRCQxXG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkMiA9IFsnaHR0cHM6Ly9wcm90b24uZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vcHJvdG9uLmNyeXB0b2xpb25zLmlvJywgJ2h0dHBzOi8vcHJvdG9uLmVvc3VzYS5uZXdzJywgXCJodHRwczovL2ZyYW5rZnVydC5wcm90b25kYXRhLm5ldFwiXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDIgPSBbJ2h0dHBzOi8vcHJvdG9uLmdyZXltYXNzLmNvbScsICdodHRwczovL3Byb3Rvbi5jcnlwdG9saW9ucy5pbyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJDIgPSBbJ2h0dHBzOi8vcHJvdG9uLmdyZXltYXNzLmNvbSddO1xudmFyIEFQSV9VUkwkMiA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vcHJvdG9uJztcbnZhciBBVE9NSUNBU1NFVFNfQVBJJDIgPSAnaHR0cHM6Ly9wcm90b24uYXBpLmF0b21pY2Fzc2V0cy5pbyc7XG52YXIgQ0hBSU4kMiA9ICdwcm90b24nO1xudmFyIENIQUlOX0lEJDIgPSAnMzg0ZGE4ODgxMTIwMjdmMDMyMTg1MGExNjlmNzM3YzMzZTUzYjM4OGFhZDQ4YjVhZGFjZTRiYWI5N2Y0MzdlMCc7XG52YXIgQ0hBSU5fU1RBUlRfREFURSQyID0gLyojX19QVVJFX18qL25ldyBEYXRlKCdBcHIgMjIsIDIwMjAnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiQyID0gNDtcbnZhciBDT1JFX1NZTUJPTCQyID0gJ1hQUic7XG52YXIgRElTUExBWV9DSEFJTiQyID0gJ1Byb3Rvbic7XG52YXIgRE9NQUlOX1RJVExFJDIgPSAnUHJvdG9uU2Nhbic7XG52YXIgSElTVE9SWV9UWVBFUyQyID0gWyduYXRpdmUnLCAnaHlwZXJpb24nXTtcbnZhciBIWVBFUklPTl9VUkwkMiA9ICdodHRwOi8vcHJvdG9uLnBpbmsuZ2cnO1xudmFyIEtFWV9QUkVGSVgkMiA9ICdFT1MnO1xudmFyIExJR0hUX0FQSSQyID0gJ2h0dHBzOi8vbGlnaHRhcGkuZW9zYW1zdGVyZGFtLm5ldCc7XG52YXIgTUFYX1ZPVEVTID0gNDtcbnZhciBORlRTX0VOQUJMRUQkMiA9IHRydWU7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJDIgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCQyLCBBQ1RJT05TX0VORFBPSU5UUyQyKTtcbnZhciBWT1RJTkdfRU5BQkxFRCQyID0gdHJ1ZTtcbnZhciBjb25zdGFudHMkMiA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJDIsXG4gIEFQSV9VUkw6IEFQSV9VUkwkMixcbiAgQVRPTUlDQVNTRVRTX0FQSTogQVRPTUlDQVNTRVRTX0FQSSQyLFxuICBDSEFJTjogQ0hBSU4kMixcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJDIsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkMixcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJDIsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCQyLFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkMixcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiQyLFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSQyLFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJDIsXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMJDIsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkMixcbiAgTElHSFRfQVBJOiBMSUdIVF9BUEkkMixcbiAgTUFYX1ZPVEVTOiBNQVhfVk9URVMsXG4gIE5GVFNfRU5BQkxFRDogTkZUU19FTkFCTEVEJDIsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJDIsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkMixcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEJDJcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyQzID0gWydodHRwczovL2Zpby5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9maW8uZW9zc3dlZGVuLm9yZycsICdodHRwczovL2Zpby5lb3N1c2EubmV3cyddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkMyA9IFsnaHR0cHM6Ly9maW8uZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vZmlvLmVvc3N3ZWRlbi5vcmcnLCAnaHR0cHM6Ly9maW8uZW9zdXNhLm5ld3MnXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyQzID0gWydodHRwczovL2Zpby5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9maW8uZW9zc3dlZGVuLm9yZycsICdodHRwczovL2Zpby5lb3N1c2EubmV3cyddO1xudmFyIEFMT0hBX1BST1hZX1VSTCQyID0gJ2h0dHBzOi8vd3d3LmFsb2hhZW9zLmNvbS92b3RlL3Byb3h5L2Zpb21haW4nO1xudmFyIEFQSV9VUkwkMyA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vZmlvJztcbnZhciBDSEFJTiQzID0gJ2Zpbyc7XG52YXIgQ0hBSU5fSUQkMyA9ICcyMWRjYWU0MmMwMTgyMjAwZTkzZjk1NGEwNzQwMTFmOTA0OGE3NjI0YzZmZTgxZDNjOTU0MWE2MTRhODhiZDFjJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJDMgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJ01hciAyNCwgMjAyMCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OJDMgPSA5O1xudmFyIENPUkVfU1lNQk9MJDMgPSAnRklPJztcbnZhciBESVNBQkxFX01FTU8gPSB0cnVlO1xudmFyIERJU1BMQVlfQ0hBSU4kMyA9ICdGSU8nO1xudmFyIERPTUFJTl9USVRMRSQzID0gJ0ZJTyBCbG9rcy5pbyc7XG52YXIgRklPX0ZFRVNfQUNDT1VOVCA9ICdmZWVzQGJsb2tzJztcbnZhciBISVNUT1JZX1RZUEVTJDMgPSBbJ25hdGl2ZScsICdoeXBlcmlvbiddO1xudmFyIEhZUEVSSU9OX1VSTCQzID0gJ2h0dHBzOi8vZmlvLmVvc3N3ZWRlbi5vcmcnO1xudmFyIEtFWV9QUkVGSVgkMyA9ICdGSU8nO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyQzID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkMywgQUNUSU9OU19FTkRQT0lOVFMkMyk7XG52YXIgVk9USU5HX0VOQUJMRUQkMyA9IHRydWU7XG52YXIgY29uc3RhbnRzJDMgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyQzLFxuICBBTE9IQV9QUk9YWV9VUkw6IEFMT0hBX1BST1hZX1VSTCQyLFxuICBBUElfVVJMOiBBUElfVVJMJDMsXG4gIENIQUlOOiBDSEFJTiQzLFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkMyxcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSQzLFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kMyxcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJDMsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyQzLFxuICBESVNBQkxFX01FTU86IERJU0FCTEVfTUVNTyxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiQzLFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSQzLFxuICBGSU9fRkVFU19BQ0NPVU5UOiBGSU9fRkVFU19BQ0NPVU5ULFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJDMsXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMJDMsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkMyxcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkMyxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQzLFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRUQkM1xufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJDQgPSBbXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyQ0ID0gW107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ0ID0gW107XG52YXIgQVBJX1VSTCQ0ID0gJyc7XG52YXIgQ0hBSU4kNCA9ICdsb2NhbCc7XG52YXIgQ0hBSU5fSUQkNCA9ICcnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkNCA9IHVuZGVmaW5lZDtcbnZhciBDT1JFX1BSRUNJU0lPTiQ0ID0gNDtcbnZhciBDT1JFX1NZTUJPTCQ0ID0gJ0VPUyc7XG52YXIgRElTUExBWV9DSEFJTiQ0ID0gJ0xvY2FsJztcbnZhciBET01BSU5fVElUTEUkNCA9ICdMb2NhbCBCbG9rcy5pbyc7XG52YXIgSElTVE9SWV9UWVBFUyQ0ID0gWyduYXRpdmUnXTtcbnZhciBLRVlfUFJFRklYJDQgPSAnRU9TJztcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkNCA9IFtdO1xudmFyIFZPVElOR19FTkFCTEVEJDQgPSB0cnVlO1xudmFyIGNvbnN0YW50cyQ0ID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkNCxcbiAgQVBJX1VSTDogQVBJX1VSTCQ0LFxuICBDSEFJTjogQ0hBSU4kNCxcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJDQsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkNCxcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJDQsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCQ0LFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkNCxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiQ0LFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSQ0LFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJDQsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkNCxcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkNCxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ0LFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRUQkNFxufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJDUgPSBbLy8gJ2h0dHBzOi8vanVuZ2xlYXBpLmVvc3N3ZWRlbi5vcmcnLFxuJ2h0dHBzOi8vYXBpLmp1bmdsZS5hbG9oYWVvcy5jb20nLCAnaHR0cHM6Ly9qdW5nbGUyLmNyeXB0b2xpb25zLmlvJywgJ2h0dHBzOi8vanVuZ2xlLmVvc3BoZXJlLmlvJywgJ2h0dHBzOi8vZW9zLWp1bmdsZS5lb3NibG9ja3NtaXRoLmlvJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkNSA9IFsnaHR0cHM6Ly9qdW5nbGUuZW9zc3dlZGVuLm9yZyddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkNSA9IFsnaHR0cHM6Ly9qdW5nbGUuZW9zc3dlZGVuLm9yZyddO1xudmFyIEFQSV9VUkwkNSA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vanVuZ2xlJztcbnZhciBCTE9LU19QUk9YWSQyID0gJ2Jsb2tzcGFydG5lcic7XG52YXIgQ0hBSU4kNSA9ICdqdW5nbGUnO1xudmFyIENIQUlOX0lEJDUgPSAnZTcwYWFhYjg5OTdlMWRmY2U1OGZiZmFjODBjYmJiOGZlY2VjN2I5OWNmOTgyYTk0NDQyNzNjYmM2NGM0MTQ3Myc7XG52YXIgQ0hBSU5fU1RBUlRfREFURSQ1ID0gLyojX19QVVJFX18qL25ldyBEYXRlKCdOb3YgMjMsIDIwMTgnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiQ1ID0gNDtcbnZhciBDT1JFX1NZTUJPTCQ1ID0gJ0VPUyc7XG52YXIgRElTUExBWV9DSEFJTiQ1ID0gJ0p1bmdsZSc7XG52YXIgRE9NQUlOX1RJVExFJDUgPSAnSnVuZ2xlIEJsb2tzLmlvJztcbnZhciBISVNUT1JZX1RZUEVTJDUgPSBbJ2h5cGVyaW9uJywgJ25hdGl2ZSddO1xudmFyIEhZUEVSSU9OX1VSTCQ0ID0gJ2h0dHBzOi8vanVuZ2xlMi5jcnlwdG9saW9ucy5pbyc7XG52YXIgS0VZX1BSRUZJWCQ1ID0gJ0VPUyc7XG52YXIgTElHSFRfQVBJJDMgPSAnaHR0cHM6Ly9saWdodGFwaS5lb3NnZW5ldmEuaW8nO1xudmFyIE5GVFNfRU5BQkxFRCQzID0gdHJ1ZTtcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkNSA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJDUsIEFDVElPTlNfRU5EUE9JTlRTJDUpO1xudmFyIFJFWF9FTkFCTEVEJDEgPSB0cnVlO1xudmFyIFZPVElOR19FTkFCTEVEJDUgPSB0cnVlO1xudmFyIGNvbnN0YW50cyQ1ID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkNSxcbiAgQVBJX1VSTDogQVBJX1VSTCQ1LFxuICBCTE9LU19QUk9YWTogQkxPS1NfUFJPWFkkMixcbiAgQ0hBSU46IENIQUlOJDUsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCQ1LFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJDUsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiQ1LFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkNSxcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJDUsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kNSxcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkNSxcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyQ1LFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCQ0LFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJDUsXG4gIExJR0hUX0FQSTogTElHSFRfQVBJJDMsXG4gIE5GVFNfRU5BQkxFRDogTkZUU19FTkFCTEVEJDMsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJDUsXG4gIFJFWF9FTkFCTEVEOiBSRVhfRU5BQkxFRCQxLFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDUsXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRCQ1XG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkNiA9IFsnaHR0cHM6Ly9qdW5nbGUzLmNyeXB0b2xpb25zLmlvJywgJ2h0dHBzOi8vYXBpLmp1bmdsZTMuYWxvaGFlb3MuY29tJywgJ2h0dHBzOi8vanVuZ2xlMy5lb3N1c2EubmV3cyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJDYgPSBbJ2h0dHBzOi8vanVuZ2xlMy5jcnlwdG9saW9ucy5pbycsICdodHRwczovL2p1bmdsZTMuZW9zdXNhLm5ld3MnXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDYgPSBbJ2h0dHBzOi8vanVuZ2xlMy5jcnlwdG9saW9ucy5pbycsICdodHRwczovL2p1bmdsZTMuZW9zdXNhLm5ld3MnXTtcbnZhciBBUElfVVJMJDYgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2p1bmdsZTMnO1xudmFyIENIQUlOJDYgPSAnanVuZ2xlMyc7XG52YXIgQ0hBSU5fSUQkNiA9ICcyYTAyYTAwNTNlNWE4Y2Y3M2E1NmJhMGZkYTExZTRkOTJlMDIzOGE0YTJhYTc0ZmNjZjQ2ZDVhOTEwNzQ2ODQwJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJDYgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJ0ZlYiAxOSwgMjAyMCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OJDYgPSA0O1xudmFyIENPUkVfU1lNQk9MJDYgPSAnRU9TJztcbnZhciBESVNQTEFZX0NIQUlOJDYgPSAnSnVuZ2xlIDMnO1xudmFyIERPTUFJTl9USVRMRSQ2ID0gJ0p1bmdsZSAzIEJsb2tzLmlvJztcbnZhciBISVNUT1JZX1RZUEVTJDYgPSBbJ2h5cGVyaW9uJ107XG52YXIgSFlQRVJJT05fVVJMJDUgPSAnaHR0cHM6Ly9qdW5nbGUzLmNyeXB0b2xpb25zLmlvJztcbnZhciBLRVlfUFJFRklYJDYgPSAnRU9TJztcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkNiA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJDYsIEFDVElPTlNfRU5EUE9JTlRTJDYpO1xudmFyIFJFWF9FTkFCTEVEJDIgPSB0cnVlO1xudmFyIFNVUFBPUlRTX1JFTlRCVyQxID0gdHJ1ZTtcbnZhciBWT1RJTkdfRU5BQkxFRCQ2ID0gdHJ1ZTtcbnZhciBjb25zdGFudHMkNiA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJDYsXG4gIEFQSV9VUkw6IEFQSV9VUkwkNixcbiAgQ0hBSU46IENIQUlOJDYsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCQ2LFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJDYsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiQ2LFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkNixcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJDYsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kNixcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkNixcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyQ2LFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCQ1LFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJDYsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJDYsXG4gIFJFWF9FTkFCTEVEOiBSRVhfRU5BQkxFRCQyLFxuICBTVVBQT1JUU19SRU5UQlc6IFNVUFBPUlRTX1JFTlRCVyQxLFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDYsXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRCQ2XG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkNyA9IFsnaHR0cHM6Ly9reWxpbi5lb3NuLmlvJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkNyA9IFsnaHR0cHM6Ly9reWxpbi5lb3NuLmlvJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ3ID0gWydodHRwczovL2t5bGluLmVvc24uaW8nXTtcbnZhciBBUElfVVJMJDcgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2t5bGluJztcbnZhciBCTE9LU19QUk9YWSQzID0gJ2Jsb2tzcGFydG5lcic7XG52YXIgQ0hBSU4kNyA9ICdreWxpbic7XG52YXIgQ0hBSU5fSUQkNyA9ICc1ZmZmMWRhZThkYzhlMmZjNGQ1YjIzYjJjNzY2NWM5N2Y5ZTlkOGVkZjJiNjQ4NWE4NmJhMzExYzI1NjM5MTkxJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJDcgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJ0p1bCAxMCwgMjAxOCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OJDcgPSA0O1xudmFyIENPUkVfU1lNQk9MJDcgPSAnRU9TJztcbnZhciBESVNQTEFZX0NIQUlOJDcgPSAnS3lsaW4nO1xudmFyIERPTUFJTl9USVRMRSQ3ID0gJ0t5bGluIEJsb2tzLmlvJztcbnZhciBISVNUT1JZX1RZUEVTJDcgPSBbJ2h5cGVyaW9uJywgJ25hdGl2ZSddO1xudmFyIEhZUEVSSU9OX1VSTCQ2ID0gJ2h0dHBzOi8va3lsaW4uZW9zdXNhLm5ld3MnO1xudmFyIEtFWV9QUkVGSVgkNyA9ICdFT1MnO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyQ3ID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkNywgQUNUSU9OU19FTkRQT0lOVFMkNyk7XG52YXIgVk9USU5HX0VOQUJMRUQkNyA9IHRydWU7XG52YXIgY29uc3RhbnRzJDcgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyQ3LFxuICBBUElfVVJMOiBBUElfVVJMJDcsXG4gIEJMT0tTX1BST1hZOiBCTE9LU19QUk9YWSQzLFxuICBDSEFJTjogQ0hBSU4kNyxcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJDcsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkNyxcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJDcsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCQ3LFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkNyxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiQ3LFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSQ3LFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJDcsXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMJDYsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkNyxcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkNyxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ3LFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRUQkN1xufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJDggPSBbJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9lb3MtdGVzdC1ub2RlJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkOCA9IFsnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2Vvcy10ZXN0LW5vZGUnXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDggPSBbJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9lb3MtdGVzdC1ub2RlJ107XG52YXIgQVBJX1VSTCQ4ID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9lb3MtdGVzdCc7XG52YXIgQ0hBSU4kOCA9ICdlb3MtdGVzdCc7XG52YXIgQ0hBSU5fSUQkOCA9ICcwZGIxM2FiOWIzMjFjMzdjMGJhODQ4MWNiNDY4MWMyNzg4YjYyMmMzYWJmZDFmMTJmMGU1MzUzZDQ0YmE2ZTcyJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJDggPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJzIwMjAtMDEtMTQnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiQ4ID0gNDtcbnZhciBDT1JFX1NZTUJPTCQ4ID0gJ1ROVCc7XG52YXIgRElTUExBWV9DSEFJTiQ4ID0gJ0VPU0lPIFRlc3QnO1xudmFyIERPTUFJTl9USVRMRSQ4ID0gJ0Jsb2tzLmlvJztcbnZhciBISVNUT1JZX1RZUEVTJDggPSBbJ25hdGl2ZSddO1xudmFyIEtFWV9QUkVGSVgkOCA9ICdFT1MnO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyQ4ID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkOCwgQUNUSU9OU19FTkRQT0lOVFMkOCk7XG52YXIgY29uc3RhbnRzJDggPSB7XG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyQ4LFxuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkOCxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ4LFxuICBBUElfVVJMOiBBUElfVVJMJDgsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJDgsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCQ4LFxuICBDSEFJTjogQ0hBSU4kOCxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiQ4LFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJDgsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCQ4LFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSQ4LFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJDgsXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkOCxcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJDhcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyQ5ID0gWydodHRwczovL3Byb3RvbnRlc3RuZXQuZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vcHJvdG9uLXRlc3RuZXQuZW9zY2FmZWJsb2NrLmNvbScsICdodHRwczovL3Rlc3RuZXQucHJvdG9uY2hhaW4uY29tJywgJ2h0dHBzOi8vdGVzdC5wcm90b24uZW9zdXNhLm5ld3MnXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDkgPSBbJ2h0dHBzOi8vcHJvdG9udGVzdG5ldC5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly90ZXN0bmV0LnByb3RvbmNoYWluLmNvbScsICdodHRwczovL3Rlc3QucHJvdG9uLmVvc3VzYS5uZXdzJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkOSA9IFsnaHR0cHM6Ly9wcm90b250ZXN0bmV0LmdyZXltYXNzLmNvbScsICdodHRwczovL3Rlc3RuZXQucHJvdG9uY2hhaW4uY29tJywgJ2h0dHBzOi8vdGVzdC5wcm90b24uZW9zdXNhLm5ld3MnXTtcbnZhciBBUElfVVJMJDkgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL3Byb3Rvbi10ZXN0JztcbnZhciBBVE9NSUNBU1NFVFNfQVBJJDMgPSAnaHR0cHM6Ly90ZXN0LnByb3Rvbi5hcGkuYXRvbWljYXNzZXRzLmlvJztcbnZhciBDSEFJTiQ5ID0gJ3Byb3Rvbi10ZXN0JztcbnZhciBDSEFJTl9JRCQ5ID0gJzcxZWU4M2JjZjUyMTQyZDYxMDE5ZDk1ZjljYzU0MjdiYTZhMGQ3ZmY4YWNjZDllMjA4OGFlMmFiZWFmM2QzZGQnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkOSA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnQXByaWwgMywgMjAyMCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OJDkgPSA0O1xudmFyIENPUkVfU1lNQk9MJDkgPSAnWFBSJztcbnZhciBESVNQTEFZX0NIQUlOJDkgPSAnUHJvdG9uLVQnO1xudmFyIERPTUFJTl9USVRMRSQ5ID0gJ1Byb3RvbiBUZXN0bmV0JztcbnZhciBISVNUT1JZX1RZUEVTJDkgPSBbJ2h5cGVyaW9uJywgJ25hdGl2ZSddO1xudmFyIEhZUEVSSU9OX1VSTCQ3ID0gJ2h0dHBzOi8vdGVzdG5ldC5wcm90b24ucGluay5nZyc7XG52YXIgS0VZX1BSRUZJWCQ5ID0gJ0VPUyc7XG52YXIgTUFYX1ZPVEVTJDEgPSA0O1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyQ5ID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkOSwgQUNUSU9OU19FTkRQT0lOVFMkOSk7XG52YXIgVk9USU5HX0VOQUJMRUQkOCA9IHRydWU7XG52YXIgY29uc3RhbnRzJDkgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyQ5LFxuICBBUElfVVJMOiBBUElfVVJMJDksXG4gIEFUT01JQ0FTU0VUU19BUEk6IEFUT01JQ0FTU0VUU19BUEkkMyxcbiAgQ0hBSU46IENIQUlOJDksXG4gIENIQUlOX0lEOiBDSEFJTl9JRCQ5LFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJDksXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiQ5LFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkOSxcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJDksXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kOSxcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkOSxcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyQ5LFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCQ3LFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJDksXG4gIE1BWF9WT1RFUzogTUFYX1ZPVEVTJDEsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJDksXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkOSxcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEJDhcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyRhID0gWydodHRwczovL3Rlc3RuZXQud2F4LmVvc2RldHJvaXQuaW8nLCAnaHR0cHM6Ly90ZXN0bmV0LndheC5waW5rLmdnJywgJ2h0dHBzOi8vdGVzdG5ldC53YXhzd2VkZW4ub3JnJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyRhID0gWydodHRwczovL3Rlc3RuZXQud2F4LmVvc2RldHJvaXQuaW8nLCAnaHR0cHM6Ly90ZXN0bmV0LndheC5waW5rLmdnJywgJ2h0dHBzOi8vdGVzdG5ldC53YXhzd2VkZW4ub3JnJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkYSA9IFsnaHR0cHM6Ly90ZXN0bmV0LndheC5lb3NkZXRyb2l0LmlvJywgJ2h0dHBzOi8vdGVzdG5ldC53YXgucGluay5nZycsICdodHRwczovL3Rlc3RuZXQud2F4c3dlZGVuLm9yZyddO1xudmFyIEFQSV9VUkwkYSA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vd2F4LXRlc3QnO1xudmFyIEFUT01JQ0FTU0VUU19BUEkkNCA9ICdodHRwczovL3Rlc3Qud2F4LmFwaS5hdG9taWNhc3NldHMuaW8nO1xudmFyIENIQUlOJGEgPSAnd2F4LXRlc3QnO1xudmFyIENIQUlOX0lEJGEgPSAnZjE2YjE4MzNjNzQ3YzQzNjgyZjQzODZmY2E5Y2JiMzI3OTI5MzM0YTc2Mjc1NWViZWMxN2Y2ZjIzYzliOGExMic7XG52YXIgQ0hBSU5fU1RBUlRfREFURSRhID0gLyojX19QVVJFX18qL25ldyBEYXRlKCdEZWMgNSwgMjAxOScpO1xudmFyIENPUkVfUFJFQ0lTSU9OJGEgPSA4O1xudmFyIENPUkVfU1lNQk9MJGEgPSAnV0FYJztcbnZhciBESVNQTEFZX0NIQUlOJGEgPSAnV0FYLVQnO1xudmFyIERPTUFJTl9USVRMRSRhID0gJ1dBWCBUZXN0bmV0IEJsb2tzLmlvJztcbnZhciBISVNUT1JZX1RZUEVTJGEgPSBbJ25hdGl2ZScsICdoeXBlcmlvbiddO1xudmFyIEhZUEVSSU9OX1VSTCQ4ID0gJ2h0dHBzOi8vdGVzdG5ldC53YXhzd2VkZW4ub3JnJztcbnZhciBLRVlfUFJFRklYJGEgPSAnRU9TJztcbnZhciBMSUdIVF9BUEkkNCA9ICdodHRwczovL3Rlc3RuZXQtbGlnaHRhcGkuZW9zYW1zLnhlb3MubWUnO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyRhID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkYSwgQUNUSU9OU19FTkRQT0lOVFMkYSk7XG52YXIgY29uc3RhbnRzJGEgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyRhLFxuICBBUElfVVJMOiBBUElfVVJMJGEsXG4gIEFUT01JQ0FTU0VUU19BUEk6IEFUT01JQ0FTU0VUU19BUEkkNCxcbiAgQ0hBSU46IENIQUlOJGEsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCRhLFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJGEsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiRhLFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkYSxcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJGEsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kYSxcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkYSxcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyRhLFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCQ4LFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJGEsXG4gIExJR0hUX0FQSTogTElHSFRfQVBJJDQsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJGEsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkYVxufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJGIgPSBbJ2h0dHBzOi8vZmlvdGVzdG5ldC5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly90ZXN0LmZpby5lb3N1c2EubmV3cyddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkYiA9IFsnaHR0cHM6Ly9maW90ZXN0bmV0LmdyZXltYXNzLmNvbScsICdodHRwczovL3Rlc3QuZmlvLmVvc3VzYS5uZXdzJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkYiA9IFsnaHR0cHM6Ly9maW90ZXN0bmV0LmdyZXltYXNzLmNvbScsICdodHRwczovL3Rlc3QuZmlvLmVvc3VzYS5uZXdzJ107XG52YXIgQVBJX1VSTCRiID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9maW8tdGVzdCc7XG52YXIgQ0hBSU4kYiA9ICdmaW8tdGVzdCc7XG52YXIgQ0hBSU5fSUQkYiA9ICdiMjA5MDEzODBhZjQ0ZWY1OWM1OTE4NDM5YTFmOWE0MWQ4MzY2OTAyMDMxOWE4MDU3NGI4MDRhNWY5NWNiZDdlJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJGIgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJ01hciAxMCwgMjAyMCcpO1xudmFyIENPUkVfUFJFQ0lTSU9OJGIgPSA5O1xudmFyIENPUkVfU1lNQk9MJGIgPSAnRklPJztcbnZhciBESVNBQkxFX01FTU8kMSA9IHRydWU7XG52YXIgRElTUExBWV9DSEFJTiRiID0gJ0ZJTyBUZXN0JztcbnZhciBET01BSU5fVElUTEUkYiA9ICdGSU8gVGVzdCBCbG9rcy5pbyc7XG52YXIgSElTVE9SWV9UWVBFUyRiID0gWyduYXRpdmUnLCAnaHlwZXJpb24nXTtcbnZhciBIWVBFUklPTl9VUkwkOSA9ICdodHRwczovL3Rlc3QuZmlvLmVvc3VzYS5uZXdzJztcbnZhciBLRVlfUFJFRklYJGIgPSAnRklPJztcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkYiA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJGIsIEFDVElPTlNfRU5EUE9JTlRTJGIpO1xudmFyIFZPVElOR19FTkFCTEVEJDkgPSB0cnVlO1xudmFyIGNvbnN0YW50cyRiID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkYixcbiAgQVBJX1VSTDogQVBJX1VSTCRiLFxuICBDSEFJTjogQ0hBSU4kYixcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJGIsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkYixcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJGIsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCRiLFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkYixcbiAgRElTQUJMRV9NRU1POiBESVNBQkxFX01FTU8kMSxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTiRiLFxuICBET01BSU5fVElUTEU6IERPTUFJTl9USVRMRSRiLFxuICBISVNUT1JZX1RZUEVTOiBISVNUT1JZX1RZUEVTJGIsXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMJDksXG4gIEtFWV9QUkVGSVg6IEtFWV9QUkVGSVgkYixcbiAgUFJPVklERVJfRU5EUE9JTlRTOiBQUk9WSURFUl9FTkRQT0lOVFMkYixcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyRiLFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRUQkOVxufTtcblxudmFyIF9jaGFpblRvTmV0d29ya0NvbnN0YTtcblxudmFyIGNoYWluVG9OZXR3b3JrQ29uc3RhbnRzTWFwID0gKF9jaGFpblRvTmV0d29ya0NvbnN0YSA9IHtcbiAgZW9zOiBjb25zdGFudHMsXG4gIHdheDogY29uc3RhbnRzJDEsXG4gIHByb3RvbjogY29uc3RhbnRzJDIsXG4gIGxvY2FsOiBjb25zdGFudHMkNCxcbiAganVuZ2xlOiBjb25zdGFudHMkNSxcbiAganVuZ2xlMzogY29uc3RhbnRzJDYsXG4gIGt5bGluOiBjb25zdGFudHMkNyxcbiAgZmlvOiBjb25zdGFudHMkM1xufSwgX2NoYWluVG9OZXR3b3JrQ29uc3RhWydlb3MtdGVzdCddID0gY29uc3RhbnRzJDgsIF9jaGFpblRvTmV0d29ya0NvbnN0YVsncHJvdG9uLXRlc3QnXSA9IGNvbnN0YW50cyQ5LCBfY2hhaW5Ub05ldHdvcmtDb25zdGFbJ3dheC10ZXN0J10gPSBjb25zdGFudHMkYSwgX2NoYWluVG9OZXR3b3JrQ29uc3RhWydmaW8tdGVzdCddID0gY29uc3RhbnRzJGIsIF9jaGFpblRvTmV0d29ya0NvbnN0YSk7XG52YXIgQ29uc3RhbnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uc3RhbnRzKCkge1xuICAgIGlmICghIUNvbnN0YW50cy5pbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIENvbnN0YW50cy5pbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ29uc3RhbnRzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIGluaXRpYWxpemUoY2hhaW4pIHtcbiAgICBpZiAoIWNoYWluIHx8ICFjaGFpblRvTmV0d29ya0NvbnN0YW50c01hcFtjaGFpbl0pIHtcbiAgICAgIGNoYWluID0gREVGQVVMVF9DSEFJTjtcbiAgICB9XG5cbiAgICB0aGlzLnNldE5ldHdvcmsoY2hhaW4pO1xuICAgIHRoaXMuc2V0Q29tbW9uKGNoYWluKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0TmV0d29yayA9IGZ1bmN0aW9uIHNldE5ldHdvcmsoY2hhaW4pIHtcbiAgICAvLyBjb25zdCBuZXR3b3JrQ29uc3RhbnRzID0gYXdhaXQgaW1wb3J0KGAnLi9uZXR3b3Jrcy8ke2NoYWlufWApXG4gICAgdmFyIG5ldHdvcmtDb25zdGFudHMgPSBjaGFpblRvTmV0d29ya0NvbnN0YW50c01hcFtjaGFpbl07XG4gICAgdGhpcy5zZXRDb25zdGFudHMobmV0d29ya0NvbnN0YW50cyk7XG4gICAgdGhpcy5zZXRDb250cmFjdChjaGFpbiwgbmV0d29ya0NvbnN0YW50cy5TWVNURU1fRE9NQUlOKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0Q29tbW9uID0gZnVuY3Rpb24gc2V0Q29tbW9uKGNoYWluKSB7XG4gICAgdmFyIGNvbW1vbkNvbnN0YW50cyA9IGdldENvbW1vbkNvbnN0YW50cyhjaGFpbik7XG4gICAgdGhpcy5zZXRDb25zdGFudHMoY29tbW9uQ29uc3RhbnRzKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0Q29udHJhY3QgPSBmdW5jdGlvbiBzZXRDb250cmFjdChjaGFpbiwgc3lzdGVtRG9tYWluKSB7XG4gICAgaWYgKHN5c3RlbURvbWFpbiA9PT0gdm9pZCAwKSB7XG4gICAgICBzeXN0ZW1Eb21haW4gPSBERUZBVUxUX1NZU1RFTV9ET01BSU47XG4gICAgfVxuXG4gICAgdmFyIGNvbnRyYWN0Q29uc3RhbnRzID0gZ2V0Q29udHJhY3RDb25zdGFudHMoY2hhaW4sIHN5c3RlbURvbWFpbik7XG4gICAgdGhpcy5zZXRDb25zdGFudHMoY29udHJhY3RDb25zdGFudHMpO1xuICB9O1xuXG4gIF9wcm90by5zZXRDb25zdGFudHMgPSBmdW5jdGlvbiBzZXRDb25zdGFudHMobmV3Q29uc3RhbnRzKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhuZXdDb25zdGFudHMpOyBfaSA8IF9PYmplY3QkZW50cmllcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfT2JqZWN0JGVudHJpZXMkX2kgPSBfT2JqZWN0JGVudHJpZXNbX2ldLFxuICAgICAgICAgIGtleSA9IF9PYmplY3QkZW50cmllcyRfaVswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9PYmplY3QkZW50cmllcyRfaVsxXTtcbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ29uc3RhbnRzO1xufSgpO1xudmFyIGNvbnN0YW50cyRjID0gLyojX19QVVJFX18qL25ldyBDb25zdGFudHMoKTtcblxuZXhwb3J0IHsgQU5DSE9SLCBDTEVPUywgQ0xJTywgQ29uc3RhbnRzLCBERUZBVUxUX0NIQUlOLCBERUZBVUxUX1NZTUJPTCwgREVGQVVMVF9TWVNURU1fRE9NQUlOLCBFT1NBVVRILCBFT1NDLCBLRVlDQVQsIExFREdFUiwgTEVER0VSX0JMRSwgTEVER0VSX1VTQiwgTEVER0VSX1dFQkhJRCwgTEVER0VSX1dFQlVTQiwgTFlOWCwgUFJPVE9OLCBQUk9UT05fV0VCLCBTQ0FUVEVSX0RFU0tUT1AsIFNDQVRURVJfREVTS1RPUF9NQU5VQUwsIFNDQVRURVJfRVhURU5TSU9OLCBTSU1QTEVPUywgU1FSTCwgVFJFWk9SLCBXQVhfQ0xPVURfV0FMTEVULCBXT01CQVQsIGNoYWluSW5mbywgY2hhaW5Ub05ldHdvcmtDb25zdGFudHNNYXAsIGNvbnN0YW50cyRjIGFzIGNvbnN0YW50cywgZGFwcHMsIGV4Y2hhbmdlcywgZ2V0Q29udHJhY3RDb25zdGFudHMsIGhpc3RvcnlUeXBlc0ZlYXR1cmVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuZXNtLmpzLm1hcFxuIiwiXG4ndXNlIHN0cmljdCdcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL251bWJlcnMuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9udW1iZXJzLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgYmlnbnVtYmVyX2pzID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG52YXIgbnVtYnJvID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BqYWZyaS9udW1icm8nKSk7XG52YXIgZGF5anMgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZGF5anMnKSk7XG52YXIgcmVsYXRpdmVUaW1lUGx1Z2luID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2RheWpzL3BsdWdpbi9yZWxhdGl2ZVRpbWUnKSk7XG52YXIgdXRjUGx1Z2luID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2RheWpzL3BsdWdpbi91dGMnKSk7XG52YXIgdGltZXpvbmVQbHVnaW4gPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZGF5anMvcGx1Z2luL3RpbWV6b25lJykpO1xudmFyIGFkdmFuY2VkRm9ybWF0UGx1Z2luID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2RheWpzL3BsdWdpbi9hZHZhbmNlZEZvcm1hdCcpKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIGFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChpc1RydWUsIGVycm9yKSB7XG4gIGlmIChpc1RydWUpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuKGZ1bmN0aW9uIChNYXRocykge1xuICB2YXIgT3BlcmF0aW9ucztcblxuICAoZnVuY3Rpb24gKE9wZXJhdGlvbnMpIHtcbiAgICBPcGVyYXRpb25zW1wiUExVU1wiXSA9IFwicGx1c1wiO1xuICAgIE9wZXJhdGlvbnNbXCJNVUxUSVBMWVwiXSA9IFwibXVsdGlwbGllZEJ5XCI7XG4gICAgT3BlcmF0aW9uc1tcIkRJVklERVwiXSA9IFwiZGl2aWRlZEJ5XCI7XG4gICAgT3BlcmF0aW9uc1tcIk1JTlVTXCJdID0gXCJtaW51c1wiO1xuICB9KShPcGVyYXRpb25zID0gTWF0aHMuT3BlcmF0aW9ucyB8fCAoTWF0aHMuT3BlcmF0aW9ucyA9IHt9KSk7XG59KShleHBvcnRzLk1hdGhzIHx8IChleHBvcnRzLk1hdGhzID0ge30pKTtcblxudmFyIEFzc2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXNzZXQoYXNzZXQpIHtcbiAgICB0aGlzLnN5bWJvbCA9IG5ldyBTeW1ib2wkMSh7XG4gICAgICBjb2RlOiBhc3NldC5jb2RlLFxuICAgICAgcHJlY2lzaW9uOiBhc3NldC5wcmVjaXNpb25cbiAgICB9KTtcbiAgICB0aGlzLmFtb3VudCA9IG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKGFzc2V0LmFtb3VudCk7XG4gIH1cblxuICBBc3NldC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhhc3NldCkge1xuICAgIHZhciBfYXNzZXQkc3BsaXQgPSBhc3NldC5zcGxpdCgnICcpLFxuICAgICAgICBhbW91bnQgPSBfYXNzZXQkc3BsaXRbMF0sXG4gICAgICAgIGNvZGUgPSBfYXNzZXQkc3BsaXRbMV07XG5cbiAgICB2YXIgcHJlY2lzaW9uID0gKGFtb3VudC5zcGxpdCgnLicpWzFdIHx8IFtdKS5sZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBBc3NldCh7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgICBhbW91bnQ6IG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKGFtb3VudClcbiAgICB9KTtcbiAgfTtcblxuICBBc3NldC5mcm9tU3ltYm9sID0gZnVuY3Rpb24gZnJvbVN5bWJvbChfcmVmKSB7XG4gICAgdmFyIHN5bWJvbCA9IF9yZWYuc3ltYm9sLFxuICAgICAgICBhbW91bnQgPSBfcmVmLmFtb3VudDtcblxuICAgIGlmICghKHN5bWJvbCBpbnN0YW5jZW9mIFN5bWJvbCQxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN5bWJvbCcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXQoe1xuICAgICAgY29kZTogc3ltYm9sLmNvZGUsXG4gICAgICBwcmVjaXNpb246IHN5bWJvbC5wcmVjaXNpb24sXG4gICAgICBhbW91bnQ6IGFtb3VudFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBBc3NldC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzRXF1YWxUbyA9IGZ1bmN0aW9uIGlzRXF1YWxUbyhhc3NldCkge1xuICAgIHJldHVybiB0aGlzLmlzTG9vc2VseUVxdWFsVG8oYXNzZXQpICYmIHRoaXMuYW1vdW50ID09IGFzc2V0LmFtb3VudDtcbiAgfTtcblxuICBfcHJvdG8uaXNMb29zZWx5RXF1YWxUbyA9IGZ1bmN0aW9uIGlzTG9vc2VseUVxdWFsVG8oYXNzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5zeW1ib2wuaXNFcXVhbFRvKGFzc2V0LnN5bWJvbCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKHRoaXMuYW1vdW50KS50b0ZpeGVkKHRoaXMuc3ltYm9sLnByZWNpc2lvbiwgYmlnbnVtYmVyX2pzLkJpZ051bWJlci5ST1VORF9ET1dOKSArIFwiIFwiICsgdGhpcy5zeW1ib2wuY29kZTtcbiAgfTtcblxuICBfcHJvdG8ubW9kaWZ5QW1vdW50ID0gZnVuY3Rpb24gbW9kaWZ5QW1vdW50KHgsIG1ldGhvZCkge1xuICAgIHZhciBhbW91bnQgPSBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcigwKTtcblxuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiB8fCBiaWdudW1iZXJfanMuQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHgpKSB7XG4gICAgICBhbW91bnQgPSBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcih4KTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEFzc2V0KSB7XG4gICAgICBhc3NlcnQodGhpcy5pc0xvb3NlbHlFcXVhbFRvKHgpLCBcImludmFsaWQgc3ltYm9sXCIpO1xuICAgICAgYW1vdW50ID0gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoeC5hbW91bnQpO1xuICAgIH1cblxuICAgIHJldHVybiBBc3NldC5mcm9tU3ltYm9sKHtcbiAgICAgIHN5bWJvbDogdGhpcy5zeW1ib2wsXG4gICAgICBhbW91bnQ6IHRoaXMuYW1vdW50W21ldGhvZF0oYW1vdW50KVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5wbHVzID0gZnVuY3Rpb24gcGx1cyh4KSB7XG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5QW1vdW50KHgsIGV4cG9ydHMuTWF0aHMuT3BlcmF0aW9ucy5QTFVTKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXMgPSBmdW5jdGlvbiBtaW51cyh4KSB7XG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5QW1vdW50KHgsIGV4cG9ydHMuTWF0aHMuT3BlcmF0aW9ucy5NSU5VUyk7XG4gIH07XG5cbiAgX3Byb3RvLm11bHRpcGxpZWRCeSA9IGZ1bmN0aW9uIG11bHRpcGxpZWRCeSh4KSB7XG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5QW1vdW50KHgsIGV4cG9ydHMuTWF0aHMuT3BlcmF0aW9ucy5NVUxUSVBMWSk7XG4gIH07XG5cbiAgX3Byb3RvLmRpdmlkZWRCeSA9IGZ1bmN0aW9uIGRpdmlkZWRCeSh4KSB7XG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5QW1vdW50KHgsIGV4cG9ydHMuTWF0aHMuT3BlcmF0aW9ucy5ESVZJREUpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhBc3NldCwgW3tcbiAgICBrZXk6IFwiaW50ZWdlckFtb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCB0aGlzLnN5bWJvbC5wcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIHRoaXMuYW1vdW50Lm11bHRpcGxpZWRCeShmYWN0b3IpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBc3NldDtcbn0oKTtcbnZhciBFeHRlbmRlZEFzc2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXh0ZW5kZWRBc3NldChleHRlbmRlZEFzc2V0KSB7XG4gICAgaWYgKCEoZXh0ZW5kZWRBc3NldC5xdWFudGl0eSBpbnN0YW5jZW9mIEFzc2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHF1YW50aXR5Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5xdWFudGl0eSA9IGV4dGVuZGVkQXNzZXQucXVhbnRpdHk7XG4gICAgdGhpcy5jb250cmFjdCA9IGV4dGVuZGVkQXNzZXQuY29udHJhY3Q7XG4gIH1cblxuICBFeHRlbmRlZEFzc2V0LmZyb21SYXcgPSBmdW5jdGlvbiBmcm9tUmF3KF9yZWYyKSB7XG4gICAgdmFyIHF1YW50aXR5ID0gX3JlZjIucXVhbnRpdHksXG4gICAgICAgIGNvbnRyYWN0ID0gX3JlZjIuY29udHJhY3Q7XG4gICAgcmV0dXJuIG5ldyBFeHRlbmRlZEFzc2V0KHtcbiAgICAgIHF1YW50aXR5OiBBc3NldC5mcm9tU3RyaW5nKHF1YW50aXR5KSxcbiAgICAgIGNvbnRyYWN0OiBjb250cmFjdFxuICAgIH0pO1xuICB9O1xuXG4gIEV4dGVuZGVkQXNzZXQuZnJvbUV4dGVuZGVkU3ltYm9sID0gZnVuY3Rpb24gZnJvbUV4dGVuZGVkU3ltYm9sKHN5bWJvbCwgYW1vdW50KSB7XG4gICAgaWYgKCEoc3ltYm9sIGluc3RhbmNlb2YgRXh0ZW5kZWRTeW1ib2wpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXh0ZW5kZWQgc3ltYm9sJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFeHRlbmRlZEFzc2V0KHtcbiAgICAgIHF1YW50aXR5OiBBc3NldC5mcm9tU3ltYm9sKHtcbiAgICAgICAgc3ltYm9sOiBzeW1ib2wuc3ltLFxuICAgICAgICBhbW91bnQ6IGFtb3VudFxuICAgICAgfSksXG4gICAgICBjb250cmFjdDogc3ltYm9sLmNvbnRyYWN0XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIF9wcm90bzIgPSBFeHRlbmRlZEFzc2V0LnByb3RvdHlwZTtcblxuICBfcHJvdG8yLmlzRXF1YWxUbyA9IGZ1bmN0aW9uIGlzRXF1YWxUbyhleHRlbmRlZEFzc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3QgPT09IGV4dGVuZGVkQXNzZXQuY29udHJhY3QgJiYgdGhpcy5xdWFudGl0eS5pc0VxdWFsVG8oZXh0ZW5kZWRBc3NldC5xdWFudGl0eSk7XG4gIH07XG5cbiAgX3Byb3RvMi5pc0xvb3NlbHlFcXVhbFRvID0gZnVuY3Rpb24gaXNMb29zZWx5RXF1YWxUbyhleHRlbmRlZEFzc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3QgPT09IGV4dGVuZGVkQXNzZXQuY29udHJhY3QgJiYgdGhpcy5xdWFudGl0eS5pc0xvb3NlbHlFcXVhbFRvKGV4dGVuZGVkQXNzZXQucXVhbnRpdHkpO1xuICB9O1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5xdWFudGl0eS50b1N0cmluZygpICsgXCJAXCIgKyB0aGlzLmNvbnRyYWN0O1xuICB9O1xuXG4gIF9wcm90bzIudG9FeHRlbmRlZFN5bWJvbCA9IGZ1bmN0aW9uIHRvRXh0ZW5kZWRTeW1ib2woKSB7XG4gICAgcmV0dXJuIG5ldyBFeHRlbmRlZFN5bWJvbCh0aGlzLnF1YW50aXR5LnN5bWJvbCwgdGhpcy5jb250cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvMi5tb2RpZnlBbW91bnQgPSBmdW5jdGlvbiBtb2RpZnlBbW91bnQoeCwgbWV0aG9kKSB7XG4gICAgdmFyIGFtb3VudCA9IG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKDApO1xuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBFeHRlbmRlZEFzc2V0KSB7XG4gICAgICBhc3NlcnQodGhpcy5pc0xvb3NlbHlFcXVhbFRvKHgpLCBcImludmFsaWQgY29udHJhY3Qgb3Igc3ltYm9sXCIpO1xuICAgICAgYW1vdW50ID0geC5xdWFudGl0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW1vdW50ID0geDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEV4dGVuZGVkQXNzZXQoe1xuICAgICAgY29udHJhY3Q6IHRoaXMuY29udHJhY3QsXG4gICAgICBxdWFudGl0eTogdGhpcy5xdWFudGl0eS5tb2RpZnlBbW91bnQoYW1vdW50LCBtZXRob2QpXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMi5wbHVzID0gZnVuY3Rpb24gcGx1cyh4KSB7XG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5QW1vdW50KHgsIGV4cG9ydHMuTWF0aHMuT3BlcmF0aW9ucy5QTFVTKTtcbiAgfTtcblxuICBfcHJvdG8yLm1pbnVzID0gZnVuY3Rpb24gbWludXMoeCkge1xuICAgIHJldHVybiB0aGlzLm1vZGlmeUFtb3VudCh4LCBleHBvcnRzLk1hdGhzLk9wZXJhdGlvbnMuTUlOVVMpO1xuICB9O1xuXG4gIF9wcm90bzIubXVsdGlwbGllZEJ5ID0gZnVuY3Rpb24gbXVsdGlwbGllZEJ5KHgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RpZnlBbW91bnQoeCwgZXhwb3J0cy5NYXRocy5PcGVyYXRpb25zLk1VTFRJUExZKTtcbiAgfTtcblxuICBfcHJvdG8yLmRpdmlkZWRCeSA9IGZ1bmN0aW9uIGRpdmlkZWRCeSh4KSB7XG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5QW1vdW50KHgsIGV4cG9ydHMuTWF0aHMuT3BlcmF0aW9ucy5ESVZJREUpO1xuICB9O1xuXG4gIHJldHVybiBFeHRlbmRlZEFzc2V0O1xufSgpO1xudmFyIFN5bWJvbCQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3ltYm9sKHN5bWJvbCkge1xuICAgIHRoaXMucHJlY2lzaW9uID0gc3ltYm9sLnByZWNpc2lvbjtcbiAgICB0aGlzLmNvZGUgPSBzeW1ib2wuY29kZTtcbiAgfVxuXG4gIFN5bWJvbC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzeW1ib2wpIHtcbiAgICB2YXIgX3N5bWJvbCRzcGxpdCA9IHN5bWJvbC5zcGxpdCgnLCcpLFxuICAgICAgICBwcmVjaXNpb24gPSBfc3ltYm9sJHNwbGl0WzBdLFxuICAgICAgICBjb2RlID0gX3N5bWJvbCRzcGxpdFsxXTtcblxuICAgIHJldHVybiBuZXcgU3ltYm9sKHtcbiAgICAgIHByZWNpc2lvbjogK3ByZWNpc2lvbixcbiAgICAgIGNvZGU6IGNvZGVcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX3Byb3RvMyA9IFN5bWJvbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5pc0VxdWFsVG8gPSBmdW5jdGlvbiBpc0VxdWFsVG8oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZSA9PT0gc3ltYm9sLmNvZGUgJiYgdGhpcy5wcmVjaXNpb24gPT09IHN5bWJvbC5wcmVjaXNpb247XG4gIH07XG5cbiAgX3Byb3RvMy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnByZWNpc2lvbiArIFwiLFwiICsgdGhpcy5jb2RlO1xuICB9O1xuXG4gIHJldHVybiBTeW1ib2w7XG59KCk7XG52YXIgRXh0ZW5kZWRTeW1ib2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHRlbmRlZFN5bWJvbChzeW0sIGNvbnRyYWN0KSB7XG4gICAgdGhpcy5zeW0gPSBzeW07XG4gICAgdGhpcy5jb250cmFjdCA9IGNvbnRyYWN0O1xuICB9XG5cbiAgRXh0ZW5kZWRTeW1ib2wuZnJvbVJhdyA9IGZ1bmN0aW9uIGZyb21SYXcoX3JlZjMpIHtcbiAgICB2YXIgc3ltID0gX3JlZjMuc3ltLFxuICAgICAgICBjb250cmFjdCA9IF9yZWYzLmNvbnRyYWN0O1xuICAgIHJldHVybiBuZXcgRXh0ZW5kZWRTeW1ib2woU3ltYm9sJDEuZnJvbVN0cmluZyhzeW0pLCBjb250cmFjdCk7XG4gIH07XG5cbiAgdmFyIF9wcm90bzQgPSBFeHRlbmRlZFN5bWJvbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC5pc0VxdWFsVG8gPSBmdW5jdGlvbiBpc0VxdWFsVG8oZXh0ZW5kZWRTeW1ib2wpIHtcbiAgICByZXR1cm4gdGhpcy5zeW0uaXNFcXVhbFRvKGV4dGVuZGVkU3ltYm9sLnN5bSkgJiYgdGhpcy5jb250cmFjdCA9PT0gZXh0ZW5kZWRTeW1ib2wuY29udHJhY3Q7XG4gIH07XG5cbiAgX3Byb3RvNC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN5bS50b1N0cmluZygpICsgXCJAXCIgKyB0aGlzLmNvbnRyYWN0O1xuICB9O1xuXG4gIHJldHVybiBFeHRlbmRlZFN5bWJvbDtcbn0oKTtcblxudmFyIGN1cnJlbmN5TWFwID0ge1xuICAvLyBGaWF0XG4gIEdCUDoge1xuICAgIHN5bWJvbDogJ8KjJyxcbiAgICBwcmVjaXNpb246IDJcbiAgfSxcbiAgRVVSOiB7XG4gICAgc3ltYm9sOiAn4oKsJyxcbiAgICBwcmVjaXNpb246IDJcbiAgfSxcbiAgSlBZOiB7XG4gICAgc3ltYm9sOiAnwqUnLFxuICAgIHByZWNpc2lvbjogMFxuICB9LFxuICBDQUQ6IHtcbiAgICBzeW1ib2w6ICdDQSQnLFxuICAgIHByZWNpc2lvbjogMlxuICB9LFxuICBVU0Q6IHtcbiAgICBzeW1ib2w6ICckJyxcbiAgICBwcmVjaXNpb246IDJcbiAgfSxcbiAgSU5SOiB7XG4gICAgc3ltYm9sOiAn4oK5JyxcbiAgICBwcmVjaXNpb246IDJcbiAgfSxcbiAgQ05ZOiB7XG4gICAgc3ltYm9sOiAnQ07CpScsXG4gICAgcHJlY2lzaW9uOiAyXG4gIH0sXG4gIEhLRDoge1xuICAgIHN5bWJvbDogJ0hLJCcsXG4gICAgcHJlY2lzaW9uOiAyXG4gIH0sXG4gIEtSVzoge1xuICAgIHN5bWJvbDogJ+KCqScsXG4gICAgcHJlY2lzaW9uOiAwXG4gIH0sXG4gIEFVRDoge1xuICAgIHN5bWJvbDogJ0FVRCQnLFxuICAgIHByZWNpc2lvbjogMlxuICB9LFxuICBTQVI6IHtcbiAgICBzeW1ib2w6ICdTUicsXG4gICAgcHJlY2lzaW9uOiAyXG4gIH0sXG4gIC8vIENyeXB0b1xuICBFVEg6IHtcbiAgICBzeW1ib2w6ICfOnicsXG4gICAgcHJlY2lzaW9uOiA0XG4gIH0sXG4gIEJUQzoge1xuICAgIHN5bWJvbDogJ+KCvycsXG4gICAgcHJlY2lzaW9uOiA4XG4gIH0sXG4gIEVPUzoge1xuICAgIHN5bWJvbDogJ0VPUycsXG4gICAgcHJlY2lzaW9uOiA0XG4gIH1cbn07XG52YXIgYXNzZXRGb3JtYXQgPSB7XG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcbiAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcbiAgZ3JvdXBTaXplOiAzXG59O1xuXG5mdW5jdGlvbiB0b0JOKG51bWJlcikge1xuICByZXR1cm4gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIobnVtYmVyKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQW1vdW50KG51bWJlciwgcHJlY2lzaW9uLCByb3VuZCkge1xuICBpZiAocm91bmQgPT09IHZvaWQgMCkge1xuICAgIHJvdW5kID0gYmlnbnVtYmVyX2pzLkJpZ051bWJlci5ST1VORF9ET1dOO1xuICB9XG5cbiAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBudW1iZXIgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4obnVtYmVyKSkge1xuICAgIG51bWJlciA9IDA7XG4gIH1cblxuICByZXR1cm4gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIobnVtYmVyKS50b0ZpeGVkKHByZWNpc2lvbiwgcm91bmQpO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9BbW91bnRGb3JtYXR0ZWQobnVtYmVyLCBwcmVjaXNpb24sIHJvdW5kKSB7XG4gIGlmIChyb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgcm91bmQgPSBiaWdudW1iZXJfanMuQmlnTnVtYmVyLlJPVU5EX0RPV047XG4gIH1cblxuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQgfHwgaXNOYU4obnVtYmVyKSkge1xuICAgIG51bWJlciA9IDA7XG4gIH1cblxuICByZXR1cm4gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIobnVtYmVyKS50b0Zvcm1hdChwcmVjaXNpb24sIHJvdW5kLCBhc3NldEZvcm1hdCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQZXJjZW50YWdlKGJhbGFuY2UsIHBlcmNlbnRhZ2UsIHByZWNpc2lvbikge1xuICB2YXIgX2ZpbmFsID0gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoYmFsYW5jZSkubXVsdGlwbGllZEJ5KHBlcmNlbnRhZ2UpO1xuXG4gIHJldHVybiBudW1iZXJUb0Ftb3VudChfZmluYWwsIHByZWNpc2lvbiwgYmlnbnVtYmVyX2pzLkJpZ051bWJlci5ST1VORF9ET1dOKTtcbn1cbmZ1bmN0aW9uIGVvc0Rpc3BsYXlGb3JtYXR0aW5nKHZhbHVlLCBzeW1ib2wsIHByZWNpc2lvbikge1xuICByZXR1cm4gbnVtYmVyVG9BbW91bnRGb3JtYXR0ZWQodmFsdWUsIHByZWNpc2lvbikgKyBcIiBcIiArIHN5bWJvbDtcbn1cbmZ1bmN0aW9uIG51bWJlclRvRW9zKG51bWJlciwgc3ltYm9sLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuIG51bWJlclRvQW1vdW50KG51bWJlciwgcHJlY2lzaW9uKSArIFwiIFwiICsgc3ltYm9sO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9Fb3NSb3VuZFVwKG51bWJlciwgc3ltYm9sLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuIG51bWJlclRvQW1vdW50KG51bWJlciwgcHJlY2lzaW9uLCBiaWdudW1iZXJfanMuQmlnTnVtYmVyLlJPVU5EX1VQKSArIFwiIFwiICsgc3ltYm9sO1xufVxuZnVuY3Rpb24gcGFyc2VSZXgocmV4KSB7XG4gIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihyZXgpLmRpdmlkZWRCeSgxMDAwMCk7XG59XG4vKipcclxuICogQ29udmVydHMgVVNEIHRvIHsgc3ltYm9sOiBcIlVTRFwiLCBwcmVjaXNpb246IDQgfVxyXG4gKiBAcGFyYW0geyp9IGN1cnJlbmN5XHJcbiAqL1xuXG5mdW5jdGlvbiBjdXJyZW5jeVRvU3ltYm9sKGN1cnJlbmN5KSB7XG4gIHJldHVybiBjdXJyZW5jeU1hcFtjdXJyZW5jeV07XG59XG4vKipcclxuICogQ29udmVydHMgXCIxMDAwLjAwMDAgRU9TXCIgdG8geyBhbW91bnQ6IDEwMDAsIHN5bWJvbDogeyBjb2RlOiBcIkVPU1wiLCBwcmVjaXNpb246IDQgfX1cclxuICogQHBhcmFtIHsqfSBxdWFudGl0eVxyXG4gKi9cblxuZnVuY3Rpb24gc3BsaXQocXVhbnRpdHkpIHtcbiAgdmFyIF9xdWFudGl0eSRzcGxpdCA9IHF1YW50aXR5LnNwbGl0KCcgJyksXG4gICAgICBhbW91bnQgPSBfcXVhbnRpdHkkc3BsaXRbMF0sXG4gICAgICBjb2RlID0gX3F1YW50aXR5JHNwbGl0WzFdO1xuXG4gIHZhciBwcmVjaXNpb24gPSAoYW1vdW50LnNwbGl0KCcuJylbMV0gfHwgW10pLmxlbmd0aDtcbiAgcmV0dXJuIHtcbiAgICBhbW91bnQ6ICthbW91bnQsXG4gICAgc3ltYm9sOiB7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb25cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0b051bWJybyhudW1iZXIpIHtcbiAgcmV0dXJuIG51bWJybyhudW1iZXIpO1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIDEwMDAgdG8gXCIxMDAwLjAwMDAgRU9TXCJcclxuICogQHBhcmFtIHsqfSBhc3NldFxyXG4gKi9cblxuZnVuY3Rpb24gbnVtYmVyVG9Bc3NldChudW1iZXIsIHN5bWJvbCwgcHJlY2lzaW9uLCB0cmltTWFudGlzc2EpIHtcbiAgaWYgKHRyaW1NYW50aXNzYSA9PT0gdm9pZCAwKSB7XG4gICAgdHJpbU1hbnRpc3NhID0gZmFsc2U7XG4gIH1cblxuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQgfHwgaXNOYU4obnVtYmVyKSkge1xuICAgIG51bWJlciA9IDA7XG4gIH1cblxuICB2YXIgYW1vdW50ID0gbnVtYnJvKG51bWJlcikuZm9ybWF0KHtcbiAgICB0aG91c2FuZFNlcGFyYXRlZDogZmFsc2UsXG4gICAgbWFudGlzc2E6IHByZWNpc2lvbixcbiAgICB0cmltTWFudGlzc2E6IHRyaW1NYW50aXNzYVxuICB9KTtcbiAgcmV0dXJuIGFtb3VudCArIFwiIFwiICsgc3ltYm9sO1xufVxuLyoqXHJcbiAqIERJU1BMQVkgRlVOQ1RJT05TXHJcbiAqL1xuXG4vKipcclxuICogQ29udmVydHMgMTAwMCB0byAxLDAwMFxyXG4gKiBAcGFyYW0geyp9IG51bWJlclxyXG4gKi9cblxuZnVuY3Rpb24gZGlzcGxheU51bWJlcihudW1iZXIsIHRyaW1NYW50aXNzYSkge1xuICBpZiAodHJpbU1hbnRpc3NhID09PSB2b2lkIDApIHtcbiAgICB0cmltTWFudGlzc2EgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IHVuZGVmaW5lZCB8fCBpc05hTihudW1iZXIpKSB7XG4gICAgbnVtYmVyID0gMDtcbiAgfVxuXG4gIHJldHVybiBudW1icm8obnVtYmVyKS5mb3JtYXQoe1xuICAgIHRob3VzYW5kU2VwYXJhdGVkOiB0cnVlLFxuICAgIHRyaW1NYW50aXNzYTogdHJpbU1hbnRpc3NhXG4gIH0pO1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIDEwMDAgdG8gJDEsMDAwIFVTRFxyXG4gKiBAcGFyYW0geyp9IG51bWJlclxyXG4gKi9cblxuZnVuY3Rpb24gZGlzcGxheU51bWJlckFzQ3VycmVuY3koX3JlZikge1xuICB2YXIgbnVtYmVyID0gX3JlZi5udW1iZXIsXG4gICAgICBwcmVjaXNpb24gPSBfcmVmLnByZWNpc2lvbixcbiAgICAgIF9yZWYkYXZlcmFnZSA9IF9yZWYuYXZlcmFnZSxcbiAgICAgIGF2ZXJhZ2UgPSBfcmVmJGF2ZXJhZ2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRhdmVyYWdlLFxuICAgICAgX3JlZiRsb3dQcmVjaXNpb24gPSBfcmVmLmxvd1ByZWNpc2lvbixcbiAgICAgIGxvd1ByZWNpc2lvbiA9IF9yZWYkbG93UHJlY2lzaW9uID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRsb3dQcmVjaXNpb24sXG4gICAgICBfcmVmJHRyaW1NYW50aXNzYSA9IF9yZWYudHJpbU1hbnRpc3NhLFxuICAgICAgdHJpbU1hbnRpc3NhID0gX3JlZiR0cmltTWFudGlzc2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiR0cmltTWFudGlzc2EsXG4gICAgICBfcmVmJGN1cnJlbmN5ID0gX3JlZi5jdXJyZW5jeSxcbiAgICAgIGN1cnJlbmN5ID0gX3JlZiRjdXJyZW5jeSA9PT0gdm9pZCAwID8gJ1VTRCcgOiBfcmVmJGN1cnJlbmN5O1xuXG4gIGlmICghY3VycmVuY3lNYXBbY3VycmVuY3ldKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjdXJyZW5jeScpO1xuICB9XG5cbiAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG51bWJlcikpIHtcbiAgICBudW1iZXIgPSAwO1xuICB9XG5cbiAgdmFyIF9jdXJyZW5jeU1hcCRjdXJyZW5jeSA9IGN1cnJlbmN5TWFwW2N1cnJlbmN5XSxcbiAgICAgIHN5bWJvbCA9IF9jdXJyZW5jeU1hcCRjdXJyZW5jeS5zeW1ib2wsXG4gICAgICBkZWZhdWx0UHJlY2lzaW9uID0gX2N1cnJlbmN5TWFwJGN1cnJlbmN5LnByZWNpc2lvbjtcbiAgdmFyIGZvcm1hdCA9IHtcbiAgICB0aG91c2FuZFNlcGFyYXRlZDogdHJ1ZSxcbiAgICBtYW50aXNzYTogcHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwcmVjaXNpb24gOiBkZWZhdWx0UHJlY2lzaW9uLFxuICAgIHRyaW1NYW50aXNzYTogdHJpbU1hbnRpc3NhLFxuICAgIGF2ZXJhZ2U6IGF2ZXJhZ2VcbiAgfTtcblxuICBpZiAoYXZlcmFnZSkge1xuICAgIGZvcm1hdC5sb3dQcmVjaXNpb24gPSBsb3dQcmVjaXNpb247XG4gIH1cblxuICB2YXIgZm9ybWF0dGVkTnVtYmVyID0gbnVtYnJvKG51bWJlcikuZm9ybWF0KGZvcm1hdCk7XG4gIHJldHVybiBcIlwiICsgc3ltYm9sICsgZm9ybWF0dGVkTnVtYmVyO1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIFwiMTAwMC4wMDAwIEVPU1wiIHRvIFwiMSwwMDAuMDAwMCBFT1NcIlxyXG4gKiBAcGFyYW0geyp9IGFzc2V0XHJcbiAqL1xuXG5mdW5jdGlvbiBkaXNwbGF5QXNzZXQoYXNzZXQpIHtcbiAgdmFyIF9zcGxpdCA9IHNwbGl0KGFzc2V0KSxcbiAgICAgIGFtb3VudCA9IF9zcGxpdC5hbW91bnQsXG4gICAgICBjb2RlID0gX3NwbGl0LnN5bWJvbC5jb2RlO1xuXG4gIHJldHVybiBkaXNwbGF5TnVtYmVyKGFtb3VudCkgKyBcIiBcIiArIGNvZGU7XG59XG4vKipcclxuICogQ29udmVydHMgMTAwMCB0byAxLDAwMC4wMDAwXHJcbiAqIEBwYXJhbSB7Kn0gbnVtYmVyXHJcbiAqL1xuXG5mdW5jdGlvbiBkaXNwbGF5TnVtYmVyQXNBbW91bnQobnVtYmVyLCBwcmVjaXNpb24sIHRyaW1NYW50aXNzYSkge1xuICBpZiAodHJpbU1hbnRpc3NhID09PSB2b2lkIDApIHtcbiAgICB0cmltTWFudGlzc2EgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IHVuZGVmaW5lZCB8fCBpc05hTihudW1iZXIpKSB7XG4gICAgbnVtYmVyID0gMDtcbiAgfVxuXG4gIHJldHVybiBudW1icm8obnVtYmVyKS5mb3JtYXQoe1xuICAgIHRob3VzYW5kU2VwYXJhdGVkOiB0cnVlLFxuICAgIG1hbnRpc3NhOiBwcmVjaXNpb24sXG4gICAgdHJpbU1hbnRpc3NhOiB0cmltTWFudGlzc2FcbiAgfSk7XG59XG4vKipcclxuICogQ29udmVydHMgMTAwMCB0byBcIjEsMDAwLjAwMDAgRU9TXCJcclxuICogQHBhcmFtIHsqfSBudW1iZXJcclxuICovXG5cbmZ1bmN0aW9uIGRpc3BsYXlOdW1iZXJBc0Fzc2V0KG51bWJlciwgc3ltYm9sLCBwcmVjaXNpb24sIHRyaW1NYW50aXNzYSkge1xuICBpZiAodHJpbU1hbnRpc3NhID09PSB2b2lkIDApIHtcbiAgICB0cmltTWFudGlzc2EgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IHVuZGVmaW5lZCB8fCBpc05hTihudW1iZXIpKSB7XG4gICAgbnVtYmVyID0gMDtcbiAgfVxuXG4gIHZhciBhbW91bnQgPSBudW1icm8obnVtYmVyKS5mb3JtYXQoe1xuICAgIHRob3VzYW5kU2VwYXJhdGVkOiB0cnVlLFxuICAgIG1hbnRpc3NhOiBwcmVjaXNpb24sXG4gICAgdHJpbU1hbnRpc3NhOiB0cmltTWFudGlzc2FcbiAgfSk7XG4gIHJldHVybiBhbW91bnQgKyBcIiBcIiArIHN5bWJvbDtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0cyAxMDAwMDAwMCB0byBcIjEsMDAwLjAwMDAgRU9TXCJcclxuICogQHBhcmFtIHsqfSBudW1iZXJcclxuICovXG5cbmZ1bmN0aW9uIGRpc3BsYXlSYXdOdW1iZXJBc0Fzc2V0KG51bWJlciwgc3ltYm9sLCBwcmVjaXNpb24sIHRyaW1NYW50aXNzYSkge1xuICBpZiAodHJpbU1hbnRpc3NhID09PSB2b2lkIDApIHtcbiAgICB0cmltTWFudGlzc2EgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkaXNwbGF5TnVtYmVyQXNBc3NldChudW1iZXIgLyBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKSwgc3ltYm9sLCBwcmVjaXNpb24sIHRyaW1NYW50aXNzYSk7XG59XG5cbmJpZ251bWJlcl9qcy5CaWdOdW1iZXIuc2V0KHtcbiAgUk9VTkRJTkdfTU9ERTogMVxufSk7XG5mdW5jdGlvbiBhZGQoKSB7XG4gIHZhciBzdGFydCA9IG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKDApO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBudW1iZXJzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG51bWJlcnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAobnVtYmVycy5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG51bWJlcnMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIG51bWJlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgc3RhcnQgPSBzdGFydC5wbHVzKG51bWJlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXJ0O1xufVxuZnVuY3Rpb24gc3Vic3RyYWN0KGEsIGIpIHtcbiAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKGEpLm1pbnVzKGIpO1xufVxuZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICByZXR1cm4gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoYSkubXVsdGlwbGllZEJ5KGIpO1xufVxuZnVuY3Rpb24gZGl2aWRlKGEsIGIpIHtcbiAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKGEpLmRpdmlkZWRCeShiKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb0tCKGJ5dGVzKSB7XG4gIGlmIChieXRlcyA9PT0gdm9pZCAwKSB7XG4gICAgYnl0ZXMgPSAwO1xuICB9XG5cbiAgcmV0dXJuIG51bWJybyhieXRlcyAvIDEwMjQpLmZvcm1hdCh7XG4gICAgdGhvdXNhbmRTZXBhcmF0ZWQ6IGZhbHNlLFxuICAgIG1hbnRpc3NhOiAyXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VOZXRBbmRSYW0oYnl0ZXMpIHtcbiAgdmFyIHBhcnNlZFZhbHVlID0gMDtcbiAgdmFyIHBhcnNlZFRleHQgPSAnJztcblxuICBpZiAoYnl0ZXMgPCAxMDI0KSB7XG4gICAgcGFyc2VkVmFsdWUgPSBieXRlcztcbiAgICBwYXJzZWRUZXh0ID0gJ0J5dGVzJztcbiAgfSBlbHNlIGlmIChieXRlcyA8IDEwNDg1NzYpIHtcbiAgICBwYXJzZWRWYWx1ZSA9IGJ5dGVzIC8gMTAyNDtcbiAgICBwYXJzZWRUZXh0ID0gJ0tCJztcbiAgfSBlbHNlIGlmIChieXRlcyA8IDEwNzM3NDE4MjQpIHtcbiAgICBwYXJzZWRWYWx1ZSA9IGJ5dGVzIC8gMTA0ODU3NjtcbiAgICBwYXJzZWRUZXh0ID0gJ01CJztcbiAgfSBlbHNlIGlmIChieXRlcyA8IDEwOTk1MTE2Mjc3NzYpIHtcbiAgICBwYXJzZWRWYWx1ZSA9IGJ5dGVzIC8gMTA3Mzc0MTgyNDtcbiAgICBwYXJzZWRUZXh0ID0gJ0dCJztcbiAgfSBlbHNlIGlmIChieXRlcyA8IDExMjU4OTk5MDY4NDI2MjQpIHtcbiAgICBwYXJzZWRWYWx1ZSA9IGJ5dGVzIC8gMTA5OTUxMTYyNzc3NjtcbiAgICBwYXJzZWRUZXh0ID0gJ1RCJztcbiAgfVxuXG4gIHJldHVybiBkaXNwbGF5TnVtYmVyQXNBbW91bnQocGFyc2VkVmFsdWUsIDIsIHRydWUpICsgXCIgXCIgKyBwYXJzZWRUZXh0O1xufVxuZnVuY3Rpb24gcGFyc2VDcHUodXMpIHtcbiAgdmFyIHBhcnNlZFZhbHVlID0gMDtcbiAgdmFyIHBhcnNlZFRleHQgPSAnJztcblxuICBpZiAodXMgPCAxMDAwKSB7XG4gICAgcGFyc2VkVmFsdWUgPSB1cztcbiAgICBwYXJzZWRUZXh0ID0gJ8K1cyc7XG4gIH0gZWxzZSBpZiAodXMgPCAxMDAwMDAwKSB7XG4gICAgcGFyc2VkVmFsdWUgPSB1cyAvIDEwMDA7XG4gICAgcGFyc2VkVGV4dCA9ICdtcyc7XG4gIH0gZWxzZSBpZiAodXMgPCA2MDAwMDAwMCkge1xuICAgIHBhcnNlZFZhbHVlID0gdXMgLyAxMDAwMDAwO1xuICAgIHBhcnNlZFRleHQgPSAncyc7XG4gIH0gZWxzZSBpZiAodXMgPCAzNjAwMDAwMDAwKSB7XG4gICAgcGFyc2VkVmFsdWUgPSB1cyAvIDYwMDAwMDAwO1xuICAgIHBhcnNlZFRleHQgPSAnbWluJztcbiAgfSBlbHNlIGlmICh1cyA8IDM2MDAwMDAwMDAwMDApIHtcbiAgICBwYXJzZWRWYWx1ZSA9IHVzIC8gMzYwMDAwMDAwMDtcbiAgICBwYXJzZWRUZXh0ID0gJ2hvdXJzJztcbiAgfSBlbHNlIHtcbiAgICBwYXJzZWRWYWx1ZSA9IHVzIC8gODY0MDAwMDAwMDA7XG4gICAgcGFyc2VkVGV4dCA9ICdkYXlzJztcbiAgfVxuXG4gIHJldHVybiBkaXNwbGF5TnVtYmVyQXNBbW91bnQocGFyc2VkVmFsdWUsIDIsIHRydWUpICsgXCIgXCIgKyBwYXJzZWRUZXh0O1xufVxuXG5kYXlqcy5leHRlbmQocmVsYXRpdmVUaW1lUGx1Z2luKTtcbmRheWpzLmV4dGVuZCh1dGNQbHVnaW4pO1xuZGF5anMuZXh0ZW5kKHRpbWV6b25lUGx1Z2luKTtcbmRheWpzLmV4dGVuZChhZHZhbmNlZEZvcm1hdFBsdWdpbik7XG52YXIgQ09NTU9OX0RBVEVfRk9STUFUID0gJ01NTS1ERC1ZWVlZLCBoaDptbTpzcyBBJztcbi8qKlxyXG4gKiBUaW1lIHV0aWxpdGllc1xyXG4gKi9cblxuZnVuY3Rpb24gdGltZShkYXRlKSB7XG4gIHJldHVybiBkYXlqcyhkYXRlKTtcbn1cbmZ1bmN0aW9uIHV0Y1RpbWUoZGF0ZSkge1xuICByZXR1cm4gZGF5anMoZGF0ZSkudXRjKCk7XG59XG5mdW5jdGlvbiB1dGNUaW1lVG9Mb2NhbChkYXRlKSB7XG4gIHJldHVybiBkYXlqcyhkYXRlKS5sb2NhbCgpO1xufVxuZnVuY3Rpb24gdW5peFRpbWUodW5peFRpbWVzdGFtcCkge1xuICByZXR1cm4gZGF5anMudW5peCh1bml4VGltZXN0YW1wKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQgPT09IHZvaWQgMCkge1xuICAgIGZvcm1hdCA9IENPTU1PTl9EQVRFX0ZPUk1BVDtcbiAgfVxuXG4gIHJldHVybiBkYXlqcyhkYXRlKS5mb3JtYXQoZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdERhdGVMb2NhbChkYXRlLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7XG4gICAgZm9ybWF0ID0gQ09NTU9OX0RBVEVfRk9STUFUO1xuICB9XG5cbiAgcmV0dXJuIGRheWpzKGRhdGUpLnV0YygpLmZvcm1hdChmb3JtYXQpO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wVG9EYXRlKHRpbWVzdGFtcCkge1xuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wKTtcbn1cbmZ1bmN0aW9uIHV0Y1RpbWVzdGFtcFRvRGF0ZSh0aW1lc3RhbXApIHtcbiAgdGltZXN0YW1wID0gdGltZXN0YW1wLnNsaWNlKC0xKSA9PT0gJ1onID8gdGltZXN0YW1wIDogdGltZXN0YW1wICsgJ1onO1xuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wKTtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcEZyb21Ob3codGltZXN0YW1wKSB7XG4gIHJldHVybiB0aW1lKHRpbWVzdGFtcCkuZnJvbU5vdygpO1xufVxuZnVuY3Rpb24gdXRjVGltZXN0YW1wRnJvbU5vdyh0aW1lc3RhbXApIHtcbiAgdGltZXN0YW1wID0gdGltZXN0YW1wLnNsaWNlKC0xKSA9PT0gJ1onID8gdGltZXN0YW1wIDogdGltZXN0YW1wICsgJ1onO1xuICByZXR1cm4gdGltZSh0aW1lc3RhbXApLmZyb21Ob3coKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZXN0YW1wKHRpbWVzdGFtcCwgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQgPT09IHZvaWQgMCkge1xuICAgIGZvcm1hdCA9IENPTU1PTl9EQVRFX0ZPUk1BVDtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXREYXRlKHRpbWVzdGFtcFRvRGF0ZSh0aW1lc3RhbXApLCBmb3JtYXQpO1xufVxuZnVuY3Rpb24gcGFyc2VVdGNUaW1lc3RhbXAodGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7XG4gICAgZm9ybWF0ID0gQ09NTU9OX0RBVEVfRk9STUFUO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdERhdGUodXRjVGltZXN0YW1wVG9EYXRlKHRpbWVzdGFtcCksIGZvcm1hdCk7XG59XG5mdW5jdGlvbiBpbkZ1dHVyZShkYXRlLCB1dGMpIHtcbiAgaWYgKHV0YyA9PT0gdm9pZCAwKSB7XG4gICAgdXRjID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdXRjID8gdXRjVGltZShkYXRlKS5pc0FmdGVyKHV0Y1RpbWUoKSkgOiB0aW1lKGRhdGUpLmlzQWZ0ZXIodGltZSgpKTtcbn1cbmZ1bmN0aW9uIGluUGFzdChkYXRlLCB1dGMpIHtcbiAgaWYgKHV0YyA9PT0gdm9pZCAwKSB7XG4gICAgdXRjID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdXRjID8gdXRjVGltZShkYXRlKS5pc0JlZm9yZSh1dGNUaW1lKCkpIDogdGltZShkYXRlKS5pc0JlZm9yZSh0aW1lKCkpO1xufVxuZnVuY3Rpb24gaXNTYW1lRGF5KHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgZW5kID0gdGltZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRheWpzKHN0YXJ0KS5pc1NhbWUoZGF5anMoZW5kKSwgJ2RheScpO1xufSAvLyBTZWNvbmRzIHRpbGwgbm93IGlmIHNlY29uZCBwYXJhbSBlbXB0eVxuXG5mdW5jdGlvbiBzZWNvbmRzRnJvbShzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHZvaWQgMCkge1xuICAgIGVuZCA9IHRpbWUoKTtcbiAgfVxuXG4gIHJldHVybiBkYXlqcyhzdGFydCkuZGlmZihkYXlqcyhlbmQpLCAnc2Vjb25kJyk7XG59XG5mdW5jdGlvbiBtaWxsaXNlY29uZHNGcm9tKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgZW5kID0gdGltZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRheWpzKHN0YXJ0KS5kaWZmKGRheWpzKGVuZCkpO1xufVxuLyoqXHJcbiAqIFNwZWNpZmljIHRvIEVPU1xyXG4gKi9cblxuZnVuY3Rpb24gc3RhcnREYXRlKHN0YXJ0RGF0ZSwgZGF5cykge1xuICBpZiAoZGF5cyA9PT0gdm9pZCAwKSB7XG4gICAgZGF5cyA9IDM7XG4gIH1cblxuICByZXR1cm4gZGF5anMoc3RhcnREYXRlKS5jbG9uZSgpLnN1YnRyYWN0KGRheXMsICdkYXlzJyk7XG59XG5mdW5jdGlvbiBmb3JtYXRTdGFydERhdGUoc3RhcnRUaW1lc3RhbXApIHtcbiAgcmV0dXJuIHN0YXJ0RGF0ZShzdGFydFRpbWVzdGFtcCkuZm9ybWF0KCdNTU0tREQtWVlZWSwgaGg6bW06c3MgQScpO1xufVxuZnVuY3Rpb24gZW5kRGF0ZShlbmREYXRlLCBkYXlzKSB7XG4gIGlmIChkYXlzID09PSB2b2lkIDApIHtcbiAgICBkYXlzID0gMztcbiAgfVxuXG4gIHJldHVybiBkYXlqcyhlbmREYXRlKS5jbG9uZSgpLmFkZChkYXlzLCAnZGF5cycpO1xufVxuZnVuY3Rpb24gZm9ybWF0RW5kRGF0ZShlbmRUaW1lc3RhbXApIHtcbiAgcmV0dXJuIGVuZERhdGUoZW5kVGltZXN0YW1wKS5mb3JtYXQoJ01NTS1ERC1ZWVlZLCBoaDptbTpzcyBBJyk7XG59XG5mdW5jdGlvbiBkYXRlVG9VdGNUaW1lUG9pbnQoZGF0ZSkge1xuICBpZiAoZGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgZGF0ZSA9IHRpbWUoKTtcbiAgfVxuXG4gIHJldHVybiBkYXlqcyhkYXRlKS51dGMoKS5mb3JtYXQoJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJyk7XG59XG52YXIgZW1wdHlUaW1lUG9pbnQgPSAnMTk3MC0wMS0wMVQwMDowMDowMC4wMDAnO1xuZnVuY3Rpb24gcGFyc2VTZWNvbmRzKHNlY29uZHMpIHtcbiAgdmFyIGRheXMgPSAwO1xuICB2YXIgaG91cnMgPSAwO1xuICB2YXIgbWludXRlcyA9IDA7XG4gIHZhciBwYXJzZWREYXRlID0gJyc7IC8vIERheXNcblxuICBpZiAoc2Vjb25kcyA+IDg2NDAwKSB7XG4gICAgZGF5cyArPSBNYXRoLmZsb29yKHNlY29uZHMgLyA4NjQwMCk7XG4gICAgc2Vjb25kcyAtPSBkYXlzICogODY0MDA7XG4gICAgcGFyc2VkRGF0ZSArPSBkYXlzLnRvRml4ZWQoMCkgKyBcIiBcIiArIChkYXlzID09PSAxID8gJ0RheScgOiAnRGF5cycpICsgXCIgXCI7XG4gIH0gLy8gSG91cnNcblxuXG4gIGlmIChzZWNvbmRzID4gMzYwMCkge1xuICAgIGhvdXJzICs9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xuICAgIHNlY29uZHMgLT0gaG91cnMgKiAzNjAwO1xuICAgIHBhcnNlZERhdGUgKz0gaG91cnMudG9GaXhlZCgwKSArIFwiIFwiICsgKGhvdXJzID09PSAxID8gJ0hvdXInIDogJ0hvdXJzJykgKyBcIiBcIjtcbiAgfSAvLyBNaW51dGVzXG5cblxuICBpZiAoc2Vjb25kcyA+IDYwKSB7XG4gICAgbWludXRlcyArPSBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgc2Vjb25kcyAtPSBtaW51dGVzICogNjA7XG4gICAgcGFyc2VkRGF0ZSArPSBtaW51dGVzLnRvRml4ZWQoMCkgKyBcIiBcIiArIChtaW51dGVzID09PSAxID8gJ01pbnV0ZScgOiAnTWludXRlcycpICsgXCIgXCI7XG4gIH0gLy8gU2Vjb25kc1xuXG5cbiAgaWYgKHNlY29uZHMgPiAwKSB7XG4gICAgcGFyc2VkRGF0ZSArPSBzZWNvbmRzLnRvRml4ZWQoMCkgKyBcIiBTZWNvbmRzIFwiO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZERhdGU7XG59XG5cbmV4cG9ydHMuQXNzZXQgPSBBc3NldDtcbmV4cG9ydHMuRXh0ZW5kZWRBc3NldCA9IEV4dGVuZGVkQXNzZXQ7XG5leHBvcnRzLkV4dGVuZGVkU3ltYm9sID0gRXh0ZW5kZWRTeW1ib2w7XG5leHBvcnRzLlN5bWJvbCA9IFN5bWJvbCQxO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLmJ5dGVzVG9LQiA9IGJ5dGVzVG9LQjtcbmV4cG9ydHMuY2FsY3VsYXRlUGVyY2VudGFnZSA9IGNhbGN1bGF0ZVBlcmNlbnRhZ2U7XG5leHBvcnRzLmN1cnJlbmN5VG9TeW1ib2wgPSBjdXJyZW5jeVRvU3ltYm9sO1xuZXhwb3J0cy5kYXRlVG9VdGNUaW1lUG9pbnQgPSBkYXRlVG9VdGNUaW1lUG9pbnQ7XG5leHBvcnRzLmRpc3BsYXlBc3NldCA9IGRpc3BsYXlBc3NldDtcbmV4cG9ydHMuZGlzcGxheU51bWJlciA9IGRpc3BsYXlOdW1iZXI7XG5leHBvcnRzLmRpc3BsYXlOdW1iZXJBc0Ftb3VudCA9IGRpc3BsYXlOdW1iZXJBc0Ftb3VudDtcbmV4cG9ydHMuZGlzcGxheU51bWJlckFzQXNzZXQgPSBkaXNwbGF5TnVtYmVyQXNBc3NldDtcbmV4cG9ydHMuZGlzcGxheU51bWJlckFzQ3VycmVuY3kgPSBkaXNwbGF5TnVtYmVyQXNDdXJyZW5jeTtcbmV4cG9ydHMuZGlzcGxheVJhd051bWJlckFzQXNzZXQgPSBkaXNwbGF5UmF3TnVtYmVyQXNBc3NldDtcbmV4cG9ydHMuZGl2aWRlID0gZGl2aWRlO1xuZXhwb3J0cy5lbXB0eVRpbWVQb2ludCA9IGVtcHR5VGltZVBvaW50O1xuZXhwb3J0cy5lbmREYXRlID0gZW5kRGF0ZTtcbmV4cG9ydHMuZW9zRGlzcGxheUZvcm1hdHRpbmcgPSBlb3NEaXNwbGF5Rm9ybWF0dGluZztcbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGZvcm1hdERhdGU7XG5leHBvcnRzLmZvcm1hdERhdGVMb2NhbCA9IGZvcm1hdERhdGVMb2NhbDtcbmV4cG9ydHMuZm9ybWF0RW5kRGF0ZSA9IGZvcm1hdEVuZERhdGU7XG5leHBvcnRzLmZvcm1hdFN0YXJ0RGF0ZSA9IGZvcm1hdFN0YXJ0RGF0ZTtcbmV4cG9ydHMuaW5GdXR1cmUgPSBpbkZ1dHVyZTtcbmV4cG9ydHMuaW5QYXN0ID0gaW5QYXN0O1xuZXhwb3J0cy5pc1NhbWVEYXkgPSBpc1NhbWVEYXk7XG5leHBvcnRzLm1pbGxpc2Vjb25kc0Zyb20gPSBtaWxsaXNlY29uZHNGcm9tO1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5udW1iZXJUb0Ftb3VudCA9IG51bWJlclRvQW1vdW50O1xuZXhwb3J0cy5udW1iZXJUb0Ftb3VudEZvcm1hdHRlZCA9IG51bWJlclRvQW1vdW50Rm9ybWF0dGVkO1xuZXhwb3J0cy5udW1iZXJUb0Fzc2V0ID0gbnVtYmVyVG9Bc3NldDtcbmV4cG9ydHMubnVtYmVyVG9Fb3MgPSBudW1iZXJUb0VvcztcbmV4cG9ydHMubnVtYmVyVG9Fb3NSb3VuZFVwID0gbnVtYmVyVG9Fb3NSb3VuZFVwO1xuZXhwb3J0cy5wYXJzZUNwdSA9IHBhcnNlQ3B1O1xuZXhwb3J0cy5wYXJzZU5ldEFuZFJhbSA9IHBhcnNlTmV0QW5kUmFtO1xuZXhwb3J0cy5wYXJzZVJleCA9IHBhcnNlUmV4O1xuZXhwb3J0cy5wYXJzZVNlY29uZHMgPSBwYXJzZVNlY29uZHM7XG5leHBvcnRzLnBhcnNlVGltZXN0YW1wID0gcGFyc2VUaW1lc3RhbXA7XG5leHBvcnRzLnBhcnNlVXRjVGltZXN0YW1wID0gcGFyc2VVdGNUaW1lc3RhbXA7XG5leHBvcnRzLnNlY29uZHNGcm9tID0gc2Vjb25kc0Zyb207XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG5leHBvcnRzLnN0YXJ0RGF0ZSA9IHN0YXJ0RGF0ZTtcbmV4cG9ydHMuc3Vic3RyYWN0ID0gc3Vic3RyYWN0O1xuZXhwb3J0cy50aW1lID0gdGltZTtcbmV4cG9ydHMudGltZXN0YW1wRnJvbU5vdyA9IHRpbWVzdGFtcEZyb21Ob3c7XG5leHBvcnRzLnRpbWVzdGFtcFRvRGF0ZSA9IHRpbWVzdGFtcFRvRGF0ZTtcbmV4cG9ydHMudG9CTiA9IHRvQk47XG5leHBvcnRzLnRvTnVtYnJvID0gdG9OdW1icm87XG5leHBvcnRzLnVuaXhUaW1lID0gdW5peFRpbWU7XG5leHBvcnRzLnV0Y1RpbWUgPSB1dGNUaW1lO1xuZXhwb3J0cy51dGNUaW1lVG9Mb2NhbCA9IHV0Y1RpbWVUb0xvY2FsO1xuZXhwb3J0cy51dGNUaW1lc3RhbXBGcm9tTm93ID0gdXRjVGltZXN0YW1wRnJvbU5vdztcbmV4cG9ydHMudXRjVGltZXN0YW1wVG9EYXRlID0gdXRjVGltZXN0YW1wVG9EYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVycy5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJpbXBvcnQgTG9uZyBmcm9tICdsb25nJztcbmltcG9ydCAnZmFzdC10ZXh0LWVuY29kaW5nJztcbmltcG9ydCBxdWVyeSBmcm9tICdxcyc7XG5cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi9cblxuICBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9O1xuXG4gIHZhciBleHBvcnRzID0ge30sXG4gICAgICBPcCA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LFxuICAgICAgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLFxuICAgICAgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLFxuICAgICAgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITBcbiAgICB9KSwgb2JqW2tleV07XG4gIH1cblxuICB0cnkge1xuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsXG4gICAgICAgIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSxcbiAgICAgICAgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yLl9pbnZva2UgPSBmdW5jdGlvbiAoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgICAgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgICBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG5cbiAgICAgICAgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7XG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7XG4gICAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuXG4gICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7XG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgICB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICAgIHN0YXRlID0gXCJleGVjdXRpbmdcIjtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oaW5uZXJGbiwgc2VsZiwgY29udGV4dCksIGdlbmVyYXRvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICBhcmc6IGZuLmNhbGwob2JqLCBhcmcpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICBhcmc6IGVyclxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbHVlICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICB0aGlzLl9pbnZva2UgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSB7XG4gICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybiAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpKSByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG4gICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDtcbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgIHRyeUxvYzogbG9jc1swXVxuICAgIH07XG4gICAgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbe1xuICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTtcblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6ICEwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSwgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTtcbiAgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuO1xuICB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICBfX2F3YWl0OiBhcmdcbiAgICB9O1xuICB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgIH0pO1xuICB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7XG5cbiAgICByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBmb3IgKDsga2V5cy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgfTtcbiAgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoc2tpcFRlbXBSZXNldCkge1xuICAgICAgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRvbmUgPSAhMDtcbiAgICAgIHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247XG4gICAgICBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSxcbiAgICAgICAgICAgIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgIGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksXG4gICAgICAgICAgICAgIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFicnVwdDogZnVuY3Rpb24gKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTtcbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7XG4gICAgICByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uIChmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYXRjaDogZnVuY3Rpb24gKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH0sIGV4cG9ydHM7XG59XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gY2xvbmVEZWVwQXJyYXlPZk9iaihhcnJheSkge1xuICByZXR1cm4gW10uY29uY2F0KGFycmF5KS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGkpO1xuICB9KTtcbn1cblxudmFyIGNoYXJtYXAgPSAnLjEyMzQ1YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuZnVuY3Rpb24gY2hhcmlkeChjaCkge1xuICB2YXIgaWR4ID0gY2hhcm1hcC5pbmRleE9mKGNoKTtcblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGNoYXJhY3RlcjogJ1wiICsgY2ggKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gZW5jb2RlTmFtZShuYW1lLCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKGxpdHRsZUVuZGlhbiA9PT0gdm9pZCAwKSB7XG4gICAgbGl0dGxlRW5kaWFuID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmFtZSBwYXJhbWV0ZXIgaXMgYSByZXF1aXJlZCBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA+IDEyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBuYW1lIGNhbiBiZSB1cCB0byAxMiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgfVxuXG4gIHZhciBiaXRzdHIgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8PSAxMjsgaSsrKSB7XG4gICAgLy8gcHJvY2VzcyBhbGwgNjQgYml0cyAoZXZlbiBpZiBuYW1lIGlzIHNob3J0KVxuICAgIHZhciBjID0gaSA8IG5hbWUubGVuZ3RoID8gY2hhcmlkeChuYW1lW2ldKSA6IDA7XG4gICAgdmFyIGJpdGxlbiA9IGkgPCAxMiA/IDUgOiA0O1xuICAgIHZhciBiaXRzID0gTnVtYmVyKGMpLnRvU3RyaW5nKDIpO1xuXG4gICAgaWYgKGJpdHMubGVuZ3RoID4gYml0bGVuKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5hbWUgJyArIG5hbWUpO1xuICAgIH1cblxuICAgIGJpdHMgPSAnMCcucmVwZWF0KGJpdGxlbiAtIGJpdHMubGVuZ3RoKSArIGJpdHM7XG4gICAgYml0c3RyICs9IGJpdHM7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcoYml0c3RyLCB0cnVlLCAyKTsgLy8gY29udmVydCB0byBMSVRUTEVfRU5ESUFOXG5cbiAgdmFyIGxlSGV4ID0gJyc7XG4gIHZhciBieXRlcyA9IGxpdHRsZUVuZGlhbiA/IHZhbHVlLnRvQnl0ZXNMRSgpIDogdmFsdWUudG9CeXRlc0JFKCk7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShieXRlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgdmFyIGIgPSBfc3RlcC52YWx1ZTtcbiAgICB2YXIgbiA9IE51bWJlcihiKS50b1N0cmluZygxNik7XG4gICAgbGVIZXggKz0gKG4ubGVuZ3RoID09PSAxID8gJzAnIDogJycpICsgbjtcbiAgfVxuXG4gIHZhciB1bE5hbWUgPSBMb25nLmZyb21TdHJpbmcobGVIZXgsIHRydWUsIDE2KS50b1N0cmluZygpOyAvLyBjb25zb2xlLmxvZygnZW5jb2RlTmFtZScsIG5hbWUsIHZhbHVlLnRvU3RyaW5nKCksIHVsTmFtZS50b1N0cmluZygpLCBKU09OLnN0cmluZ2lmeShiaXRzdHIuc3BsaXQoLyguLi4uLikvKS5zbGljZSgxKSkpXG5cbiAgcmV0dXJuIHVsTmFtZS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gZGVjb2RlTmFtZShlbmNvZGVkTmFtZSwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmIChsaXR0bGVFbmRpYW4gPT09IHZvaWQgMCkge1xuICAgIGxpdHRsZUVuZGlhbiA9IHRydWU7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcoZW5jb2RlZE5hbWUpOyAvLyBjb252ZXJ0IGZyb20gTElUVExFX0VORElBTlxuXG4gIHZhciBiZUhleCA9ICcnO1xuICB2YXIgYnl0ZXMgPSBsaXR0bGVFbmRpYW4gPyB2YWx1ZS50b0J5dGVzTEUoKSA6IHZhbHVlLnRvQnl0ZXNCRSgpO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGJ5dGVzKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICB2YXIgYiA9IF9zdGVwMi52YWx1ZTtcbiAgICB2YXIgbiA9IE51bWJlcihiKS50b1N0cmluZygxNik7XG4gICAgYmVIZXggKz0gKG4ubGVuZ3RoID09PSAxID8gJzAnIDogJycpICsgbjtcbiAgfVxuXG4gIGJlSGV4ICs9ICcwJy5yZXBlYXQoMTYgLSBiZUhleC5sZW5ndGgpO1xuICB2YXIgZml2ZUJpdHMgPSBMb25nLmZyb21OdW1iZXIoMHgxZiwgdHJ1ZSk7XG4gIHZhciBmb3VyQml0cyA9IExvbmcuZnJvbU51bWJlcigweDBmLCB0cnVlKTtcbiAgdmFyIGJlVmFsdWUgPSBMb25nLmZyb21TdHJpbmcoYmVIZXgsIHRydWUsIDE2KTtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgdG1wID0gYmVWYWx1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8PSAxMjsgaSsrKSB7XG4gICAgdmFyIGMgPSBjaGFybWFwW3RtcC5hbmQoaSA9PT0gMCA/IGZvdXJCaXRzIDogZml2ZUJpdHMpXTtcbiAgICBzdHIgPSBjICsgc3RyO1xuICAgIHRtcCA9IHRtcC5zaGlmdFJpZ2h0KGkgPT09IDAgPyA0IDogNSk7XG4gIH1cblxuICBzdHIgPSBzdHIucmVwbGFjZSgvXFwuKyQvLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBkb3RzIChhbGwgb2YgdGhlbSlcbiAgLy8gY29uc29sZS5sb2coJ2RlY29kZU5hbWUnLCBzdHIsIGJlVmFsdWUudG9TdHJpbmcoKSwgdmFsdWUudG9TdHJpbmcoKSwgSlNPTi5zdHJpbmdpZnkoYmVWYWx1ZS50b1N0cmluZygyKS5zcGxpdCgvKC4uLi4uKS8pLnNsaWNlKDEpKSlcblxuICByZXR1cm4gc3RyO1xufVxuLyoqXHJcbiAqIEZJTyBTUEVDSUZJQ1xyXG4gKiBAcGFyYW0ga2V5IEZJT1xyXG4gKi9cblxudmFyIHNob3J0ZW5fa2V5ID0gZnVuY3Rpb24gc2hvcnRlbl9rZXkoa2V5KSB7XG4gIHZhciByZXMgPSBuZXcgTG9uZygwLCAwLCB0cnVlKTtcbiAgdmFyIGkgPSAxOyAvLyBJZ25vcmUga2V5IGhlYWRcblxuICB2YXIgbGVuID0gMDtcblxuICB3aGlsZSAobGVuIDw9IDEyKSB7XG4gICAgaWYgKGkgPj0gMzMpIHRocm93IG5ldyBFcnJvcignRklPOiBpIHRvbyBsYXJnZScpO1xuICAgIHZhciB0cmltbWVkX2NoYXIgPSBrZXlbaV0gJiAobGVuID09IDEyID8gMHgwZiA6IDB4MWYpO1xuXG4gICAgaWYgKHRyaW1tZWRfY2hhciA9PSAwKSB7XG4gICAgICBpKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIFNraXAgYSB6ZXJvIGFuZCBtb3ZlIHRvIG5leHRcblxuXG4gICAgdmFyIHNodWZmbGUgPSBsZW4gPT0gMTIgPyAwIDogNSAqICgxMiAtIGxlbikgLSAxO1xuICAgIHJlcyA9IHJlcy5vcihMb25nLmZyb21OdW1iZXIoc2hpZnQodHJpbW1lZF9jaGFyLCBzaHVmZmxlKSwgdHJ1ZSkpO1xuICAgIGxlbisrO1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBzaGlmdChudW1iZXIsIHNoaWZ0KSB7XG4gIHJldHVybiBudW1iZXIgKiBNYXRoLnBvdygyLCBzaGlmdCk7XG59XG5cbnZhciBmaW9LZXlUb0FjdG9yID0gZnVuY3Rpb24gZmlvS2V5VG9BY3RvcihrZXksIHN0cmluZ1RvUHVibGljS2V5KSB7XG4gIHZhciBwdWJLZXkgPSBzdHJpbmdUb1B1YmxpY0tleShrZXksICdGSU8nKS5kYXRhO1xuICB2YXIgc2hvcnRlbmVkUHViS2V5ID0gc2hvcnRlbl9rZXkocHViS2V5KTtcbiAgdmFyIGRlY29kZWROYW1lID0gZGVjb2RlTmFtZShzaG9ydGVuZWRQdWJLZXkudG9TdHJpbmcoKSwgZmFsc2UpO1xuICByZXR1cm4gZGVjb2RlZE5hbWUuc3Vic3RyKDAsIDEyKTtcbn07IC8vIGNvbnZlcnQgYnl0ZXMgdG8gYSBTdHJpbmdcblxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIHJldHVybiBieXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX2J5dGUpIHtcbiAgICByZXR1cm4gYWNjICsgU3RyaW5nLmZyb21DaGFyQ29kZShfYnl0ZSk7XG4gIH0sICcnKTtcbn1cbi8qKlxyXG4gKiBDaGVja3MgaWYgc3RyaW5nXHJcbiAqL1xuXG5mdW5jdGlvbiBpc1N0cmluZyhzdHJpbmcpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHJpbmcpID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVzc2FnZSBTaGEyNTZcclxuICovXG5cbmZ1bmN0aW9uIHNoYShfeCwgX3gyLCBfeDMpIHtcbiAgcmV0dXJuIF9zaGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8qKlxyXG4gKiBGSU8gZnVuY3Rpb25cclxuICpcclxuICogQHBhcmFtIHN0ciBleGFtcGxlOiBjb2lub21pXHJcbiAqIEByZXR1cm5zIHJldHVybnM6IDk2OGJhODQ2MTdiNzNiOGUyYTczYjU5MTcwOTc2ZjQxXHJcbiAqL1xuXG5mdW5jdGlvbiBfc2hhKCkge1xuICBfc2hhID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKG1lc3NhZ2UsIGJpbmFyeVJlcHJlc2VudGF0aW9uT2ZIZXgsIHR5cGUpIHtcbiAgICB2YXIgZW5jb2RlZE1lc3NhZ2UsIG1hdGNoZWQsIG1hcHBlZCwgaGFzaEJ1ZmZlciwgaGFzaEFycmF5LCBoYXNoSGV4O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChiaW5hcnlSZXByZXNlbnRhdGlvbk9mSGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgYmluYXJ5UmVwcmVzZW50YXRpb25PZkhleCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSAnU0hBLTI1Nic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYmluYXJ5UmVwcmVzZW50YXRpb25PZkhleCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRjaGVkID0gbWVzc2FnZS5tYXRjaCgvW1xcZGEtZl17Mn0vZ2kpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IEVycm9yKCdFbXB0eSBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBtYXBwZWQgPSBtYXRjaGVkLm1hcChmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaCwgMTYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbmNvZGVkTWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1hcHBlZCk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBlbmNvZGVkTWVzc2FnZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShtZXNzYWdlKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kaWdlc3QodHlwZSwgZW5jb2RlZE1lc3NhZ2UpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGhhc2hCdWZmZXIgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgLy8gaGFzaCB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgaGFzaEFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShoYXNoQnVmZmVyKSk7IC8vIGNvbnZlcnQgYnVmZmVyIHRvIGJ5dGUgYXJyYXlcblxuICAgICAgICAgICAgaGFzaEhleCA9IGhhc2hBcnJheS5tYXAoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgICB9KS5qb2luKCcnKTsgLy8gY29udmVydCBieXRlcyB0byBoZXggc3RyaW5nXG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgaGFzaEhleCk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3NoYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdfdG9fdWludDEyOF9oYXNoKF94NCkge1xuICByZXR1cm4gX3N0cmluZ190b191aW50MTI4X2hhc2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3N0cmluZ190b191aW50MTI4X2hhc2goKSB7XG4gIF9zdHJpbmdfdG9fdWludDEyOF9oYXNoID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihzdHIpIHtcbiAgICB2YXIgaGV4Qnl0ZXM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBzaGEoc3RyLCBmYWxzZSwgJ1NIQS0xJyk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBoZXhCeXRlcyA9IF9jb250ZXh0Mi5zZW50Lm1hdGNoKC8uLi9nKTtcblxuICAgICAgICAgICAgaWYgKCFoZXhCeXRlcykge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBoZXhCeXRlcy5zbGljZSgwLCAtNCkucmV2ZXJzZSgpLmpvaW4oJycpKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIDApO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfc3RyaW5nX3RvX3VpbnQxMjhfaGFzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBuYXRpdmVUcmFuc2Zvcm1HZXRBY3Rpb25zKHJlc3VsdCwgY29uc3RhbnRzKSB7XG4gIHJlc3VsdC5hY3Rpb25zID0gcmVzdWx0LmFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICBpZiAoYWN0aW9uWydhY3Rpb25fdHJhY2UnXVsnYWN0J11bJ2FjY291bnQnXSA9PT0gY29uc3RhbnRzLkVPU0lPICYmIGFjdGlvblsnYWN0aW9uX3RyYWNlJ11bJ2FjdCddWyduYW1lJ10gPT09ICdjbGFpbXJld2FyZHMnICYmIGFjdGlvblsnYWN0aW9uX3RyYWNlJ11bJ2lubGluZV90cmFjZXMnXSkge1xuICAgICAgdmFyIHRvdGFsQW1vdW50ID0gMDtcbiAgICAgIHZhciB0b3RhbFN5bWJvbCA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjdGlvblsnYWN0aW9uX3RyYWNlJ11bJ2lubGluZV90cmFjZXMnXSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBpbmxpbmVfdHJhY2UgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICBpZiAoaW5saW5lX3RyYWNlWydhY3QnXVsnZGF0YSddWydmcm9tJ10gPT09IGNvbnN0YW50cy5FT1NJT19WUEFZIHx8IGlubGluZV90cmFjZVsnYWN0J11bJ2RhdGEnXVsnZnJvbSddID09PSBjb25zdGFudHMuRU9TSU9fQlBBWSkge1xuICAgICAgICAgIHZhciBfaW5saW5lX3RyYWNlJGFjdCRkYXQgPSBpbmxpbmVfdHJhY2VbJ2FjdCddWydkYXRhJ11bJ3F1YW50aXR5J10uc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgYW1vdW50ID0gX2lubGluZV90cmFjZSRhY3QkZGF0WzBdLFxuICAgICAgICAgICAgICBzeW1ib2wgPSBfaW5saW5lX3RyYWNlJGFjdCRkYXRbMV07XG5cbiAgICAgICAgICB0b3RhbEFtb3VudCArPSBOdW1iZXIoYW1vdW50KTtcbiAgICAgICAgICB0b3RhbFN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhY3Rpb25bJ2FjdGlvbl90cmFjZSddWydhY3QnXVsnZGF0YSddWydxdWFudGl0eSddID0gdG90YWxBbW91bnQudG9GaXhlZChjb25zdGFudHMuQ09SRV9QUkVDSVNJT04pICsgXCIgXCIgKyB0b3RhbFN5bWJvbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9KS5yZXZlcnNlKCk7XG4gIHJlc3VsdC5udW1PZlR4TG9hZGVkID0gcmVzdWx0LmFjdGlvbnMubGVuZ3RoO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaHlwZXJpb25UcmFuc2Zvcm1HZXRBY3Rpb25zKF9yZWYpIHtcbiAgdmFyIHF1ZXJ5X3RpbWUgPSBfcmVmLnF1ZXJ5X3RpbWUsXG4gICAgICBsaWIgPSBfcmVmLmxpYixcbiAgICAgIGFjdGlvbnMgPSBfcmVmLmFjdGlvbnMsXG4gICAgICBfcmVmJHRvdGFsID0gX3JlZi50b3RhbCxcbiAgICAgIHJlbGF0aW9uID0gX3JlZiR0b3RhbC5yZWxhdGlvbixcbiAgICAgIHZhbHVlID0gX3JlZiR0b3RhbC52YWx1ZTtcbiAgdmFyIHRyYW5zZm9ybWVkQWN0aW9ucyA9IFtdO1xuICB2YXIgYWN0X2RpZ2VzdCA9IDA7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWN0aW9ucyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgdmFyIGFjdGlvbiA9IF9zdGVwMi52YWx1ZTtcbiAgICBhY3Rpb24ucmVjZWlwdCA9IHtcbiAgICAgIGFjdF9kaWdlc3Q6IGFjdF9kaWdlc3QrK1xuICAgIH07XG4gICAgYWN0aW9uLmJsb2NrX3RpbWUgPSBhY3Rpb25bJ0B0aW1lc3RhbXAnXTsgLy8gU2V0IHF1YW50aXR5XG5cbiAgICBpZiAoYWN0aW9uLmFjdC5kYXRhICYmIGFjdGlvbi5hY3QuZGF0YS5hbW91bnQgJiYgYWN0aW9uLmFjdC5kYXRhLnN5bWJvbCkge1xuICAgICAgYWN0aW9uLmFjdC5kYXRhLnF1YW50aXR5ID0gYWN0aW9uLmFjdC5kYXRhLmFtb3VudCArIFwiIFwiICsgYWN0aW9uLmFjdC5kYXRhLnN5bWJvbDtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1lZEFjdGlvbnMucHVzaCh7XG4gICAgICBhY3Rpb25fdHJhY2U6IGFjdGlvblxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaWI6IGxpYixcbiAgICBhY3Rpb25zOiB0cmFuc2Zvcm1lZEFjdGlvbnMsXG4gICAgcXVlcnlfdGltZTogcXVlcnlfdGltZSxcbiAgICBudW1PZlR4TG9hZGVkOiBhY3Rpb25zLmxlbmd0aCxcbiAgICB0b3RhbDoge1xuICAgICAgcmVsYXRpb246IHJlbGF0aW9uLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGZ1c2VUcmFuc2Zvcm1HZXRBY3Rpb25zKF9yZWYyLCBhY2NvdW50TmFtZSwgY29uc3RhbnRzKSB7XG4gIHZhciB0cmFuc2FjdGlvbnMgPSBfcmVmMi50cmFuc2FjdGlvbnMsXG4gICAgICBjdXJzb3IgPSBfcmVmMi5jdXJzb3I7XG5cbiAgLy8gRXJyb3IgY2hlY2tpbmdcbiAgaWYgKCF0cmFuc2FjdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3Vyc29yOiBjdXJzb3IsXG4gICAgICBhY3Rpb25zOiBbXSxcbiAgICAgIG51bU9mVHhMb2FkZWQ6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFjdGlvbnMgPSBbXTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0cmFuc2FjdGlvbnMpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgIHZhciB0cmFuc2FjdGlvbiA9IF9zdGVwMy52YWx1ZTtcbiAgICB2YXIgbGlmZWN5Y2xlID0gdHJhbnNhY3Rpb24ubGlmZWN5Y2xlLFxuICAgICAgICBhY3Rpb25faWR4ID0gdHJhbnNhY3Rpb24uYWN0aW9uX2lkeDsgLy8gR1JBUEhRTCAtPiBET2VzbnQgZ2l2ZSBhY3Rpb25faWR4IHNpbmNlIGl0cyBtYXRjaFxuXG4gICAgaWYgKCFhY3Rpb25faWR4KSB7XG4gICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQobGlmZWN5Y2xlWydleGVjdXRpb25fdHJhY2UnXVsnYWN0aW9uX3RyYWNlcyddLm1hcChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aW9uX3RyYWNlOiBhY3Rpb25cbiAgICAgICAgfTtcbiAgICAgIH0pLnJldmVyc2UoKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudF9pZHggPSAwO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobGlmZWN5Y2xlWydleGVjdXRpb25fdHJhY2UnXVsnYWN0aW9uX3RyYWNlcyddKSwgX3N0ZXA0OyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQoKSkuZG9uZTspIHtcbiAgICAgIHZhciBhY3Rpb25fdHJhY2UgPSBfc3RlcDQudmFsdWU7XG4gICAgICAvLyBGaXggaG9sZXNcbiAgICAgIGlmICghYWN0aW9uX3RyYWNlWydpbmxpbmVfdHJhY2VzJ10pIGFjdGlvbl90cmFjZVsnaW5saW5lX3RyYWNlcyddID0gW107IC8vIEJQIENMQUlNIFJFV0FSRFNcblxuICAgICAgaWYgKGFjdGlvbl90cmFjZVsnYWN0J11bJ2FjY291bnQnXSA9PT0gY29uc3RhbnRzLkVPU0lPICYmIGFjdGlvbl90cmFjZVsnYWN0J11bJ25hbWUnXSA9PT0gJ2NsYWltcmV3YXJkcycpIHtcbiAgICAgICAgdmFyIHRvdGFsQW1vdW50ID0gMDtcbiAgICAgICAgdmFyIHRvdGFsU3ltYm9sID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWN0aW9uX3RyYWNlWydpbmxpbmVfdHJhY2VzJ10pLCBfc3RlcDU7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNSgpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpbmxpbmVfdHJhY2UgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgICBpZiAoaW5saW5lX3RyYWNlWydhY3QnXVsnZGF0YSddWydmcm9tJ10gPT09IGNvbnN0YW50cy5FT1NJT19WUEFZIHx8IGlubGluZV90cmFjZVsnYWN0J11bJ2RhdGEnXVsnZnJvbSddID09PSBjb25zdGFudHMuRU9TSU9fQlBBWSkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgYWN0aW9uX3RyYWNlOiBpbmxpbmVfdHJhY2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgX2lubGluZV90cmFjZSRhY3QkZGF0MiA9IGlubGluZV90cmFjZVsnYWN0J11bJ2RhdGEnXVsncXVhbnRpdHknXS5zcGxpdCgnICcpLFxuICAgICAgICAgICAgICAgIGFtb3VudCA9IF9pbmxpbmVfdHJhY2UkYWN0JGRhdDJbMF0sXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gX2lubGluZV90cmFjZSRhY3QkZGF0MlsxXTtcblxuICAgICAgICAgICAgdG90YWxBbW91bnQgKz0gTnVtYmVyKGFtb3VudCk7XG4gICAgICAgICAgICB0b3RhbFN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhY3Rpb25fdHJhY2VbJ2FjdCddWydkYXRhJ11bJ3F1YW50aXR5J10gPSB0b3RhbEFtb3VudC50b0ZpeGVkKGNvbnN0YW50cy5DT1JFX1BSRUNJU0lPTikgKyBcIiBcIiArIHRvdGFsU3ltYm9sO1xuICAgICAgICBkZWxldGUgYWN0aW9uX3RyYWNlLmlubGluZV90cmFjZXM7XG4gICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgYWN0aW9uX3RyYWNlOiBhY3Rpb25fdHJhY2VcbiAgICAgICAgfSk7IC8vIFJFWCBzZWxsXG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbl90cmFjZVsnYWN0J11bJ2FjY291bnQnXSA9PT0gY29uc3RhbnRzLkVPU0lPICYmIGFjdGlvbl90cmFjZVsnYWN0J11bJ25hbWUnXSA9PT0gJ3NlbGxyZXgnKSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjdGlvbl90cmFjZVsnaW5saW5lX3RyYWNlcyddKSwgX3N0ZXA2OyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYoKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2lubGluZV90cmFjZSA9IF9zdGVwNi52YWx1ZTtcblxuICAgICAgICAgIGlmIChfaW5saW5lX3RyYWNlWydhY3QnXVsnYWNjb3VudCddID09PSBjb25zdGFudHMuRU9TSU9fUkVYIHx8IF9pbmxpbmVfdHJhY2VbJ2FjdCddWyduYW1lJ10gPT09ICdzZWxscmVzdWx0Jykge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgYWN0aW9uX3RyYWNlOiBfaW5saW5lX3RyYWNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgYWN0aW9uX3RyYWNlLmlubGluZV90cmFjZXM7XG4gICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgYWN0aW9uX3RyYWNlOiBhY3Rpb25fdHJhY2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGRvbmUgZm9yIG9yZGVyaW5nIG9mIFRYXG4gICAgICAgIHZhciBsb2NhbF9hY3Rpb25zID0gW107XG4gICAgICAgIGN1cnJlbnRfaWR4ID0gZGZ1c2VFeHRyYWN0QWN0aW9ucyhhY2NvdW50TmFtZSwgYWN0aW9uX3RyYWNlLCBsb2NhbF9hY3Rpb25zLCBhY3Rpb25faWR4LCBjdXJyZW50X2lkeCk7XG4gICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChsb2NhbF9hY3Rpb25zLnJldmVyc2UoKSk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRfaWR4Kys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjdXJzb3I6IGN1cnNvcixcbiAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgIG51bU9mVHhMb2FkZWQ6IHRyYW5zYWN0aW9ucy5sZW5ndGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGZ1c2VFeHRyYWN0QWN0aW9ucyhhY2NvdW50TmFtZSwgYWN0aW9uLCB0cmFjZXMsIGFjdGlvbl9pZHgsIGN1cnJlbnRfaWR4KSB7XG4gIGlmIChhY3Rpb25faWR4LmluY2x1ZGVzKGN1cnJlbnRfaWR4KSkge1xuICAgIHRyYWNlcy5wdXNoKHtcbiAgICAgIGFjdGlvbl90cmFjZTogYWN0aW9uXG4gICAgfSk7XG4gIH1cblxuICBpZiAoYWN0aW9uWydpbmxpbmVfdHJhY2VzJ10pIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY3Rpb25bJ2lubGluZV90cmFjZXMnXSksIF9zdGVwNzsgIShfc3RlcDcgPSBfaXRlcmF0b3I3KCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaW5saW5lX3RyYWNlID0gX3N0ZXA3LnZhbHVlO1xuICAgICAgY3VycmVudF9pZHgrKztcbiAgICAgIGN1cnJlbnRfaWR4ID0gZGZ1c2VFeHRyYWN0QWN0aW9ucyhhY2NvdW50TmFtZSwgaW5saW5lX3RyYWNlLCB0cmFjZXMsIGFjdGlvbl9pZHgsIGN1cnJlbnRfaWR4KTtcbiAgICB9XG5cbiAgICBkZWxldGUgYWN0aW9uWydpbmxpbmVfdHJhY2VzJ107XG4gIH1cblxuICByZXR1cm4gY3VycmVudF9pZHg7XG59XG5cbmZ1bmN0aW9uIGRmdXNlRGVwdGhGaXJzdEV4dHJhY3QocmVzdWx0KSB7XG4gIHZhciB0cmFuc2FjdGlvbnMgPSByZXN1bHQudHJhbnNhY3Rpb25zLFxuICAgICAgY3Vyc29yID0gcmVzdWx0LmN1cnNvcjtcbiAgdmFyIGFjdGlvbnMgPSBbXTtcblxuICBpZiAodHJhbnNhY3Rpb25zKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodHJhbnNhY3Rpb25zKSwgX3N0ZXA4OyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgoKSkuZG9uZTspIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IF9zdGVwOC52YWx1ZTtcbiAgICAgIHZhciBsaWZlY3ljbGUgPSB0cmFuc2FjdGlvbi5saWZlY3ljbGUsXG4gICAgICAgICAgYWN0aW9uX2lkeCA9IHRyYW5zYWN0aW9uLmFjdGlvbl9pZHg7XG4gICAgICB2YXIgdHJhY2VzID0gbGlmZWN5Y2xlWydleGVjdXRpb25fdHJhY2UnXVsnYWN0aW9uX3RyYWNlcyddO1xuICAgICAgdmFyIGN1cnJlbnRfaWR4ID0gMDtcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodHJhY2VzKSwgX3N0ZXA5OyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHRyYWNlID0gX3N0ZXA5LnZhbHVlO1xuICAgICAgICBjdXJyZW50X2lkeCA9IGRmdXNlRGVwdGhGaXJzdEV4dHJhY3RIZWxwZXIodHJhY2UsIGxpZmVjeWNsZVsnZGJvcHMnXSwgYWN0aW9ucywgYWN0aW9uX2lkeCwgY3VycmVudF9pZHgpO1xuICAgICAgICBjdXJyZW50X2lkeCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICBjdXJzb3I6IGN1cnNvclxuICB9O1xufVxuXG5mdW5jdGlvbiBkZnVzZURlcHRoRmlyc3RFeHRyYWN0SGVscGVyKGFjdGlvbiwgZGJvcHMsIGFsbEFjdGlvbnMsIGFjdGlvbl9pZHgsIGN1cnJlbnRJZHgpIHtcbiAgaWYgKGFjdGlvbl9pZHggJiYgYWN0aW9uX2lkeC5pbmNsdWRlcyhjdXJyZW50SWR4KSkge1xuICAgIGFsbEFjdGlvbnMucHVzaCh7XG4gICAgICBhY3Rpb25fdHJhY2U6IGFjdGlvbixcbiAgICAgIGRib3BzOiBkYm9wcy5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgIHJldHVybiBvcC5hY3Rpb25faWR4ID09PSBjdXJyZW50SWR4O1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhY3Rpb25bJ2lubGluZV90cmFjZXMnXSkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjEwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY3Rpb25bJ2lubGluZV90cmFjZXMnXSksIF9zdGVwMTA7ICEoX3N0ZXAxMCA9IF9pdGVyYXRvcjEwKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdHJhY2UgPSBfc3RlcDEwLnZhbHVlO1xuICAgICAgY3VycmVudElkeCA9IGRmdXNlRGVwdGhGaXJzdEV4dHJhY3RIZWxwZXIodHJhY2UsIGRib3BzLCBhbGxBY3Rpb25zLCBhY3Rpb25faWR4LCArK2N1cnJlbnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50SWR4O1xufVxuXG5mdW5jdGlvbiBoeXBlcmlvblRyYW5zZm9ybUZsYXRUcmFjZXModHJhY2VzKSB7XG4gIHZhciB0cmFjZXNCeU9yZGluYWwgPSB0cmFjZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHRyYWNlKSB7XG4gICAgYWNjW3RyYWNlLmFjdGlvbl9vcmRpbmFsXSA9IF9leHRlbmRzKHt9LCB0cmFjZSwge1xuICAgICAgdHJhY2VzOiBbXSxcbiAgICAgIGFjY291bnRfcmFtX2RlbHRhczogdHJhY2UuYWNjb3VudF9yYW1fZGVsdGFzLFxuICAgICAgcmVjZWl2ZXJzOiB0cmFjZS5ub3RpZmllZFxuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IxMSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodHJhY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hY3Rpb25fb3JkaW5hbCAtIGEuYWN0aW9uX29yZGluYWw7XG4gIH0pKSwgX3N0ZXAxMTsgIShfc3RlcDExID0gX2l0ZXJhdG9yMTEoKSkuZG9uZTspIHtcbiAgICB2YXIgdHJhY2UgPSBfc3RlcDExLnZhbHVlO1xuXG4gICAgLy8gU2tpcCB0b3AgbGV2ZWwgYWN0aW9uc1xuICAgIGlmICh0cmFjZS5jcmVhdG9yX2FjdGlvbl9vcmRpbmFsID09PSAwIHx8ICF0cmFjZXNCeU9yZGluYWxbdHJhY2UuY3JlYXRvcl9hY3Rpb25fb3JkaW5hbF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SW5saW5lVHJhY2VzID0gdHJhY2VzQnlPcmRpbmFsW3RyYWNlLmNyZWF0b3JfYWN0aW9uX29yZGluYWxdLnRyYWNlcyB8fCBbXTtcbiAgICB2YXIgbmV3SW5saW5lVHJhY2VzID0gW3RyYWNlc0J5T3JkaW5hbFt0cmFjZS5hY3Rpb25fb3JkaW5hbF1dO1xuICAgIGRlbGV0ZSB0cmFjZXNCeU9yZGluYWxbdHJhY2UuYWN0aW9uX29yZGluYWxdO1xuICAgIHRyYWNlc0J5T3JkaW5hbFt0cmFjZS5jcmVhdG9yX2FjdGlvbl9vcmRpbmFsXS50cmFjZXMgPSBuZXdJbmxpbmVUcmFjZXMuY29uY2F0KGN1cnJlbnRJbmxpbmVUcmFjZXMpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IE9iamVjdC52YWx1ZXModHJhY2VzQnlPcmRpbmFsKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGh5cGVyaW9uVHJhbnNmb3JtVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgdmFyIGFjdGlvbnMgPSB0cmFuc2FjdGlvbi5hY3Rpb25zLFxuICAgICAgbGliID0gdHJhbnNhY3Rpb24ubGliLFxuICAgICAgdHJ4X2lkID0gdHJhbnNhY3Rpb24udHJ4X2lkO1xuICB2YXIgZmlyc3RBY3Rpb24gPSBhY3Rpb25zWzBdOyAvLyBQYXJlbnQgb25seSBvbiA8IDEuOFxuXG4gIHZhciB0cmFuc2Zvcm1lZEFjdGlvbnMgPSBmaXJzdEFjdGlvbi5wYXJlbnQgPyBhY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAodHJhY2UpIHtcbiAgICByZXR1cm4gdHJhY2UucGFyZW50ID09PSAwO1xuICB9KSA6IGFjdGlvbnM7XG4gIHZhciB0cmFjZXMgPSBoeXBlcmlvblRyYW5zZm9ybUZsYXRUcmFjZXMoYWN0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiAnRXhlY3V0ZWQnLFxuICAgIGNwdV91c2FnZTogZmlyc3RBY3Rpb24uY3B1X3VzYWdlX3VzLFxuICAgIG5ldF91c2FnZTogZmlyc3RBY3Rpb24ubmV0X3VzYWdlX3dvcmRzICogOCxcbiAgICBpZDogdHJ4X2lkLFxuICAgIGJsb2NrX3RpbWU6IGZpcnN0QWN0aW9uWydAdGltZXN0YW1wJ10sXG4gICAgYmxvY2tfbnVtOiBmaXJzdEFjdGlvblsnYmxvY2tfbnVtJ10sXG4gICAgZGVsYXlfc2VjOiAnTi9BJyxcbiAgICBleHBpcmF0aW9uOiAnTi9BJyxcbiAgICBsaWI6IGxpYixcbiAgICBhY3Rpb25zOiB0cmFuc2Zvcm1lZEFjdGlvbnMsXG4gICAgdHJhY2VzOiB0cmFjZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGRmdXNlVHJhbnNmb3JtVHJhY2UoX3JlZjMpIHtcbiAgdmFyIHRyYWNlID0gX3JlZjMudHJhY2UsXG4gICAgICBfcmVmMyRkYm9wcyA9IF9yZWYzLmRib3BzLFxuICAgICAgZGJvcHMgPSBfcmVmMyRkYm9wcyA9PT0gdm9pZCAwID8gW10gOiBfcmVmMyRkYm9wcyxcbiAgICAgIF9yZWYzJHJhbW9wcyA9IF9yZWYzLnJhbW9wcyxcbiAgICAgIHJhbW9wcyA9IF9yZWYzJHJhbW9wcyA9PT0gdm9pZCAwID8gW10gOiBfcmVmMyRyYW1vcHMsXG4gICAgICBfcmVmMyRpbmRleCA9IF9yZWYzLmluZGV4LFxuICAgICAgaW5kZXggPSBfcmVmMyRpbmRleCA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJGluZGV4O1xuICB2YXIgdHJhbnNmb3JtZWQgPSB7XG4gICAgYWN0OiB0cmFjZS5hY3QsXG4gICAgYWNjb3VudF9yYW1fZGVsdGFzOiB0cmFjZS5hY2NvdW50X3JhbV9kZWx0YXMsXG4gICAgcmVjZWl2ZXJzOiBbdHJhY2UucmVjZWlwdC5yZWNlaXZlcl0sXG4gICAgYWN0X2RpZ2VzdDogdHJhY2UucmVjZWlwdC5hY3RfZGlnZXN0LFxuICAgIGRib3BzOiAoZGJvcHMgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAob3ApIHtcbiAgICAgIHJldHVybiBvcC5hY3Rpb25faWR4ID09PSBpbmRleDtcbiAgICB9KSxcbiAgICByYW1vcHM6IChyYW1vcHMgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAob3ApIHtcbiAgICAgIHJldHVybiBvcC5hY3Rpb25faWR4ID09PSBpbmRleDtcbiAgICB9KSxcbiAgICB0cmFjZXM6IFtdXG4gIH07XG5cbiAgaWYgKHRyYWNlLmlubGluZV90cmFjZXMgJiYgdHJhY2UuaW5saW5lX3RyYWNlcy5sZW5ndGgpIHtcbiAgICB0cmFjZS5pbmxpbmVfdHJhY2VzLm1hcChmdW5jdGlvbiAoaXRyYWNlKSB7XG4gICAgICBpbmRleCsrOyAvLyBJZiBUWCBkYXRhIGlzIGRpZmZlcmVudFxuXG4gICAgICBpZiAoaXRyYWNlLmFjdC5oZXhfZGF0YSAhPT0gdHJhbnNmb3JtZWQuYWN0LmhleF9kYXRhIHx8IGl0cmFjZS5hY3QubmFtZSAhPT0gdHJhbnNmb3JtZWQuYWN0Lm5hbWUgfHwgaXRyYWNlLmFjdC5hY2NvdW50ICE9PSB0cmFuc2Zvcm1lZC5hY3QuYWNjb3VudCkge1xuICAgICAgICB0cmFuc2Zvcm1lZC50cmFjZXMucHVzaChkZnVzZVRyYW5zZm9ybVRyYWNlKHtcbiAgICAgICAgICB0cmFjZTogaXRyYWNlLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICByYW1vcHM6IHJhbW9wcyxcbiAgICAgICAgICBkYm9wczogZGJvcHNcbiAgICAgICAgfSkpOyAvLyBIZXggZGF0YSBpcyBzYW1lLCBidXQgc3RpbGwgYWRkIGluIGlubGluZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0cmFjZS5pbmxpbmVfdHJhY2VzICYmIGl0cmFjZS5pbmxpbmVfdHJhY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShpdHJhY2UuaW5saW5lX3RyYWNlcyksIF9zdGVwMTI7ICEoX3N0ZXAxMiA9IF9pdGVyYXRvcjEyKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgaWl0cmFjZSA9IF9zdGVwMTIudmFsdWU7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWQudHJhY2VzLnB1c2goZGZ1c2VUcmFuc2Zvcm1UcmFjZSh7XG4gICAgICAgICAgICAgIHRyYWNlOiBpaXRyYWNlLFxuICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIHJhbW9wczogcmFtb3BzLFxuICAgICAgICAgICAgICBkYm9wczogZGJvcHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQWRkIFJlY2VpdmVycyBldmVuIGlmIG5vdCBkaWZmZXJlbnRcblxuXG4gICAgICAgIGlmICghdHJhbnNmb3JtZWQucmVjZWl2ZXJzLmluY2x1ZGVzKGl0cmFjZS5yZWNlaXB0LnJlY2VpdmVyKSkge1xuICAgICAgICAgIHRyYW5zZm9ybWVkLnJlY2VpdmVycy5wdXNoKGl0cmFjZS5yZWNlaXB0LnJlY2VpdmVyKTtcbiAgICAgICAgfSAvLyBBZGQgZGIgb3BzIGFuZCByYW0gb3BzIGV2ZW4gaWYgbm90IGRpZmZlcmVudFxuXG5cbiAgICAgICAgdHJhbnNmb3JtZWQuZGJvcHMgPSB0cmFuc2Zvcm1lZC5kYm9wcy5jb25jYXQoKGRib3BzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgcmV0dXJuIG9wLmFjdGlvbl9pZHggPT09IGluZGV4O1xuICAgICAgICB9KSk7XG4gICAgICAgIHRyYW5zZm9ybWVkLnJhbW9wcyA9IHRyYW5zZm9ybWVkLnJhbW9wcy5jb25jYXQoKHJhbW9wcyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgIHJldHVybiBvcC5hY3Rpb25faWR4ID09PSBpbmRleDtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zZm9ybWVkO1xufVxuZnVuY3Rpb24gZGZ1c2VUcmFuc2Zvcm1UcmFuc2FjdGlvbihyZXN1bHQpIHtcbiAgdmFyIGV4ZWN1dGlvbl90cmFjZSA9IHJlc3VsdC5leGVjdXRpb25fdHJhY2UsXG4gICAgICB0cmFuc2FjdGlvbiA9IHJlc3VsdC50cmFuc2FjdGlvbixcbiAgICAgIHJhbW9wcyA9IHJlc3VsdC5yYW1vcHMsXG4gICAgICBkYm9wcyA9IHJlc3VsdC5kYm9wcyxcbiAgICAgIGNyZWF0ZWRfYnkgPSByZXN1bHQuY3JlYXRlZF9ieTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGFjdGlvbnMgPSAoZXhlY3V0aW9uX3RyYWNlWydhY3Rpb25fdHJhY2VzJ10gfHwgW10pLm1hcChmdW5jdGlvbiAodHJhY2UpIHtcbiAgICB2YXIgdHJhbnNmb3JtZWRUcmFjZSA9IGRmdXNlVHJhbnNmb3JtVHJhY2Uoe1xuICAgICAgdHJhY2U6IHRyYWNlLFxuICAgICAgcmFtb3BzOiByYW1vcHMsXG4gICAgICBkYm9wczogZGJvcHMsXG4gICAgICBpbmRleDogY291bnRcbiAgICB9KTsgLy8gSW5jcmVtZW50IGNvdW50c1xuXG4gICAgdmFyIHRyYWNlQ291bnQgPSBpbmxpbmVUcmFjZUNvdW50SGVscGVyKFt0cmFjZV0pO1xuICAgIGNvdW50ICs9IHRyYWNlQ291bnQ7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkVHJhY2U7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogZXhlY3V0aW9uX3RyYWNlLnJlY2VpcHQuc3RhdHVzLFxuICAgIGNwdV91c2FnZTogZXhlY3V0aW9uX3RyYWNlLnJlY2VpcHQuY3B1X3VzYWdlX3VzLFxuICAgIG5ldF91c2FnZTogZXhlY3V0aW9uX3RyYWNlLnJlY2VpcHQubmV0X3VzYWdlX3dvcmRzICogOCxcbiAgICBpZDogZXhlY3V0aW9uX3RyYWNlLmlkLFxuICAgIGJsb2NrX3RpbWU6IGV4ZWN1dGlvbl90cmFjZS5ibG9ja190aW1lLFxuICAgIGJsb2NrX251bTogZXhlY3V0aW9uX3RyYWNlLmJsb2NrX251bSxcbiAgICBkZWxheV9zZWM6IHRyYW5zYWN0aW9uLmRlbGF5X3NlYyxcbiAgICBleHBpcmF0aW9uOiB0cmFuc2FjdGlvbi5leHBpcmF0aW9uLFxuICAgIGNyZWF0ZWRfYnk6IGNyZWF0ZWRfYnksXG4gICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICB0cmFjZXM6IGFjdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGRmdXNlVHJhbnNmb3JtRGVmZXJyZWRBY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgYWN0OiBfZXh0ZW5kcyh7fSwgYWN0aW9uKSxcbiAgICBhY2NvdW50X3JhbV9kZWx0YXM6IFtdLFxuICAgIHJlY2VpdmVyczogW10sXG4gICAgYWN0X2RpZ2VzdDogJycsXG4gICAgdHJhY2VzOiBbXVxuICB9O1xufVxuZnVuY3Rpb24gZGZ1c2VUcmFuc2Zvcm1EZWZlcnJlZFRyYW5zYWN0aW9uKHJlc3VsdCkge1xuICB2YXIgYWN0aW9ucyA9IHJlc3VsdC50cmFuc2FjdGlvbi5hY3Rpb25zLm1hcChkZnVzZVRyYW5zZm9ybURlZmVycmVkQWN0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogcmVzdWx0LmlkLFxuICAgIHN0YXR1czogJ2RlZmVycmVkJyxcbiAgICBkZnVzZV9zdGF0dXM6IHJlc3VsdC50cmFuc2FjdGlvbl9zdGF0dXMsXG4gICAgc2VuZGVyOiByZXN1bHQuY3JlYXRlZF9ieS5zZW5kZXIsXG4gICAgcGF5ZXI6IHJlc3VsdC5jcmVhdGVkX2J5LnBheWVyLFxuICAgIHB1Ymxpc2hlZDogcmVzdWx0LmNyZWF0ZWRfYnkucHVibGlzaGVkX2F0LFxuICAgIGRlbGF5X3VudGlsOiByZXN1bHQuY3JlYXRlZF9ieS5kZWxheV91bnRpbCxcbiAgICBleHBpcmF0aW9uOiByZXN1bHQudHJhbnNhY3Rpb24uZXhwaXJhdGlvbixcbiAgICBkZWxheV9zZWM6IHJlc3VsdC50cmFuc2FjdGlvbi5kZWxheV9zZWMsXG4gICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICB0cmFjZXM6IGFjdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGRmdXNlVHJhbnNmb3JtVHJhbnNhY3Rpb25SZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQuZXhlY3V0aW9uX3RyYWNlID8gZGZ1c2VUcmFuc2Zvcm1UcmFuc2FjdGlvbihyZXN1bHQpIDogZGZ1c2VUcmFuc2Zvcm1EZWZlcnJlZFRyYW5zYWN0aW9uKHJlc3VsdCk7XG59XG5mdW5jdGlvbiBoaXN0b3J5VHJhbnNmb3JtRGVmZXJyZWRBY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgYWN0aW9uLCB7XG4gICAgYWNjb3VudF9yYW1fZGVsdGFzOiBbXSxcbiAgICByZWNlaXZlcjogJycsXG4gICAgYWN0X2RpZ2VzdDogJycsXG4gICAgdHJhY2VzOiBbXVxuICB9KTtcbn1cbmZ1bmN0aW9uIGhpc3RvcnlUcmFuc2Zvcm1EZWZlcnJlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IHRyYW5zYWN0aW9uLnRyeF9pZCxcbiAgICBzdGF0dXM6ICdkZWZlcnJlZCcsXG4gICAgc2VuZGVyOiB0cmFuc2FjdGlvbi5zZW5kZXIsXG4gICAgcGF5ZXI6IHRyYW5zYWN0aW9uLnBheWVyLFxuICAgIHB1Ymxpc2hlZDogdHJhbnNhY3Rpb24ucHVibGlzaGVkLFxuICAgIGV4cGlyYXRpb246IHRyYW5zYWN0aW9uLmV4cGlyYXRpb24sXG4gICAgZGVsYXlfdW50aWw6IHRyYW5zYWN0aW9uLmRlbGF5X3VudGlsLFxuICAgIGRlbGF5X3NlYzogdHJhbnNhY3Rpb24udHJhbnNhY3Rpb24uZGVsYXlfc2VjLFxuICAgIGFjdGlvbnM6IHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uLmFjdGlvbnMsXG4gICAgdHJhY2VzOiB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbi5hY3Rpb25zLm1hcChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeVRyYW5zZm9ybURlZmVycmVkQWN0aW9uKGFjdGlvbik7XG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGhpc3RvcnlUcmFuc2Zvcm1SZWN1cnNpdmVUcmFjZShhY3Rpb24pIHtcbiAgdmFyIHRyYW5zZm9ybWVkID0ge1xuICAgIGFjdDogYWN0aW9uLmFjdCxcbiAgICBhY2NvdW50X3JhbV9kZWx0YXM6IGFjdGlvbi5hY2NvdW50X3JhbV9kZWx0YXMgfHwgW10sXG4gICAgcmVjZWl2ZXJzOiBbYWN0aW9uLnJlY2VpcHQucmVjZWl2ZXJdLFxuICAgIGFjdF9kaWdlc3Q6IGFjdGlvbi5yZWNlaXB0LmFjdF9kaWdlc3QsXG4gICAgdHJhY2VzOiBbXVxuICB9O1xuXG4gIGlmIChhY3Rpb24uaW5saW5lX3RyYWNlcyAmJiBhY3Rpb24uaW5saW5lX3RyYWNlcy5sZW5ndGgpIHtcbiAgICBhY3Rpb24uaW5saW5lX3RyYWNlcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjZSkge1xuICAgICAgdmFyIHNhbWVBc1BhcmVudCA9IHRyYWNlLnJlY2VpcHQuYWN0X2RpZ2VzdCA9PT0gYWN0aW9uLnJlY2VpcHQuYWN0X2RpZ2VzdDsgLy8gQWN0aW9ucyBkb25lIGluIHJlc3BvbnNlIHRvIG5vdGlmaWNhdGlvbiAtPiBBZGQgaW4gaW5saW5lIHRyYWNlc1xuXG4gICAgICBpZiAoc2FtZUFzUGFyZW50ICYmIHRyYWNlLmlubGluZV90cmFjZXMgJiYgdHJhY2UuaW5saW5lX3RyYWNlcy5sZW5ndGgpIHtcbiAgICAgICAgdHJhbnNmb3JtZWQudHJhY2VzID0gdHJhbnNmb3JtZWQudHJhY2VzLmNvbmNhdCh0cmFjZS5pbmxpbmVfdHJhY2VzLm1hcChoaXN0b3J5VHJhbnNmb3JtUmVjdXJzaXZlVHJhY2UpKTtcblxuICAgICAgICBpZiAoIXRyYW5zZm9ybWVkLnJlY2VpdmVycy5pbmNsdWRlcyh0cmFjZS5yZWNlaXB0LnJlY2VpdmVyKSkge1xuICAgICAgICAgIHRyYW5zZm9ybWVkLnJlY2VpdmVycy5wdXNoKHRyYWNlLnJlY2VpcHQucmVjZWl2ZXIpO1xuICAgICAgICB9IC8vIE5vcm1hbCBhY3Rpb25cblxuICAgICAgfSBlbHNlIGlmICghc2FtZUFzUGFyZW50KSB7XG4gICAgICAgIHRyYW5zZm9ybWVkLnRyYWNlcy5wdXNoKGhpc3RvcnlUcmFuc2Zvcm1SZWN1cnNpdmVUcmFjZSh0cmFjZSkpOyAvLyBOb3JtYWwgbm90aWZpY2F0aW9uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRyYW5zZm9ybWVkLnJlY2VpdmVycy5pbmNsdWRlcyh0cmFjZS5yZWNlaXB0LnJlY2VpdmVyKSkge1xuICAgICAgICAgIHRyYW5zZm9ybWVkLnJlY2VpdmVycy5wdXNoKHRyYWNlLnJlY2VpcHQucmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtZWQ7XG59XG5mdW5jdGlvbiBoaXN0b3J5VHJhbnNmb3JtRmxhdFRyYWNlcyh0cmFjZXMpIHtcbiAgdmFyIHRyYWNlc0J5T3JkaW5hbCA9IHRyYWNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHJhY2UpIHtcbiAgICBhY2NbdHJhY2UuYWN0aW9uX29yZGluYWxdID0gdHJhY2U7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvcjEzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0cmFjZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFjdGlvbl9vcmRpbmFsIC0gYS5hY3Rpb25fb3JkaW5hbDtcbiAgfSkpLCBfc3RlcDEzOyAhKF9zdGVwMTMgPSBfaXRlcmF0b3IxMygpKS5kb25lOykge1xuICAgIHZhciB0cmFjZSA9IF9zdGVwMTMudmFsdWU7XG5cbiAgICAvLyBTa2lwIHRvcCBsZXZlbCBhY3Rpb25zXG4gICAgaWYgKHRyYWNlLmNyZWF0b3JfYWN0aW9uX29yZGluYWwgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SW5saW5lVHJhY2VzID0gdHJhY2VzQnlPcmRpbmFsW3RyYWNlLmNyZWF0b3JfYWN0aW9uX29yZGluYWxdLmlubGluZV90cmFjZXMgfHwgW107XG4gICAgdmFyIG5ld0lubGluZVRyYWNlcyA9IFt0cmFjZXNCeU9yZGluYWxbdHJhY2UuYWN0aW9uX29yZGluYWxdXTtcbiAgICB0cmFjZXNCeU9yZGluYWxbdHJhY2UuY3JlYXRvcl9hY3Rpb25fb3JkaW5hbF0uaW5saW5lX3RyYWNlcyA9IG5ld0lubGluZVRyYWNlcy5jb25jYXQoY3VycmVudElubGluZVRyYWNlcyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gT2JqZWN0LnZhbHVlcyh0cmFjZXNCeU9yZGluYWwpLmZpbHRlcihmdW5jdGlvbiAodHJhY2UpIHtcbiAgICByZXR1cm4gdHJhY2UuY3JlYXRvcl9hY3Rpb25fb3JkaW5hbCA9PT0gMDtcbiAgfSkubWFwKGZ1bmN0aW9uICh0cmFjZSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdHJhY2UsIHtcbiAgICAgIHJlY2VpdmVyczogW3RyYWNlLnJlY2VpcHQucmVjZWl2ZXJdLFxuICAgICAgYWN0X2RpZ2VzdDogdHJhY2UucmVjZWlwdC5hY3RfZGlnZXN0XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kSWZTYW1lVHgoaW5saW5lX3RyYWNlcywgYWN0KSB7XG4gIHZhciBtYXRjaCA9IGZhbHNlO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvcjE0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShpbmxpbmVfdHJhY2VzKSwgX3N0ZXAxNDsgIShfc3RlcDE0ID0gX2l0ZXJhdG9yMTQoKSkuZG9uZTspIHtcbiAgICB2YXIgdHJhY2UgPSBfc3RlcDE0LnZhbHVlO1xuXG4gICAgaWYgKHRyYWNlLmFjdC5oZXhfZGF0YSA9PT0gYWN0LmhleF9kYXRhICYmIHRyYWNlLmFjdC5uYW1lID09PSBhY3QubmFtZSAmJiB0cmFjZS5hY3QuYWNjb3VudCA9PT0gYWN0LmFjY291bnQgfHwgZmluZElmU2FtZVR4KHRyYWNlLmlubGluZV90cmFjZXMsIGFjdCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuZnVuY3Rpb24gaW5saW5lVHJhY2VDb3VudEhlbHBlcih0cmFjZXMpIHtcbiAgcmV0dXJuIHRyYWNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHJhY2UpIHtcbiAgICByZXR1cm4gYWNjICsgMSArIGlubGluZVRyYWNlQ291bnRIZWxwZXIodHJhY2UuaW5saW5lX3RyYWNlcyB8fCBbXSk7XG4gIH0sIDApO1xufVxuXG5mdW5jdGlvbiBoaXN0b3J5VHJhbnNmb3JtVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uLnRyeCkge1xuICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgdmFyIGRlbGF5X3NlYztcbiAgICB2YXIgZXhwaXJhdGlvbjtcbiAgICB2YXIgdHJhY2VzOyAvLyA+PSAxLjggdHJhY2VzXG5cbiAgICBpZiAodHJhbnNhY3Rpb24udHJhY2VzICYmIHRyYW5zYWN0aW9uLnRyYWNlcy5sZW5ndGggJiYgJ2NyZWF0b3JfYWN0aW9uX29yZGluYWwnIGluIHRyYW5zYWN0aW9uLnRyYWNlc1swXSkge1xuICAgICAgdHJhY2VzID0gaGlzdG9yeVRyYW5zZm9ybUZsYXRUcmFjZXModHJhbnNhY3Rpb24udHJhY2VzKS5tYXAoaGlzdG9yeVRyYW5zZm9ybVJlY3Vyc2l2ZVRyYWNlKTtcbiAgICAgIGFjdGlvbnMgPSB0cmFuc2FjdGlvbi50cmFjZXMuZmlsdGVyKGZ1bmN0aW9uICh0cmFjZSkge1xuICAgICAgICByZXR1cm4gdHJhY2UuY3JlYXRvcl9hY3Rpb25fb3JkaW5hbCA9PT0gMDtcbiAgICAgIH0pOyAvLyAxLjcgYW5kIHVuZGVyIG5vZGVvc1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdmFyIF9zdGVwMTUkdmFsdWUgPSBfc3RlcDE1LnZhbHVlLFxuICAgICAgICAgICAgaSA9IF9zdGVwMTUkdmFsdWVbMF0sXG4gICAgICAgICAgICBhY3Rpb24gPSBfc3RlcDE1JHZhbHVlWzFdO1xuICAgICAgICB2YXIgdGVtcFRyYWNlcyA9IHRyYW5zYWN0aW9uLnRyYWNlcy5zbGljZSgpO1xuICAgICAgICB0ZW1wVHJhY2VzLnNwbGljZShpLCBpICsgMSk7XG4gICAgICAgIHZhciBmb3VuZFNhbWVIZXggPSB0ZW1wVHJhY2VzLmZpbmQoZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRJZlNhbWVUeCh0cmFjZS5pbmxpbmVfdHJhY2VzLnNsaWNlKCksIGFjdGlvbi5hY3QpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWZvdW5kU2FtZUhleCkge1xuICAgICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodHJhbnNhY3Rpb24udHJhY2VzLmVudHJpZXMoKSksIF9zdGVwMTU7ICEoX3N0ZXAxNSA9IF9pdGVyYXRvcjE1KCkpLmRvbmU7KSB7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG5cbiAgICAgIHRyYWNlcyA9IGFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGhpc3RvcnlUcmFuc2Zvcm1SZWN1cnNpdmVUcmFjZShhY3Rpb24pO1xuICAgICAgfSk7IC8vIE5vcm1hbCBub3QgZGVmZXJyZWQgVFhcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnRyeC50cngpIHtcbiAgICAgICAgZGVsYXlfc2VjID0gdHJhbnNhY3Rpb24udHJ4LnRyeC5kZWxheV9zZWM7XG4gICAgICAgIGV4cGlyYXRpb24gPSB0cmFuc2FjdGlvbi50cngudHJ4LmV4cGlyYXRpb247IC8vIERlZmVycmVkIFRYXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxheV9zZWMgPSAnTi9BJztcbiAgICAgICAgZXhwaXJhdGlvbiA9ICdOL0EnO1xuICAgICAgfSAvLyBGaXggZm9yIGVtcHR5IGFycmF5IChoZXggZGF0YSBmdWNrZWQgdXApIFdURj9cblxuXG4gICAgICBpZiAodHJhbnNhY3Rpb24udHJhY2VzLmxlbmd0aCA+IDAgJiYgYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYWN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodHJhbnNhY3Rpb24udHJhY2VzKSwgX3N0ZXAxNjsgIShfc3RlcDE2ID0gX2l0ZXJhdG9yMTYoKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3R4ID0gX3N0ZXAxNi52YWx1ZTtcblxuICAgICAgICAgIGlmIChpID49IGNvdW50ZXIpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChfdHgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvdW50ZXIgKz0gaW5saW5lVHJhY2VDb3VudEhlbHBlcihfdHguaW5saW5lX3RyYWNlcyk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhY2VzID0gYWN0aW9ucy5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBoaXN0b3J5VHJhbnNmb3JtUmVjdXJzaXZlVHJhY2UoYWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIEZpeCBmb3IgZW1wdHkgdHJhY2UgKGJsb2NrIGhpbnQgdXNlZD8pXG5cblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnRyYWNlcy5sZW5ndGggPT09IDAgJiYgYWN0aW9ucy5sZW5ndGggPT09IDAgJiYgdHJhbnNhY3Rpb24udHJ4LnRyeCAmJiB0cmFuc2FjdGlvbi50cngudHJ4LmFjdGlvbnMgJiYgdHJhbnNhY3Rpb24udHJ4LnRyeC5hY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICB0cmFjZXMgPSB0cmFuc2FjdGlvbi50cngudHJ4LmFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0OiBhY3Rpb24sXG4gICAgICAgICAgICBhY2NvdW50X3JhbV9kZWx0YXM6IFtdLFxuICAgICAgICAgICAgcmVjZWl2ZXJzOiBhY3Rpb24uYXV0aG9yaXphdGlvbi5tYXAoZnVuY3Rpb24gKGF1dGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF1dGguYWN0b3I7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdF9kaWdlc3Q6ICcnLFxuICAgICAgICAgICAgdHJhY2VzOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhY3Rpb25zID0gdHJhY2VzO1xuICAgICAgfVxuICAgIH0gLy8gRm9yIGRpc3BsYXlcblxuXG4gICAgdmFyIGV4dHJhRmllbGRzID0gX2V4dGVuZHMoe30sIHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi50cngucmVjZWlwdCwgdHJhbnNhY3Rpb24udHJ4LnRyeCB8fCB7fSk7XG5cbiAgICB2YXIgdHggPSBfZXh0ZW5kcyh7fSwgZXh0cmFGaWVsZHMsIHtcbiAgICAgIHN0YXR1czogdHJhbnNhY3Rpb24udHJ4LnJlY2VpcHQuc3RhdHVzLFxuICAgICAgY3B1X3VzYWdlOiB0cmFuc2FjdGlvbi50cngucmVjZWlwdC5jcHVfdXNhZ2VfdXMsXG4gICAgICBuZXRfdXNhZ2U6IHRyYW5zYWN0aW9uLnRyeC5yZWNlaXB0Lm5ldF91c2FnZV93b3JkcyAqIDgsXG4gICAgICBpZDogdHJhbnNhY3Rpb24uaWQsXG4gICAgICBibG9ja190aW1lOiB0cmFuc2FjdGlvbi5ibG9ja190aW1lLFxuICAgICAgYmxvY2tfbnVtOiB0cmFuc2FjdGlvbi5ibG9ja19udW0sXG4gICAgICBkZWxheV9zZWM6IGRlbGF5X3NlYyxcbiAgICAgIGV4cGlyYXRpb246IGV4cGlyYXRpb24sXG4gICAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgICAgdHJhY2VzOiB0cmFjZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0eDsgLy8gTUVFVE9ORSBoaXN0b3J5XG4gIH0gZWxzZSBpZiAodHJhbnNhY3Rpb24uYWN0aW9uX3RyYWNlcykge1xuICAgIHJldHVybiBkZnVzZVRyYW5zZm9ybVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTsgLy8gT24gYmxvY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3RyYWNlcyA9IHRyYW5zYWN0aW9uLnRyYWNlcy5tYXAoZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeVRyYW5zZm9ybVJlY3Vyc2l2ZVRyYWNlKHRyYWNlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6ICdleGVjdXRlZCcsXG4gICAgICBjcHVfdXNhZ2U6IDAsXG4gICAgICBuZXRfdXNhZ2U6IDAsXG4gICAgICBpZDogdHJhbnNhY3Rpb24uaWQsXG4gICAgICBibG9ja190aW1lOiB0cmFuc2FjdGlvbi5ibG9ja190aW1lLFxuICAgICAgYmxvY2tfbnVtOiB0cmFuc2FjdGlvbi5ibG9ja19udW0sXG4gICAgICBkZWxheV9zZWM6IDAsXG4gICAgICBleHBpcmF0aW9uOiAwLFxuICAgICAgYWN0aW9uczogX3RyYWNlcyxcbiAgICAgIHRyYWNlczogX3RyYWNlc1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaGV4VG9VaW50OEFycmF5KGhleCkge1xuICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN0cmluZyBjb250YWluaW5nIGhleCBkaWdpdHMnKTtcbiAgfVxuXG4gIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignT2RkIG51bWJlciBvZiBoZXggZGlnaXRzJyk7XG4gIH1cblxuICB2YXIgbCA9IGhleC5sZW5ndGggLyAyO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICB2YXIgeCA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG5cbiAgICBpZiAoTnVtYmVyLmlzTmFOKHgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGhleCBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICByZXN1bHRbaV0gPSB4O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdXJsQnVpbGRlcih1cmwsIGlkLCBwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgaWQgIT09ICd1bmRlZmluZWQnICYmIGlkICE9PSBudWxsKSB7XG4gICAgdXJsICs9IFwiL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCAhPT0gMCkge1xuICAgIHZhciBxdWVyeVN0cmluZyA9IHF1ZXJ5LnN0cmluZ2lmeShwYXJhbXMpO1xuICAgIHVybCArPSBcIj9cIiArIHF1ZXJ5U3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuZnVuY3Rpb24gY29weSh0ZXh0KSB7XG4gIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICBlbC52YWx1ZSA9IHRleHQ7XG4gIGVsLnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAnJyk7XG4gIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZWwuc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgIHNlbGVjdGVkID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gIH1cblxuICBlbC5zZWxlY3QoKTtcbiAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cbiAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3RlZCkge1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2Uoc2VsZWN0ZWQpO1xuICB9XG59XG5cbnZhciBOZnQgPSBmdW5jdGlvbiBOZnQoX3JlZikge1xuICB2YXIgaWRhdGEgPSBfcmVmLmlkYXRhLFxuICAgICAgbWRhdGEgPSBfcmVmLm1kYXRhLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIGltYWdlID0gX3JlZi5pbWFnZSxcbiAgICAgIHZpZGVvID0gX3JlZi52aWRlbyxcbiAgICAgIG1vZGVsID0gX3JlZi5tb2RlbCxcbiAgICAgIGF1ZGlvID0gX3JlZi5hdWRpbyxcbiAgICAgIHN0YWdlID0gX3JlZi5zdGFnZSxcbiAgICAgIHNreWJveCA9IF9yZWYuc2t5Ym94LFxuICAgICAgcGRmID0gX3JlZi5wZGYsXG4gICAgICBpZCA9IF9yZWYuaWQsXG4gICAgICBjb250cmFjdCA9IF9yZWYuY29udHJhY3QsXG4gICAgICBsaW5rID0gX3JlZi5saW5rLFxuICAgICAgb3duZXIgPSBfcmVmLm93bmVyLFxuICAgICAgYXV0aG9yID0gX3JlZi5hdXRob3IsXG4gICAgICBjb2xsZWN0aW9uID0gX3JlZi5jb2xsZWN0aW9uLFxuICAgICAgbWludCA9IF9yZWYubWludCxcbiAgICAgIGVkaXRpb25fc2l6ZSA9IF9yZWYuZWRpdGlvbl9zaXplO1xuICB0aGlzLmlkYXRhID0gaWRhdGE7XG4gIHRoaXMubWRhdGEgPSBtZGF0YTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICB0aGlzLnZpZGVvID0gdmlkZW87XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5hdWRpbyA9IGF1ZGlvO1xuICB0aGlzLnN0YWdlID0gc3RhZ2U7XG4gIHRoaXMuc2t5Ym94ID0gc2t5Ym94O1xuICB0aGlzLnBkZiA9IHBkZjtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmNvbnRyYWN0ID0gY29udHJhY3Q7XG4gIHRoaXMubGluayA9IGxpbms7XG4gIHRoaXMub3duZXIgPSBvd25lcjtcbiAgdGhpcy5hdXRob3IgPSBhdXRob3I7XG4gIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIHRoaXMubWludCA9IG1pbnQ7XG4gIHRoaXMuZWRpdGlvbl9zaXplID0gZWRpdGlvbl9zaXplO1xufTtcblxuZnVuY3Rpb24gcGFyc2VJcGZzKGltYWdlVXJsKSB7XG4gIGlmICghaW1hZ2VVcmwpIHtcbiAgICByZXR1cm4gaW1hZ2VVcmw7XG4gIH1cblxuICBpZiAoaW1hZ2VVcmwuc3Vic3RyaW5nKDAsIDIpID09PSAnUW0nKSB7XG4gICAgaW1hZ2VVcmwgPSBcImh0dHBzOi8vY2xvdWRmbGFyZS1pcGZzLmNvbS9pcGZzL1wiICsgaW1hZ2VVcmw7XG4gIH1cblxuICByZXR1cm4gaW1hZ2VVcmw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2FOZnQobmZ0KSB7XG4gIHZhciBuYW1lID0gbmZ0LmlkYXRhICYmIG5mdC5pZGF0YS5uYW1lIHx8IG5mdC5tZGF0YSAmJiBuZnQubWRhdGEubmFtZTtcbiAgdmFyIGltYWdlVXJsID0gcGFyc2VJcGZzKG5mdC5pZGF0YSAmJiAobmZ0LmlkYXRhLmltZyB8fCBuZnQuaWRhdGEuaW1hZ2UpIHx8IG5mdC5tZGF0YSAmJiAobmZ0Lm1kYXRhLmltZyB8fCBuZnQubWRhdGEuaW1nKSk7XG4gIHZhciB2aWRlb1VybCA9IHBhcnNlSXBmcyhuZnQuaWRhdGEgJiYgbmZ0LmlkYXRhLnZpZGVvIHx8IG5mdC5tZGF0YSAmJiBuZnQubWRhdGEudmlkZW8pO1xuICB2YXIgYXVkaW9VcmwgPSBwYXJzZUlwZnMobmZ0LmlkYXRhICYmIG5mdC5pZGF0YS5hdWRpbyB8fCBuZnQubWRhdGEgJiYgbmZ0Lm1kYXRhLmF1ZGlvKTtcbiAgdmFyIG1vZGVsVXJsID0gcGFyc2VJcGZzKG5mdC5pZGF0YSAmJiBuZnQuaWRhdGEubW9kZWwgfHwgbmZ0Lm1kYXRhICYmIG5mdC5tZGF0YS5tb2RlbCk7XG4gIHZhciBzdGFnZVVybCA9IHBhcnNlSXBmcyhuZnQuaWRhdGEgJiYgbmZ0LmlkYXRhLnN0YWdlIHx8IG5mdC5tZGF0YSAmJiBuZnQubWRhdGEuc3RhZ2UpO1xuICB2YXIgcGRmVXJsID0gcGFyc2VJcGZzKG5mdC5pZGF0YSAmJiBuZnQuaWRhdGEucGRmIHx8IG5mdC5tZGF0YSAmJiBuZnQubWRhdGEucGRmKTtcbiAgdmFyIHNreWJveFVybCA9IHBhcnNlSXBmcyhuZnQuaWRhdGEgJiYgbmZ0LmlkYXRhLnNreWJveCB8fCBuZnQubWRhdGEgJiYgbmZ0Lm1kYXRhLnNreWJveCk7XG4gIHZhciBuZnRPYmogPSBuZXcgTmZ0KHtcbiAgICBpZGF0YTogbmZ0LmlkYXRhLFxuICAgIG1kYXRhOiBuZnQubWRhdGEsXG4gICAgbmFtZTogbmFtZSxcbiAgICBpbWFnZTogaW1hZ2VVcmwsXG4gICAgdmlkZW86IHZpZGVvVXJsLFxuICAgIG1vZGVsOiBtb2RlbFVybCxcbiAgICBhdWRpbzogYXVkaW9VcmwsXG4gICAgc3RhZ2U6IHN0YWdlVXJsLFxuICAgIHNreWJveDogc2t5Ym94VXJsLFxuICAgIHBkZjogcGRmVXJsLFxuICAgIGlkOiBuZnQuYXNzZXRJZCxcbiAgICBjb250cmFjdDogJ3NpbXBsZWFzc2V0cycsXG4gICAgbGluazogXCIvbmZ0L1wiICsgbmZ0LmFzc2V0SWQsXG4gICAgb3duZXI6IG5mdC5vd25lcixcbiAgICBhdXRob3I6IG5mdC5hdXRob3IsXG4gICAgbWludDogbmZ0LmV4dHJhICYmIG5mdC5leHRyYS5taW50TnVtYmVyLFxuICAgIGNvbGxlY3Rpb246IG5mdC5jYXRlZ29yeSxcbiAgICBlZGl0aW9uX3NpemU6IG5mdC5leHRyYSAmJiBuZnQuZXh0cmEudG90YWxNaW50ZWRcbiAgfSk7XG4gIHJldHVybiBuZnRPYmo7XG59XG5mdW5jdGlvbiBwYXJzZUFhTmZ0KG5mdCkge1xuICB2YXIgaW1hZ2VVcmwgPSBwYXJzZUlwZnMobmZ0LmRhdGEuaW1nIHx8IG5mdC5kYXRhLmltYWdlKTtcbiAgdmFyIHZpZGVvVXJsID0gcGFyc2VJcGZzKG5mdC5kYXRhLnZpZGVvKTtcbiAgdmFyIGF1ZGlvVXJsID0gcGFyc2VJcGZzKG5mdC5kYXRhLmF1ZGlvKTtcbiAgdmFyIG1vZGVsVXJsID0gcGFyc2VJcGZzKG5mdC5kYXRhLm1vZGVsKTtcbiAgdmFyIHN0YWdlVXJsID0gcGFyc2VJcGZzKG5mdC5kYXRhLnN0YWdlKTtcbiAgdmFyIHNreWJveFVybCA9IHBhcnNlSXBmcyhuZnQuZGF0YS5za3lib3gpO1xuICB2YXIgcGRmVXJsID0gcGFyc2VJcGZzKG5mdC5kYXRhLnBkZik7XG4gIHZhciBpZGF0YSA9IG5mdC5pbW11dGFibGVfZGF0YTtcblxuICBpZiAobmZ0LnRlbXBsYXRlICYmIG5mdC50ZW1wbGF0ZS5pbW11dGFibGVfZGF0YSkge1xuICAgIGlkYXRhID0gX2V4dGVuZHMoe30sIGlkYXRhLCBuZnQudGVtcGxhdGUuaW1tdXRhYmxlX2RhdGEpO1xuICB9XG5cbiAgdmFyIG5mdE9iaiA9IG5ldyBOZnQoe1xuICAgIGlkYXRhOiBpZGF0YSxcbiAgICBtZGF0YTogbmZ0Lm11dGFibGVfZGF0YSxcbiAgICBuYW1lOiBuZnQubmFtZSB8fCBuZnQuZGF0YS5uYW1lIHx8IG5mdC5hc3NldF9pZCxcbiAgICBpbWFnZTogaW1hZ2VVcmwsXG4gICAgdmlkZW86IHZpZGVvVXJsLFxuICAgIG1vZGVsOiBtb2RlbFVybCxcbiAgICBhdWRpbzogYXVkaW9VcmwsXG4gICAgc3RhZ2U6IHN0YWdlVXJsLFxuICAgIHNreWJveDogc2t5Ym94VXJsLFxuICAgIHBkZjogcGRmVXJsLFxuICAgIGlkOiBuZnQuYXNzZXRfaWQsXG4gICAgY29udHJhY3Q6ICdhdG9taWNhc3NldHMnLFxuICAgIGxpbms6IFwiL25mdC9cIiArIG5mdC5hc3NldF9pZCxcbiAgICBvd25lcjogbmZ0Lm93bmVyLFxuICAgIGF1dGhvcjogbmZ0LmNvbGxlY3Rpb24uYXV0aG9yLFxuICAgIGNvbGxlY3Rpb246IG5mdC5jb2xsZWN0aW9uLmNvbGxlY3Rpb25fbmFtZSxcbiAgICBtaW50OiBuZnQudGVtcGxhdGVfbWludCA/ICtuZnQudGVtcGxhdGVfbWludCA6IHVuZGVmaW5lZCxcbiAgICBlZGl0aW9uX3NpemU6IG5mdC50ZW1wbGF0ZSA/ICtuZnQudGVtcGxhdGUubWF4X3N1cHBseSB8fCArbmZ0LnRlbXBsYXRlLmlzc3VlZF9zdXBwbHkgOiB1bmRlZmluZWRcbiAgfSk7XG4gIHJldHVybiBuZnRPYmo7XG59XG5cbmZ1bmN0aW9uIHdhaXQoX3gpIHtcbiAgcmV0dXJuIF93YWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93YWl0KCkge1xuICBfd2FpdCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShtcykge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfd2FpdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKipcclxuICogTmF0aXZlXHJcbiAqL1xudmFyIERib3BPcDtcblxuKGZ1bmN0aW9uIChEYm9wT3ApIHtcbiAgRGJvcE9wW1wiSW5zXCJdID0gXCJJTlNcIjtcbiAgRGJvcE9wW1wiUmVtXCJdID0gXCJSRU1cIjtcbiAgRGJvcE9wW1wiVXBkXCJdID0gXCJVUERcIjtcbn0pKERib3BPcCB8fCAoRGJvcE9wID0ge30pKTtcblxuZXhwb3J0IHsgRGJvcE9wLCBOZnQsIGJ5dGVzVG9TdHJpbmcsIGNoYXJpZHgsIGNsb25lRGVlcEFycmF5T2ZPYmosIGNvcHksIGRlY29kZU5hbWUsIGRmdXNlRGVwdGhGaXJzdEV4dHJhY3QsIGRmdXNlVHJhbnNmb3JtRGVmZXJyZWRBY3Rpb24sIGRmdXNlVHJhbnNmb3JtRGVmZXJyZWRUcmFuc2FjdGlvbiwgZGZ1c2VUcmFuc2Zvcm1HZXRBY3Rpb25zLCBkZnVzZVRyYW5zZm9ybVRyYWNlLCBkZnVzZVRyYW5zZm9ybVRyYW5zYWN0aW9uLCBkZnVzZVRyYW5zZm9ybVRyYW5zYWN0aW9uUmVzdWx0LCBlbmNvZGVOYW1lLCBmaW9LZXlUb0FjdG9yLCBoZXhUb1VpbnQ4QXJyYXksIGhpc3RvcnlUcmFuc2Zvcm1EZWZlcnJlZEFjdGlvbiwgaGlzdG9yeVRyYW5zZm9ybURlZmVycmVkVHJhbnNhY3Rpb24sIGhpc3RvcnlUcmFuc2Zvcm1GbGF0VHJhY2VzLCBoaXN0b3J5VHJhbnNmb3JtUmVjdXJzaXZlVHJhY2UsIGhpc3RvcnlUcmFuc2Zvcm1UcmFuc2FjdGlvbiwgaHlwZXJpb25UcmFuc2Zvcm1GbGF0VHJhY2VzLCBoeXBlcmlvblRyYW5zZm9ybUdldEFjdGlvbnMsIGh5cGVyaW9uVHJhbnNmb3JtVHJhbnNhY3Rpb24sIGlzU3RyaW5nLCBuYXRpdmVUcmFuc2Zvcm1HZXRBY3Rpb25zLCBwYXJzZUFhTmZ0LCBwYXJzZVNhTmZ0LCBzaGEsIHN0cmluZ190b191aW50MTI4X2hhc2gsIHVybEJ1aWxkZXIsIHdhaXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmVzbS5qcy5tYXBcbiIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcykubnVtYnJvPWUoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIGEobyx1LGMpe2Z1bmN0aW9uIHModCxlKXtpZighdVt0XSl7aWYoIW9bdF0pe3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWUmJnIpcmV0dXJuIHIodCwhMCk7aWYobClyZXR1cm4gbCh0LCEwKTt2YXIgbj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK3QrXCInXCIpO3Rocm93IG4uY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixufXZhciBpPXVbdF09e2V4cG9ydHM6e319O29bdF1bMF0uY2FsbChpLmV4cG9ydHMsZnVuY3Rpb24oZSl7cmV0dXJuIHMob1t0XVsxXVtlXXx8ZSl9LGksaS5leHBvcnRzLGEsbyx1LGMpfXJldHVybiB1W3RdLmV4cG9ydHN9Zm9yKHZhciBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsZT0wO2U8Yy5sZW5ndGg7ZSsrKXMoY1tlXSk7cmV0dXJuIHN9KHsxOltmdW5jdGlvbihlLHIsdCl7IWZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO3ZhciB0LEM9L14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksVD1NYXRoLmNlaWwsVT1NYXRoLmZsb29yLFI9XCJbQmlnTnVtYmVyIEVycm9yXSBcIixJPVIrXCJOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiBcIiwkPTFlMTQsRz0xNCxWPTkwMDcxOTkyNTQ3NDA5OTEscT1bMSwxMCwxMDAsMWUzLDFlNCwxZTUsMWU2LDFlNywxZTgsMWU5LDFlMTAsMWUxMSwxZTEyLDFlMTNdLFo9MWU3LHo9MWU5O2Z1bmN0aW9uIFcoZSl7dmFyIHQ9MHxlO3JldHVybiAwPGV8fGU9PT10P3Q6dC0xfWZ1bmN0aW9uIEgoZSl7Zm9yKHZhciB0LHIsbj0xLGk9ZS5sZW5ndGgsYT1lWzBdK1wiXCI7bjxpOyl7Zm9yKHQ9ZVtuKytdK1wiXCIscj1HLXQubGVuZ3RoO3ItLTt0PVwiMFwiK3QpO2ErPXR9Zm9yKGk9YS5sZW5ndGg7NDg9PT1hLmNoYXJDb2RlQXQoLS1pKTspO3JldHVybiBhLnNsaWNlKDAsaSsxfHwxKX1mdW5jdGlvbiBZKGUsdCl7dmFyIHIsbixpPWUuYyxhPXQuYyxvPWUucyx1PXQucyxjPWUuZSxzPXQuZTtpZighb3x8IXUpcmV0dXJuIG51bGw7aWYocj1pJiYhaVswXSxuPWEmJiFhWzBdLHJ8fG4pcmV0dXJuIHI/bj8wOi11Om87aWYobyE9dSlyZXR1cm4gbztpZihyPW88MCxuPWM9PXMsIWl8fCFhKXJldHVybiBuPzA6IWlecj8xOi0xO2lmKCFuKXJldHVybiBzPGNecj8xOi0xO2Zvcih1PShjPWkubGVuZ3RoKTwocz1hLmxlbmd0aCk/YzpzLG89MDtvPHU7bysrKWlmKGlbb10hPWFbb10pcmV0dXJuIGlbb10+YVtvXV5yPzE6LTE7cmV0dXJuIGM9PXM/MDpzPGNecj8xOi0xfWZ1bmN0aW9uIEsoZSx0LHIsbil7aWYoZTx0fHxyPGV8fGUhPT1VKGUpKXRocm93IEVycm9yKFIrKG58fFwiQXJndW1lbnRcIikrKFwibnVtYmVyXCI9PXR5cGVvZiBlP2U8dHx8cjxlP1wiIG91dCBvZiByYW5nZTogXCI6XCIgbm90IGFuIGludGVnZXI6IFwiOlwiIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6IFwiKStTdHJpbmcoZSkpfWZ1bmN0aW9uIEooZSl7dmFyIHQ9ZS5jLmxlbmd0aC0xO3JldHVybiBXKGUuZS9HKT09dCYmZS5jW3RdJTIhPTB9ZnVuY3Rpb24gWChlLHQpe3JldHVybigxPGUubGVuZ3RoP2UuY2hhckF0KDApK1wiLlwiK2Uuc2xpY2UoMSk6ZSkrKHQ8MD9cImVcIjpcImUrXCIpK3R9ZnVuY3Rpb24gUShlLHQscil7dmFyIG4saTtpZih0PDApe2ZvcihpPXIrXCIuXCI7Kyt0O2krPXIpO2U9aStlfWVsc2UgaWYoKyt0PihuPWUubGVuZ3RoKSl7Zm9yKGk9cix0LT1uOy0tdDtpKz1yKTtlKz1pfWVsc2UgdDxuJiYoZT1lLnNsaWNlKDAsdCkrXCIuXCIrZS5zbGljZSh0KSk7cmV0dXJuIGV9KHQ9ZnVuY3Rpb24gZSh0KXt2YXIgdixmLHAscixzLG0sbyx1LGMsbCxnLG49QS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOkEsdG9TdHJpbmc6bnVsbCx2YWx1ZU9mOm51bGx9LGg9bmV3IEEoMSkseT0yMCxiPTQsZD0tNyx3PTIxLFM9LTFlNyx4PTFlNyxPPSExLGE9MSxOPTAsQj17cHJlZml4OlwiXCIsZ3JvdXBTaXplOjMsc2Vjb25kYXJ5R3JvdXBTaXplOjAsZ3JvdXBTZXBhcmF0b3I6XCIsXCIsZGVjaW1hbFNlcGFyYXRvcjpcIi5cIixmcmFjdGlvbkdyb3VwU2l6ZTowLGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6XCLCoFwiLHN1ZmZpeDpcIlwifSxNPVwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7ZnVuY3Rpb24gQShlLHQpe3ZhciByLG4saSxhLG8sdSxjLHMsbD10aGlzO2lmKCEobCBpbnN0YW5jZW9mIEEpKXJldHVybiBuZXcgQShlLHQpO2lmKG51bGw9PXQpe2lmKGUmJiEwPT09ZS5faXNCaWdOdW1iZXIpcmV0dXJuIGwucz1lLnMsdm9pZCghZS5jfHxlLmU+eD9sLmM9bC5lPW51bGw6ZS5lPFM/bC5jPVtsLmU9MF06KGwuZT1lLmUsbC5jPWUuYy5zbGljZSgpKSk7aWYoKHU9XCJudW1iZXJcIj09dHlwZW9mIGUpJiYwKmU9PTApe2lmKGwucz0xL2U8MD8oZT0tZSwtMSk6MSxlPT09fn5lKXtmb3IoYT0wLG89ZTsxMDw9bztvLz0xMCxhKyspO3JldHVybiB2b2lkKHg8YT9sLmM9bC5lPW51bGw6KGwuZT1hLGwuYz1bZV0pKX1zPVN0cmluZyhlKX1lbHNle2lmKCFDLnRlc3Qocz1TdHJpbmcoZSkpKXJldHVybiBwKGwscyx1KTtsLnM9NDU9PXMuY2hhckNvZGVBdCgwKT8ocz1zLnNsaWNlKDEpLC0xKToxfS0xPChhPXMuaW5kZXhPZihcIi5cIikpJiYocz1zLnJlcGxhY2UoXCIuXCIsXCJcIikpLDA8KG89cy5zZWFyY2goL2UvaSkpPyhhPDAmJihhPW8pLGErPStzLnNsaWNlKG8rMSkscz1zLnN1YnN0cmluZygwLG8pKTphPDAmJihhPXMubGVuZ3RoKX1lbHNle2lmKEsodCwyLE0ubGVuZ3RoLFwiQmFzZVwiKSwxMD09dClyZXR1cm4gUChsPW5ldyBBKGUpLHkrbC5lKzEsYik7aWYocz1TdHJpbmcoZSksdT1cIm51bWJlclwiPT10eXBlb2YgZSl7aWYoMCplIT0wKXJldHVybiBwKGwscyx1LHQpO2lmKGwucz0xL2U8MD8ocz1zLnNsaWNlKDEpLC0xKToxLEEuREVCVUcmJjE1PHMucmVwbGFjZSgvXjBcXC4wKnxcXC4vLFwiXCIpLmxlbmd0aCl0aHJvdyBFcnJvcihJK2UpfWVsc2UgbC5zPTQ1PT09cy5jaGFyQ29kZUF0KDApPyhzPXMuc2xpY2UoMSksLTEpOjE7Zm9yKHI9TS5zbGljZSgwLHQpLGE9bz0wLGM9cy5sZW5ndGg7bzxjO28rKylpZihyLmluZGV4T2Yobj1zLmNoYXJBdChvKSk8MCl7aWYoXCIuXCI9PW4pe2lmKGE8byl7YT1jO2NvbnRpbnVlfX1lbHNlIGlmKCFpJiYocz09cy50b1VwcGVyQ2FzZSgpJiYocz1zLnRvTG93ZXJDYXNlKCkpfHxzPT1zLnRvTG93ZXJDYXNlKCkmJihzPXMudG9VcHBlckNhc2UoKSkpKXtpPSEwLG89LTEsYT0wO2NvbnRpbnVlfXJldHVybiBwKGwsU3RyaW5nKGUpLHUsdCl9dT0hMSwtMTwoYT0ocz1mKHMsdCwxMCxsLnMpKS5pbmRleE9mKFwiLlwiKSk/cz1zLnJlcGxhY2UoXCIuXCIsXCJcIik6YT1zLmxlbmd0aH1mb3Iobz0wOzQ4PT09cy5jaGFyQ29kZUF0KG8pO28rKyk7Zm9yKGM9cy5sZW5ndGg7NDg9PT1zLmNoYXJDb2RlQXQoLS1jKTspO2lmKHM9cy5zbGljZShvLCsrYykpe2lmKGMtPW8sdSYmQS5ERUJVRyYmMTU8YyYmKFY8ZXx8ZSE9PVUoZSkpKXRocm93IEVycm9yKEkrbC5zKmUpO2lmKChhPWEtby0xKT54KWwuYz1sLmU9bnVsbDtlbHNlIGlmKGE8UylsLmM9W2wuZT0wXTtlbHNle2lmKGwuZT1hLGwuYz1bXSxvPShhKzEpJUcsYTwwJiYobys9RyksbzxjKXtmb3IobyYmbC5jLnB1c2goK3Muc2xpY2UoMCxvKSksYy09RztvPGM7KWwuYy5wdXNoKCtzLnNsaWNlKG8sbys9RykpO289Ry0ocz1zLnNsaWNlKG8pKS5sZW5ndGh9ZWxzZSBvLT1jO2Zvcig7by0tO3MrPVwiMFwiKTtsLmMucHVzaCgrcyl9fWVsc2UgbC5jPVtsLmU9MF19ZnVuY3Rpb24gRChlLHQscixuKXtmb3IodmFyIGksYSxvPVswXSx1PTAsYz1lLmxlbmd0aDt1PGM7KXtmb3IoYT1vLmxlbmd0aDthLS07b1thXSo9dCk7Zm9yKG9bMF0rPW4uaW5kZXhPZihlLmNoYXJBdCh1KyspKSxpPTA7aTxvLmxlbmd0aDtpKyspb1tpXT5yLTEmJihudWxsPT1vW2krMV0mJihvW2krMV09MCksb1tpKzFdKz1vW2ldL3J8MCxvW2ldJT1yKX1yZXR1cm4gby5yZXZlcnNlKCl9ZnVuY3Rpb24gRShlLHQscil7dmFyIG4saSxhLG8sdT0wLGM9ZS5sZW5ndGgscz10JVosbD10L1p8MDtmb3IoZT1lLnNsaWNlKCk7Yy0tOyl1PSgoaT1zKihhPWVbY10lWikrKG49bCphKyhvPWVbY10vWnwwKSpzKSVaKlordSkvcnwwKSsobi9afDApK2wqbyxlW2NdPWklcjtyZXR1cm4gdSYmKGU9W3VdLmNvbmNhdChlKSksZX1mdW5jdGlvbiBGKGUsdCxyLG4pe3ZhciBpLGE7aWYociE9bilhPW48cj8xOi0xO2Vsc2UgZm9yKGk9YT0wO2k8cjtpKyspaWYoZVtpXSE9dFtpXSl7YT1lW2ldPnRbaV0/MTotMTticmVha31yZXR1cm4gYX1mdW5jdGlvbiBrKGUsdCxyLG4pe2Zvcih2YXIgaT0wO3ItLTspZVtyXS09aSxpPWVbcl08dFtyXT8xOjAsZVtyXT1pKm4rZVtyXS10W3JdO2Zvcig7IWVbMF0mJjE8ZS5sZW5ndGg7ZS5zcGxpY2UoMCwxKSk7fWZ1bmN0aW9uIGkoZSx0LHIsbil7dmFyIGksYSxvLHUsYztpZihudWxsPT1yP3I9YjpLKHIsMCw4KSwhZS5jKXJldHVybiBlLnRvU3RyaW5nKCk7aWYoaT1lLmNbMF0sbz1lLmUsbnVsbD09dCljPUgoZS5jKSxjPTE9PW58fDI9PW4mJihvPD1kfHx3PD1vKT9YKGMsbyk6UShjLG8sXCIwXCIpO2Vsc2UgaWYoYT0oZT1QKG5ldyBBKGUpLHQscikpLmUsdT0oYz1IKGUuYykpLmxlbmd0aCwxPT1ufHwyPT1uJiYodDw9YXx8YTw9ZCkpe2Zvcig7dTx0O2MrPVwiMFwiLHUrKyk7Yz1YKGMsYSl9ZWxzZSBpZih0LT1vLGM9UShjLGEsXCIwXCIpLHU8YSsxKXtpZigwPC0tdClmb3IoYys9XCIuXCI7dC0tO2MrPVwiMFwiKTt9ZWxzZSBpZigwPCh0Kz1hLXUpKWZvcihhKzE9PXUmJihjKz1cIi5cIik7dC0tO2MrPVwiMFwiKTtyZXR1cm4gZS5zPDAmJmk/XCItXCIrYzpjfWZ1bmN0aW9uIF8oZSx0KXtmb3IodmFyIHIsbj0xLGk9bmV3IEEoZVswXSk7bjxlLmxlbmd0aDtuKyspe2lmKCEocj1uZXcgQShlW25dKSkucyl7aT1yO2JyZWFrfXQuY2FsbChpLHIpJiYoaT1yKX1yZXR1cm4gaX1mdW5jdGlvbiBMKGUsdCxyKXtmb3IodmFyIG49MSxpPXQubGVuZ3RoOyF0Wy0taV07dC5wb3AoKSk7Zm9yKGk9dFswXTsxMDw9aTtpLz0xMCxuKyspO3JldHVybihyPW4rcipHLTEpPng/ZS5jPWUuZT1udWxsOnI8Uz9lLmM9W2UuZT0wXTooZS5lPXIsZS5jPXQpLGV9ZnVuY3Rpb24gUChlLHQscixuKXt2YXIgaSxhLG8sdSxjLHMsbCxmPWUuYyxwPXE7aWYoZil7ZTp7Zm9yKGk9MSx1PWZbMF07MTA8PXU7dS89MTAsaSsrKTtpZigoYT10LWkpPDApYSs9RyxvPXQsbD0oYz1mW3M9MF0pL3BbaS1vLTFdJTEwfDA7ZWxzZSBpZigocz1UKChhKzEpL0cpKT49Zi5sZW5ndGgpe2lmKCFuKWJyZWFrIGU7Zm9yKDtmLmxlbmd0aDw9cztmLnB1c2goMCkpO2M9bD0wLG89KGElPUcpLUcrKGk9MSl9ZWxzZXtmb3IoYz11PWZbc10saT0xOzEwPD11O3UvPTEwLGkrKyk7bD0obz0oYSU9RyktRytpKTwwPzA6Yy9wW2ktby0xXSUxMHwwfWlmKG49bnx8dDwwfHxudWxsIT1mW3MrMV18fChvPDA/YzpjJXBbaS1vLTFdKSxuPXI8ND8obHx8bikmJigwPT1yfHxyPT0oZS5zPDA/MzoyKSk6NTxsfHw1PT1sJiYoND09cnx8bnx8Nj09ciYmKDA8YT8wPG8/Yy9wW2ktb106MDpmW3MtMV0pJTEwJjF8fHI9PShlLnM8MD84OjcpKSx0PDF8fCFmWzBdKXJldHVybiBmLmxlbmd0aD0wLG4/KHQtPWUuZSsxLGZbMF09cFsoRy10JUcpJUddLGUuZT0tdHx8MCk6ZlswXT1lLmU9MCxlO2lmKDA9PWE/KGYubGVuZ3RoPXMsdT0xLHMtLSk6KGYubGVuZ3RoPXMrMSx1PXBbRy1hXSxmW3NdPTA8bz9VKGMvcFtpLW9dJXBbb10pKnU6MCksbilmb3IoOzspe2lmKDA9PXMpe2ZvcihhPTEsbz1mWzBdOzEwPD1vO28vPTEwLGErKyk7Zm9yKG89ZlswXSs9dSx1PTE7MTA8PW87by89MTAsdSsrKTthIT11JiYoZS5lKyssZlswXT09JCYmKGZbMF09MSkpO2JyZWFrfWlmKGZbc10rPXUsZltzXSE9JClicmVhaztmW3MtLV09MCx1PTF9Zm9yKGE9Zi5sZW5ndGg7MD09PWZbLS1hXTtmLnBvcCgpKTt9ZS5lPng/ZS5jPWUuZT1udWxsOmUuZTxTJiYoZS5jPVtlLmU9MF0pfXJldHVybiBlfWZ1bmN0aW9uIGooZSl7dmFyIHQscj1lLmU7cmV0dXJuIG51bGw9PT1yP2UudG9TdHJpbmcoKToodD1IKGUuYyksdD1yPD1kfHx3PD1yP1godCxyKTpRKHQscixcIjBcIiksZS5zPDA/XCItXCIrdDp0KX1yZXR1cm4gQS5jbG9uZT1lLEEuUk9VTkRfVVA9MCxBLlJPVU5EX0RPV049MSxBLlJPVU5EX0NFSUw9MixBLlJPVU5EX0ZMT09SPTMsQS5ST1VORF9IQUxGX1VQPTQsQS5ST1VORF9IQUxGX0RPV049NSxBLlJPVU5EX0hBTEZfRVZFTj02LEEuUk9VTkRfSEFMRl9DRUlMPTcsQS5ST1VORF9IQUxGX0ZMT09SPTgsQS5FVUNMSUQ9OSxBLmNvbmZpZz1BLnNldD1mdW5jdGlvbihlKXt2YXIgdCxyO2lmKG51bGwhPWUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IEVycm9yKFIrXCJPYmplY3QgZXhwZWN0ZWQ6IFwiK2UpO2lmKGUuaGFzT3duUHJvcGVydHkodD1cIkRFQ0lNQUxfUExBQ0VTXCIpJiYoSyhyPWVbdF0sMCx6LHQpLHk9ciksZS5oYXNPd25Qcm9wZXJ0eSh0PVwiUk9VTkRJTkdfTU9ERVwiKSYmKEsocj1lW3RdLDAsOCx0KSxiPXIpLGUuaGFzT3duUHJvcGVydHkodD1cIkVYUE9ORU5USUFMX0FUXCIpJiYoKHI9ZVt0XSkmJnIucG9wPyhLKHJbMF0sLXosMCx0KSxLKHJbMV0sMCx6LHQpLGQ9clswXSx3PXJbMV0pOihLKHIsLXoseix0KSxkPS0odz1yPDA/LXI6cikpKSxlLmhhc093blByb3BlcnR5KHQ9XCJSQU5HRVwiKSlpZigocj1lW3RdKSYmci5wb3ApSyhyWzBdLC16LC0xLHQpLEsoclsxXSwxLHosdCksUz1yWzBdLHg9clsxXTtlbHNle2lmKEsociwteix6LHQpLCFyKXRocm93IEVycm9yKFIrdCtcIiBjYW5ub3QgYmUgemVybzogXCIrcik7Uz0tKHg9cjwwPy1yOnIpfWlmKGUuaGFzT3duUHJvcGVydHkodD1cIkNSWVBUT1wiKSl7aWYoKHI9ZVt0XSkhPT0hIXIpdGhyb3cgRXJyb3IoUit0K1wiIG5vdCB0cnVlIG9yIGZhbHNlOiBcIityKTtpZihyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgY3J5cHRvfHwhY3J5cHRvfHwhY3J5cHRvLmdldFJhbmRvbVZhbHVlcyYmIWNyeXB0by5yYW5kb21CeXRlcyl0aHJvdyBPPSFyLEVycm9yKFIrXCJjcnlwdG8gdW5hdmFpbGFibGVcIik7Tz1yfWVsc2UgTz1yfWlmKGUuaGFzT3duUHJvcGVydHkodD1cIk1PRFVMT19NT0RFXCIpJiYoSyhyPWVbdF0sMCw5LHQpLGE9ciksZS5oYXNPd25Qcm9wZXJ0eSh0PVwiUE9XX1BSRUNJU0lPTlwiKSYmKEsocj1lW3RdLDAseix0KSxOPXIpLGUuaGFzT3duUHJvcGVydHkodD1cIkZPUk1BVFwiKSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mKHI9ZVt0XSkpdGhyb3cgRXJyb3IoUit0K1wiIG5vdCBhbiBvYmplY3Q6IFwiK3IpO0I9cn1pZihlLmhhc093blByb3BlcnR5KHQ9XCJBTFBIQUJFVFwiKSl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mKHI9ZVt0XSl8fC9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QocikpdGhyb3cgRXJyb3IoUit0K1wiIGludmFsaWQ6IFwiK3IpO009cn19cmV0dXJue0RFQ0lNQUxfUExBQ0VTOnksUk9VTkRJTkdfTU9ERTpiLEVYUE9ORU5USUFMX0FUOltkLHddLFJBTkdFOltTLHhdLENSWVBUTzpPLE1PRFVMT19NT0RFOmEsUE9XX1BSRUNJU0lPTjpOLEZPUk1BVDpCLEFMUEhBQkVUOk19fSxBLmlzQmlnTnVtYmVyPWZ1bmN0aW9uKGUpe2lmKCFlfHwhMCE9PWUuX2lzQmlnTnVtYmVyKXJldHVybiExO2lmKCFBLkRFQlVHKXJldHVybiEwO3ZhciB0LHIsbj1lLmMsaT1lLmUsYT1lLnM7ZTppZihcIltvYmplY3QgQXJyYXldXCI9PXt9LnRvU3RyaW5nLmNhbGwobikpe2lmKCgxPT09YXx8LTE9PT1hKSYmLXo8PWkmJmk8PXomJmk9PT1VKGkpKXtpZigwPT09blswXSl7aWYoMD09PWkmJjE9PT1uLmxlbmd0aClyZXR1cm4hMDticmVhayBlfWlmKCh0PShpKzEpJUcpPDEmJih0Kz1HKSxTdHJpbmcoblswXSkubGVuZ3RoPT10KXtmb3IodD0wO3Q8bi5sZW5ndGg7dCsrKWlmKChyPW5bdF0pPDB8fCQ8PXJ8fHIhPT1VKHIpKWJyZWFrIGU7aWYoMCE9PXIpcmV0dXJuITB9fX1lbHNlIGlmKG51bGw9PT1uJiZudWxsPT09aSYmKG51bGw9PT1hfHwxPT09YXx8LTE9PT1hKSlyZXR1cm4hMDt0aHJvdyBFcnJvcihSK1wiSW52YWxpZCBCaWdOdW1iZXI6IFwiK2UpfSxBLm1heGltdW09QS5tYXg9ZnVuY3Rpb24oKXtyZXR1cm4gXyhhcmd1bWVudHMsbi5sdCl9LEEubWluaW11bT1BLm1pbj1mdW5jdGlvbigpe3JldHVybiBfKGFyZ3VtZW50cyxuLmd0KX0sQS5yYW5kb209KHI9OTAwNzE5OTI1NDc0MDk5MixzPU1hdGgucmFuZG9tKCkqciYyMDk3MTUxP2Z1bmN0aW9uKCl7cmV0dXJuIFUoTWF0aC5yYW5kb20oKSpyKX06ZnVuY3Rpb24oKXtyZXR1cm4gODM4ODYwOCooMTA3Mzc0MTgyNCpNYXRoLnJhbmRvbSgpfDApKyg4Mzg4NjA4Kk1hdGgucmFuZG9tKCl8MCl9LGZ1bmN0aW9uKGUpe3ZhciB0LHIsbixpLGEsbz0wLHU9W10sYz1uZXcgQShoKTtpZihudWxsPT1lP2U9eTpLKGUsMCx6KSxpPVQoZS9HKSxPKWlmKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe2Zvcih0PWNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGkqPTIpKTtvPGk7KTllMTU8PShhPTEzMTA3Mip0W29dKyh0W28rMV0+Pj4xMSkpPyhyPWNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKSx0W29dPXJbMF0sdFtvKzFdPXJbMV0pOih1LnB1c2goYSUxZTE0KSxvKz0yKTtvPWkvMn1lbHNle2lmKCFjcnlwdG8ucmFuZG9tQnl0ZXMpdGhyb3cgTz0hMSxFcnJvcihSK1wiY3J5cHRvIHVuYXZhaWxhYmxlXCIpO2Zvcih0PWNyeXB0by5yYW5kb21CeXRlcyhpKj03KTtvPGk7KTllMTU8PShhPTI4MTQ3NDk3NjcxMDY1NiooMzEmdFtvXSkrMTA5OTUxMTYyNzc3Nip0W28rMV0rNDI5NDk2NzI5Nip0W28rMl0rMTY3NzcyMTYqdFtvKzNdKyh0W28rNF08PDE2KSsodFtvKzVdPDw4KSt0W28rNl0pP2NyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KHQsbyk6KHUucHVzaChhJTFlMTQpLG8rPTcpO289aS83fWlmKCFPKWZvcig7bzxpOykoYT1zKCkpPDllMTUmJih1W28rK109YSUxZTE0KTtmb3IoaT11Wy0tb10sZSU9RyxpJiZlJiYoYT1xW0ctZV0sdVtvXT1VKGkvYSkqYSk7MD09PXVbb107dS5wb3AoKSxvLS0pO2lmKG88MCl1PVtuPTBdO2Vsc2V7Zm9yKG49LTE7MD09PXVbMF07dS5zcGxpY2UoMCwxKSxuLT1HKTtmb3Iobz0xLGE9dVswXTsxMDw9YTthLz0xMCxvKyspO288RyYmKG4tPUctbyl9cmV0dXJuIGMuZT1uLGMuYz11LGN9KSxBLnN1bT1mdW5jdGlvbigpe2Zvcih2YXIgZT0xLHQ9YXJndW1lbnRzLHI9bmV3IEEodFswXSk7ZTx0Lmxlbmd0aDspcj1yLnBsdXModFtlKytdKTtyZXR1cm4gcn0sbT1cIjAxMjM0NTY3ODlcIixmPWZ1bmN0aW9uKGUsdCxyLG4saSl7dmFyIGEsbyx1LGMscyxsLGYscCxnPWUuaW5kZXhPZihcIi5cIiksZD15LGg9Yjtmb3IoMDw9ZyYmKGM9TixOPTAsZT1lLnJlcGxhY2UoXCIuXCIsXCJcIiksbD0ocD1uZXcgQSh0KSkucG93KGUubGVuZ3RoLWcpLE49YyxwLmM9RChRKEgobC5jKSxsLmUsXCIwXCIpLDEwLHIsbSkscC5lPXAuYy5sZW5ndGgpLHU9Yz0oZj1EKGUsdCxyLGk/KGE9TSxtKTooYT1tLE0pKSkubGVuZ3RoOzA9PWZbLS1jXTtmLnBvcCgpKTtpZighZlswXSlyZXR1cm4gYS5jaGFyQXQoMCk7aWYoZzwwPy0tdToobC5jPWYsbC5lPXUsbC5zPW4sZj0obD12KGwscCxkLGgscikpLmMscz1sLnIsdT1sLmUpLGc9ZltvPXUrZCsxXSxjPXIvMixzPXN8fG88MHx8bnVsbCE9ZltvKzFdLHM9aDw0PyhudWxsIT1nfHxzKSYmKDA9PWh8fGg9PShsLnM8MD8zOjIpKTpjPGd8fGc9PWMmJig0PT1ofHxzfHw2PT1oJiYxJmZbby0xXXx8aD09KGwuczwwPzg6NykpLG88MXx8IWZbMF0pZT1zP1EoYS5jaGFyQXQoMSksLWQsYS5jaGFyQXQoMCkpOmEuY2hhckF0KDApO2Vsc2V7aWYoZi5sZW5ndGg9byxzKWZvcigtLXI7KytmWy0tb10+cjspZltvXT0wLG98fCgrK3UsZj1bMV0uY29uY2F0KGYpKTtmb3IoYz1mLmxlbmd0aDshZlstLWNdOyk7Zm9yKGc9MCxlPVwiXCI7Zzw9YztlKz1hLmNoYXJBdChmW2crK10pKTtlPVEoZSx1LGEuY2hhckF0KDApKX1yZXR1cm4gZX0sdj1mdW5jdGlvbihlLHQscixuLGkpe3ZhciBhLG8sdSxjLHMsbCxmLHAsZyxkLGgsdixtLHksYix3LFMseD1lLnM9PXQucz8xOi0xLE89ZS5jLE49dC5jO2lmKCEoTyYmT1swXSYmTiYmTlswXSkpcmV0dXJuIG5ldyBBKGUucyYmdC5zJiYoTz8hTnx8T1swXSE9TlswXTpOKT9PJiYwPT1PWzBdfHwhTj8wKng6eC8wOk5hTik7Zm9yKGc9KHA9bmV3IEEoeCkpLmM9W10seD1yKyhvPWUuZS10LmUpKzEsaXx8KGk9JCxvPVcoZS5lL0cpLVcodC5lL0cpLHg9eC9HfDApLHU9MDtOW3VdPT0oT1t1XXx8MCk7dSsrKTtpZihOW3VdPihPW3VdfHwwKSYmby0tLHg8MClnLnB1c2goMSksYz0hMDtlbHNle2Zvcih5PU8ubGVuZ3RoLHc9Ti5sZW5ndGgseCs9MiwxPChzPVUoaS8oTlt1PTBdKzEpKSkmJihOPUUoTixzLGkpLE89RShPLHMsaSksdz1OLmxlbmd0aCx5PU8ubGVuZ3RoKSxtPXcsaD0oZD1PLnNsaWNlKDAsdykpLmxlbmd0aDtoPHc7ZFtoKytdPTApO1M9Ti5zbGljZSgpLFM9WzBdLmNvbmNhdChTKSxiPU5bMF0sTlsxXT49aS8yJiZiKys7ZG97aWYocz0wLChhPUYoTixkLHcsaCkpPDApe2lmKHY9ZFswXSx3IT1oJiYodj12KmkrKGRbMV18fDApKSwxPChzPVUodi9iKSkpZm9yKGk8PXMmJihzPWktMSksZj0obD1FKE4scyxpKSkubGVuZ3RoLGg9ZC5sZW5ndGg7MT09RihsLGQsZixoKTspcy0tLGsobCx3PGY/UzpOLGYsaSksZj1sLmxlbmd0aCxhPTE7ZWxzZSAwPT1zJiYoYT1zPTEpLGY9KGw9Ti5zbGljZSgpKS5sZW5ndGg7aWYoZjxoJiYobD1bMF0uY29uY2F0KGwpKSxrKGQsbCxoLGkpLGg9ZC5sZW5ndGgsLTE9PWEpZm9yKDtGKE4sZCx3LGgpPDE7KXMrKyxrKGQsdzxoP1M6TixoLGkpLGg9ZC5sZW5ndGh9ZWxzZSAwPT09YSYmKHMrKyxkPVswXSk7Z1t1KytdPXMsZFswXT9kW2grK109T1ttXXx8MDooZD1bT1ttXV0saD0xKX13aGlsZSgobSsrPHl8fG51bGwhPWRbMF0pJiZ4LS0pO2M9bnVsbCE9ZFswXSxnWzBdfHxnLnNwbGljZSgwLDEpfWlmKGk9PSQpe2Zvcih1PTEseD1nWzBdOzEwPD14O3gvPTEwLHUrKyk7UChwLHIrKHAuZT11K28qRy0xKSsxLG4sYyl9ZWxzZSBwLmU9byxwLnI9K2M7cmV0dXJuIHB9LG89L14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSx1PS9eKFteLl0rKVxcLiQvLGM9L15cXC4oW14uXSspJC8sbD0vXi0/KEluZmluaXR5fE5hTikkLyxnPS9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZyxwPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpLGE9cj90OnQucmVwbGFjZShnLFwiXCIpO2lmKGwudGVzdChhKSllLnM9aXNOYU4oYSk/bnVsbDphPDA/LTE6MTtlbHNle2lmKCFyJiYoYT1hLnJlcGxhY2UobyxmdW5jdGlvbihlLHQscil7cmV0dXJuIGk9XCJ4XCI9PShyPXIudG9Mb3dlckNhc2UoKSk/MTY6XCJiXCI9PXI/Mjo4LG4mJm4hPWk/ZTp0fSksbiYmKGk9bixhPWEucmVwbGFjZSh1LFwiJDFcIikucmVwbGFjZShjLFwiMC4kMVwiKSksdCE9YSkpcmV0dXJuIG5ldyBBKGEsaSk7aWYoQS5ERUJVRyl0aHJvdyBFcnJvcihSK1wiTm90IGFcIisobj9cIiBiYXNlIFwiK246XCJcIikrXCIgbnVtYmVyOiBcIit0KTtlLnM9bnVsbH1lLmM9ZS5lPW51bGx9LG4uYWJzb2x1dGVWYWx1ZT1uLmFicz1mdW5jdGlvbigpe3ZhciBlPW5ldyBBKHRoaXMpO3JldHVybiBlLnM8MCYmKGUucz0xKSxlfSxuLmNvbXBhcmVkVG89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gWSh0aGlzLG5ldyBBKGUsdCkpfSxuLmRlY2ltYWxQbGFjZXM9bi5kcD1mdW5jdGlvbihlLHQpe3ZhciByLG4saTtpZihudWxsIT1lKXJldHVybiBLKGUsMCx6KSxudWxsPT10P3Q9YjpLKHQsMCw4KSxQKG5ldyBBKHRoaXMpLGUrdGhpcy5lKzEsdCk7aWYoIShyPXRoaXMuYykpcmV0dXJuIG51bGw7aWYobj0oKGk9ci5sZW5ndGgtMSktVyh0aGlzLmUvRykpKkcsaT1yW2ldKWZvcig7aSUxMD09MDtpLz0xMCxuLS0pO3JldHVybiBuPDAmJihuPTApLG59LG4uZGl2aWRlZEJ5PW4uZGl2PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHYodGhpcyxuZXcgQShlLHQpLHksYil9LG4uZGl2aWRlZFRvSW50ZWdlckJ5PW4uaWRpdj1mdW5jdGlvbihlLHQpe3JldHVybiB2KHRoaXMsbmV3IEEoZSx0KSwwLDEpfSxuLmV4cG9uZW50aWF0ZWRCeT1uLnBvdz1mdW5jdGlvbihlLHQpe3ZhciByLG4saSxhLG8sdSxjLHMsbD10aGlzO2lmKChlPW5ldyBBKGUpKS5jJiYhZS5pc0ludGVnZXIoKSl0aHJvdyBFcnJvcihSK1wiRXhwb25lbnQgbm90IGFuIGludGVnZXI6IFwiK2ooZSkpO2lmKG51bGwhPXQmJih0PW5ldyBBKHQpKSxvPTE0PGUuZSwhbC5jfHwhbC5jWzBdfHwxPT1sLmNbMF0mJiFsLmUmJjE9PWwuYy5sZW5ndGh8fCFlLmN8fCFlLmNbMF0pcmV0dXJuIHM9bmV3IEEoTWF0aC5wb3coK2oobCksbz8yLUooZSk6K2ooZSkpKSx0P3MubW9kKHQpOnM7aWYodT1lLnM8MCx0KXtpZih0LmM/IXQuY1swXTohdC5zKXJldHVybiBuZXcgQShOYU4pOyhuPSF1JiZsLmlzSW50ZWdlcigpJiZ0LmlzSW50ZWdlcigpKSYmKGw9bC5tb2QodCkpfWVsc2V7aWYoOTxlLmUmJigwPGwuZXx8bC5lPC0xfHwoMD09bC5lPzE8bC5jWzBdfHxvJiYyNGU3PD1sLmNbMV06bC5jWzBdPDhlMTN8fG8mJmwuY1swXTw9OTk5OTk3NWU3KSkpcmV0dXJuIGE9bC5zPDAmJkooZSk/LTA6MCwtMTxsLmUmJihhPTEvYSksbmV3IEEodT8xL2E6YSk7TiYmKGE9VChOL0crMikpfWZvcihjPW8/KHI9bmV3IEEoLjUpLHUmJihlLnM9MSksSihlKSk6KGk9TWF0aC5hYnMoK2ooZSkpKSUyLHM9bmV3IEEoaCk7Oyl7aWYoYyl7aWYoIShzPXMudGltZXMobCkpLmMpYnJlYWs7YT9zLmMubGVuZ3RoPmEmJihzLmMubGVuZ3RoPWEpOm4mJihzPXMubW9kKHQpKX1pZihpKXtpZigwPT09KGk9VShpLzIpKSlicmVhaztjPWklMn1lbHNlIGlmKFAoZT1lLnRpbWVzKHIpLGUuZSsxLDEpLDE0PGUuZSljPUooZSk7ZWxzZXtpZigwPT0oaT0raihlKSkpYnJlYWs7Yz1pJTJ9bD1sLnRpbWVzKGwpLGE/bC5jJiZsLmMubGVuZ3RoPmEmJihsLmMubGVuZ3RoPWEpOm4mJihsPWwubW9kKHQpKX1yZXR1cm4gbj9zOih1JiYocz1oLmRpdihzKSksdD9zLm1vZCh0KTphP1AocyxOLGIsdm9pZCAwKTpzKX0sbi5pbnRlZ2VyVmFsdWU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEEodGhpcyk7cmV0dXJuIG51bGw9PWU/ZT1iOksoZSwwLDgpLFAodCx0LmUrMSxlKX0sbi5pc0VxdWFsVG89bi5lcT1mdW5jdGlvbihlLHQpe3JldHVybiAwPT09WSh0aGlzLG5ldyBBKGUsdCkpfSxuLmlzRmluaXRlPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmN9LG4uaXNHcmVhdGVyVGhhbj1uLmd0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDA8WSh0aGlzLG5ldyBBKGUsdCkpfSxuLmlzR3JlYXRlclRoYW5PckVxdWFsVG89bi5ndGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMT09PSh0PVkodGhpcyxuZXcgQShlLHQpKSl8fDA9PT10fSxuLmlzSW50ZWdlcj1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jJiZXKHRoaXMuZS9HKT50aGlzLmMubGVuZ3RoLTJ9LG4uaXNMZXNzVGhhbj1uLmx0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIFkodGhpcyxuZXcgQShlLHQpKTwwfSxuLmlzTGVzc1RoYW5PckVxdWFsVG89bi5sdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4tMT09PSh0PVkodGhpcyxuZXcgQShlLHQpKSl8fDA9PT10fSxuLmlzTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuc30sbi5pc05lZ2F0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuczwwfSxuLmlzUG9zaXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gMDx0aGlzLnN9LG4uaXNaZXJvPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmMmJjA9PXRoaXMuY1swXX0sbi5taW51cz1mdW5jdGlvbihlLHQpe3ZhciByLG4saSxhLG89dGhpcyx1PW8ucztpZih0PShlPW5ldyBBKGUsdCkpLnMsIXV8fCF0KXJldHVybiBuZXcgQShOYU4pO2lmKHUhPXQpcmV0dXJuIGUucz0tdCxvLnBsdXMoZSk7dmFyIGM9by5lL0cscz1lLmUvRyxsPW8uYyxmPWUuYztpZighY3x8IXMpe2lmKCFsfHwhZilyZXR1cm4gbD8oZS5zPS10LGUpOm5ldyBBKGY/bzpOYU4pO2lmKCFsWzBdfHwhZlswXSlyZXR1cm4gZlswXT8oZS5zPS10LGUpOm5ldyBBKGxbMF0/bzozPT1iPy0wOjApfWlmKGM9VyhjKSxzPVcocyksbD1sLnNsaWNlKCksdT1jLXMpe2ZvcigoaT0oYT11PDApPyh1PS11LGwpOihzPWMsZikpLnJldmVyc2UoKSx0PXU7dC0tO2kucHVzaCgwKSk7aS5yZXZlcnNlKCl9ZWxzZSBmb3Iobj0oYT0odT1sLmxlbmd0aCk8KHQ9Zi5sZW5ndGgpKT91OnQsdT10PTA7dDxuO3QrKylpZihsW3RdIT1mW3RdKXthPWxbdF08Zlt0XTticmVha31pZihhJiYoaT1sLGw9ZixmPWksZS5zPS1lLnMpLDA8KHQ9KG49Zi5sZW5ndGgpLShyPWwubGVuZ3RoKSkpZm9yKDt0LS07bFtyKytdPTApO2Zvcih0PSQtMTt1PG47KXtpZihsWy0tbl08ZltuXSl7Zm9yKHI9bjtyJiYhbFstLXJdO2xbcl09dCk7LS1sW3JdLGxbbl0rPSR9bFtuXS09ZltuXX1mb3IoOzA9PWxbMF07bC5zcGxpY2UoMCwxKSwtLXMpO3JldHVybiBsWzBdP0woZSxsLHMpOihlLnM9Mz09Yj8tMToxLGUuYz1bZS5lPTBdLGUpfSxuLm1vZHVsbz1uLm1vZD1mdW5jdGlvbihlLHQpe3ZhciByLG4saT10aGlzO3JldHVybiBlPW5ldyBBKGUsdCksIWkuY3x8IWUuc3x8ZS5jJiYhZS5jWzBdP25ldyBBKE5hTik6IWUuY3x8aS5jJiYhaS5jWzBdP25ldyBBKGkpOig5PT1hPyhuPWUucyxlLnM9MSxyPXYoaSxlLDAsMyksZS5zPW4sci5zKj1uKTpyPXYoaSxlLDAsYSksKGU9aS5taW51cyhyLnRpbWVzKGUpKSkuY1swXXx8MSE9YXx8KGUucz1pLnMpLGUpfSxuLm11bHRpcGxpZWRCeT1uLnRpbWVzPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLGEsbyx1LGMscyxsLGYscCxnLGQsaCx2LG09dGhpcyx5PW0uYyxiPShlPW5ldyBBKGUsdCkpLmM7aWYoISh5JiZiJiZ5WzBdJiZiWzBdKSlyZXR1cm4hbS5zfHwhZS5zfHx5JiYheVswXSYmIWJ8fGImJiFiWzBdJiYheT9lLmM9ZS5lPWUucz1udWxsOihlLnMqPW0ucyx5JiZiPyhlLmM9WzBdLGUuZT0wKTplLmM9ZS5lPW51bGwpLGU7Zm9yKG49VyhtLmUvRykrVyhlLmUvRyksZS5zKj1tLnMsKGM9eS5sZW5ndGgpPChmPWIubGVuZ3RoKSYmKGQ9eSx5PWIsYj1kLGk9YyxjPWYsZj1pKSxpPWMrZixkPVtdO2ktLTtkLnB1c2goMCkpO2ZvcihoPSQsdj1aLGk9ZjswPD0tLWk7KXtmb3Iocj0wLHA9YltpXSV2LGc9YltpXS92fDAsYT1pKyhvPWMpO2k8YTspcj0oKHM9cCoocz15Wy0tb10ldikrKHU9ZypzKyhsPXlbb10vdnwwKSpwKSV2KnYrZFthXStyKS9ofDApKyh1L3Z8MCkrZypsLGRbYS0tXT1zJWg7ZFthXT1yfXJldHVybiByPysrbjpkLnNwbGljZSgwLDEpLEwoZSxkLG4pfSxuLm5lZ2F0ZWQ9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgQSh0aGlzKTtyZXR1cm4gZS5zPS1lLnN8fG51bGwsZX0sbi5wbHVzPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbj10aGlzLGk9bi5zO2lmKHQ9KGU9bmV3IEEoZSx0KSkucywhaXx8IXQpcmV0dXJuIG5ldyBBKE5hTik7aWYoaSE9dClyZXR1cm4gZS5zPS10LG4ubWludXMoZSk7dmFyIGE9bi5lL0csbz1lLmUvRyx1PW4uYyxjPWUuYztpZighYXx8IW8pe2lmKCF1fHwhYylyZXR1cm4gbmV3IEEoaS8wKTtpZighdVswXXx8IWNbMF0pcmV0dXJuIGNbMF0/ZTpuZXcgQSh1WzBdP246MCppKX1pZihhPVcoYSksbz1XKG8pLHU9dS5zbGljZSgpLGk9YS1vKXtmb3IoKHI9MDxpPyhvPWEsYyk6KGk9LWksdSkpLnJldmVyc2UoKTtpLS07ci5wdXNoKDApKTtyLnJldmVyc2UoKX1mb3IoKGk9dS5sZW5ndGgpLSh0PWMubGVuZ3RoKTwwJiYocj1jLGM9dSx1PXIsdD1pKSxpPTA7dDspaT0odVstLXRdPXVbdF0rY1t0XStpKS8kfDAsdVt0XT0kPT09dVt0XT8wOnVbdF0lJDtyZXR1cm4gaSYmKHU9W2ldLmNvbmNhdCh1KSwrK28pLEwoZSx1LG8pfSxuLnByZWNpc2lvbj1uLnNkPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpO2lmKG51bGwhPWUmJmUhPT0hIWUpcmV0dXJuIEsoZSwxLHopLG51bGw9PXQ/dD1iOksodCwwLDgpLFAobmV3IEEodGhpcyksZSx0KTtpZighKHI9dGhpcy5jKSlyZXR1cm4gbnVsbDtpZihuPShpPXIubGVuZ3RoLTEpKkcrMSxpPXJbaV0pe2Zvcig7aSUxMD09MDtpLz0xMCxuLS0pO2ZvcihpPXJbMF07MTA8PWk7aS89MTAsbisrKTt9cmV0dXJuIGUmJnRoaXMuZSsxPm4mJihuPXRoaXMuZSsxKSxufSxuLnNoaWZ0ZWRCeT1mdW5jdGlvbihlKXtyZXR1cm4gSyhlLC1WLFYpLHRoaXMudGltZXMoXCIxZVwiK2UpfSxuLnNxdWFyZVJvb3Q9bi5zcXJ0PWZ1bmN0aW9uKCl7dmFyIGUsdCxyLG4saSxhPXRoaXMsbz1hLmMsdT1hLnMsYz1hLmUscz15KzQsbD1uZXcgQShcIjAuNVwiKTtpZigxIT09dXx8IW98fCFvWzBdKXJldHVybiBuZXcgQSghdXx8dTwwJiYoIW98fG9bMF0pP05hTjpvP2E6MS8wKTtpZigocj0wPT0odT1NYXRoLnNxcnQoK2ooYSkpKXx8dT09MS8wPygoKHQ9SChvKSkubGVuZ3RoK2MpJTI9PTAmJih0Kz1cIjBcIiksdT1NYXRoLnNxcnQoK3QpLGM9VygoYysxKS8yKS0oYzwwfHxjJTIpLG5ldyBBKHQ9dT09MS8wP1wiNWVcIitjOih0PXUudG9FeHBvbmVudGlhbCgpKS5zbGljZSgwLHQuaW5kZXhPZihcImVcIikrMSkrYykpOm5ldyBBKHUrXCJcIikpLmNbMF0pZm9yKCh1PShjPXIuZSkrcyk8MyYmKHU9MCk7OylpZihpPXIscj1sLnRpbWVzKGkucGx1cyh2KGEsaSxzLDEpKSksSChpLmMpLnNsaWNlKDAsdSk9PT0odD1IKHIuYykpLnNsaWNlKDAsdSkpe2lmKHIuZTxjJiYtLXUsXCI5OTk5XCIhPSh0PXQuc2xpY2UodS0zLHUrMSkpJiYobnx8XCI0OTk5XCIhPXQpKXsrdCYmKCt0LnNsaWNlKDEpfHxcIjVcIiE9dC5jaGFyQXQoMCkpfHwoUChyLHIuZSt5KzIsMSksZT0hci50aW1lcyhyKS5lcShhKSk7YnJlYWt9aWYoIW4mJihQKGksaS5lK3krMiwwKSxpLnRpbWVzKGkpLmVxKGEpKSl7cj1pO2JyZWFrfXMrPTQsdSs9NCxuPTF9cmV0dXJuIFAocixyLmUreSsxLGIsZSl9LG4udG9FeHBvbmVudGlhbD1mdW5jdGlvbihlLHQpe3JldHVybiBudWxsIT1lJiYoSyhlLDAseiksZSsrKSxpKHRoaXMsZSx0LDEpfSxuLnRvRml4ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbCE9ZSYmKEsoZSwwLHopLGU9ZSt0aGlzLmUrMSksaSh0aGlzLGUsdCl9LG4udG9Gb3JtYXQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuO2lmKG51bGw9PXIpbnVsbCE9ZSYmdCYmXCJvYmplY3RcIj09dHlwZW9mIHQ/KHI9dCx0PW51bGwpOmUmJlwib2JqZWN0XCI9PXR5cGVvZiBlPyhyPWUsZT10PW51bGwpOnI9QjtlbHNlIGlmKFwib2JqZWN0XCIhPXR5cGVvZiByKXRocm93IEVycm9yKFIrXCJBcmd1bWVudCBub3QgYW4gb2JqZWN0OiBcIityKTtpZihuPXRoaXMudG9GaXhlZChlLHQpLHRoaXMuYyl7dmFyIGksYT1uLnNwbGl0KFwiLlwiKSxvPStyLmdyb3VwU2l6ZSx1PStyLnNlY29uZGFyeUdyb3VwU2l6ZSxjPXIuZ3JvdXBTZXBhcmF0b3J8fFwiXCIscz1hWzBdLGw9YVsxXSxmPXRoaXMuczwwLHA9Zj9zLnNsaWNlKDEpOnMsZz1wLmxlbmd0aDtpZih1JiYoaT1vLG89dSxnLT11PWkpLDA8byYmMDxnKXtmb3IoaT1nJW98fG8scz1wLnN1YnN0cigwLGkpO2k8ZztpKz1vKXMrPWMrcC5zdWJzdHIoaSxvKTswPHUmJihzKz1jK3Auc2xpY2UoaSkpLGYmJihzPVwiLVwiK3MpfW49bD9zKyhyLmRlY2ltYWxTZXBhcmF0b3J8fFwiXCIpKygodT0rci5mcmFjdGlvbkdyb3VwU2l6ZSk/bC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcZHtcIit1K1wifVxcXFxCXCIsXCJnXCIpLFwiJCZcIisoci5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yfHxcIlwiKSk6bCk6c31yZXR1cm4oci5wcmVmaXh8fFwiXCIpK24rKHIuc3VmZml4fHxcIlwiKX0sbi50b0ZyYWN0aW9uPWZ1bmN0aW9uKGUpe3ZhciB0LHIsbixpLGEsbyx1LGMscyxsLGYscCxnPXRoaXMsZD1nLmM7aWYobnVsbCE9ZSYmKCEodT1uZXcgQShlKSkuaXNJbnRlZ2VyKCkmJih1LmN8fDEhPT11LnMpfHx1Lmx0KGgpKSl0aHJvdyBFcnJvcihSK1wiQXJndW1lbnQgXCIrKHUuaXNJbnRlZ2VyKCk/XCJvdXQgb2YgcmFuZ2U6IFwiOlwibm90IGFuIGludGVnZXI6IFwiKStqKHUpKTtpZighZClyZXR1cm4gbmV3IEEoZyk7Zm9yKHQ9bmV3IEEoaCkscz1yPW5ldyBBKGgpLG49Yz1uZXcgQShoKSxwPUgoZCksYT10LmU9cC5sZW5ndGgtZy5lLTEsdC5jWzBdPXFbKG89YSVHKTwwP0crbzpvXSxlPSFlfHwwPHUuY29tcGFyZWRUbyh0KT8wPGE/dDpzOnUsbz14LHg9MS8wLHU9bmV3IEEocCksYy5jWzBdPTA7bD12KHUsdCwwLDEpLDEhPShpPXIucGx1cyhsLnRpbWVzKG4pKSkuY29tcGFyZWRUbyhlKTspcj1uLG49aSxzPWMucGx1cyhsLnRpbWVzKGk9cykpLGM9aSx0PXUubWludXMobC50aW1lcyhpPXQpKSx1PWk7cmV0dXJuIGk9dihlLm1pbnVzKHIpLG4sMCwxKSxjPWMucGx1cyhpLnRpbWVzKHMpKSxyPXIucGx1cyhpLnRpbWVzKG4pKSxjLnM9cy5zPWcucyxmPXYocyxuLGEqPTIsYikubWludXMoZykuYWJzKCkuY29tcGFyZWRUbyh2KGMscixhLGIpLm1pbnVzKGcpLmFicygpKTwxP1tzLG5dOltjLHJdLHg9byxmfSxuLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuK2oodGhpcyl9LG4udG9QcmVjaXNpb249ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbCE9ZSYmSyhlLDEseiksaSh0aGlzLGUsdCwyKX0sbi50b1N0cmluZz1mdW5jdGlvbihlKXt2YXIgdCxyPXRoaXMsbj1yLnMsaT1yLmU7cmV0dXJuIG51bGw9PT1pP24/KHQ9XCJJbmZpbml0eVwiLG48MCYmKHQ9XCItXCIrdCkpOnQ9XCJOYU5cIjoodD1udWxsPT1lP2k8PWR8fHc8PWk/WChIKHIuYyksaSk6UShIKHIuYyksaSxcIjBcIik6MTA9PT1lP1EoSCgocj1QKG5ldyBBKHIpLHkraSsxLGIpKS5jKSxyLmUsXCIwXCIpOihLKGUsMixNLmxlbmd0aCxcIkJhc2VcIiksZihRKEgoci5jKSxpLFwiMFwiKSwxMCxlLG4sITApKSxuPDAmJnIuY1swXSYmKHQ9XCItXCIrdCkpLHR9LG4udmFsdWVPZj1uLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiBqKHRoaXMpfSxuLl9pc0JpZ051bWJlcj0hMCxudWxsIT10JiZBLnNldCh0KSxBfSgpKS5kZWZhdWx0PXQuQmlnTnVtYmVyPXQsdm9pZCAwIT09ciYmci5leHBvcnRzP3IuZXhwb3J0cz10OihlPWV8fChcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZj9zZWxmOndpbmRvdykpLkJpZ051bWJlcj10fSh0aGlzKX0se31dLDI6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9e2xhbmd1YWdlVGFnOlwiZW4tVVNcIixkZWxpbWl0ZXJzOnt0aG91c2FuZHM6XCIsXCIsZGVjaW1hbDpcIi5cIn0sYWJicmV2aWF0aW9uczp7dGhvdXNhbmQ6XCJrXCIsbWlsbGlvbjpcIm1cIixiaWxsaW9uOlwiYlwiLHRyaWxsaW9uOlwidFwifSxzcGFjZVNlcGFyYXRlZDohMSxvcmRpbmFsOmZ1bmN0aW9uKGUpe3ZhciB0PWUlMTA7cmV0dXJuIDE9PX5+KGUlMTAwLzEwKT9cInRoXCI6MT09dD9cInN0XCI6Mj09dD9cIm5kXCI6Mz09dD9cInJkXCI6XCJ0aFwifSxieXRlczp7YmluYXJ5U3VmZml4ZXM6W1wiQlwiLFwiS2lCXCIsXCJNaUJcIixcIkdpQlwiLFwiVGlCXCIsXCJQaUJcIixcIkVpQlwiLFwiWmlCXCIsXCJZaUJcIl0sZGVjaW1hbFN1ZmZpeGVzOltcIkJcIixcIktCXCIsXCJNQlwiLFwiR0JcIixcIlRCXCIsXCJQQlwiLFwiRUJcIixcIlpCXCIsXCJZQlwiXX0sY3VycmVuY3k6e3N5bWJvbDpcIiRcIixwb3NpdGlvbjpcInByZWZpeFwiLGNvZGU6XCJVU0RcIn0sY3VycmVuY3lGb3JtYXQ6e3Rob3VzYW5kU2VwYXJhdGVkOiEwLHRvdGFsTGVuZ3RoOjQsc3BhY2VTZXBhcmF0ZWQ6ITAsc3BhY2VTZXBhcmF0ZWRDdXJyZW5jeTohMH0sZm9ybWF0czp7Zm91ckRpZ2l0czp7dG90YWxMZW5ndGg6NCxzcGFjZVNlcGFyYXRlZDohMH0sZnVsbFdpdGhUd29EZWNpbWFsczp7b3V0cHV0OlwiY3VycmVuY3lcIix0aG91c2FuZFNlcGFyYXRlZDohMCxtYW50aXNzYToyfSxmdWxsV2l0aFR3b0RlY2ltYWxzTm9DdXJyZW5jeTp7dGhvdXNhbmRTZXBhcmF0ZWQ6ITAsbWFudGlzc2E6Mn0sZnVsbFdpdGhOb0RlY2ltYWxzOntvdXRwdXQ6XCJjdXJyZW5jeVwiLHRob3VzYW5kU2VwYXJhdGVkOiEwLG1hbnRpc3NhOjB9fX19LHt9XSwzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gSShlLHQpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfShlKXx8ZnVuY3Rpb24oZSx0KXtpZighKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpKXJldHVybjt2YXIgcj1bXSxuPSEwLGk9ITEsYT12b2lkIDA7dHJ5e2Zvcih2YXIgbyx1PWVbU3ltYm9sLml0ZXJhdG9yXSgpOyEobj0obz11Lm5leHQoKSkuZG9uZSkmJihyLnB1c2goby52YWx1ZSksIXR8fHIubGVuZ3RoIT09dCk7bj0hMCk7fWNhdGNoKGUpe2k9ITAsYT1lfWZpbmFsbHl7dHJ5e258fG51bGw9PXUucmV0dXJufHx1LnJldHVybigpfWZpbmFsbHl7aWYoaSl0aHJvdyBhfX1yZXR1cm4gcn0oZSx0KXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX12YXIgJD1lKFwiLi9nbG9iYWxTdGF0ZVwiKSxvPWUoXCIuL3ZhbGlkYXRpbmdcIiksdT1lKFwiLi9wYXJzaW5nXCIpLEc9e3RyaWxsaW9uOk1hdGgucG93KDEwLDEyKSxiaWxsaW9uOk1hdGgucG93KDEwLDkpLG1pbGxpb246TWF0aC5wb3coMTAsNiksdGhvdXNhbmQ6TWF0aC5wb3coMTAsMyl9LFY9e3RvdGFsTGVuZ3RoOjAsY2hhcmFjdGVyaXN0aWM6MCxmb3JjZUF2ZXJhZ2U6ITEsYXZlcmFnZTohMSxtYW50aXNzYTotMSxvcHRpb25hbE1hbnRpc3NhOiEwLHRob3VzYW5kU2VwYXJhdGVkOiExLHNwYWNlU2VwYXJhdGVkOiExLG5lZ2F0aXZlOlwic2lnblwiLGZvcmNlU2lnbjohMSxyb3VuZGluZ0Z1bmN0aW9uOk1hdGgucm91bmQsc3BhY2VTZXBhcmF0ZWRBYmJyZXZpYXRpb246ITF9LG49JC5jdXJyZW50Qnl0ZXMoKSxkPW4uYmluYXJ5U3VmZml4ZXMsaD1uLmRlY2ltYWxTdWZmaXhlcyxpPXtnZW5lcmFsOntzY2FsZToxMDI0LHN1ZmZpeGVzOmgsbWFya2VyOlwiYmRcIn0sYmluYXJ5OntzY2FsZToxMDI0LHN1ZmZpeGVzOmQsbWFya2VyOlwiYlwifSxkZWNpbWFsOntzY2FsZToxZTMsc3VmZml4ZXM6aCxtYXJrZXI6XCJkXCJ9fTtmdW5jdGlvbiBhKGUpe3ZhciB0PTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxyPTI8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMl06dm9pZCAwO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD11LnBhcnNlRm9ybWF0KHQpKSwhby52YWxpZGF0ZUZvcm1hdCh0KSlyZXR1cm5cIkVSUk9SOiBpbnZhbGlkIGZvcm1hdFwiO3ZhciBuPXQucHJlZml4fHxcIlwiLGk9dC5wb3N0Zml4fHxcIlwiLGE9ZnVuY3Rpb24oZSx0LHIpe3N3aXRjaCh0Lm91dHB1dCl7Y2FzZVwiY3VycmVuY3lcIjpyZXR1cm4gdD1jKHQsJC5jdXJyZW50Q3VycmVuY3lEZWZhdWx0Rm9ybWF0KCkpLGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yLmN1cnJlbnRDdXJyZW5jeSgpLGk9T2JqZWN0LmFzc2lnbih7fSxWLHQpLGE9dm9pZCAwLG89XCJcIix1PSEhaS50b3RhbExlbmd0aHx8ISFpLmZvcmNlQXZlcmFnZXx8aS5hdmVyYWdlLGM9dC5jdXJyZW5jeVBvc2l0aW9ufHxuLnBvc2l0aW9uLHM9dC5jdXJyZW5jeVN5bWJvbHx8bi5zeW1ib2wsbD12b2lkIDAhPT1pLnNwYWNlU2VwYXJhdGVkQ3VycmVuY3k/aS5zcGFjZVNlcGFyYXRlZEN1cnJlbmN5Omkuc3BhY2VTZXBhcmF0ZWQ7dm9pZCAwPT09dC5sb3dQcmVjaXNpb24mJih0Lmxvd1ByZWNpc2lvbj0hMSk7bCYmKG89XCIgXCIpO1wiaW5maXhcIj09PWMmJihhPW8rcytvKTt2YXIgZj1tKHtpbnN0YW5jZTplLHByb3ZpZGVkRm9ybWF0OnQsc3RhdGU6cixkZWNpbWFsU2VwYXJhdG9yOmF9KTtcInByZWZpeFwiPT09YyYmKGY9ZS5fdmFsdWU8MCYmXCJzaWduXCI9PT1pLm5lZ2F0aXZlP1wiLVwiLmNvbmNhdChvKS5jb25jYXQocykuY29uY2F0KGYuc2xpY2UoMSkpOjA8ZS5fdmFsdWUmJmkuZm9yY2VTaWduP1wiK1wiLmNvbmNhdChvKS5jb25jYXQocykuY29uY2F0KGYuc2xpY2UoMSkpOnMrbytmKTtjJiZcInBvc3RmaXhcIiE9PWN8fChvPSFpLnNwYWNlU2VwYXJhdGVkQWJicmV2aWF0aW9uJiZ1P1wiXCI6byxmPWYrbytzKTtyZXR1cm4gZn0oZSx0LCQpO2Nhc2VcInBlcmNlbnRcIjpyZXR1cm4gdD1jKHQsJC5jdXJyZW50UGVyY2VudGFnZURlZmF1bHRGb3JtYXQoKSksZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk9dC5wcmVmaXhTeW1ib2wsYT1tKHtpbnN0YW5jZTpuKDEwMCplLl92YWx1ZSkscHJvdmlkZWRGb3JtYXQ6dCxzdGF0ZTpyfSksbz1PYmplY3QuYXNzaWduKHt9LFYsdCk7aWYoaSlyZXR1cm5cIiVcIi5jb25jYXQoby5zcGFjZVNlcGFyYXRlZD9cIiBcIjpcIlwiKS5jb25jYXQoYSk7cmV0dXJuXCJcIi5jb25jYXQoYSkuY29uY2F0KG8uc3BhY2VTZXBhcmF0ZWQ/XCIgXCI6XCJcIixcIiVcIil9KGUsdCwkLHIpO2Nhc2VcImJ5dGVcIjpyZXR1cm4gdD1jKHQsJC5jdXJyZW50Qnl0ZURlZmF1bHRGb3JtYXQoKSksZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk9dC5iYXNlfHxcImJpbmFyeVwiLGE9T2JqZWN0LmFzc2lnbih7fSxWLHQpLG89ci5jdXJyZW50Qnl0ZXMoKSx1PW8uYmluYXJ5U3VmZml4ZXMsYz1vLmRlY2ltYWxTdWZmaXhlcyxzPXtnZW5lcmFsOntzY2FsZToxMDI0LHN1ZmZpeGVzOmN8fGgsbWFya2VyOlwiYmRcIn0sYmluYXJ5OntzY2FsZToxMDI0LHN1ZmZpeGVzOnV8fGQsbWFya2VyOlwiYlwifSxkZWNpbWFsOntzY2FsZToxZTMsc3VmZml4ZXM6Y3x8aCxtYXJrZXI6XCJkXCJ9fVtpXSxsPXYoZS5fdmFsdWUscy5zdWZmaXhlcyxzLnNjYWxlKSxmPWwudmFsdWUscD1sLnN1ZmZpeCxnPW0oe2luc3RhbmNlOm4oZikscHJvdmlkZWRGb3JtYXQ6dCxzdGF0ZTpyLGRlZmF1bHRzOnIuY3VycmVudEJ5dGVEZWZhdWx0Rm9ybWF0KCl9KTtyZXR1cm5cIlwiLmNvbmNhdChnKS5jb25jYXQoYS5zcGFjZVNlcGFyYXRlZD9cIiBcIjpcIlwiKS5jb25jYXQocCl9KGUsdCwkLHIpO2Nhc2VcInRpbWVcIjpyZXR1cm4gdD1jKHQsJC5jdXJyZW50VGltZURlZmF1bHRGb3JtYXQoKSksZnVuY3Rpb24oZSl7dmFyIHQ9TWF0aC5mbG9vcihlLl92YWx1ZS82MC82MCkscj1NYXRoLmZsb29yKChlLl92YWx1ZS02MCp0KjYwKS82MCksbj1NYXRoLnJvdW5kKGUuX3ZhbHVlLTYwKnQqNjAtNjAqcik7cmV0dXJuXCJcIi5jb25jYXQodCxcIjpcIikuY29uY2F0KHI8MTA/XCIwXCI6XCJcIikuY29uY2F0KHIsXCI6XCIpLmNvbmNhdChuPDEwP1wiMFwiOlwiXCIpLmNvbmNhdChuKX0oZSk7Y2FzZVwib3JkaW5hbFwiOnJldHVybiB0PWModCwkLmN1cnJlbnRPcmRpbmFsRGVmYXVsdEZvcm1hdCgpKSxmdW5jdGlvbihlLHQscil7dmFyIG49ci5jdXJyZW50T3JkaW5hbCgpLGk9T2JqZWN0LmFzc2lnbih7fSxWLHQpLGE9bSh7aW5zdGFuY2U6ZSxwcm92aWRlZEZvcm1hdDp0LHN0YXRlOnJ9KSxvPW4oZS5fdmFsdWUpO3JldHVyblwiXCIuY29uY2F0KGEpLmNvbmNhdChpLnNwYWNlU2VwYXJhdGVkP1wiIFwiOlwiXCIpLmNvbmNhdChvKX0oZSx0LCQpO2Nhc2VcIm51bWJlclwiOmRlZmF1bHQ6cmV0dXJuIG0oe2luc3RhbmNlOmUscHJvdmlkZWRGb3JtYXQ6dCxudW1icm86cn0pfX0oZSx0LHIpO3JldHVybiBhPShhPW4rYSkraX1mdW5jdGlvbiB2KGUsdCxyKXt2YXIgbj10WzBdLGk9TWF0aC5hYnMoZSk7aWYocjw9aSl7Zm9yKHZhciBhPTE7YTx0Lmxlbmd0aDsrK2Epe3ZhciBvPU1hdGgucG93KHIsYSksdT1NYXRoLnBvdyhyLGErMSk7aWYobzw9aSYmaTx1KXtuPXRbYV0sZS89bzticmVha319bj09PXRbMF0mJihlLz1NYXRoLnBvdyhyLHQubGVuZ3RoLTEpLG49dFt0Lmxlbmd0aC0xXSl9cmV0dXJue3ZhbHVlOmUsc3VmZml4Om59fWZ1bmN0aW9uIHAoZSl7Zm9yKHZhciB0PVwiXCIscj0wO3I8ZTtyKyspdCs9XCIwXCI7cmV0dXJuIHR9ZnVuY3Rpb24gcShlLHQscil7dmFyIG49Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1yP3I6TWF0aC5yb3VuZDtyZXR1cm4tMSE9PWUudG9TdHJpbmcoKS5pbmRleE9mKFwiZVwiKT9mdW5jdGlvbihlLHQpe3ZhciByPWUudG9TdHJpbmcoKSxuPUkoci5zcGxpdChcImVcIiksMiksaT1uWzBdLGE9blsxXSxvPUkoaS5zcGxpdChcIi5cIiksMiksdT1vWzBdLGM9b1sxXSxzPXZvaWQgMD09PWM/XCJcIjpjO2lmKDA8K2Epcj11K3MrcChhLXMubGVuZ3RoKTtlbHNle3ZhciBsPVwiLlwiO2w9K3U8MD9cIi0wXCIuY29uY2F0KGwpOlwiMFwiLmNvbmNhdChsKTt2YXIgZj0ocCgtYS0xKStNYXRoLmFicyh1KStzKS5zdWJzdHIoMCx0KTtmLmxlbmd0aDx0JiYoZis9cCh0LWYubGVuZ3RoKSkscj1sK2Z9cmV0dXJuIDA8K2EmJjA8dCYmKHIrPVwiLlwiLmNvbmNhdChwKHQpKSkscn0oZSx0KToobigrXCJcIi5jb25jYXQoZSxcImUrXCIpLmNvbmNhdCh0KSkvTWF0aC5wb3coMTAsdCkpLnRvRml4ZWQodCl9ZnVuY3Rpb24gWihlLHQscixuLGkpe3ZhciBhPW4uY3VycmVudERlbGltaXRlcnMoKSxvPWEudGhvdXNhbmRzO2k9aXx8YS5kZWNpbWFsO3ZhciB1PWEudGhvdXNhbmRzU2l6ZXx8MyxjPWUudG9TdHJpbmcoKSxzPWMuc3BsaXQoXCIuXCIpWzBdLGw9Yy5zcGxpdChcIi5cIilbMV0sZj10PDAmJjA9PT1zLmluZGV4T2YoXCItXCIpO3ImJihmJiYocz1zLnNsaWNlKDEpKSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj1bXSxuPTAsaT1lOzA8aTtpLS0pbj09PXQmJihyLnVuc2hpZnQoaSksbj0wKSxuKys7cmV0dXJuIHJ9KHMubGVuZ3RoLHUpLmZvckVhY2goZnVuY3Rpb24oZSx0KXtzPXMuc2xpY2UoMCxlK3QpK28rcy5zbGljZShlK3QpfSksZiYmKHM9XCItXCIuY29uY2F0KHMpKSk7cmV0dXJuIGM9bD9zK2krbDpzfWZ1bmN0aW9uIG0oZSl7dmFyIHQ9ZS5pbnN0YW5jZSxyPWUucHJvdmlkZWRGb3JtYXQsbj1lLnN0YXRlLGk9dm9pZCAwPT09bj8kOm4sYT1lLmRlY2ltYWxTZXBhcmF0b3Isbz1lLmRlZmF1bHRzLHU9dm9pZCAwPT09bz9pLmN1cnJlbnREZWZhdWx0cygpOm8sYz10Ll92YWx1ZTtpZigwPT09YyYmaS5oYXNaZXJvRm9ybWF0KCkpcmV0dXJuIGkuZ2V0WmVyb0Zvcm1hdCgpO2lmKCFpc0Zpbml0ZShjKSlyZXR1cm4gYy50b1N0cmluZygpO3ZhciBzLGwsZixwLGcsZCxoLHYsbT1PYmplY3QuYXNzaWduKHt9LFYsdSxyKSx5PW0udG90YWxMZW5ndGgsYj15PzA6bS5jaGFyYWN0ZXJpc3RpYyx3PW0ub3B0aW9uYWxDaGFyYWN0ZXJpc3RpYyxTPW0uZm9yY2VBdmVyYWdlLHg9bS5sb3dQcmVjaXNpb24sTz0hIXl8fCEhU3x8bS5hdmVyYWdlLE49eT8tMTpPJiZ2b2lkIDA9PT1yLm1hbnRpc3NhPzA6bS5tYW50aXNzYSxCPSF5JiYodm9pZCAwPT09ci5vcHRpb25hbE1hbnRpc3NhPy0xPT09TjptLm9wdGlvbmFsTWFudGlzc2EpLE09bS50cmltTWFudGlzc2EsQT1tLnRob3VzYW5kU2VwYXJhdGVkLEQ9bS5zcGFjZVNlcGFyYXRlZCxFPW0ubmVnYXRpdmUsRj1tLmZvcmNlU2lnbixrPW0uZXhwb25lbnRpYWwsXz1tLnJvdW5kaW5nRnVuY3Rpb24sTD1cIlwiO2lmKE8pe3ZhciBQPWZ1bmN0aW9uKGUpe3ZhciB0PWUudmFsdWUscj1lLmZvcmNlQXZlcmFnZSxuPWUubG93UHJlY2lzaW9uLGk9dm9pZCAwPT09bnx8bixhPWUuYWJicmV2aWF0aW9ucyxvPWUuc3BhY2VTZXBhcmF0ZWQsdT12b2lkIDAhPT1vJiZvLGM9ZS50b3RhbExlbmd0aCxzPXZvaWQgMD09PWM/MDpjLGw9ZS5yb3VuZGluZ0Z1bmN0aW9uLGY9dm9pZCAwPT09bD9NYXRoLnJvdW5kOmwscD1cIlwiLGc9TWF0aC5hYnModCksZD0tMTtpZihyJiZhW3JdJiZHW3JdPyhwPWFbcl0sdC89R1tyXSk6Zz49Ry50cmlsbGlvbnx8aSYmMT09PWYoZy9HLnRyaWxsaW9uKT8ocD1hLnRyaWxsaW9uLHQvPUcudHJpbGxpb24pOmc8Ry50cmlsbGlvbiYmZz49Ry5iaWxsaW9ufHxpJiYxPT09ZihnL0cuYmlsbGlvbik/KHA9YS5iaWxsaW9uLHQvPUcuYmlsbGlvbik6ZzxHLmJpbGxpb24mJmc+PUcubWlsbGlvbnx8aSYmMT09PWYoZy9HLm1pbGxpb24pPyhwPWEubWlsbGlvbix0Lz1HLm1pbGxpb24pOihnPEcubWlsbGlvbiYmZz49Ry50aG91c2FuZHx8aSYmMT09PWYoZy9HLnRob3VzYW5kKSkmJihwPWEudGhvdXNhbmQsdC89Ry50aG91c2FuZCkscD1wJiYodT9cIiBcIjpcIlwiKStwLHMpe3ZhciBoPXQ8MCx2PXQudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMF0sbT1oP3YubGVuZ3RoLTE6di5sZW5ndGg7ZD1NYXRoLm1heChzLW0sMCl9cmV0dXJue3ZhbHVlOnQsYWJicmV2aWF0aW9uOnAsbWFudGlzc2FQcmVjaXNpb246ZH19KHt2YWx1ZTpjLGZvcmNlQXZlcmFnZTpTLGxvd1ByZWNpc2lvbjp4LGFiYnJldmlhdGlvbnM6aS5jdXJyZW50QWJicmV2aWF0aW9ucygpLHNwYWNlU2VwYXJhdGVkOkQscm91bmRpbmdGdW5jdGlvbjpfLHRvdGFsTGVuZ3RoOnl9KTtjPVAudmFsdWUsTCs9UC5hYmJyZXZpYXRpb24seSYmKE49UC5tYW50aXNzYVByZWNpc2lvbil9aWYoayl7dmFyIGo9KGw9KHM9e3ZhbHVlOmMsY2hhcmFjdGVyaXN0aWNQcmVjaXNpb246Yn0pLnZhbHVlLGY9cy5jaGFyYWN0ZXJpc3RpY1ByZWNpc2lvbixwPXZvaWQgMD09PWY/MDpmLGc9SShsLnRvRXhwb25lbnRpYWwoKS5zcGxpdChcImVcIiksMiksZD1nWzBdLGg9Z1sxXSx2PStkLHAmJjE8cCYmKHYqPU1hdGgucG93KDEwLHAtMSksaD0wPD0oaC09cC0xKT9cIitcIi5jb25jYXQoaCk6aCkse3ZhbHVlOnYsYWJicmV2aWF0aW9uOlwiZVwiLmNvbmNhdChoKX0pO2M9ai52YWx1ZSxMPWouYWJicmV2aWF0aW9uK0x9dmFyIEMsVCxVLFI9ZnVuY3Rpb24oZSx0LHIsbixpLGEpe2lmKC0xPT09bilyZXR1cm4gZTt2YXIgbz1xKHQsbixhKSx1PUkoby50b1N0cmluZygpLnNwbGl0KFwiLlwiKSwyKSxjPXVbMF0scz11WzFdLGw9dm9pZCAwPT09cz9cIlwiOnM7aWYobC5tYXRjaCgvXjArJC8pJiYocnx8aSkpcmV0dXJuIGM7dmFyIGY9bC5tYXRjaCgvMCskLyk7cmV0dXJuIGkmJmY/XCJcIi5jb25jYXQoYyxcIi5cIikuY29uY2F0KGwudG9TdHJpbmcoKS5zbGljZSgwLGYuaW5kZXgpKTpvLnRvU3RyaW5nKCl9KGMudG9TdHJpbmcoKSxjLEIsTixNLF8pO3JldHVybiBSPVooUj1mdW5jdGlvbihlLHQscixuKXt2YXIgaT1lLGE9SShpLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpLDIpLG89YVswXSx1PWFbMV07aWYoby5tYXRjaCgvXi0/MCQvKSYmcilyZXR1cm4gdT9cIlwiLmNvbmNhdChvLnJlcGxhY2UoXCIwXCIsXCJcIiksXCIuXCIpLmNvbmNhdCh1KTpvLnJlcGxhY2UoXCIwXCIsXCJcIik7dmFyIGM9dDwwJiYwPT09by5pbmRleE9mKFwiLVwiKTtpZihjJiYobz1vLnNsaWNlKDEpLGk9aS5zbGljZSgxKSksby5sZW5ndGg8bilmb3IodmFyIHM9bi1vLmxlbmd0aCxsPTA7bDxzO2wrKylpPVwiMFwiLmNvbmNhdChpKTtyZXR1cm4gYyYmKGk9XCItXCIuY29uY2F0KGkpKSxpLnRvU3RyaW5nKCl9KFIsYyx3LGIpLGMsQSxpLGEpLChPfHxrKSYmKFI9UitMKSwoRnx8YzwwKSYmKEM9UixVPUUsUj0wPT09KFQ9Yyk/QzowPT0rQz9DLnJlcGxhY2UoXCItXCIsXCJcIik6MDxUP1wiK1wiLmNvbmNhdChDKTpcInNpZ25cIj09PVU/QzpcIihcIi5jb25jYXQoQy5yZXBsYWNlKFwiLVwiLFwiXCIpLFwiKVwiKSksUn1mdW5jdGlvbiBjKGUsdCl7aWYoIWUpcmV0dXJuIHQ7dmFyIHI9T2JqZWN0LmtleXMoZSk7cmV0dXJuIDE9PT1yLmxlbmd0aCYmXCJvdXRwdXRcIj09PXJbMF0/dDplfXQuZXhwb3J0cz1mdW5jdGlvbihuKXtyZXR1cm57Zm9ybWF0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuIGEuYXBwbHkodm9pZCAwLHQuY29uY2F0KFtuXSkpfSxnZXRCeXRlVW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdO3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1pLmdlbmVyYWw7cmV0dXJuIHYoZS5fdmFsdWUsdC5zdWZmaXhlcyx0LnNjYWxlKS5zdWZmaXh9LmFwcGx5KHZvaWQgMCx0LmNvbmNhdChbbl0pKX0sZ2V0QmluYXJ5Qnl0ZVVuaXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxyPTA7cjxlO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9aS5iaW5hcnk7cmV0dXJuIHYoZS5fdmFsdWUsdC5zdWZmaXhlcyx0LnNjYWxlKS5zdWZmaXh9LmFwcGx5KHZvaWQgMCx0LmNvbmNhdChbbl0pKX0sZ2V0RGVjaW1hbEJ5dGVVbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVjaW1hbDtyZXR1cm4gdihlLl92YWx1ZSx0LnN1ZmZpeGVzLHQuc2NhbGUpLnN1ZmZpeH0uYXBwbHkodm9pZCAwLHQuY29uY2F0KFtuXSkpfSxmb3JtYXRPckRlZmF1bHQ6Y319fSx7XCIuL2dsb2JhbFN0YXRlXCI6NCxcIi4vcGFyc2luZ1wiOjgsXCIuL3ZhbGlkYXRpbmdcIjoxMH1dLDQ6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi9lbi1VU1wiKSxuPWUoXCIuL3ZhbGlkYXRpbmdcIiksYT1lKFwiLi9wYXJzaW5nXCIpLG89e30sdT12b2lkIDAsYz17fSxzPW51bGwsbD17fTtmdW5jdGlvbiBmKGUpe3U9ZX1mdW5jdGlvbiBwKCl7cmV0dXJuIGNbdV19by5sYW5ndWFnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxjKX0sby5jdXJyZW50TGFuZ3VhZ2U9ZnVuY3Rpb24oKXtyZXR1cm4gdX0sby5jdXJyZW50Qnl0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gcCgpLmJ5dGVzfHx7fX0sby5jdXJyZW50Q3VycmVuY3k9ZnVuY3Rpb24oKXtyZXR1cm4gcCgpLmN1cnJlbmN5fSxvLmN1cnJlbnRBYmJyZXZpYXRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHAoKS5hYmJyZXZpYXRpb25zfSxvLmN1cnJlbnREZWxpbWl0ZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIHAoKS5kZWxpbWl0ZXJzfSxvLmN1cnJlbnRPcmRpbmFsPWZ1bmN0aW9uKCl7cmV0dXJuIHAoKS5vcmRpbmFsfSxvLmN1cnJlbnREZWZhdWx0cz1mdW5jdGlvbigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LHAoKS5kZWZhdWx0cyxsKX0sby5jdXJyZW50T3JkaW5hbERlZmF1bHRGb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxvLmN1cnJlbnREZWZhdWx0cygpLHAoKS5vcmRpbmFsRm9ybWF0KX0sby5jdXJyZW50Qnl0ZURlZmF1bHRGb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxvLmN1cnJlbnREZWZhdWx0cygpLHAoKS5ieXRlRm9ybWF0KX0sby5jdXJyZW50UGVyY2VudGFnZURlZmF1bHRGb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxvLmN1cnJlbnREZWZhdWx0cygpLHAoKS5wZXJjZW50YWdlRm9ybWF0KX0sby5jdXJyZW50Q3VycmVuY3lEZWZhdWx0Rm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sby5jdXJyZW50RGVmYXVsdHMoKSxwKCkuY3VycmVuY3lGb3JtYXQpfSxvLmN1cnJlbnRUaW1lRGVmYXVsdEZvcm1hdD1mdW5jdGlvbigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LG8uY3VycmVudERlZmF1bHRzKCkscCgpLnRpbWVGb3JtYXQpfSxvLnNldERlZmF1bHRzPWZ1bmN0aW9uKGUpe2U9YS5wYXJzZUZvcm1hdChlKSxuLnZhbGlkYXRlRm9ybWF0KGUpJiYobD1lKX0sby5nZXRaZXJvRm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIHN9LG8uc2V0WmVyb0Zvcm1hdD1mdW5jdGlvbihlKXtyZXR1cm4gcz1cInN0cmluZ1wiPT10eXBlb2YgZT9lOm51bGx9LG8uaGFzWmVyb0Zvcm1hdD1mdW5jdGlvbigpe3JldHVybiBudWxsIT09c30sby5sYW5ndWFnZURhdGE9ZnVuY3Rpb24oZSl7aWYoZSl7aWYoY1tlXSlyZXR1cm4gY1tlXTt0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdGFnIFwiJy5jb25jYXQoZSwnXCInKSl9cmV0dXJuIHAoKX0sby5yZWdpc3Rlckxhbmd1YWdlPWZ1bmN0aW9uKGUpe3ZhciB0PTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV07aWYoIW4udmFsaWRhdGVMYW5ndWFnZShlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxhbmd1YWdlIGRhdGFcIik7Y1tlLmxhbmd1YWdlVGFnXT1lLHQmJmYoZS5sYW5ndWFnZVRhZyl9LG8uc2V0TGFuZ3VhZ2U9ZnVuY3Rpb24oZSl7dmFyIHQ9MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmkubGFuZ3VhZ2VUYWc7aWYoIWNbZV0pe3ZhciByPWUuc3BsaXQoXCItXCIpWzBdLG49T2JqZWN0LmtleXMoYykuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdChcIi1cIilbMF09PT1yfSk7cmV0dXJuIGNbbl0/dm9pZCBmKG4pOnZvaWQgZih0KX1mKGUpfSxvLnJlZ2lzdGVyTGFuZ3VhZ2UoaSksdT1pLmxhbmd1YWdlVGFnLHQuZXhwb3J0cz1vfSx7XCIuL2VuLVVTXCI6MixcIi4vcGFyc2luZ1wiOjgsXCIuL3ZhbGlkYXRpbmdcIjoxMH1dLDU6W2Z1bmN0aW9uKG4sZSx0KXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJue2xvYWRMYW5ndWFnZXNJbk5vZGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHI9dCx2b2lkIGUuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT12b2lkIDA7dHJ5e2U9bihcIi4uL2xhbmd1YWdlcy9cIi5jb25jYXQodCkpfWNhdGNoKGUpe2NvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byBsb2FkIFwiJy5jb25jYXQodCwnXCIuIE5vIG1hdGNoaW5nIGxhbmd1YWdlIGZpbGUgZm91bmQuJykpfWUmJnIucmVnaXN0ZXJMYW5ndWFnZShlKX0pO3ZhciByfX19fSx7fV0sNjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBjPWUoXCJiaWdudW1iZXIuanNcIik7ZnVuY3Rpb24gYShlLHQscil7dmFyIG49bmV3IGMoZS5fdmFsdWUpLGk9dDtyZXR1cm4gci5pc051bWJybyh0KSYmKGk9dC5fdmFsdWUpLGk9bmV3IGMoaSksZS5fdmFsdWU9bi5taW51cyhpKS50b051bWJlcigpLGV9dC5leHBvcnRzPWZ1bmN0aW9uKHUpe3JldHVybnthZGQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbj10LGk9dSxhPW5ldyBjKChyPWUpLl92YWx1ZSksbz1uLGkuaXNOdW1icm8obikmJihvPW4uX3ZhbHVlKSxvPW5ldyBjKG8pLHIuX3ZhbHVlPWEucGx1cyhvKS50b051bWJlcigpLHI7dmFyIHIsbixpLGEsb30sc3VidHJhY3Q6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYShlLHQsdSl9LG11bHRpcGx5OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG49dCxpPXUsYT1uZXcgYygocj1lKS5fdmFsdWUpLG89bixpLmlzTnVtYnJvKG4pJiYobz1uLl92YWx1ZSksbz1uZXcgYyhvKSxyLl92YWx1ZT1hLnRpbWVzKG8pLnRvTnVtYmVyKCkscjt2YXIgcixuLGksYSxvfSxkaXZpZGU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbj10LGk9dSxhPW5ldyBjKChyPWUpLl92YWx1ZSksbz1uLGkuaXNOdW1icm8obikmJihvPW4uX3ZhbHVlKSxvPW5ldyBjKG8pLHIuX3ZhbHVlPWEuZGl2aWRlZEJ5KG8pLnRvTnVtYmVyKCkscjt2YXIgcixuLGksYSxvfSxzZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gcj1lLGk9bj10LHUuaXNOdW1icm8obikmJihpPW4uX3ZhbHVlKSxyLl92YWx1ZT1pLHI7dmFyIHIsbixpfSxkaWZmZXJlbmNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHI9dCxhKGk9KG49dSkoZS5fdmFsdWUpLHIsbiksTWF0aC5hYnMoaS5fdmFsdWUpO3ZhciByLG4saX0sQmlnTnVtYmVyOmN9fX0se1wiYmlnbnVtYmVyLmpzXCI6MX1dLDc6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX12YXIgYT1lKFwiLi9nbG9iYWxTdGF0ZVwiKSxuPWUoXCIuL3ZhbGlkYXRpbmdcIiksbz1lKFwiLi9sb2FkaW5nXCIpKGcpLHU9ZShcIi4vdW5mb3JtYXR0aW5nXCIpLGM9ZShcIi4vZm9ybWF0dGluZ1wiKShnKSxzPWUoXCIuL21hbmlwdWxhdGluZ1wiKShnKSxsPWUoXCIuL3BhcnNpbmdcIiksZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyx0KSx0aGlzLl92YWx1ZT1lfXZhciBlLHIsbjtyZXR1cm4gZT10LChyPVt7a2V5OlwiY2xvbmVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBnKHRoaXMuX3ZhbHVlKX19LHtrZXk6XCJmb3JtYXRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0wPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWU/ZTp7fTtyZXR1cm4gYy5mb3JtYXQodGhpcyx0KX19LHtrZXk6XCJmb3JtYXRDdXJyZW5jeVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1sLnBhcnNlRm9ybWF0KGUpKSwoZT1jLmZvcm1hdE9yRGVmYXVsdChlLGEuY3VycmVudEN1cnJlbmN5RGVmYXVsdEZvcm1hdCgpKSkub3V0cHV0PVwiY3VycmVuY3lcIixjLmZvcm1hdCh0aGlzLGUpfX0se2tleTpcImZvcm1hdFRpbWVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0wPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWU/ZTp7fTtyZXR1cm4gdC5vdXRwdXQ9XCJ0aW1lXCIsYy5mb3JtYXQodGhpcyx0KX19LHtrZXk6XCJiaW5hcnlCeXRlVW5pdHNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBjLmdldEJpbmFyeUJ5dGVVbml0KHRoaXMpfX0se2tleTpcImRlY2ltYWxCeXRlVW5pdHNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBjLmdldERlY2ltYWxCeXRlVW5pdCh0aGlzKX19LHtrZXk6XCJieXRlVW5pdHNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBjLmdldEJ5dGVVbml0KHRoaXMpfX0se2tleTpcImRpZmZlcmVuY2VcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gcy5kaWZmZXJlbmNlKHRoaXMsZSl9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuYWRkKHRoaXMsZSl9fSx7a2V5Olwic3VidHJhY3RcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gcy5zdWJ0cmFjdCh0aGlzLGUpfX0se2tleTpcIm11bHRpcGx5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMubXVsdGlwbHkodGhpcyxlKX19LHtrZXk6XCJkaXZpZGVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gcy5kaXZpZGUodGhpcyxlKX19LHtrZXk6XCJzZXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gcy5zZXQodGhpcyxwKGUpKX19LHtrZXk6XCJ2YWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ZhbHVlfX0se2tleTpcInZhbHVlT2ZcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl92YWx1ZX19XSkmJmkoZS5wcm90b3R5cGUsciksbiYmaShlLG4pLHR9KCk7ZnVuY3Rpb24gcChlKXt2YXIgdD1lO3JldHVybiBnLmlzTnVtYnJvKGUpP3Q9ZS5fdmFsdWU6XCJzdHJpbmdcIj09dHlwZW9mIGU/dD1nLnVuZm9ybWF0KGUpOmlzTmFOKGUpJiYodD1OYU4pLHR9ZnVuY3Rpb24gZyhlKXtyZXR1cm4gbmV3IGYocChlKSl9Zy52ZXJzaW9uPVwiMi4zLjJcIixnLmlzTnVtYnJvPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgZn0sZy5sYW5ndWFnZT1hLmN1cnJlbnRMYW5ndWFnZSxnLnJlZ2lzdGVyTGFuZ3VhZ2U9YS5yZWdpc3Rlckxhbmd1YWdlLGcuc2V0TGFuZ3VhZ2U9YS5zZXRMYW5ndWFnZSxnLmxhbmd1YWdlcz1hLmxhbmd1YWdlcyxnLmxhbmd1YWdlRGF0YT1hLmxhbmd1YWdlRGF0YSxnLnplcm9Gb3JtYXQ9YS5zZXRaZXJvRm9ybWF0LGcuZGVmYXVsdEZvcm1hdD1hLmN1cnJlbnREZWZhdWx0cyxnLnNldERlZmF1bHRzPWEuc2V0RGVmYXVsdHMsZy5kZWZhdWx0Q3VycmVuY3lGb3JtYXQ9YS5jdXJyZW50Q3VycmVuY3lEZWZhdWx0Rm9ybWF0LGcudmFsaWRhdGU9bi52YWxpZGF0ZSxnLmxvYWRMYW5ndWFnZXNJbk5vZGU9by5sb2FkTGFuZ3VhZ2VzSW5Ob2RlLGcudW5mb3JtYXQ9dS51bmZvcm1hdCxnLkJpZ051bWJlcj1zLkJpZ051bWJlcix0LmV4cG9ydHM9Z30se1wiLi9mb3JtYXR0aW5nXCI6MyxcIi4vZ2xvYmFsU3RhdGVcIjo0LFwiLi9sb2FkaW5nXCI6NSxcIi4vbWFuaXB1bGF0aW5nXCI6NixcIi4vcGFyc2luZ1wiOjgsXCIuL3VuZm9ybWF0dGluZ1wiOjksXCIuL3ZhbGlkYXRpbmdcIjoxMH1dLDg6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9e3BhcnNlRm9ybWF0OmZ1bmN0aW9uKGUpe3ZhciB0LHIsbixpLGEsbyx1LGMscyxsLGYscCxnLGQsaCx2LG0seSxiLHcsUyx4LE89MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBlP2U6KHI9TyxlPShuPSh0PWUpLm1hdGNoKC9eeyhbXn1dKil9LykpPyhyLnByZWZpeD1uWzFdLHQuc2xpY2UoblswXS5sZW5ndGgpKTp0LGE9TyxmdW5jdGlvbihlLHQpe2lmKC0xPT09ZS5pbmRleE9mKFwiJFwiKSl7aWYoLTE9PT1lLmluZGV4T2YoXCIlXCIpKXJldHVybi0xIT09ZS5pbmRleE9mKFwiYmRcIik/KHQub3V0cHV0PVwiYnl0ZVwiLHQuYmFzZT1cImdlbmVyYWxcIik6LTEhPT1lLmluZGV4T2YoXCJiXCIpPyh0Lm91dHB1dD1cImJ5dGVcIix0LmJhc2U9XCJiaW5hcnlcIik6LTEhPT1lLmluZGV4T2YoXCJkXCIpPyh0Lm91dHB1dD1cImJ5dGVcIix0LmJhc2U9XCJkZWNpbWFsXCIpOi0xPT09ZS5pbmRleE9mKFwiOlwiKT8tMSE9PWUuaW5kZXhPZihcIm9cIikmJih0Lm91dHB1dD1cIm9yZGluYWxcIik6dC5vdXRwdXQ9XCJ0aW1lXCI7dC5vdXRwdXQ9XCJwZXJjZW50XCJ9ZWxzZSB0Lm91dHB1dD1cImN1cnJlbmN5XCJ9KGU9KG89KGk9ZSkubWF0Y2goL3soW159XSopfSQvKSk/KGEucG9zdGZpeD1vWzFdLGkuc2xpY2UoMCwtb1swXS5sZW5ndGgpKTppLE8pLHU9TywoYz1lLm1hdGNoKC9bMS05XStbMC05XSovKSkmJih1LnRvdGFsTGVuZ3RoPStjWzBdKSxzPU8sKGw9ZS5zcGxpdChcIi5cIilbMF0ubWF0Y2goLzArLykpJiYocy5jaGFyYWN0ZXJpc3RpYz1sWzBdLmxlbmd0aCksZnVuY3Rpb24oZSx0KXtpZigtMSE9PWUuaW5kZXhPZihcIi5cIikpe3ZhciByPWUuc3BsaXQoXCIuXCIpWzBdO3Qub3B0aW9uYWxDaGFyYWN0ZXJpc3RpYz0tMT09PXIuaW5kZXhPZihcIjBcIil9fShlLE8pLGY9TywtMSE9PWUuaW5kZXhPZihcImFcIikmJihmLmF2ZXJhZ2U9ITApLGc9TywtMSE9PShwPWUpLmluZGV4T2YoXCJLXCIpP2cuZm9yY2VBdmVyYWdlPVwidGhvdXNhbmRcIjotMSE9PXAuaW5kZXhPZihcIk1cIik/Zy5mb3JjZUF2ZXJhZ2U9XCJtaWxsaW9uXCI6LTEhPT1wLmluZGV4T2YoXCJCXCIpP2cuZm9yY2VBdmVyYWdlPVwiYmlsbGlvblwiOi0xIT09cC5pbmRleE9mKFwiVFwiKSYmKGcuZm9yY2VBdmVyYWdlPVwidHJpbGxpb25cIiksZnVuY3Rpb24oZSx0KXt2YXIgcj1lLnNwbGl0KFwiLlwiKVsxXTtpZihyKXt2YXIgbj1yLm1hdGNoKC8wKy8pO24mJih0Lm1hbnRpc3NhPW5bMF0ubGVuZ3RoKX19KGUsTyksaD1PLChkPWUpLm1hdGNoKC9cXFtcXC5dLyk/aC5vcHRpb25hbE1hbnRpc3NhPSEwOmQubWF0Y2goL1xcLi8pJiYoaC5vcHRpb25hbE1hbnRpc3NhPSExKSx2PU8sKG09ZS5zcGxpdChcIi5cIilbMV0pJiYodi50cmltTWFudGlzc2E9LTEhPT1tLmluZGV4T2YoXCJbXCIpKSx5PU8sLTEhPT1lLmluZGV4T2YoXCIsXCIpJiYoeS50aG91c2FuZFNlcGFyYXRlZD0hMCksYj1PLC0xIT09ZS5pbmRleE9mKFwiIFwiKSYmKGIuc3BhY2VTZXBhcmF0ZWQ9ITAsYi5zcGFjZVNlcGFyYXRlZEN1cnJlbmN5PSEwLChiLmF2ZXJhZ2V8fGIuZm9yY2VBdmVyYWdlKSYmKGIuc3BhY2VTZXBhcmF0ZWRBYmJyZXZpYXRpb249ITApKSxTPU8sKHc9ZSkubWF0Y2goL15cXCs/XFwoW14pXSpcXCkkLykmJihTLm5lZ2F0aXZlPVwicGFyZW50aGVzaXNcIiksdy5tYXRjaCgvXlxcKz8tLykmJihTLm5lZ2F0aXZlPVwic2lnblwiKSx4PU8sZS5tYXRjaCgvXlxcKy8pJiYoeC5mb3JjZVNpZ249ITApLE8pfX19LHt9XSw5OltmdW5jdGlvbihwLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIE09W3trZXk6XCJaaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCw3KX0se2tleTpcIlpCXCIsZmFjdG9yOk1hdGgucG93KDFlMyw3KX0se2tleTpcIllpQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDgpfSx7a2V5OlwiWUJcIixmYWN0b3I6TWF0aC5wb3coMWUzLDgpfSx7a2V5OlwiVGlCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsNCl9LHtrZXk6XCJUQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsNCl9LHtrZXk6XCJQaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCw1KX0se2tleTpcIlBCXCIsZmFjdG9yOk1hdGgucG93KDFlMyw1KX0se2tleTpcIk1pQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDIpfSx7a2V5OlwiTUJcIixmYWN0b3I6TWF0aC5wb3coMWUzLDIpfSx7a2V5OlwiS2lCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsMSl9LHtrZXk6XCJLQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsMSl9LHtrZXk6XCJHaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCwzKX0se2tleTpcIkdCXCIsZmFjdG9yOk1hdGgucG93KDFlMywzKX0se2tleTpcIkVpQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDYpfSx7a2V5OlwiRUJcIixmYWN0b3I6TWF0aC5wb3coMWUzLDYpfSx7a2V5OlwiQlwiLGZhY3RvcjoxfV07ZnVuY3Rpb24gQShlKXtyZXR1cm4gZS5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLFwiXFxcXCQmXCIpfWZ1bmN0aW9uIGcoZSx0LHIsbixpLGEsbyl7dmFyIHU9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1yP3I6XCJcIixjPTM8YXJndW1lbnRzLmxlbmd0aD9uOnZvaWQgMCxzPTQ8YXJndW1lbnRzLmxlbmd0aD9pOnZvaWQgMCxsPTU8YXJndW1lbnRzLmxlbmd0aD9hOnZvaWQgMCxmPTY8YXJndW1lbnRzLmxlbmd0aD9vOnZvaWQgMDtpZihcIlwiIT09ZSlyZXR1cm4gZT09PXM/MDpmdW5jdGlvbiBlKHQscixuLGksYSxvLHUpe3ZhciBjPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09bj9uOlwiXCIscz0zPGFyZ3VtZW50cy5sZW5ndGg/aTp2b2lkIDAsbD00PGFyZ3VtZW50cy5sZW5ndGg/YTp2b2lkIDAsZj01PGFyZ3VtZW50cy5sZW5ndGg/bzp2b2lkIDAscD02PGFyZ3VtZW50cy5sZW5ndGg/dTp2b2lkIDA7aWYoIWlzTmFOKCt0KSlyZXR1cm4rdDt2YXIgZz1cIlwiLGQ9dC5yZXBsYWNlKC8oXlteKF0qKVxcKCguKilcXCkoW14pXSokKS8sXCIkMSQyJDNcIik7aWYoZCE9PXQpcmV0dXJuLTEqZShkLHIsYyxzLGwsZixwKTtmb3IodmFyIGg9MDtoPE0ubGVuZ3RoO2grKyl7dmFyIHY9TVtoXTtpZigoZz10LnJlcGxhY2UoUmVnRXhwKFwiKFswLTkgXSkoXCIuY29uY2F0KHYua2V5LFwiKSRcIikpLFwiJDFcIikpIT09dClyZXR1cm4gZShnLHIsYyxzLGwsZixwKSp2LmZhY3Rvcn1pZigoZz10LnJlcGxhY2UoXCIlXCIsXCJcIikpIT09dClyZXR1cm4gZShnLHIsYyxzLGwsZixwKS8xMDA7dmFyIG09cGFyc2VGbG9hdCh0KTtpZighaXNOYU4obSkpe3ZhciB5PXMobSk7aWYoeSYmXCIuXCIhPT15JiYoZz10LnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChBKHkpLFwiJFwiKSksXCJcIikpIT09dClyZXR1cm4gZShnLHIsYyxzLGwsZixwKTt2YXIgYj17fTtPYmplY3Qua2V5cyhmKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2JbZltlXV09ZX0pO2Zvcih2YXIgdz1PYmplY3Qua2V5cyhiKS5zb3J0KCkucmV2ZXJzZSgpLFM9dy5sZW5ndGgseD0wO3g8Uzt4Kyspe3ZhciBPPXdbeF0sTj1iW09dO2lmKChnPXQucmVwbGFjZShPLFwiXCIpKSE9PXQpe3ZhciBCPXZvaWQgMDtzd2l0Y2goTil7Y2FzZVwidGhvdXNhbmRcIjpCPU1hdGgucG93KDEwLDMpO2JyZWFrO2Nhc2VcIm1pbGxpb25cIjpCPU1hdGgucG93KDEwLDYpO2JyZWFrO2Nhc2VcImJpbGxpb25cIjpCPU1hdGgucG93KDEwLDkpO2JyZWFrO2Nhc2VcInRyaWxsaW9uXCI6Qj1NYXRoLnBvdygxMCwxMil9cmV0dXJuIGUoZyxyLGMscyxsLGYscCkqQn19fX0oZnVuY3Rpb24oZSx0LHIpe3ZhciBuPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09cj9yOlwiXCIsaT1lLnJlcGxhY2UobixcIlwiKTtyZXR1cm4gaT0oaT1pLnJlcGxhY2UobmV3IFJlZ0V4cChcIihbMC05XSlcIi5jb25jYXQoQSh0LnRob3VzYW5kcyksXCIoWzAtOV0pXCIpLFwiZ1wiKSxcIiQxJDJcIikpLnJlcGxhY2UodC5kZWNpbWFsLFwiLlwiKX0oZSx0LHUpLHQsdSxjLHMsbCxmKX1lLmV4cG9ydHM9e3VuZm9ybWF0OmZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLGE9cChcIi4vZ2xvYmFsU3RhdGVcIiksbz1hLmN1cnJlbnREZWxpbWl0ZXJzKCksdT1hLmN1cnJlbnRDdXJyZW5jeSgpLnN5bWJvbCxjPWEuY3VycmVudE9yZGluYWwoKSxzPWEuZ2V0WmVyb0Zvcm1hdCgpLGw9YS5jdXJyZW50QWJicmV2aWF0aW9ucygpLGY9dm9pZCAwO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKWY9ZnVuY3Rpb24oZSx0KXtpZihlLmluZGV4T2YoXCI6XCIpJiZcIjpcIiE9PXQudGhvdXNhbmRzKXt2YXIgcj1lLnNwbGl0KFwiOlwiKTtpZigzPT09ci5sZW5ndGgpe3ZhciBuPStyWzBdLGk9K3JbMV0sYT0rclsyXTtyZXR1cm4haXNOYU4obikmJiFpc05hTihpKSYmIWlzTmFOKGEpfX19KGUsbyk/KHI9ZS5zcGxpdChcIjpcIiksbj0rclswXSxpPStyWzFdLCtyWzJdKzYwKmkrMzYwMCpuKTpnKGUsbyx1LGMscyxsLHQpO2Vsc2V7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpcmV0dXJuO2Y9ZX1pZih2b2lkIDAhPT1mKXJldHVybiBmfX19LHtcIi4vZ2xvYmFsU3RhdGVcIjo0fV0sMTA6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxyPW5ldyBBcnJheShlLmxlbmd0aCk7dDxlLmxlbmd0aDt0Kyspclt0XT1lW3RdO3JldHVybiByfX0oZSl8fGZ1bmN0aW9uKGUpe2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpcmV0dXJuIEFycmF5LmZyb20oZSl9KGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX1mdW5jdGlvbiBmKGUpe3JldHVybihmPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX12YXIgaT1lKFwiLi91bmZvcm1hdHRpbmdcIiksYT0vXlthLXpdezIsM30oLVthLXpBLVpdezR9KT8oLShbQS1aXXsyfXxbMC05XXszfSkpPyQvLHA9e291dHB1dDp7dHlwZTpcInN0cmluZ1wiLHZhbGlkVmFsdWVzOltcImN1cnJlbmN5XCIsXCJwZXJjZW50XCIsXCJieXRlXCIsXCJ0aW1lXCIsXCJvcmRpbmFsXCIsXCJudW1iZXJcIl19LGJhc2U6e3R5cGU6XCJzdHJpbmdcIix2YWxpZFZhbHVlczpbXCJkZWNpbWFsXCIsXCJiaW5hcnlcIixcImdlbmVyYWxcIl0scmVzdHJpY3Rpb246ZnVuY3Rpb24oZSx0KXtyZXR1cm5cImJ5dGVcIj09PXQub3V0cHV0fSxtZXNzYWdlOlwiYGJhc2VgIG11c3QgYmUgcHJvdmlkZWQgb25seSB3aGVuIHRoZSBvdXRwdXQgaXMgYGJ5dGVgXCIsbWFuZGF0b3J5OmZ1bmN0aW9uKGUpe3JldHVyblwiYnl0ZVwiPT09ZS5vdXRwdXR9fSxjaGFyYWN0ZXJpc3RpYzp7dHlwZTpcIm51bWJlclwiLHJlc3RyaWN0aW9uOmZ1bmN0aW9uKGUpe3JldHVybiAwPD1lfSxtZXNzYWdlOlwidmFsdWUgbXVzdCBiZSBwb3NpdGl2ZVwifSxwcmVmaXg6XCJzdHJpbmdcIixwb3N0Zml4Olwic3RyaW5nXCIsZm9yY2VBdmVyYWdlOnt0eXBlOlwic3RyaW5nXCIsdmFsaWRWYWx1ZXM6W1widHJpbGxpb25cIixcImJpbGxpb25cIixcIm1pbGxpb25cIixcInRob3VzYW5kXCJdfSxhdmVyYWdlOlwiYm9vbGVhblwiLGxvd1ByZWNpc2lvbjp7dHlwZTpcImJvb2xlYW5cIixyZXN0cmljdGlvbjpmdW5jdGlvbihlLHQpe3JldHVybiEwPT09dC5hdmVyYWdlfSxtZXNzYWdlOlwiYGxvd1ByZWNpc2lvbmAgbXVzdCBiZSBwcm92aWRlZCBvbmx5IHdoZW4gdGhlIG9wdGlvbiBgYXZlcmFnZWAgaXMgc2V0XCJ9LGN1cnJlbmN5UG9zaXRpb246e3R5cGU6XCJzdHJpbmdcIix2YWxpZFZhbHVlczpbXCJwcmVmaXhcIixcImluZml4XCIsXCJwb3N0Zml4XCJdfSxjdXJyZW5jeVN5bWJvbDpcInN0cmluZ1wiLHRvdGFsTGVuZ3RoOnt0eXBlOlwibnVtYmVyXCIscmVzdHJpY3Rpb25zOlt7cmVzdHJpY3Rpb246ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PWV9LG1lc3NhZ2U6XCJ2YWx1ZSBtdXN0IGJlIHBvc2l0aXZlXCJ9LHtyZXN0cmljdGlvbjpmdW5jdGlvbihlLHQpe3JldHVybiF0LmV4cG9uZW50aWFsfSxtZXNzYWdlOlwiYHRvdGFsTGVuZ3RoYCBpcyBpbmNvbXBhdGlibGUgd2l0aCBgZXhwb25lbnRpYWxgXCJ9XX0sbWFudGlzc2E6e3R5cGU6XCJudW1iZXJcIixyZXN0cmljdGlvbjpmdW5jdGlvbihlKXtyZXR1cm4gMDw9ZX0sbWVzc2FnZTpcInZhbHVlIG11c3QgYmUgcG9zaXRpdmVcIn0sb3B0aW9uYWxNYW50aXNzYTpcImJvb2xlYW5cIix0cmltTWFudGlzc2E6XCJib29sZWFuXCIscm91bmRpbmdGdW5jdGlvbjpcImZ1bmN0aW9uXCIsb3B0aW9uYWxDaGFyYWN0ZXJpc3RpYzpcImJvb2xlYW5cIix0aG91c2FuZFNlcGFyYXRlZDpcImJvb2xlYW5cIixzcGFjZVNlcGFyYXRlZDpcImJvb2xlYW5cIixzcGFjZVNlcGFyYXRlZEN1cnJlbmN5OlwiYm9vbGVhblwiLHNwYWNlU2VwYXJhdGVkQWJicmV2aWF0aW9uOlwiYm9vbGVhblwiLGFiYnJldmlhdGlvbnM6e3R5cGU6XCJvYmplY3RcIixjaGlsZHJlbjp7dGhvdXNhbmQ6XCJzdHJpbmdcIixtaWxsaW9uOlwic3RyaW5nXCIsYmlsbGlvbjpcInN0cmluZ1wiLHRyaWxsaW9uOlwic3RyaW5nXCJ9fSxuZWdhdGl2ZTp7dHlwZTpcInN0cmluZ1wiLHZhbGlkVmFsdWVzOltcInNpZ25cIixcInBhcmVudGhlc2lzXCJdfSxmb3JjZVNpZ246XCJib29sZWFuXCIsZXhwb25lbnRpYWw6e3R5cGU6XCJib29sZWFuXCJ9LHByZWZpeFN5bWJvbDp7dHlwZTpcImJvb2xlYW5cIixyZXN0cmljdGlvbjpmdW5jdGlvbihlLHQpe3JldHVyblwicGVyY2VudFwiPT09dC5vdXRwdXR9LG1lc3NhZ2U6XCJgcHJlZml4U3ltYm9sYCBjYW4gYmUgcHJvdmlkZWQgb25seSB3aGVuIHRoZSBvdXRwdXQgaXMgYHBlcmNlbnRgXCJ9fSxvPXtsYW5ndWFnZVRhZzp7dHlwZTpcInN0cmluZ1wiLG1hbmRhdG9yeTohMCxyZXN0cmljdGlvbjpmdW5jdGlvbihlKXtyZXR1cm4gZS5tYXRjaChhKX0sbWVzc2FnZTpcInRoZSBsYW5ndWFnZSB0YWcgbXVzdCBmb2xsb3cgdGhlIEJDUCA0NyBzcGVjaWZpY2F0aW9uIChzZWUgaHR0cHM6Ly90b29scy5pZWZ0Lm9yZy9odG1sL2JjcDQ3KVwifSxkZWxpbWl0ZXJzOnt0eXBlOlwib2JqZWN0XCIsY2hpbGRyZW46e3Rob3VzYW5kczpcInN0cmluZ1wiLGRlY2ltYWw6XCJzdHJpbmdcIix0aG91c2FuZHNTaXplOlwibnVtYmVyXCJ9LG1hbmRhdG9yeTohMH0sYWJicmV2aWF0aW9uczp7dHlwZTpcIm9iamVjdFwiLGNoaWxkcmVuOnt0aG91c2FuZDp7dHlwZTpcInN0cmluZ1wiLG1hbmRhdG9yeTohMH0sbWlsbGlvbjp7dHlwZTpcInN0cmluZ1wiLG1hbmRhdG9yeTohMH0sYmlsbGlvbjp7dHlwZTpcInN0cmluZ1wiLG1hbmRhdG9yeTohMH0sdHJpbGxpb246e3R5cGU6XCJzdHJpbmdcIixtYW5kYXRvcnk6ITB9fSxtYW5kYXRvcnk6ITB9LHNwYWNlU2VwYXJhdGVkOlwiYm9vbGVhblwiLHNwYWNlU2VwYXJhdGVkQ3VycmVuY3k6XCJib29sZWFuXCIsb3JkaW5hbDp7dHlwZTpcImZ1bmN0aW9uXCIsbWFuZGF0b3J5OiEwfSxieXRlczp7dHlwZTpcIm9iamVjdFwiLGNoaWxkcmVuOntiaW5hcnlTdWZmaXhlczpcIm9iamVjdFwiLGRlY2ltYWxTdWZmaXhlczpcIm9iamVjdFwifX0sY3VycmVuY3k6e3R5cGU6XCJvYmplY3RcIixjaGlsZHJlbjp7c3ltYm9sOlwic3RyaW5nXCIscG9zaXRpb246XCJzdHJpbmdcIixjb2RlOlwic3RyaW5nXCJ9LG1hbmRhdG9yeTohMH0sZGVmYXVsdHM6XCJmb3JtYXRcIixvcmRpbmFsRm9ybWF0OlwiZm9ybWF0XCIsYnl0ZUZvcm1hdDpcImZvcm1hdFwiLHBlcmNlbnRhZ2VGb3JtYXQ6XCJmb3JtYXRcIixjdXJyZW5jeUZvcm1hdDpcImZvcm1hdFwiLHRpbWVEZWZhdWx0czpcImZvcm1hdFwiLGZvcm1hdHM6e3R5cGU6XCJvYmplY3RcIixjaGlsZHJlbjp7Zm91ckRpZ2l0czp7dHlwZTpcImZvcm1hdFwiLG1hbmRhdG9yeTohMH0sZnVsbFdpdGhUd29EZWNpbWFsczp7dHlwZTpcImZvcm1hdFwiLG1hbmRhdG9yeTohMH0sZnVsbFdpdGhUd29EZWNpbWFsc05vQ3VycmVuY3k6e3R5cGU6XCJmb3JtYXRcIixtYW5kYXRvcnk6ITB9LGZ1bGxXaXRoTm9EZWNpbWFsczp7dHlwZTpcImZvcm1hdFwiLG1hbmRhdG9yeTohMH19fX07ZnVuY3Rpb24gdShlKXtyZXR1cm4gdm9pZCAwIT09aS51bmZvcm1hdChlKX1mdW5jdGlvbiBnKGMscyxsLGUpe3ZhciB0PTM8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09ZSYmZSxyPU9iamVjdC5rZXlzKGMpLm1hcChmdW5jdGlvbihlKXtpZighc1tlXSlyZXR1cm4gY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdChsLFwiIEludmFsaWQga2V5OiBcIikuY29uY2F0KGUpKSwhMTt2YXIgdD1jW2VdLHI9c1tlXTtpZihcInN0cmluZ1wiPT10eXBlb2YgciYmKHI9e3R5cGU6cn0pLFwiZm9ybWF0XCI9PT1yLnR5cGUpe2lmKCFnKHQscCxcIltWYWxpZGF0ZSBcIi5jb25jYXQoZSxcIl1cIiksITApKXJldHVybiExfWVsc2UgaWYoZih0KSE9PXIudHlwZSlyZXR1cm4gY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdChsLFwiIFwiKS5jb25jYXQoZSwnIHR5cGUgbWlzbWF0Y2hlZDogXCInKS5jb25jYXQoci50eXBlLCdcIiBleHBlY3RlZCwgXCInKS5jb25jYXQoZih0KSwnXCIgcHJvdmlkZWQnKSksITE7aWYoci5yZXN0cmljdGlvbnMmJnIucmVzdHJpY3Rpb25zLmxlbmd0aClmb3IodmFyIG49ci5yZXN0cmljdGlvbnMubGVuZ3RoLGk9MDtpPG47aSsrKXt2YXIgYT1yLnJlc3RyaWN0aW9uc1tpXSxvPWEucmVzdHJpY3Rpb24sdT1hLm1lc3NhZ2U7aWYoIW8odCxjKSlyZXR1cm4gY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdChsLFwiIFwiKS5jb25jYXQoZSxcIiBpbnZhbGlkIHZhbHVlOiBcIikuY29uY2F0KHUpKSwhMX1pZihyLnJlc3RyaWN0aW9uJiYhci5yZXN0cmljdGlvbih0LGMpKXJldHVybiBjb25zb2xlLmVycm9yKFwiXCIuY29uY2F0KGwsXCIgXCIpLmNvbmNhdChlLFwiIGludmFsaWQgdmFsdWU6IFwiKS5jb25jYXQoci5tZXNzYWdlKSksITE7aWYoci52YWxpZFZhbHVlcyYmLTE9PT1yLnZhbGlkVmFsdWVzLmluZGV4T2YodCkpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCxcIiBcIikuY29uY2F0KGUsXCIgaW52YWxpZCB2YWx1ZTogbXVzdCBiZSBhbW9uZyBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHIudmFsaWRWYWx1ZXMpLCcsIFwiJykuY29uY2F0KHQsJ1wiIHByb3ZpZGVkJykpLCExO2lmKHIuY2hpbGRyZW4mJiFnKHQsci5jaGlsZHJlbixcIltWYWxpZGF0ZSBcIi5jb25jYXQoZSxcIl1cIikpKXJldHVybiExO3JldHVybiEwfSk7cmV0dXJuIHR8fHIucHVzaC5hcHBseShyLG4oT2JqZWN0LmtleXMocykubWFwKGZ1bmN0aW9uKGUpe3ZhciB0PXNbZV07aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PXt0eXBlOnR9KSx0Lm1hbmRhdG9yeSl7dmFyIHI9dC5tYW5kYXRvcnk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgciYmKHI9cihjKSksciYmdm9pZCAwPT09Y1tlXSlyZXR1cm4gY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdChsLCcgTWlzc2luZyBtYW5kYXRvcnkga2V5IFwiJykuY29uY2F0KGUsJ1wiJykpLCExfXJldHVybiEwfSkpKSxyLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlJiZ0fSwhMCl9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gZyhlLHAsXCJbVmFsaWRhdGUgZm9ybWF0XVwiKX10LmV4cG9ydHM9e3ZhbGlkYXRlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dShlKSxuPWModCk7cmV0dXJuIHImJm59LHZhbGlkYXRlRm9ybWF0OmMsdmFsaWRhdGVJbnB1dDp1LHZhbGlkYXRlTGFuZ3VhZ2U6ZnVuY3Rpb24oZSl7cmV0dXJuIGcoZSxvLFwiW1ZhbGlkYXRlIGxhbmd1YWdlXVwiKX19fSx7XCIuL3VuZm9ybWF0dGluZ1wiOjl9XX0se30sWzddKSg3KX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYnJvLm1pbi5qcy5tYXBcbiIsImltcG9ydCB7IE51bWVyaWMsIFJwY0Vycm9yLCBKc29uUnBjLCBTZXJpYWxpemUsIEtleSwgQXBpIH0gZnJvbSAnQHByb3Rvbi9qcyc7XG5pbXBvcnQgeyBjb25zdGFudHMgfSBmcm9tICdAYmxva3MvY29uc3RhbnRzJztcbmltcG9ydCB7IEpzb25ScGMgYXMgSnNvblJwYyQyIH0gZnJvbSAnQHByb3Rvbi9oeXBlcmlvbic7XG5pbXBvcnQgeyBKc29uUnBjIGFzIEpzb25ScGMkMSB9IGZyb20gJ0Bwcm90b24vbGlnaHQtYXBpJztcbmltcG9ydCB7IHVybEJ1aWxkZXIsIG5hdGl2ZVRyYW5zZm9ybUdldEFjdGlvbnMsIGRmdXNlVHJhbnNmb3JtR2V0QWN0aW9ucywgaHlwZXJpb25UcmFuc2Zvcm1HZXRBY3Rpb25zLCBlbmNvZGVOYW1lLCBzdHJpbmdfdG9fdWludDEyOF9oYXNoLCBoZXhUb1VpbnQ4QXJyYXksIGhpc3RvcnlUcmFuc2Zvcm1UcmFuc2FjdGlvbiwgaGlzdG9yeVRyYW5zZm9ybURlZmVycmVkVHJhbnNhY3Rpb24sIGh5cGVyaW9uVHJhbnNmb3JtVHJhbnNhY3Rpb24sIGZpb0tleVRvQWN0b3IgfSBmcm9tICdAYmxva3MvdXRpbHMnO1xuaW1wb3J0IGZldGNoIGZyb20gJ2Nyb3NzLWZldGNoJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBleGNoYW5nZVJhdGVzUGFyc2VyLCB3aXRoZHJhd2FsRmVlUXVvdGVQYXJzZXIgfSBmcm9tICdAcHJvdG9uL3dyYXAtY29uc3RhbnRzJztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuaW1wb3J0IHsgbXVsdGlwbHksIGRpdmlkZSwgZm9ybWF0RGF0ZSwgdXRjVGltZSwgc3RhcnREYXRlLCB0aW1lIH0gZnJvbSAnQGJsb2tzL251bWJlcnMnO1xuXG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovXG5cbiAgX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfTtcblxuICB2YXIgZXhwb3J0cyA9IHt9LFxuICAgICAgT3AgPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksXG4gICAgICAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICAgIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICAgIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIixcbiAgICAgIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwXG4gICAgfSksIG9ialtrZXldO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLFxuICAgICAgICBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksXG4gICAgICAgIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvci5faW52b2tlID0gZnVuY3Rpb24gKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuXG4gICAgICAgIGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkge1xuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnO1xuICAgICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgICAgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgICBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KGlubmVyRm4sIHNlbGYsIGNvbnRleHQpLCBnZW5lcmF0b3I7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgYXJnOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7XG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICAgIGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnLFxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWx1ZSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgdGhpcy5faW52b2tlID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcblxuICAgIGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkge1xuICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSkgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7XG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgIHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICB9O1xuICAgIDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBkb25lUmVzdWx0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkb25lOiAhMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSksIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbiksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7XG4gIH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjtcbiAgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX19hd2FpdDogYXJnXG4gICAgfTtcbiAgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpO1xuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICB9KTtcbiAgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpO1xuXG4gICAgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgZm9yICg7IGtleXMubGVuZ3RoOykge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgIH07XG4gIH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kb25lID0gITA7XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uO1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sXG4gICAgICAgICAgICByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLFxuICAgICAgICAgICAgICBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uICh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7XG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG4gICAgZmluaXNoOiBmdW5jdGlvbiAoZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2F0Y2g6IGZ1bmN0aW9uICh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiAoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9LCBleHBvcnRzO1xufVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIGdldEFjY291bnQoX3gpIHtcbiAgcmV0dXJuIF9nZXRBY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY2NvdW50KCkge1xuICBfZ2V0QWNjb3VudCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhY2NvdW50TmFtZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgYWNjb3VudDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF9hY2NvdW50KGFjY291bnROYW1lKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGFjY291bnQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgYWNjb3VudC5wZXJtaXNzaW9ucyA9IGFjY291bnQucGVybWlzc2lvbnMubWFwKGZ1bmN0aW9uIChwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgIHBlcm1pc3Npb24ucmVxdWlyZWRfYXV0aC5rZXlzID0gcGVybWlzc2lvbi5yZXF1aXJlZF9hdXRoLmtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmtleS5pbmRleE9mKF90aGlzLmNvbnN0YW50cy5LRVlfUFJFRklYKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGtleS5rZXkgPSBOdW1lcmljLmNvbnZlcnRMZWdhY3lQdWJsaWNLZXkoa2V5LmtleSwgX3RoaXMuY29uc3RhbnRzLktFWV9QUkVGSVgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gcGVybWlzc2lvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhY2NvdW50KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzZWFyY2hBY2NvdW50KF94MiwgX3gzKSB7XG4gIHJldHVybiBfc2VhcmNoQWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfc2VhcmNoQWNjb3VudCgpIHtcbiAgX3NlYXJjaEFjY291bnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHF1ZXJ5LCBsaW1pdCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEoIXF1ZXJ5IHx8ICEvKF5bYS16QS1aMTIzNDUuXSskKS8udGVzdChxdWVyeSkpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICghKHF1ZXJ5LmluZGV4T2YoJy4nKSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA0O1xuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfYnlfc2NvcGUoe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogcXVlcnksXG4gICAgICAgICAgICAgIHRhYmxlOiAndXNlcnJlcycsXG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiBcIlwiICsgcXVlcnkgKyAocXVlcnkubGVuZ3RoIDwgMTIgPyAneicucmVwZWF0KDEyIC0gcXVlcnkubGVuZ3RoKSA6ICcnKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Qucm93cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5zY29wZTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDEzO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDIudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzQsIDEzXV0pO1xuICB9KSk7XG4gIHJldHVybiBfc2VhcmNoQWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRHcmF2YXRhcihfeDQpIHtcbiAgcmV0dXJuIF9nZXRHcmF2YXRhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0R3JhdmF0YXIoKSB7XG4gIF9nZXRHcmF2YXRhciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYWNjb3VudCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHRoaXMuY29uc3RhbnRzLkNIQUlOID09PSAnZW9zJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuQUNDT1VOVF9JTkZPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuQUNDT1VOVF9JTkZPLFxuICAgICAgICAgICAgICB0YWJsZTogJ2FjY291bnRzJyxcbiAgICAgICAgICAgICAgdGFibGVfa2V5OiAnJyxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICduYW1lJyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGFjY291bnQsXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAxLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdC5yb3dzLmxlbmd0aCA+IDAgJiYgcmVzdWx0LnJvd3NbMF0uYWNjb3VudF9uYW1lID09PSBhY2NvdW50ID8gcmVzdWx0LnJvd3NbMF0gOiB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEdyYXZhdGFyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudChfeDUpIHtcbiAgcmV0dXJuIF9nZXRQYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFBhcmVudCgpIHtcbiAgX2dldFBhcmVudCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWNjb3VudCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVMuaW5jbHVkZXMoJ2h5cGVyaW9uJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5IWVBFUklPTl9VUkwpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5oeXBlcmlvbi5nZXRfY3JlYXRvcihhY2NvdW50KSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0aGlzLmdldCh1cmxCdWlsZGVyKHRoaXMuY29uc3RhbnRzLkFQSV9VUkwsICdoeXBlcmlvbicsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2dldF9jcmVhdG9yJyxcbiAgICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudFxuICAgICAgICAgICAgfSkpKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gOTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWNjb3VudExpZ2h0RGF0YShfeDYpIHtcbiAgcmV0dXJuIF9nZXRBY2NvdW50TGlnaHREYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY2NvdW50TGlnaHREYXRhKCkge1xuICBfZ2V0QWNjb3VudExpZ2h0RGF0YSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoYWNjb3VudE5hbWUpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHRoaXMubGlnaHRBcGkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMjtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpZ2h0QXBpLmdldF9hY2NvdW50X2luZm8oYWNjb3VudE5hbWUpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ1LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDUudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1syLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWNjb3VudExpZ2h0RGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBY3Rpb25zRnJvbU5hdGl2ZShfeCwgX3gyLCBfeDMsIF94NCkge1xuICByZXR1cm4gX2dldEFjdGlvbnNGcm9tTmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY3Rpb25zRnJvbU5hdGl2ZSgpIHtcbiAgX2dldEFjdGlvbnNGcm9tTmF0aXZlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFjY291bnROYW1lLCBhY3Rpb25Ta2lwLCBhY3Rpb25zUGVyUGFnZSwgaGlzdG9yeVR5cGUpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChoaXN0b3J5VHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGhpc3RvcnlUeXBlID0gJ25hdGl2ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhY3Rpb25zIGZyb206JywgaGlzdG9yeVR5cGUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZldGNoIFBhcmFtczonLCAnYWN0aW9uU2tpcCcsIGFjdGlvblNraXAsICdhY3Rpb25zUGVyUGFnZScsIGFjdGlvbnNQZXJQYWdlKTsgLy8gUmVxdWVzdFxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnNScGMuaGlzdG9yeV9nZXRfYWN0aW9ucyhhY2NvdW50TmFtZSwgYWN0aW9uU2tpcCwgYWN0aW9uc1BlclBhZ2UpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJldHJpZXZlIGFjdGlvbnMnKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmICghKGhpc3RvcnlUeXBlID09PSAnbmF0aXZlJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuYXRpdmVUcmFuc2Zvcm1HZXRBY3Rpb25zKHJlc3VsdCwgdGhpcy5jb25zdGFudHMpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWN0aW9uc0Zyb21OYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9ucyhfeDUsIF94NiwgX3g3KSB7XG4gIHJldHVybiBfZ2V0QWN0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWN0aW9ucygpIHtcbiAgX2dldEFjdGlvbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGFjY291bnROYW1lLCBoaXN0b3J5VHlwZSwgX3RlbXApIHtcbiAgICB2YXIgX3JlZiwgX3JlZiRhY3Rpb25zUGVyUGFnZSwgYWN0aW9uc1BlclBhZ2UsIF9yZWYkYWN0aW9uU2tpcCwgYWN0aW9uU2tpcCwgX3JlZiRzb3J0RGlyZWN0aW9uLCBzb3J0RGlyZWN0aW9uLCBfcmVmJGRmdXNlQ3Vyc29yU3RhY2ssIGRmdXNlQ3Vyc29yU3RhY2ssIHRva2VuRmlsdGVyLCBhY3Rpb25GaWx0ZXJzLCBjb250cmFjdEZpbHRlciwgYWN0aW9uRmlsdGVyLCBzdGFydCwgZW5kLCByZXN1bHQsIGlucHV0Q3Vyc29yO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCwgX3JlZiRhY3Rpb25zUGVyUGFnZSA9IF9yZWYuYWN0aW9uc1BlclBhZ2UsIGFjdGlvbnNQZXJQYWdlID0gX3JlZiRhY3Rpb25zUGVyUGFnZSA9PT0gdm9pZCAwID8gMTAwIDogX3JlZiRhY3Rpb25zUGVyUGFnZSwgX3JlZiRhY3Rpb25Ta2lwID0gX3JlZi5hY3Rpb25Ta2lwLCBhY3Rpb25Ta2lwID0gX3JlZiRhY3Rpb25Ta2lwID09PSB2b2lkIDAgPyAwIDogX3JlZiRhY3Rpb25Ta2lwLCBfcmVmJHNvcnREaXJlY3Rpb24gPSBfcmVmLnNvcnREaXJlY3Rpb24sIHNvcnREaXJlY3Rpb24gPSBfcmVmJHNvcnREaXJlY3Rpb24gPT09IHZvaWQgMCA/ICdkZXNjJyA6IF9yZWYkc29ydERpcmVjdGlvbiwgX3JlZiRkZnVzZUN1cnNvclN0YWNrID0gX3JlZi5kZnVzZUN1cnNvclN0YWNrLCBkZnVzZUN1cnNvclN0YWNrID0gX3JlZiRkZnVzZUN1cnNvclN0YWNrID09PSB2b2lkIDAgPyBbXSA6IF9yZWYkZGZ1c2VDdXJzb3JTdGFjaywgdG9rZW5GaWx0ZXIgPSBfcmVmLnRva2VuRmlsdGVyLCBhY3Rpb25GaWx0ZXJzID0gX3JlZi5hY3Rpb25GaWx0ZXJzLCBjb250cmFjdEZpbHRlciA9IF9yZWYuY29udHJhY3RGaWx0ZXIsIGFjdGlvbkZpbHRlciA9IF9yZWYuYWN0aW9uRmlsdGVyLCBzdGFydCA9IF9yZWYuc3RhcnQsIGVuZCA9IF9yZWYuZW5kO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5jb25zdGFudHMuQ0hBSU5fU1RBUlRfREFURTtcbiAgICAgICAgICAgIH0gLy8gRmFsbGJhY2sgZm9yIGhpc3RvcnkgdHlwZVxuXG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVMpO1xuXG4gICAgICAgICAgICBpZiAoIWhpc3RvcnlUeXBlICYmIHRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGhpc3RvcnlUeXBlID0gdGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFU1swXTtcbiAgICAgICAgICAgIH0gLy8gRml4IGZvciBmaXJlZm94IGFuZCBJRSBhbmQgc2FmYXJpXG5cblxuICAgICAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IHRoaXMuY29uc3RhbnRzLkNIQUlOX1NUQVJUX0RBVEUgPyBuZXcgRGF0ZShzdGFydCB8fCB0aGlzLmNvbnN0YW50cy5DSEFJTl9TVEFSVF9EQVRFKS50b0lTT1N0cmluZygpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBlbmQgPSBuZXcgRGF0ZShlbmQgfHwgbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBlbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKGhpc3RvcnlUeXBlID09PSAnZGZ1c2UnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5wdXRDdXJzb3IgPSBkZnVzZUN1cnNvclN0YWNrLmxlbmd0aCA+IDAgPyBkZnVzZUN1cnNvclN0YWNrW2RmdXNlQ3Vyc29yU3RhY2subGVuZ3RoIC0gMV0gOiAnJztcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjdGlvbnNGcm9tRGZ1c2UoYWNjb3VudE5hbWUsIHtcbiAgICAgICAgICAgICAgbGltaXQ6IGFjdGlvbnNQZXJQYWdlLFxuICAgICAgICAgICAgICBjdXJzb3I6IGlucHV0Q3Vyc29yLFxuICAgICAgICAgICAgICBkaXJlY3Rpb246IHNvcnREaXJlY3Rpb24sXG4gICAgICAgICAgICAgIHF1ZXJ5OiAnJyxcbiAgICAgICAgICAgICAgYWZ0ZXI6IHN0YXJ0LFxuICAgICAgICAgICAgICBiZWZvcmU6IGVuZCxcbiAgICAgICAgICAgICAgdG9rZW5GaWx0ZXI6IHRva2VuRmlsdGVyLFxuICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXJzOiBhY3Rpb25GaWx0ZXJzLFxuICAgICAgICAgICAgICBjb250cmFjdEZpbHRlcjogY29udHJhY3RGaWx0ZXIsXG4gICAgICAgICAgICAgIGFjdGlvbkZpbHRlcjogYWN0aW9uRmlsdGVyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGlmICghKGhpc3RvcnlUeXBlID09PSAnaHlwZXJpb24nKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjdGlvbnNGcm9tSHlwZXJpb24oYWNjb3VudE5hbWUsIHtcbiAgICAgICAgICAgICAgc2tpcDogTWF0aC5hYnMoYWN0aW9uU2tpcCkgLSAxLFxuICAgICAgICAgICAgICBsaW1pdDogYWN0aW9uc1BlclBhZ2UsXG4gICAgICAgICAgICAgIHNvcnQ6IHNvcnREaXJlY3Rpb24sXG4gICAgICAgICAgICAgIGFmdGVyOiBzdGFydCxcbiAgICAgICAgICAgICAgYmVmb3JlOiBlbmQsXG4gICAgICAgICAgICAgIHRva2VuRmlsdGVyOiB0b2tlbkZpbHRlcixcbiAgICAgICAgICAgICAgYWN0aW9uRmlsdGVyczogYWN0aW9uRmlsdGVycyxcbiAgICAgICAgICAgICAgY29udHJhY3RGaWx0ZXI6IGNvbnRyYWN0RmlsdGVyLFxuICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXI6IGFjdGlvbkZpbHRlclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjdGlvbnNGcm9tTmF0aXZlKGFjY291bnROYW1lLCBhY3Rpb25Ta2lwLCAtYWN0aW9uc1BlclBhZ2UsICduYXRpdmUnKTtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXN1bHQpO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uc0Zyb21EZnVzZShfeDgsIF94OSkge1xuICByZXR1cm4gX2dldEFjdGlvbnNGcm9tRGZ1c2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjdGlvbnNGcm9tRGZ1c2UoKSB7XG4gIF9nZXRBY3Rpb25zRnJvbURmdXNlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhY2NvdW50TmFtZSwgX3RlbXAyKSB7XG4gICAgdmFyIF9yZWYyLCBiZWZvcmUsIGFmdGVyLCBfcmVmMiRsaW1pdCwgbGltaXQsIGN1cnNvciwgcXVlcnksIF9yZWYyJGRpcmVjdGlvbiwgZGlyZWN0aW9uLCB0b2tlbkZpbHRlciwgYWN0aW9uRmlsdGVycywgY29udHJhY3RGaWx0ZXIsIGFjdGlvbkZpbHRlciwgX3JlZjIkdHlwZSwgdHlwZSwgcSwgX3Rva2VuRmlsdGVyJHNwbGl0LCB0b2tlbkNvbnRyYWN0LCB0b2tlbmZpbHRlciwgYWN0aW9uRmlsdGVyc0xvY2FsLCBhY3Rpb25GaWx0ZXJzUXVlcnksIHJlc3VsdDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmMiA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsIGJlZm9yZSA9IF9yZWYyLmJlZm9yZSwgYWZ0ZXIgPSBfcmVmMi5hZnRlciwgX3JlZjIkbGltaXQgPSBfcmVmMi5saW1pdCwgbGltaXQgPSBfcmVmMiRsaW1pdCA9PT0gdm9pZCAwID8gMjUgOiBfcmVmMiRsaW1pdCwgY3Vyc29yID0gX3JlZjIuY3Vyc29yLCBxdWVyeSA9IF9yZWYyLnF1ZXJ5LCBfcmVmMiRkaXJlY3Rpb24gPSBfcmVmMi5kaXJlY3Rpb24sIGRpcmVjdGlvbiA9IF9yZWYyJGRpcmVjdGlvbiA9PT0gdm9pZCAwID8gJ2Rlc2MnIDogX3JlZjIkZGlyZWN0aW9uLCB0b2tlbkZpbHRlciA9IF9yZWYyLnRva2VuRmlsdGVyLCBhY3Rpb25GaWx0ZXJzID0gX3JlZjIuYWN0aW9uRmlsdGVycywgY29udHJhY3RGaWx0ZXIgPSBfcmVmMi5jb250cmFjdEZpbHRlciwgYWN0aW9uRmlsdGVyID0gX3JlZjIuYWN0aW9uRmlsdGVyLCBfcmVmMiR0eXBlID0gX3JlZjIudHlwZSwgdHlwZSA9IF9yZWYyJHR5cGUgPT09IHZvaWQgMCA/ICdzZWFyY2hfdHJhbnNhY3Rpb25zX2dyYXBocWwnIDogX3JlZjIkdHlwZTtcbiAgICAgICAgICAgIHEgPSBxdWVyeSB8fCBcIihhdXRoOlwiICsgYWNjb3VudE5hbWUgKyBcIiBPUlxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXI6XCIgKyBhY2NvdW50TmFtZSArIFwiIE9SXFxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRvOlwiICsgYWNjb3VudE5hbWUgKyBcIiBPUlxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mcm9tOlwiICsgYWNjb3VudE5hbWUgKyBcIiBPUlxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5yZWNlaXZlcjpcIiArIGFjY291bnROYW1lICsgXCIpXCI7XG5cbiAgICAgICAgICAgIGlmICh0b2tlbkZpbHRlcikge1xuICAgICAgICAgICAgICBfdG9rZW5GaWx0ZXIkc3BsaXQgPSB0b2tlbkZpbHRlci5zcGxpdCgnICcpLCB0b2tlbkNvbnRyYWN0ID0gX3Rva2VuRmlsdGVyJHNwbGl0WzFdO1xuICAgICAgICAgICAgICB0b2tlbmZpbHRlciA9IFwiYWNjb3VudDpcIiArIHRva2VuQ29udHJhY3Q7XG4gICAgICAgICAgICAgIHEgPSBxICsgXCIgXCIgKyB0b2tlbmZpbHRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGlvbkZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgYWN0aW9uRmlsdGVyc0xvY2FsID0gT2JqZWN0LmVudHJpZXMoYWN0aW9uRmlsdGVycykucmVkdWNlKGZ1bmN0aW9uIChmaWx0ZXJzLCBfcmVmNCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWY0WzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5pc0FjdGl2ZSA/IGZpbHRlcnMuY29uY2F0KHZhbHVlKSA6IGZpbHRlcnM7XG4gICAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgICBpZiAoYWN0aW9uRmlsdGVyc0xvY2FsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFjdGlvbkZpbHRlcnNRdWVyeSA9IGFjdGlvbkZpbHRlcnNMb2NhbC5tYXAoZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5kZnVzZVF1ZXJ5KGFjY291bnROYW1lKTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcgT1IgJyk7IC8vIFdyYXAgYXJvdW5kIHRoZSBhY3Rpb24gZmlsdGVyc1xuXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbkZpbHRlcnNRdWVyeS5zZWFyY2goJ09SJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXJzUXVlcnkgPSBcIihcIiArIGFjdGlvbkZpbHRlcnNRdWVyeSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIH0gLy8gU2V0IHRoZSBhY3Rpb24gZmlsdGVyc1xuXG5cbiAgICAgICAgICAgICAgICBxID0gcSArIFwiIFwiICsgYWN0aW9uRmlsdGVyc1F1ZXJ5O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNvbnRyYWN0RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcSA9IHEgKyBcIiBhY2NvdW50OlwiICsgY29udHJhY3RGaWx0ZXI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYWN0aW9uRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcSA9IHEgKyBcIiBhY3Rpb246XCIgKyBhY3Rpb25GaWx0ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybEJ1aWxkZXIodGhpcy5jb25zdGFudHMuQVBJX1VSTCwgJ2RmdXNlJywge1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBxOiBxLFxuICAgICAgICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgc29ydDogZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogY3Vyc29yLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgICAgICB3aXRoUmV2ZXJzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGJlZm9yZSxcbiAgICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXIsXG4gICAgICAgICAgICAgICAgY29kZTogMVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmV0cmlldmUgYWN0aW9ucycpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgZGZ1c2VUcmFuc2Zvcm1HZXRBY3Rpb25zKHJlc3VsdCwgYWNjb3VudE5hbWUsIHRoaXMuY29uc3RhbnRzKSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWN0aW9uc0Zyb21EZnVzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBY3Rpb25zRnJvbUh5cGVyaW9uKF94MTAsIF94MTEpIHtcbiAgcmV0dXJuIF9nZXRBY3Rpb25zRnJvbUh5cGVyaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY3Rpb25zRnJvbUh5cGVyaW9uKCkge1xuICBfZ2V0QWN0aW9uc0Zyb21IeXBlcmlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWNjb3VudCwgX3RlbXAzKSB7XG4gICAgdmFyIF9yZWYzLCBza2lwLCBsaW1pdCwgc29ydCwgYWZ0ZXIsIGJlZm9yZSwgZmlsdGVyLCB0b2tlbkZpbHRlciwgYWN0aW9uRmlsdGVycywgY29udHJhY3RGaWx0ZXIsIGFjdGlvbkZpbHRlciwgcGFyYW1zLCByZXN1bHQsIF90b2tlbkZpbHRlciRzcGxpdDIsIHRva2VuQ29udHJhY3QsIGFjdGlvbkZpbHRlcnNMb2NhbCwgX2l0ZXJhdG9yLCBfc3RlcCwgZWFjaEZpbHRlciwgdW5pcXVlQ29udHJhY3RzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9yZWYzID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMywgc2tpcCA9IF9yZWYzLnNraXAsIGxpbWl0ID0gX3JlZjMubGltaXQsIHNvcnQgPSBfcmVmMy5zb3J0LCBhZnRlciA9IF9yZWYzLmFmdGVyLCBiZWZvcmUgPSBfcmVmMy5iZWZvcmUsIGZpbHRlciA9IF9yZWYzLmZpbHRlciwgdG9rZW5GaWx0ZXIgPSBfcmVmMy50b2tlbkZpbHRlciwgYWN0aW9uRmlsdGVycyA9IF9yZWYzLmFjdGlvbkZpbHRlcnMsIGNvbnRyYWN0RmlsdGVyID0gX3JlZjMuY29udHJhY3RGaWx0ZXIsIGFjdGlvbkZpbHRlciA9IF9yZWYzLmFjdGlvbkZpbHRlcjtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemVcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICAgIHNraXA6IHNraXAsXG4gICAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgICAgc29ydDogc29ydCxcbiAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyLFxuICAgICAgICAgICAgICBiZWZvcmU6IGJlZm9yZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhY3Rpb25zIGZyb20gSHlwZXJpb24nKTtcblxuICAgICAgICAgICAgLy8gVG9rZW4gZmlsdGVyLCB3ZSB3b3VsZCBvbmx5IHJlY2VpdmUgdW5kZWZpbmVkIG9yICo6YWN0aW9uXG4gICAgICAgICAgICBpZiAodG9rZW5GaWx0ZXIpIHtcbiAgICAgICAgICAgICAgX3Rva2VuRmlsdGVyJHNwbGl0MiA9IHRva2VuRmlsdGVyLnNwbGl0KCcgJyksIHRva2VuQ29udHJhY3QgPSBfdG9rZW5GaWx0ZXIkc3BsaXQyWzFdO1xuXG4gICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZpbHRlciA9IHBhcmFtcy5maWx0ZXIucmVwbGFjZSgnKicsIHRva2VuQ29udHJhY3QpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIgPSB0b2tlbkNvbnRyYWN0ICsgXCI6KlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhY3Rpb25GaWx0ZXJzKSB7XG4gICAgICAgICAgICAgIGFjdGlvbkZpbHRlcnNMb2NhbCA9IE9iamVjdC5lbnRyaWVzKGFjdGlvbkZpbHRlcnMpLnJlZHVjZShmdW5jdGlvbiAoZmlsdGVycywgX3JlZjUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmNVsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaXNBY3RpdmUgPyBmaWx0ZXJzLmNvbmNhdCh2YWx1ZSkgOiBmaWx0ZXJzO1xuICAgICAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGlvbkZpbHRlcnNMb2NhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWN0aW9uRmlsdGVyc0xvY2FsKTsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgICAgZWFjaEZpbHRlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgZWFjaEZpbHRlci5oeXBlcmlvblF1ZXJ5KGFjY291bnQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocGFyYW1zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBBY3Rpb25zIGNvbnRyYWN0IGZpbHRlcnNcblxuXG4gICAgICAgICAgICBpZiAoY29udHJhY3RGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyID0gcGFyYW1zLmZpbHRlci5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3RGaWx0ZXIgKyBcIjpcIiArIGZpbHRlci5zcGxpdCgnOicpWzFdO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyID0gY29udHJhY3RGaWx0ZXIgKyBcIjoqXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGlvbkZpbHRlcikge1xuICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHVuaXF1ZUNvbnRyYWN0cyA9IEFycmF5LmZyb20obmV3IFNldChwYXJhbXMuZmlsdGVyLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIuc3BsaXQoJzonKVswXTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIgPSB1bmlxdWVDb250cmFjdHMubWFwKGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0ICsgXCI6XCIgKyBhY3Rpb25GaWx0ZXI7XG4gICAgICAgICAgICAgICAgfSkuam9pbignLCcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIgPSBcIio6XCIgKyBhY3Rpb25GaWx0ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gSWYgaHlwZXJpb24gVVJMIHByb3ZpZGVkLCBkbyBpdCBjbGllbnQgc2lkZVxuXG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdGFudHMuSFlQRVJJT05fVVJMKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb24uZ2V0X2FjdGlvbnMoYWNjb3VudCwgT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmxCdWlsZGVyKHRoaXMuY29uc3RhbnRzLkFQSV9VUkwsICdoeXBlcmlvbicsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2dldF9hY3Rpb25zJyxcbiAgICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NC5zZW50O1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJldHJpZXZlIGFjdGlvbnMnKTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBoeXBlcmlvblRyYW5zZm9ybUdldEFjdGlvbnMocmVzdWx0KSk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWN0aW9uc0Zyb21IeXBlcmlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREYXBwU3RhdHMoKSB7XG4gIHJldHVybiBfZ2V0RGFwcFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREYXBwU3RhdHMoKSB7XG4gIF9nZXREYXBwU3RhdHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2RhcHBzZXJ2aWNlcycsXG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICBzY29wZTogJy4uLi4uLjJrZTEubzQnLFxuICAgICAgICAgICAgICB0YWJsZTogJ3N0YXRleHQnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghKCFyZXN1bHQgfHwgIXJlc3VsdC5yb3dzIHx8ICFyZXN1bHQucm93cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7fSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdC5yb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMTtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge30pO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCAxMV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERhcHBTdGF0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREc3BQYWNrYWdlcygpIHtcbiAgcmV0dXJuIF9nZXREc3BQYWNrYWdlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RHNwUGFja2FnZXMoKSB7XG4gIF9nZXREc3BQYWNrYWdlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2RhcHBzZXJ2aWNlcycsXG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiA1MDAsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZGFwcHNlcnZpY2VzJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdwYWNrYWdlJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCAmJiByZXN1bHQucm93cyAmJiByZXN1bHQucm93cy5sZW5ndGggPyByZXN1bHQucm93cyA6IFtdKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gNztcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQyLnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCA3XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RHNwUGFja2FnZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGFwcGhvZGxCYWxhbmNlKF94KSB7XG4gIHJldHVybiBfZ2V0RGFwcGhvZGxCYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREYXBwaG9kbEJhbGFuY2UoKSB7XG4gIF9nZXREYXBwaG9kbEJhbGFuY2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGFjY291bnQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZGFwcGFpcmhvZGwxJyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgICAgIHNjb3BlOiBhY2NvdW50LFxuICAgICAgICAgICAgICB0YWJsZTogJ2FjY291bnRzJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCAmJiByZXN1bHQucm93cyAmJiByZXN1bHQucm93cy5sZW5ndGggPyByZXN1bHQucm93c1swXSA6IHt9KTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gNztcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwge30pO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzAsIDddXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREYXBwaG9kbEJhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGFwcEJhbGFuY2UoX3gyKSB7XG4gIHJldHVybiBfZ2V0RGFwcEJhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERhcHBCYWxhbmNlKCkge1xuICBfZ2V0RGFwcEJhbGFuY2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGFjY291bnQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZGFwcHNlcnZpY2VzJyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgICAgIHNjb3BlOiBhY2NvdW50LFxuICAgICAgICAgICAgICB0YWJsZTogJ2FjY291bnRzJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCAmJiByZXN1bHQucm93cyAmJiByZXN1bHQucm93cy5sZW5ndGggPyByZXN1bHQucm93c1swXSA6IHt9KTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gNztcbiAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IF9jb250ZXh0NFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwge30pO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzAsIDddXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREYXBwQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREYXBwU3Rha2VzKF94Mykge1xuICByZXR1cm4gX2dldERhcHBTdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERhcHBTdGFrZXMoKSB7XG4gIF9nZXREYXBwU3Rha2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShhY2NvdW50KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2RhcHBzZXJ2aWNlcycsXG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDAsXG4gICAgICAgICAgICAgIHNjb3BlOiBhY2NvdW50LFxuICAgICAgICAgICAgICB0YWJsZTogJ3N0YWtpbmcnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0ICYmIHJlc3VsdC5yb3dzICYmIHJlc3VsdC5yb3dzLmxlbmd0aCA/IHJlc3VsdC5yb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJvdy5zY29wZSA9IGFjY291bnQ7XG4gICAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgICAgICB9KSA6IFtdKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gNztcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzAsIDddXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREYXBwU3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERhcHBob2RsU3Rha2VzKF94NCwgX3g1KSB7XG4gIHJldHVybiBfZ2V0RGFwcGhvZGxTdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERhcHBob2RsU3Rha2VzKCkge1xuICBfZ2V0RGFwcGhvZGxTdGFrZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGFjY291bnQsIGxvd2VyX2JvdW5kKSB7XG4gICAgdmFyIHJlc3VsdCwgcm93cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGxvd2VyX2JvdW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2RhcHBzZXJ2aWNlcycsXG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDAwLFxuICAgICAgICAgICAgICBzY29wZTogJ2RhcHBhaXJob2RsMScsXG4gICAgICAgICAgICAgIHRhYmxlOiAnc3Rha2luZycsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBsb3dlcl9ib3VuZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDYuc2VudDtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByb3dzID0gcmVzdWx0LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghcmVzdWx0Lm1vcmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IHJvd3M7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDEyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGFwcGhvZGxTdGFrZXMoYWNjb3VudCwgK3Jvd3Nbcm93cy5sZW5ndGggLSAxXS5pZCArIDEpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MSA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF9jb250ZXh0Ni50MC5jb25jYXQuY2FsbChfY29udGV4dDYudDAsIF9jb250ZXh0Ni50MSk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gcm93LmFjY291bnQgPT09IGFjY291bnQ7XG4gICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByb3cuc2NvcGUgPSAnZGFwcGFpcmhvZGwxJztcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDE3O1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQyID0gX2NvbnRleHQ2W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYsIHRoaXMsIFtbMSwgMTddXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREYXBwaG9kbFN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREYXBwVW5zdGFrZXMoX3g2KSB7XG4gIHJldHVybiBfZ2V0RGFwcFVuc3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREYXBwVW5zdGFrZXMoKSB7XG4gIF9nZXREYXBwVW5zdGFrZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KGFjY291bnQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZGFwcHNlcnZpY2VzJyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMCxcbiAgICAgICAgICAgICAgc2NvcGU6IGFjY291bnQsXG4gICAgICAgICAgICAgIHRhYmxlOiAncmVmdW5kcydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCByZXN1bHQgJiYgcmVzdWx0LnJvd3MgJiYgcmVzdWx0LnJvd3MubGVuZ3RoID8gcmVzdWx0LnJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcm93LnNjb3BlID0gYWNjb3VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgICAgIH0pIDogW10pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSA3O1xuICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTcsIHRoaXMsIFtbMCwgN11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERhcHBVbnN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREYXBwaG9kbFVuc3Rha2VzKF94Nykge1xuICByZXR1cm4gX2dldERhcHBob2RsVW5zdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERhcHBob2RsVW5zdGFrZXMoKSB7XG4gIF9nZXREYXBwaG9kbFVuc3Rha2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOChhY2NvdW50KSB7XG4gICAgdmFyIHJlc3VsdCwgcm93cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2RhcHBzZXJ2aWNlcycsXG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDAwLFxuICAgICAgICAgICAgICBzY29wZTogJ2RhcHBhaXJob2RsMScsXG4gICAgICAgICAgICAgIHRhYmxlOiAncmVmdW5kcydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ4LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcm93cyA9IHJlc3VsdC5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5tb3JlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDgudDAgPSByb3dzO1xuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhcHBob2RsVW5zdGFrZXMoYWNjb3VudCk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQ4LnQxID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX2NvbnRleHQ4LnQwLmNvbmNhdC5jYWxsKF9jb250ZXh0OC50MCwgX2NvbnRleHQ4LnQxKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuYWNjb3VudCA9PT0gYWNjb3VudDtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJvdy5zY29wZSA9ICdkYXBwYWlyaG9kbDEnO1xuICAgICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMTY7XG4gICAgICAgICAgICBfY29udGV4dDgudDIgPSBfY29udGV4dDhbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlOCwgdGhpcywgW1swLCAxNl1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERhcHBob2RsVW5zdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIGh0dHAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZjIgPSAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKF9yZWYpIHtcbiAgICB2YXIgcGF0aCwgbWV0aG9kLCBib2R5LCBoZWFkZXJzLCBkYXRhLCByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwYXRoID0gX3JlZi5wYXRoLCBtZXRob2QgPSBfcmVmLm1ldGhvZCwgYm9keSA9IF9yZWYuYm9keSwgaGVhZGVycyA9IF9yZWYuaGVhZGVycztcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2gocGF0aCwge1xuICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyB8fCB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDEwO1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgUnBjRXJyb3IoZGF0YSB8fCAnRXJyb3InKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxLCAxMF1dKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBodHRwKF94KSB7XG4gICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG52YXIgZ2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYzID0gLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocGF0aCwgaGVhZGVycykge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gaHR0cCh7XG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGdldChfeDIsIF94Mykge1xuICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xudmFyIHBvc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZjQgPSAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhwYXRoLCBib2R5KSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBodHRwKHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0My5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBwb3N0KF94NCwgX3g1KSB7XG4gICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGdldEZJT1ZvdGVyKF94KSB7XG4gIHJldHVybiBfZ2V0RklPVm90ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEZJT1ZvdGVyKCkge1xuICBfZ2V0RklPVm90ZXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB1cHBlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHRhYmxlOiAndm90ZXJzJyxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpNjQnLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogMyxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Qucm93cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cy5sZW5ndGggPyByb3dzWzBdIDogdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RklPVm90ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RklPQWRkcmVzc0J5TmFtZShfeDIpIHtcbiAgcmV0dXJuIF9nZXRGSU9BZGRyZXNzQnlOYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRGSU9BZGRyZXNzQnlOYW1lKCkge1xuICBfZ2V0RklPQWRkcmVzc0J5TmFtZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIobmFtZSkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IHRoaXMucnBjO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ190b191aW50MTI4X2hhc2gobmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfY29udGV4dDIudDEgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MiA9ICcweCcgKyBfY29udGV4dDIudDE7XG4gICAgICAgICAgICBfY29udGV4dDIudDMgPSB7XG4gICAgICAgICAgICAgIGNvZGU6ICdmaW8uYWRkcmVzcycsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZmlvLmFkZHJlc3MnLFxuICAgICAgICAgICAgICB0YWJsZTogJ2Zpb25hbWVzJyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IF9jb250ZXh0Mi50MixcbiAgICAgICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTEyOCcsXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiA1XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi50MC5nZXRfdGFibGVfcm93cy5jYWxsKF9jb250ZXh0Mi50MCwgX2NvbnRleHQyLnQzKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGggJiYgcm93c1swXS5uYW1lID09PSBuYW1lKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxODtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50NCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQyLnQ0KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbMCwgMThdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRGSU9BZGRyZXNzQnlOYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldE5GVHNCeUZpb0FkZHJlc3MoX3gzKSB7XG4gIHJldHVybiBfZ2V0TkZUc0J5RmlvQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0TkZUc0J5RmlvQWRkcmVzcygpIHtcbiAgX2dldE5GVHNCeUZpb0FkZHJlc3MgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKG5hbWUpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF9uLCBuZnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfbmZ0c19maW9fYWRkcmVzcyhuYW1lKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfbiA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgbmZ0cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfbi5uZnRzO1xuXG4gICAgICAgICAgICBpZiAoIShuZnRzICYmIG5mdHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBuZnRzKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxMjtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQzLnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCAxMl1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldE5GVHNCeUZpb0FkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RklPRG9tYWluQnlOYW1lKF94NCkge1xuICByZXR1cm4gX2dldEZJT0RvbWFpbkJ5TmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RklPRG9tYWluQnlOYW1lKCkge1xuICBfZ2V0RklPRG9tYWluQnlOYW1lID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChuYW1lKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDMsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gdGhpcy5ycGM7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nX3RvX3VpbnQxMjhfaGFzaChuYW1lKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF9jb250ZXh0NC50MSA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQ0LnQyID0gJzB4JyArIF9jb250ZXh0NC50MTtcbiAgICAgICAgICAgIF9jb250ZXh0NC50MyA9IHtcbiAgICAgICAgICAgICAgY29kZTogJ2Zpby5hZGRyZXNzJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdmaW8uYWRkcmVzcycsXG4gICAgICAgICAgICAgIHRhYmxlOiAnZG9tYWlucycsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBfY29udGV4dDQudDIsXG4gICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2kxMjgnLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogNFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQudDAuZ2V0X3RhYmxlX3Jvd3MuY2FsbChfY29udGV4dDQudDAsIF9jb250ZXh0NC50Myk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QzID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90My5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoICYmIHJvd3NbMF0ubmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTg7XG4gICAgICAgICAgICBfY29udGV4dDQudDQgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0NC50NCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzAsIDE4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RklPRG9tYWluQnlOYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERvbWFpbnMoX3g1LCBfeDYpIHtcbiAgcmV0dXJuIF9nZXREb21haW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREb21haW5zKCkge1xuICBfZ2V0RG9tYWlucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUobGltaXQsIHVwcGVyX2JvdW5kKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDQsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbGltaXQgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2Zpby5hZGRyZXNzJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdmaW8uYWRkcmVzcycsXG4gICAgICAgICAgICAgIHRhYmxlOiAnZG9tYWlucycsXG4gICAgICAgICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiB1cHBlcl9ib3VuZCxcbiAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDQgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q0LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0NS50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMSwgMTNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREb21haW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFkZHJlc3NlcyhfeDcsIF94OCkge1xuICByZXR1cm4gX2dldEFkZHJlc3Nlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWRkcmVzc2VzKCkge1xuICBfZ2V0QWRkcmVzc2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihsaW1pdCwgdXBwZXJfYm91bmQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90NSwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBsaW1pdCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZmlvLmFkZHJlc3MnLFxuICAgICAgICAgICAgICBzY29wZTogJ2Zpby5hZGRyZXNzJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdmaW9uYW1lcycsXG4gICAgICAgICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiB1cHBlcl9ib3VuZCxcbiAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDUgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Ni50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYsIHRoaXMsIFtbMSwgMTNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBZGRyZXNzZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RklPUHJvZHVjZXJzKF94OSkge1xuICByZXR1cm4gX2dldEZJT1Byb2R1Y2Vycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RklPUHJvZHVjZXJzKCkge1xuICBfZ2V0RklPUHJvZHVjZXJzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhsaW1pdCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q2LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAncHJvZHVjZXJzJyxcbiAgICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDYgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q2LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDEyO1xuICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDcudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU3LCB0aGlzLCBbWzAsIDEyXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RklPUHJvZHVjZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEZJT0JhbGFuY2UoX3gxMCkge1xuICByZXR1cm4gX2dldEZJT0JhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEZJT0JhbGFuY2UoKSB7XG4gIF9nZXRGSU9CYWxhbmNlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOChmaW9fcHVibGljX2tleSkge1xuICAgIHZhciBiYWxhbmNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZmV0Y2goJy92MS9jaGFpbi9nZXRfZmlvX2JhbGFuY2UnLCB7XG4gICAgICAgICAgICAgIGZpb19wdWJsaWNfa2V5OiBmaW9fcHVibGljX2tleVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBiYWxhbmNlID0gX2NvbnRleHQ4LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghYmFsYW5jZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBiYWxhbmNlKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMTE7XG4gICAgICAgICAgICBfY29udGV4dDgudDAgPSBfY29udGV4dDhbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0OC50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlOCwgdGhpcywgW1swLCAxMV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEZJT0JhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RklPU3VwcGx5QnJlYWtkb3duKCkge1xuICByZXR1cm4gX2dldEZJT1N1cHBseUJyZWFrZG93bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RklPU3VwcGx5QnJlYWtkb3duKCkge1xuICBfZ2V0RklPU3VwcGx5QnJlYWtkb3duID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOSgpIHtcbiAgICB2YXIgdG9rZW5SZXMsIHN1cHBseSwgYnBSZXdhcmRSZXMsIGJwUmV3YXJkcywgYnBCdWNrZXRSZXMsIGJwQnVja2V0LCB0b3RhbEJwLCBjaXJjdWxhdGluZywgdG90YWxMb2NrZWQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IFwiZmlvLnRva2VuXCIsXG4gICAgICAgICAgICAgIHNjb3BlOiBcIkZJT1wiLFxuICAgICAgICAgICAgICB0YWJsZTogXCJzdGF0XCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdG9rZW5SZXMgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgIHN1cHBseSA9ICt0b2tlblJlcy5yb3dzWzBdLnN1cHBseS5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogXCJmaW8udHJlYXN1cnlcIixcbiAgICAgICAgICAgICAgc2NvcGU6IFwiZmlvLnRyZWFzdXJ5XCIsXG4gICAgICAgICAgICAgIHRhYmxlOiBcImJwcmV3YXJkc1wiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGJwUmV3YXJkUmVzID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICBicFJld2FyZHMgPSBicFJld2FyZFJlcy5yb3dzWzBdLnJld2FyZHMgLyBNYXRoLnBvdygxMCwgdGhpcy5jb25zdGFudHMuQ09SRV9QUkVDSVNJT04pO1xuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IFwiZmlvLnRyZWFzdXJ5XCIsXG4gICAgICAgICAgICAgIHNjb3BlOiBcImZpby50cmVhc3VyeVwiLFxuICAgICAgICAgICAgICB0YWJsZTogXCJicGJ1Y2tldHBvb2xcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgYnBCdWNrZXRSZXMgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgIGJwQnVja2V0ID0gYnBCdWNrZXRSZXMucm93c1swXS5yZXdhcmRzIC8gTWF0aC5wb3coMTAsIHRoaXMuY29uc3RhbnRzLkNPUkVfUFJFQ0lTSU9OKTtcbiAgICAgICAgICAgIHRvdGFsQnAgPSBicFJld2FyZHMgKyBicEJ1Y2tldDsgLy8gY29uc3QgdG90YWxMb2NrZWQgPSBiYXNlTG9ja2VkICsgdG90YWxCcFxuICAgICAgICAgICAgLy8gY29uc3QgY2lyY3VsYXRpbmcgPSBzdXBwbHkgLSB0b3RhbExvY2tlZFxuXG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDE1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdodHRwczovL2Zpb3Byb3RvY29sLmlvL2NpcmN1bGF0aW5nJyk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgY2lyY3VsYXRpbmcgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgIHRvdGFsTG9ja2VkID0gc3VwcGx5IC0gK2NpcmN1bGF0aW5nO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBzdXBwbHk6IHN1cHBseSxcbiAgICAgICAgICAgICAgdG90YWxMb2NrZWQ6IHRvdGFsTG9ja2VkLFxuICAgICAgICAgICAgICBicFJld2FyZHM6IGJwUmV3YXJkcyxcbiAgICAgICAgICAgICAgYnBCdWNrZXQ6IGJwQnVja2V0LFxuICAgICAgICAgICAgICB0b3RhbEJwOiB0b3RhbEJwLFxuICAgICAgICAgICAgICBjaXJjdWxhdGluZzogY2lyY3VsYXRpbmdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU5LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEZJT1N1cHBseUJyZWFrZG93bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRGSU9GZWVzKCkge1xuICByZXR1cm4gX2dldEZJT0ZlZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEZJT0ZlZXMoKSB7XG4gIF9nZXRGSU9GZWVzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnZmlvLmZlZScsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZmlvLmZlZScsXG4gICAgICAgICAgICAgIHRhYmxlOiAnZmlvZmVlcycsXG4gICAgICAgICAgICAgIGxpbWl0OiAtMVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQucm93cztcbiAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUxMCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRGSU9GZWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGFkZEZJT0ZlZVRvQWN0aW9ucyhfeDExLCBfeDEyKSB7XG4gIHJldHVybiBfYWRkRklPRmVlVG9BY3Rpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9hZGRGSU9GZWVUb0FjdGlvbnMoKSB7XG4gIF9hZGRGSU9GZWVUb0FjdGlvbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMShhY3Rpb25zLCBhY3Rvcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZmlvRmVlc01hcCwgZmVlcywgbW9kaWZpZWRBY3Rpb25zLCBfbG9vcCwgX2l0ZXJhdG9yLCBfc3RlcDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgZmlvRmVlc01hcCA9IHtcbiAgICAgICAgICAgICAgJ2Vvc2lvOjpkZWxldGVhdXRoJzogJ2F1dGhfZGVsZXRlJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvOjpsaW5rYXV0aCc6ICdhdXRoX2xpbmsnLFxuICAgICAgICAgICAgICAnZW9zaW86OnJlZ3Byb2R1Y2VyJzogJ3JlZ2lzdGVyX3Byb2R1Y2VyJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvOjpyZWdwcm94eSc6ICdyZWdpc3Rlcl9wcm94eScsXG4gICAgICAgICAgICAgICdlb3Npbzo6dW5yZWdwcm9kJzogJ3VucmVnaXN0ZXJfcHJvZHVjZXInLFxuICAgICAgICAgICAgICAnZW9zaW86OnVucmVncHJveHknOiAndW5yZWdpc3Rlcl9wcm94eScsXG4gICAgICAgICAgICAgICdlb3Npbzo6dXBkYXRlYXV0aCc6ICdhdXRoX3VwZGF0ZScsXG4gICAgICAgICAgICAgICdlb3Npbzo6dm90ZXByb2R1Y2VyJzogJ3ZvdGVfcHJvZHVjZXInLFxuICAgICAgICAgICAgICAnZW9zaW86OnZvdGVwcm94eSc6ICdwcm94eV92b3RlJyxcbiAgICAgICAgICAgICAgJ2Zpby50b2tlbjo6dHJuc2Zpb3B1Ymt5JzogJ3RyYW5zZmVyX3Rva2Vuc19wdWJfa2V5JyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjphZGRhZGRyZXNzJzogJ2FkZF9wdWJfYWRkcmVzcycsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6cmVnYWRkcmVzcyc6ICdyZWdpc3Rlcl9maW9fYWRkcmVzcycsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6cmVnZG9tYWluJzogJ3JlZ2lzdGVyX2Zpb19kb21haW4nLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OnJlbmV3YWRkcmVzcyc6ICdyZW5ld19maW9fYWRkcmVzcycsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6cmVuZXdkb21haW4nOiAncmVuZXdfZmlvX2RvbWFpbicsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6c2V0ZG9tYWlucHViJzogJ3NldF9maW9fZG9tYWluX3B1YmxpYycsXG4gICAgICAgICAgICAgICdlb3Npby5tc2lnOjphcHByb3ZlJzogJ21zaWdfYXBwcm92ZScsXG4gICAgICAgICAgICAgICdlb3Npby5tc2lnOjpjYW5jZWwnOiAnbXNpZ19jYW5jZWwnLFxuICAgICAgICAgICAgICAnZW9zaW8ubXNpZzo6ZXhlYyc6ICdtc2lnX2V4ZWMnLFxuICAgICAgICAgICAgICAnZW9zaW8ubXNpZzo6aW52YWxpZGF0ZSc6ICdtc2lnX2ludmFsaWRhdGUnLFxuICAgICAgICAgICAgICAnZW9zaW8ubXNpZzo6cHJvcG9zZSc6ICdtc2lnX3Byb3Bvc2UnLFxuICAgICAgICAgICAgICAnZW9zaW8ubXNpZzo6dW5hcHByb3ZlJzogJ21zaWdfYXBwcm92ZScsXG4gICAgICAgICAgICAgICdmaW8ucmVxb2J0OjpuZXdmdW5kc3JlcSc6ICduZXdfZnVuZHNfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICdmaW8ucmVxb2J0OjpyZWplY3RmbmRyZXEnOiAncmVqZWN0X2Z1bmRzX3JlcXVlc3QnLFxuICAgICAgICAgICAgICAnZmlvLnJlcW9idDo6Y2FuY2VsZm5kcmVxJzogJ2NhbmNlbGZuZHJlcScsXG4gICAgICAgICAgICAgICdmaW8ucmVxb2J0OjpyZWNvcmRvYnQnOiAncmVjb3JkX29idF9kYXRhJyxcbiAgICAgICAgICAgICAgJ2Zpby5yZXFvYnQ6Om5ld3B1YmFkZHJlcSc6ICduZXdfcHViX2FkZHJlc3NfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICdmaW8ucmVxb2J0OjpyZWxwdWJhZGQnOiAncmVsZWFzZV9wdWJfYWRkcmVzcycsXG4gICAgICAgICAgICAgICdmaW8ucmVxb2J0OjpyZWplY3RhZGRyZXEnOiAncmVqZWN0X3B1Yl9hZGRyZXNzX3JlcXVlc3QnLFxuICAgICAgICAgICAgICAnZmlvLnJlcW9idDo6Y2FuY2VsYWRkcmVxJzogJ2NhbmNlbF9wdWJfYWRkcmVzc19yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgJ2Zpby5sb2NrOjp0cm5zbG9jdG9rcyc6ICd0cmFuc2Zlcl9sb2NrZWRfdG9rZW5zJyxcbiAgICAgICAgICAgICAgJ2Zpby5sb2NrOjpsb2NrdG9rZW5zJzogJ2xvY2tfdG9rZW5zJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjpyZW1hZGRyZXNzJzogJ3JlbW92ZV9wdWJfYWRkcmVzcycsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6cmVtYWxsYWRkcic6ICdyZW1vdmVfYWxsX3B1Yl9hZGRyZXNzZXMnLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OmJ1cm5hZGRyZXNzJzogJ2J1cm5fZmlvX2FkZHJlc3MnLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OnhmZXJkb21haW4nOiAndHJhbnNmZXJfZmlvX2RvbWFpbicsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6eGZlcmFkZHJlc3MnOiAndHJhbnNmZXJfZmlvX2FkZHJlc3MnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZJT0ZlZXMoKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGZlZXMgPSBfY29udGV4dDEyLnNlbnQ7XG4gICAgICAgICAgICBtb2RpZmllZEFjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIF9sb29wID0gLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgICAgICB2YXIgYWN0aW9uLCBfeWllbGQkX3RoaXMkYXBpJGdldEMsIF95aWVsZCRfdGhpcyRhcGkkZ2V0QzIsIGFiaUFjdGlvbnMsIGFiaVN0cnVjdHMsIHJlbGV2YW50QWN0aW9uLCByZWxldmFudFN0cnVjdCwgbWF4RmVlRmllbGQsIGVuZHBvaW50LCByZWxldmFudEZlZSwgYWN0b3JGaWVsZCwgdHBpZEZpZWxkLCBhZGRyZXNzRmllbGQsIGFkZHJlc3NlcztcblxuICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2xvb3AkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFwaS5nZXRDYWNoZWRBYmkoYWN0aW9uLmFjY291bnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICBfeWllbGQkX3RoaXMkYXBpJGdldEMgPSBfY29udGV4dDExLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgX3lpZWxkJF90aGlzJGFwaSRnZXRDMiA9IF95aWVsZCRfdGhpcyRhcGkkZ2V0Qy5hYmk7XG4gICAgICAgICAgICAgICAgICAgICAgYWJpQWN0aW9ucyA9IF95aWVsZCRfdGhpcyRhcGkkZ2V0QzIuYWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICBhYmlTdHJ1Y3RzID0gX3lpZWxkJF90aGlzJGFwaSRnZXRDMi5zdHJ1Y3RzO1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGV2YW50QWN0aW9uID0gYWJpQWN0aW9ucy5maW5kKGZ1bmN0aW9uIChhYmlBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhYmlBY3Rpb24ubmFtZSA9PT0gYWN0aW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbGV2YW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHJlbGV2YW50U3RydWN0ID0gYWJpU3RydWN0cy5maW5kKGZ1bmN0aW9uIChhYmlTdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhYmlTdHJ1Y3QubmFtZSA9PT0gcmVsZXZhbnRBY3Rpb24udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVsZXZhbnRTdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgbWF4RmVlRmllbGQgPSByZWxldmFudFN0cnVjdC5maWVsZHMuZmluZChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC5uYW1lID09PSBcIm1heF9mZWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhGZWVGaWVsZCAmJiBhY3Rpb24uZGF0YS5tYXhfZmVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gZmlvRmVlc01hcFthY3Rpb24uYWNjb3VudCArIFwiOjpcIiArIGFjdGlvbi5uYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGV2YW50RmVlID0gZmVlcy5maW5kKGZ1bmN0aW9uIChmZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmVlLmVuZF9wb2ludCA9PT0gZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxldmFudEZlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5kYXRhLm1heF9mZWUgPSByZWxldmFudEZlZS5zdWZfYW1vdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5kYXRhLm1heF9mZWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgYWN0b3JGaWVsZCA9IHJlbGV2YW50U3RydWN0LmZpZWxkcy5maW5kKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm5hbWUgPT09IFwiYWN0b3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RvckZpZWxkICYmIGFjdGlvbi5kYXRhLmFjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5kYXRhLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgdHBpZEZpZWxkID0gcmVsZXZhbnRTdHJ1Y3QuZmllbGRzLmZpbmQoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQubmFtZSA9PT0gXCJ0cGlkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHBpZEZpZWxkICYmIGFjdGlvbi5kYXRhLnRwaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmRhdGEudHBpZCA9IF90aGlzLmNvbnN0YW50cy5GSU9fRkVFU19BQ0NPVU5UO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NGaWVsZCA9IHJlbGV2YW50U3RydWN0LmZpZWxkcy5maW5kKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm5hbWUgPT09IFwiZmlvX2FkZHJlc3NcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmICghKGFkZHJlc3NGaWVsZCAmJiBhY3Rpb24uZGF0YS5maW9fYWRkcmVzcyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0RklPQWRkcmVzc2VzKGFjdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlcyA9IF9jb250ZXh0MTEuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24uZGF0YS5maW9fYWRkcmVzcyA9IGFkZHJlc3Nlc1swXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkQWN0aW9ucy5wdXNoKGFjdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIF9sb29wKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY3Rpb25zKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlmICgoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmRlbGVnYXRlWWllbGQoX2xvb3AoKSwgXCJ0MFwiLCA5KTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwgbW9kaWZpZWRBY3Rpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTExLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2FkZEZJT0ZlZVRvQWN0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRGSU9BZGRyZXNzZXMoYWNjb3VudCkge1xuICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgIGNvZGU6ICdmaW8uYWRkcmVzcycsXG4gICAgc2NvcGU6ICdmaW8uYWRkcmVzcycsXG4gICAgdGFibGU6ICdmaW9uYW1lcycsXG4gICAga2V5X3R5cGU6ICdpNjQnLFxuICAgIGxpbWl0OiAtMSxcbiAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgdXBwZXJfYm91bmQ6IG5ldyBCaWdOdW1iZXIoZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSkpLnBsdXMoMSkudG9TdHJpbmcoKSxcbiAgICBpbmRleF9wb3NpdGlvbjogNFxuICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LnJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5yb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiByb3cub3duZXJfYWNjb3VudCA9PT0gYWNjb3VudDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZJT0RvbWFpbnMoYWNjb3VudCkge1xuICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgIGNvZGU6ICdmaW8uYWRkcmVzcycsXG4gICAgc2NvcGU6ICdmaW8uYWRkcmVzcycsXG4gICAgdGFibGU6ICdkb21haW5zJyxcbiAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgbGltaXQ6IC0xLFxuICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICB1cHBlcl9ib3VuZDogbmV3IEJpZ051bWJlcihlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSkucGx1cygxKS50b1N0cmluZygpLFxuICAgIGluZGV4X3Bvc2l0aW9uOiAyXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQucm93cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5hY2NvdW50ID09PSBhY2NvdW50O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF8pIHtcbiAgICByZXR1cm4gW107XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RklPQWRkcmVzc2VzQW5kRG9tYWlucyhmaW9fcHVibGljX2tleSkge1xuICByZXR1cm4gcG9zdCh0aGlzLmNvbnN0YW50cy5ERUZBVUxUX0VORFBPSU5UU1swXSArIFwiL3YxL2dldF9maW9fbmFtZXNcIiwge1xuICAgIGZpb19wdWJsaWNfa2V5OiBmaW9fcHVibGljX2tleVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxsTXNpZ3MoKSB7XG4gIHJldHVybiBfZ2V0QWxsTXNpZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFsbE1zaWdzKCkge1xuICBfZ2V0QWxsTXNpZ3MgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJGdldCwgdGFibGVzLCByb3dzLCBsb3dlcl9ib3VuZCwgcmVzdWx0O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTLmluY2x1ZGVzKCdkZnVzZScpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsQnVpbGRlcih0aGlzLmNvbnN0YW50cy5BUElfVVJMLCAnZGZ1c2UnLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdGF0ZV9zY29wZV9waXBlbGluZScsXG4gICAgICAgICAgICAgIGFjY291bnQ6IHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUcsXG4gICAgICAgICAgICAgIHRhYmxlOiB0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHX1BST1BPU0FMU19UQUJMRSxcbiAgICAgICAgICAgICAgb3B0aW9uczoge31cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICB0YWJsZXMgPSBfeWllbGQkdGhpcyRnZXQudGFibGVzO1xuICAgICAgICAgICAgdGFibGVzID0gdGFibGVzLm1hcChmdW5jdGlvbiAodGFibGUpIHtcbiAgICAgICAgICAgICAgdGFibGUucm93cyA9IHRhYmxlLnJvd3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBiLmJsb2NrIC0gYS5ibG9jaztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRhYmxlLmhpZ2hlc3RCbG9jayA9IHRhYmxlLnJvd3NbMF0uYmxvY2s7XG4gICAgICAgICAgICAgIHJldHVybiB0YWJsZTtcbiAgICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGIuaGlnaGVzdEJsb2NrIC0gYS5oaWdoZXN0QmxvY2s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGFibGVzKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJvd3MgPSBbXTtcbiAgICAgICAgICAgIGxvd2VyX2JvdW5kID0gJyc7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9ieV9zY29wZSh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6ICdlb3Npby5tc2lnJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMCxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGxvd2VyX2JvdW5kLFxuICAgICAgICAgICAgICB0YWJsZTogJ3Byb3Bvc2FsJyxcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6ICcnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgbG93ZXJfYm91bmQgPSByZXN1bHQubW9yZTtcbiAgICAgICAgICAgIHJvd3MgPSByb3dzLmNvbmNhdChyZXN1bHQucm93cyk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgaWYgKGxvd2VyX2JvdW5kKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NvcGU6IHJvdy5zY29wZSxcbiAgICAgICAgICAgICAgICByb3dzOiBBcnJheShyb3cuY291bnQpLmZpbGwoe1xuICAgICAgICAgICAgICAgICAga2V5OiAnJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFsbE1zaWdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldE1zaWdQcm9wb3NhbChfeCwgX3gyKSB7XG4gIHJldHVybiBfZ2V0TXNpZ1Byb3Bvc2FsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRNc2lnUHJvcG9zYWwoKSB7XG4gIF9nZXRNc2lnUHJvcG9zYWwgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGFjY291bnROYW1lLCBwcm9wb3NhbE5hbWUpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6ICdlb3Npby5tc2lnJyxcbiAgICAgICAgICAgICAgc2NvcGU6IGFjY291bnROYW1lLFxuICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IHByb3Bvc2FsTmFtZSxcbiAgICAgICAgICAgICAgdGFibGU6ICdwcm9wb3NhbCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGggJiYgcm93c1swXS5wcm9wb3NhbF9uYW1lID09PSBwcm9wb3NhbE5hbWUpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldE1zaWdQcm9wb3NhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhY2tlZE1zaWdBY3Rpb25zKF94Mykge1xuICByZXR1cm4gX3BhcnNlUGFja2VkTXNpZ0FjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3BhcnNlUGFja2VkTXNpZ0FjdGlvbnMoKSB7XG4gIF9wYXJzZVBhY2tlZE1zaWdBY3Rpb25zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhwYWNrZWRBY3Rpb25zKSB7XG4gICAgdmFyIGFjdGlvbnMsIF9pdGVyYXRvciwgX3N0ZXAsIGFjdGlvbjtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBhY3Rpb25zID0gW107XG4gICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHBhY2tlZEFjdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKChfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhY3Rpb24gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKCEoYWN0aW9uLmFjY291bnQgPT09IHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUcgJiYgYWN0aW9uLm5hbWUgPT09ICdwcm9wb3NlJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmRlc2VyaWFsaXplQWN0aW9uc1N5bmMoYWN0aW9uLmRhdGEudHJ4LmFjdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgYWN0aW9uLmRhdGEudHJ4LmFjdGlvbnMgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmICghKGFjdGlvbi5hY2NvdW50ID09PSB0aGlzLmNvbnN0YW50cy5FT1NJTyAmJiBhY3Rpb24ubmFtZSA9PT0gJ3NldGFiaScpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpLnJhd0FiaVRvSnNvbihoZXhUb1VpbnQ4QXJyYXkoYWN0aW9uLmRhdGEuYWJpKSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgYWN0aW9uLmRhdGEuYWJpID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25fdHJhY2U6IHtcbiAgICAgICAgICAgICAgICAgIGFjdDogYWN0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBhY3Rpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9wYXJzZVBhY2tlZE1zaWdBY3Rpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFja2VkTXNpZyhfeDQpIHtcbiAgcmV0dXJuIF9wYXJzZVBhY2tlZE1zaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3BhcnNlUGFja2VkTXNpZygpIHtcbiAgX3BhcnNlUGFja2VkTXNpZyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQocGFja2VkX3RyYW5zYWN0aW9uKSB7XG4gICAgdmFyIHR4O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGkuZGVzZXJpYWxpemVUcmFuc2FjdGlvbldpdGhBY3Rpb25zKHBhY2tlZF90cmFuc2FjdGlvbik7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0eCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYWNrZWRNc2lnQWN0aW9ucyh0eC5hY3Rpb25zKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHR4LmFjdGlvbnMgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHR4KTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDEwO1xuICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgcGFyc2luZyBwYWNrZWQgbXNpZycpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ0LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1swLCAxMF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX3BhcnNlUGFja2VkTXNpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRGdWxsTXNpZ1Byb3Bvc2FsKF94NSwgX3g2KSB7XG4gIHJldHVybiBfZ2V0RnVsbE1zaWdQcm9wb3NhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RnVsbE1zaWdQcm9wb3NhbCgpIHtcbiAgX2dldEZ1bGxNc2lnUHJvcG9zYWwgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGFjY291bnRfbmFtZSwgcHJvcG9zYWxfbmFtZSkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUcsXG4gICAgICAgICAgICAgIHNjb3BlOiBlbmNvZGVOYW1lKGFjY291bnRfbmFtZSwgZmFsc2UpLFxuICAgICAgICAgICAgICB0YWJsZTogdGhpcy5jb25zdGFudHMuRU9TSU9fTVNJR19QUk9QT1NBTFNfVEFCTEUsXG4gICAgICAgICAgICAgIHRhYmxlX2tleTogJycsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnbmFtZScsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBwcm9wb3NhbF9uYW1lLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogMSxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ1LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghKHJlc3VsdCAmJiByZXN1bHQucm93cyAmJiByZXN1bHQucm93cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFja2VkTXNpZyhyZXN1bHQucm93c1swXS5wYWNrZWRfdHJhbnNhY3Rpb24pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ1LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMTA7XG4gICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0NS50MCk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMCwgMTBdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRGdWxsTXNpZ1Byb3Bvc2FsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldE1zaWdBcHByb3ZhbHMoX3g3LCBfeDgpIHtcbiAgcmV0dXJuIF9nZXRNc2lnQXBwcm92YWxzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRNc2lnQXBwcm92YWxzKCkge1xuICBfZ2V0TXNpZ0FwcHJvdmFscyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoYWNjb3VudCwgdGFibGUpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Miwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHLFxuICAgICAgICAgICAgICBzY29wZTogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLnJvd3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ2LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNiwgdGhpcywgW1swLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0TXNpZ0FwcHJvdmFscy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBY2NvdW50c01zaWdQcm9wb3NhbHMoX3g5KSB7XG4gIHJldHVybiBfZ2V0QWNjb3VudHNNc2lnUHJvcG9zYWxzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY2NvdW50c01zaWdQcm9wb3NhbHMoKSB7XG4gIF9nZXRBY2NvdW50c01zaWdQcm9wb3NhbHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KGFjY291bnQpIHtcbiAgICB2YXIgcHJvbWlzZXMsIF95aWVsZCRQcm9taXNlJGFsbCwgcm93czIsIHJvd3MxO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMDtcbiAgICAgICAgICAgIHByb21pc2VzID0gW3RoaXMuZ2V0TXNpZ0FwcHJvdmFscyhhY2NvdW50LCB0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHX0FQUFJPVkFMU19UQUJMRSldO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdGFudHMuRU9TSU9fTVNJR19BUFBST1ZBTFNfVEFCTEUgPT09ICdhcHByb3ZhbHMyJykge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZ2V0TXNpZ0FwcHJvdmFscyhhY2NvdW50LCAnYXBwcm92YWxzJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX3lpZWxkJFByb21pc2UkYWxsID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICByb3dzMiA9IF95aWVsZCRQcm9taXNlJGFsbFswXTtcbiAgICAgICAgICAgIHJvd3MxID0gX3lpZWxkJFByb21pc2UkYWxsWzFdO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93czIuY29uY2F0KHJvd3MxKSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxMTtcbiAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ3LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgdGhpcywgW1swLCAxMV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjY291bnRzTXNpZ1Byb3Bvc2Fscy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBoeXBlcmlvbkdldE1zaWcoX3gxMCkge1xuICByZXR1cm4gX2h5cGVyaW9uR2V0TXNpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaHlwZXJpb25HZXRNc2lnKCkge1xuICBfaHlwZXJpb25HZXRNc2lnID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOChtc2lnRmlsdGVycykge1xuICAgIHZhciByZXMsIGV4ZWN1dGlvblRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbiwgcHJvcG9zYWwsIF95aWVsZCRQcm9taXNlJGFsbDIsIGFjdGlvbnNSZXMsIGFjdGlvbnNSZXMyLCByZWxldmFudEFjdGlvbiwgdHg7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHRoaXMuaHlwZXJpb24pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uLmdldF9wcm9wb3NhbHMobXNpZ0ZpbHRlcnMpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ4LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghKHJlcyAmJiByZXMucHJvcG9zYWxzICYmIHJlcy5wcm9wb3NhbHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDIyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcG9zYWwgPSByZXMucHJvcG9zYWxzWzBdO1xuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLmh5cGVyaW9uLmdldF9hY3Rpb25zKHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUcsIHtcbiAgICAgICAgICAgICAgYmxvY2tfbnVtOiBwcm9wb3NhbC5ibG9ja19udW0sXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KSwgdGhpcy5oeXBlcmlvbi5nZXRfZGVsdGFzKHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUcsIG1zaWdGaWx0ZXJzLnByb3Bvc2VyLCAncHJvcG9zYWwnLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgYmxvY2tfbnVtOiBwcm9wb3NhbC5ibG9ja19udW1cbiAgICAgICAgICAgIH0pXSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfeWllbGQkUHJvbWlzZSRhbGwyID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICBhY3Rpb25zUmVzID0gX3lpZWxkJFByb21pc2UkYWxsMlswXTtcbiAgICAgICAgICAgIGFjdGlvbnNSZXMyID0gX3lpZWxkJFByb21pc2UkYWxsMlsxXTtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbnNSZXMgJiYgYWN0aW9uc1Jlcy5hY3Rpb25zICYmIGFjdGlvbnNSZXMuYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVsZXZhbnRBY3Rpb24gPSBhY3Rpb25zUmVzLmFjdGlvbnMuZmluZChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5hY3QuZGF0YS5wcm9wb3NhbF9uYW1lID09PSBtc2lnRmlsdGVycy5wcm9wb3NhbDtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHJlbGV2YW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICBwYXllcjogcmVsZXZhbnRBY3Rpb24uYWN0LmRhdGEuZXhlY3V0ZXIgfHwgcmVsZXZhbnRBY3Rpb24uYWN0LmRhdGEuY2FuY2VsZXIsXG4gICAgICAgICAgICAgICAgICB0cnhfaWQ6IHJlbGV2YW50QWN0aW9uLnRyeF9pZCxcbiAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlZF9hdDogcmVsZXZhbnRBY3Rpb24udGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkOiByZWxldmFudEFjdGlvbi5hY3QubmFtZSA9PT0gJ2NhbmNlbCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKGFjdGlvbnNSZXMyICYmIGFjdGlvbnNSZXMyLmRlbHRhcyAmJiBhY3Rpb25zUmVzMi5kZWx0YXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHggPSBhY3Rpb25zUmVzMi5kZWx0YXNbMF0uZGF0YS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBhY2tlZE1zaWdBY3Rpb25zKHR4LmFjdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHR4LmFjdGlvbnMgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHg7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBhcHByb3ZhbHM6IHByb3Bvc2FsLFxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgIGV4ZWN1dGlvblRyYW5zYWN0aW9uOiBleGVjdXRpb25UcmFuc2FjdGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9oeXBlcmlvbkdldE1zaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Vm90ZXIoX3gpIHtcbiAgcmV0dXJuIF9nZXRWb3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0Vm90ZXIoKSB7XG4gIF9nZXRWb3RlciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdGFibGU6ICd2b3RlcnMnLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5yb3dzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByb3dzLmxlbmd0aCA/IHJvd3NbMF0gOiB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRWb3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm94aWVzKCkge1xuICByZXR1cm4gX2dldFByb3hpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3hpZXMoKSB7XG4gIF9nZXRQcm94aWVzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF95aWVsZCR0aGlzJGdldCwgcHJveGllcywgX3lpZWxkJHRoaXMkaHlwZXJpb24kLCB2b3RlcnM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEodGhpcy5jb25zdGFudHMuQUxPSEFfUFJPWFlfVVJMICE9PSAnJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuY29uc3RhbnRzLkFMT0hBX1BST1hZX1VSTCArIFwiP291dHB1dD1qc29uXCIpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBwcm94aWVzID0gX3lpZWxkJHRoaXMkZ2V0LnByb3hpZXM7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBwcm94aWVzKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbi5nZXRfdm90ZXJzKHtcbiAgICAgICAgICAgICAgcHJveHk6IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDAwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRoeXBlcmlvbiQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHZvdGVycyA9IF95aWVsZCR0aGlzJGh5cGVyaW9uJC52b3RlcnM7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB2b3RlcnMubWFwKGZ1bmN0aW9uICh2b3RlciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCB2b3Rlciwge1xuICAgICAgICAgICAgICAgIHdlaWdodDogdm90ZXIud2VpZ2h0IC8gTWF0aC5wb3coMTAsIF90aGlzLmNvbnN0YW50cy5DT1JFX1BSRUNJU0lPTiksXG4gICAgICAgICAgICAgICAgcmFuazogaW5kZXggKyAxXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb3hpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Vm90ZXJzKF94Mikge1xuICByZXR1cm4gX2dldFZvdGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0Vm90ZXJzKCkge1xuICBfZ2V0Vm90ZXJzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhwcm9kdWNlcikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF95aWVsZCR0aGlzJGh5cGVyaW9uJDIsIHZvdGVycywgdm90ZVdlaWdodDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXRoaXMuaHlwZXJpb24pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb24uZ2V0X3ZvdGVycyh7XG4gICAgICAgICAgICAgIHByb2R1Y2VyOiBwcm9kdWNlcixcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRoeXBlcmlvbiQyID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICB2b3RlcnMgPSBfeWllbGQkdGhpcyRoeXBlcmlvbiQyLnZvdGVycztcbiAgICAgICAgICAgIHZvdGVXZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZVZvdGVXZWlnaHQoKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHZvdGVycy5tYXAoZnVuY3Rpb24gKHZvdGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdm90ZXIsIHtcbiAgICAgICAgICAgICAgICB2b3RlOiBfdGhpczIud2VpZ2h0ZWRWb3RlVG9OdW1iZXIodm90ZXIud2VpZ2h0LCB2b3RlV2VpZ2h0KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0Vm90ZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVZvdGVXZWlnaHQoKSB7XG4gIHZhciBkZWNheVdlZWtzID0gdGhpcy5jb25zdGFudHMuQ0hBSU4gPT09ICd3YXgnID8gMTMgOiA1MjtcbiAgdmFyIHRpbWVzdGFtcF9lcG9jaCA9IDk0NjY4NDgwMDAwMDtcbiAgdmFyIGRhdGVzID0gRGF0ZS5ub3coKSAvIDEwMDAgLSB0aW1lc3RhbXBfZXBvY2ggLyAxMDAwO1xuICB2YXIgd2VpZ2h0ID0gTWF0aC5mbG9vcihkYXRlcyAvICg4NjQwMCAqIDcpKSAvIGRlY2F5V2Vla3M7XG4gIHJldHVybiBNYXRoLnBvdygyLCB3ZWlnaHQpO1xufVxuZnVuY3Rpb24gd2VpZ2h0ZWRWb3RlVG9OdW1iZXIod2VpZ2h0ZWRWb3RlLCB2b3RlV2VpZ2h0KSB7XG4gIGlmICghdm90ZVdlaWdodCkge1xuICAgIHZvdGVXZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZVZvdGVXZWlnaHQoKTtcbiAgfVxuXG4gIHJldHVybiArd2VpZ2h0ZWRWb3RlIC8gdm90ZVdlaWdodCAvIE1hdGgucG93KDEwLCB0aGlzLmNvbnN0YW50cy5DT1JFX1BSRUNJU0lPTik7XG59XG5mdW5jdGlvbiBnZXRQcm94eURhdGEoX3gzKSB7XG4gIHJldHVybiBfZ2V0UHJveHlEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm94eURhdGEoKSB7XG4gIF9nZXRQcm94eURhdGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGFjY291bnROYW1lKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJGdldDIsIHByb3h5O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHRoaXMuY29uc3RhbnRzLkFMT0hBX1BST1hZX1VSTCAhPT0gJycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmNvbnN0YW50cy5BTE9IQV9QUk9YWV9VUkwgKyBcIi9cIiArIGFjY291bnROYW1lICsgXCI/b3V0cHV0PWpzb25cIik7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRnZXQyID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICBwcm94eSA9IF95aWVsZCR0aGlzJGdldDIucHJveHk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBwcm94eSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UHJveHlEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb2R1Y2Vyc0xvY2FsKCkge1xuICByZXR1cm4gX2dldFByb2R1Y2Vyc0xvY2FsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm9kdWNlcnNMb2NhbCgpIHtcbiAgX2dldFByb2R1Y2Vyc0xvY2FsID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICB2YXIgbW9yZSwgcm93cywgcmVzdWx0LCBsb3dlcl9ib3VuZDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgbW9yZSA9IHRydWU7XG4gICAgICAgICAgICByb3dzID0gW107XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbG93ZXJfYm91bmQgPSBudWxsO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdwcm9kdWNlcnMnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogbG93ZXJfYm91bmQsXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAxLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICBtb3JlID0gcmVzdWx0Lm1vcmU7XG4gICAgICAgICAgICByb3dzID0gcm93cy5jb25jYXQocmVzdWx0LnJvd3MpO1xuICAgICAgICAgICAgbG93ZXJfYm91bmQgPSBuZXcgQmlnTnVtYmVyKGVuY29kZU5hbWUocm93c1tyb3dzLmxlbmd0aCAtIDFdLm93bmVyLCBmYWxzZSkpLnBsdXMoMSkudG9TdHJpbmcoKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBpZiAobW9yZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb2R1Y2Vyc0xvY2FsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb2R1Y2VycyhfeDQsIF94NSwgX3g2KSB7XG4gIHJldHVybiBfZ2V0UHJvZHVjZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm9kdWNlcnMoKSB7XG4gIF9nZXRQcm9kdWNlcnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHBhZ2VOdW0sIHBlclBhZ2UsIGxvY2FsKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChwYWdlTnVtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcGFnZU51bSA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwZXJQYWdlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcGVyUGFnZSA9IDUwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9jYWwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBsb2NhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISh0aGlzLmNvbnN0YW50cy5BUElfVVJMICE9PSAnJyAmJiAhbG9jYWwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmxCdWlsZGVyKHRoaXMuY29uc3RhbnRzLkFQSV9VUkwsICdwcm9kdWNlcnMnLCB7XG4gICAgICAgICAgICAgIHBhZ2VOdW06IHBhZ2VOdW0sXG4gICAgICAgICAgICAgIHBlclBhZ2U6IHBlclBhZ2VcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ni5zZW50KTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuZ2V0UHJvZHVjZXJzTG9jYWwoKSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UHJvZHVjZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldENoYWluVGFibGUoKSB7XG4gIHJldHVybiBfZ2V0Q2hhaW5UYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q2hhaW5UYWJsZSgpIHtcbiAgX2dldENoYWluVGFibGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAnZ2xvYmFsJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90MiA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDIucm93cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0Q2hhaW5UYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgS3ljU3RhdHVzO1xuXG4oZnVuY3Rpb24gKEt5Y1N0YXR1cykge1xuICBLeWNTdGF0dXNbXCJGQUlMRURcIl0gPSBcIkZBSUxFRFwiO1xuICBLeWNTdGF0dXNbXCJVTlNVQk1JVFRFRFwiXSA9IFwiVU5TVUJNSVRURURcIjtcbiAgS3ljU3RhdHVzW1wiUEVORElOR1wiXSA9IFwiUEVORElOR1wiO1xuICBLeWNTdGF0dXNbXCJQQVNTRURcIl0gPSBcIlBBU1NFRFwiO1xufSkoS3ljU3RhdHVzIHx8IChLeWNTdGF0dXMgPSB7fSkpO1xuXG52YXIgY291bnRyeU9wdGlvbnMgPSBbe1xuICBrZXk6ICdBRicsXG4gIHZhbHVlOiAnQUYnLFxuICBmbGFnOiAnYWYnLFxuICB0ZXh0OiAnQWZnaGFuaXN0YW4nXG59LCB7XG4gIGtleTogJ0FYJyxcbiAgdmFsdWU6ICdBWCcsXG4gIGZsYWc6ICdheCcsXG4gIHRleHQ6ICdBbGFuZCBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdBTCcsXG4gIHZhbHVlOiAnQUwnLFxuICBmbGFnOiAnYWwnLFxuICB0ZXh0OiAnQWxiYW5pYSdcbn0sIHtcbiAga2V5OiAnRFonLFxuICB2YWx1ZTogJ0RaJyxcbiAgZmxhZzogJ2R6JyxcbiAgdGV4dDogJ0FsZ2VyaWEnXG59LCB7XG4gIGtleTogJ0FTJyxcbiAgdmFsdWU6ICdBUycsXG4gIGZsYWc6ICdhcycsXG4gIHRleHQ6ICdBbWVyaWNhbiBTYW1vYSdcbn0sIHtcbiAga2V5OiAnQUQnLFxuICB2YWx1ZTogJ0FEJyxcbiAgZmxhZzogJ2FkJyxcbiAgdGV4dDogJ0FuZG9ycmEnXG59LCB7XG4gIGtleTogJ0FPJyxcbiAgdmFsdWU6ICdBTycsXG4gIGZsYWc6ICdhbycsXG4gIHRleHQ6ICdBbmdvbGEnXG59LCB7XG4gIGtleTogJ0FJJyxcbiAgdmFsdWU6ICdBSScsXG4gIGZsYWc6ICdhaScsXG4gIHRleHQ6ICdBbmd1aWxsYSdcbn0sIHtcbiAga2V5OiAnQUcnLFxuICB2YWx1ZTogJ0FHJyxcbiAgZmxhZzogJ2FnJyxcbiAgdGV4dDogJ0FudGlndWEnXG59LCB7XG4gIGtleTogJ0FSJyxcbiAgdmFsdWU6ICdBUicsXG4gIGZsYWc6ICdhcicsXG4gIHRleHQ6ICdBcmdlbnRpbmEnXG59LCB7XG4gIGtleTogJ0FNJyxcbiAgdmFsdWU6ICdBTScsXG4gIGZsYWc6ICdhbScsXG4gIHRleHQ6ICdBcm1lbmlhJ1xufSwge1xuICBrZXk6ICdBVycsXG4gIHZhbHVlOiAnQVcnLFxuICBmbGFnOiAnYXcnLFxuICB0ZXh0OiAnQXJ1YmEnXG59LCB7XG4gIGtleTogJ0FVJyxcbiAgdmFsdWU6ICdBVScsXG4gIGZsYWc6ICdhdScsXG4gIHRleHQ6ICdBdXN0cmFsaWEnXG59LCB7XG4gIGtleTogJ0FUJyxcbiAgdmFsdWU6ICdBVCcsXG4gIGZsYWc6ICdhdCcsXG4gIHRleHQ6ICdBdXN0cmlhJ1xufSwge1xuICBrZXk6ICdBWicsXG4gIHZhbHVlOiAnQVonLFxuICBmbGFnOiAnYXonLFxuICB0ZXh0OiAnQXplcmJhaWphbidcbn0sIHtcbiAga2V5OiAnQlMnLFxuICB2YWx1ZTogJ0JTJyxcbiAgZmxhZzogJ2JzJyxcbiAgdGV4dDogJ0JhaGFtYXMnXG59LCB7XG4gIGtleTogJ0JIJyxcbiAgdmFsdWU6ICdCSCcsXG4gIGZsYWc6ICdiaCcsXG4gIHRleHQ6ICdCYWhyYWluJ1xufSwge1xuICBrZXk6ICdCRCcsXG4gIHZhbHVlOiAnQkQnLFxuICBmbGFnOiAnYmQnLFxuICB0ZXh0OiAnQmFuZ2xhZGVzaCdcbn0sIHtcbiAga2V5OiAnQkInLFxuICB2YWx1ZTogJ0JCJyxcbiAgZmxhZzogJ2JiJyxcbiAgdGV4dDogJ0JhcmJhZG9zJ1xufSwge1xuICBrZXk6ICdCWScsXG4gIHZhbHVlOiAnQlknLFxuICBmbGFnOiAnYnknLFxuICB0ZXh0OiAnQmVsYXJ1cydcbn0sIHtcbiAga2V5OiAnQkUnLFxuICB2YWx1ZTogJ0JFJyxcbiAgZmxhZzogJ2JlJyxcbiAgdGV4dDogJ0JlbGdpdW0nXG59LCB7XG4gIGtleTogJ0JaJyxcbiAgdmFsdWU6ICdCWicsXG4gIGZsYWc6ICdieicsXG4gIHRleHQ6ICdCZWxpemUnXG59LCB7XG4gIGtleTogJ0JKJyxcbiAgdmFsdWU6ICdCSicsXG4gIGZsYWc6ICdiaicsXG4gIHRleHQ6ICdCZW5pbidcbn0sIHtcbiAga2V5OiAnQk0nLFxuICB2YWx1ZTogJ0JNJyxcbiAgZmxhZzogJ2JtJyxcbiAgdGV4dDogJ0Jlcm11ZGEnXG59LCB7XG4gIGtleTogJ0JUJyxcbiAgdmFsdWU6ICdCVCcsXG4gIGZsYWc6ICdidCcsXG4gIHRleHQ6ICdCaHV0YW4nXG59LCB7XG4gIGtleTogJ0JPJyxcbiAgdmFsdWU6ICdCTycsXG4gIGZsYWc6ICdibycsXG4gIHRleHQ6ICdCb2xpdmlhJ1xufSwge1xuICBrZXk6ICdCQScsXG4gIHZhbHVlOiAnQkEnLFxuICBmbGFnOiAnYmEnLFxuICB0ZXh0OiAnQm9zbmlhJ1xufSwge1xuICBrZXk6ICdCVycsXG4gIHZhbHVlOiAnQlcnLFxuICBmbGFnOiAnYncnLFxuICB0ZXh0OiAnQm90c3dhbmEnXG59LCB7XG4gIGtleTogJ0JWJyxcbiAgdmFsdWU6ICdCVicsXG4gIGZsYWc6ICdidicsXG4gIHRleHQ6ICdCb3V2ZXQgSXNsYW5kJ1xufSwge1xuICBrZXk6ICdCUicsXG4gIHZhbHVlOiAnQlInLFxuICBmbGFnOiAnYnInLFxuICB0ZXh0OiAnQnJhemlsJ1xufSwge1xuICBrZXk6ICdWRycsXG4gIHZhbHVlOiAnVkcnLFxuICBmbGFnOiAndmcnLFxuICB0ZXh0OiAnQnJpdGlzaCBWaXJnaW4gSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnQk4nLFxuICB2YWx1ZTogJ0JOJyxcbiAgZmxhZzogJ2JuJyxcbiAgdGV4dDogJ0JydW5laSdcbn0sIHtcbiAga2V5OiAnQkcnLFxuICB2YWx1ZTogJ0JHJyxcbiAgZmxhZzogJ2JnJyxcbiAgdGV4dDogJ0J1bGdhcmlhJ1xufSwge1xuICBrZXk6ICdCRicsXG4gIHZhbHVlOiAnQkYnLFxuICBmbGFnOiAnYmYnLFxuICB0ZXh0OiAnQnVya2luYSBGYXNvJ1xufSwge1xuICBrZXk6ICdCSScsXG4gIHZhbHVlOiAnQkknLFxuICBmbGFnOiAnYmknLFxuICB0ZXh0OiAnQnVydW5kaSdcbn0sIHtcbiAga2V5OiAnVEMnLFxuICB2YWx1ZTogJ1RDJyxcbiAgZmxhZzogJ3RjJyxcbiAgdGV4dDogJ0NhaWNvcyBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdLSCcsXG4gIHZhbHVlOiAnS0gnLFxuICBmbGFnOiAna2gnLFxuICB0ZXh0OiAnQ2FtYm9kaWEnXG59LCB7XG4gIGtleTogJ0NNJyxcbiAgdmFsdWU6ICdDTScsXG4gIGZsYWc6ICdjbScsXG4gIHRleHQ6ICdDYW1lcm9vbidcbn0sIHtcbiAga2V5OiAnQ0EnLFxuICB2YWx1ZTogJ0NBJyxcbiAgZmxhZzogJ2NhJyxcbiAgdGV4dDogJ0NhbmFkYSdcbn0sIHtcbiAga2V5OiAnQ1YnLFxuICB2YWx1ZTogJ0NWJyxcbiAgZmxhZzogJ2N2JyxcbiAgdGV4dDogJ0NhcGUgVmVyZGUnXG59LCB7XG4gIGtleTogJ0tZJyxcbiAgdmFsdWU6ICdLWScsXG4gIGZsYWc6ICdreScsXG4gIHRleHQ6ICdDYXltYW4gSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnQ0YnLFxuICB2YWx1ZTogJ0NGJyxcbiAgZmxhZzogJ2NmJyxcbiAgdGV4dDogJ0NlbnRyYWwgQWZyaWNhbiBSZXB1YmxpYydcbn0sIHtcbiAga2V5OiAnVEQnLFxuICB2YWx1ZTogJ1REJyxcbiAgZmxhZzogJ3RkJyxcbiAgdGV4dDogJ0NoYWQnXG59LCB7XG4gIGtleTogJ0NMJyxcbiAgdmFsdWU6ICdDTCcsXG4gIGZsYWc6ICdjbCcsXG4gIHRleHQ6ICdDaGlsZSdcbn0sIHtcbiAga2V5OiAnQ04nLFxuICB2YWx1ZTogJ0NOJyxcbiAgZmxhZzogJ2NuJyxcbiAgdGV4dDogJ0NoaW5hJ1xufSwge1xuICBrZXk6ICdDWCcsXG4gIHZhbHVlOiAnQ1gnLFxuICBmbGFnOiAnY3gnLFxuICB0ZXh0OiAnQ2hyaXN0bWFzIElzbGFuZCdcbn0sIHtcbiAga2V5OiAnQ0MnLFxuICB2YWx1ZTogJ0NDJyxcbiAgZmxhZzogJ2NjJyxcbiAgdGV4dDogJ0NvY29zIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ0NPJyxcbiAgdmFsdWU6ICdDTycsXG4gIGZsYWc6ICdjbycsXG4gIHRleHQ6ICdDb2xvbWJpYSdcbn0sIHtcbiAga2V5OiAnS00nLFxuICB2YWx1ZTogJ0tNJyxcbiAgZmxhZzogJ2ttJyxcbiAgdGV4dDogJ0NvbW9yb3MnXG59LCB7XG4gIGtleTogJ0NHJyxcbiAgdmFsdWU6ICdDRycsXG4gIGZsYWc6ICdjZycsXG4gIHRleHQ6ICdDb25nbyBCcmF6emF2aWxsZSdcbn0sIHtcbiAga2V5OiAnQ0QnLFxuICB2YWx1ZTogJ0NEJyxcbiAgZmxhZzogJ2NkJyxcbiAgdGV4dDogJ0NvbmdvJ1xufSwge1xuICBrZXk6ICdDSycsXG4gIHZhbHVlOiAnQ0snLFxuICBmbGFnOiAnY2snLFxuICB0ZXh0OiAnQ29vayBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdDUicsXG4gIHZhbHVlOiAnQ1InLFxuICBmbGFnOiAnY3InLFxuICB0ZXh0OiAnQ29zdGEgUmljYSdcbn0sIHtcbiAga2V5OiAnQ0knLFxuICB2YWx1ZTogJ0NJJyxcbiAgZmxhZzogJ2NpJyxcbiAgdGV4dDogJ0NvdGUgRGl2b2lyZSdcbn0sIHtcbiAga2V5OiAnSFInLFxuICB2YWx1ZTogJ0hSJyxcbiAgZmxhZzogJ2hyJyxcbiAgdGV4dDogJ0Nyb2F0aWEnXG59LCB7XG4gIGtleTogJ0NVJyxcbiAgdmFsdWU6ICdDVScsXG4gIGZsYWc6ICdjdScsXG4gIHRleHQ6ICdDdWJhJ1xufSwge1xuICBrZXk6ICdDWScsXG4gIHZhbHVlOiAnQ1knLFxuICBmbGFnOiAnY3knLFxuICB0ZXh0OiAnQ3lwcnVzJ1xufSwge1xuICBrZXk6ICdDWicsXG4gIHZhbHVlOiAnQ1onLFxuICBmbGFnOiAnY3onLFxuICB0ZXh0OiAnQ3plY2ggUmVwdWJsaWMnXG59LCB7XG4gIGtleTogJ0RLJyxcbiAgdmFsdWU6ICdESycsXG4gIGZsYWc6ICdkaycsXG4gIHRleHQ6ICdEZW5tYXJrJ1xufSwge1xuICBrZXk6ICdESicsXG4gIHZhbHVlOiAnREonLFxuICBmbGFnOiAnZGonLFxuICB0ZXh0OiAnRGppYm91dGknXG59LCB7XG4gIGtleTogJ0RNJyxcbiAgdmFsdWU6ICdETScsXG4gIGZsYWc6ICdkbScsXG4gIHRleHQ6ICdEb21pbmljYSdcbn0sIHtcbiAga2V5OiAnRE8nLFxuICB2YWx1ZTogJ0RPJyxcbiAgZmxhZzogJ2RvJyxcbiAgdGV4dDogJ0RvbWluaWNhbiBSZXB1YmxpYydcbn0sIHtcbiAga2V5OiAnRUMnLFxuICB2YWx1ZTogJ0VDJyxcbiAgZmxhZzogJ2VjJyxcbiAgdGV4dDogJ0VjdWFkb3InXG59LCB7XG4gIGtleTogJ0VHJyxcbiAgdmFsdWU6ICdFRycsXG4gIGZsYWc6ICdlZycsXG4gIHRleHQ6ICdFZ3lwdCdcbn0sIHtcbiAga2V5OiAnU1YnLFxuICB2YWx1ZTogJ1NWJyxcbiAgZmxhZzogJ3N2JyxcbiAgdGV4dDogJ0VsIFNhbHZhZG9yJ1xufSwge1xuICBrZXk6ICdHQicsXG4gIHZhbHVlOiAnR0InLFxuICBmbGFnOiAnZ2InLFxuICB0ZXh0OiAnRW5nbGFuZCdcbn0sIHtcbiAga2V5OiAnR1EnLFxuICB2YWx1ZTogJ0dRJyxcbiAgZmxhZzogJ2dxJyxcbiAgdGV4dDogJ0VxdWF0b3JpYWwgR3VpbmVhJ1xufSwge1xuICBrZXk6ICdFUicsXG4gIHZhbHVlOiAnRVInLFxuICBmbGFnOiAnZXInLFxuICB0ZXh0OiAnRXJpdHJlYSdcbn0sIHtcbiAga2V5OiAnRUUnLFxuICB2YWx1ZTogJ0VFJyxcbiAgZmxhZzogJ2VlJyxcbiAgdGV4dDogJ0VzdG9uaWEnXG59LCB7XG4gIGtleTogJ0VUJyxcbiAgdmFsdWU6ICdFVCcsXG4gIGZsYWc6ICdldCcsXG4gIHRleHQ6ICdFdGhpb3BpYSdcbn0sIHtcbiAga2V5OiAnRVUnLFxuICB2YWx1ZTogJ0VVJyxcbiAgZmxhZzogJ2V1JyxcbiAgdGV4dDogJ0V1cm9wZWFuIFVuaW9uJ1xufSwge1xuICBrZXk6ICdGSycsXG4gIHZhbHVlOiAnRksnLFxuICBmbGFnOiAnZmsnLFxuICB0ZXh0OiAnRmFsa2xhbmQgSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnRk8nLFxuICB2YWx1ZTogJ0ZPJyxcbiAgZmxhZzogJ2ZvJyxcbiAgdGV4dDogJ0Zhcm9lIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ0ZKJyxcbiAgdmFsdWU6ICdGSicsXG4gIGZsYWc6ICdmaicsXG4gIHRleHQ6ICdGaWppJ1xufSwge1xuICBrZXk6ICdGSScsXG4gIHZhbHVlOiAnRkknLFxuICBmbGFnOiAnZmknLFxuICB0ZXh0OiAnRmlubGFuZCdcbn0sIHtcbiAga2V5OiAnRlInLFxuICB2YWx1ZTogJ0ZSJyxcbiAgZmxhZzogJ2ZyJyxcbiAgdGV4dDogJ0ZyYW5jZSdcbn0sIHtcbiAga2V5OiAnR0YnLFxuICB2YWx1ZTogJ0dGJyxcbiAgZmxhZzogJ2dmJyxcbiAgdGV4dDogJ0ZyZW5jaCBHdWlhbmEnXG59LCB7XG4gIGtleTogJ1BGJyxcbiAgdmFsdWU6ICdQRicsXG4gIGZsYWc6ICdwZicsXG4gIHRleHQ6ICdGcmVuY2ggUG9seW5lc2lhJ1xufSwge1xuICBrZXk6ICdURicsXG4gIHZhbHVlOiAnVEYnLFxuICBmbGFnOiAndGYnLFxuICB0ZXh0OiAnRnJlbmNoIFRlcnJpdG9yaWVzJ1xufSwge1xuICBrZXk6ICdHQScsXG4gIHZhbHVlOiAnR0EnLFxuICBmbGFnOiAnZ2EnLFxuICB0ZXh0OiAnR2Fib24nXG59LCB7XG4gIGtleTogJ0dNJyxcbiAgdmFsdWU6ICdHTScsXG4gIGZsYWc6ICdnbScsXG4gIHRleHQ6ICdHYW1iaWEnXG59LCB7XG4gIGtleTogJ0dFJyxcbiAgdmFsdWU6ICdHRScsXG4gIGZsYWc6ICdnZScsXG4gIHRleHQ6ICdHZW9yZ2lhJ1xufSwge1xuICBrZXk6ICdERScsXG4gIHZhbHVlOiAnREUnLFxuICBmbGFnOiAnZGUnLFxuICB0ZXh0OiAnR2VybWFueSdcbn0sIHtcbiAga2V5OiAnR0gnLFxuICB2YWx1ZTogJ0dIJyxcbiAgZmxhZzogJ2doJyxcbiAgdGV4dDogJ0doYW5hJ1xufSwge1xuICBrZXk6ICdHSScsXG4gIHZhbHVlOiAnR0knLFxuICBmbGFnOiAnZ2knLFxuICB0ZXh0OiAnR2licmFsdGFyJ1xufSwge1xuICBrZXk6ICdHUicsXG4gIHZhbHVlOiAnR1InLFxuICBmbGFnOiAnZ3InLFxuICB0ZXh0OiAnR3JlZWNlJ1xufSwge1xuICBrZXk6ICdHTCcsXG4gIHZhbHVlOiAnR0wnLFxuICBmbGFnOiAnZ2wnLFxuICB0ZXh0OiAnR3JlZW5sYW5kJ1xufSwge1xuICBrZXk6ICdHRCcsXG4gIHZhbHVlOiAnR0QnLFxuICBmbGFnOiAnZ2QnLFxuICB0ZXh0OiAnR3JlbmFkYSdcbn0sIHtcbiAga2V5OiAnR1AnLFxuICB2YWx1ZTogJ0dQJyxcbiAgZmxhZzogJ2dwJyxcbiAgdGV4dDogJ0d1YWRlbG91cGUnXG59LCB7XG4gIGtleTogJ0dVJyxcbiAgdmFsdWU6ICdHVScsXG4gIGZsYWc6ICdndScsXG4gIHRleHQ6ICdHdWFtJ1xufSwge1xuICBrZXk6ICdHVCcsXG4gIHZhbHVlOiAnR1QnLFxuICBmbGFnOiAnZ3QnLFxuICB0ZXh0OiAnR3VhdGVtYWxhJ1xufSwge1xuICBrZXk6ICdHVycsXG4gIHZhbHVlOiAnR1cnLFxuICBmbGFnOiAnZ3cnLFxuICB0ZXh0OiAnR3VpbmVhLUJpc3NhdSdcbn0sIHtcbiAga2V5OiAnR04nLFxuICB2YWx1ZTogJ0dOJyxcbiAgZmxhZzogJ2duJyxcbiAgdGV4dDogJ0d1aW5lYSdcbn0sIHtcbiAga2V5OiAnR1knLFxuICB2YWx1ZTogJ0dZJyxcbiAgZmxhZzogJ2d5JyxcbiAgdGV4dDogJ0d1eWFuYSdcbn0sIHtcbiAga2V5OiAnSFQnLFxuICB2YWx1ZTogJ0hUJyxcbiAgZmxhZzogJ2h0JyxcbiAgdGV4dDogJ0hhaXRpJ1xufSwge1xuICBrZXk6ICdITScsXG4gIHZhbHVlOiAnSE0nLFxuICBmbGFnOiAnaG0nLFxuICB0ZXh0OiAnSGVhcmQgSXNsYW5kJ1xufSwge1xuICBrZXk6ICdITicsXG4gIHZhbHVlOiAnSE4nLFxuICBmbGFnOiAnaG4nLFxuICB0ZXh0OiAnSG9uZHVyYXMnXG59LCB7XG4gIGtleTogJ0hLJyxcbiAgdmFsdWU6ICdISycsXG4gIGZsYWc6ICdoaycsXG4gIHRleHQ6ICdIb25nIEtvbmcnXG59LCB7XG4gIGtleTogJ0hVJyxcbiAgdmFsdWU6ICdIVScsXG4gIGZsYWc6ICdodScsXG4gIHRleHQ6ICdIdW5nYXJ5J1xufSwge1xuICBrZXk6ICdJUycsXG4gIHZhbHVlOiAnSVMnLFxuICBmbGFnOiAnaXMnLFxuICB0ZXh0OiAnSWNlbGFuZCdcbn0sIHtcbiAga2V5OiAnSU4nLFxuICB2YWx1ZTogJ0lOJyxcbiAgZmxhZzogJ2luJyxcbiAgdGV4dDogJ0luZGlhJ1xufSwge1xuICBrZXk6ICdJTycsXG4gIHZhbHVlOiAnSU8nLFxuICBmbGFnOiAnaW8nLFxuICB0ZXh0OiAnSW5kaWFuIE9jZWFuIFRlcnJpdG9yeSdcbn0sIHtcbiAga2V5OiAnSUQnLFxuICB2YWx1ZTogJ0lEJyxcbiAgZmxhZzogJ2lkJyxcbiAgdGV4dDogJ0luZG9uZXNpYSdcbn0sIHtcbiAga2V5OiAnSVInLFxuICB2YWx1ZTogJ0lSJyxcbiAgZmxhZzogJ2lyJyxcbiAgdGV4dDogJ0lyYW4nXG59LCB7XG4gIGtleTogJ0lRJyxcbiAgdmFsdWU6ICdJUScsXG4gIGZsYWc6ICdpcScsXG4gIHRleHQ6ICdJcmFxJ1xufSwge1xuICBrZXk6ICdJRScsXG4gIHZhbHVlOiAnSUUnLFxuICBmbGFnOiAnaWUnLFxuICB0ZXh0OiAnSXJlbGFuZCdcbn0sIHtcbiAga2V5OiAnSUwnLFxuICB2YWx1ZTogJ0lMJyxcbiAgZmxhZzogJ2lsJyxcbiAgdGV4dDogJ0lzcmFlbCdcbn0sIHtcbiAga2V5OiAnSVQnLFxuICB2YWx1ZTogJ0lUJyxcbiAgZmxhZzogJ2l0JyxcbiAgdGV4dDogJ0l0YWx5J1xufSwge1xuICBrZXk6ICdKTScsXG4gIHZhbHVlOiAnSk0nLFxuICBmbGFnOiAnam0nLFxuICB0ZXh0OiAnSmFtYWljYSdcbn0sIHtcbiAga2V5OiAnSlAnLFxuICB2YWx1ZTogJ0pQJyxcbiAgZmxhZzogJ2pwJyxcbiAgdGV4dDogJ0phcGFuJ1xufSwge1xuICBrZXk6ICdKTycsXG4gIHZhbHVlOiAnSk8nLFxuICBmbGFnOiAnam8nLFxuICB0ZXh0OiAnSm9yZGFuJ1xufSwge1xuICBrZXk6ICdLWicsXG4gIHZhbHVlOiAnS1onLFxuICBmbGFnOiAna3onLFxuICB0ZXh0OiAnS2F6YWtoc3Rhbidcbn0sIHtcbiAga2V5OiAnS0UnLFxuICB2YWx1ZTogJ0tFJyxcbiAgZmxhZzogJ2tlJyxcbiAgdGV4dDogJ0tlbnlhJ1xufSwge1xuICBrZXk6ICdLSScsXG4gIHZhbHVlOiAnS0knLFxuICBmbGFnOiAna2knLFxuICB0ZXh0OiAnS2lyaWJhdGknXG59LCB7XG4gIGtleTogJ0tXJyxcbiAgdmFsdWU6ICdLVycsXG4gIGZsYWc6ICdrdycsXG4gIHRleHQ6ICdLdXdhaXQnXG59LCB7XG4gIGtleTogJ0tHJyxcbiAgdmFsdWU6ICdLRycsXG4gIGZsYWc6ICdrZycsXG4gIHRleHQ6ICdLeXJneXpzdGFuJ1xufSwge1xuICBrZXk6ICdMQScsXG4gIHZhbHVlOiAnTEEnLFxuICBmbGFnOiAnbGEnLFxuICB0ZXh0OiAnTGFvcydcbn0sIHtcbiAga2V5OiAnTFYnLFxuICB2YWx1ZTogJ0xWJyxcbiAgZmxhZzogJ2x2JyxcbiAgdGV4dDogJ0xhdHZpYSdcbn0sIHtcbiAga2V5OiAnTEInLFxuICB2YWx1ZTogJ0xCJyxcbiAgZmxhZzogJ2xiJyxcbiAgdGV4dDogJ0xlYmFub24nXG59LCB7XG4gIGtleTogJ0xTJyxcbiAgdmFsdWU6ICdMUycsXG4gIGZsYWc6ICdscycsXG4gIHRleHQ6ICdMZXNvdGhvJ1xufSwge1xuICBrZXk6ICdMUicsXG4gIHZhbHVlOiAnTFInLFxuICBmbGFnOiAnbHInLFxuICB0ZXh0OiAnTGliZXJpYSdcbn0sIHtcbiAga2V5OiAnTFknLFxuICB2YWx1ZTogJ0xZJyxcbiAgZmxhZzogJ2x5JyxcbiAgdGV4dDogJ0xpYnlhJ1xufSwge1xuICBrZXk6ICdMSScsXG4gIHZhbHVlOiAnTEknLFxuICBmbGFnOiAnbGknLFxuICB0ZXh0OiAnTGllY2h0ZW5zdGVpbidcbn0sIHtcbiAga2V5OiAnTFQnLFxuICB2YWx1ZTogJ0xUJyxcbiAgZmxhZzogJ2x0JyxcbiAgdGV4dDogJ0xpdGh1YW5pYSdcbn0sIHtcbiAga2V5OiAnTFUnLFxuICB2YWx1ZTogJ0xVJyxcbiAgZmxhZzogJ2x1JyxcbiAgdGV4dDogJ0x1eGVtYm91cmcnXG59LCB7XG4gIGtleTogJ01PJyxcbiAgdmFsdWU6ICdNTycsXG4gIGZsYWc6ICdtbycsXG4gIHRleHQ6ICdNYWNhdSdcbn0sIHtcbiAga2V5OiAnTUsnLFxuICB2YWx1ZTogJ01LJyxcbiAgZmxhZzogJ21rJyxcbiAgdGV4dDogJ01hY2Vkb25pYSdcbn0sIHtcbiAga2V5OiAnTUcnLFxuICB2YWx1ZTogJ01HJyxcbiAgZmxhZzogJ21nJyxcbiAgdGV4dDogJ01hZGFnYXNjYXInXG59LCB7XG4gIGtleTogJ01XJyxcbiAgdmFsdWU6ICdNVycsXG4gIGZsYWc6ICdtdycsXG4gIHRleHQ6ICdNYWxhd2knXG59LCB7XG4gIGtleTogJ01ZJyxcbiAgdmFsdWU6ICdNWScsXG4gIGZsYWc6ICdteScsXG4gIHRleHQ6ICdNYWxheXNpYSdcbn0sIHtcbiAga2V5OiAnTVYnLFxuICB2YWx1ZTogJ01WJyxcbiAgZmxhZzogJ212JyxcbiAgdGV4dDogJ01hbGRpdmVzJ1xufSwge1xuICBrZXk6ICdNTCcsXG4gIHZhbHVlOiAnTUwnLFxuICBmbGFnOiAnbWwnLFxuICB0ZXh0OiAnTWFsaSdcbn0sIHtcbiAga2V5OiAnTVQnLFxuICB2YWx1ZTogJ01UJyxcbiAgZmxhZzogJ210JyxcbiAgdGV4dDogJ01hbHRhJ1xufSwge1xuICBrZXk6ICdNSCcsXG4gIHZhbHVlOiAnTUgnLFxuICBmbGFnOiAnbWgnLFxuICB0ZXh0OiAnTWFyc2hhbGwgSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnTVEnLFxuICB2YWx1ZTogJ01RJyxcbiAgZmxhZzogJ21xJyxcbiAgdGV4dDogJ01hcnRpbmlxdWUnXG59LCB7XG4gIGtleTogJ01SJyxcbiAgdmFsdWU6ICdNUicsXG4gIGZsYWc6ICdtcicsXG4gIHRleHQ6ICdNYXVyaXRhbmlhJ1xufSwge1xuICBrZXk6ICdNVScsXG4gIHZhbHVlOiAnTVUnLFxuICBmbGFnOiAnbXUnLFxuICB0ZXh0OiAnTWF1cml0aXVzJ1xufSwge1xuICBrZXk6ICdZVCcsXG4gIHZhbHVlOiAnWVQnLFxuICBmbGFnOiAneXQnLFxuICB0ZXh0OiAnTWF5b3R0ZSdcbn0sIHtcbiAga2V5OiAnTVgnLFxuICB2YWx1ZTogJ01YJyxcbiAgZmxhZzogJ214JyxcbiAgdGV4dDogJ01leGljbydcbn0sIHtcbiAga2V5OiAnRk0nLFxuICB2YWx1ZTogJ0ZNJyxcbiAgZmxhZzogJ2ZtJyxcbiAgdGV4dDogJ01pY3JvbmVzaWEnXG59LCB7XG4gIGtleTogJ01EJyxcbiAgdmFsdWU6ICdNRCcsXG4gIGZsYWc6ICdtZCcsXG4gIHRleHQ6ICdNb2xkb3ZhJ1xufSwge1xuICBrZXk6ICdNQycsXG4gIHZhbHVlOiAnTUMnLFxuICBmbGFnOiAnbWMnLFxuICB0ZXh0OiAnTW9uYWNvJ1xufSwge1xuICBrZXk6ICdNTicsXG4gIHZhbHVlOiAnTU4nLFxuICBmbGFnOiAnbW4nLFxuICB0ZXh0OiAnTW9uZ29saWEnXG59LCB7XG4gIGtleTogJ01FJyxcbiAgdmFsdWU6ICdNRScsXG4gIGZsYWc6ICdtZScsXG4gIHRleHQ6ICdNb250ZW5lZ3JvJ1xufSwge1xuICBrZXk6ICdNUycsXG4gIHZhbHVlOiAnTVMnLFxuICBmbGFnOiAnbXMnLFxuICB0ZXh0OiAnTW9udHNlcnJhdCdcbn0sIHtcbiAga2V5OiAnTUEnLFxuICB2YWx1ZTogJ01BJyxcbiAgZmxhZzogJ21hJyxcbiAgdGV4dDogJ01vcm9jY28nXG59LCB7XG4gIGtleTogJ01aJyxcbiAgdmFsdWU6ICdNWicsXG4gIGZsYWc6ICdteicsXG4gIHRleHQ6ICdNb3phbWJpcXVlJ1xufSwge1xuICBrZXk6ICdOQScsXG4gIHZhbHVlOiAnTkEnLFxuICBmbGFnOiAnbmEnLFxuICB0ZXh0OiAnTmFtaWJpYSdcbn0sIHtcbiAga2V5OiAnTlInLFxuICB2YWx1ZTogJ05SJyxcbiAgZmxhZzogJ25yJyxcbiAgdGV4dDogJ05hdXJ1J1xufSwge1xuICBrZXk6ICdOUCcsXG4gIHZhbHVlOiAnTlAnLFxuICBmbGFnOiAnbnAnLFxuICB0ZXh0OiAnTmVwYWwnXG59LCB7XG4gIGtleTogJ0FOJyxcbiAgdmFsdWU6ICdBTicsXG4gIGZsYWc6ICdhbicsXG4gIHRleHQ6ICdOZXRoZXJsYW5kcyBBbnRpbGxlcydcbn0sIHtcbiAga2V5OiAnTkwnLFxuICB2YWx1ZTogJ05MJyxcbiAgZmxhZzogJ25sJyxcbiAgdGV4dDogJ05ldGhlcmxhbmRzJ1xufSwge1xuICBrZXk6ICdOQycsXG4gIHZhbHVlOiAnTkMnLFxuICBmbGFnOiAnbmMnLFxuICB0ZXh0OiAnTmV3IENhbGVkb25pYSdcbn0sIHtcbiAga2V5OiAnUEcnLFxuICB2YWx1ZTogJ1BHJyxcbiAgZmxhZzogJ3BnJyxcbiAgdGV4dDogJ05ldyBHdWluZWEnXG59LCB7XG4gIGtleTogJ05aJyxcbiAgdmFsdWU6ICdOWicsXG4gIGZsYWc6ICdueicsXG4gIHRleHQ6ICdOZXcgWmVhbGFuZCdcbn0sIHtcbiAga2V5OiAnTkknLFxuICB2YWx1ZTogJ05JJyxcbiAgZmxhZzogJ25pJyxcbiAgdGV4dDogJ05pY2FyYWd1YSdcbn0sIHtcbiAga2V5OiAnTkUnLFxuICB2YWx1ZTogJ05FJyxcbiAgZmxhZzogJ25lJyxcbiAgdGV4dDogJ05pZ2VyJ1xufSwge1xuICBrZXk6ICdORycsXG4gIHZhbHVlOiAnTkcnLFxuICBmbGFnOiAnbmcnLFxuICB0ZXh0OiAnTmlnZXJpYSdcbn0sIHtcbiAga2V5OiAnTlUnLFxuICB2YWx1ZTogJ05VJyxcbiAgZmxhZzogJ251JyxcbiAgdGV4dDogJ05pdWUnXG59LCB7XG4gIGtleTogJ05GJyxcbiAgdmFsdWU6ICdORicsXG4gIGZsYWc6ICduZicsXG4gIHRleHQ6ICdOb3Jmb2xrIElzbGFuZCdcbn0sIHtcbiAga2V5OiAnS1AnLFxuICB2YWx1ZTogJ0tQJyxcbiAgZmxhZzogJ2twJyxcbiAgdGV4dDogJ05vcnRoIEtvcmVhJ1xufSwge1xuICBrZXk6ICdNUCcsXG4gIHZhbHVlOiAnTVAnLFxuICBmbGFnOiAnbXAnLFxuICB0ZXh0OiAnTm9ydGhlcm4gTWFyaWFuYSBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdOTycsXG4gIHZhbHVlOiAnTk8nLFxuICBmbGFnOiAnbm8nLFxuICB0ZXh0OiAnTm9yd2F5J1xufSwge1xuICBrZXk6ICdPTScsXG4gIHZhbHVlOiAnT00nLFxuICBmbGFnOiAnb20nLFxuICB0ZXh0OiAnT21hbidcbn0sIHtcbiAga2V5OiAnUEsnLFxuICB2YWx1ZTogJ1BLJyxcbiAgZmxhZzogJ3BrJyxcbiAgdGV4dDogJ1Bha2lzdGFuJ1xufSwge1xuICBrZXk6ICdQVycsXG4gIHZhbHVlOiAnUFcnLFxuICBmbGFnOiAncHcnLFxuICB0ZXh0OiAnUGFsYXUnXG59LCB7XG4gIGtleTogJ1BTJyxcbiAgdmFsdWU6ICdQUycsXG4gIGZsYWc6ICdwcycsXG4gIHRleHQ6ICdQYWxlc3RpbmUnXG59LCB7XG4gIGtleTogJ1BBJyxcbiAgdmFsdWU6ICdQQScsXG4gIGZsYWc6ICdwYScsXG4gIHRleHQ6ICdQYW5hbWEnXG59LCB7XG4gIGtleTogJ1BZJyxcbiAgdmFsdWU6ICdQWScsXG4gIGZsYWc6ICdweScsXG4gIHRleHQ6ICdQYXJhZ3VheSdcbn0sIHtcbiAga2V5OiAnUEUnLFxuICB2YWx1ZTogJ1BFJyxcbiAgZmxhZzogJ3BlJyxcbiAgdGV4dDogJ1BlcnUnXG59LCB7XG4gIGtleTogJ1BIJyxcbiAgdmFsdWU6ICdQSCcsXG4gIGZsYWc6ICdwaCcsXG4gIHRleHQ6ICdQaGlsaXBwaW5lcydcbn0sIHtcbiAga2V5OiAnUE4nLFxuICB2YWx1ZTogJ1BOJyxcbiAgZmxhZzogJ3BuJyxcbiAgdGV4dDogJ1BpdGNhaXJuIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ1BMJyxcbiAgdmFsdWU6ICdQTCcsXG4gIGZsYWc6ICdwbCcsXG4gIHRleHQ6ICdQb2xhbmQnXG59LCB7XG4gIGtleTogJ1BUJyxcbiAgdmFsdWU6ICdQVCcsXG4gIGZsYWc6ICdwdCcsXG4gIHRleHQ6ICdQb3J0dWdhbCdcbn0sIHtcbiAga2V5OiAnUFInLFxuICB2YWx1ZTogJ1BSJyxcbiAgZmxhZzogJ3ByJyxcbiAgdGV4dDogJ1B1ZXJ0byBSaWNvJ1xufSwge1xuICBrZXk6ICdRQScsXG4gIHZhbHVlOiAnUUEnLFxuICBmbGFnOiAncWEnLFxuICB0ZXh0OiAnUWF0YXInXG59LCB7XG4gIGtleTogJ1JFJyxcbiAgdmFsdWU6ICdSRScsXG4gIGZsYWc6ICdyZScsXG4gIHRleHQ6ICdSZXVuaW9uJ1xufSwge1xuICBrZXk6ICdSTycsXG4gIHZhbHVlOiAnUk8nLFxuICBmbGFnOiAncm8nLFxuICB0ZXh0OiAnUm9tYW5pYSdcbn0sIHtcbiAga2V5OiAnUlUnLFxuICB2YWx1ZTogJ1JVJyxcbiAgZmxhZzogJ3J1JyxcbiAgdGV4dDogJ1J1c3NpYSdcbn0sIHtcbiAga2V5OiAnUlcnLFxuICB2YWx1ZTogJ1JXJyxcbiAgZmxhZzogJ3J3JyxcbiAgdGV4dDogJ1J3YW5kYSdcbn0sIHtcbiAga2V5OiAnU0gnLFxuICB2YWx1ZTogJ1NIJyxcbiAgZmxhZzogJ3NoJyxcbiAgdGV4dDogJ1NhaW50IEhlbGVuYSdcbn0sIHtcbiAga2V5OiAnS04nLFxuICB2YWx1ZTogJ0tOJyxcbiAgZmxhZzogJ2tuJyxcbiAgdGV4dDogJ1NhaW50IEtpdHRzIGFuZCBOZXZpcydcbn0sIHtcbiAga2V5OiAnTEMnLFxuICB2YWx1ZTogJ0xDJyxcbiAgZmxhZzogJ2xjJyxcbiAgdGV4dDogJ1NhaW50IEx1Y2lhJ1xufSwge1xuICBrZXk6ICdQTScsXG4gIHZhbHVlOiAnUE0nLFxuICBmbGFnOiAncG0nLFxuICB0ZXh0OiAnU2FpbnQgUGllcnJlJ1xufSwge1xuICBrZXk6ICdWQycsXG4gIHZhbHVlOiAnVkMnLFxuICBmbGFnOiAndmMnLFxuICB0ZXh0OiAnU2FpbnQgVmluY2VudCdcbn0sIHtcbiAga2V5OiAnV1MnLFxuICB2YWx1ZTogJ1dTJyxcbiAgZmxhZzogJ3dzJyxcbiAgdGV4dDogJ1NhbW9hJ1xufSwge1xuICBrZXk6ICdTTScsXG4gIHZhbHVlOiAnU00nLFxuICBmbGFnOiAnc20nLFxuICB0ZXh0OiAnU2FuIE1hcmlubydcbn0sIHtcbiAga2V5OiAnR1MnLFxuICB2YWx1ZTogJ0dTJyxcbiAgZmxhZzogJ2dzJyxcbiAgdGV4dDogJ1NhbmR3aWNoIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ1NUJyxcbiAgdmFsdWU6ICdTVCcsXG4gIGZsYWc6ICdzdCcsXG4gIHRleHQ6ICdTYW8gVG9tZSdcbn0sIHtcbiAga2V5OiAnU0EnLFxuICB2YWx1ZTogJ1NBJyxcbiAgZmxhZzogJ3NhJyxcbiAgdGV4dDogJ1NhdWRpIEFyYWJpYSdcbn0sIHtcbiAga2V5OiAnU04nLFxuICB2YWx1ZTogJ1NOJyxcbiAgZmxhZzogJ3NuJyxcbiAgdGV4dDogJ1NlbmVnYWwnXG59LCB7XG4gIGtleTogJ0NTJyxcbiAgdmFsdWU6ICdDUycsXG4gIGZsYWc6ICdjcycsXG4gIHRleHQ6ICdTZXJiaWEnXG59LCB7XG4gIGtleTogJ1JTJyxcbiAgdmFsdWU6ICdSUycsXG4gIGZsYWc6ICdycycsXG4gIHRleHQ6ICdTZXJiaWEnXG59LCB7XG4gIGtleTogJ1NDJyxcbiAgdmFsdWU6ICdTQycsXG4gIGZsYWc6ICdzYycsXG4gIHRleHQ6ICdTZXljaGVsbGVzJ1xufSwge1xuICBrZXk6ICdTTCcsXG4gIHZhbHVlOiAnU0wnLFxuICBmbGFnOiAnc2wnLFxuICB0ZXh0OiAnU2llcnJhIExlb25lJ1xufSwge1xuICBrZXk6ICdTRycsXG4gIHZhbHVlOiAnU0cnLFxuICBmbGFnOiAnc2cnLFxuICB0ZXh0OiAnU2luZ2Fwb3JlJ1xufSwge1xuICBrZXk6ICdTSycsXG4gIHZhbHVlOiAnU0snLFxuICBmbGFnOiAnc2snLFxuICB0ZXh0OiAnU2xvdmFraWEnXG59LCB7XG4gIGtleTogJ1NJJyxcbiAgdmFsdWU6ICdTSScsXG4gIGZsYWc6ICdzaScsXG4gIHRleHQ6ICdTbG92ZW5pYSdcbn0sIHtcbiAga2V5OiAnU0InLFxuICB2YWx1ZTogJ1NCJyxcbiAgZmxhZzogJ3NiJyxcbiAgdGV4dDogJ1NvbG9tb24gSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnU08nLFxuICB2YWx1ZTogJ1NPJyxcbiAgZmxhZzogJ3NvJyxcbiAgdGV4dDogJ1NvbWFsaWEnXG59LCB7XG4gIGtleTogJ1pBJyxcbiAgdmFsdWU6ICdaQScsXG4gIGZsYWc6ICd6YScsXG4gIHRleHQ6ICdTb3V0aCBBZnJpY2EnXG59LCB7XG4gIGtleTogJ0tSJyxcbiAgdmFsdWU6ICdLUicsXG4gIGZsYWc6ICdrcicsXG4gIHRleHQ6ICdTb3V0aCBLb3JlYSdcbn0sIHtcbiAga2V5OiAnRVMnLFxuICB2YWx1ZTogJ0VTJyxcbiAgZmxhZzogJ2VzJyxcbiAgdGV4dDogJ1NwYWluJ1xufSwge1xuICBrZXk6ICdMSycsXG4gIHZhbHVlOiAnTEsnLFxuICBmbGFnOiAnbGsnLFxuICB0ZXh0OiAnU3JpIExhbmthJ1xufSwge1xuICBrZXk6ICdTRCcsXG4gIHZhbHVlOiAnU0QnLFxuICBmbGFnOiAnc2QnLFxuICB0ZXh0OiAnU3VkYW4nXG59LCB7XG4gIGtleTogJ1NSJyxcbiAgdmFsdWU6ICdTUicsXG4gIGZsYWc6ICdzcicsXG4gIHRleHQ6ICdTdXJpbmFtZSdcbn0sIHtcbiAga2V5OiAnU0onLFxuICB2YWx1ZTogJ1NKJyxcbiAgZmxhZzogJ3NqJyxcbiAgdGV4dDogJ1N2YWxiYXJkJ1xufSwge1xuICBrZXk6ICdTWicsXG4gIHZhbHVlOiAnU1onLFxuICBmbGFnOiAnc3onLFxuICB0ZXh0OiAnU3dhemlsYW5kJ1xufSwge1xuICBrZXk6ICdTRScsXG4gIHZhbHVlOiAnU0UnLFxuICBmbGFnOiAnc2UnLFxuICB0ZXh0OiAnU3dlZGVuJ1xufSwge1xuICBrZXk6ICdDSCcsXG4gIHZhbHVlOiAnQ0gnLFxuICBmbGFnOiAnY2gnLFxuICB0ZXh0OiAnU3dpdHplcmxhbmQnXG59LCB7XG4gIGtleTogJ1NZJyxcbiAgdmFsdWU6ICdTWScsXG4gIGZsYWc6ICdzeScsXG4gIHRleHQ6ICdTeXJpYSdcbn0sIHtcbiAga2V5OiAnVFcnLFxuICB2YWx1ZTogJ1RXJyxcbiAgZmxhZzogJ3R3JyxcbiAgdGV4dDogJ1RhaXdhbidcbn0sIHtcbiAga2V5OiAnVEonLFxuICB2YWx1ZTogJ1RKJyxcbiAgZmxhZzogJ3RqJyxcbiAgdGV4dDogJ1RhamlraXN0YW4nXG59LCB7XG4gIGtleTogJ1RaJyxcbiAgdmFsdWU6ICdUWicsXG4gIGZsYWc6ICd0eicsXG4gIHRleHQ6ICdUYW56YW5pYSdcbn0sIHtcbiAga2V5OiAnVEgnLFxuICB2YWx1ZTogJ1RIJyxcbiAgZmxhZzogJ3RoJyxcbiAgdGV4dDogJ1RoYWlsYW5kJ1xufSwge1xuICBrZXk6ICdUTCcsXG4gIHZhbHVlOiAnVEwnLFxuICBmbGFnOiAndGwnLFxuICB0ZXh0OiAnVGltb3JsZXN0ZSdcbn0sIHtcbiAga2V5OiAnVEcnLFxuICB2YWx1ZTogJ1RHJyxcbiAgZmxhZzogJ3RnJyxcbiAgdGV4dDogJ1RvZ28nXG59LCB7XG4gIGtleTogJ1RLJyxcbiAgdmFsdWU6ICdUSycsXG4gIGZsYWc6ICd0aycsXG4gIHRleHQ6ICdUb2tlbGF1J1xufSwge1xuICBrZXk6ICdUTycsXG4gIHZhbHVlOiAnVE8nLFxuICBmbGFnOiAndG8nLFxuICB0ZXh0OiAnVG9uZ2EnXG59LCB7XG4gIGtleTogJ1RUJyxcbiAgdmFsdWU6ICdUVCcsXG4gIGZsYWc6ICd0dCcsXG4gIHRleHQ6ICdUcmluaWRhZCdcbn0sIHtcbiAga2V5OiAnVE4nLFxuICB2YWx1ZTogJ1ROJyxcbiAgZmxhZzogJ3RuJyxcbiAgdGV4dDogJ1R1bmlzaWEnXG59LCB7XG4gIGtleTogJ1RSJyxcbiAgdmFsdWU6ICdUUicsXG4gIGZsYWc6ICd0cicsXG4gIHRleHQ6ICdUdXJrZXknXG59LCB7XG4gIGtleTogJ1RNJyxcbiAgdmFsdWU6ICdUTScsXG4gIGZsYWc6ICd0bScsXG4gIHRleHQ6ICdUdXJrbWVuaXN0YW4nXG59LCB7XG4gIGtleTogJ1RWJyxcbiAgdmFsdWU6ICdUVicsXG4gIGZsYWc6ICd0dicsXG4gIHRleHQ6ICdUdXZhbHUnXG59LCB7XG4gIGtleTogJ1VHJyxcbiAgdmFsdWU6ICdVRycsXG4gIGZsYWc6ICd1ZycsXG4gIHRleHQ6ICdVZ2FuZGEnXG59LCB7XG4gIGtleTogJ1VBJyxcbiAgdmFsdWU6ICdVQScsXG4gIGZsYWc6ICd1YScsXG4gIHRleHQ6ICdVa3JhaW5lJ1xufSwge1xuICBrZXk6ICdBRScsXG4gIHZhbHVlOiAnQUUnLFxuICBmbGFnOiAnYWUnLFxuICB0ZXh0OiAnVW5pdGVkIEFyYWIgRW1pcmF0ZXMnXG59LCB7XG4gIGtleTogJ1VTJyxcbiAgdmFsdWU6ICdVUycsXG4gIGZsYWc6ICd1cycsXG4gIHRleHQ6ICdVbml0ZWQgU3RhdGVzJ1xufSwge1xuICBrZXk6ICdVWScsXG4gIHZhbHVlOiAnVVknLFxuICBmbGFnOiAndXknLFxuICB0ZXh0OiAnVXJ1Z3VheSdcbn0sIHtcbiAga2V5OiAnVU0nLFxuICB2YWx1ZTogJ1VNJyxcbiAgZmxhZzogJ3VtJyxcbiAgdGV4dDogJ1VzIE1pbm9yIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ1ZJJyxcbiAgdmFsdWU6ICdWSScsXG4gIGZsYWc6ICd2aScsXG4gIHRleHQ6ICdVcyBWaXJnaW4gSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnVVonLFxuICB2YWx1ZTogJ1VaJyxcbiAgZmxhZzogJ3V6JyxcbiAgdGV4dDogJ1V6YmVraXN0YW4nXG59LCB7XG4gIGtleTogJ1ZVJyxcbiAgdmFsdWU6ICdWVScsXG4gIGZsYWc6ICd2dScsXG4gIHRleHQ6ICdWYW51YXR1J1xufSwge1xuICBrZXk6ICdWQScsXG4gIHZhbHVlOiAnVkEnLFxuICBmbGFnOiAndmEnLFxuICB0ZXh0OiAnVmF0aWNhbiBDaXR5J1xufSwge1xuICBrZXk6ICdWRScsXG4gIHZhbHVlOiAnVkUnLFxuICBmbGFnOiAndmUnLFxuICB0ZXh0OiAnVmVuZXp1ZWxhJ1xufSwge1xuICBrZXk6ICdWTicsXG4gIHZhbHVlOiAnVk4nLFxuICBmbGFnOiAndm4nLFxuICB0ZXh0OiAnVmlldG5hbSdcbn0sIHtcbiAga2V5OiAnV0YnLFxuICB2YWx1ZTogJ1dGJyxcbiAgZmxhZzogJ3dmJyxcbiAgdGV4dDogJ1dhbGxpcyBhbmQgRnV0dW5hJ1xufSwge1xuICBrZXk6ICdFSCcsXG4gIHZhbHVlOiAnRUgnLFxuICBmbGFnOiAnZWgnLFxuICB0ZXh0OiAnV2VzdGVybiBTYWhhcmEnXG59LCB7XG4gIGtleTogJ1lFJyxcbiAgdmFsdWU6ICdZRScsXG4gIGZsYWc6ICd5ZScsXG4gIHRleHQ6ICdZZW1lbidcbn0sIHtcbiAga2V5OiAnWk0nLFxuICB2YWx1ZTogJ1pNJyxcbiAgZmxhZzogJ3ptJyxcbiAgdGV4dDogJ1phbWJpYSdcbn0sIHtcbiAga2V5OiAnWlcnLFxuICB2YWx1ZTogJ1pXJyxcbiAgZmxhZzogJ3p3JyxcbiAgdGV4dDogJ1ppbWJhYndlJ1xufV07XG5cbmZ1bmN0aW9uIGZldGNoS3ljQ291bnRyaWVzKF94KSB7XG4gIHJldHVybiBfZmV0Y2hLeWNDb3VudHJpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8qKlxyXG4gKiBGQUlMRURcclxuICogVU5TVUJNSVRURURcclxuICogUEVORElOR1xyXG4gKiBQQVNTRURcclxuICovXG5cbmZ1bmN0aW9uIF9mZXRjaEt5Y0NvdW50cmllcygpIHtcbiAgX2ZldGNoS3ljQ291bnRyaWVzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKF9yZWYpIHtcbiAgICB2YXIgY2hhaW4sIHVybCwgX3lpZWxkJHRoaXMkZ2V0LCBjb3VudHJpZXMsIGNvdW50cmllc0J5SWQ7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjaGFpbiA9IF9yZWYuY2hhaW47XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5CTE9LU19BUEkgKyBcIi9cIiArIGNoYWluICsgXCIva3ljP3R5cGU9Y291bnRyaWVzJmNoYWluPVwiICsgY2hhaW47XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGNvdW50cmllcyA9IF95aWVsZCR0aGlzJGdldC5jb250ZW50O1xuICAgICAgICAgICAgY291bnRyaWVzQnlJZCA9IGNvdW50cmllcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY291bnRyeSkge1xuICAgICAgICAgICAgICBhY2NbY291bnRyeS5pZF0gPSBjb3VudHJ5O1xuICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb3VudHJ5T3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGNvdW50cnlPcHRpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvdW50cmllc0J5SWRbY291bnRyeU9wdGlvbi5rZXldO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2ZldGNoS3ljQ291bnRyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVXNlckt5Y1N0YXR1cyhfeDIpIHtcbiAgcmV0dXJuIF9jaGVja1VzZXJLeWNTdGF0dXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NoZWNrVXNlckt5Y1N0YXR1cygpIHtcbiAgX2NoZWNrVXNlckt5Y1N0YXR1cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoX3JlZjIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNoYWluLCBhY3RvciwgZXhwZWN0ZWRUaWVyO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjaGFpbiA9IF9yZWYyLmNoYWluLCBhY3RvciA9IF9yZWYyLmFjdG9yLCBleHBlY3RlZFRpZXIgPSBfcmVmMi5leHBlY3RlZFRpZXI7XG5cbiAgICAgICAgICAgIGlmICghKCFjaGFpbiB8fCAhYWN0b3IgfHwgIWV4cGVjdGVkVGllcikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcnMnKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBnZXRTdGF0dXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgS1lDIHJlY29yZHMgZm9yIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF95aWVsZCRfdGhpcyRycGMkaXNMaSwgdXNlckluZm8sIHVybCwga3ljLCBtYXRjaGVkVGllciwgc3RhdHVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ycGMuaXNMaWdodEtZQ1ZlcmlmaWVkKGFjdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF95aWVsZCRfdGhpcyRycGMkaXNMaSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckluZm8gPSBfeWllbGQkX3RoaXMkcnBjJGlzTGlbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHVzZXJJbmZvICYmIHVzZXJJbmZvLmlzTGlnaHRLWUNWZXJpZmllZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzb2x2ZShLeWNTdGF0dXMuUEFTU0VEKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBfdGhpcy5jb25zdGFudHMuQkxPS1NfQVBJICsgXCIvXCIgKyBjaGFpbiArIFwiL2t5Yz90eXBlPXN0YXR1cyZjaGFpbj1cIiArIGNoYWluICsgXCImYWN0b3I9XCIgKyBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXQodXJsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGt5YyA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgha3ljIHx8ICFreWMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVqZWN0KG5ldyBFcnJvcignQ291bGQgbm90IGZldGNoIEtZQyByZWNvcmQnKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgcmVsZXZhbnQgS1lDIHJlY29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFRpZXIgPSBreWMuZmluZChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpZXIgPSBfcmVmNS50aWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGllciA9PT0gU3RyaW5nKGV4cGVjdGVkVGllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRUaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZWplY3QobmV3IEVycm9yKCdObyBreWMgZGF0YSBtYXRjaGluZyB0aWVyIGZvdW5kJykpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbndyYXAga3ljIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IG1hdGNoZWRUaWVyLnN0YXR1cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRUaWVyLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVqZWN0KG5ldyBFcnJvcignS1lDIFN0YXR1cyBub3QgZm91bmQnKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHN0YXR1cyA9PT0gS3ljU3RhdHVzLlBFTkRJTkcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFN0YXR1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCAqIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc29sdmUoc3RhdHVzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdHVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMyk7XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94NCwgX3g1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCkpKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX2NoZWNrVXNlckt5Y1N0YXR1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBhcHBseUZvckt5YyhfeDMpIHtcbiAgcmV0dXJuIF9hcHBseUZvckt5Yy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfYXBwbHlGb3JLeWMoKSB7XG4gIF9hcHBseUZvckt5YyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUocGFyYW1zKSB7XG4gICAgdmFyIHVybCwgZGF0YTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuQkxPS1NfQVBJICsgXCIvXCIgKyBwYXJhbXMuY2hhaW4gKyBcIi9reWNcIjtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QodXJsLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgIHR5cGU6ICdhcHBseSdcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBhcHBseSBmb3IgS1lDJyk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9hcHBseUZvckt5Yy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgY2hhaW5JbmZvUGFyc2VyID0gLyojX19QVVJFX18qL3oub2JqZWN0KHtcbiAgY2hhaW5JZDogLyojX19QVVJFX18qL3ouc3RyaW5nKCksXG4gIGV4cGxvcmVyVXJsOiAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSxcbiAgZXhwbG9yZXJOYW1lOiAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSxcbiAgcmVzb3VyY2VUb2tlblN5bWJvbDogLyojX19QVVJFX18qL3ouc3RyaW5nKCksXG4gIHJlc291cmNlVG9rZW5Db250cmFjdDogLyojX19QVVJFX18qL3ouc3RyaW5nKCksXG4gIHN5c3RlbVRva2VuU3ltYm9sOiAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSxcbiAgc3lzdGVtVG9rZW5Db250cmFjdDogLyojX19QVVJFX18qL3ouc3RyaW5nKCksXG4gIHJwY0VuZHBvaW50czogLyojX19QVVJFX18qL3ouYXJyYXkoIC8qI19fUFVSRV9fKi96LnN0cmluZygpKSxcbiAgYWN0aW9uc1JwY0VuZHBvaW50czogLyojX19QVVJFX18qL3ouYXJyYXkoIC8qI19fUFVSRV9fKi96LnN0cmluZygpKSxcbiAgaHlwZXJpb25FbmRwb2ludHM6IC8qI19fUFVSRV9fKi96LmFycmF5KCAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSksXG4gIGxpZ2h0RW5kcG9pbnRzOiAvKiNfX1BVUkVfXyovei5hcnJheSggLyojX19QVVJFX18qL3ouc3RyaW5nKCkpXG59KTtcblxuZnVuY3Rpb24gZ2V0Q2hhaW5JbmZvKCkge1xuICByZXR1cm4gX2dldENoYWluSW5mby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q2hhaW5JbmZvKCkge1xuICBfZ2V0Q2hhaW5JbmZvID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgIHZhciB1cmwsIGRhdGE7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuQ0hBSU4gPT09ICdwcm90b24tdGVzdCcgPyAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1Byb3RvblByb3RvY29sL2NoYWluLWluZm8vbWFpbi90ZXN0bmV0Lmpzb24nIDogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9Qcm90b25Qcm90b2NvbC9jaGFpbi1pbmZvL21haW4vbWFpbm5ldC5qc29uJztcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsLCB7fSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY2hhaW5JbmZvUGFyc2VyLnBhcnNlKGRhdGEpKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcywgW1sxLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0Q2hhaW5JbmZvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFRva2VuUHJpY2VzKCkge1xuICByZXR1cm4gX2dldFRva2VuUHJpY2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRUb2tlblByaWNlcygpIHtcbiAgX2dldFRva2VuUHJpY2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICB2YXIgdXJsLCBkYXRhO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5NRVRBTF9QUk9UT05fRU5EUE9JTlQgKyBcIi92MS9jaGFpbi9leGNoYW5nZS1yYXRlcy9pbmZvXCI7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGV4Y2hhbmdlUmF0ZXNQYXJzZXIucGFyc2UoZGF0YSkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmV0Y2ggZXhjaGFuZ2UgcmF0ZXNcIik7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbMSwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFRva2VuUHJpY2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFdpdGhkcmF3YWxGZWUoX3gpIHtcbiAgcmV0dXJuIF9nZXRXaXRoZHJhd2FsRmVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRXaXRoZHJhd2FsRmVlKCkge1xuICBfZ2V0V2l0aGRyYXdhbEZlZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoX3JlZikge1xuICAgIHZhciBjdXJyZW5jeSwgbmV0d29yaywgdXJsLCBkYXRhO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjdXJyZW5jeSA9IF9yZWYuY3VycmVuY3ksIG5ldHdvcmsgPSBfcmVmLm5ldHdvcms7XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5NRVRBTF9QUk9UT05fRU5EUE9JTlQgKyBcIi92MS9zd2Fwcy9jYWxjdWxhdGUtZXN0aW1hdGVkLWZlZVwiO1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdCh1cmwsIHtcbiAgICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHdpdGhkcmF3YWxGZWVRdW90ZVBhcnNlci5wYXJzZShkYXRhKSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDk7XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0My50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzIsIDldXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRXaXRoZHJhd2FsRmVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGN1cnJlbnRMb2NhdGlvbigpIHtcbiAgcmV0dXJuIF9jdXJyZW50TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2N1cnJlbnRMb2NhdGlvbigpIHtcbiAgX2N1cnJlbnRMb2NhdGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuTUVUQUxfUFJPVE9OX0VORFBPSU5UICsgXCIvdjEva3ljL2lwLWluZm9cIjtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfY3VycmVudExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEF2YWlsYWJsZUZlYXR1cmVzKF94Mikge1xuICByZXR1cm4gX2dldEF2YWlsYWJsZUZlYXR1cmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBdmFpbGFibGVGZWF0dXJlcygpIHtcbiAgX2dldEF2YWlsYWJsZUZlYXR1cmVzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShhY2NvdW50KSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuTUVUQUxfUFJPVE9OX0VORFBPSU5UICsgKFwiL3YyL2t5Yy9ieS1jaGFpbi1hY2NvdW50L1wiICsgYWNjb3VudCArIFwiL2F2YWlsYWJsZS1mZWF0dXJlc1wiKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ1LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QXZhaWxhYmxlRmVhdHVyZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWNjb3VudChfeDMpIHtcbiAgcmV0dXJuIF9jcmVhdGVBY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVBY2NvdW50KCkge1xuICBfY3JlYXRlQWNjb3VudCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYocGFyYW1zKSB7XG4gICAgdmFyIHVybCwgZGF0YTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuTUVUQUxfUFJPVE9OX0VORFBPSU5UICsgXCIvdjIvdXNlcnMvY3JlYXRlXCI7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHVybCwgcGFyYW1zKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfY3JlYXRlQWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBsb2dpbkFjY291bnQoX3g0KSB7XG4gIHJldHVybiBfbG9naW5BY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9sb2dpbkFjY291bnQoKSB7XG4gIF9sb2dpbkFjY291bnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHBhcmFtcykge1xuICAgIHZhciB1cmwsIGRhdGE7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLk1FVEFMX1BST1RPTl9FTkRQT0lOVCArIFwiL3YyL3VzZXJzL2xvZ2luXCI7XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHVybCwgcGFyYW1zKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfbG9naW5BY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG90Y1F1b3RlKF94KSB7XG4gIHJldHVybiBfb3RjUXVvdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX290Y1F1b3RlKCkge1xuICBfb3RjUXVvdGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYm9keSkge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuU1dBUF9VUkwgKyAoXCIvdjEvcXVvdGUvXCIgKyBib2R5LmJhc2VTeW1ib2wgKyBcIi9cIiArIGJvZHkuYmFzZUFtb3VudCArIFwiL1wiICsgYm9keS5xdW90ZVN5bWJvbCk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9vdGNRdW90ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBvdGNPcmRlcihfeDIpIHtcbiAgcmV0dXJuIF9vdGNPcmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb3RjT3JkZXIoKSB7XG4gIF9vdGNPcmRlciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoaWQpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5TV0FQX1VSTCArIChcIi92MS9vcmRlci9cIiArIGlkKTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfb3RjT3JkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVBZGRyZXNzKF94KSB7XG4gIHJldHVybiBfZ2VuZXJhdGVBZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZW5lcmF0ZUFkZHJlc3MoKSB7XG4gIF9nZW5lcmF0ZUFkZHJlc3MgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYm9keSkge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuV1JBUF9TRVJWRVJfVVJMICsgJy9hZGRyZXNzL2dlbmVyYXRlJztcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdCh1cmwsIGJvZHkpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZW5lcmF0ZUFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlQWRkcmVzcyhfeDIpIHtcbiAgcmV0dXJuIF9kZWxldGVBZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9kZWxldGVBZGRyZXNzKCkge1xuICBfZGVsZXRlQWRkcmVzcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYm9keSkge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLldSQVBfU0VSVkVSX1VSTCArICcvYWRkcmVzcy9kZWxldGUnO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdCh1cmwsIGJvZHkpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZGVsZXRlQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB3aXRoZHJhd01ldGFsKF94Mykge1xuICByZXR1cm4gX3dpdGhkcmF3TWV0YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3dpdGhkcmF3TWV0YWwoKSB7XG4gIF93aXRoZHJhd01ldGFsID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhib2R5KSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuV1JBUF9TRVJWRVJfVVJMICsgJy93aXRoZHJhdyc7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHVybCwgYm9keSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDMuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF93aXRoZHJhd01ldGFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHdpdGhkcmF3YWxIaXN0b3J5TWV0YWwoX3g0KSB7XG4gIHJldHVybiBfd2l0aGRyYXdhbEhpc3RvcnlNZXRhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfd2l0aGRyYXdhbEhpc3RvcnlNZXRhbCgpIHtcbiAgX3dpdGhkcmF3YWxIaXN0b3J5TWV0YWwgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGFjY291bnQpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5XUkFQX1NFUlZFUl9VUkwgKyAoXCIvd2l0aGRyYXdhbHMvXCIgKyBhY2NvdW50KTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfd2l0aGRyYXdhbEhpc3RvcnlNZXRhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRYcHJUb3RhbFN0YWtlZEFuZEFwcigpIHtcbiAgcmV0dXJuIF9nZXRYcHJUb3RhbFN0YWtlZEFuZEFwci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0WHByVG90YWxTdGFrZWRBbmRBcHIoKSB7XG4gIF9nZXRYcHJUb3RhbFN0YWtlZEFuZEFwciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICB2YXIgX3lpZWxkJFByb21pc2UkYWxsLCBzdXBwbHksIHRvdGFsU3Rha2VkVW5wYXJzZWQsIF95aWVsZCRQcm9taXNlJGFsbCQsIGNvbnRpbnVvdXNfcmF0ZSwgaW5mbGF0aW9uX3BheV9mYWN0b3IsIHZvdGVwYXlfZmFjdG9yLCBhZGRpdGlvbmFsSW5mbGF0aW9uLCBuZXdfdG9rZW5zLCB0b195aWVsZGZhcm1zLCBicGFuZHNhdmluZ3MsIHRvX3Byb2R1Y2VycywgdG9fcHJvZHVjZXJzX2Jsb2NrLCB0b19wcm9kdWNlcnNfdm90ZSwgc2F2aW5ncywgdG9fc2F2aW5ncywgdG9fY29uc29ydGl1bSwgdG90YWxTdGFrZWQsIGFwcjtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMuZ2V0VG9rZW5TdXBwbHkodGhpcy5jb25zdGFudHMuRU9TSU9fVE9LRU4sIHRoaXMuY29uc3RhbnRzLkNPUkVfU1lNQk9MKSwgdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ2dsb2JhbHNkJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzLnJvd3NbMF07XG4gICAgICAgICAgICB9KSwgdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ2dsb2JhbDQnLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXMucm93c1swXTtcbiAgICAgICAgICAgIH0pXSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkUHJvbWlzZSRhbGwgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgc3VwcGx5ID0gX3lpZWxkJFByb21pc2UkYWxsWzBdLnN1cHBseTtcbiAgICAgICAgICAgIHRvdGFsU3Rha2VkVW5wYXJzZWQgPSBfeWllbGQkUHJvbWlzZSRhbGxbMV0udG90YWxyc3Rha2VkO1xuICAgICAgICAgICAgX3lpZWxkJFByb21pc2UkYWxsJCA9IF95aWVsZCRQcm9taXNlJGFsbFsyXTtcbiAgICAgICAgICAgIGNvbnRpbnVvdXNfcmF0ZSA9IF95aWVsZCRQcm9taXNlJGFsbCQuY29udGludW91c19yYXRlO1xuICAgICAgICAgICAgaW5mbGF0aW9uX3BheV9mYWN0b3IgPSBfeWllbGQkUHJvbWlzZSRhbGwkLmluZmxhdGlvbl9wYXlfZmFjdG9yO1xuICAgICAgICAgICAgdm90ZXBheV9mYWN0b3IgPSBfeWllbGQkUHJvbWlzZSRhbGwkLnZvdGVwYXlfZmFjdG9yO1xuICAgICAgICAgICAgYWRkaXRpb25hbEluZmxhdGlvbiA9ICtjb250aW51b3VzX3JhdGUgKiBzdXBwbHk7XG4gICAgICAgICAgICBuZXdfdG9rZW5zID0gYWRkaXRpb25hbEluZmxhdGlvbjtcbiAgICAgICAgICAgIHRvX3lpZWxkZmFybXMgPSBuZXdfdG9rZW5zIC8gNDtcbiAgICAgICAgICAgIGJwYW5kc2F2aW5ncyA9IG5ld190b2tlbnMgLSB0b195aWVsZGZhcm1zO1xuICAgICAgICAgICAgdG9fcHJvZHVjZXJzID0gYnBhbmRzYXZpbmdzICogKDEwMDAwIC8gaW5mbGF0aW9uX3BheV9mYWN0b3IpO1xuICAgICAgICAgICAgdG9fcHJvZHVjZXJzX2Jsb2NrID0gdG9fcHJvZHVjZXJzICogKDEwMDAwIC8gdm90ZXBheV9mYWN0b3IpO1xuICAgICAgICAgICAgdG9fcHJvZHVjZXJzX3ZvdGUgPSB0b19wcm9kdWNlcnMgLSB0b19wcm9kdWNlcnNfYmxvY2s7XG4gICAgICAgICAgICBzYXZpbmdzID0gYnBhbmRzYXZpbmdzIC0gdG9fcHJvZHVjZXJzO1xuICAgICAgICAgICAgdG9fc2F2aW5ncyA9IDIgKiBzYXZpbmdzIC8gMztcbiAgICAgICAgICAgIHRvX2NvbnNvcnRpdW0gPSBzYXZpbmdzIC0gdG9fc2F2aW5ncztcbiAgICAgICAgICAgIHRvdGFsU3Rha2VkID0gK3RvdGFsU3Rha2VkVW5wYXJzZWQgLyBNYXRoLnBvdygxMCwgdGhpcy5jb25zdGFudHMuQ09SRV9QUkVDSVNJT04pO1xuICAgICAgICAgICAgYXByID0gdG9fc2F2aW5ncyAvIHRvdGFsU3Rha2VkICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIHN1cHBseTogc3VwcGx5LFxuICAgICAgICAgICAgICB5aWVsZEZhcm1pbmc6IHRvX3lpZWxkZmFybXMsXG4gICAgICAgICAgICAgIHByb2R1Y2VyczogdG9fcHJvZHVjZXJzLFxuICAgICAgICAgICAgICBwcm9kdWNlcnNCbG9jazogdG9fcHJvZHVjZXJzX2Jsb2NrLFxuICAgICAgICAgICAgICBwcm9kdWNlcnNWb3RlOiB0b19wcm9kdWNlcnNfdm90ZSxcbiAgICAgICAgICAgICAgY29uc29ydGl1bTogdG9fY29uc29ydGl1bSxcbiAgICAgICAgICAgICAgc3Rha2luZzogdG9fc2F2aW5ncyxcbiAgICAgICAgICAgICAgdG90YWxTdGFrZWQ6IHRvdGFsU3Rha2VkLFxuICAgICAgICAgICAgICBhcHI6IGFwclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI1O1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCAwKTtcblxuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgMjVdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRYcHJUb3RhbFN0YWtlZEFuZEFwci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRYcHJWb3RlcihfeCkge1xuICByZXR1cm4gX2dldFhwclZvdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRYcHJWb3RlcigpIHtcbiAgX2dldFhwclZvdGVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHRhYmxlOiAndm90ZXJzeHByJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGggJiYgcm93c1swXS5vd25lciA9PT0gYWNjb3VudCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDEyO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDIudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCAxMl1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFhwclZvdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFhwckFjY291bnRTdGFrZXMoX3gyKSB7XG4gIHJldHVybiBfZ2V0WHByQWNjb3VudFN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0WHByQWNjb3VudFN0YWtlcygpIHtcbiAgX2dldFhwckFjY291bnRTdGFrZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGFjY291bnQpIHtcbiAgICB2YXIgc3Rha2VzLCBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHN0YWtlcyA9IFtdO1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdGFibGU6ICdkZWx4cHInLFxuICAgICAgICAgICAgICBsaW1pdDogLTFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90MiA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDIucm93cztcblxuICAgICAgICAgICAgaWYgKHJvd3MgJiYgcm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3Rha2VzID0gcm93cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSA5O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHN0YWtlcyk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMSwgOV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFhwckFjY291bnRTdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0WHByQWNjb3VudFJlZnVuZChfeDMpIHtcbiAgcmV0dXJuIF9nZXRYcHJBY2NvdW50UmVmdW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRYcHJBY2NvdW50UmVmdW5kKCkge1xuICBfZ2V0WHByQWNjb3VudFJlZnVuZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWNjb3VudCkge1xuICAgIHZhciByZWZ1bmQsIF95aWVsZCR0aGlzJHJwYyRnZXRfdDMsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdGFibGU6ICdyZWZ1bmRzeHByJyxcbiAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDMgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QzLnJvd3M7XG5cbiAgICAgICAgICAgIGlmIChyb3dzICYmIHJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlZnVuZCA9IHJvd3NbMF07XG4gICAgICAgICAgICAgIHJlZnVuZC5xdWFudGl0eSA9ICtyZWZ1bmQucXVhbnRpdHkuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDQudDApO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHJlZnVuZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMsIFtbMCwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFhwckFjY291bnRSZWZ1bmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0WHByT3JhY2xlRGF0YShfeDQpIHtcbiAgcmV0dXJuIF9nZXRYcHJPcmFjbGVEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRYcHJPcmFjbGVEYXRhKCkge1xuICBfZ2V0WHByT3JhY2xlRGF0YSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUob3JhY2xlSW5kZXgpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90NCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnb3JhY2xlcycsXG4gICAgICAgICAgICAgIHNjb3BlOiAnb3JhY2xlcycsXG4gICAgICAgICAgICAgIHRhYmxlOiAnZGF0YScsXG4gICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogb3JhY2xlSW5kZXgsXG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiBvcmFjbGVJbmRleFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q0ID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90NC5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMTI7XG4gICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0NS50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzAsIDEyXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0WHByT3JhY2xlRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBbGxPcmFjbGVGZWVkcyhfeDUpIHtcbiAgcmV0dXJuIF9nZXRBbGxPcmFjbGVGZWVkcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWxsT3JhY2xlRmVlZHMoKSB7XG4gIF9nZXRBbGxPcmFjbGVGZWVkcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYobG93ZXJfYm91bmQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90NSwgcm93cywgbW9yZSwgbmV4dF9rZXksIHJlc3RPZlJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGxvd2VyX2JvdW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdvcmFjbGVzJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdvcmFjbGVzJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdmZWVkcycsXG4gICAgICAgICAgICAgIGxpbWl0OiAtMSxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGxvd2VyX2JvdW5kXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDUgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1LnJvd3M7XG4gICAgICAgICAgICBtb3JlID0gX3lpZWxkJHRoaXMkcnBjJGdldF90NS5tb3JlO1xuICAgICAgICAgICAgbmV4dF9rZXkgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1Lm5leHRfa2V5O1xuXG4gICAgICAgICAgICBpZiAoIW1vcmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxPcmFjbGVGZWVkcyhuZXh0X2tleSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmVzdE9mUm93cyA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cy5jb25jYXQocmVzdE9mUm93cykpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMjI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDE4O1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gX2NvbnRleHQ2W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDYudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzEsIDE4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWxsT3JhY2xlRmVlZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BlY2lmaWNPcmFjbGVEYXRhKF94Nikge1xuICByZXR1cm4gX2dldFNwZWNpZmljT3JhY2xlRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSAvLyBwdWJcblxuZnVuY3Rpb24gX2dldFNwZWNpZmljT3JhY2xlRGF0YSgpIHtcbiAgX2dldFNwZWNpZmljT3JhY2xlRGF0YSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoZmVlZF9pbmRleCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q2LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdvcmFjbGVzJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdvcmFjbGVzJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgbGltaXQ6IC0xLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZmVlZF9pbmRleCxcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6IGZlZWRfaW5kZXhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NiA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDYucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCAmJiByb3dzWzBdLmZlZWRfaW5kZXggPT09IGZlZWRfaW5kZXgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSA5O1xuICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDcudDApO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTcsIHRoaXMsIFtbMCwgOV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFNwZWNpZmljT3JhY2xlRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBbGxPcmFjbGVEYXRhKF94Nykge1xuICByZXR1cm4gX2dldEFsbE9yYWNsZURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFsbE9yYWNsZURhdGEoKSB7XG4gIF9nZXRBbGxPcmFjbGVEYXRhID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOChsb3dlcl9ib3VuZCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q3LCByb3dzLCBtb3JlLCBuZXh0X2tleTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnb3JhY2xlcycsXG4gICAgICAgICAgICAgIHNjb3BlOiAnb3JhY2xlcycsXG4gICAgICAgICAgICAgIHRhYmxlOiAnZGF0YScsXG4gICAgICAgICAgICAgIGxpbWl0OiAtMSxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGxvd2VyX2JvdW5kXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDcgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q3LnJvd3M7XG4gICAgICAgICAgICBtb3JlID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Ny5tb3JlO1xuICAgICAgICAgICAgbmV4dF9rZXkgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q3Lm5leHRfa2V5O1xuXG4gICAgICAgICAgICBpZiAoIW1vcmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0OC50MCA9IHJvd3M7XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsT3JhY2xlRGF0YShuZXh0X2tleSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQ4LnQxID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX2NvbnRleHQ4LnQwLmNvbmNhdC5jYWxsKF9jb250ZXh0OC50MCwgX2NvbnRleHQ4LnQxKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDE2O1xuICAgICAgICAgICAgX2NvbnRleHQ4LnQyID0gX2NvbnRleHQ4W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDgudDIpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU4LCB0aGlzLCBbWzAsIDE2XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWxsT3JhY2xlRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm90b25BdmF0YXJzKF94OCwgX3g5KSB7XG4gIHJldHVybiBfZ2V0UHJvdG9uQXZhdGFycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG9uQXZhdGFycygpIHtcbiAgX2dldFByb3RvbkF2YXRhcnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KGFjY291bnQsIGxpbWl0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbGltaXQgPSAxMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEodGhpcy5jb25zdGFudHMuQ0hBSU4uaW5kZXhPZigncHJvdG9uJykgIT09IC0xKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ5LnByZXYgPSAyO1xuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogJ2Vvc2lvLnByb3RvbicsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZW9zaW8ucHJvdG9uJyxcbiAgICAgICAgICAgICAgdGFibGU6ICd1c2Vyc2luZm8nLFxuICAgICAgICAgICAgICB0YWJsZV9rZXk6ICcnLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDEsXG4gICAgICAgICAgICAgIGxpbWl0OiBsaW1pdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdC5yb3dzKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0OS5wcmV2ID0gOTtcbiAgICAgICAgICAgIF9jb250ZXh0OS50MCA9IF9jb250ZXh0OVtcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dldFByb3RvbkF2YXRhciBlcnJvcicsIF9jb250ZXh0OS50MCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU5LCB0aGlzLCBbWzIsIDldXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQcm90b25BdmF0YXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb3RvbkF2YXRhcihfeDEwKSB7XG4gIHJldHVybiBfZ2V0UHJvdG9uQXZhdGFyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b25BdmF0YXIoKSB7XG4gIF9nZXRQcm90b25BdmF0YXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMChhY2NvdW50KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHRoaXMuY29uc3RhbnRzLkNIQUlOLmluZGV4T2YoJ3Byb3RvbicpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6ICdlb3Npby5wcm90b24nLFxuICAgICAgICAgICAgICBzY29wZTogJ2Vvc2lvLnByb3RvbicsXG4gICAgICAgICAgICAgIHRhYmxlOiAndXNlcnNpbmZvJyxcbiAgICAgICAgICAgICAgdGFibGVfa2V5OiAnJyxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpNjQnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAxLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDEwLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LnJvd3MubGVuZ3RoID4gMCAmJiByZXN1bHQucm93c1swXS5hY2MgPT09IGFjY291bnQgPyByZXN1bHQucm93c1swXSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQxMC50MCA9IF9jb250ZXh0MTBbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXRQcm90b25BdmF0YXIgZXJyb3InLCBfY29udGV4dDEwLnQwKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTEwLCB0aGlzLCBbWzEsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQcm90b25BdmF0YXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVudGJ3U3RhdGUoKSB7XG4gIHJldHVybiBfZ2V0UmVudGJ3U3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJlbnRid1N0YXRlKCkge1xuICBfZ2V0UmVudGJ3U3RhdGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiAwLFxuICAgICAgICAgICAgICB0YWJsZTogJ3Bvd3VwLnN0YXRlJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Qucm93cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmVudGJ3U3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZGVsZWdhdGVkQmFuZHdpZHRoKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9kZWxlZ2F0ZWRCYW5kd2lkdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2RlbGVnYXRlZEJhbmR3aWR0aCgpIHtcbiAgX2RlbGVnYXRlZEJhbmR3aWR0aCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYWNjb3VudCwgbG93ZXJfYm91bmQpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB0YWJsZTogJ2RlbGJhbmQnLFxuICAgICAgICAgICAgICB0YWJsZV9rZXk6ICcnLFxuICAgICAgICAgICAgICBsaW1pdDogLTEsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBsb3dlcl9ib3VuZCxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpNjQnLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogMVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZGVsZWdhdGVkQmFuZHdpZHRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjY291bnREZWxlZ2F0ZWRCYW5kd2lkdGgoX3gzKSB7XG4gIHJldHVybiBfZ2V0QWNjb3VudERlbGVnYXRlZEJhbmR3aWR0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWNjb3VudERlbGVnYXRlZEJhbmR3aWR0aCgpIHtcbiAgX2dldEFjY291bnREZWxlZ2F0ZWRCYW5kd2lkdGggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGFjY291bnQpIHtcbiAgICB2YXIgbW9yZSwgcm93cywgcmVzdWx0LCBsb3dlcl9ib3VuZDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgbW9yZSA9IHRydWU7XG4gICAgICAgICAgICByb3dzID0gW107XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbG93ZXJfYm91bmQgPSAnJztcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gNDtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlZEJhbmR3aWR0aChhY2NvdW50LCBsb3dlcl9ib3VuZCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIG1vcmUgPSByZXN1bHQubW9yZTtcbiAgICAgICAgICAgIHJvd3MgPSByb3dzLmNvbmNhdChyZXN1bHQucm93cyk7XG5cbiAgICAgICAgICAgIGlmIChtb3JlKSB7XG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kID0gbmV3IEJpZ051bWJlcihlbmNvZGVOYW1lKHJvd3Nbcm93cy5sZW5ndGggLSAxXS50bywgZmFsc2UpKS5wbHVzKDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgaWYgKG1vcmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNDtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcywgW1s0LCAxNF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjY291bnREZWxlZ2F0ZWRCYW5kd2lkdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWNjb3VudFJlc291cmNlcyhfeDQpIHtcbiAgcmV0dXJuIF9nZXRBY2NvdW50UmVzb3VyY2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY2NvdW50UmVzb3VyY2VzKCkge1xuICBfZ2V0QWNjb3VudFJlc291cmNlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHRhYmxlOiAndXNlcnJlcycsXG4gICAgICAgICAgICAgIHRhYmxlX2tleTogJycsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLnJvd3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjY291bnRSZXNvdXJjZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFtUHJpY2VJbkVvcygpIHtcbiAgcmV0dXJuIF9nZXRSYW1QcmljZUluRW9zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSYW1QcmljZUluRW9zKCkge1xuICBfZ2V0UmFtUHJpY2VJbkVvcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoKSB7XG4gICAgdmFyIHJhbSwgYmFzZVN0cmluZywgYmFzZSwgcXVvdGVTdHJpbmcsIHF1b3RlLCBwcmljZSwgcmFtUHJpY2VFb3M7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAncmFtbWFya2V0JyxcbiAgICAgICAgICAgICAgdGFibGVfa2V5OiAnJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJhbSA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgLy8gQW1vdW50IG9mIFJBTSBieXRlcyBpbiB1c2VcbiAgICAgICAgICAgIGJhc2VTdHJpbmcgPSByYW0ucm93c1swXS5iYXNlLmJhbGFuY2U7XG4gICAgICAgICAgICBiYXNlID0gK2Jhc2VTdHJpbmcuc3Vic3RyKDAsIGJhc2VTdHJpbmcuaW5kZXhPZignICcpKTsgLy8gQW1vdW50IG9mIEVPUyBpbiB0aGUgUkFNIGNvbGxlY3RvclxuXG4gICAgICAgICAgICBxdW90ZVN0cmluZyA9IHJhbS5yb3dzWzBdLnF1b3RlLmJhbGFuY2U7XG4gICAgICAgICAgICBxdW90ZSA9IHF1b3RlU3RyaW5nLnN1YnN0cigwLCBxdW90ZVN0cmluZy5pbmRleE9mKCcgJykpOyAvLyBQcmljZSBpbiBrYlxuXG4gICAgICAgICAgICBwcmljZSA9IHF1b3RlIC8gYmFzZTtcbiAgICAgICAgICAgIHJhbVByaWNlRW9zID0gTnVtYmVyKHByaWNlLnRvRml4ZWQoOCkpICogMTAyNDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJhbVByaWNlRW9zKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDEzO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDUudDApO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIDApO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzAsIDEzXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmFtUHJpY2VJbkVvcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRFb3NUb3BTdGFrZXMoX3gpIHtcbiAgcmV0dXJuIF9nZXRFb3NUb3BTdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEVvc1RvcFN0YWtlcygpIHtcbiAgX2dldEVvc1RvcFN0YWtlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShsaW1pdCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGxpbWl0ID0gNTAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMubGlnaHRBcGkuZ2V0X3RvcHN0YWtlKGxpbWl0KSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RW9zVG9wU3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEVvc1RvcFJhbXMoX3gyKSB7XG4gIHJldHVybiBfZ2V0RW9zVG9wUmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RW9zVG9wUmFtcygpIHtcbiAgX2dldEVvc1RvcFJhbXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGxpbWl0KSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGxpbWl0ID0gNTAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB0aGlzLmxpZ2h0QXBpLmdldF90b3ByYW0obGltaXQpKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEVvc1RvcFJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudE5hbWVCaWRzKF94MywgX3g0KSB7XG4gIHJldHVybiBfZ2V0Q3VycmVudE5hbWVCaWRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRDdXJyZW50TmFtZUJpZHMoKSB7XG4gIF9nZXRDdXJyZW50TmFtZUJpZHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QsIHJvd3MsIG1vcmUsIG5leHRfa2V5O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChsb3dlcl9ib3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1cHBlcl9ib3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAnbmFtZWJpZHMnLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBsb3dlcl9ib3VuZCAmJiBsb3dlcl9ib3VuZC5sZW5ndGggPD0gMTIgPyBlbmNvZGVOYW1lKGxvd2VyX2JvdW5kLCB0cnVlKSA6IGxvd2VyX2JvdW5kLFxuICAgICAgICAgICAgICB1cHBlcl9ib3VuZDogdXBwZXJfYm91bmQgJiYgdXBwZXJfYm91bmQubGVuZ3RoIDw9IDEyID8gZW5jb2RlTmFtZSh1cHBlcl9ib3VuZCwgdHJ1ZSkgOiB1cHBlcl9ib3VuZCxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDEsXG4gICAgICAgICAgICAgIGxpbWl0OiAtMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Qucm93cztcbiAgICAgICAgICAgIG1vcmUgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QubW9yZTtcbiAgICAgICAgICAgIG5leHRfa2V5ID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Lm5leHRfa2V5O1xuXG4gICAgICAgICAgICBpZiAoIW1vcmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IHJvd3M7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudE5hbWVCaWRzKG5leHRfa2V5LCB1cHBlcl9ib3VuZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQzLnQxID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX2NvbnRleHQzLnQwLmNvbmNhdC5jYWxsKF9jb250ZXh0My50MCwgX2NvbnRleHQzLnQxKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRDdXJyZW50TmFtZUJpZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIGNoYWluVG9SZXhNYXAgPSB7XG4gIGp1bmdsZTogJ2p1bmdsZScsXG4gIGJvczogJ2JvcycsXG4gIGVvczogJ21haW5uZXQnLFxuICB0ZWxvczogJ3RlbG9zJ1xufTtcbmZ1bmN0aW9uIGdldFJleFF1ZXVlZChfeCkge1xuICByZXR1cm4gX2dldFJleFF1ZXVlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmV4UXVldWVkKCkge1xuICBfZ2V0UmV4UXVldWVkID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAncmV4cXVldWUnLFxuICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGggJiYgcm93c1swXS5vd25lciA9PT0gYWNjb3VudCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDldXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZXhRdWV1ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmV4UG9vbCgpIHtcbiAgcmV0dXJuIF9nZXRSZXhQb29sLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXhQb29sKCkge1xuICBfZ2V0UmV4UG9vbCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIsIHJvd3MsIHBvb2wsIGFzc2V0VG9OdW1iZXIsIHRvdGFsX2xlbnQsIHRvdGFsX2xlbmRhYmxlLCB0b3RhbF91bmxlbnQsIHRvdGFsX3JleCwgdG90YWxfcmVudCwgbGVudF9wZXJjZW50LCByZXhfcHJpY2UsIHJlc291cmNlX3ByaWNlO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAncmV4cG9vbCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90MiA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDIucm93cztcbiAgICAgICAgICAgIHBvb2wgPSByb3dzWzBdO1xuXG4gICAgICAgICAgICBhc3NldFRvTnVtYmVyID0gZnVuY3Rpb24gYXNzZXRUb051bWJlcihhc3NldCkge1xuICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKGFzc2V0LnNwbGl0KCcgJylbMF0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdG90YWxfbGVudCA9IGFzc2V0VG9OdW1iZXIocG9vbC50b3RhbF9sZW50KTtcbiAgICAgICAgICAgIHRvdGFsX2xlbmRhYmxlID0gYXNzZXRUb051bWJlcihwb29sLnRvdGFsX2xlbmRhYmxlKTtcbiAgICAgICAgICAgIHRvdGFsX3VubGVudCA9IGFzc2V0VG9OdW1iZXIocG9vbC50b3RhbF91bmxlbnQpO1xuICAgICAgICAgICAgdG90YWxfcmV4ID0gYXNzZXRUb051bWJlcihwb29sLnRvdGFsX3JleCk7XG4gICAgICAgICAgICB0b3RhbF9yZW50ID0gYXNzZXRUb051bWJlcihwb29sLnRvdGFsX3JlbnQpO1xuICAgICAgICAgICAgbGVudF9wZXJjZW50ID0gbXVsdGlwbHkoZGl2aWRlKHRvdGFsX2xlbnQsIHRvdGFsX2xlbmRhYmxlKSwgMTAwKTtcbiAgICAgICAgICAgIHJleF9wcmljZSA9ICtkaXZpZGUodG90YWxfbGVuZGFibGUsIHRvdGFsX3JleCk7XG4gICAgICAgICAgICByZXNvdXJjZV9wcmljZSA9ICtkaXZpZGUodG90YWxfdW5sZW50LCB0b3RhbF9yZW50ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIHZlcnNpb246IHBvb2wudmVyc2lvbixcbiAgICAgICAgICAgICAgbmFtZWJpZF9wcm9jZWVkczogYXNzZXRUb051bWJlcihwb29sLm5hbWViaWRfcHJvY2VlZHMpLFxuICAgICAgICAgICAgICBsb2FuX251bTogcG9vbC5sb2FuX251bSxcbiAgICAgICAgICAgICAgdG90YWxfbGVudDogdG90YWxfbGVudCxcbiAgICAgICAgICAgICAgdG90YWxfdW5sZW50OiB0b3RhbF91bmxlbnQsXG4gICAgICAgICAgICAgIHRvdGFsX3JlbnQ6IHRvdGFsX3JlbnQsXG4gICAgICAgICAgICAgIHRvdGFsX2xlbmRhYmxlOiB0b3RhbF9sZW5kYWJsZSxcbiAgICAgICAgICAgICAgdG90YWxfcmV4OiB0b3RhbF9yZXgsXG4gICAgICAgICAgICAgIGxlbnRfcGVyY2VudDogbGVudF9wZXJjZW50LFxuICAgICAgICAgICAgICByZXhfcHJpY2U6IHJleF9wcmljZSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VfcHJpY2U6IHJlc291cmNlX3ByaWNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZXhQb29sLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJleEJhbGFuY2UoX3gyKSB7XG4gIHJldHVybiBfZ2V0UmV4QmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmV4QmFsYW5jZSgpIHtcbiAgX2dldFJleEJhbGFuY2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Mywgcm93cywgYmFsO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAncmV4YmFsJyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDMgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QzLnJvd3M7XG4gICAgICAgICAgICBiYWwgPSByb3dzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgYmFsLm93bmVyID09PSBhY2NvdW50ID8gYmFsIDogdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJleEJhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmV4Q3B1TG9hbnMoX3gzKSB7XG4gIHJldHVybiBfZ2V0UmV4Q3B1TG9hbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJleENwdUxvYW5zKCkge1xuICBfZ2V0UmV4Q3B1TG9hbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90NCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ2NwdWxvYW4nLFxuICAgICAgICAgICAgICB0YWJsZV9rZXk6ICdieW93bmVyJyxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpNjQnLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDQgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q0LnJvd3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuZnJvbSA9PT0gYWNjb3VudDtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJleENwdUxvYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJleE5ldExvYW5zKF94NCkge1xuICByZXR1cm4gX2dldFJleE5ldExvYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXhOZXRMb2FucygpIHtcbiAgX2dldFJleE5ldExvYW5zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDUsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICduZXRsb2FuJyxcbiAgICAgICAgICAgICAgdGFibGVfa2V5OiAnYnlvd25lcicsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMCxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogM1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1ID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90NS5yb3dzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gcm93LmZyb20gPT09IGFjY291bnQ7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZXhOZXRMb2Fucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRFb3NEZXBvc2l0ZWRJbnRvUmV4KF94NSkge1xuICByZXR1cm4gX2dldEVvc0RlcG9zaXRlZEludG9SZXguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEVvc0RlcG9zaXRlZEludG9SZXgoKSB7XG4gIF9nZXRFb3NEZXBvc2l0ZWRJbnRvUmV4ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDYsIHJvd3MsIHJvdztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ3JleGZ1bmQnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NiA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDYucm93cztcbiAgICAgICAgICAgIHJvdyA9IHJvd3NbMF07XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByb3cub3duZXIgPT09IGFjY291bnQgPyBOdW1iZXIocm93LmJhbGFuY2Uuc3BsaXQoJyAnKVswXSkgOiAwKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEVvc0RlcG9zaXRlZEludG9SZXguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmV4UmV0dXJuUmF0ZShfeDYpIHtcbiAgcmV0dXJuIF9nZXRSZXhSZXR1cm5SYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXhSZXR1cm5SYXRlKCkge1xuICBfZ2V0UmV4UmV0dXJuUmF0ZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcodHlwZSkge1xuICAgIHZhciBjaGFpbiwgX3lpZWxkJHRoaXMkcG9zdCwgZGF0YTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSAnbXByJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hhaW4gPSBjaGFpblRvUmV4TWFwW3RoaXMuY29uc3RhbnRzLkNIQUlOXTtcblxuICAgICAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdCgnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2dyYXBocWwvdjFhbHBoYTEvZ3JhcGhxbCcsIHtcbiAgICAgICAgICAgICAgcXVlcnk6IFwicXVlcnkge1xcbiAgICAgICAgXCIgKyBjaGFpbiArIFwiX1wiICsgdHlwZSArIFwiIHtcXG4gICAgICAgICAgXCIgKyB0eXBlICsgXCJcXG4gICAgICAgIH1cXG4gICAgICB9XCIsXG4gICAgICAgICAgICAgIHZhcmlhYmxlczogbnVsbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRwb3N0ID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICBkYXRhID0gX3lpZWxkJHRoaXMkcG9zdC5kYXRhO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIE1hdGguYWJzKGRhdGFbY2hhaW4gKyBcIl9cIiArIHR5cGVdWzBdW3R5cGVdKSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgMCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIDApO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU3LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJleFJldHVyblJhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmV4UHJpY2VDaGFydCgpIHtcbiAgcmV0dXJuIF9nZXRSZXhQcmljZUNoYXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXhQcmljZUNoYXJ0KCkge1xuICBfZ2V0UmV4UHJpY2VDaGFydCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgoKSB7XG4gICAgdmFyIGNoYWluLCBjdXJyZW50X3RpbWUsIHNldmVuX2RheXNfYWdvLCBfeWllbGQkdGhpcyRwb3N0MiwgZGF0YTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjaGFpbiA9IGNoYWluVG9SZXhNYXBbdGhpcy5jb25zdGFudHMuQ0hBSU5dO1xuXG4gICAgICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50X3RpbWUgPSBmb3JtYXREYXRlKHV0Y1RpbWUoKSk7XG4gICAgICAgICAgICBzZXZlbl9kYXlzX2FnbyA9IGZvcm1hdERhdGUodXRjVGltZShzdGFydERhdGUodGltZSgpLCA3KSkpO1xuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdCgnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2dyYXBocWwvdjFhbHBoYTEvZ3JhcGhxbCcsIHtcbiAgICAgICAgICAgICAgcXVlcnk6IFwicXVlcnkge1xcbiAgICAgICAgXCIgKyBjaGFpbiArIFwiX3ByaWNlY2hhcnQoYXJnczoge1xcbiAgICAgICAgICBmcm9tX3RpbWU6IFxcXCJcIiArIHNldmVuX2RheXNfYWdvICsgXCJcXFwiLFxcbiAgICAgICAgICB0b190aW1lOiBcXFwiXCIgKyBjdXJyZW50X3RpbWUgKyBcIlxcXCJcXG4gICAgICAgIH0pIHtcXG4gICAgICAgICAgdFxcbiAgICAgICAgICBvXFxuICAgICAgICAgIGhcXG4gICAgICAgICAgbFxcbiAgICAgICAgICBjXFxuICAgICAgICB9XFxuICAgICAgfVwiLFxuICAgICAgICAgICAgICB2YXJpYWJsZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcG9zdDIgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgIGRhdGEgPSBfeWllbGQkdGhpcyRwb3N0Mi5kYXRhO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIGRhdGFbY2hhaW4gKyBcIl9wcmljZWNoYXJ0XCJdKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgYWN0aW9uczogW11cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJleFByaWNlQ2hhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW9zQmFsYW5jZShfeCkge1xuICByZXR1cm4gX2dldEVvc0JhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEVvc0JhbGFuY2UoKSB7XG4gIF9nZXRFb3NCYWxhbmNlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFjY291bnROYW1lKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfYywgYmFsYW5jZTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF9jdXJyZW5jeV9iYWxhbmNlKHRoaXMuY29uc3RhbnRzLkVPU0lPX1RPS0VOLCBhY2NvdW50TmFtZSwgdGhpcy5jb25zdGFudHMuQ09SRV9TWU1CT0wpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF9jID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGJhbGFuY2UgPSBfeWllbGQkdGhpcyRycGMkZ2V0X2NbMF07XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGJhbGFuY2UpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEVvc0JhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW5CYWxhbmNlKF94MiwgX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9nZXRUb2tlbkJhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0gLy8gR2V0IEFjY291bnQgVG9rZW5zXG5cbmZ1bmN0aW9uIF9nZXRUb2tlbkJhbGFuY2UoKSB7XG4gIF9nZXRUb2tlbkJhbGFuY2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGNvbnRyYWN0LCBhY2NvdW50TmFtZSwgc3ltYm9sKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF9jdXJyZW5jeV9iYWxhbmNlKGNvbnRyYWN0LCBhY2NvdW50TmFtZSwgc3ltYm9sKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIShyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0WzBdKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0VG9rZW5CYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjY291bnRUb2tlbnMoX3g1KSB7XG4gIHJldHVybiBfZ2V0QWNjb3VudFRva2Vucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWNjb3VudFRva2VucygpIHtcbiAgX2dldEFjY291bnRUb2tlbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGFjY291bnROYW1lKSB7XG4gICAgdmFyIGFjY291bnRCYWxhbmNlcztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGFjY291bnRCYWxhbmNlcykge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saWdodEdldFRva2VucyhhY2NvdW50TmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBhY2NvdW50QmFsYW5jZXMgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlmIChhY2NvdW50QmFsYW5jZXMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb25HZXRUb2tlbnNGb3JBY2NvdW50KGFjY291bnROYW1lKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGFjY291bnRCYWxhbmNlcyA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgYWNjb3VudEJhbGFuY2VzIHx8IFtdKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjY291bnRUb2tlbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbGlnaHRHZXRUb2tlbnMoX3g2KSB7XG4gIHJldHVybiBfbGlnaHRHZXRUb2tlbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xpZ2h0R2V0VG9rZW5zKCkge1xuICBfbGlnaHRHZXRUb2tlbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkbGlnaHRBcGkkLCBiYWxhbmNlcztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saWdodEFwaS5nZXRfYmFsYW5jZXMoYWNjb3VudCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRsaWdodEFwaSQgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIGJhbGFuY2VzID0gX3lpZWxkJHRoaXMkbGlnaHRBcGkkLmJhbGFuY2VzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgYmFsYW5jZXMubWFwKGZ1bmN0aW9uIChiYWxhbmNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3k6IGJhbGFuY2UuY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgYW1vdW50OiBOdW1iZXIoYmFsYW5jZS5hbW91bnQpLFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBiYWxhbmNlLmNvbnRyYWN0LFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBOdW1iZXIoYmFsYW5jZS5kZWNpbWFscylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IF9jb250ZXh0NFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2xpZ2h0R2V0VG9rZW5zIGVycm9yJywgX2NvbnRleHQ0LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMsIFtbMCwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2xpZ2h0R2V0VG9rZW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGh5cGVyaW9uR2V0VG9rZW5zRm9yQWNjb3VudChfeDcpIHtcbiAgcmV0dXJuIF9oeXBlcmlvbkdldFRva2Vuc0ZvckFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2h5cGVyaW9uR2V0VG9rZW5zRm9yQWNjb3VudCgpIHtcbiAgX2h5cGVyaW9uR2V0VG9rZW5zRm9yQWNjb3VudCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRoeXBlcmlvbiQsIHRva2VucztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbi5nZXRfdG9rZW5zKGFjY291bnQpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkaHlwZXJpb24kID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICB0b2tlbnMgPSBfeWllbGQkdGhpcyRoeXBlcmlvbiQudG9rZW5zO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeTogdG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgICAgIGFtb3VudDogTnVtYmVyKHRva2VuLmFtb3VudCksXG4gICAgICAgICAgICAgICAgY29udHJhY3Q6IHRva2VuLmNvbnRyYWN0LFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBOdW1iZXIodG9rZW4ucHJlY2lzaW9uKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaHlwZXJpb25HZXRUb2tlbnNGb3JBY2NvdW50IGVycm9yJywgX2NvbnRleHQ1LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMCwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2h5cGVyaW9uR2V0VG9rZW5zRm9yQWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRUb2tlblN1cHBseShfeDgsIF94OSkge1xuICByZXR1cm4gX2dldFRva2VuU3VwcGx5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRUb2tlblN1cHBseSgpIHtcbiAgX2dldFRva2VuU3VwcGx5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihjb250cmFjdCwgc3ltYm9sKSB7XG4gICAgdmFyIHN0YXRzLCBfc3RhdHMkc3ltYm9sLCBzdXBwbHksIG1heF9zdXBwbHk7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF9jdXJyZW5jeV9zdGF0cyhjb250cmFjdCwgc3ltYm9sKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0YXRzID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICBfc3RhdHMkc3ltYm9sID0gc3RhdHNbc3ltYm9sXSwgc3VwcGx5ID0gX3N0YXRzJHN5bWJvbC5zdXBwbHksIG1heF9zdXBwbHkgPSBfc3RhdHMkc3ltYm9sLm1heF9zdXBwbHk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIHN1cHBseTogc3VwcGx5ID8gK3N1cHBseS5zcGxpdCgnICcpWzBdIDogMCxcbiAgICAgICAgICAgICAgbWF4X3N1cHBseTogbWF4X3N1cHBseSA/ICttYXhfc3VwcGx5LnNwbGl0KCcgJylbMF0gOiAwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ2LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgc3VwcGx5OiAwLFxuICAgICAgICAgICAgICBtYXhfc3VwcGx5OiAwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNiwgdGhpcywgW1swLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0VG9rZW5TdXBwbHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SGlzdG9yeVRyYW5zYWN0aW9uKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9nZXRIaXN0b3J5VHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEhpc3RvcnlUcmFuc2FjdGlvbigpIHtcbiAgX2dldEhpc3RvcnlUcmFuc2FjdGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh0eElkLCBibG9ja0hpbnQpIHtcbiAgICB2YXIgZW9zVHJhbnNhY3Rpb25zLCB0eDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoYmxvY2tIaW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgYmxvY2tIaW50ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW9zVHJhbnNhY3Rpb25zID0gbmV3IEpzb25ScGModGhpcy5jb25zdGFudHMuVFJBTlNBQ1RJT05TX0VORFBPSU5UUyk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBlb3NUcmFuc2FjdGlvbnMuaGlzdG9yeV9nZXRfdHJhbnNhY3Rpb24odHhJZCwgYmxvY2tIaW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHR4ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUWCBub3QgZm91bmQnKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgaGlzdG9yeVRyYW5zZm9ybVRyYW5zYWN0aW9uKHR4KSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0SGlzdG9yeVRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERlZmVycmVkVHJhbnNhY3Rpb24oX3gzKSB7XG4gIHJldHVybiBfZ2V0RGVmZXJyZWRUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RGVmZXJyZWRUcmFuc2FjdGlvbigpIHtcbiAgX2dldERlZmVycmVkVHJhbnNhY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHR4SWQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF9zLCB0cmFuc2FjdGlvbnM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF9zY2hlZHVsZWRfdHJhbnNhY3Rpb25zKHRydWUsIHR4SWQsIDEpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF9zID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3MudHJhbnNhY3Rpb25zO1xuXG4gICAgICAgICAgICBpZiAoISh0cmFuc2FjdGlvbnMubGVuZ3RoID4gMCAmJiB0cmFuc2FjdGlvbnNbMF0udHJ4X2lkLnN1YnN0cmluZygwLCA2KSA9PT0gdHhJZC5zdWJzdHJpbmcoMCwgNikpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGhpc3RvcnlUcmFuc2Zvcm1EZWZlcnJlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uc1swXSkpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge30pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RGVmZXJyZWRUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRIeXBlcmlvblRyYW5zYWN0aW9uKF94NCkge1xuICByZXR1cm4gX2dldEh5cGVyaW9uVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEh5cGVyaW9uVHJhbnNhY3Rpb24oKSB7XG4gIF9nZXRIeXBlcmlvblRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhpZCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdGFudHMuSFlQRVJJT05fVVJMKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uLmdldF90cmFuc2FjdGlvbihpZCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybEJ1aWxkZXIodGhpcy5jb25zdGFudHMuQVBJX1VSTCwgJ2h5cGVyaW9uJywge1xuICAgICAgICAgICAgICB0eXBlOiAnZ2V0X3RyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBpZiAoISghcmVzdWx0IHx8ICFyZXN1bHQuYWN0aW9ucyB8fCAhcmVzdWx0LmFjdGlvbnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUWCBub3QgZm91bmQnKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBoeXBlcmlvblRyYW5zZm9ybVRyYW5zYWN0aW9uKHJlc3VsdCkpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEh5cGVyaW9uVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVUcmFuc2FjdGlvblNldHRpbmdzKF94NSwgX3g2LCBfeDcpIHtcbiAgcmV0dXJuIF9nZW5lcmF0ZVRyYW5zYWN0aW9uU2V0dGluZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dlbmVyYXRlVHJhbnNhY3Rpb25TZXR0aW5ncygpIHtcbiAgX2dlbmVyYXRlVHJhbnNhY3Rpb25TZXR0aW5ncyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoZXhwaXJlU2Vjb25kcywgYmxvY2tzQmVoaW5kLCBkZWxheVNlYykge1xuICAgIHZhciBpbmZvLCByZWZCbG9jaywgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoZXhwaXJlU2Vjb25kcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGV4cGlyZVNlY29uZHMgPSAzMDAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmxvY2tzQmVoaW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgYmxvY2tzQmVoaW5kID0gMTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWxheVNlYyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGRlbGF5U2VjID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF9pbmZvKCk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpbmZvID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF9ibG9jayhpbmZvLmhlYWRfYmxvY2tfbnVtIC0gYmxvY2tzQmVoaW5kKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZWZCbG9jayA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gU2VyaWFsaXplLnRyYW5zYWN0aW9uSGVhZGVyKHJlZkJsb2NrLCBleHBpcmVTZWNvbmRzKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgIG1heF9uZXRfdXNhZ2Vfd29yZHM6IDAsXG4gICAgICAgICAgICAgIG1heF9jcHVfdXNhZ2VfbXM6IDAsXG4gICAgICAgICAgICAgIGRlbGF5X3NlYzogZGVsYXlTZWMsXG4gICAgICAgICAgICAgIGNvbnRleHRfZnJlZV9hY3Rpb25zOiBbXSxcbiAgICAgICAgICAgICAgYWN0aW9uczogW10sXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uX2V4dGVuc2lvbnM6IFtdXG4gICAgICAgICAgICB9LCByZXN1bHQpKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZW5lcmF0ZVRyYW5zYWN0aW9uU2V0dGluZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udHJvbGxlZEFjY291bnRzKGFjY291bnROYW1lKSB7XG4gIGlmICh0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTLmluY2x1ZGVzKCduYXRpdmUnKSkge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnNScGMuaGlzdG9yeV9nZXRfY29udHJvbGxlZF9hY2NvdW50cyhhY2NvdW50TmFtZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFUy5pbmNsdWRlcygnaHlwZXJpb24nKSkge1xuICAgIHZhciBhY3Rpb25zUnBjID0gbmV3IEpzb25ScGMoW3RoaXMuY29uc3RhbnRzLkhZUEVSSU9OX1VSTF0pO1xuICAgIHJldHVybiBhY3Rpb25zUnBjLmhpc3RvcnlfZ2V0X2NvbnRyb2xsZWRfYWNjb3VudHMoYWNjb3VudE5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGVybWlzc2lvbkxpbmtzKF94KSB7XG4gIHJldHVybiBfZ2V0UGVybWlzc2lvbkxpbmtzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQZXJtaXNzaW9uTGlua3MoKSB7XG4gIF9nZXRQZXJtaXNzaW9uTGlua3MgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYWNjb3VudCkge1xuICAgIHZhciBsaWdodEFjY291bnQsIF95aWVsZCR0aGlzJGdldCwgbGlua2VkX3Blcm1pc3Npb25zLCBfeWllbGQkdGhpcyRoeXBlcmlvbiQsIGxpbmtzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5MSUdIVF9BUEkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjY291bnRMaWdodERhdGEoYWNjb3VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBsaWdodEFjY291bnQgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIWxpZ2h0QWNjb3VudCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbGlnaHRBY2NvdW50LmxpbmthdXRoLm1hcChmdW5jdGlvbiAoYXV0aCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogYXV0aC50eXBlLFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBhdXRoLmNvZGUsXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbl9uYW1lOiBhdXRoLnJlcXVpcmVtZW50XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFUy5pbmNsdWRlcygnZGZ1c2UnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5jb25zdGFudHMuQVBJX1VSTCArIFwiL2RmdXNlP3R5cGU9c3RhdGVfcGVybWlzc2lvbl9saW5rcyZhY2NvdW50PVwiICsgYWNjb3VudCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGxpbmtlZF9wZXJtaXNzaW9ucyA9IF95aWVsZCR0aGlzJGdldC5saW5rZWRfcGVybWlzc2lvbnM7XG5cbiAgICAgICAgICAgIGlmICghbGlua2VkX3Blcm1pc3Npb25zKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbGlua2VkX3Blcm1pc3Npb25zKTtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjI7XG4gICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMTMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDEpO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFUy5pbmNsdWRlcygnaHlwZXJpb24nKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjY7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbi5nZXRfbGlua3MoYWNjb3VudCk7XG5cbiAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkaHlwZXJpb24kID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGxpbmtzID0gX3lpZWxkJHRoaXMkaHlwZXJpb24kLmxpbmtzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBsaW5rcy5tYXAoZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGxpbmsuYWN0aW9uLFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBsaW5rLmNvZGUsXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbl9uYW1lOiBsaW5rLnBlcm1pc3Npb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzQ7XG4gICAgICAgICAgICBfY29udGV4dC50MiA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMjYpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDIpO1xuXG4gICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQZXJtaXNzaW9uIGxpbmtzIG5vdCBhdmFpbGFibGUgb24gY2hhaW4nKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcywgW1sxLCA5XSwgWzEzLCAyMl0sIFsyNiwgMzRdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQZXJtaXNzaW9uTGlua3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZGZ1c2VHZXRLZXlBY2NvdW50cyhfeDIpIHtcbiAgcmV0dXJuIF9kZnVzZUdldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9kZnVzZUdldEtleUFjY291bnRzKCkge1xuICBfZGZ1c2VHZXRLZXlBY2NvdW50cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoa2V5KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJGdldDIsIGFjY291bnRfbmFtZXM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuY29uc3RhbnRzLkFQSV9VUkwgKyBcIi9kZnVzZT90eXBlPXN0YXRlX2tleV9hY2NvdW50cyZwdWJsaWNLZXk9XCIgKyBrZXkpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0MiA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgYWNjb3VudF9uYW1lcyA9IF95aWVsZCR0aGlzJGdldDIuYWNjb3VudF9uYW1lcztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGFjY291bnRfbmFtZXMgJiYgYWNjb3VudF9uYW1lcy5sZW5ndGggPyBhY2NvdW50X25hbWVzIDogW10pO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDIudDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIGRmdXNlIGFjY291bnRzIGZvdW5kIGFzc29jaWF0ZWQgd2l0aCBrZXk6Jywga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZGZ1c2VHZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBuYXRpdmVHZXRLZXlBY2NvdW50cyhfeDMpIHtcbiAgcmV0dXJuIF9uYXRpdmVHZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbmF0aXZlR2V0S2V5QWNjb3VudHMoKSB7XG4gIF9uYXRpdmVHZXRLZXlBY2NvdW50cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoa2V5KSB7XG4gICAgdmFyIGtleUFjY291bnRzLCBmaW9BY2NvdW50LCBfeWllbGQkdGhpcyRycGMkZ2V0X2EsIGFjY291bnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcbiAgICAgICAgICAgIGtleUFjY291bnRzID0gW107XG5cbiAgICAgICAgICAgIGlmICghWydmaW8nLCAnZmlvLXRlc3QnXS5pbmNsdWRlcyh0aGlzLmNvbnN0YW50cy5DSEFJTikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlvQWNjb3VudCA9IGZpb0tleVRvQWN0b3Ioa2V5LnJlcGxhY2UoJ0VPUycsICdGSU8nKSwgTnVtZXJpYy5zdHJpbmdUb1B1YmxpY0tleSk7XG5cbiAgICAgICAgICAgIGlmIChrZXlBY2NvdW50cy5pbmRleE9mKGZpb0FjY291bnQpID09PSAtMSkge1xuICAgICAgICAgICAgICBrZXlBY2NvdW50cy5wdXNoKGZpb0FjY291bnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X2FjY291bnRzX2J5X2F1dGhvcml6ZXJzKFtdLCBba2V5XSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X2EgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIGFjY291bnRzID0gX3lpZWxkJHRoaXMkcnBjJGdldF9hLmFjY291bnRzO1xuICAgICAgICAgICAga2V5QWNjb3VudHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoYWNjb3VudHMubWFwKGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY2NvdW50LmFjY291bnRfbmFtZTtcbiAgICAgICAgICAgIH0pKSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwga2V5QWNjb3VudHMpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTU7XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0My50MCk7XG4gICAgICAgICAgICB0aHJvdyBfY29udGV4dDMudDA7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMCwgMTVdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9uYXRpdmVHZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBoeXBlcmlvbkdldEtleUFjY291bnRzKF94NCkge1xuICByZXR1cm4gX2h5cGVyaW9uR2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2h5cGVyaW9uR2V0S2V5QWNjb3VudHMoKSB7XG4gIF9oeXBlcmlvbkdldEtleUFjY291bnRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChrZXkpIHtcbiAgICB2YXIgbGVnYWN5UHVibGljS2V5LCBfeWllbGQkdGhpcyRoeXBlcmlvbiQyLCBhY2NvdW50X25hbWVzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICh0aGlzLmh5cGVyaW9uKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSHlwZXJpb24gQVBJIG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxlZ2FjeVB1YmxpY0tleSA9IEtleS5QdWJsaWNLZXkuZnJvbVN0cmluZyhrZXkpLnRvTGVnYWN5U3RyaW5nKCk7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbi5nZXRfa2V5X2FjY291bnRzKGxlZ2FjeVB1YmxpY0tleSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRoeXBlcmlvbiQyID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICBhY2NvdW50X25hbWVzID0gX3lpZWxkJHRoaXMkaHlwZXJpb24kMi5hY2NvdW50X25hbWVzO1xuXG4gICAgICAgICAgICBpZiAoIShhY2NvdW50X25hbWVzICYmIGFjY291bnRfbmFtZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgYWNjb3VudF9uYW1lcyk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBrZXlzIGZvdW5kJyk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfaHlwZXJpb25HZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBsaWdodEdldEtleUFjY291bnRzKF94NSkge1xuICByZXR1cm4gX2xpZ2h0R2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xpZ2h0R2V0S2V5QWNjb3VudHMoKSB7XG4gIF9saWdodEdldEtleUFjY291bnRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShrZXkpIHtcbiAgICB2YXIgbGlnaHRDaGFpbiwgYWNjb3VudHNCeUNoYWluLCBhY2NvdW50cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHRoaXMubGlnaHRBcGkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaWdodCBBUEkgbm90IHN1cHBvcnRlZCcpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGlnaHRDaGFpbiA9IHRoaXMuY29uc3RhbnRzLkNIQUlOLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpZ2h0QXBpLmdldF9rZXlfYWNjb3VudHMoa2V5KTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGFjY291bnRzQnlDaGFpbiA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgYWNjb3VudHMgPSBhY2NvdW50c0J5Q2hhaW5bbGlnaHRDaGFpbl0uYWNjb3VudHM7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBBcnJheS5mcm9tKG5ldyBTZXQoT2JqZWN0LmtleXMoYWNjb3VudHMpKSkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfbGlnaHRHZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlBY2NvdW50c0J5VHlwZShfeDYsIF94Nykge1xuICByZXR1cm4gX2dldEtleUFjY291bnRzQnlUeXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcclxuICogVHJpZXMgYWxsIGhpc3RvcmllcyB0byBnZXQga2V5cy5cclxuICogQHBhcmFtIHsqfSBrZXlcclxuICovXG5cbmZ1bmN0aW9uIF9nZXRLZXlBY2NvdW50c0J5VHlwZSgpIHtcbiAgX2dldEtleUFjY291bnRzQnlUeXBlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gdHlwZTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gX2NvbnRleHQ2LnQwID09PSAnZGZ1c2UnID8gMyA6IF9jb250ZXh0Ni50MCA9PT0gJ25hdGl2ZScgPyA2IDogX2NvbnRleHQ2LnQwID09PSAnaHlwZXJpb24nID8gOSA6IF9jb250ZXh0Ni50MCA9PT0gJ2xpZ2h0JyA/IDEyIDogMTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRmdXNlR2V0S2V5QWNjb3VudHMoa2V5KTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ni5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gODtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZUdldEtleUFjY291bnRzKGtleSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDYuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb25HZXRLZXlBY2NvdW50cyhrZXkpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ni5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlnaHRHZXRLZXlBY2NvdW50cyhrZXkpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ni5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRLZXlBY2NvdW50c0J5VHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlBY2NvdW50cyhfeDgpIHtcbiAgcmV0dXJuIF9nZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0S2V5QWNjb3VudHMoKSB7XG4gIF9nZXRLZXlBY2NvdW50cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoa2V5KSB7XG4gICAgdmFyIF9pLCBfYXJyLCBoaXN0b3J5VHlwZSwgcmVzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnRklPJykpIHtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LnJlcGxhY2UoJ0ZJTycsICdFT1MnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2kgPSAwLCBfYXJyID0gW3RoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVNbMF0sICdsaWdodCddLmNvbmNhdCh0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTLnNsaWNlKDEpKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICghKF9pIDwgX2Fyci5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoaXN0b3J5VHlwZSA9IF9hcnJbX2ldO1xuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSA0O1xuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5QWNjb3VudHNCeVR5cGUoa2V5LCBoaXN0b3J5VHlwZSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXMgPSBfY29udGV4dDcuc2VudDtcblxuICAgICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTI7XG4gICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Ny50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcImNvbnRpbnVlXCIsIDE2KTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU3LCB0aGlzLCBbWzQsIDEyXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5QWNjb3VudHNGb3JBbGxDaGFpbnMoX3g5KSB7XG4gIHJldHVybiBfZ2V0S2V5QWNjb3VudHNGb3JBbGxDaGFpbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8qKlxyXG4gKiBSZWN1cnNpdmVseSByZXNvbHZlcyBhbGwgcmVxdWlyZWQgcGVybWlzc2lvbnNcclxuICogQHBhcmFtIGFjY291bnROYW1lXHJcbiAqIEBwYXJhbSBwZXJtaXNzaW9uXHJcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0S2V5QWNjb3VudHNGb3JBbGxDaGFpbnMoKSB7XG4gIF9nZXRLZXlBY2NvdW50c0ZvckFsbENoYWlucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgoa2V5KSB7XG4gICAgdmFyIGtleUFjY291bnRzLCBjb21iaW5lZDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHRoaXMubGlnaHRBcGkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaWdodCBBUEkgbm90IHN1cHBvcnRlZCcpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAyO1xuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlnaHRBcGkuZ2V0X2FsbF9rZXlfYWNjb3VudHMoa2V5KTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGtleUFjY291bnRzID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICBjb21iaW5lZCA9IGtleUFjY291bnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBvYmopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBhY2MsIG9iaik7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBPYmplY3QuZW50cmllcyhjb21iaW5lZCkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWYpIHtcbiAgICAgICAgICAgICAgdmFyIGNoYWluID0gX3JlZlswXSxcbiAgICAgICAgICAgICAgICAgIGFjY291bnRzQnlOYW1lID0gX3JlZlsxXS5hY2NvdW50cztcbiAgICAgICAgICAgICAgdmFyIGFjY291bnRzID0gT2JqZWN0LmtleXMoYWNjb3VudHNCeU5hbWUpO1xuXG4gICAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaCh7XG4gICAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCBbXSkpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMTA7XG4gICAgICAgICAgICBfY29udGV4dDgudDAgPSBfY29udGV4dDhbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0OC50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTgsIHRoaXMsIFtbMiwgMTBdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRLZXlBY2NvdW50c0ZvckFsbENoYWlucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXF1aXJlZEFjY291bnRzKF94MTAsIF94MTEsIF94MTIsIF94MTMsIF94MTQpIHtcbiAgcmV0dXJuIF9nZXRSZXF1aXJlZEFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlZEFjY291bnRzKCkge1xuICBfZ2V0UmVxdWlyZWRBY2NvdW50cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoYWNjb3VudE5hbWUsIHBlcm1pc3Npb25OYW1lLCBhbGxQZXJtaXNzaW9ucywgY3VycmVudExldmVsLCBtYXhMZXZlbCkge1xuICAgIHZhciBhY2NvdW50SW5mbywgX2l0ZXJhdG9yLCBfc3RlcCwgcGVybWlzc2lvbiwgYWNjb3VudHMsIHByb2R1Y2VycywgX2l0ZXJhdG9yMiwgX3N0ZXAyLCBhY2NvdW50O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChhbGxQZXJtaXNzaW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGFsbFBlcm1pc3Npb25zID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF4TGV2ZWwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBtYXhMZXZlbCA9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjY291bnQoYWNjb3VudE5hbWUpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgYWNjb3VudEluZm8gPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWNjb3VudEluZm8ucGVybWlzc2lvbnMpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWYgKChfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMzE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwZXJtaXNzaW9uID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICghKHBlcm1pc3Npb24ucGVybV9uYW1lID09PSBwZXJtaXNzaW9uTmFtZSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBhbGwgYWNjb3VudCAoZS5nLiBneXksIGhhcnRvbm8sIHRob21wc29uKVxuICAgICAgICAgICAgYWNjb3VudHMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCEoYWNjb3VudE5hbWUgPT09ICdlb3NpbycgJiYgWydvd25lcicsICdhY3RpdmUnXS5pbmNsdWRlcyhwZXJtaXNzaW9uLnBlcm1fbmFtZSkpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDE0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvZHVjZXJzTG9jYWwoKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBwcm9kdWNlcnMgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgIGFjY291bnRzID0gcHJvZHVjZXJzLm1hcChmdW5jdGlvbiAocHJvZHVjZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3RvcjogcHJvZHVjZXIub3duZXIsXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbjogJ2FjdGl2ZSdcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGlmICghYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFjY291bnRzID0gcGVybWlzc2lvbi5yZXF1aXJlZF9hdXRoLmFjY291bnRzLm1hcChmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2NvdW50LnBlcm1pc3Npb247XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBhbGxQZXJtaXNzaW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBhY3RvcjogYWNjb3VudE5hbWUsXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbjogcGVybWlzc2lvbk5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IC8vIEZvciBlYWNoIGFjY291bnQgKGUuZy4gaGFydG9ubylcblxuXG4gICAgICAgICAgICBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY2NvdW50cyk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgaWYgKChfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFjY291bnQgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICghKGN1cnJlbnRMZXZlbCA8IG1heExldmVsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDI2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlcXVpcmVkQWNjb3VudHMoYWNjb3VudC5hY3RvciwgYWNjb3VudC5wZXJtaXNzaW9uLCBhbGxQZXJtaXNzaW9ucywgKytjdXJyZW50TGV2ZWwsIG1heExldmVsKTtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDI3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgYWxsUGVybWlzc2lvbnMucHVzaCh7XG4gICAgICAgICAgICAgIGFjdG9yOiBhY2NvdW50LmFjdG9yLFxuICAgICAgICAgICAgICBwZXJtaXNzaW9uOiBhY2NvdW50LnBlcm1pc3Npb25cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCBhbGxQZXJtaXNzaW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmVxdWlyZWRBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRVc2Vyc0Zyb21LZXlzKF94MTUpIHtcbiAgcmV0dXJuIF9nZXRVc2Vyc0Zyb21LZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRVc2Vyc0Zyb21LZXlzKCkge1xuICBfZ2V0VXNlcnNGcm9tS2V5cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKGtleXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHVzZXJzLCBwcm9taXNlcztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEyJChfY29udGV4dDEyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVzZXJzID0gW107XG4gICAgICAgICAgICBwcm9taXNlcyA9IGtleXMubWFwKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMShrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWNjb3VudF9uYW1lcywgcHJvbWlzZXMyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRLZXlBY2NvdW50cyhrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudF9uYW1lcyA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzMiA9IGFjY291bnRfbmFtZXMubWFwKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMChhY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjY291bnRJbmZvLCBfaXRlcmF0b3IzLCBfc3RlcDMsIHBlcm1pc3Npb247XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0QWNjb3VudChhY2NvdW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRJbmZvID0gX2NvbnRleHQxMC5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXZlcnkgcGVybWlzc2lvbiwgYWRkIHRvIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjY291bnRJbmZvLnBlcm1pc3Npb25zKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb24gPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYga2V5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVybWlzc2lvbi5yZXF1aXJlZF9hdXRoLmtleXMuZmluZChmdW5jdGlvbiAocGVybUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwZXJtS2V5LmtleSA9PT0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3I6IGFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uOiBwZXJtaXNzaW9uLnBlcm1fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY0tleToga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDE3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlczIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUxMSk7XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCB1c2Vycyk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTEyKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFVzZXJzRnJvbUtleXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIEFwaUNsYXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXBpQ2xhc3MoY2hhaW4pIHtcbiAgICB0aGlzLnJwYyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFjdGlvbnNScGMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hcGkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oeXBlcmlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpZ2h0QXBpID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuY29uc3RhbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaHR0cCA9IGh0dHA7XG4gICAgdGhpcy5nZXQgPSBnZXQ7XG4gICAgdGhpcy5wb3N0ID0gcG9zdDtcbiAgICB0aGlzLmdldEFjY291bnQgPSBnZXRBY2NvdW50O1xuICAgIHRoaXMuZ2V0R3JhdmF0YXIgPSBnZXRHcmF2YXRhcjtcbiAgICB0aGlzLnNlYXJjaEFjY291bnQgPSBzZWFyY2hBY2NvdW50O1xuICAgIHRoaXMuZ2V0UGFyZW50ID0gZ2V0UGFyZW50O1xuICAgIHRoaXMuZ2V0QWNjb3VudExpZ2h0RGF0YSA9IGdldEFjY291bnRMaWdodERhdGE7XG4gICAgdGhpcy5nZXRBY3Rpb25zRnJvbU5hdGl2ZSA9IGdldEFjdGlvbnNGcm9tTmF0aXZlO1xuICAgIHRoaXMuZ2V0QWN0aW9ucyA9IGdldEFjdGlvbnM7XG4gICAgdGhpcy5nZXRBY3Rpb25zRnJvbURmdXNlID0gZ2V0QWN0aW9uc0Zyb21EZnVzZTtcbiAgICB0aGlzLmdldEFjdGlvbnNGcm9tSHlwZXJpb24gPSBnZXRBY3Rpb25zRnJvbUh5cGVyaW9uO1xuICAgIHRoaXMuZ2V0RGFwcFN0YXRzID0gZ2V0RGFwcFN0YXRzO1xuICAgIHRoaXMuZ2V0RHNwUGFja2FnZXMgPSBnZXREc3BQYWNrYWdlcztcbiAgICB0aGlzLmdldERhcHBob2RsQmFsYW5jZSA9IGdldERhcHBob2RsQmFsYW5jZTtcbiAgICB0aGlzLmdldERhcHBCYWxhbmNlID0gZ2V0RGFwcEJhbGFuY2U7XG4gICAgdGhpcy5nZXREYXBwU3Rha2VzID0gZ2V0RGFwcFN0YWtlcztcbiAgICB0aGlzLmdldERhcHBob2RsU3Rha2VzID0gZ2V0RGFwcGhvZGxTdGFrZXM7XG4gICAgdGhpcy5nZXREYXBwVW5zdGFrZXMgPSBnZXREYXBwVW5zdGFrZXM7XG4gICAgdGhpcy5nZXREYXBwaG9kbFVuc3Rha2VzID0gZ2V0RGFwcGhvZGxVbnN0YWtlcztcbiAgICB0aGlzLmdldEZJT1ZvdGVyID0gZ2V0RklPVm90ZXI7XG4gICAgdGhpcy5nZXRGSU9BZGRyZXNzQnlOYW1lID0gZ2V0RklPQWRkcmVzc0J5TmFtZTtcbiAgICB0aGlzLmdldEZJT0RvbWFpbkJ5TmFtZSA9IGdldEZJT0RvbWFpbkJ5TmFtZTtcbiAgICB0aGlzLmdldE5GVHNCeUZpb0FkZHJlc3MgPSBnZXRORlRzQnlGaW9BZGRyZXNzO1xuICAgIHRoaXMuZ2V0RG9tYWlucyA9IGdldERvbWFpbnM7XG4gICAgdGhpcy5nZXRBZGRyZXNzZXMgPSBnZXRBZGRyZXNzZXM7XG4gICAgdGhpcy5nZXRGSU9Qcm9kdWNlcnMgPSBnZXRGSU9Qcm9kdWNlcnM7XG4gICAgdGhpcy5nZXRGSU9TdXBwbHlCcmVha2Rvd24gPSBnZXRGSU9TdXBwbHlCcmVha2Rvd247XG4gICAgdGhpcy5nZXRGSU9GZWVzID0gZ2V0RklPRmVlcztcbiAgICB0aGlzLmFkZEZJT0ZlZVRvQWN0aW9ucyA9IGFkZEZJT0ZlZVRvQWN0aW9ucztcbiAgICB0aGlzLmdldEZJT0FkZHJlc3NlcyA9IGdldEZJT0FkZHJlc3NlcztcbiAgICB0aGlzLmdldEZJT0RvbWFpbnMgPSBnZXRGSU9Eb21haW5zO1xuICAgIHRoaXMuZ2V0RklPQWRkcmVzc2VzQW5kRG9tYWlucyA9IGdldEZJT0FkZHJlc3Nlc0FuZERvbWFpbnM7XG4gICAgdGhpcy5nZXRGSU9CYWxhbmNlID0gZ2V0RklPQmFsYW5jZTtcbiAgICB0aGlzLmdldENvbnRyb2xsZWRBY2NvdW50cyA9IGdldENvbnRyb2xsZWRBY2NvdW50cztcbiAgICB0aGlzLmdldFBlcm1pc3Npb25MaW5rcyA9IGdldFBlcm1pc3Npb25MaW5rcztcbiAgICB0aGlzLmRmdXNlR2V0S2V5QWNjb3VudHMgPSBkZnVzZUdldEtleUFjY291bnRzO1xuICAgIHRoaXMubmF0aXZlR2V0S2V5QWNjb3VudHMgPSBuYXRpdmVHZXRLZXlBY2NvdW50cztcbiAgICB0aGlzLmh5cGVyaW9uR2V0S2V5QWNjb3VudHMgPSBoeXBlcmlvbkdldEtleUFjY291bnRzO1xuICAgIHRoaXMubGlnaHRHZXRLZXlBY2NvdW50cyA9IGxpZ2h0R2V0S2V5QWNjb3VudHM7XG4gICAgdGhpcy5nZXRLZXlBY2NvdW50c0J5VHlwZSA9IGdldEtleUFjY291bnRzQnlUeXBlO1xuICAgIHRoaXMuZ2V0S2V5QWNjb3VudHMgPSBnZXRLZXlBY2NvdW50cztcbiAgICB0aGlzLmdldEtleUFjY291bnRzRm9yQWxsQ2hhaW5zID0gZ2V0S2V5QWNjb3VudHNGb3JBbGxDaGFpbnM7XG4gICAgdGhpcy5nZXRSZXF1aXJlZEFjY291bnRzID0gZ2V0UmVxdWlyZWRBY2NvdW50cztcbiAgICB0aGlzLmdldFVzZXJzRnJvbUtleXMgPSBnZXRVc2Vyc0Zyb21LZXlzO1xuICAgIHRoaXMuZ2V0QWxsTXNpZ3MgPSBnZXRBbGxNc2lncztcbiAgICB0aGlzLnBhcnNlUGFja2VkTXNpZ0FjdGlvbnMgPSBwYXJzZVBhY2tlZE1zaWdBY3Rpb25zO1xuICAgIHRoaXMucGFyc2VQYWNrZWRNc2lnID0gcGFyc2VQYWNrZWRNc2lnO1xuICAgIHRoaXMuZ2V0RnVsbE1zaWdQcm9wb3NhbCA9IGdldEZ1bGxNc2lnUHJvcG9zYWw7XG4gICAgdGhpcy5nZXRNc2lnQXBwcm92YWxzID0gZ2V0TXNpZ0FwcHJvdmFscztcbiAgICB0aGlzLmdldEFjY291bnRzTXNpZ1Byb3Bvc2FscyA9IGdldEFjY291bnRzTXNpZ1Byb3Bvc2FscztcbiAgICB0aGlzLmh5cGVyaW9uR2V0TXNpZyA9IGh5cGVyaW9uR2V0TXNpZztcbiAgICB0aGlzLmdldE1zaWdQcm9wb3NhbCA9IGdldE1zaWdQcm9wb3NhbDtcbiAgICB0aGlzLmdldFJlbnRid1N0YXRlID0gZ2V0UmVudGJ3U3RhdGU7XG4gICAgdGhpcy5kZWxlZ2F0ZWRCYW5kd2lkdGggPSBkZWxlZ2F0ZWRCYW5kd2lkdGg7XG4gICAgdGhpcy5nZXRBY2NvdW50RGVsZWdhdGVkQmFuZHdpZHRoID0gZ2V0QWNjb3VudERlbGVnYXRlZEJhbmR3aWR0aDtcbiAgICB0aGlzLmdldEFjY291bnRSZXNvdXJjZXMgPSBnZXRBY2NvdW50UmVzb3VyY2VzO1xuICAgIHRoaXMuZ2V0UmFtUHJpY2VJbkVvcyA9IGdldFJhbVByaWNlSW5Fb3M7XG4gICAgdGhpcy5nZXRSZXhRdWV1ZWQgPSBnZXRSZXhRdWV1ZWQ7XG4gICAgdGhpcy5nZXRSZXhQb29sID0gZ2V0UmV4UG9vbDtcbiAgICB0aGlzLmdldFJleEJhbGFuY2UgPSBnZXRSZXhCYWxhbmNlO1xuICAgIHRoaXMuZ2V0UmV4Q3B1TG9hbnMgPSBnZXRSZXhDcHVMb2FucztcbiAgICB0aGlzLmdldFJleE5ldExvYW5zID0gZ2V0UmV4TmV0TG9hbnM7XG4gICAgdGhpcy5nZXRFb3NEZXBvc2l0ZWRJbnRvUmV4ID0gZ2V0RW9zRGVwb3NpdGVkSW50b1JleDtcbiAgICB0aGlzLmdldFJleFJldHVyblJhdGUgPSBnZXRSZXhSZXR1cm5SYXRlO1xuICAgIHRoaXMuZ2V0UmV4UHJpY2VDaGFydCA9IGdldFJleFByaWNlQ2hhcnQ7XG4gICAgdGhpcy5nZXRFb3NUb3BTdGFrZXMgPSBnZXRFb3NUb3BTdGFrZXM7XG4gICAgdGhpcy5nZXRFb3NUb3BSYW1zID0gZ2V0RW9zVG9wUmFtcztcbiAgICB0aGlzLmdldEN1cnJlbnROYW1lQmlkcyA9IGdldEN1cnJlbnROYW1lQmlkcztcbiAgICB0aGlzLmdldEVvc0JhbGFuY2UgPSBnZXRFb3NCYWxhbmNlO1xuICAgIHRoaXMuZ2V0VG9rZW5CYWxhbmNlID0gZ2V0VG9rZW5CYWxhbmNlO1xuICAgIHRoaXMuaHlwZXJpb25HZXRUb2tlbnNGb3JBY2NvdW50ID0gaHlwZXJpb25HZXRUb2tlbnNGb3JBY2NvdW50O1xuICAgIHRoaXMuZ2V0VG9rZW5TdXBwbHkgPSBnZXRUb2tlblN1cHBseTtcbiAgICB0aGlzLmxpZ2h0R2V0VG9rZW5zID0gbGlnaHRHZXRUb2tlbnM7XG4gICAgdGhpcy5nZXRBY2NvdW50VG9rZW5zID0gZ2V0QWNjb3VudFRva2VucztcbiAgICB0aGlzLmdldEhpc3RvcnlUcmFuc2FjdGlvbiA9IGdldEhpc3RvcnlUcmFuc2FjdGlvbjtcbiAgICB0aGlzLmdldERlZmVycmVkVHJhbnNhY3Rpb24gPSBnZXREZWZlcnJlZFRyYW5zYWN0aW9uO1xuICAgIHRoaXMuZ2V0SHlwZXJpb25UcmFuc2FjdGlvbiA9IGdldEh5cGVyaW9uVHJhbnNhY3Rpb247XG4gICAgdGhpcy5nZW5lcmF0ZVRyYW5zYWN0aW9uU2V0dGluZ3MgPSBnZW5lcmF0ZVRyYW5zYWN0aW9uU2V0dGluZ3M7XG4gICAgdGhpcy5nZXRQcm94aWVzID0gZ2V0UHJveGllcztcbiAgICB0aGlzLmdldFZvdGVycyA9IGdldFZvdGVycztcbiAgICB0aGlzLmNhbGN1bGF0ZVZvdGVXZWlnaHQgPSBjYWxjdWxhdGVWb3RlV2VpZ2h0O1xuICAgIHRoaXMud2VpZ2h0ZWRWb3RlVG9OdW1iZXIgPSB3ZWlnaHRlZFZvdGVUb051bWJlcjtcbiAgICB0aGlzLmdldFByb3h5RGF0YSA9IGdldFByb3h5RGF0YTtcbiAgICB0aGlzLmdldFZvdGVyID0gZ2V0Vm90ZXI7XG4gICAgdGhpcy5nZXRQcm9kdWNlcnMgPSBnZXRQcm9kdWNlcnM7XG4gICAgdGhpcy5nZXRQcm9kdWNlcnNMb2NhbCA9IGdldFByb2R1Y2Vyc0xvY2FsO1xuICAgIHRoaXMuZ2V0Q2hhaW5UYWJsZSA9IGdldENoYWluVGFibGU7XG4gICAgdGhpcy5mZXRjaEt5Y0NvdW50cmllcyA9IGZldGNoS3ljQ291bnRyaWVzO1xuICAgIHRoaXMuY2hlY2tVc2VyS3ljU3RhdHVzID0gY2hlY2tVc2VyS3ljU3RhdHVzO1xuICAgIHRoaXMuYXBwbHlGb3JLeWMgPSBhcHBseUZvckt5YztcbiAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcbiAgICB0aGlzLmdldEF2YWlsYWJsZUZlYXR1cmVzID0gZ2V0QXZhaWxhYmxlRmVhdHVyZXM7XG4gICAgdGhpcy5vdGNRdW90ZSA9IG90Y1F1b3RlO1xuICAgIHRoaXMub3RjT3JkZXIgPSBvdGNPcmRlcjtcbiAgICB0aGlzLmdlbmVyYXRlQWRkcmVzcyA9IGdlbmVyYXRlQWRkcmVzcztcbiAgICB0aGlzLmRlbGV0ZUFkZHJlc3MgPSBkZWxldGVBZGRyZXNzO1xuICAgIHRoaXMud2l0aGRyYXdNZXRhbCA9IHdpdGhkcmF3TWV0YWw7XG4gICAgdGhpcy53aXRoZHJhd2FsSGlzdG9yeU1ldGFsID0gd2l0aGRyYXdhbEhpc3RvcnlNZXRhbDtcbiAgICB0aGlzLmdldFRva2VuUHJpY2VzID0gZ2V0VG9rZW5QcmljZXM7XG4gICAgdGhpcy5nZXRXaXRoZHJhd2FsRmVlID0gZ2V0V2l0aGRyYXdhbEZlZTtcbiAgICB0aGlzLmdldENoYWluSW5mbyA9IGdldENoYWluSW5mbztcbiAgICB0aGlzLmNyZWF0ZUFjY291bnQgPSBjcmVhdGVBY2NvdW50O1xuICAgIHRoaXMubG9naW5BY2NvdW50ID0gbG9naW5BY2NvdW50O1xuICAgIHRoaXMuZ2V0WHByVG90YWxTdGFrZWRBbmRBcHIgPSBnZXRYcHJUb3RhbFN0YWtlZEFuZEFwcjtcbiAgICB0aGlzLmdldFhwclZvdGVyID0gZ2V0WHByVm90ZXI7XG4gICAgdGhpcy5nZXRYcHJBY2NvdW50U3Rha2VzID0gZ2V0WHByQWNjb3VudFN0YWtlcztcbiAgICB0aGlzLmdldFhwckFjY291bnRSZWZ1bmQgPSBnZXRYcHJBY2NvdW50UmVmdW5kO1xuICAgIHRoaXMuZ2V0WHByT3JhY2xlRGF0YSA9IGdldFhwck9yYWNsZURhdGE7XG4gICAgdGhpcy5nZXRBbGxPcmFjbGVGZWVkcyA9IGdldEFsbE9yYWNsZUZlZWRzO1xuICAgIHRoaXMuZ2V0QWxsT3JhY2xlRGF0YSA9IGdldEFsbE9yYWNsZURhdGE7XG4gICAgdGhpcy5nZXRTcGVjaWZpY09yYWNsZURhdGEgPSBnZXRTcGVjaWZpY09yYWNsZURhdGE7XG4gICAgdGhpcy5nZXRQcm90b25BdmF0YXIgPSBnZXRQcm90b25BdmF0YXI7XG4gICAgdGhpcy5nZXRQcm90b25BdmF0YXJzID0gZ2V0UHJvdG9uQXZhdGFycztcblxuICAgIGlmIChjaGFpbikge1xuICAgICAgY29uc3RhbnRzLmluaXRpYWxpemUoY2hhaW4pO1xuICAgICAgdGhpcy5pbml0aWFsaXplKGNvbnN0YW50cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IEFwaUNsYXNzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIGluaXRpYWxpemUoY29uc3RhbnRzLCBfdGVtcCkge1xuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIHJwY0VuZHBvaW50cyA9IF9yZWYucnBjRW5kcG9pbnRzLFxuICAgICAgICBhY3Rpb25zUnBjRW5kcG9pbnRzID0gX3JlZi5hY3Rpb25zUnBjRW5kcG9pbnRzLFxuICAgICAgICBsaWdodEVuZHBvaW50ID0gX3JlZi5saWdodEVuZHBvaW50LFxuICAgICAgICBoeXBlcmlvbkVuZHBvaW50ID0gX3JlZi5oeXBlcmlvbkVuZHBvaW50O1xuXG4gICAgdGhpcy5jb25zdGFudHMgPSBjb25zdGFudHM7XG4gICAgdGhpcy5ycGMgPSBuZXcgSnNvblJwYyhycGNFbmRwb2ludHMgfHwgdGhpcy5jb25zdGFudHMuREVGQVVMVF9FTkRQT0lOVFMpO1xuICAgIHRoaXMuYWN0aW9uc1JwYyA9IG5ldyBKc29uUnBjKGFjdGlvbnNScGNFbmRwb2ludHMgfHwgdGhpcy5jb25zdGFudHMuQUNUSU9OU19FTkRQT0lOVFMpO1xuICAgIHRoaXMuYXBpID0gbmV3IEFwaSh7XG4gICAgICBycGM6IHRoaXMucnBjXG4gICAgfSk7XG4gICAgdmFyIGxpZ2h0VXJsID0gbGlnaHRFbmRwb2ludCB8fCB0aGlzLmNvbnN0YW50cy5MSUdIVF9BUEk7XG5cbiAgICBpZiAobGlnaHRVcmwpIHtcbiAgICAgIHRoaXMubGlnaHRBcGkgPSBuZXcgSnNvblJwYyQxKHRoaXMuY29uc3RhbnRzLkNIQUlOLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnLScsICcnKSwge1xuICAgICAgICBlbmRwb2ludDogbGlnaHRVcmxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBoeXBlcmlvblVybCA9IGh5cGVyaW9uRW5kcG9pbnQgfHwgdGhpcy5jb25zdGFudHMuSFlQRVJJT05fVVJMO1xuXG4gICAgaWYgKGh5cGVyaW9uVXJsKSB7XG4gICAgICB0aGlzLmh5cGVyaW9uID0gbmV3IEpzb25ScGMkMihoeXBlcmlvblVybCk7XG4gICAgfVxuXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gQXBpQ2xhc3M7XG59KCk7XG5cbmV4cG9ydCB7IEFwaUNsYXNzLCBLeWNTdGF0dXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5lc20uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gVHlwZVNjcmlwdCBEZWZpbml0aW9uc1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy90eXBlcy9hY3Rpb25fdHJhY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy90eXBlcy9hcGlcIiksIGV4cG9ydHMpO1xuLy8gSHlwZXJpb24gQVBJXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL2pzb25ycGNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9lbmRwb2ludHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9ycGNlcnJvclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVjJfR0VUX1RSQU5TRkVSUyA9IGV4cG9ydHMuVjJfR0VUX1RSQU5TQUNUSU9OID0gZXhwb3J0cy5WMl9HRVRfVFJBTlNBQ1RFRF9BQ0NPVU5UUyA9IGV4cG9ydHMuVjJfR0VUX0RFTFRBUyA9IGV4cG9ydHMuVjJfR0VUX0NSRUFUT1IgPSBleHBvcnRzLlYyX0dFVF9DUkVBVEVEX0FDQ09VTlRTID0gZXhwb3J0cy5WMl9HRVRfQUNUSU9OUyA9IGV4cG9ydHMuVjJfR0VUX0FCSV9TTkFQU0hPVCA9IGV4cG9ydHMuVjJfR0VUX1BST1BPU0FMUyA9IGV4cG9ydHMuVjJfR0VUX0xJTktTID0gZXhwb3J0cy5WMl9HRVRfVk9URVJTID0gZXhwb3J0cy5WMl9HRVRfVE9LRU5TID0gZXhwb3J0cy5WMl9HRVRfS0VZX0FDQ09VTlRTID0gZXhwb3J0cy5WMl9BTElWRSA9IHZvaWQgMDtcbi8vIFN0YXRlXG5leHBvcnRzLlYyX0FMSVZFID0gXCIvdjIvc3RhdGUvYWxpdmVcIjtcbmV4cG9ydHMuVjJfR0VUX0tFWV9BQ0NPVU5UUyA9IFwiL3YyL3N0YXRlL2dldF9rZXlfYWNjb3VudHNcIjtcbmV4cG9ydHMuVjJfR0VUX1RPS0VOUyA9IFwiL3YyL3N0YXRlL2dldF90b2tlbnNcIjtcbmV4cG9ydHMuVjJfR0VUX1ZPVEVSUyA9IFwiL3YyL3N0YXRlL2dldF92b3RlcnNcIjtcbmV4cG9ydHMuVjJfR0VUX0xJTktTID0gXCIvdjIvc3RhdGUvZ2V0X2xpbmtzXCI7XG5leHBvcnRzLlYyX0dFVF9QUk9QT1NBTFMgPSBcIi92Mi9zdGF0ZS9nZXRfcHJvcG9zYWxzXCI7XG4vLyBIaXN0b3J5XG5leHBvcnRzLlYyX0dFVF9BQklfU05BUFNIT1QgPSBcIi92Mi9oaXN0b3J5L2dldF9hYmlfc25hcHNob3RcIjtcbmV4cG9ydHMuVjJfR0VUX0FDVElPTlMgPSBcIi92Mi9oaXN0b3J5L2dldF9hY3Rpb25zXCI7XG5leHBvcnRzLlYyX0dFVF9DUkVBVEVEX0FDQ09VTlRTID0gXCIvdjIvaGlzdG9yeS9nZXRfY3JlYXRlZF9hY2NvdW50c1wiO1xuZXhwb3J0cy5WMl9HRVRfQ1JFQVRPUiA9IFwiL3YyL2hpc3RvcnkvZ2V0X2NyZWF0b3JcIjtcbmV4cG9ydHMuVjJfR0VUX0RFTFRBUyA9IFwiL3YyL2hpc3RvcnkvZ2V0X2RlbHRhc1wiO1xuZXhwb3J0cy5WMl9HRVRfVFJBTlNBQ1RFRF9BQ0NPVU5UUyA9IFwiL3YyL2hpc3RvcnkvZ2V0X3RyYW5zYWN0ZWRfYWNjb3VudHNcIjtcbmV4cG9ydHMuVjJfR0VUX1RSQU5TQUNUSU9OID0gXCIvdjIvaGlzdG9yeS9nZXRfdHJhbnNhY3Rpb25cIjtcbmV4cG9ydHMuVjJfR0VUX1RSQU5TRkVSUyA9IFwiL3YyL2hpc3RvcnkvZ2V0X3RyYW5zZmVyc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5kcG9pbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25ScGMgPSB2b2lkIDA7XG52YXIgZW5kcG9pbnRzXzEgPSByZXF1aXJlKFwiLi9lbmRwb2ludHNcIik7XG52YXIgcnBjZXJyb3JfMSA9IHJlcXVpcmUoXCIuL3JwY2Vycm9yXCIpO1xudmFyIGNyb3NzX2ZldGNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNyb3NzLWZldGNoXCIpKTtcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zKHBhcmFtcykge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHBhcmFtcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW50cmllcy5qb2luKFwiJlwiKTtcbn1cbmZ1bmN0aW9uIGZldGNoV2l0aFRpbWVvdXQocmVzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lb3V0LCBjb250cm9sbGVyLCBpZCwgcmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sbGVyLmFib3J0KCk7IH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgY3Jvc3NfZmV0Y2hfMS5kZWZhdWx0KShyZXNvdXJjZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSksIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBKc29uUnBjXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50IGh5cGVyaW9uIGVuZHBvaW50XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGVuZHBvaW50ID0gXCJodHRwczovL2JyLmVvc3Jpby5pb1wiXG4gKiBjb25zdCBycGMgPSBuZXcgSnNvblJwYyhlbmRwb2ludCwgeyBmZXRjaCB9KVxuICovXG52YXIgSnNvblJwYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKc29uUnBjKGVuZHBvaW50LCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IHt9OyB9XG4gICAgICAgIHRoaXMudGltZW91dCA9IDgwMDA7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgICAgICAgaWYgKGFyZ3MudGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gYXJncy50aW1lb3V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHBvc3RcbiAgICAgKlxuICAgICAqIFBPU1QgYGJvZHlgIHRvIGBlbmRwb2ludCArIHBhdGhgLlxuICAgICAqIFRocm93cyBkZXRhaWxlZCBlcnJvciBpbmZvcm1hdGlvbiBpbiBgUnBjRXJyb3JgIHdoZW4gYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHBhdGgsIGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlLCBqc29uLCBlXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hXaXRoVGltZW91dCh0aGlzLmVuZHBvaW50ICsgcGF0aCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLmpzb24oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5wcm9jZXNzZWQgJiYganNvbi5wcm9jZXNzZWQuZXhjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJwY2Vycm9yXzEuUnBjRXJyb3IoanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZV8xLmlzRmV0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcnBjZXJyb3JfMS5ScGNFcnJvcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBqc29uXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRcbiAgICAgKlxuICAgICAqIEdFVCBgcGFyYW1zYCB0byBgZW5kcG9pbnQgKyBwYXRoYC5cbiAgICAgKiBUaHJvd3MgZGV0YWlsZWQgZXJyb3IgaW5mb3JtYXRpb24gaW4gYFJwY0Vycm9yYCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGpzb24sIHVybCwgZV8yO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy5lbmRwb2ludCArIHBhdGggKyBcIj9cIiArIHF1ZXJ5UGFyYW1zKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgNCwgLCA1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaFdpdGhUaW1lb3V0KHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcnBjZXJyb3JfMS5ScGNTdGF0dXNFcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS5qc29uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24ucHJvY2Vzc2VkICYmIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBycGNlcnJvcl8xLlJwY0Vycm9yKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMi5pc0ZldGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJwY2Vycm9yXzEuUnBjRXJyb3IoanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywganNvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvc3RhdGUvYWxpdmVdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL3N0YXRlL2dldF92Ml9zdGF0ZV9hbGl2ZSlcbiAgICAgKlxuICAgICAqIHNpbXBsZSBzZXJ2ZXIgaGVhbHRoY2hlY2tcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFsaXZlPn0gYWxpdmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuYWxpdmUoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogLy8gPT4ge1wic3RhdHVzXCI6IFwiT0tcIn1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5hbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0FMSVZFLCB7fSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9oaXN0b3J5L2dldF9hYmlfc25hcHNob3RdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL2hpc3RvcnkvZ2V0X3YyX2hpc3RvcnlfZ2V0X2FiaV9zbmFwc2hvdClcbiAgICAgKlxuICAgICAqIGZldGNoIGNvbnRyYWN0IGFiaSBhdCBzcGVjaWZpYyBibG9ja1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0IGNvbnRyYWN0IGFjY291bnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIHRhcmdldCBibG9ja1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldEFiaVNuYXBzaG90Pn0gYWJpIHNuYXBzaG90XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF9hYmlfc25hcHNob3QoXCJlb3Npb1wiLCAyMDApO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLnZlcnNpb24pO1xuICAgICAqIC8vID0+IFwiZW9zaW86OmFiaS8xLjBcIlxuICAgICAqXG4gICAgICogZm9yIChjb25zdCB0YWJsZSBvZiByZXNwb25zZS50YWJsZXMpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2codGFibGUpO1xuICAgICAqICAgICAvLyA9PiB7IG5hbWU6ICdwcm9kdWNlcnMnLCBpbmRleF90eXBlOiAnaTY0Jywga2V5X25hbWVzOiBbICdvd25lcicgXSwga2V5X3R5cGVzOiBbICd1aW50NjQnIF0sIHR5cGU6ICdwcm9kdWNlcl9pbmZvJyB9XG4gICAgICogfVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9hYmlfc25hcHNob3QgPSBmdW5jdGlvbiAoY29udHJhY3QsIGJsb2NrKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBjb250cmFjdDogY29udHJhY3QsXG4gICAgICAgICAgICBibG9jazogYmxvY2ssXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfQUJJX1NOQVBTSE9ULCBwYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvc3RhdGUvZ2V0X3ZvdGVyc10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvc3RhdGUvZ2V0X3YyX3N0YXRlX2dldF92b3RlcnMpXG4gICAgICpcbiAgICAgKiBnZXQgdm90ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvZHVjZXJdIGZpbHRlciBieSB2b3RlZCBwcm9kdWNlciAoY29tbWEgc2VwYXJhdGVkKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJveHldIHRydWUgb3IgZmFsc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpcF0gc2tpcCBbbl0gYWN0aW9ucyAocGFnaW5hdGlvbilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGltaXRdIGxpbWl0IG9mIFtuXSBhY3Rpb25zIHBlciBwYWdlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0Vm90ZXJzPn0gdm90ZXJzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF92b3RlcnMoeyBwcm9kdWNlcjogXCJlb3NjYWZlYmxvY2tcIiwgbGltaXQ6IDEwMCB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS52b3RlcnMpO1xuICAgICAqIC8vID0+IFwiW3tcbiAgICAgKiAvLyAgIFwiYWNjb3VudFwiOiBcImd1emRrbXJ0Z2FnZVwiLFxuICAgICAqIC8vICAgXCJ3ZWlnaHRcIjogNzg0MzQ2OTUyMzY1MDUyODAsXG4gICAgICogLy8gICBcImxhc3Rfdm90ZVwiOiA2NDgwNDc2OFxuICAgICAqIC8vIH1dXCJcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdm90ZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9WT1RFUlMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvc3RhdGUvZ2V0X2xpbmtzXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9zdGF0ZS9nZXRfdjJfc3RhdGVfbGlua3MpXG4gICAgICpcbiAgICAgKiBnZXQgdm90ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjY291bnRdIGFjY291bnQgdG8gZ2V0IGxpbmtzIGZvclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldExpbmtzPn0gbGlua3NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X2xpbmtzKFwiZW9zY2FmZWJsb2NrXCIpO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLmxpbmtzKTtcbiAgICAgKiAvLyA9PiBcIlt7XG4gICAgICogXCJibG9ja19udW1cIjoyNjA4ODA3MixcbiAgICAgKiBcInRpbWVzdGFtcFwiOlwiMjAxOS0xMS0yMlQyMzoxNzo0Mi4wMDBcIixcbiAgICAgKiBcImFjY291bnRcIjpcImVvc3Jpb2JyYXppbFwiLFxuICAgICAqIFwicGVybWlzc2lvblwiOlwiY2xhaW0yXCIsXG4gICAgICogXCJjb2RlXCI6XCJlb3Npb1wiLFxuICAgICAqIFwiYWN0aW9uXCI6XCJ2b3RlcHJvZHVjZXJcIlxuICAgICAqIH1dXCJcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfbGlua3MgPSBmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX0xJTktTLCB7IGFjY291bnQ6IGFjY291bnQgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9zdGF0ZS9nZXRfcHJvcG9zYWxzXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9zdGF0ZS9nZXRfdjJfc3RhdGVfZ2V0X3Byb3Bvc2FscylcbiAgICAgKlxuICAgICAqIGdldCBwcm9wb3NhbHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYWNjb3VudF0gYWNjb3VudCB0byBnZXQgcHJvcG9zYWxzIGZvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcm9wb3Nlcl0gZmlsdGVyIGJ5IHByb3Bvc2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3Bvc2FsXSBmaWx0ZXIgYnkgcHJvcG9zYWwgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hY2NvdW50XSBmaWx0ZXIgYnkgZWl0aGVyIHJlcXVlc3RlZCBvciBwcm92aWRlZCBhY2NvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlcXVlc3RlZF0gZmlsdGVyIGJ5IHJlcXVlc3RlZCBhY2NvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3ZpZGVkXSBmaWx0ZXIgYnkgcHJvdmlkZWQgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja10gdG90YWwgcmVzdWx0cyB0byB0cmFjayAoY291bnQpIFtudW1iZXIgb3IgdHJ1ZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpcF0gc2tpcCBbbl0gYWN0aW9ucyAocGFnaW5hdGlvbilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGltaXRdIGxpbWl0IG9mIFtuXSBhY3Rpb25zIHBlciBwYWdlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0UHJvcG9zYWxzPn0gcHJvcG9zYWxzXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3Byb3Bvc2FscyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfUFJPUE9TQUxTLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL2hpc3RvcnkvZ2V0X2FjdGlvbnNdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL2hpc3RvcnkvZ2V0X3YyX2hpc3RvcnlfZ2V0X2FjdGlvbnMpXG4gICAgICpcbiAgICAgKiBnZXQgYWN0aW9ucyBiYXNlZCBvbiBub3RpZmllZCBhY2NvdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudCBub3RpZmllZCBhY2NvdW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZpbHRlcl0gY29kZTo6bmFtZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpcF0gc2tpcCBbbl0gYWN0aW9ucyAocGFnaW5hdGlvbilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGltaXRdIGxpbWl0IG9mIFtuXSBhY3Rpb25zIHBlciBwYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvcnRdIHNvcnQgZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFmdGVyXSBmaWx0ZXIgYWZ0ZXIgc3BlY2lmaWVkIGRhdGUgKElTTzg2MDEpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJlZm9yZV0gZmlsdGVyIGJlZm9yZSBzcGVjaWZpZWQgZGF0ZSAoSVNPODYwMSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhbnNmZXJfdG9dIHRyYW5zZmVyIGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFuc2Zlcl9mcm9tXSAgdHJhbnNmZXIgZmlsdGVyIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhbnNmZXJfc3ltYm9sXSAgdHJhbnNmZXIgZmlsdGVyIHN5bWJvbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hY3RfbmFtZV0gIGFjdCBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFjdF9hY2NvdW50XSAgYWN0IGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRBY3Rpb25zPn0gZ2V0IGFjdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X2FjdGlvbnMoXCJlb3NjYWZlYmxvY2tcIiwge1xuICAgICAqICAgICBmaWx0ZXI6IFwiZW9zaW8udG9rZW46KlwiLFxuICAgICAqICAgICBza2lwOiAxMDAsXG4gICAgICogICAgIGxpbWl0OiAxMDAsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmb3IgKGNvbnN0IGFjdGlvbiBvZiByZXNwb25zZS5hY3Rpb25zKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGFjdGlvbik7XG4gICAgICogICAgIC8vID0+IHsgYWN0OiB7IGFjY291bnQ6ICdlb3Npby50b2tlbicsIG5hbWU6ICd0cmFuc2ZlcicsIC4uLiB9IH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2FjdGlvbnMgPSBmdW5jdGlvbiAoYWNjb3VudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgeyBhY2NvdW50OiBhY2NvdW50IH0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX0FDVElPTlMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9oaXN0b3J5L2dldF9jcmVhdGVkX2FjY291bnRzXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9oaXN0b3J5L2dldF92Ml9oaXN0b3J5X2dldF9jcmVhdGVkX2FjY291bnRzKVxuICAgICAqXG4gICAgICogZ2V0IGNyZWF0ZWQgYWNjb3VudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50IGNyZWF0ZWQgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldENyZWF0ZWRBY2NvdW50cz59IGdldCBjcmVhdG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF9jcmVhdGVkX2FjY291bnRzKFwiZW9zbmF0aW9uZnR3XCIpO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiAvLyA9PiB7XCJhY2NvdW50c1wiOiBbe1wibmFtZVwiOlwiZW9zbmF0aW9uZHNwXCIsXCJ0cnhfaWRcIjpcIjcyOGQ0YTRkYTM2YTk4ZDkwNDgwODA0NjFkYWNhZjk3NWFkMDgzZTgxNThlZjg0ZWRlYTYwY2M3NTVhYjJjMWFcIixcInRpbWVzdGFtcFwiOlwiMjAxOS0wMi0yOFQyMjozNjo0NS4wMDBcIn0sIC4uLiBdfVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9jcmVhdGVkX2FjY291bnRzID0gZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGFjY291bnQ6IGFjY291bnQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfQ1JFQVRFRF9BQ0NPVU5UUywgcGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL2hpc3RvcnkvZ2V0X2NyZWF0b3JdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL2hpc3RvcnkvZ2V0X3YyX2hpc3RvcnlfZ2V0X2NyZWF0b3IpXG4gICAgICpcbiAgICAgKiBnZXQgY3JlYXRvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnQgY3JlYXRlZCBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0Q3JlYXRvcj59IGdldCBjcmVhdG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF9jcmVhdG9yKFwiZW9zbmF0aW9uZnR3XCIpO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiAvLyA9PiB7IGFjY291bnQ6ICdlb3NuYXRpb25mdHcnLCBjcmVhdG9yOiAnZ3l6dGNtcnZncWdlJywgdGltZXN0YW1wOiAnMjAxOC0wNi0xMFQxMzowNjo0My41MDAnLCAuLi4gfVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9jcmVhdG9yID0gZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGFjY291bnQ6IGFjY291bnQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfQ1JFQVRPUiwgcGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL2hpc3RvcnkvZ2V0X2RlbHRhc10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvaGlzdG9yeS9nZXRfdjJfaGlzdG9yeV9nZXRfZGVsdGFzKVxuICAgICAqXG4gICAgICogZ2V0IGRlbHRhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgY29udHJhY3QgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSB0YWJsZSBzY29wZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZSB0YWJsZSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBheWVyIHBheWVyIGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXREZWx0YXM+fSBnZXQgZGVsdGFzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF9kZWx0YXMoXCJlb3Npby50b2tlblwiLCBcImVvc25hdGlvbmZ0d1wiLCBcImFjY291bnRzXCIsIFwiZW9zbmF0aW9uZnR3XCIpO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiAvLyA9PiB7IFwicXVlcnlfdGltZVwiOiAxOSwgXCJ0b3RhbFwiOiB7IFwidmFsdWVcIjogNDg2LCBcInJlbGF0aW9uXCI6IFwiZXFcIiB9LCBcImRlbHRhc1wiOiBbIC4uLiBdIH1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfZGVsdGFzID0gZnVuY3Rpb24gKGNvZGUsIHNjb3BlLCB0YWJsZSwgcGF5ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICBzY29wZTogc2NvcGUsXG4gICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICBwYXllcjogcGF5ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX0RFTFRBUywgcGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQvdjIvc3RhdGUvZ2V0X2tleV9hY2NvdW50c10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvc3RhdGUvZ2V0X3YyX3N0YXRlX2dldF9rZXlfYWNjb3VudHMpXG4gICAgICpcbiAgICAgKiBnZXQgYWNjb3VudCBieSBwdWJsaWMga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2tleSBDb250cmFjdCBhY2NvdW50IHRhcmdldGVkIGJ5IHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0S2V5QWNjb3VudHM+fSBrZXkgYWNjb3VudHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X2tleV9hY2NvdW50cyhcIkVPUzVNdG8zS202QkNWeG93YjZMa2tGYVQ5b2FVd0xWZ3N3Z2N4dlk0UWdjNHJoSHJ5NFR2XCIpO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLmFjY291bnRfbmFtZXMpO1xuICAgICAqIC8vID0+IFsgJ2Vvc2NhZmVibG9jaycgXVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9rZXlfYWNjb3VudHMgPSBmdW5jdGlvbiAocHVibGljX2tleSkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgcHVibGljX2tleTogcHVibGljX2tleSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9LRVlfQUNDT1VOVFMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9zdGF0ZS9nZXRfdG9rZW5zXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9zdGF0ZS9nZXRfdjJfc3RhdGVfZ2V0X3Rva2VucylcbiAgICAgKlxuICAgICAqIGdldCB0b2tlbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50IGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRUb2tlbnM+fSBnZXQgdG9rZW5zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF90b2tlbnMoXCJlb3NuYXRpb25mdHdcIik7XG4gICAgICogZm9yIChjb25zdCB0b2tlbiBvZiByZXNwb25zZS50b2tlbnMpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2codG9rZW4pO1xuICAgICAqICAgICAvLyA9PiB7IHN5bWJvbDogJ1pPUycsIHByZWNpc2lvbjogNCwgYW1vdW50OiAxNDAsIGNvbnRyYWN0OiAnem9zZGlzY291bnRzJyB9XG4gICAgICogfVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90b2tlbnMgPSBmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9UT0tFTlMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9oaXN0b3J5L2dldF90cmFuc2FjdGVkX2FjY291bnRzXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9oaXN0b3J5L2dldF92Ml9oaXN0b3J5X2dldF90cmFuc2FjdGVkX2FjY291bnRzKVxuICAgICAqXG4gICAgICogZ2V0IGFsbCBhY2NvdW50IHRoYXQgaW50ZXJhY3RlZCB3aXRoIHRoZSBzb3VyY2UgYWNjb3VudCBwcm92aWRlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnQgc291cmNlIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIHNlYXJjaCBkaXJlY3Rpb24gKGluLCBvdXQgb3IgYm90aClcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRUcmFuc2FjdGVkQWNjb3VudHM+fSB0cmFuc2FjdGVkIGFjY291bnRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF90cmFuc2FjdGVkX2FjY291bnRzKFwiZW9zY2FmZWJsb2NrXCIsIFwiaW5cIik7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIC8vID0+IHsgcXVlcnlfdGltZTogMjY4LCBhY2NvdW50OiAnZW9zY2FmZWJsb2NrJywgdG90YWxfaW46IDEwOTIzNjkuMTgyNywgaW5wdXRzOiBbIC4uLiBdIH1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdHJhbnNhY3RlZF9hY2NvdW50cyA9IGZ1bmN0aW9uIChhY2NvdW50LCBkaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHsgYWNjb3VudDogYWNjb3VudCwgZGlyZWN0aW9uOiBkaXJlY3Rpb24gfSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfVFJBTlNBQ1RFRF9BQ0NPVU5UUywgcGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL2hpc3RvcnkvZ2V0X3RyYW5zYWN0aW9uXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9oaXN0b3J5L2dldF92Ml9oaXN0b3J5X2dldF90cmFuc2FjdGlvbilcbiAgICAgKlxuICAgICAqIGdldCBhbGwgYWN0aW9ucyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgdHJhbnNhY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB0cmFuc2FjdGlvbiBpZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldFRyYW5zYWN0aW9uPn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBycGMuZ2V0X3RyYW5zYWN0aW9uKFwiNDJkYWNkNTcyMjAwMWI3MzRiZTQ2YTIxNDA5MTdlMDZjZDIxZDQyNDI1ZjkyN2Y1MDZjMDdiNDM4OGIwN2Y2MlwiKTtcbiAgICAgKiBmb3IgKGNvbnN0IGFjdGlvbiBvZiByZXNwb25zZS5hY3Rpb25zKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGFjdGlvbik7XG4gICAgICogICAgIC8vID0+IHsgYWN0OiB7IGFjY291bnQ6ICdlb3NpbycsIG5hbWU6ICdidXlyYW1ieXRlcycsIC4uLiB9fVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9UUkFOU0FDVElPTiwgcGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL2hpc3RvcnkvZ2V0X3RyYW5zZmVyc10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvaGlzdG9yeS9nZXRfdjJfaGlzdG9yeV9nZXRfdHJhbnNmZXJzKVxuICAgICAqXG4gICAgICogZ2V0IHRva2VuIHRyYW5zZmVycyB1dGlsaXppbmcgdGhlIGVvc2lvLnRva2VuIHN0YW5kYXJkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZnJvbV0gc291cmNlIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9dIGRlc3RpbmF0aW9uIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3ltYm9sXSB0b2tlbiBzeW1ib2xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29udHJhY3RdIHRva2VuIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNraXBdIHNraXAgW25dIGFjdGlvbnMgKHBhZ2luYXRpb24pXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbWl0XSBsaW1pdCBvZiBbbl0gYWN0aW9ucyBwZXIgcGFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hZnRlcl0gZmlsdGVyIGFmdGVyIHNwZWNpZmllZCBkYXRlIChJU084NjAxKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5iZWZvcmVdIGZpbHRlciBiZWZvcmUgc3BlY2lmaWVkIGRhdGUgKElTTzg2MDEpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0VHJhbnNmZXJzPn0gdHJhbnNmZXJzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF90cmFuc2ZlcnMoe3RvOiBcImVvc25ld3lvcmtpb1wifSk7XG4gICAgICogZm9yIChjb25zdCBhY3Rpb24gb2YgcmVzcG9uc2UuYWN0aW9ucykge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhhY3Rpb24uYWN0LmRhdGEpO1xuICAgICAqICAgICAvLyA9PiB7IGZyb206ICdlb3Npby5icGF5JywgdG86ICdlb3NuZXd5b3JraW8nLCBhbW91bnQ6IDMyNi41MjQsIHN5bWJvbDogJ0VPUycsIG1lbW86ICdwcm9kdWNlciBibG9jayBwYXknIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3RyYW5zZmVycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9UUkFOU0ZFUlMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICByZXR1cm4gSnNvblJwYztcbn0oKSk7XG5leHBvcnRzLkpzb25ScGMgPSBKc29uUnBjO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbnJwYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJwY1N0YXR1c0Vycm9yID0gZXhwb3J0cy5ScGNFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogQHByaXZhdGVcbiAqIEBtb2R1bGUgUlBDLUVycm9yXG4gKlxuICogY29weXJpZ2h0IGRlZmluZWQgaW4gZW9zanMvTElDRU5TRS50eHRcbiAqL1xudmFyIFJwY0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhScGNFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBScGNFcnJvcihqc29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChqc29uLmVycm9yICYmIGpzb24uZXJyb3IuZGV0YWlscyAmJiBqc29uLmVycm9yLmRldGFpbHMubGVuZ3RoICYmIGpzb24uZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlKSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGpzb24uZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24ucHJvY2Vzc2VkICYmIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdCAmJiBqc29uLnByb2Nlc3NlZC5leGNlcHQubWVzc2FnZSkge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBqc29uLnByb2Nlc3NlZC5leGNlcHQubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywganNvbi5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUnBjRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgX3RoaXMuanNvbiA9IGpzb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJwY0Vycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5ScGNFcnJvciA9IFJwY0Vycm9yO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgUnBjU3RhdHVzRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJwY1N0YXR1c0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJwY1N0YXR1c0Vycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNSkge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZXNwb25zZS5zdGF0dXNUZXh0KSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUnBjU3RhdHVzRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgX3RoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUnBjU3RhdHVzRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlJwY1N0YXR1c0Vycm9yID0gUnBjU3RhdHVzRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ycGNlcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbl90cmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gVHlwZVNjcmlwdCBEZWZpbml0aW9uc1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy90eXBlcy9hcGlcIiksIGV4cG9ydHMpO1xuLy8gTGlnaHQgQVBJXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL2pzb25ycGNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9lbmRwb2ludHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9ycGNlcnJvclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR0VUX0FDQ09VTlRTX0ZST01fS0VZUyA9IGV4cG9ydHMuR0VUX1RPS0VOX0hPTERFUlMgPSBleHBvcnRzLkdFVF9UT0tFTl9IT0xERVJfQ09VTlQgPSBleHBvcnRzLkdFVF9DT0RFSEFTSCA9IGV4cG9ydHMuR0VUX1RPUFNUQUtFID0gZXhwb3J0cy5HRVRfVE9QUkFNID0gZXhwb3J0cy5HRVRfVVNFUkNPVU5UID0gZXhwb3J0cy5HRVRfVE9QSE9MREVSUyA9IGV4cG9ydHMuR0VUX1RPS0VOX0JBTEFOQ0UgPSBleHBvcnRzLkdFVF9TWU5DX0lORk8gPSBleHBvcnRzLkdFVF9ORVRXT1JLUyA9IGV4cG9ydHMuR0VUX0tFWV9BQ0NPVU5UUyA9IGV4cG9ydHMuR0VUX0JBTEFOQ0VTID0gZXhwb3J0cy5HRVRfQUNDT1VOVF9JTkZPID0gZXhwb3J0cy5HRVRfQUNDT1VOVCA9IHZvaWQgMDtcbmV4cG9ydHMuR0VUX0FDQ09VTlQgPSBcIi9hcGkvYWNjb3VudFwiO1xuZXhwb3J0cy5HRVRfQUNDT1VOVF9JTkZPID0gXCIvYXBpL2FjY2luZm9cIjtcbmV4cG9ydHMuR0VUX0JBTEFOQ0VTID0gXCIvYXBpL2JhbGFuY2VzXCI7XG5leHBvcnRzLkdFVF9LRVlfQUNDT1VOVFMgPSBcIi9hcGkva2V5XCI7XG5leHBvcnRzLkdFVF9ORVRXT1JLUyA9IFwiL2FwaS9uZXR3b3Jrc1wiO1xuZXhwb3J0cy5HRVRfU1lOQ19JTkZPID0gXCIvYXBpL3N5bmNcIjtcbmV4cG9ydHMuR0VUX1RPS0VOX0JBTEFOQ0UgPSBcIi9hcGkvdG9rZW5iYWxhbmNlXCI7XG5leHBvcnRzLkdFVF9UT1BIT0xERVJTID0gXCIvYXBpL3RvcGhvbGRlcnNcIjtcbmV4cG9ydHMuR0VUX1VTRVJDT1VOVCA9IFwiL2FwaS91c2VyY291bnRcIjtcbmV4cG9ydHMuR0VUX1RPUFJBTSA9IFwiL2FwaS90b3ByYW1cIjtcbmV4cG9ydHMuR0VUX1RPUFNUQUtFID0gXCIvYXBpL3RvcHN0YWtlXCI7XG5leHBvcnRzLkdFVF9DT0RFSEFTSCA9IFwiL2FwaS9jb2RlaGFzaFwiO1xuZXhwb3J0cy5HRVRfVE9LRU5fSE9MREVSX0NPVU5UID0gXCIvYXBpL2hvbGRlcmNvdW50XCI7XG5leHBvcnRzLkdFVF9UT0tFTl9IT0xERVJTID0gXCJnZXRfdG9rZW5faG9sZGVyc1wiO1xuZXhwb3J0cy5HRVRfQUNDT1VOVFNfRlJPTV9LRVlTID0gXCJnZXRfYWNjb3VudHNfZnJvbV9rZXlzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmRwb2ludHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSnNvblJwYyA9IHZvaWQgMDtcbnZhciBlbmRwb2ludHNfMSA9IHJlcXVpcmUoXCIuL2VuZHBvaW50c1wiKTtcbnZhciBycGNlcnJvcl8xID0gcmVxdWlyZShcIi4vcnBjZXJyb3JcIik7XG52YXIgY3Jvc3NfZmV0Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3Jvc3MtZmV0Y2hcIikpO1xudmFyIGpzb25ycGMyX3dzXzEgPSByZXF1aXJlKFwianNvbnJwYzItd3NcIik7XG52YXIgY2hhaW5Ub0VuZHBvaW50ID0ge1xuICAgIGVvczogXCJodHRwczovL2FwaS5saWdodC54ZW9zLm1lXCIsXG4gICAgdGVsb3M6IFwiaHR0cHM6Ly9hcGkubGlnaHQueGVvcy5tZVwiLFxuICAgIGp1bmdsZTogXCJodHRwczovL2xpZ2h0YXBpLmVvc2dlbmV2YS5pb1wiLFxuICAgIGJvczogXCJodHRwczovL2xpZ2h0YXBpLmVvc2Ftc3RlcmRhbS5uZXRcIixcbiAgICBpbnN0YXI6IFwiaHR0cHM6Ly9saWdodGFwaS5lb3NhbXN0ZXJkYW0ubmV0XCIsXG4gICAgcHJvdG9uOiBcImh0dHBzOi8vcHJvdG9uLmxpZ2h0LWFwaS5uZXRcIixcbiAgICB3YXg6IFwiaHR0cHM6Ly9saWdodGFwaS5lb3NhbXN0ZXJkYW0ubmV0XCIsXG4gICAgd29yYmxpOiBcImh0dHBzOi8vbGlnaHRhcGkuZW9zYW1zdGVyZGFtLm5ldFwiLFxuICAgIHhlYzogXCJodHRwczovL2xpZ2h0YXBpLmVvc2Ftc3RlcmRhbS5uZXRcIixcbiAgICBwcm90b250ZXN0OiBcImh0dHBzOi8vdGVzdG5ldC1saWdodGFwaS5lb3NhbXMueGVvcy5tZVwiLFxuICAgIHRlbG9zdGVzdDogXCJodHRwczovL3Rlc3RuZXQtbGlnaHRhcGkuZW9zYW1zLnhlb3MubWVcIixcbiAgICB3YXh0ZXN0OiBcImh0dHBzOi8vdGVzdG5ldC1saWdodGFwaS5lb3NhbXMueGVvcy5tZVwiLFxuICAgIGNvZmZlOiBcImh0dHBzOi8vaHlwZXJpb24uY29mZmUuaW9cIixcbn07XG5mdW5jdGlvbiBmZXRjaFdpdGhUaW1lb3V0KHJlc291cmNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZW91dCwgY29udHJvbGxlciwgaWQsIHJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbGxlci5hYm9ydCgpOyB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGNyb3NzX2ZldGNoXzEuZGVmYXVsdCkocmVzb3VyY2UsIF9fYXNzaWduKF9fYXNzaWduKHt9LCAob3B0aW9ucyB8fCB7fSkpLCB7IHNpZ25hbDogY29udHJvbGxlci5zaWduYWwgfSkpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogSnNvblJwY1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCBMSUdIVCBBUEkgZW5kcG9pbnRcbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgcnBjID0gbmV3IEpzb25ScGMoXCJwcm90b25cIilcbiAqL1xudmFyIEpzb25ScGMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSnNvblJwYyhjaGFpbiwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSB7fTsgfVxuICAgICAgICB0aGlzLnRpbWVvdXQgPSA1MDAwO1xuICAgICAgICB0aGlzLndzUmVxdWVzdElkID0gMTAwO1xuICAgICAgICB0aGlzLmNoYWluID0gY2hhaW47XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBhcmdzLmVuZHBvaW50IHx8IGNoYWluVG9FbmRwb2ludFtjaGFpbl07XG4gICAgICAgIHRoaXMud3NDbGllbnQgPSBuZXcganNvbnJwYzJfd3NfMS5DbGllbnQodGhpcy5lbmRwb2ludC5yZXBsYWNlKCdodHRwczonLCAnd3NzOicpICsgJy93c2FwaScpO1xuICAgICAgICBpZiAoIXRoaXMuZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYWluIFwiLmNvbmNhdChjaGFpbiwgXCIgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgZW5kcG9pbnQsIHByb3ZpZGUgb25lIGluIGFyZ3NcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IGFyZ3MudGltZW91dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRcbiAgICAgKlxuICAgICAqIEdFVCBgcGFyYW1zYCB0byBgZW5kcG9pbnQgKyBwYXRoYC5cbiAgICAgKiBUaHJvd3MgZGV0YWlsZWQgZXJyb3IgaW5mb3JtYXRpb24gaW4gYFJwY0Vycm9yYCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgsIGVuZHBvaW50KSB7XG4gICAgICAgIGlmIChlbmRwb2ludCA9PT0gdm9pZCAwKSB7IGVuZHBvaW50ID0gdGhpcy5lbmRwb2ludDsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGpzb24sIHVybCwgdGV4dCwgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gZW5kcG9pbnQgKyBwYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDQsICwgNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hXaXRoVGltZW91dCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBycGNlcnJvcl8xLlJwY1N0YXR1c0Vycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLnRleHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLnByb2Nlc3NlZCAmJiBqc29uLnByb2Nlc3NlZC5leGNlcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJwY2Vycm9yXzEuUnBjRXJyb3IoanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZV8xLmlzRmV0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcnBjZXJyb3JfMS5ScGNFcnJvcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBqc29uXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvYWNjb3VudF1cbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGFsbCB0b2tlbiBiYWxhbmNlcywgcmVzb3VyY2VzIGFuZCBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIGZvciBhbiBhY2NvdW50OlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnROYW1lIG5hbWUgb2YgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldEFjY291bnQ+fSBhY2NvdW50XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2FjY291bnQgPSBmdW5jdGlvbiAoYWNjb3VudE5hbWUpIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9BQ0NPVU5ULCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4sIFwiL1wiKS5jb25jYXQoYWNjb3VudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS9hY2NpbmZvXVxuICAgICAqXG4gICAgICogUmV0cmlldmUgYWxsIHJlc291cmNlcyBhbmQgYXV0aG9yaXphdGlvbiBpbmZvcm1hdGlvbiBmb3IgYW4gYWNjb3VudDpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50TmFtZSBuYW1lIG9mIGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRBY2NvdW50SW5mbz59IGFjY291bnRcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfYWNjb3VudF9pbmZvID0gZnVuY3Rpb24gKGFjY291bnROYW1lKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfQUNDT1VOVF9JTkZPLCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4sIFwiL1wiKS5jb25jYXQoYWNjb3VudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS9iYWxhbmNlc11cbiAgICAgKlxuICAgICAqIFJldHJpZXZlIG9ubHkgdG9rZW4gYmFsYW5jZXMgZm9yIGFuIGFjY291bnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50TmFtZSBuYW1lIG9mIGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRCYWxhbmNlcz59IGJhbGFuY2VzXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2JhbGFuY2VzID0gZnVuY3Rpb24gKGFjY291bnROYW1lKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfQkFMQU5DRVMsIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbiwgXCIvXCIpLmNvbmNhdChhY2NvdW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL2tleV1cbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGFsbCBhY2NvdW50cyBpbiBhbGwga25vd24gRU9TIG5ldHdvcmtzIGRlcGVuZGVudCBvbiBhIHB1YmxpYyBrZXk6XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHB1YmxpYyBrZXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRLZXlBY2NvdW50c1tdPn0gYWNjb3VudHMgcGVyIG5ldHdvcmtcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfYWxsX2tleV9hY2NvdW50cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhjaGFpblRvRW5kcG9pbnQpKSksIGZhbHNlKS5tYXAoZnVuY3Rpb24gKGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9LRVlfQUNDT1VOVFMsIFwiL1wiKS5jb25jYXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0KHVybCwgZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChwcm9taXNlcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS9rZXldXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBhbGwgYWNjb3VudHMgaW4gbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBwdWJsaWMga2V5XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0S2V5QWNjb3VudHM+fSBhY2NvdW50c1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9rZXlfYWNjb3VudHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX0tFWV9BQ0NPVU5UUywgXCIvXCIpLmNvbmNhdChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmdldCh1cmwpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS9uZXR3b3Jrc11cbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGFsbCBhY2NvdW50cyBpbiBhbGwga25vd24gRU9TIG5ldHdvcmtzIGRlcGVuZGVudCBvbiBhIHB1YmxpYyBrZXk6XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXROZXR3b3Jrcz59IGFjY291bnRzXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X25ldHdvcmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuR0VUX05FVFdPUktTKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS9zeW5jXVxuICAgICAqXG4gICAgICogcmV0dXJucyBhIHBsYWluIHRleHQgd2l0aCBkZWxheSBpbiBzZWNvbmRzIHRoYXQgdGhpcyBzZXJ2ZXIncyBibG9ja2NoYWluIGRhdGFiYXNlIGlzIGJlaGluZCB0aGUgcmVhbCB0aW1lLCBhbmQgYSBzdGF0dXM6IE9LIGlmIHRoZSBkZWxheSBpcyB3aXRoaW4gMTgwIHNlY29uZHMsIG9yICdPVVRfT0ZfU1lOQycgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gZ2V0IHN5bmNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfc3luY19pbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX1NZTkNfSU5GTywgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvdG9rZW5iYWxhbmNlXVxuICAgICAqXG4gICAgICogIHJldHVybnMgYSBwbGFpbiB0ZXh0IHdpdGggbnVtZXJpYyBvdXRwdXQgaW5kaWNhdGluZyB0aGUgdG9rZW4gYmFsYW5jZS4gWmVybyBpcyByZXR1cm5lZCBpZiB0aGUgdG9rZW4gaXMgbm90IHByZXNlbnQgb3IgZG9lcyBub3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudCBvd25lciBvZiB0b2tlblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdCB0b2tlbiBjb250cmFjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiB0b2tlbiBzeW1ib2xcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSB0b2tlbiBiYWxhbmNlXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3Rva2VuX2JhbGFuY2UgPSBmdW5jdGlvbiAoYWNjb3VudCwgY29udHJhY3QsIHRva2VuKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfVE9LRU5fQkFMQU5DRSwgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluLCBcIi9cIikuY29uY2F0KGFjY291bnQsIFwiL1wiKS5jb25jYXQoY29udHJhY3QsIFwiL1wiKS5jb25jYXQodG9rZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS90b3Bob2xkZXJzXVxuICAgICAqXG4gICAgICogcmV0dXJucyB0b3AgTlVNIGhvbGRlcnMgb2YgYSBzcGVjaWZpZWQgdG9rZW4gaW4gYSBKU09OIGFycmF5IGNvbnRhaW5pbmcgYXJyYXlzIG9mIChhY2NvdW50LCBhbW91bnQpIHBhaXJzLiBOVU0gbXVzdCBub3QgYmUgbGVzcyB0aGFuIDEwIG9yIG1vcmUgdGhhbiAxMDAwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0IHRva2VuIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIHRva2VuIHN5bWJvbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW0gbnVtYmVyIG9mIHRvcCBob2xkZXJzIChtaW4gMTAsIG1heCAxMDAwKVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gdG9rZW4gYmFsYW5jZVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90b3Bob2xkZXJzID0gZnVuY3Rpb24gKGNvbnRyYWN0LCB0b2tlbiwgbnVtKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfVE9QSE9MREVSUywgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluLCBcIi9cIikuY29uY2F0KGNvbnRyYWN0LCBcIi9cIikuY29uY2F0KHRva2VuLCBcIi9cIikuY29uY2F0KG51bSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL3VzZXJjb3VudF1cbiAgICAgKlxuICAgICAqIHJldHVybnMgYSBwbGFpbiB0ZXh0IHdpdGggdG90YWwgbnVtYmVyIG9mIGFjY291bnRzIGluIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gdG9rZW4gYmFsYW5jZVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF91c2VyY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfVVNFUkNPVU5ULCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS90b3ByYW1dXG4gICAgICpcbiAgICAgKiByZXR1cm5zIHRvcCBOVU0gUkFNIGJ1eWVycyBpbiBhIEpTT04gYXJyYXkgY29udGFpbmluZyBhcnJheXMgb2YgKGFjY291bnQsIGJ5dGVzKSBwYWlycy4gTlVNIG11c3Qgbm90IGJlIGxlc3MgdGhhbiAxMCBvciBtb3JlIHRoYW4gMTAwMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW0gbnVtYmVyIG9mIHRvcCBob2xkZXJzIChtaW4gMTAsIG1heCAxMDAwKVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0VG9wUmFtPn0gdG9wIHJhbSBob2xkZXJzXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3RvcHJhbSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9UT1BSQU0sIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbiwgXCIvXCIpLmNvbmNhdChudW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS90b3BzdGFrZV1cbiAgICAgKlxuICAgICAqIHJldHVybnMgdG9wIE5VTSBSQU0gYnV5ZXJzIGluIGEgSlNPTiBhcnJheSBjb250YWluaW5nIGFycmF5cyBvZiAoYWNjb3VudCwgYnl0ZXMpIHBhaXJzLiBOVU0gbXVzdCBub3QgYmUgbGVzcyB0aGFuIDEwIG9yIG1vcmUgdGhhbiAxMDAwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bSByZXR1cm5zIHRvcCBOVU0gc3Rha2UgaG9sZGVycyBieSBzdW0gb2YgQ1BVIGFuZCBOZXQgc3Rha2VzLCBpbiBhIEpTT04gYXJyYXkgY29udGFpbmluZyBhcnJheXMgb2YgKGFjY291bnQsIGNwdV93ZWlnaHQsIG5ldF93ZWlnaHQpIHR1cGxlcy4gTlVNIG11c3Qgbm90IGJlIGxlc3MgdGhhbiAxMCBvciBtb3JlIHRoYW4gMTAwMC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldFRvcFN0YWtlPn0gdG9wIHN0YWtlIGhvbGRlcnNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdG9wc3Rha2UgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfVE9QU1RBS0UsIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbiwgXCIvXCIpLmNvbmNhdChudW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS9jb2RlaGFzaF1cbiAgICAgKlxuICAgICAqIHJldHJpZXZlcyBhbGwgYWNjb3VudHMgaW4gYWxsIGtub3duIEVPUyBuZXR3b3JrcyBieSBjb250cmFjdCBoYXNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bSByZXR1cm5zIHRvcCBOVU0gc3Rha2UgaG9sZGVycyBieSBzdW0gb2YgQ1BVIGFuZCBOZXQgc3Rha2VzLCBpbiBhIEpTT04gYXJyYXkgY29udGFpbmluZyBhcnJheXMgb2YgKGFjY291bnQsIGNwdV93ZWlnaHQsIG5ldF93ZWlnaHQpIHR1cGxlcy4gTlVNIG11c3Qgbm90IGJlIGxlc3MgdGhhbiAxMCBvciBtb3JlIHRoYW4gMTAwMC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldENvZGVoYXNoPn0gYWNjb3VudHNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfY29kZWhhc2ggPSBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX0NPREVIQVNILCBcIi9cIikuY29uY2F0KGhhc2gpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS9ob2xkZXJjb3VudF1cbiAgICAgKlxuICAgICAqIHJldHVybnMgYSBwbGFpbnRleHQgaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2YgYWNjb3VudHMgd2l0aCBwb3NpdGl2ZSBiYWxhbmNlIGZvciBhIHNwZWNpZmllZCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdCB0b2tlbiBjb250cmFjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiB0b2tlbiBzeW1ib2xcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IGNvdW50XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3Rva2VuaG9sZGVyX2NvdW50ID0gZnVuY3Rpb24gKGNvbnRyYWN0LCB0b2tlbikge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX1RPS0VOX0hPTERFUl9DT1VOVCwgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluLCBcIi9cIikuY29uY2F0KGNvbnRyYWN0LCBcIi9cIikuY29uY2F0KHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbV1MgZ2V0X3Rva2VuX2hvbGRlcnNdXG4gICAgICpcbiAgICAgKiBHZXQgYWxsIHRva2VuIGhvbGRlcnMgb2YgYSBjb250cmFjdCBhbmQgc3ltYm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgdG9rZW4gY29udHJhY3RcbiAgICAgKiBAcGFyYW0gdG9rZW4gdG9rZW4gc3ltYm9sXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdG9rZW5faG9sZGVycyA9IGZ1bmN0aW9uIChjb250cmFjdCwgdG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcUlkID0gKyt0aGlzLndzUmVxdWVzdElkO1xuICAgICAgICB2YXIgYmFsYW5jZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLndzQ2xpZW50Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9KTtcbiAgICAgICAgICAgIF90aGlzLndzQ2xpZW50Lm1ldGhvZHMuc2V0KCdyZXFkYXRhJywgZnVuY3Rpb24gKF8sIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYmFsYW5jZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYWxhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogcGFyYW1zLmRhdGEuYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiArcGFyYW1zLmRhdGEuYW1vdW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF90aGlzLndzQ2xpZW50LmNhbGwoZW5kcG9pbnRzXzEuR0VUX1RPS0VOX0hPTERFUlMsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxaWQ6IHJlcUlkLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBfdGhpcy5jaGFpbixcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3Q6IGNvbnRyYWN0LFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogdG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtXUyBnZXRfYWNjb3VudHNfZnJvbV9rZXlzXVxuICAgICAqXG4gICAgICogR2V0IGFsbCB0b2tlbiBob2xkZXJzIG9mIGEgY29udHJhY3QgYW5kIHN5bWJvbFxuICAgICAqXG4gICAgICogQHBhcmFtIGtleXNbXSBhcnJheSBvZiBrZXlzXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfYWNjb3VudHNfZnJvbV9rZXlzID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcUlkID0gKyt0aGlzLndzUmVxdWVzdElkO1xuICAgICAgICB2YXIgYWNjb3VudHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLndzQ2xpZW50Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9KTtcbiAgICAgICAgICAgIF90aGlzLndzQ2xpZW50Lm1ldGhvZHMuc2V0KCdyZXFkYXRhJywgZnVuY3Rpb24gKF8sIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYWNjb3VudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudF9uYW1lOiBwYXJhbXMuZGF0YS5hY2NvdW50X25hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBlcm06IHBhcmFtcy5kYXRhLnBlcm0sXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogK3BhcmFtcy5kYXRhLndlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBwYXJhbXMuZGF0YS5wdWJrZXksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud3NDbGllbnQuY2FsbChlbmRwb2ludHNfMS5HRVRfQUNDT1VOVFNfRlJPTV9LRVlTLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcWlkOiByZXFJZCxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogX3RoaXMuY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBKc29uUnBjO1xufSgpKTtcbmV4cG9ydHMuSnNvblJwYyA9IEpzb25ScGM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29ucnBjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUnBjU3RhdHVzRXJyb3IgPSBleHBvcnRzLlJwY0Vycm9yID0gdm9pZCAwO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQG1vZHVsZSBSUEMtRXJyb3JcbiAqXG4gKiBjb3B5cmlnaHQgZGVmaW5lZCBpbiBlb3Nqcy9MSUNFTlNFLnR4dFxuICovXG52YXIgUnBjRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJwY0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJwY0Vycm9yKGpzb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGpzb24uZXJyb3IgJiYganNvbi5lcnJvci5kZXRhaWxzICYmIGpzb24uZXJyb3IuZGV0YWlscy5sZW5ndGggJiYganNvbi5lcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywganNvbi5lcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvbi5wcm9jZXNzZWQgJiYganNvbi5wcm9jZXNzZWQuZXhjZXB0ICYmIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdC5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBqc29uLm1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBScGNFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICBfdGhpcy5qc29uID0ganNvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUnBjRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlJwY0Vycm9yID0gUnBjRXJyb3I7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBScGNTdGF0dXNFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUnBjU3RhdHVzRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUnBjU3RhdHVzRXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA1KSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlc3BvbnNlLnN0YXR1c1RleHQpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBScGNTdGF0dXNFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBScGNTdGF0dXNFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUnBjU3RhdHVzRXJyb3IgPSBScGNTdGF0dXNFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJwY2Vycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCIsImltcG9ydCB7IHN0cmluZywgb2JqZWN0LCBhcnJheSwgbGl0ZXJhbCwgbnVtYmVyLCBhbnksIG5hdGl2ZUVudW0sIGJvb2xlYW4gfSBmcm9tICd6b2QnO1xuXG52YXIgX3NpbWlsYXJDaGFpbnMsIF9leHBsb3JlckxpbmtCeUNoYWluO1xuXG52YXIgQ2hhaW5zO1xuXG4oZnVuY3Rpb24gKENoYWlucykge1xuICBDaGFpbnNbXCJCaXRjb2luTWFpbm5ldFwiXSA9IFwiQml0Y29pblwiO1xuICBDaGFpbnNbXCJCaXRjb2luVGVzdG5ldFwiXSA9IFwiQml0Y29pbiAoVGVzdG5ldClcIjtcbiAgQ2hhaW5zW1wiRXRoZXJldW1NYWlubmV0XCJdID0gXCJFdGhlcmV1bVwiO1xuICBDaGFpbnNbXCJFdGhlcmV1bVJvcHN0ZW5cIl0gPSBcIkV0aGVyZXVtIChSb3BzdGVuKVwiO1xuICBDaGFpbnNbXCJMaXRlY29pbk1haW5uZXRcIl0gPSBcIkxpdGVjb2luXCI7XG4gIENoYWluc1tcIkxpdGVjb2luVGVzdG5ldFwiXSA9IFwiTGl0ZWNvaW4gKFRlc3RuZXQpXCI7XG4gIENoYWluc1tcIkJpdGNvaW5DYXNoTWFpbm5ldFwiXSA9IFwiQml0Y29pbiBDYXNoXCI7XG4gIENoYWluc1tcIkJpdGNvaW5DYXNoVGVzdG5ldFwiXSA9IFwiQml0Y29pbiBDYXNoIChUZXN0bmV0KVwiO1xuICBDaGFpbnNbXCJTdGVsbGFyTWFpbm5ldFwiXSA9IFwiU3RlbGxhclwiO1xuICBDaGFpbnNbXCJTdGVsbGFyVGVzdG5ldFwiXSA9IFwiU3RlbGxhciAoVGVzdG5ldClcIjtcbiAgQ2hhaW5zW1wiUHJvdG9uTWFpbm5ldFwiXSA9IFwiUHJvdG9uXCI7XG4gIENoYWluc1tcIlByb3RvblRlc3RuZXRcIl0gPSBcIlByb3RvbiAoVGVzdG5ldClcIjtcbiAgQ2hhaW5zW1wiUG9sa2Fkb3RNYWlubmV0XCJdID0gXCJQb2xrYWRvdFwiO1xuICBDaGFpbnNbXCJCaW5hbmNlQkVQMlwiXSA9IFwiQmluYW5jZSAoQkVQMilcIjtcbiAgQ2hhaW5zW1wiQmluYW5jZUJFUDIwXCJdID0gXCJCaW5hbmNlIChCRVAyMClcIjtcbiAgQ2hhaW5zW1wiRW9zTWFpbm5ldFwiXSA9IFwiRU9TXCI7XG4gIENoYWluc1tcIkVvc1Rlc3RuZXRcIl0gPSBcIkVPUyAoSnVuZ2xlIFRlc3RuZXQpXCI7XG4gIENoYWluc1tcIkhlZGVyYU1haW5uZXRcIl0gPSBcIkhlZGVyYSAoTWFpbm5ldClcIjtcbiAgQ2hhaW5zW1wiSGVkZXJhVGVzdG5ldFwiXSA9IFwiSGVkZXJhIChUZXN0bmV0KVwiO1xuICBDaGFpbnNbXCJEb2dlTWFpbm5ldFwiXSA9IFwiRG9nZWNvaW5cIjtcbiAgQ2hhaW5zW1wiQ2FyZGFub01haW5uZXRcIl0gPSBcIkNhcmRhbm9cIjtcbiAgQ2hhaW5zW1wiQXZhbGFuY2hlWENoYWluXCJdID0gXCJBdmFsYW5jaGUgWC1DaGFpblwiO1xuICBDaGFpbnNbXCJBdmFsYW5jaGVDQ2hhaW5cIl0gPSBcIkF2YWxhbmNoZSBDLUNoYWluXCI7XG4gIENoYWluc1tcIlBvbHlnb25NYWlubmV0XCJdID0gXCJQb2x5Z29uXCI7XG4gIENoYWluc1tcIlRlcnJhTWFpbm5ldFwiXSA9IFwiVGVycmFcIjtcbn0pKENoYWlucyB8fCAoQ2hhaW5zID0ge30pKTtcblxudmFyIE5ldHdvcmtzO1xuXG4oZnVuY3Rpb24gKE5ldHdvcmtzKSB7XG4gIE5ldHdvcmtzW1wiTWFpbm5ldFwiXSA9IFwibWFpbm5ldFwiO1xuICBOZXR3b3Jrc1tcIlRlc3RuZXRcIl0gPSBcInRlc3RuZXRcIjtcbiAgTmV0d29ya3NbXCJSb3BzdGVuXCJdID0gXCJyb3BzdGVuXCI7XG4gIE5ldHdvcmtzW1wiRVJDMjBcIl0gPSBcImVyYzIwXCI7XG4gIE5ldHdvcmtzW1wiQkVQMjBcIl0gPSBcImJlcDIwXCI7XG4gIE5ldHdvcmtzW1wiWExNXCJdID0gXCJ4bG1cIjtcbn0pKE5ldHdvcmtzIHx8IChOZXR3b3JrcyA9IHt9KSk7XG5cbnZhciBzaW1pbGFyQ2hhaW5zID0gKF9zaW1pbGFyQ2hhaW5zID0ge30sIF9zaW1pbGFyQ2hhaW5zW0NoYWlucy5FdGhlcmV1bU1haW5uZXRdID0gW0NoYWlucy5CaW5hbmNlQkVQMjBdLCBfc2ltaWxhckNoYWluc1tDaGFpbnMuQmluYW5jZUJFUDIwXSA9IFtDaGFpbnMuRXRoZXJldW1NYWlubmV0XSwgX3NpbWlsYXJDaGFpbnMpO1xudmFyIGV4cGxvcmVyTGlua0J5Q2hhaW4gPSAoX2V4cGxvcmVyTGlua0J5Q2hhaW4gPSB7fSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkJpdGNvaW5NYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmxvY2tjaGFpbi5jb20vYnRjL3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5CaXRjb2luVGVzdG5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2Jsb2Nrc3RyZWFtLmluZm8vdGVzdG5ldC90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuRXRoZXJldW1NYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vZXRoZXJzY2FuLmlvL3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5FdGhlcmV1bVJvcHN0ZW5dID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9yb3BzdGVuLmV0aGVyc2Nhbi5pby90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuTGl0ZWNvaW5NYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmxvY2tjaGFpci5jb20vbGl0ZWNvaW4vdHJhbnNhY3Rpb24vXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkxpdGVjb2luVGVzdG5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2Jsb2NrZXhwbG9yZXIub25lL2xpdGVjb2luL3Rlc3RuZXQvYmxvY2tIYXNoL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5CaXRjb2luQ2FzaE1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ibG9ja2NoYWlyLmNvbS9iaXRjb2luLWNhc2gvdHJhbnNhY3Rpb24vXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkJpdGNvaW5DYXNoVGVzdG5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2Jsb2NrZXhwbG9yZXIub25lL2JpdGNvaW4tY2FzaC90ZXN0bmV0L2Jsb2NrSGFzaC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuU3RlbGxhck1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ibG9ja2NoYWlyLmNvbS9zdGVsbGFyL3RyYW5zYWN0aW9uL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5TdGVsbGFyVGVzdG5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL3Rlc3RuZXQuc3RlZXhwLmNvbS90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuUHJvdG9uTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL3Byb3Rvbi5ibG9rcy5pby90cmFuc2FjdGlvbi9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuUHJvdG9uVGVzdG5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL3Byb3Rvbi10ZXN0LmJsb2tzLmlvL3RyYW5zYWN0aW9uL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5Qb2xrYWRvdE1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9wb2xrYWRvdC5zdWJzY2FuLmlvL2V4dHJpbnNpYy9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuQmluYW5jZUJFUDJdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9iaW5hbmNlLm1pbnRzY2FuLmlvL3R4cy9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuQmluYW5jZUJFUDIwXSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYnNjc2Nhbi5jb20vdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkVvc01haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ibG9rcy5pby90cmFuc2FjdGlvbi9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuRW9zVGVzdG5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2p1bmdsZS5ibG9rcy5pby90cmFuc2FjdGlvbi9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuSGVkZXJhTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2FwcC5kcmFnb25nbGFzcy5tZS90cmFuc2FjdGlvbnMvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkhlZGVyYVRlc3RuZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly90ZXN0bmV0LmRyYWdvbmdsYXNzLm1lL3RyYW5zYWN0aW9ucy9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuRG9nZU1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ibG9ja2NoYWlyLmNvbS9kb2dlY29pbi90cmFuc2FjdGlvbi9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuQ2FyZGFub01haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9leHBsb3Jlci5jYXJkYW5vLm9yZy9lbi90cmFuc2FjdGlvbj9pZD1cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuQXZhbGFuY2hlWENoYWluXSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYXZhc2Nhbi5pbmZvL2Jsb2NrY2hhaW4veC90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuQXZhbGFuY2hlQ0NoYWluXSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vc25vd3RyYWNlLmlvL3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5Qb2x5Z29uTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL3BvbHlnb25zY2FuLmNvbS90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuVGVycmFNYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vdGVycmEuc3Rha2UuaWQvPyMvdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW4pO1xudmFyIGluaXRpYWxpemVDb2lucyA9IGZ1bmN0aW9uIGluaXRpYWxpemVDb2lucyhwcm90b25DaGFpbikge1xuICB2YXIgSVNfTUFJTk5FVCA9IHByb3RvbkNoYWluID09PSAncHJvdG9uJztcbiAgdmFyIElTX1RFU1RORVQgPSBwcm90b25DaGFpbiA9PT0gJ3Byb3Rvbi10ZXN0JztcbiAgdmFyIGNvaW5zID0gW3tcbiAgICBhbGxvd1N3YXA6IHRydWUsXG4gICAgYWxsb3dCcmlkZ2U6IElTX01BSU5ORVQsXG4gICAgYWxsb3dMZW5kOiB0cnVlLFxuICAgIGFsbG93Qm9ycm93OiB0cnVlLFxuICAgIG5hbWU6ICdQcm90b24nLFxuICAgIGNvaW46ICdYUFInLFxuICAgIHh0b2tlblN5bWJvbDogJ1hQUicsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA0LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAnZW9zaW8udG9rZW4nLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1hQUi1FUkMyMCcsXG4gICAgICBzeW1ib2w6ICdYUFInLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogNCxcbiAgICAgIGNvbnRyYWN0OiAnMHhEN0VGQjAwRDEyQzJDMTMxMzFGRDMxOTMzNkZERjk1MjUyNURBMkFGJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9LCB7XG4gICAgICB3YWxsZXQ6ICdYUFItQkVQMjAnLFxuICAgICAgc3ltYm9sOiAnWFBSJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQmluYW5jZUJFUDIwLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuQkVQMjAsXG4gICAgICBwcmVjaXNpb246IDQsXG4gICAgICBjb250cmFjdDogJzB4NURFMzkzOUIyRjgxMUE2MUQ4MzBFNkY1MkQxM0IwNjY4ODE0MTJBQicsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy9lb3Npby10b2tlblhQUi5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAncHJvdG9uJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiB0cnVlLFxuICAgIGFsbG93QnJpZGdlOiB0cnVlLFxuICAgIGFsbG93TGVuZDogdHJ1ZSxcbiAgICBhbGxvd0JvcnJvdzogdHJ1ZSxcbiAgICBuYW1lOiAnVVNEIENvaW4nLFxuICAgIGNvaW46ICdVU0RDJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYVVNEQycsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnVVNEQycsXG4gICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDYsXG4gICAgICBjb250cmFjdDogJzB4QTBCODY5OTFDNjIxOEIzNkMxRDE5RDRBMkU5RUIwQ0UzNjA2RUI0OCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfSwge1xuICAgICAgd2FsbGV0OiAnVVNEQy1CRVAyMCcsXG4gICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQmluYW5jZUJFUDIwLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuQkVQMjAsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDhBQzc2QTUxQ0M5NTBEOTgyMkQ2OEI4M0ZFMUFEOTdCMzJDRDU4MEQnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHdhbGxldDogJ1VTREMtWExNJyxcbiAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgY2hhaW46IENoYWlucy5TdGVsbGFyTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlhMTSxcbiAgICAgIHByZWNpc2lvbjogNyxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IHRydWVcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1VTREMnLFxuICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtUm9wc3RlbixcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlJvcHN0ZW4sXG4gICAgICBwcmVjaXNpb246IDYsXG4gICAgICBjb250cmFjdDogJzB4QTBCODY5OTFDNjIxOEIzNkMxRDE5RDRBMkU5RUIwQ0UzNjA2RUI0OCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWFVTREMucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3VzZC1jb2luJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiB0cnVlLFxuICAgIGFsbG93QnJpZGdlOiBJU19NQUlOTkVULFxuICAgIGFsbG93TGVuZDogdHJ1ZSxcbiAgICBhbGxvd0JvcnJvdzogdHJ1ZSxcbiAgICBuYW1lOiAnTWV0YWwnLFxuICAgIGNvaW46ICdNVEwnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hNVCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA4LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnTVRMJyxcbiAgICAgIHN5bWJvbDogJ01UTCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiA4LFxuICAgICAgY29udHJhY3Q6ICcweEY0MzMwODkzNjY4OTlEODNBOUYyNkE3NzNENTlFQzdFQ0YzMDM1NUUnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hNVC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnbWV0YWwnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IHRydWUsXG4gICAgYWxsb3dCcmlkZ2U6IHRydWUsXG4gICAgYWxsb3dMZW5kOiB0cnVlLFxuICAgIGFsbG93Qm9ycm93OiB0cnVlLFxuICAgIG5hbWU6ICdCaXRjb2luJyxcbiAgICBjb2luOiAnQlRDJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYQlRDJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDgsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdCVEMnLFxuICAgICAgc3ltYm9sOiAnQlRDJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQml0Y29pbk1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA4LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0JUQycsXG4gICAgICBzeW1ib2w6ICdCVEMnLFxuICAgICAgY2hhaW46IENoYWlucy5CaXRjb2luVGVzdG5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlRlc3RuZXQsXG4gICAgICBwcmVjaXNpb246IDgsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hCVEMucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2JpdGNvaW4nXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IHRydWUsXG4gICAgYWxsb3dCcmlkZ2U6IHRydWUsXG4gICAgYWxsb3dMZW5kOiB0cnVlLFxuICAgIGFsbG93Qm9ycm93OiB0cnVlLFxuICAgIG5hbWU6ICdFdGhlcmV1bScsXG4gICAgY29pbjogJ0VUSCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWEVUSCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA4LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnRVRIJyxcbiAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnRVRIJyxcbiAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtUm9wc3RlbixcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlJvcHN0ZW4sXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hFVEgucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2V0aGVyZXVtJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiB0cnVlLFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnTG9hbicsXG4gICAgY29pbjogJ0xPQU4nLFxuICAgIHh0b2tlblN5bWJvbDogJ0xPQU4nLFxuICAgIHh0b2tlblByZWNpc2lvbjogNCxcbiAgICB4dG9rZW5Db250cmFjdDogJ2xvYW4udG9rZW4nLFxuICAgIHdhbGxldHM6IFtdLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMvbG9hbi50b2tlbkxPQU4ucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3Byb3Rvbi1sb2FuJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBJU19NQUlOTkVULFxuICAgIGFsbG93QnJpZGdlOiB0cnVlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdUZXRoZXInLFxuICAgIGNvaW46ICdVU0RUJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYVVNEVCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnVVNEVCcsXG4gICAgICBzeW1ib2w6ICdVU0RUJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDYsXG4gICAgICBjb250cmFjdDogJzB4REFDMTdGOTU4RDJFRTUyM0EyMjA2MjA2OTk0NTk3QzEzRDgzMUVDNycsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdVU0RUJyxcbiAgICAgIHN5bWJvbDogJ1VTRFQnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bVJvcHN0ZW4sXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5Sb3BzdGVuLFxuICAgICAgcHJlY2lzaW9uOiA2LFxuICAgICAgY29udHJhY3Q6ICcweERBQzE3Rjk1OEQyRUU1MjNBMjIwNjIwNjk5NDU5N0MxM0Q4MzFFQzcnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hVU0RULnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICd0ZXRoZXInXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBJU19NQUlOTkVULFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdUcnVlVVNEJyxcbiAgICBjb2luOiAnVFVTRCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWFRVU0QnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1RVU0QnLFxuICAgICAgc3ltYm9sOiAnVFVTRCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHgwMDAwMDAwMDAwMDg1RDQ3ODBCNzMxMTlCNjQ0QUU1RUNEMjJCMzc2JyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYVFVTRC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAndHJ1ZS11c2QnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBJU19NQUlOTkVULFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdQYXhvcyBTdGFuZGFyZCcsXG4gICAgY29pbjogJ1BBWCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWFBBWCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnUEFYJyxcbiAgICAgIHN5bWJvbDogJ1BBWCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHg4RTg3MEQ2N0Y2NjBEOTVENUJFNTMwMzgwRDBFQzBCRDM4ODI4OUUxJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYUEFYLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICd1c2RwJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogdHJ1ZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnUGF4b3MgR29sZCcsXG4gICAgY29pbjogJ1BBWEcnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hQQVhHJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDgsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdQQVhHJyxcbiAgICAgIHN5bWJvbDogJ1BBWEcnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4NDU4MDQ4ODBERTIyOTEzREFGRTA5RjQ5ODA4NDhFQ0U2RUNCQUY3OCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdQQVhHJyxcbiAgICAgIHN5bWJvbDogJ1BBWEcnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bVJvcHN0ZW4sXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5Sb3BzdGVuLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHg0NTgwNDg4MERFMjI5MTNEQUZFMDlGNDk4MDg0OEVDRTZFQ0JBRjc4JyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYUEFYRy5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAncGF4LWdvbGQnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IElTX01BSU5ORVQsXG4gICAgYWxsb3dCcmlkZ2U6IHRydWUsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1VuaXN3YXAnLFxuICAgIGNvaW46ICdVTkknLFxuICAgIHh0b2tlblN5bWJvbDogJ1hVTkknLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1VOSScsXG4gICAgICBzeW1ib2w6ICdVTkknLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4MUY5ODQwQTg1RDVBRjVCRjFEMTc2MkY5MjVCREFEREM0MjAxRjk4NCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdVTkknLFxuICAgICAgc3ltYm9sOiAnVU5JJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1Sb3BzdGVuLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuUm9wc3RlbixcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4MUY5ODQwQTg1RDVBRjVCRjFEMTc2MkY5MjVCREFEREM0MjAxRjk4NCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWFVOSS5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAndW5pc3dhcCdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICcxSU5DSCcsXG4gICAgY29pbjogJzFJTkNIJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYSU5DSCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnMUlOQ0gnLFxuICAgICAgc3ltYm9sOiAnMUlOQ0gnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4MTExMTExMTExMTE3REMwQUE3OEI3NzBGQTZBNzM4MDM0MTIwQzMwMicsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWElOQ0gucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJzFpbmNoJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0NoYWlubGluaycsXG4gICAgY29pbjogJ0xJTksnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hMSU5LJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdMSU5LJyxcbiAgICAgIHN5bWJvbDogJ0xJTksnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4NTE0OTEwNzcxQUY5Q0E2NTZBRjg0MERGRjgzRTgyNjRFQ0Y5ODZDQScsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWExJTksucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2NoYWlubGluaydcbiAgfSwge1xuICAgIGFsbG93U3dhcDogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0JyaWRnZTogdHJ1ZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnTGl0ZWNvaW4nLFxuICAgIGNvaW46ICdMVEMnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hMVEMnLFxuICAgIHh0b2tlblByZWNpc2lvbjogOCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0xUQycsXG4gICAgICBzeW1ib2w6ICdMVEMnLFxuICAgICAgY2hhaW46IENoYWlucy5MaXRlY29pbk1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA4LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0xUQycsXG4gICAgICBzeW1ib2w6ICdMVEMnLFxuICAgICAgY2hhaW46IENoYWlucy5MaXRlY29pblRlc3RuZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5UZXN0bmV0LFxuICAgICAgcHJlY2lzaW9uOiA4LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYTFRDLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdsaXRlY29pbidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0JyaWRnZTogdHJ1ZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnQml0Y29pbiBDYXNoJyxcbiAgICBjb2luOiAnQkNIJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYQkNIJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDgsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdCQ0gnLFxuICAgICAgc3ltYm9sOiAnQkNIJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQml0Y29pbkNhc2hNYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogOCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdCQ0gnLFxuICAgICAgc3ltYm9sOiAnQkNIJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQml0Y29pbkNhc2hUZXN0bmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuVGVzdG5ldCxcbiAgICAgIHByZWNpc2lvbjogOCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWEJDSC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnYml0Y29pbi1jYXNoJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1N0ZWxsYXInLFxuICAgIGNvaW46ICdYTE0nLFxuICAgIHh0b2tlblN5bWJvbDogJ1hYTE0nLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1hMTScsXG4gICAgICBzeW1ib2w6ICdYTE0nLFxuICAgICAgY2hhaW46IENoYWlucy5TdGVsbGFyTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDcsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiB0cnVlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdYTE0nLFxuICAgICAgc3ltYm9sOiAnWExNJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuU3RlbGxhclRlc3RuZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5UZXN0bmV0LFxuICAgICAgcHJlY2lzaW9uOiA3LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogdHJ1ZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hYTE0ucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3N0ZWxsYXInXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IElTX01BSU5ORVQsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdTZW5zZScsXG4gICAgY29pbjogJ1NFTlNFJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYU0VOU0UnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3NlbnNlJyxcbiAgICB3YWxsZXRzOiBbXSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3NlbnNlWFNFTlNFLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdzZW5zZSdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdQb2xrYWRvdCcsXG4gICAgY29pbjogJ0RPVCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWERPVCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA4LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnRE9UJyxcbiAgICAgIHN5bWJvbDogJ0RPVCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLlBvbGthZG90TWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDEwLFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYRE9ULnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdwb2xrYWRvdCdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogdHJ1ZSxcbiAgICBhbGxvd0JyaWRnZTogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnQmluYW5jZSBDb2luJyxcbiAgICBjb2luOiAnQk5CJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYQk5CJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDgsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdCTkInLFxuICAgICAgc3ltYm9sOiAnQk5CJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQmluYW5jZUJFUDIwLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuQkVQMjAsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYQk5CLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdiaW5hbmNlY29pbidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogdHJ1ZSxcbiAgICBhbGxvd0JyaWRnZTogdHJ1ZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnRU9TJyxcbiAgICBjb2luOiAnRU9TJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYRU9TJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDQsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdFT1MnLFxuICAgICAgc3ltYm9sOiAnRU9TJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRW9zTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDQsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiB0cnVlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdFT1MnLFxuICAgICAgc3ltYm9sOiAnRU9TJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRW9zVGVzdG5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlRlc3RuZXQsXG4gICAgICBwcmVjaXNpb246IDQsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiB0cnVlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWEVPUy5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnZW9zJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBJU19NQUlOTkVULFxuICAgIGFsbG93QnJpZGdlOiBJU19NQUlOTkVULFxuICAgIGFsbG93TGVuZDogdHJ1ZSxcbiAgICBhbGxvd0JvcnJvdzogdHJ1ZSxcbiAgICBuYW1lOiAnRG9nZWNvaW4nLFxuICAgIGNvaW46ICdET0dFJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYRE9HRScsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnRE9HRScsXG4gICAgICBzeW1ib2w6ICdET0dFJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRG9nZU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA4LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYRE9HRS5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnZG9nZWNvaW4nXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IElTX01BSU5ORVQsXG4gICAgYWxsb3dCcmlkZ2U6IElTX01BSU5ORVQsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0NhcmRhbm8nLFxuICAgIGNvaW46ICdBREEnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hBREEnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0FEQScsXG4gICAgICBzeW1ib2w6ICdBREEnLFxuICAgICAgY2hhaW46IENoYWlucy5DYXJkYW5vTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDYsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hBREEucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2NhcmRhbm8nXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnQXZhbGFuY2hlJyxcbiAgICBjb2luOiAnQVZBWCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWEFWQVgnLFxuICAgIHh0b2tlblByZWNpc2lvbjogOSxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0FWQVgnLFxuICAgICAgc3ltYm9sOiAnQVZBWCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkF2YWxhbmNoZVhDaGFpbixcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDksXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHdhbGxldDogJ0FWQVgnLFxuICAgICAgc3ltYm9sOiAnQVZBWCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkF2YWxhbmNoZUNDaGFpbixcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDksXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hBVkFYLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdhdmFsYW5jaGUtMidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdQb2x5Z29uJyxcbiAgICBjb2luOiAnTUFUSUMnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hNQVRJQycsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA4LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnTUFUSUMnLFxuICAgICAgc3ltYm9sOiAnTUFUSUMnLFxuICAgICAgY2hhaW46IENoYWlucy5Qb2x5Z29uTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hNQVRJQy5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnbWF0aWMtbmV0d29yaydcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdMdW5hJyxcbiAgICBjb2luOiAnTFVOQScsXG4gICAgeHRva2VuU3ltYm9sOiAnWExVTkEnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0xVTkEnLFxuICAgICAgc3ltYm9sOiAnTFVOQScsXG4gICAgICBjaGFpbjogQ2hhaW5zLlRlcnJhTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDYsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiB0cnVlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWExVTkEucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3RlcnJhLWx1bmEnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnVGVycmFVU0QnLFxuICAgIGNvaW46ICdVU1QnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hVU1QnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1VTVCcsXG4gICAgICBzeW1ib2w6ICdVU1QnLFxuICAgICAgY2hhaW46IENoYWlucy5UZXJyYU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA2LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogdHJ1ZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hVU1QucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3RlcnJhdXNkJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogSVNfVEVTVE5FVCxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnSEJBUicsXG4gICAgY29pbjogJ0hCQVInLFxuICAgIHh0b2tlblN5bWJvbDogJ1hIQkFSJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdIQkFSJyxcbiAgICAgIHN5bWJvbDogJ0hCQVInLFxuICAgICAgY2hhaW46IENoYWlucy5IZWRlcmFUZXN0bmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuVGVzdG5ldCxcbiAgICAgIHByZWNpc2lvbjogOCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IHRydWVcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYSEJBUi5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnaGVkZXJhLWhhc2hncmFwaCdcbiAgfV07IC8vIFZhbGlkYXRpb25cblxuICB2YXIgd2FsbGV0V2l0aER1cGxpY2F0ZUNoYWlucyA9IGNvaW5zLmZpbmQoZnVuY3Rpb24gKGNvaW4pIHtcbiAgICB2YXIgY2hhaW5zID0gY29pbi53YWxsZXRzLm1hcChmdW5jdGlvbiAod2FsbGV0KSB7XG4gICAgICByZXR1cm4gd2FsbGV0LmNoYWluO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgU2V0KGNoYWlucykuc2l6ZSAhPT0gY2hhaW5zLmxlbmd0aDtcbiAgfSk7XG5cbiAgaWYgKHdhbGxldFdpdGhEdXBsaWNhdGVDaGFpbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2luIFwiICsgd2FsbGV0V2l0aER1cGxpY2F0ZUNoYWlucy5jb2luICsgXCIgaGFzIGR1cGxpY2F0ZSBjaGFpbnMgaW4gd2FsbGV0XCIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhbGxDb2luczogY29pbnMsXG4gICAgc3dhcENvaW5zOiBjb2lucy5maWx0ZXIoZnVuY3Rpb24gKGNvaW4pIHtcbiAgICAgIHJldHVybiBjb2luLmFsbG93U3dhcDtcbiAgICB9KSxcbiAgICBicmlkZ2VDb2luczogY29pbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2luKSB7XG4gICAgICByZXR1cm4gY29pbi5hbGxvd0JyaWRnZTtcbiAgICB9KSxcbiAgICBsZW5kQ29pbnM6IGNvaW5zLmZpbHRlcihmdW5jdGlvbiAoY29pbikge1xuICAgICAgcmV0dXJuIGNvaW4uYWxsb3dMZW5kO1xuICAgIH0pLFxuICAgIGJvcnJvd0NvaW5zOiBjb2lucy5maWx0ZXIoZnVuY3Rpb24gKGNvaW4pIHtcbiAgICAgIHJldHVybiBjb2luLmFsbG93Qm9ycm93O1xuICAgIH0pLFxuICAgIGxvYW5Db2luczogY29pbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2luKSB7XG4gICAgICByZXR1cm4gY29pbi5hbGxvd0xlbmQgfHwgY29pbi5hbGxvd0JvcnJvdztcbiAgICB9KSxcbiAgICBhbGxFbmFibGVkQ29pbnM6IGNvaW5zLmZpbHRlcihmdW5jdGlvbiAoY29pbikge1xuICAgICAgcmV0dXJuIGNvaW4uYWxsb3dTd2FwIHx8IGNvaW4uYWxsb3dCcmlkZ2U7XG4gICAgfSlcbiAgfTtcbn07XG5cbnZhciBhY2NvdW50UGFyc2VyID0gLyojX19QVVJFX18qL3N0cmluZygpLnJlZ2V4KC9eWy4xLTVhLXpdezAsMTJ9Wy4xLTVhLWpdPyQvKTtcbnZhciBhdXRob3JpemF0aW9uUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGFjdG9yOiBhY2NvdW50UGFyc2VyLFxuICBwZXJtaXNzaW9uOiAvKiNfX1BVUkVfXyovc3RyaW5nKClcbn0pO1xudmFyIGF1dGhvcml6YXRpb25zUGFyc2VyID0gLyojX19QVVJFX18qL2FycmF5KGF1dGhvcml6YXRpb25QYXJzZXIpLm1pbigxKTtcbnZhciBFeHRlbmRlZEFzc2V0UGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIHF1YW50aXR5OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNvbnRyYWN0OiBhY2NvdW50UGFyc2VyXG59KTtcblxudmFyIHJhd1RyYW5zYWN0aW9uUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGV4cGlyYXRpb246IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgcmVmX2Jsb2NrX251bTogLyojX19QVVJFX18qL251bWJlcigpLFxuICByZWZfYmxvY2tfcHJlZml4OiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIG1heF9uZXRfdXNhZ2Vfd29yZHM6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgbWF4X2NwdV91c2FnZV9tczogLyojX19QVVJFX18qL251bWJlcigpLFxuICBkZWxheV9zZWM6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgY29udGV4dF9mcmVlX2FjdGlvbnM6IC8qI19fUFVSRV9fKi9hcnJheSggLyojX19QVVJFX18qL2FueSgpKSxcbiAgdHJhbnNhY3Rpb25fZXh0ZW5zaW9uczogLyojX19QVVJFX18qL2FycmF5KCAvKiNfX1BVUkVfXyovYW55KCkpXG59KTtcbnZhciBiYXNlQWN0aW9uUGFyc2VyID0gZnVuY3Rpb24gYmFzZUFjdGlvblBhcnNlcihjb250cmFjdCwgYWN0aW9uLCBkYXRhKSB7XG4gIHJldHVybiBvYmplY3Qoe1xuICAgIGFjY291bnQ6IGNvbnRyYWN0ID09PSAnKicgPyBhY2NvdW50UGFyc2VyIDogbGl0ZXJhbChjb250cmFjdCksXG4gICAgbmFtZTogbGl0ZXJhbChhY3Rpb24pLFxuICAgIGRhdGE6IG9iamVjdChkYXRhKSxcbiAgICBhdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uc1BhcnNlclxuICB9KTtcbn07XG52YXIgYmFzZUFjdGlvblNlcmlhbGl6ZWRQYXJzZXIgPSBmdW5jdGlvbiBiYXNlQWN0aW9uU2VyaWFsaXplZFBhcnNlcihjb250cmFjdCwgYWN0aW9uLCBkYXRhKSB7XG4gIHJldHVybiBvYmplY3Qoe1xuICAgIGFjY291bnQ6IGNvbnRyYWN0ID09PSAnKicgPyBhY2NvdW50UGFyc2VyIDogbGl0ZXJhbChjb250cmFjdCksXG4gICAgbmFtZTogbGl0ZXJhbChhY3Rpb24pLFxuICAgIGRhdGE6IHN0cmluZygpLm9yKG9iamVjdChkYXRhKSksXG4gICAgYXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbnNQYXJzZXJcbiAgfSk7XG59O1xudmFyIHdlYmF1dGhBY3Rpb25QYXJzZXIgPSBmdW5jdGlvbiB3ZWJhdXRoQWN0aW9uUGFyc2VyKGNvbnRyYWN0LCBhY3Rpb24sIGRhdGEpIHtcbiAgcmV0dXJuIG9iamVjdCh7XG4gICAgYWNjb3VudDogbGl0ZXJhbCgnd2ViYXV0aG4nKSxcbiAgICBuYW1lOiBsaXRlcmFsKCdleGVjJyksXG4gICAgZGF0YTogb2JqZWN0KHtcbiAgICAgIGFjY291bnQ6IGFjY291bnRQYXJzZXIsXG4gICAgICBrZXk6IG9iamVjdCh7XG4gICAgICAgIGtleTogYXJyYXkoc3RyaW5nKCkub3Iob2JqZWN0KHtcbiAgICAgICAgICBtb2R1bHVzOiBzdHJpbmcoKSxcbiAgICAgICAgICBleHBvbmVudDogc3RyaW5nKClcbiAgICAgICAgfSkpKSxcbiAgICAgICAgdXNlcl9wcmVzZW5jZTogbnVtYmVyKCksXG4gICAgICAgIHJwaWQ6IHN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIG5vbmNlOiBudW1iZXIoKSxcbiAgICAgIHBlcm1pc3Npb25zOiBhdXRob3JpemF0aW9uc1BhcnNlcixcbiAgICAgIHNpZ25hdHVyZTogb2JqZWN0KHtcbiAgICAgICAgYXV0aF9kYXRhOiBzdHJpbmcoKSxcbiAgICAgICAgY2xpZW50X2pzb246IHN0cmluZygpLFxuICAgICAgICBzaWduYXR1cmU6IHN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIHRyeDogcmF3VHJhbnNhY3Rpb25QYXJzZXIubWVyZ2Uob2JqZWN0KHtcbiAgICAgICAgYWN0aW9uczogYXJyYXkoYmFzZUFjdGlvblNlcmlhbGl6ZWRQYXJzZXIoY29udHJhY3QsIGFjdGlvbiwgZGF0YSkpLmxlbmd0aCgxKVxuICAgICAgfSkpXG4gICAgfSksXG4gICAgYXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbnNQYXJzZXJcbiAgfSk7XG59O1xudmFyIHNpbmdsZUFjdGlvblRyYW5zYWN0aW9uUGFyc2VyID0gZnVuY3Rpb24gc2luZ2xlQWN0aW9uVHJhbnNhY3Rpb25QYXJzZXIoY29udHJhY3QsIGFjdGlvbiwgZGF0YSkge1xuICB2YXIgYmFzZUFjdGlvbiA9IGJhc2VBY3Rpb25QYXJzZXIoY29udHJhY3QsIGFjdGlvbiwgZGF0YSk7XG4gIHZhciB3ZWJhdXRoQWN0aW9uID0gd2ViYXV0aEFjdGlvblBhcnNlcihjb250cmFjdCwgYWN0aW9uLCBkYXRhKTtcbiAgcmV0dXJuIHJhd1RyYW5zYWN0aW9uUGFyc2VyLm1lcmdlKG9iamVjdCh7XG4gICAgYWN0aW9uczogYXJyYXkoYmFzZUFjdGlvbi5vcih3ZWJhdXRoQWN0aW9uKSkubGVuZ3RoKDEpXG4gIH0pKTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBXUkFQX0NPTlRSQUNUID0gJ3Byb3Rvbi53cmFwJztcbnZhciBXUkFQX0FVVEhfQUNUSU9OID0gJ2dlbmVyYXRlYXV0aCc7XG52YXIgaW5pdGlhbGl6ZUNvbnN0YW50cyA9IGZ1bmN0aW9uIGluaXRpYWxpemVDb25zdGFudHMoY2hhaW4pIHtcbiAgdmFyIF9pbml0aWFsaXplQ29pbnMgPSBpbml0aWFsaXplQ29pbnMoY2hhaW4pLFxuICAgICAgc3dhcENvaW5zID0gX2luaXRpYWxpemVDb2lucy5zd2FwQ29pbnMsXG4gICAgICBicmlkZ2VDb2lucyA9IF9pbml0aWFsaXplQ29pbnMuYnJpZGdlQ29pbnMsXG4gICAgICBhbGxFbmFibGVkQ29pbnMgPSBfaW5pdGlhbGl6ZUNvaW5zLmFsbEVuYWJsZWRDb2lucyxcbiAgICAgIGFsbENvaW5zID0gX2luaXRpYWxpemVDb2lucy5hbGxDb2lucyxcbiAgICAgIGxlbmRDb2lucyA9IF9pbml0aWFsaXplQ29pbnMubGVuZENvaW5zLFxuICAgICAgYm9ycm93Q29pbnMgPSBfaW5pdGlhbGl6ZUNvaW5zLmJvcnJvd0NvaW5zLFxuICAgICAgbG9hbkNvaW5zID0gX2luaXRpYWxpemVDb2lucy5sb2FuQ29pbnM7XG5cbiAgdmFyIGNvbnN0YW50cyA9IHtcbiAgICBTV0FQX0NPTlRSQUNUOiAncHJvdG9uLnN3YXBzJyxcbiAgICBGRUVfRkFDVE9SOiAxMDAwMCxcbiAgICBHT09HTEVfTUFQU19LRVk6ICdBSXphU3lEYjJfQ3JLMDMya1NJcUJYYmtkd21hTEtXRUxsMFN4VnMnLFxuICAgIFNXQVBfVVJMOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyAnaHR0cHM6Ly9vdGMucHJvdG9uc3dhcC5jb20nIDogJ2h0dHBzOi8vb3RjLXRlc3QucHJvdG9uc3dhcC5jb20nLFxuICAgIFdSQVBfU0VSVkVSX1VSTDogY2hhaW4gPT09ICdwcm90b24nID8gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9wcm90b24td3JhcC1wdWJsaWMyJyA6ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vcHJvdG9uLXdyYXAtdGVzdG5ldC1wdWJsaWMyJyxcbiAgICBXUkFQX0NPTlRSQUNUOiBXUkFQX0NPTlRSQUNULFxuICAgIFdSQVBfQUNUSU9OUzoge1xuICAgICAgU0FWRV9BRERSRVNTOiAnc2F2ZWFkZHJlc3MyJyxcbiAgICAgIERFTEVURV9BRERSRVNTOiAnZGVsYWRkcmVzczInLFxuICAgICAgV1JBUF9TVEFSVDogJ3dyYXBzdGFydDInLFxuICAgICAgV1JBUF9GSU5JU0g6ICd3cmFwZmluaXNoMicsXG4gICAgICBXUkFQX1BST0NFU1M6ICd3cmFwcHJvY2VzczInLFxuICAgICAgV1JBUF9TRVRfQ09ORjogJ3dyYXBzZXRjb25mMidcbiAgICB9LFxuICAgIFdSQVBfVEFCTEVTOiB7XG4gICAgICBBRERSRVNTRVM6ICdhZGRyZXNzZXMyJyxcbiAgICAgIFdSQVBTOiAnd3JhcHMyJ1xuICAgIH0sXG4gICAgQUREUkVTU0VTX0lOREVYRVM6IHtcbiAgICAgIEJZX0FDQ09VTlQ6IDIsXG4gICAgICBCWV9BRERSX0hBU0g6IDNcbiAgICB9LFxuICAgIFdSQVBTX0lOREVYRVM6IHtcbiAgICAgIEJZX0FDQ09VTlQ6IDIsXG4gICAgICBCWV9TVEFUVVM6IDMsXG4gICAgICBCWV9XUkFQX0hBU0g6IDRcbiAgICB9LFxuICAgIFdSQVBfUFJPQ0VTU19USU1FUjogNTAwMCxcbiAgICBGQVJNX0NPTlRSQUNUOiAneWllbGQuZmFybXMnLFxuICAgIFdFQkhPT0tfUEVSTUlTU0lPTjogJ3dlYmhvb2snLFxuICAgIFBVQkxJQ19QRVJNSVNTSU9OOiAncHVibGljJyxcbiAgICBMSUdIVF9QRVJNSVNTSU9OOiAnbGlnaHQnLFxuICAgIFdSQVBfQVVUSF9BQ1RJT046IFdSQVBfQVVUSF9BQ1RJT04sXG4gICAgTUVUQUxfRU5EUE9JTlQ6IGNoYWluID09PSAncHJvdG9uJyA/ICdodHRwczovL2NpcnJ1cy5tZXRhbHBheS5jb20nIDogJ2h0dHBzOi8vY2lycnVzLWRldi5tZXRhbHBheS5jb20nLFxuICAgIE1FVEFMX1BST1RPTl9FTkRQT0lOVDogY2hhaW4gPT09ICdwcm90b24nID8gJ2h0dHBzOi8vYXBpLnByb3RvbmNoYWluLmNvbScgOiAnaHR0cHM6Ly9hcGktZGV2LnByb3RvbmNoYWluLmNvbScsXG4gICAgUFJPVE9OX0VORFBPSU5UUzogY2hhaW4gPT09ICdwcm90b24nID8gWydodHRwczovL3Byb3Rvbi5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9wcm90b24uZW9zY2FmZWJsb2NrLmNvbScsICdodHRwczovL3Byb3Rvbi5jcnlwdG9saW9ucy5pbycsICdodHRwczovL3Byb3Rvbi5lb3N1c2EubmV3cyddIDogWydodHRwczovL3Rlc3RuZXQucHJvdG9uY2hhaW4uY29tJ10sXG4gICAgQ0hBSU5fSUQ6IGNoYWluID09PSAncHJvdG9uJyA/ICczODRkYTg4ODExMjAyN2YwMzIxODUwYTE2OWY3MzdjMzNlNTNiMzg4YWFkNDhiNWFkYWNlNGJhYjk3ZjQzN2UwJyA6ICc3MWVlODNiY2Y1MjE0MmQ2MTAxOWQ5NWY5Y2M1NDI3YmE2YTBkN2ZmOGFjY2Q5ZTIwODhhZTJhYmVhZjNkM2RkJyxcbiAgICBDSEFJTjogY2hhaW4sXG4gICAgU1dBUF9DT0lOUzogc3dhcENvaW5zLFxuICAgIEJSSURHRV9DT0lOUzogYnJpZGdlQ29pbnMsXG4gICAgQUxMX0VOQUJMRURfQ09JTlM6IGFsbEVuYWJsZWRDb2lucyxcbiAgICBMRU5EX0NPSU5TOiBsZW5kQ29pbnMsXG4gICAgQk9SUk9XX0NPSU5TOiBib3Jyb3dDb2lucyxcbiAgICBMT0FOX0NPSU5TOiBsb2FuQ29pbnMsXG4gICAgQUxMX0NPSU5TOiBhbGxDb2lucyxcbiAgICBmaW5kQnJpZGdlQ29pbldhbGxldEJ5WHRva2VuQW5kQ2hhaW46IGZ1bmN0aW9uIGZpbmRCcmlkZ2VDb2luV2FsbGV0QnlYdG9rZW5BbmRDaGFpbih4dG9rZW5TeW1ib2wsIGNoYWluKSB7XG4gICAgICB2YXIgYnJpZGdlQ29pbiA9IGNvbnN0YW50cy5CUklER0VfQ09JTlMuZmluZChmdW5jdGlvbiAoYnJpZGdlQ29pbikge1xuICAgICAgICByZXR1cm4gYnJpZGdlQ29pbi54dG9rZW5TeW1ib2wgPT09IHh0b2tlblN5bWJvbDtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFicmlkZ2VDb2luKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIGJyaWRnZVdhbGxldCA9IGJyaWRnZUNvaW4ud2FsbGV0cy5maW5kKGZ1bmN0aW9uIChicmlkZ2VXYWxsZXQpIHtcbiAgICAgICAgcmV0dXJuIGJyaWRnZVdhbGxldC5jaGFpbiA9PT0gY2hhaW47XG4gICAgICB9KTtcbiAgICAgIGlmICghYnJpZGdlV2FsbGV0KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBicmlkZ2VDb2luLCBicmlkZ2VXYWxsZXQpO1xuICAgIH0sXG4gICAgZmluZEJyaWRnZUNvaW5XYWxsZXQ6IGZ1bmN0aW9uIGZpbmRCcmlkZ2VDb2luV2FsbGV0KGNvaW4sIHdhbGxldCkge1xuICAgICAgdmFyIGJyaWRnZUNvaW4gPSBjb25zdGFudHMuQlJJREdFX0NPSU5TLmZpbmQoZnVuY3Rpb24gKGJyaWRnZUNvaW4pIHtcbiAgICAgICAgcmV0dXJuIGJyaWRnZUNvaW4uY29pbiA9PT0gY29pbjtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFicmlkZ2VDb2luKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIGJyaWRnZVdhbGxldCA9IGJyaWRnZUNvaW4ud2FsbGV0cy5maW5kKGZ1bmN0aW9uIChicmlkZ2VXYWxsZXQpIHtcbiAgICAgICAgcmV0dXJuIGJyaWRnZVdhbGxldC53YWxsZXQgPT09IHdhbGxldDtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFicmlkZ2VXYWxsZXQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGJyaWRnZUNvaW4sIGJyaWRnZVdhbGxldCk7XG4gICAgfSxcbiAgICBmaW5kQnJpZGdlQ29pbk5ldHdvcms6IGZ1bmN0aW9uIGZpbmRCcmlkZ2VDb2luTmV0d29yayhjb2luLCBuZXR3b3JrKSB7XG4gICAgICB2YXIgYnJpZGdlQ29pbiA9IGNvbnN0YW50cy5CUklER0VfQ09JTlMuZmluZChmdW5jdGlvbiAoYnJpZGdlQ29pbikge1xuICAgICAgICByZXR1cm4gYnJpZGdlQ29pbi5jb2luID09PSBjb2luO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWJyaWRnZUNvaW4pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgYnJpZGdlV2FsbGV0ID0gYnJpZGdlQ29pbi53YWxsZXRzLmZpbmQoZnVuY3Rpb24gKGJyaWRnZVdhbGxldCkge1xuICAgICAgICByZXR1cm4gYnJpZGdlV2FsbGV0Lm5ldHdvcmsgPT09IG5ldHdvcms7XG4gICAgICB9KTtcbiAgICAgIGlmICghYnJpZGdlV2FsbGV0KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBicmlkZ2VDb2luLCBicmlkZ2VXYWxsZXQpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGNvbnN0YW50cztcbn07XG5cbnZhciBjcmVhdGVBYnN0cmFjdEF1dGhQYXJzZXIgPSBmdW5jdGlvbiBjcmVhdGVBYnN0cmFjdEF1dGhQYXJzZXIoY29udHJhY3QsIGFjdGlvbiwgZGF0YSkge1xuICByZXR1cm4gb2JqZWN0KHtcbiAgICBzaWduZXI6IGF1dGhvcml6YXRpb25QYXJzZXIsXG4gICAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLmxlbmd0aCgxKSxcbiAgICB0cmFuc2FjdGlvbjogc2luZ2xlQWN0aW9uVHJhbnNhY3Rpb25QYXJzZXIoY29udHJhY3QsIGFjdGlvbiwgZGF0YSlcbiAgfSk7XG59O1xudmFyIGdlbmVyYXRlQXV0aERhdGEgPSB7XG4gIHRpbWU6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgcHJvdG9uQWNjb3VudDogLyojX19QVVJFX18qL3N0cmluZygpXG59O1xudmFyIGdlbmVyYXRlQXV0aFBhcnNlciA9IC8qI19fUFVSRV9fKi9jcmVhdGVBYnN0cmFjdEF1dGhQYXJzZXIoV1JBUF9DT05UUkFDVCwgV1JBUF9BVVRIX0FDVElPTiwgZ2VuZXJhdGVBdXRoRGF0YSk7XG5cbnZhciBhZGRyZXNzUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGluZGV4OiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIGFjY291bnQ6IGFjY291bnRQYXJzZXIsXG4gIGNoYWluOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGFkZHJlc3M6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgYWRkcmVzc19oYXNoOiAvKiNfX1BVUkVfXyovc3RyaW5nKClcbn0pO1xudmFyIGdlbmVyYXRlQWRkcmVzc0JvZHlQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgY29pbjogc3RyaW5nKCksXG4gIHdhbGxldDogc3RyaW5nKClcbn0pLm1lcmdlKGdlbmVyYXRlQXV0aFBhcnNlcik7XG52YXIgZ2VuZXJhdGVBZGRyZXNzUmVzcG9uc2UgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgaWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgYWRkcmVzczogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjb2luOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHdhbGxldDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBtZW1vOiAvKiNfX1BVUkVfXyovc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5cbnZhciByYXRlUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGNvdW50ZXJDdXJyZW5jeTogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBwcmljZTogLyojX19QVVJFX18qL251bWJlcigpLFxuICBwcmljZUNoYW5nZVBlcmNlbnQ6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgbWFya2V0Q2FwOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHZvbHVtZTogLyojX19QVVJFX18qL251bWJlcigpLFxuICB0aW1lc3RhbXA6IC8qI19fUFVSRV9fKi9udW1iZXIoKVxufSk7XG52YXIgZXhjaGFuZ2VSYXRlUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGNvbnRyYWN0OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHN5bWJvbDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICByYW5rOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHJhdGVzOiAvKiNfX1BVUkVfXyovYXJyYXkocmF0ZVBhcnNlcilcbn0pO1xudmFyIGV4Y2hhbmdlUmF0ZXNQYXJzZXIgPSAvKiNfX1BVUkVfXyovYXJyYXkoZXhjaGFuZ2VSYXRlUGFyc2VyKTtcblxudmFyIFR5cGU7XG5cbihmdW5jdGlvbiAoVHlwZSkge1xuICBUeXBlW1wiUkVDRUlWRVwiXSA9IFwicmVjZWl2ZVwiO1xuICBUeXBlW1wiU0VORFwiXSA9IFwic2VuZFwiO1xufSkoVHlwZSB8fCAoVHlwZSA9IHt9KSk7XG5cbnZhciBkZXBvc2l0Qm9keVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBpZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB0eXBlOiAvKiNfX1BVUkVfXyovbmF0aXZlRW51bShUeXBlKSxcbiAgaGFzaDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjb2luOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHdhbGxldDogLyojX19QVVJFX18qL3N0cmluZygpXG59KTtcbnZhciB0cmFuc2FjdGlvblBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBpZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB3YWxsZXQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgdmFsdWU6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgdmFsdWVTdHJpbmc6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgYWRkcmVzczogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB0eXBlOiAvKiNfX1BVUkVfXyovbmF0aXZlRW51bShUeXBlKSxcbiAgc3RhdGU6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY29uZmlybWF0aW9uczogLyojX19QVVJFX18qL251bWJlcigpLFxuICBoYXNoOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGJsb2NrSGFzaDogLyojX19QVVJFX18qL3N0cmluZygpLm9wdGlvbmFsKCkubnVsbGFibGUoKSxcbiAgYmxvY2tIZWlnaHQ6IC8qI19fUFVSRV9fKi9udW1iZXIoKS5vcHRpb25hbCgpLm51bGxhYmxlKClcbn0pO1xuXG52YXIgb3RjT3JkZXJSZXNwb25zZVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBzdWNjZXNzOiAvKiNfX1BVUkVfXyovYm9vbGVhbigpLFxuICB0cmFuc2FjdGlvbl9pZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBlcnJvcm1zZzogLyojX19QVVJFX18qL3N0cmluZygpLm9wdGlvbmFsKClcbn0pO1xudmFyIG90Y1F1b3RlQm9keVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBiYXNlQW1vdW50OiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIGJhc2VTeW1ib2w6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgcXVvdGVTeW1ib2w6IC8qI19fUFVSRV9fKi9zdHJpbmcoKVxufSk7XG52YXIgb3RjUXVvdGVSZXNwb25zZVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBzdWNjZXNzOiAvKiNfX1BVUkVfXyovYm9vbGVhbigpLFxuICB0b2tlbjogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBxdHk6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgZXJyb3Jtc2c6IC8qI19fUFVSRV9fKi9zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcblxudmFyIHdpdGhkcmF3RGF0YSA9IHtcbiAgZnJvbTogLyojX19QVVJFX18qL3N0cmluZygpLnJlZmluZShmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCAhPT0gV1JBUF9DT05UUkFDVDtcbiAgfSwge1xuICAgIG1lc3NhZ2U6IFdSQVBfQ09OVFJBQ1QgKyBcIiBtdXN0IGJlIHJlY2VpdmVyXCJcbiAgfSksXG4gIHRvOiAvKiNfX1BVUkVfXyovbGl0ZXJhbChXUkFQX0NPTlRSQUNUKSxcbiAgcXVhbnRpdHk6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgbWVtbzogLyojX19QVVJFX18qL3N0cmluZygpXG59O1xudmFyIHdpdGhkcmF3Qm9keVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBzaWduZXI6IGF1dGhvcml6YXRpb25QYXJzZXIsXG4gIHNpZ25hdHVyZXM6IC8qI19fUFVSRV9fKi9hcnJheShzdHJpbmcoKSkubGVuZ3RoKDEpLFxuICB0cmFuc2FjdGlvbjogLyojX19QVVJFX18qL3NpbmdsZUFjdGlvblRyYW5zYWN0aW9uUGFyc2VyKCcqJywgJ3RyYW5zZmVyJywgd2l0aGRyYXdEYXRhKSxcbiAgcXVvdGVJZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBwcm92aWRlcjogLyojX19QVVJFX18qL3N0cmluZygpLm9wdGlvbmFsKClcbn0pO1xudmFyIHdpdGhkcmF3TWV0YWxSZXNwb25zZVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBzdWNjZXNzOiAvKiNfX1BVUkVfXyovYm9vbGVhbigpLFxuICBpZDogLyojX19QVVJFX18qL3N0cmluZygpXG59KTtcbnZhciB3aXRoZHJhd2FsRmVlUXVvdGVQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgcXVvdGVJZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBlc3RpbWF0ZWRGZWU6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY3VycmVuY3k6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgbmV0d29yazogLyojX19QVVJFX18qL3N0cmluZygpXG59KTtcblxudmFyIHdpdGhkcmF3SGlzdG9yeU1ldGFsU3dhcFBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBpZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBzdGF0dXM6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgYW1vdW50OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGN1cnJlbmN5OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIG5ldHdvcms6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY3JlYXRlZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB3aXRoZHJhd2FsQWRkcmVzczogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB3aXRoZHJhd2FsSGFzaDogLyojX19QVVJFX18qL3N0cmluZygpLm9wdGlvbmFsKClcbn0pO1xudmFyIHdpdGhkcmF3SGlzdG9yeU1ldGFsUmVzcG9uc2VQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgc3dhcHM6IC8qI19fUFVSRV9fKi9hcnJheSh3aXRoZHJhd0hpc3RvcnlNZXRhbFN3YXBQYXJzZXIpLFxuICBwYWdlOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHBhZ2VTaXplOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIG51bWJlck9mRWxlbWVudHM6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgdG90YWxQYWdlczogLyojX19QVVJFX18qL251bWJlcigpLFxuICB0b3RhbEVsZW1lbnRzOiAvKiNfX1BVUkVfXyovbnVtYmVyKClcbn0pO1xuXG52YXIgU3RhdHVzO1xuXG4oZnVuY3Rpb24gKFN0YXR1cykge1xuICBTdGF0dXNbXCJQRU5ESU5HXCJdID0gXCJwZW5kaW5nXCI7XG4gIFN0YXR1c1tcIlNVQ0NFU1NcIl0gPSBcInN1Y2Nlc3NcIjtcbiAgU3RhdHVzW1wiRkFJTFwiXSA9IFwiZmFpbFwiO1xuICBTdGF0dXNbXCJQUk9DRVNTSU5HXCJdID0gXCJwcm9jZXNzaW5nXCI7XG59KShTdGF0dXMgfHwgKFN0YXR1cyA9IHt9KSk7XG5cbnZhciB3cmFwU3RhcnRQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgYmFsYW5jZTogRXh0ZW5kZWRBc3NldFBhcnNlcixcbiAgaWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgdHhpZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjaGFpbjogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBkZXBvc2l0X2FkZHJlc3M6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY29uZmlybWF0aW9uczogLyojX19QVVJFX18qL251bWJlcigpXG59KTtcbnZhciB3cmFwU2V0Q29uZlBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICB3cmFwX2hhc2g6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY29uZmlybWF0aW9uczogLyojX19QVVJFX18qL251bWJlcigpXG59KTtcbnZhciB3cmFwUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGluZGV4OiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHByb3Rvbl9hY2NvdW50OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGJhbGFuY2U6IEV4dGVuZGVkQXNzZXRQYXJzZXIsXG4gIGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHR4aWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY2hhaW46IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgZGVwb3NpdF9hZGRyZXNzOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHN0YXR1czogLyojX19QVVJFX18qL25hdGl2ZUVudW0oU3RhdHVzKSxcbiAgZmluaXNoX3R4aWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgd3JhcF9oYXNoOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNvbmZpcm1hdGlvbnM6IC8qI19fUFVSRV9fKi9udW1iZXIoKVxufSk7XG5cbnZhciBpc1NhbWVUb2tlbiA9IGZ1bmN0aW9uIGlzU2FtZVRva2VuKHRva2VuMSwgdG9rZW4yKSB7XG4gIHJldHVybiB0b2tlbjEueHRva2VuU3ltYm9sID09PSB0b2tlbjIueHRva2VuU3ltYm9sICYmIHRva2VuMS54dG9rZW5QcmVjaXNpb24gPT09IHRva2VuMi54dG9rZW5QcmVjaXNpb24gJiYgdG9rZW4xLnh0b2tlbkNvbnRyYWN0ID09PSB0b2tlbjIueHRva2VuQ29udHJhY3Q7XG59O1xuXG5leHBvcnQgeyBDaGFpbnMsIEV4dGVuZGVkQXNzZXRQYXJzZXIsIE5ldHdvcmtzLCBTdGF0dXMsIFR5cGUsIFdSQVBfQVVUSF9BQ1RJT04sIFdSQVBfQ09OVFJBQ1QsIGFjY291bnRQYXJzZXIsIGFkZHJlc3NQYXJzZXIsIGF1dGhvcml6YXRpb25QYXJzZXIsIGF1dGhvcml6YXRpb25zUGFyc2VyLCBiYXNlQWN0aW9uUGFyc2VyLCBiYXNlQWN0aW9uU2VyaWFsaXplZFBhcnNlciwgY3JlYXRlQWJzdHJhY3RBdXRoUGFyc2VyLCBkZXBvc2l0Qm9keVBhcnNlciwgZXhjaGFuZ2VSYXRlUGFyc2VyLCBleGNoYW5nZVJhdGVzUGFyc2VyLCBleHBsb3JlckxpbmtCeUNoYWluLCBnZW5lcmF0ZUFkZHJlc3NCb2R5UGFyc2VyLCBnZW5lcmF0ZUFkZHJlc3NSZXNwb25zZSwgZ2VuZXJhdGVBdXRoUGFyc2VyLCBpbml0aWFsaXplQ29pbnMsIGluaXRpYWxpemVDb25zdGFudHMsIGlzU2FtZVRva2VuLCBvdGNPcmRlclJlc3BvbnNlUGFyc2VyLCBvdGNRdW90ZUJvZHlQYXJzZXIsIG90Y1F1b3RlUmVzcG9uc2VQYXJzZXIsIHJhdGVQYXJzZXIsIHNpbWlsYXJDaGFpbnMsIHNpbmdsZUFjdGlvblRyYW5zYWN0aW9uUGFyc2VyLCB0cmFuc2FjdGlvblBhcnNlciwgd2ViYXV0aEFjdGlvblBhcnNlciwgd2l0aGRyYXdCb2R5UGFyc2VyLCB3aXRoZHJhd0hpc3RvcnlNZXRhbFJlc3BvbnNlUGFyc2VyLCB3aXRoZHJhd0hpc3RvcnlNZXRhbFN3YXBQYXJzZXIsIHdpdGhkcmF3TWV0YWxSZXNwb25zZVBhcnNlciwgd2l0aGRyYXdhbEZlZVF1b3RlUGFyc2VyLCB3cmFwUGFyc2VyLCB3cmFwU2V0Q29uZlBhcnNlciwgd3JhcFN0YXJ0UGFyc2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cmFwLWNvbnN0YW50cy5lc20uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbFwiKTtcbmV4cG9ydHMuWm9kRXJyb3JDb2RlID0gdXRpbF8xLnV0aWwuYXJyYXlUb0VudW0oW1xuICAgICdpbnZhbGlkX3R5cGUnLFxuICAgICdub25lbXB0eV9hcnJheV9pc19lbXB0eScsXG4gICAgJ2N1c3RvbV9lcnJvcicsXG4gICAgJ2ludmFsaWRfdW5pb24nLFxuICAgICdpbnZhbGlkX2xpdGVyYWxfdmFsdWUnLFxuICAgICdpbnZhbGlkX2VudW1fdmFsdWUnLFxuICAgICd1bnJlY29nbml6ZWRfa2V5cycsXG4gICAgJ2ludmFsaWRfYXJndW1lbnRzJyxcbiAgICAnaW52YWxpZF9yZXR1cm5fdHlwZScsXG4gICAgJ2ludmFsaWRfZGF0ZScsXG4gICAgJ2ludmFsaWRfc3RyaW5nJyxcbiAgICAndG9vX3NtYWxsJyxcbiAgICAndG9vX2JpZycsXG5dKTtcbmV4cG9ydHMucXVvdGVsZXNzSnNvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7IC8vIHtcIm5hbWVcIjpcIkpvaG4gU21pdGhcIn1cbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csICckMTonKTtcbn07XG52YXIgWm9kRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZEVycm9yKGVycm9ycykge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICBfdGhpcy5hZGRFcnJvciA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgICAgICAgIF90aGlzLmVycm9ycyA9IF90aGlzLmVycm9ycy5jb25jYXQoW3N1Yl0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5hZGRFcnJvcnMgPSBmdW5jdGlvbiAoc3Vicykge1xuICAgICAgICAgICAgaWYgKHN1YnMgPT09IHZvaWQgMCkgeyBzdWJzID0gW107IH1cbiAgICAgICAgICAgIF90aGlzLmVycm9ycyA9IF90aGlzLmVycm9ycy5jb25jYXQoc3Vicyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmllbGRFcnJvcnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBmb3JtRXJyb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMuZXJyb3JzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChzdWIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2goc3ViLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnM6IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzOiBmaWVsZEVycm9ycyB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXN0b3JlIHByb3RvdHlwZSBjaGFpblxuICAgICAgICB2YXIgYWN0dWFsUHJvdG8gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZEVycm9yLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5lcnJvcnMsIG51bGwsIDIpO1xuICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5sZW5ndGggKyBcIiB2YWxpZGF0aW9uIGlzc3VlKHMpXCIsXG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZXJyb3JzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBlcnIucGF0aC5qb2luKCcuJykgfHwgJ1tbcm9vdF1dJztcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UucHVzaChcIiAgSXNzdWUgI1wiICsgdGhpcy5lcnJvcnMuaW5kZXhPZihlcnIpICsgXCI6IFwiICsgZXJyLmNvZGUgKyBcIiBhdCBcIiArIHBhdGhTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZS5wdXNoKFwiICBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UucHVzaCgnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHF1b3RlbGVzc0pzb24odGhpcyk7XG4gICAgICAgICAgICAvLyAubWFwKCh7IHBhdGgsIG1lc3NhZ2UgfSkgPT4ge1xuICAgICAgICAgICAgLy8gICByZXR1cm4gcGF0aC5sZW5ndGggPyBgJHtwYXRoLmpvaW4oJy4vaW5kZXgnKX06ICR7bWVzc2FnZX1gIDogYCR7bWVzc2FnZX1gO1xuICAgICAgICAgICAgLy8gfSlcbiAgICAgICAgICAgIC8vIC5qb2luKCdcXG4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZEVycm9yLnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnMubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kRXJyb3IucHJvdG90eXBlLCBcImZvcm1FcnJvcnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgWm9kRXJyb3IuY3JlYXRlID0gZnVuY3Rpb24gKGVycm9ycykge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgWm9kRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5ab2RFcnJvciA9IFpvZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Wm9kRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbmRleFwiKSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsXCIpO1xudmFyIGlzT3B0aW9uYWwgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgdmFyIGRlZiA9IHNjaGVtYS5fZGVmO1xuICAgIGlmIChkZWYudCA9PT0gei5ab2RUeXBlcy51bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGVsc2UgaWYgKGRlZi50ID09PSB6LlpvZFR5cGVzLmludGVyc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gaXNPcHRpb25hbChkZWYucmlnaHQpICYmIGlzT3B0aW9uYWwoZGVmLmxlZnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWYudCA9PT0gei5ab2RUeXBlcy51bmlvbikge1xuICAgICAgICByZXR1cm4gZGVmLm9wdGlvbnMubWFwKGlzT3B0aW9uYWwpLnNvbWUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IHRydWU7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xudmFyIFpvZENvZGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWm9kQ29kZUdlbmVyYXRvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZWVuID0gW107XG4gICAgICAgIHRoaXMuc2VyaWFsID0gMDtcbiAgICAgICAgdGhpcy5yYW5kb21JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIklab2RcIiArIF90aGlzLnNlcmlhbCsrO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZpbmRCeVNjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZWVuLmZpbmQoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuc2NoZW1hID09PSBzY2hlbWE7IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZpbmRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBfdGhpcy5zZWVuLmZpbmQoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuaWQgPT09IGlkOyB9KTtcbiAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5mb3VuZCBJRDogXCIgKyBpZCk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcbnR5cGUgSWRlbnRpdHk8VD4gPSBUO1xcblxcblwiICsgX3RoaXMuc2VlblxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIFwidHlwZSBcIiArIGl0ZW0uaWQgKyBcIiA9IElkZW50aXR5PFwiICsgaXRlbS50eXBlICsgXCI+O1wiOyB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG5cXG4nKSArIFwiXFxuXCI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VHlwZSA9IGZ1bmN0aW9uIChpZCwgdHlwZSkge1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gX3RoaXMuZmluZEJ5SWQoaWQpO1xuICAgICAgICAgICAgZm91bmQudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBfdGhpcy5maW5kQnlTY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB2YXIgZGVmID0gc2NoZW1hLl9kZWY7XG4gICAgICAgICAgICB2YXIgaWQgPSBfdGhpcy5yYW5kb21JZCgpO1xuICAgICAgICAgICAgdmFyIHR5ID0ge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcIl9fSU5DT01QTEVURV9fXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuc2Vlbi5wdXNoKHR5KTtcbiAgICAgICAgICAgIHN3aXRjaCAoZGVmLnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMuc3RyaW5nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm51bWJlcjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5iaWdpbnQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcImJpZ2ludFwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMuYm9vbGVhbjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMuZGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwiRGF0ZVwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMudW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJ1bmRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm51bGw6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcIm51bGxcIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmFueTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwiYW55XCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy51bmtub3duOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJ1bmtub3duXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy52b2lkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJ2b2lkXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5saXRlcmFsOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZGVmLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbFR5cGUgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IFwiXFxcIlwiICsgdmFsICsgXCJcXFwiXCIgOiBcIlwiICsgdmFsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgbGl0ZXJhbFR5cGUpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5lbnVtOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgZGVmLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFwiXFxcIlwiICsgdiArIFwiXFxcIlwiOyB9KS5qb2luKCcgfCAnKSk7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm9iamVjdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdExpbmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGRlZi5zaGFwZSgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFNjaGVtYSA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRUeXBlID0gX3RoaXMuZ2VuZXJhdGUoY2hpbGRTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE9QVEtFWSA9IGlzT3B0aW9uYWwoY2hpbGRTY2hlbWEpID8gJz8nIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RMaW5lcy5wdXNoKFwiXCIgKyBrZXkgKyBPUFRLRVkgKyBcIjogXCIgKyBjaGlsZFR5cGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlU3RydWN0ID0gXCJ7XFxuXCIgKyBvYmplY3RMaW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gXCIgIFwiICsgbGluZSArIFwiO1wiOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpICsgXCJcXG59XCI7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFR5cGUoaWQsIFwiXCIgKyBiYXNlU3RydWN0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnR1cGxlOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdHVwbGVMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGVmLml0ZW1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsU2NoZW1hID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsVHlwZSA9IF90aGlzLmdlbmVyYXRlKGVsU2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlTGluZXMucHVzaChlbFR5cGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVHVwbGUgPSBcIltcXG5cIiArIHR1cGxlTGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUpIHsgcmV0dXJuIFwiICBcIiArIGxpbmUgKyBcIixcIjsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSArIFwiXFxuXVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJcIiArIGJhc2VUdXBsZSk7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmFycmF5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgX3RoaXMuZ2VuZXJhdGUoZGVmLnR5cGUpLmlkICsgXCJbXVwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMuZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gX3RoaXMuZ2VuZXJhdGUoZGVmLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJucyA9IF90aGlzLmdlbmVyYXRlKGRlZi5yZXR1cm5zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwiKC4uLmFyZ3M6IFwiICsgYXJncy5pZCArIFwiKT0+XCIgKyByZXR1cm5zLmlkKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMucHJvbWlzZTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21WYWx1ZSA9IF90aGlzLmdlbmVyYXRlKGRlZi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwiUHJvbWlzZTxcIiArIHByb21WYWx1ZS5pZCArIFwiPlwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMudW5pb246XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmlvbkxpbmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBkZWYub3B0aW9uczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbFNjaGVtYSA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbFR5cGUgPSBfdGhpcy5nZW5lcmF0ZShlbFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlvbkxpbmVzLnB1c2goZWxUeXBlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgdW5pb25MaW5lcy5qb2luKFwiIHwgXCIpKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMuaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgX3RoaXMuZ2VuZXJhdGUoZGVmLmxlZnQpLmlkICsgXCIgJiBcIiArIF90aGlzLmdlbmVyYXRlKGRlZi5yaWdodCkuaWQpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5yZWNvcmQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcIntbazpzdHJpbmddOiBcIiArIF90aGlzLmdlbmVyYXRlKGRlZi52YWx1ZVR5cGUpLmlkICsgXCJ9XCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5sYXp5OlxuICAgICAgICAgICAgICAgICAgICB2YXIgbGF6eVR5cGUgPSBkZWYuZ2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBfdGhpcy5nZW5lcmF0ZShsYXp5VHlwZSkuaWQpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5uYXRpdmVFbnVtOlxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBsYXp5VHlwZSA9IGRlZi5nZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsICdhc2RmJyk7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmtleW9mOlxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBsYXp5VHlwZSA9IGRlZi5nZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwia2V5b2YgW1wiICsgZGVmLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBcIlxcXCJcIiArIHZhbCArIFwiXFxcIlwiIDogdmFsKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS51dGlsLmFzc2VydE5ldmVyKGRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZmluZEJ5SWQoaWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBab2RDb2RlR2VuZXJhdG9yLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBab2RDb2RlR2VuZXJhdG9yKCk7IH07XG4gICAgcmV0dXJuIFpvZENvZGVHZW5lcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5ab2RDb2RlR2VuZXJhdG9yID0gWm9kQ29kZUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVnZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgWm9kRXJyb3JfMSA9IHJlcXVpcmUoXCIuL1pvZEVycm9yXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbFwiKTtcbmV4cG9ydHMuZGVmYXVsdEVycm9yTWFwID0gZnVuY3Rpb24gKGVycm9yLCBfY3R4KSB7XG4gICAgdmFyIG1lc3NhZ2U7XG4gICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGVycm9yLnJlY2VpdmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnUmVxdWlyZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgXCIgKyBlcnJvci5leHBlY3RlZCArIFwiLCByZWNlaXZlZCBcIiArIGVycm9yLnJlY2VpdmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUubm9uZW1wdHlfYXJyYXlfaXNfZW1wdHk6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJMaXN0IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgaXRlbVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogXCIgKyBlcnJvci5rZXlzLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gXCInXCIgKyBrICsgXCInXCI7IH0pLmpvaW4oJywgJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGNhc2UgWm9kRXJyb3JDb2RlLmludmFsaWRfdHVwbGVfbGVuZ3RoOlxuICAgICAgICAvLyAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgbGlzdCBvZiAke2Vycm9yLmV4cGVjdGVkfSBpdGVtcywgcmVjZWl2ZWQgJHtlcnJvci5yZWNlaXZlZH0gaXRlbXNgO1xuICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfbGl0ZXJhbF92YWx1ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIklucHV0IG11c3QgYmUgXFxcIlwiICsgZXJyb3IuZXhwZWN0ZWQgKyBcIlxcXCJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIklucHV0IG11c3QgYmUgb25lIG9mIHRoZXNlIHZhbHVlczogXCIgKyBlcnJvci5vcHRpb25zLmpvaW4oJywgJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBkYXRlXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gY2FzZSBab2RFcnJvckNvZGUudG9vX3NtYWxsOlxuICAgICAgICAvLyAgIGNvbnN0IHRvb1Nob3J0Tm91biA9IF9jdHguZGF0YSA9PT0gJ3N0cmluZycgPyAnY2hhcmFjdGVycycgOiAnaXRlbXMnO1xuICAgICAgICAvLyAgIG1lc3NhZ2UgPSBgVG9vIHNob3J0LCBzaG91bGQgYmUgYXQgbGVhc3QgJHtlcnJvci5taW5pbXVtfSAke3Rvb1Nob3J0Tm91bn1gO1xuICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAvLyBjYXNlIFpvZEVycm9yQ29kZS50b29fYmlnOlxuICAgICAgICAvLyAgIGNvbnN0IHRvb0xvbmdOb3VuID0gX2N0eC5kYXRhID09PSAnc3RyaW5nJyA/ICdjaGFyYWN0ZXJzJyA6ICdpdGVtcyc7XG4gICAgICAgIC8vICAgbWVzc2FnZSA9IGBUb28gc2hvcnQsIHNob3VsZCBiZSBhdCBtb3N0ICR7ZXJyb3IubWF4aW11bX0gJHt0b29Mb25nTm91bn1gO1xuICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgICAgICAgaWYgKGVycm9yLnZhbGlkYXRpb24gIT09ICdyZWdleCcpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBcIiArIGVycm9yLnZhbGlkYXRpb247XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9ICdJbnZhbGlkJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBjYXNlIFpvZEVycm9yQ29kZS5pbnZhbGlkX3VybDpcbiAgICAgICAgLy8gICBtZXNzYWdlID0gJ0ludmFsaWQgVVJMLic7XG4gICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgIC8vIGNhc2UgWm9kRXJyb3JDb2RlLmludmFsaWRfdXVpZDpcbiAgICAgICAgLy8gICBtZXNzYWdlID0gJ0ludmFsaWQgVVVJRC4nO1xuICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19zbWFsbDpcbiAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSAnYXJyYXknKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlNob3VsZCBoYXZlIFwiICsgKGVycm9yLmluY2x1c2l2ZSA/IFwiYXQgbGVhc3RcIiA6IFwibW9yZSB0aGFuXCIpICsgXCIgXCIgKyBlcnJvci5taW5pbXVtICsgXCIgaXRlbXNcIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlNob3VsZCBiZSBcIiArIChlcnJvci5pbmNsdXNpdmUgPyBcImF0IGxlYXN0XCIgOiBcIm92ZXJcIikgKyBcIiBcIiArIGVycm9yLm1pbmltdW0gKyBcIiBjaGFyYWN0ZXJzXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvci50eXBlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJWYWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIFwiICsgKGVycm9yLmluY2x1c2l2ZSA/IFwib3IgZXF1YWwgdG8gXCIgOiBcIlwiKSArIGVycm9yLm1pbmltdW07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9ICdJbnZhbGlkIGlucHV0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gJ2FycmF5JylcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJTaG91bGQgaGF2ZSBcIiArIChlcnJvci5pbmNsdXNpdmUgPyBcImF0IG1vc3RcIiA6IFwibGVzcyB0aGFuXCIpICsgXCIgXCIgKyBlcnJvci5tYXhpbXVtICsgXCIgaXRlbXNcIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlNob3VsZCBiZSBcIiArIChlcnJvci5pbmNsdXNpdmUgPyBcImF0IG1vc3RcIiA6IFwidW5kZXJcIikgKyBcIiBcIiArIGVycm9yLm1heGltdW0gKyBcIiBjaGFyYWN0ZXJzIGxvbmdcIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnR5cGUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlZhbHVlIHNob3VsZCBiZSBsZXNzIHRoYW4gXCIgKyAoZXJyb3IuaW5jbHVzaXZlID8gXCJvciBlcXVhbCB0byBcIiA6IFwiXCIpICsgZXJyb3IubWF4aW11bTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ0ludmFsaWQgaW5wdXQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuY3VzdG9tX2Vycm9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dC5cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dC5cIjtcbiAgICAgICAgICAgIHV0aWxfMS51dGlsLmFzc2VydE5ldmVyKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgIC8vIHJldHVybiBgSW52YWxpZCBpbnB1dC5gO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRFcnJvck1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8geyBtZXNzYWdlOiBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9KTsgfTtcbn0pKGVycm9yVXRpbCA9IGV4cG9ydHMuZXJyb3JVdGlsIHx8IChleHBvcnRzLmVycm9yVXRpbCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvclV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJhc2VfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy9iYXNlXCIpO1xudmFyIGludGVyc2VjdGlvbl8xID0gcmVxdWlyZShcIi4uL3R5cGVzL2ludGVyc2VjdGlvblwiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy9vYmplY3RcIik7XG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgZmlyc3RLZXlzID0gT2JqZWN0LmtleXMoZmlyc3QpO1xuICAgICAgICB2YXIgc2Vjb25kS2V5cyA9IE9iamVjdC5rZXlzKHNlY29uZCk7XG4gICAgICAgIHZhciBzaGFyZWRLZXlzID0gZmlyc3RLZXlzLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gc2Vjb25kS2V5cy5pbmRleE9mKGspICE9PSAtMTsgfSk7XG4gICAgICAgIHZhciBzaGFyZWRTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNoYXJlZEtleXNfMSA9IHNoYXJlZEtleXM7IF9pIDwgc2hhcmVkS2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGsgPSBzaGFyZWRLZXlzXzFbX2ldO1xuICAgICAgICAgICAgc2hhcmVkU2hhcGVba10gPSBpbnRlcnNlY3Rpb25fMS5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlKGZpcnN0W2tdLCBzZWNvbmRba10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgZmlyc3QsIHNlY29uZCwgc2hhcmVkU2hhcGUpO1xuICAgIH07XG4gICAgb2JqZWN0VXRpbC5tZXJnZU9iamVjdHMgPSBmdW5jdGlvbiAoZmlyc3QpIHsgcmV0dXJuIGZ1bmN0aW9uIChzZWNvbmQpIHtcbiAgICAgICAgdmFyIG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhmaXJzdC5fZGVmLnNoYXBlKCksIHNlY29uZC5fZGVmLnNoYXBlKCkpO1xuICAgICAgICB2YXIgbWVyZ2VkID0gbmV3IG9iamVjdF8xLlpvZE9iamVjdCh7XG4gICAgICAgICAgICB0OiBiYXNlXzEuWm9kVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgY2hlY2tzOiAoZmlyc3QuX2RlZi5jaGVja3MgfHwgW10pLmNvbmNhdCgoc2Vjb25kLl9kZWYuY2hlY2tzIHx8IFtdKSksXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IGZpcnN0LnBhcmFtcy5zdHJpY3QgJiYgc2Vjb25kLnBhcmFtcy5zdHJpY3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lcmdlZFNoYXBlOyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9OyB9O1xufSkob2JqZWN0VXRpbCA9IGV4cG9ydHMub2JqZWN0VXRpbCB8fCAoZXhwb3J0cy5vYmplY3RVdGlsID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdFV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG4gICAgdXRpbC5hcnJheVRvRW51bSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaXRlbXNfMSA9IGl0ZW1zOyBfaSA8IGl0ZW1zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zXzFbX2ldO1xuICAgICAgICAgICAgb2JqW2l0ZW1dID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciB2YWxpZEtleXMgPSBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gdHlwZW9mIG9ialtvYmpba11dICE9PSAnbnVtYmVyJzsgfSk7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHZhbGlkS2V5c18xID0gdmFsaWRLZXlzOyBfaSA8IHZhbGlkS2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGsgPSB2YWxpZEtleXNfMVtfaV07XG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5nZXRWYWx1ZXMoZmlsdGVyZWQpO1xuICAgIH07XG4gICAgdXRpbC5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2VdO1xuICAgICAgICB9KTtcbiAgICB9O1xufSkodXRpbCA9IGV4cG9ydHMudXRpbCB8fCAoZXhwb3J0cy51dGlsID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBaT0QgKi9cbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi90eXBlcy9zdHJpbmdcIik7XG5leHBvcnRzLlpvZFN0cmluZyA9IHN0cmluZ18xLlpvZFN0cmluZztcbnZhciBudW1iZXJfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL251bWJlclwiKTtcbmV4cG9ydHMuWm9kTnVtYmVyID0gbnVtYmVyXzEuWm9kTnVtYmVyO1xudmFyIGJpZ2ludF8xID0gcmVxdWlyZShcIi4vdHlwZXMvYmlnaW50XCIpO1xuZXhwb3J0cy5ab2RCaWdJbnQgPSBiaWdpbnRfMS5ab2RCaWdJbnQ7XG52YXIgYm9vbGVhbl8xID0gcmVxdWlyZShcIi4vdHlwZXMvYm9vbGVhblwiKTtcbmV4cG9ydHMuWm9kQm9vbGVhbiA9IGJvb2xlYW5fMS5ab2RCb29sZWFuO1xudmFyIGRhdGVfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2RhdGVcIik7XG5leHBvcnRzLlpvZERhdGUgPSBkYXRlXzEuWm9kRGF0ZTtcbnZhciB1bmRlZmluZWRfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3VuZGVmaW5lZFwiKTtcbmV4cG9ydHMuWm9kVW5kZWZpbmVkID0gdW5kZWZpbmVkXzEuWm9kVW5kZWZpbmVkO1xudmFyIG51bGxfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL251bGxcIik7XG5leHBvcnRzLlpvZE51bGwgPSBudWxsXzEuWm9kTnVsbDtcbnZhciBhbnlfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2FueVwiKTtcbmV4cG9ydHMuWm9kQW55ID0gYW55XzEuWm9kQW55O1xudmFyIHVua25vd25fMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3Vua25vd25cIik7XG5leHBvcnRzLlpvZFVua25vd24gPSB1bmtub3duXzEuWm9kVW5rbm93bjtcbnZhciB2b2lkXzEgPSByZXF1aXJlKFwiLi90eXBlcy92b2lkXCIpO1xuZXhwb3J0cy5ab2RWb2lkID0gdm9pZF8xLlpvZFZvaWQ7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2FycmF5XCIpO1xuZXhwb3J0cy5ab2RBcnJheSA9IGFycmF5XzEuWm9kQXJyYXk7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi90eXBlcy9vYmplY3RcIik7XG5leHBvcnRzLlpvZE9iamVjdCA9IG9iamVjdF8xLlpvZE9iamVjdDtcbnZhciB1bmlvbl8xID0gcmVxdWlyZShcIi4vdHlwZXMvdW5pb25cIik7XG5leHBvcnRzLlpvZFVuaW9uID0gdW5pb25fMS5ab2RVbmlvbjtcbnZhciBpbnRlcnNlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2ludGVyc2VjdGlvblwiKTtcbmV4cG9ydHMuWm9kSW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uXzEuWm9kSW50ZXJzZWN0aW9uO1xudmFyIHR1cGxlXzEgPSByZXF1aXJlKFwiLi90eXBlcy90dXBsZVwiKTtcbmV4cG9ydHMuWm9kVHVwbGUgPSB0dXBsZV8xLlpvZFR1cGxlO1xudmFyIHJlY29yZF8xID0gcmVxdWlyZShcIi4vdHlwZXMvcmVjb3JkXCIpO1xuZXhwb3J0cy5ab2RSZWNvcmQgPSByZWNvcmRfMS5ab2RSZWNvcmQ7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2Z1bmN0aW9uXCIpO1xuZXhwb3J0cy5ab2RGdW5jdGlvbiA9IGZ1bmN0aW9uXzEuWm9kRnVuY3Rpb247XG52YXIgbGF6eV8xID0gcmVxdWlyZShcIi4vdHlwZXMvbGF6eVwiKTtcbmV4cG9ydHMuWm9kTGF6eSA9IGxhenlfMS5ab2RMYXp5O1xudmFyIGxpdGVyYWxfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2xpdGVyYWxcIik7XG5leHBvcnRzLlpvZExpdGVyYWwgPSBsaXRlcmFsXzEuWm9kTGl0ZXJhbDtcbnZhciBlbnVtXzEgPSByZXF1aXJlKFwiLi90eXBlcy9lbnVtXCIpO1xuZXhwb3J0cy5ab2RFbnVtID0gZW51bV8xLlpvZEVudW07XG52YXIgbmF0aXZlRW51bV8xID0gcmVxdWlyZShcIi4vdHlwZXMvbmF0aXZlRW51bVwiKTtcbmV4cG9ydHMuWm9kTmF0aXZlRW51bSA9IG5hdGl2ZUVudW1fMS5ab2ROYXRpdmVFbnVtO1xudmFyIGtleW9mXzEgPSByZXF1aXJlKFwiLi90eXBlcy9rZXlvZlwiKTtcbnZhciBwcm9taXNlXzEgPSByZXF1aXJlKFwiLi90eXBlcy9wcm9taXNlXCIpO1xuZXhwb3J0cy5ab2RQcm9taXNlID0gcHJvbWlzZV8xLlpvZFByb21pc2U7XG52YXIgYmFzZV8xID0gcmVxdWlyZShcIi4vdHlwZXMvYmFzZVwiKTtcbmV4cG9ydHMuWm9kVHlwZSA9IGJhc2VfMS5ab2RUeXBlO1xuZXhwb3J0cy5TY2hlbWEgPSBiYXNlXzEuWm9kVHlwZTtcbmV4cG9ydHMuWm9kU2NoZW1hID0gYmFzZV8xLlpvZFR5cGU7XG5leHBvcnRzLlpvZFR5cGVzID0gYmFzZV8xLlpvZFR5cGVzO1xuLy8gaW1wb3J0IHsgWm9kRXJyb3IsIFpvZEVycm9yQ29kZSwgWm9kSW52YWxpZFR5cGVFcnJvcixcbi8vIFpvZE5vbkVtcHR5QXJyYXlJc0VtcHR5RXJyb3IsXG4vLyBab2RVbnJlY29nbml6ZWRLZXlzRXJyb3IsXG4vLyBab2RJbnZhbGlkVW5pb25FcnJvcixcbi8vIFpvZEludmFsaWRMaXRlcmFsVmFsdWVFcnJvcixcbi8vIFpvZEludmFsaWRFbnVtVmFsdWVFcnJvcixcbi8vIFpvZEludmFsaWRBcmd1bWVudHNFcnJvcixcbi8vIFpvZEludmFsaWRSZXR1cm5UeXBlRXJyb3IsXG4vLyBab2RJbnZhbGlkRGF0ZUVycm9yLFxuLy8gWm9kSW52YWxpZFN0cmluZ0Vycm9yLFxuLy8gWm9kVG9vU21hbGxFcnJvcixcbi8vIFpvZFRvb0JpZ0Vycm9yLFxuLy8gWm9kQ3VzdG9tRXJyb3IgfSBmcm9tICcuL1pvZEVycm9yJztcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3BhcnNlclwiKTtcbmV4cG9ydHMuWm9kUGFyc2VkVHlwZSA9IHBhcnNlcl8xLlpvZFBhcnNlZFR5cGU7XG52YXIgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmV4cG9ydHMuWm9kQ29kZUdlbmVyYXRvciA9IGNvZGVnZW5fMS5ab2RDb2RlR2VuZXJhdG9yO1xudmFyIHN0cmluZ1R5cGUgPSBzdHJpbmdfMS5ab2RTdHJpbmcuY3JlYXRlO1xuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmdUeXBlO1xudmFyIG51bWJlclR5cGUgPSBudW1iZXJfMS5ab2ROdW1iZXIuY3JlYXRlO1xuZXhwb3J0cy5udW1iZXIgPSBudW1iZXJUeXBlO1xudmFyIGJpZ0ludFR5cGUgPSBiaWdpbnRfMS5ab2RCaWdJbnQuY3JlYXRlO1xuZXhwb3J0cy5iaWdpbnQgPSBiaWdJbnRUeXBlO1xudmFyIGJvb2xlYW5UeXBlID0gYm9vbGVhbl8xLlpvZEJvb2xlYW4uY3JlYXRlO1xuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhblR5cGU7XG52YXIgZGF0ZVR5cGUgPSBkYXRlXzEuWm9kRGF0ZS5jcmVhdGU7XG5leHBvcnRzLmRhdGUgPSBkYXRlVHlwZTtcbnZhciB1bmRlZmluZWRUeXBlID0gdW5kZWZpbmVkXzEuWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbmV4cG9ydHMudW5kZWZpbmVkID0gdW5kZWZpbmVkVHlwZTtcbnZhciBudWxsVHlwZSA9IG51bGxfMS5ab2ROdWxsLmNyZWF0ZTtcbmV4cG9ydHMubnVsbCA9IG51bGxUeXBlO1xudmFyIGFueVR5cGUgPSBhbnlfMS5ab2RBbnkuY3JlYXRlO1xuZXhwb3J0cy5hbnkgPSBhbnlUeXBlO1xudmFyIHVua25vd25UeXBlID0gdW5rbm93bl8xLlpvZFVua25vd24uY3JlYXRlO1xuZXhwb3J0cy51bmtub3duID0gdW5rbm93blR5cGU7XG52YXIgdm9pZFR5cGUgPSB2b2lkXzEuWm9kVm9pZC5jcmVhdGU7XG5leHBvcnRzLnZvaWQgPSB2b2lkVHlwZTtcbnZhciBhcnJheVR5cGUgPSBhcnJheV8xLlpvZEFycmF5LmNyZWF0ZTtcbmV4cG9ydHMuYXJyYXkgPSBhcnJheVR5cGU7XG52YXIgb2JqZWN0VHlwZSA9IG9iamVjdF8xLlpvZE9iamVjdC5jcmVhdGU7XG5leHBvcnRzLm9iamVjdCA9IG9iamVjdFR5cGU7XG52YXIgdW5pb25UeXBlID0gdW5pb25fMS5ab2RVbmlvbi5jcmVhdGU7XG5leHBvcnRzLnVuaW9uID0gdW5pb25UeXBlO1xudmFyIGludGVyc2VjdGlvblR5cGUgPSBpbnRlcnNlY3Rpb25fMS5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlO1xuZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb25UeXBlO1xudmFyIHR1cGxlVHlwZSA9IHR1cGxlXzEuWm9kVHVwbGUuY3JlYXRlO1xuZXhwb3J0cy50dXBsZSA9IHR1cGxlVHlwZTtcbnZhciByZWNvcmRUeXBlID0gcmVjb3JkXzEuWm9kUmVjb3JkLmNyZWF0ZTtcbmV4cG9ydHMucmVjb3JkID0gcmVjb3JkVHlwZTtcbnZhciBmdW5jdGlvblR5cGUgPSBmdW5jdGlvbl8xLlpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmV4cG9ydHMuZnVuY3Rpb24gPSBmdW5jdGlvblR5cGU7XG52YXIgbGF6eVR5cGUgPSBsYXp5XzEuWm9kTGF6eS5jcmVhdGU7XG5leHBvcnRzLmxhenkgPSBsYXp5VHlwZTtcbnZhciBsaXRlcmFsVHlwZSA9IGxpdGVyYWxfMS5ab2RMaXRlcmFsLmNyZWF0ZTtcbmV4cG9ydHMubGl0ZXJhbCA9IGxpdGVyYWxUeXBlO1xudmFyIGVudW1UeXBlID0gZW51bV8xLlpvZEVudW0uY3JlYXRlO1xuZXhwb3J0cy5lbnVtID0gZW51bVR5cGU7XG52YXIgbmF0aXZlRW51bVR5cGUgPSBuYXRpdmVFbnVtXzEuWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5leHBvcnRzLm5hdGl2ZUVudW0gPSBuYXRpdmVFbnVtVHlwZTtcbnZhciBwcm9taXNlVHlwZSA9IHByb21pc2VfMS5ab2RQcm9taXNlLmNyZWF0ZTtcbmV4cG9ydHMucHJvbWlzZSA9IHByb21pc2VUeXBlO1xudmFyIGtleW9mVHlwZSA9IGtleW9mXzEuWm9kS2V5b2YuY3JlYXRlO1xuZXhwb3J0cy5rZXlvZiA9IGtleW9mVHlwZTtcbnZhciBvc3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7IH07XG5leHBvcnRzLm9zdHJpbmcgPSBvc3RyaW5nO1xudmFyIG9udW1iZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTsgfTtcbmV4cG9ydHMub251bWJlciA9IG9udW1iZXI7XG52YXIgb2Jvb2xlYW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBib29sZWFuVHlwZSgpLm9wdGlvbmFsKCk7IH07XG5leHBvcnRzLm9ib29sZWFuID0gb2Jvb2xlYW47XG52YXIgY29kZWdlbiA9IGNvZGVnZW5fMS5ab2RDb2RlR2VuZXJhdG9yLmNyZWF0ZTtcbmV4cG9ydHMuY29kZWdlbiA9IGNvZGVnZW47XG5leHBvcnRzLmN1c3RvbSA9IGZ1bmN0aW9uIChjaGVjaywgcGFyYW1zKSB7IHJldHVybiBhbnlUeXBlKCkucmVmaW5lKGNoZWNrLCBwYXJhbXMpOyB9O1xudmFyIGluc3RhbmNlT2ZUeXBlID0gZnVuY3Rpb24gKGNscywgcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHtcbiAgICAgICAgbWVzc2FnZTogXCJJbnB1dCBub3QgaW5zdGFuY2Ugb2YgXCIgKyBjbHMubmFtZSxcbiAgICB9OyB9XG4gICAgcmV0dXJuIGV4cG9ydHMuY3VzdG9tKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhIGluc3RhbmNlb2YgY2xzOyB9LCBwYXJhbXMpO1xufTtcbmV4cG9ydHMuaW5zdGFuY2VvZiA9IGluc3RhbmNlT2ZUeXBlO1xuZXhwb3J0cy5sYXRlID0ge1xuICAgIG9iamVjdDogb2JqZWN0XzEuWm9kT2JqZWN0LmxhenljcmVhdGUsXG59O1xuX19leHBvcnQocmVxdWlyZShcIi4vWm9kRXJyb3JcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbmRleFwiKSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsXCIpO1xuZXhwb3J0cy5pc1NjYWxhciA9IGZ1bmN0aW9uIChzY2hlbWEsIHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7IHJvb3Q6IHRydWUgfTsgfVxuICAgIHZhciBkZWYgPSBzY2hlbWEuX2RlZjtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKGRlZi50KSB7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5zdHJpbmc6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm51bWJlcjpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuYmlnaW50OlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5ib29sZWFuOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy51bmRlZmluZWQ6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm51bGw6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmFueTpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnVua25vd246XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy52b2lkOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuYXJyYXk6XG4gICAgICAgICAgICBpZiAocGFyYW1zLnJvb3QgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZXhwb3J0cy5pc1NjYWxhcihkZWYudHlwZSwgeyByb290OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMub2JqZWN0OlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudW5pb246XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGRlZi5vcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiBleHBvcnRzLmlzU2NhbGFyKHgpOyB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBleHBvcnRzLmlzU2NhbGFyKGRlZi5sZWZ0KSAmJiBleHBvcnRzLmlzU2NhbGFyKGRlZi5yaWdodCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnR1cGxlOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubGF6eTpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZXhwb3J0cy5pc1NjYWxhcihkZWYuZ2V0dGVyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5saXRlcmFsOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5lbnVtOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5uYXRpdmVFbnVtOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5mdW5jdGlvbjpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnJlY29yZDpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmRhdGU6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnByb21pc2U6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5rZXlvZjpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdXRpbF8xLnV0aWwuYXNzZXJ0TmV2ZXIoZGVmKTtcbiAgICAgICAgLy8gcmV0dXJuVmFsdWUgPSBmYWxzZTsgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1NjYWxhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF90aGlzID0gdGhpcztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL2Jhc2VcIikpO1xudmFyIFpvZEVycm9yXzEgPSByZXF1aXJlKFwiLi9ab2RFcnJvclwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxcIik7XG52YXIgZGVmYXVsdEVycm9yTWFwXzEgPSByZXF1aXJlKFwiLi9kZWZhdWx0RXJyb3JNYXBcIik7XG5leHBvcnRzLmdldFBhcnNlZFR5cGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oZGF0YSkpXG4gICAgICAgICAgICByZXR1cm4gJ25hbic7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnYm9vbGVhbicpXG4gICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnYmlnaW50JylcbiAgICAgICAgcmV0dXJuICdiaWdpbnQnO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N5bWJvbCcpXG4gICAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgaWYgKGRhdGEudGhlbiAmJlxuICAgICAgICAgICAgdHlwZW9mIGRhdGEudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxuICAgICAgICAgICAgdHlwZW9mIGRhdGEuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAncHJvbWlzZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICByZXR1cm4gJ3Vua25vd24nO1xufTtcbmV4cG9ydHMuWm9kUGFyc2VkVHlwZSA9IHV0aWxfMS51dGlsLmFycmF5VG9FbnVtKFtcbiAgICAnc3RyaW5nJyxcbiAgICAnbmFuJyxcbiAgICAnbnVtYmVyJyxcbiAgICAnaW50ZWdlcicsXG4gICAgJ2Jvb2xlYW4nLFxuICAgICdkYXRlJyxcbiAgICAnYmlnaW50JyxcbiAgICAnc3ltYm9sJyxcbiAgICAnZnVuY3Rpb24nLFxuICAgICd1bmRlZmluZWQnLFxuICAgICdudWxsJyxcbiAgICAnYXJyYXknLFxuICAgICdvYmplY3QnLFxuICAgICd1bmtub3duJyxcbiAgICAncHJvbWlzZScsXG4gICAgJ3ZvaWQnLFxuXSk7XG5leHBvcnRzLmZpbmQgPSBmdW5jdGlvbiAoYXJyLCBjaGVja2VyKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBhcnJfMSA9IGFycjsgX2kgPCBhcnJfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJfMVtfaV07XG4gICAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xudmFyIG1ha2VFcnJvciA9IGZ1bmN0aW9uIChwYXJhbXMsIG9iaiwgZXJyb3JEYXRhKSB7XG4gICAgdmFyIGVycm9yQXJnID0gX19hc3NpZ24oe30sIGVycm9yRGF0YSwgeyBwYXRoOiBwYXJhbXMucGF0aC5jb25jYXQoKGVycm9yRGF0YS5wYXRoIHx8IFtdKSkgfSk7XG4gICAgdmFyIGN0eEFyZyA9IHsgZGF0YTogb2JqIH07XG4gICAgdmFyIGRlZmF1bHRFcnJvciA9IGRlZmF1bHRFcnJvck1hcF8xLmRlZmF1bHRFcnJvck1hcCA9PT0gcGFyYW1zLmVycm9yTWFwXG4gICAgICAgID8geyBtZXNzYWdlOiBcIkludmFsaWQgdmFsdWUuXCIgfVxuICAgICAgICA6IGRlZmF1bHRFcnJvck1hcF8xLmRlZmF1bHRFcnJvck1hcChlcnJvckFyZywgX19hc3NpZ24oe30sIGN0eEFyZywgeyBkZWZhdWx0RXJyb3I6IFwiSW52YWxpZCB2YWx1ZS5cIiB9KSk7XG4gICAgcmV0dXJuIF9fYXNzaWduKHt9LCBlcnJvckRhdGEsIHsgcGF0aDogcGFyYW1zLnBhdGguY29uY2F0KChlcnJvckRhdGEucGF0aCB8fCBbXSkpLCBtZXNzYWdlOiBlcnJvckRhdGEubWVzc2FnZSB8fFxuICAgICAgICAgICAgcGFyYW1zLmVycm9yTWFwKGVycm9yQXJnLCBfX2Fzc2lnbih7fSwgY3R4QXJnLCB7IGRlZmF1bHRFcnJvcjogZGVmYXVsdEVycm9yLm1lc3NhZ2UgfSkpLm1lc3NhZ2UgfSk7XG59O1xuZXhwb3J0cy5ab2RQYXJzZXIgPSBmdW5jdGlvbiAoc2NoZW1hRGVmKSB7IHJldHVybiBmdW5jdGlvbiAob2JqLCBiYXNlUGFyYW1zKSB7XG4gICAgaWYgKGJhc2VQYXJhbXMgPT09IHZvaWQgMCkgeyBiYXNlUGFyYW1zID0geyBzZWVuOiBbXSwgZXJyb3JNYXA6IGRlZmF1bHRFcnJvck1hcF8xLmRlZmF1bHRFcnJvck1hcCwgcGF0aDogW10gfTsgfVxuICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgIHNlZW46IGJhc2VQYXJhbXMuc2VlbiB8fCBbXSxcbiAgICAgICAgcGF0aDogYmFzZVBhcmFtcy5wYXRoIHx8IFtdLFxuICAgICAgICBlcnJvck1hcDogYmFzZVBhcmFtcy5lcnJvck1hcCB8fCBkZWZhdWx0RXJyb3JNYXBfMS5kZWZhdWx0RXJyb3JNYXAsXG4gICAgfTtcbiAgICB2YXIgZGVmID0gc2NoZW1hRGVmO1xuICAgIHZhciBwYXJzZWRUeXBlID0gZXhwb3J0cy5nZXRQYXJzZWRUeXBlKG9iaik7XG4gICAgdmFyIHNjaGVtYVNlZW4gPSBleHBvcnRzLmZpbmQocGFyYW1zLnNlZW4sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNjaGVtYSA9PT0gc2NoZW1hRGVmOyB9KTtcbiAgICB2YXIgaXNOb25wcmltaXRpdmUgPSBbJ2FycmF5JywgJ29iamVjdCddLmluZGV4T2YocGFyc2VkVHlwZSkgIT09IC0xO1xuICAgIGlmIChpc05vbnByaW1pdGl2ZSkge1xuICAgICAgICBpZiAoc2NoZW1hU2Vlbikge1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gZXhwb3J0cy5maW5kKHNjaGVtYVNlZW4ub2JqZWN0cywgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguZGF0YSA9PT0gb2JqOyB9KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmb3VuZC5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm91bmQudGltZXMgPSBmb3VuZC50aW1lcyArIDE7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kLnRpbWVzID4gNSAmJiBpc05vbnByaW1pdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sKCdyZWN1cnNpb24gZGVwdGggZXhjZWVkZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvdW5kLnRpbWVzID4gMikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgc2NoZW1hU2Vlbi5vYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZWVuLnB1c2goe1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hRGVmLFxuICAgICAgICAgICAgICAgIG9iamVjdHM6IFt7IGRhdGE6IG9iaiwgZXJyb3I6IHVuZGVmaW5lZCwgdGltZXM6IDEgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zdCBzZXRFcnJvciA9IChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAvLyAgIGNvbnN0IHNjaGVtYVNlZW4gPSBwYXJhbXMuc2Vlbi5maW5kKHggPT4geC5zY2hlbWEgPT09IHNjaGVtYURlZik7XG4gICAgLy8gICBpZiAoc2NoZW1hU2Vlbikge1xuICAgIC8vICAgICBjb25zdCBmb3VuZCA9IHNjaGVtYVNlZW4ub2JqZWN0cy5maW5kKHggPT4geC5kYXRhID09PSBvYmopO1xuICAgIC8vICAgICBpZiAoZm91bmQpIHtcbiAgICAvLyAgICAgICBmb3VuZC5lcnJvciA9IGVycm9yO1xuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gfTtcbiAgICB2YXIgZXJyb3IgPSBuZXcgWm9kRXJyb3JfMS5ab2RFcnJvcihbXSk7XG4gICAgdmFyIHJldHVyblZhbHVlID0gb2JqO1xuICAgIHN3aXRjaCAoZGVmLnQpIHtcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnN0cmluZzpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm51bWJlcjpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG9iaikpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5uYW4sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuYmlnaW50OlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuYm9vbGVhbjpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudW5kZWZpbmVkOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubnVsbDpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuYW55OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy51bmtub3duOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy52b2lkOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS51bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuYXJyYXk6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhID0gb2JqO1xuICAgICAgICAgICAgaWYgKGRlZi5ub25lbXB0eSA9PT0gdHJ1ZSAmJiBvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLm5vbmVtcHR5X2FycmF5X2lzX2VtcHR5LFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRJdGVtID0gZGVmLnR5cGUucGFyc2UoaXRlbSwgX19hc3NpZ24oe30sIHBhcmFtcywgeyBwYXRoOiBwYXJhbXMucGF0aC5jb25jYXQoW2ldKSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRJdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6ZXJyID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcnMoemVyci5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFlcnJvci5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5vYmplY3Q6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNoYXBlID0gZGVmLnNoYXBlKCk7XG4gICAgICAgICAgICBpZiAoZGVmLnBhcmFtcy5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGVLZXlzXzEgPSBPYmplY3Qua2V5cyhzaGFwZSk7XG4gICAgICAgICAgICAgICAgdmFyIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgICAgIHZhciBleHRyYUtleXMgPSBvYmpLZXlzLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gc2hhcGVLZXlzXzEuaW5kZXhPZihrKSA9PT0gLTE7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChleHRyYUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zaGFwZSgpW2tleV0ucGFyc2Uob2JqW2tleV0sIF9fYXNzaWduKHt9LCBwYXJhbXMsIHsgcGF0aDogcGFyYW1zLnBhdGguY29uY2F0KFtrZXldKSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHplcnIgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9ycyh6ZXJyLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy51bmlvbjpcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdW5pb25FcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBkZWYub3B0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi5wYXJzZShvYmosIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRFcnJvcnMgPSB1bmlvbkVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyLmVycm9yc1swXS5jb2RlICE9PSAnaW52YWxpZF90eXBlJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRFcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9ycyhmaWx0ZXJlZEVycm9yc1swXS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pb25FcnJvcnM6IHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5pbnRlcnNlY3Rpb246XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRlZi5sZWZ0LnBhcnNlKG9iaiwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcnMoZXJyLmVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRlZi5yaWdodC5wYXJzZShvYmosIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3JzKGVyci5lcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy50dXBsZTpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggPiBkZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmoubGVuZ3RoIDwgZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyc2VkVHVwbGUgPSBbXTtcbiAgICAgICAgICAgIHZhciB0dXBsZURhdGEgPSBvYmo7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCBpbiB0dXBsZURhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHR1cGxlRGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1QYXJzZXIgPSBkZWYuaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFR1cGxlLnB1c2goaXRlbVBhcnNlci5wYXJzZShpdGVtLCBfX2Fzc2lnbih7fSwgcGFyYW1zLCB7IHBhdGg6IHBhcmFtcy5wYXRoLmNvbmNhdChbaW5kZXhdKSB9KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9ycyhlcnIuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmxhenk6XG4gICAgICAgICAgICB2YXIgbGF6eVNjaGVtYSA9IGRlZi5nZXR0ZXIoKTtcbiAgICAgICAgICAgIGxhenlTY2hlbWEucGFyc2Uob2JqLCBwYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5saXRlcmFsOlxuICAgICAgICAgICAgaWYgKG9iaiAhPT0gZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfbGl0ZXJhbF92YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGRlZi52YWx1ZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmVudW06XG4gICAgICAgICAgICBpZiAoZGVmLnZhbHVlcy5pbmRleE9mKG9iaikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZGVmLnZhbHVlcyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm5hdGl2ZUVudW06XG4gICAgICAgICAgICBpZiAodXRpbF8xLnV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKGRlZi52YWx1ZXMpLmluZGV4T2Yob2JqKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB1dGlsXzEudXRpbC5nZXRWYWx1ZXMoZGVmLnZhbHVlcyksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5rZXlvZjpcbiAgICAgICAgICAgIGlmICh1dGlsXzEudXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMoZGVmLnZhbHVlcykuaW5kZXhPZihvYmopID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHV0aWxfMS51dGlsLmdldFZhbHVlcyhkZWYudmFsdWVzKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmZ1bmN0aW9uOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGVkRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLmFyZ3MucGFyc2UoYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFpvZEVycm9yXzEuWm9kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzRXJyb3IgPSBuZXcgWm9kRXJyb3JfMS5ab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzRXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGFyZ3NFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmouYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnJldHVybnMucGFyc2UocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgWm9kRXJyb3JfMS5ab2RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybnNFcnJvciA9IG5ldyBab2RFcnJvcl8xLlpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnNFcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmV0dXJuc0Vycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5yZWNvcmQ6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZVR5cGUucGFyc2Uob2JqW2tleV0sIF9fYXNzaWduKHt9LCBwYXJhbXMsIHsgcGF0aDogcGFyYW1zLnBhdGguY29uY2F0KFtrZXldKSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3JzKGVyci5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuZGF0ZTpcbiAgICAgICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKG9iai5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5wcm9taXNlOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmpWYWx1ZSwgcGFyc2VkO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBvYmpdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGRlZi50eXBlLnBhcnNlKG9ialZhbHVlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWooZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1dGlsXzEudXRpbC5hc3NlcnROZXZlcihkZWYpO1xuICAgIH1cbiAgICB2YXIgY3VzdG9tQ2hlY2tzID0gZGVmLmNoZWNrcyB8fCBbXTtcbiAgICBmb3IgKHZhciBfYiA9IDAsIGN1c3RvbUNoZWNrc18xID0gY3VzdG9tQ2hlY2tzOyBfYiA8IGN1c3RvbUNoZWNrc18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICB2YXIgY2hlY2sgPSBjdXN0b21DaGVja3NfMVtfYl07XG4gICAgICAgIGlmICghY2hlY2suY2hlY2socmV0dXJuVmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tNZXRob2QgPSBjaGVjay5jaGVjaywgbm9NZXRob2RDaGVjayA9IF9fcmVzdChjaGVjaywgW1wiY2hlY2tcIl0pO1xuICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCBub01ldGhvZENoZWNrKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFlcnJvci5pc0VtcHR5KSB7XG4gICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn07IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZEFueSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kQW55LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZEFueSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZEFueS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQW55KHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMuYW55LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RBbnk7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RBbnkgPSBab2RBbnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbi8vIGltcG9ydCB7IFpvZFVuZGVmaW5lZCB9IGZyb20gJy4vdW5kZWZpbmVkJztcbi8vIGltcG9ydCB7IFpvZE51bGwgfSBmcm9tICcuL251bGwnO1xuLy8gaW1wb3J0IHsgWm9kVW5pb24gfSBmcm9tICcuL3VuaW9uJztcbnZhciBab2RFcnJvcl8xID0gcmVxdWlyZShcIi4uL1pvZEVycm9yXCIpO1xudmFyIFpvZEFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RBcnJheSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RBcnJheSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdDogX3RoaXMuX2RlZi50LFxuICAgICAgICAgICAgICAgIG5vbmVtcHR5OiBfdGhpcy5fZGVmLm5vbmVtcHR5LFxuICAgICAgICAgICAgICAgIHR5cGU6IF90aGlzLl9kZWYudHlwZS50b0pTT04oKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy5taW4gPSBmdW5jdGlvbiAobWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEubGVuZ3RoID49IG1pbkxlbmd0aDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX3NtYWxsLCB0eXBlOiAnYXJyYXknLCBpbmNsdXNpdmU6IHRydWUsIG1pbmltdW06IG1pbkxlbmd0aCB9LCAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8geyBtZXNzYWdlOiBtZXNzYWdlIH0gOiBtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tYXggPSBmdW5jdGlvbiAobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEubGVuZ3RoIDw9IG1heExlbmd0aDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX2JpZywgdHlwZTogJ2FycmF5JywgaW5jbHVzaXZlOiB0cnVlLCBtYXhpbXVtOiBtYXhMZW5ndGggfSwgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IHsgbWVzc2FnZTogbWVzc2FnZSB9IDogbWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubGVuZ3RoID0gZnVuY3Rpb24gKGxlbiwgbWVzc2FnZSkgeyByZXR1cm4gX3RoaXMubWluKGxlbiwgeyBtZXNzYWdlOiBtZXNzYWdlIH0pLm1heChsZW4sIHsgbWVzc2FnZTogbWVzc2FnZSB9KTsgfTtcbiAgICAgICAgX3RoaXMubm9uZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZE5vbkVtcHR5QXJyYXkoX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgbm9uZW1wdHk6IHRydWUgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RBcnJheS5wcm90b3R5cGUsIFwiZWxlbWVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBab2RBcnJheS5jcmVhdGUgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5hcnJheSxcbiAgICAgICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgICAgIG5vbmVtcHR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kQXJyYXk7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RBcnJheSA9IFpvZEFycmF5O1xudmFyIFpvZE5vbkVtcHR5QXJyYXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZE5vbkVtcHR5QXJyYXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kTm9uRW1wdHlBcnJheSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdDogX3RoaXMuX2RlZi50LFxuICAgICAgICAgICAgICAgIHR5cGU6IF90aGlzLl9kZWYudHlwZS50b0pTT04oKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy5taW4gPSBmdW5jdGlvbiAobWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEubGVuZ3RoID49IG1pbkxlbmd0aDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX3NtYWxsLCBtaW5pbXVtOiBtaW5MZW5ndGgsIHR5cGU6ICdhcnJheScsIGluY2x1c2l2ZTogdHJ1ZSB9LCAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8geyBtZXNzYWdlOiBtZXNzYWdlIH0gOiBtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tYXggPSBmdW5jdGlvbiAobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEubGVuZ3RoIDw9IG1heExlbmd0aDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX2JpZywgbWF4aW11bTogbWF4TGVuZ3RoLCB0eXBlOiAnYXJyYXknLCBpbmNsdXNpdmU6IHRydWUgfSwgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IHsgbWVzc2FnZTogbWVzc2FnZSB9IDogbWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubGVuZ3RoID0gZnVuY3Rpb24gKGxlbiwgbWVzc2FnZSkgeyByZXR1cm4gX3RoaXMubWluKGxlbiwgeyBtZXNzYWdlOiBtZXNzYWdlIH0pLm1heChsZW4sIHsgbWVzc2FnZTogbWVzc2FnZSB9KTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gWm9kTm9uRW1wdHlBcnJheTtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZE5vbkVtcHR5QXJyYXkgPSBab2ROb25FbXB0eUFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4uL3BhcnNlclwiKTtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIFpvZFR5cGVzO1xuKGZ1bmN0aW9uIChab2RUeXBlcykge1xuICAgIFpvZFR5cGVzW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBab2RUeXBlc1tcIm51bWJlclwiXSA9IFwibnVtYmVyXCI7XG4gICAgWm9kVHlwZXNbXCJiaWdpbnRcIl0gPSBcImJpZ2ludFwiO1xuICAgIFpvZFR5cGVzW1wiYm9vbGVhblwiXSA9IFwiYm9vbGVhblwiO1xuICAgIFpvZFR5cGVzW1wiZGF0ZVwiXSA9IFwiZGF0ZVwiO1xuICAgIFpvZFR5cGVzW1widW5kZWZpbmVkXCJdID0gXCJ1bmRlZmluZWRcIjtcbiAgICBab2RUeXBlc1tcIm51bGxcIl0gPSBcIm51bGxcIjtcbiAgICBab2RUeXBlc1tcImFycmF5XCJdID0gXCJhcnJheVwiO1xuICAgIFpvZFR5cGVzW1wib2JqZWN0XCJdID0gXCJvYmplY3RcIjtcbiAgICBab2RUeXBlc1tcInVuaW9uXCJdID0gXCJ1bmlvblwiO1xuICAgIFpvZFR5cGVzW1wiaW50ZXJzZWN0aW9uXCJdID0gXCJpbnRlcnNlY3Rpb25cIjtcbiAgICBab2RUeXBlc1tcInR1cGxlXCJdID0gXCJ0dXBsZVwiO1xuICAgIFpvZFR5cGVzW1wicmVjb3JkXCJdID0gXCJyZWNvcmRcIjtcbiAgICBab2RUeXBlc1tcImZ1bmN0aW9uXCJdID0gXCJmdW5jdGlvblwiO1xuICAgIFpvZFR5cGVzW1wibGF6eVwiXSA9IFwibGF6eVwiO1xuICAgIFpvZFR5cGVzW1wibGl0ZXJhbFwiXSA9IFwibGl0ZXJhbFwiO1xuICAgIFpvZFR5cGVzW1wiZW51bVwiXSA9IFwiZW51bVwiO1xuICAgIFpvZFR5cGVzW1wibmF0aXZlRW51bVwiXSA9IFwibmF0aXZlRW51bVwiO1xuICAgIFpvZFR5cGVzW1wicHJvbWlzZVwiXSA9IFwicHJvbWlzZVwiO1xuICAgIFpvZFR5cGVzW1wiYW55XCJdID0gXCJhbnlcIjtcbiAgICBab2RUeXBlc1tcInVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgICBab2RUeXBlc1tcInZvaWRcIl0gPSBcInZvaWRcIjtcbiAgICBab2RUeXBlc1tcImtleW9mXCJdID0gXCJrZXlvZlwiO1xufSkoWm9kVHlwZXMgPSBleHBvcnRzLlpvZFR5cGVzIHx8IChleHBvcnRzLlpvZFR5cGVzID0ge30pKTtcbnZhciBab2RUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpvZFR5cGUoZGVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gZnVuY3Rpb24gKGRhdGEsIHBhcmFtcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gX3RoaXMucGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJzZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgaW5kZXhfMS5ab2RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IGZ1bmN0aW9uICh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IF90aGlzLnBhcnNlKHZhbHVlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlaihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlZmluZSA9IGZ1bmN0aW9uIChjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gJ0ludmFsaWQgdmFsdWUuJzsgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZWZpbmVtZW50KHsgY2hlY2s6IGNoZWNrLCBtZXNzYWdlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogY2hlY2sgfSwgbWVzc2FnZSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSBmdW5jdGlvbiAocmVmaW5lbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY29kZTogaW5kZXhfMS5ab2RFcnJvckNvZGUuY3VzdG9tX2Vycm9yIH0sIHJlZmluZW1lbnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcmVmaW5lbWVudCA9IGZ1bmN0aW9uIChyZWZpbmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF90aGlzLmNvbnN0cnVjdG9yKF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IGNoZWNrczogKF90aGlzLl9kZWYuY2hlY2tzIHx8IFtdKS5jb25jYXQoW3JlZmluZW1lbnRdKSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vICBhYnN0cmFjdCAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IGFueTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleF8xLlpvZFVuaW9uLmNyZWF0ZShbX3RoaXMsIGluZGV4XzEuWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubnVsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhfMS5ab2RVbmlvbi5jcmVhdGUoW190aGlzLCBpbmRleF8xLlpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcnJheSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4XzEuWm9kQXJyYXkuY3JlYXRlKF90aGlzKTsgfTtcbiAgICAgICAgdGhpcy5vciA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleF8xLlpvZFVuaW9uLmNyZWF0ZShbX3RoaXMsIGFyZ10pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZXJfMS5ab2RQYXJzZXIoZGVmKTtcbiAgICB9XG4gICAgWm9kVHlwZS5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAodSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZSh1KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWm9kVHlwZS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAodSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZSh1KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFpvZFR5cGU7XG59KCkpO1xuZXhwb3J0cy5ab2RUeXBlID0gWm9kVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZEJpZ0ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kQmlnSW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZEJpZ0ludCgpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZEJpZ0ludC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMuYmlnaW50LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RCaWdJbnQ7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RCaWdJbnQgPSBab2RCaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaWdpbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZEJvb2xlYW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZEJvb2xlYW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kQm9vbGVhbigpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZEJvb2xlYW4uY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5ib29sZWFuLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RCb29sZWFuO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kQm9vbGVhbiA9IFpvZEJvb2xlYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2REYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2REYXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZERhdGUoKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2REYXRlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMuZGF0ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kRGF0ZTtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZERhdGUgPSBab2REYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kRW51bSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kRW51bSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RFbnVtKCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZEVudW0ucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kRW51bS5wcm90b3R5cGUsIFwiZW51bVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9kZWYudmFsdWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RFbnVtLnByb3RvdHlwZSwgXCJWYWx1ZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbnVtVmFsdWVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fZGVmLnZhbHVlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kRW51bS5wcm90b3R5cGUsIFwiRW51bVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9kZWYudmFsdWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFpvZEVudW0uY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5lbnVtLFxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZEVudW07XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RFbnVtID0gWm9kRW51bTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHVwbGVcIik7XG52YXIgdW5rbm93bl8xID0gcmVxdWlyZShcIi4vdW5rbm93blwiKTtcbnZhciBab2RGdW5jdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kRnVuY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hcmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IGFyZ3M6IHR1cGxlXzEuWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJldHVybnMgPSBmdW5jdGlvbiAocmV0dXJuVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbihfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyByZXR1cm5zOiByZXR1cm5UeXBlIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaW1wbGVtZW50ID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZWRGdW5jID0gX3RoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudmFsaWRhdGUgPSBfdGhpcy5pbXBsZW1lbnQ7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHQ6IF90aGlzLl9kZWYudCxcbiAgICAgICAgICAgICAgICBhcmdzOiBfdGhpcy5fZGVmLmFyZ3MudG9KU09OKCksXG4gICAgICAgICAgICAgICAgcmV0dXJuczogX3RoaXMuX2RlZi5yZXR1cm5zLnRvSlNPTigpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RGdW5jdGlvbi5jcmVhdGUgPSBmdW5jdGlvbiAoYXJncywgcmV0dXJucykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMuZnVuY3Rpb24sXG4gICAgICAgICAgICBhcmdzOiBhcmdzIHx8IHR1cGxlXzEuWm9kVHVwbGUuY3JlYXRlKFtdKSxcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVybnMgfHwgdW5rbm93bl8xLlpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZEZ1bmN0aW9uO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kRnVuY3Rpb24gPSBab2RGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RJbnRlcnNlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZEludGVyc2VjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RJbnRlcnNlY3Rpb24oKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHQ6IF90aGlzLl9kZWYudCxcbiAgICAgICAgICAgIGxlZnQ6IF90aGlzLl9kZWYubGVmdC50b0pTT04oKSxcbiAgICAgICAgICAgIHJpZ2h0OiBfdGhpcy5fZGVmLnJpZ2h0LnRvSlNPTigpLFxuICAgICAgICB9KTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMuaW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kSW50ZXJzZWN0aW9uID0gWm9kSW50ZXJzZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJzZWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RLZXlvZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kS2V5b2YsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kS2V5b2YoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgdDogX3RoaXMuX2RlZi50LFxuICAgICAgICAgICAgdmFsdWVzOiBfdGhpcy5fZGVmLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9TdHJpbmcoKTsgfSksXG4gICAgICAgIH0pOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZEtleW9mLmNyZWF0ZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RLZXlvZih7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmtleW9mLFxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgY2FzdCBpcyBub3QgY29ycmVjdCBpbiB0aGUgZ2VuZXJhbCBjYXNlXG4gICAgICAgICAgICAvLyBTZWUgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEyODcwXG4gICAgICAgICAgICB2YWx1ZXM6IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZEtleW9mO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kS2V5b2YgPSBab2RLZXlvZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleW9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RMYXp5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RMYXp5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZExhenkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgSlNPTmlmeSByZWN1cnNpdmUgc3RydWN0dXJlXCIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RMYXp5LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFpvZExhenkuY3JlYXRlID0gZnVuY3Rpb24gKGdldHRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5sYXp5LFxuICAgICAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZExhenk7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RMYXp5ID0gWm9kTGF6eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhenkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZExpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZExpdGVyYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kTGl0ZXJhbCgpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZExpdGVyYWwuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmxpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZExpdGVyYWw7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RMaXRlcmFsID0gWm9kTGl0ZXJhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdGVyYWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZE5hdGl2ZUVudW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZE5hdGl2ZUVudW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kTmF0aXZlRW51bSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kTmF0aXZlRW51bS5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLm5hdGl2ZUVudW0sXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kTmF0aXZlRW51bTtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZE5hdGl2ZUVudW0gPSBab2ROYXRpdmVFbnVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF0aXZlRW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kTnVsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kTnVsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2ROdWxsKCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kTnVsbC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLm51bGwsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZE51bGw7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2ROdWxsID0gWm9kTnVsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbi8vIGltcG9ydCB7IFpvZFVuZGVmaW5lZCB9IGZyb20gJy4vdW5kZWZpbmVkJztcbi8vIGltcG9ydCB7IFpvZE51bGwgfSBmcm9tICcuL251bGwnO1xuLy8gaW1wb3J0IHsgWm9kVW5pb24gfSBmcm9tICcuL3VuaW9uJztcbnZhciBab2RFcnJvcl8xID0gcmVxdWlyZShcIi4uL1pvZEVycm9yXCIpO1xudmFyIGVycm9yVXRpbF8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZXJyb3JVdGlsXCIpO1xudmFyIFpvZE51bWJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kTnVtYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZE51bWJlcigpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICBfdGhpcy5taW4gPSBmdW5jdGlvbiAobWluaW11bSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhID49IG1pbmltdW07IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19zbWFsbCwgbWluaW11bTogbWluaW11bSwgdHlwZTogJ251bWJlcicsIGluY2x1c2l2ZTogdHJ1ZSB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWF4ID0gZnVuY3Rpb24gKG1heGltdW0sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSA8PSBtYXhpbXVtOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fYmlnLCBtYXhpbXVtOiBtYXhpbXVtLCB0eXBlOiAnbnVtYmVyJywgaW5jbHVzaXZlOiB0cnVlIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pbnQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGRhdGEpOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiAnaW50ZWdlcicsIHJlY2VpdmVkOiAnbnVtYmVyJyB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucG9zaXRpdmUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhID4gMDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX3NtYWxsLCBtaW5pbXVtOiAwLCB0eXBlOiAnbnVtYmVyJywgaW5jbHVzaXZlOiBmYWxzZSB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubmVnYXRpdmUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhIDwgMDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX2JpZywgbWF4aW11bTogMCwgdHlwZTogJ251bWJlcicsIGluY2x1c2l2ZTogZmFsc2UgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm5vbnBvc2l0aXZlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSA8PSAwOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fYmlnLCBtYXhpbXVtOiAwLCB0eXBlOiAnbnVtYmVyJywgaW5jbHVzaXZlOiB0cnVlIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5ub25uZWdhdGl2ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgPj0gMDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX3NtYWxsLCBtaW5pbXVtOiAwLCB0eXBlOiAnbnVtYmVyJywgaW5jbHVzaXZlOiB0cnVlIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZE51bWJlci5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMubnVtYmVyLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2ROdW1iZXI7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2ROdW1iZXIgPSBab2ROdW1iZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBvYmplY3RVdGlsXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9vYmplY3RVdGlsXCIpO1xudmFyIGlzU2NhbGFyXzEgPSByZXF1aXJlKFwiLi4vaXNTY2FsYXJcIik7XG52YXIgQXVnbWVudEZhY3RvcnkgPSBmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBmdW5jdGlvbiAoYXVnbWVudGF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3QoX19hc3NpZ24oe30sIGRlZiwgeyBzaGFwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBkZWYuc2hhcGUoKSwgYXVnbWVudGF0aW9uKSk7IH0gfSkpO1xufTsgfTtcbnZhciBvYmplY3REZWZUb0pzb24gPSBmdW5jdGlvbiAoZGVmKSB7IHJldHVybiAoe1xuICAgIHQ6IGRlZi50LFxuICAgIHNoYXBlOiBPYmplY3QuYXNzaWduKHt9LCBPYmplY3Qua2V5cyhkZWYuc2hhcGUoKSkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHt9LFxuICAgICAgICAgICAgX2Fba10gPSBkZWYuc2hhcGUoKVtrXS50b0pTT04oKSxcbiAgICAgICAgICAgIF9hKTtcbiAgICB9KSksXG59KTsgfTtcbnZhciBab2RPYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZE9iamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RPYmplY3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmplY3REZWZUb0pzb24oX3RoaXMuX2RlZik7IH07XG4gICAgICAgIF90aGlzLm5vbnN0cmljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBzaGFwZTogX3RoaXMuX2RlZi5zaGFwZSxcbiAgICAgICAgICAgICAgICB0OiB6LlpvZFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IF9fYXNzaWduKHt9LCBfdGhpcy5fcGFyYW1zLCB7IHN0cmljdDogZmFsc2UgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICAvLyBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy5hdWdtZW50ID0gQXVnbWVudEZhY3RvcnkoX3RoaXMuX2RlZik7XG4gICAgICAgIF90aGlzLmV4dGVuZCA9IEF1Z21lbnRGYWN0b3J5KF90aGlzLl9kZWYpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICAgICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxuICAgICAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm1lcmdlID0gb2JqZWN0VXRpbF8xLm9iamVjdFV0aWwubWVyZ2VPYmplY3RzKF90aGlzKTtcbiAgICAgICAgX3RoaXMucGljayA9IGZ1bmN0aW9uIChtYXNrKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1hc2spLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IF90aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IHNoYXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFwZTsgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9taXQgPSBmdW5jdGlvbiAobWFzaykge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfdGhpcy5zaGFwZSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobWFzaykuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gX3RoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IHNoYXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFwZTsgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnBhcnRpYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBfdGhpcy5zaGFwZSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBfdGhpcy5zaGFwZVtrZXldLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdChfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyBzaGFwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3U2hhcGU7IH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5wcmltaXRpdmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX3RoaXMuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTY2FsYXJfMS5pc1NjYWxhcihfdGhpcy5zaGFwZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gX3RoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdChfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyBzaGFwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3U2hhcGU7IH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5ub25wcmltaXRpdmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX3RoaXMuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2NhbGFyXzEuaXNTY2FsYXIoX3RoaXMuc2hhcGVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IF90aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3QoX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgc2hhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ld1NoYXBlOyB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVlcFBhcnRpYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBfdGhpcy5zaGFwZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZFNjaGVtYSA9IF90aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkU2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYS5kZWVwUGFydGlhbCgpLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gX3RoaXMuc2hhcGVba2V5XS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IHNoYXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXdTaGFwZTsgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZE9iamVjdC5wcm90b3R5cGUsIFwic2hhcGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZE9iamVjdC5wcm90b3R5cGUsIFwicGFyYW1zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnBhcmFtcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgWm9kT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIHNoYXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFwZTsgfSxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWm9kT2JqZWN0LmxhenljcmVhdGUgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RPYmplY3Q7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RPYmplY3QgPSBab2RPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZFByb21pc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZFByb21pc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kUHJvbWlzZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdDogX3RoaXMuX2RlZi50LFxuICAgICAgICAgICAgICAgIHR5cGU6IF90aGlzLl9kZWYudHlwZS50b0pTT04oKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICBab2RQcm9taXNlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMucHJvbWlzZSxcbiAgICAgICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kUHJvbWlzZTtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZFByb21pc2UgPSBab2RQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kUmVjb3JkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kUmVjb3JkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHQ6IF90aGlzLl9kZWYudCxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogX3RoaXMuX2RlZi52YWx1ZVR5cGUudG9KU09OKCksXG4gICAgICAgIH0pOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgWm9kUmVjb3JkLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5yZWNvcmQsXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kUmVjb3JkO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kUmVjb3JkID0gWm9kUmVjb3JkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjb3JkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG4vLyBpbXBvcnQgeyBab2RVbmRlZmluZWQgfSBmcm9tICcuL3VuZGVmaW5lZCc7XG4vLyBpbXBvcnQgeyBab2ROdWxsIH0gZnJvbSAnLi9udWxsJztcbi8vIGltcG9ydCB7IFpvZFVuaW9uIH0gZnJvbSAnLi91bmlvbic7XG52YXIgWm9kRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9ab2RFcnJvclwiKTtcbnZhciBlcnJvclV0aWxfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Vycm9yVXRpbFwiKTtcbnZhciBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xudmFyIHV1aWRSZWdleCA9IC9eW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tNFthLWYwLTldezN9LVs4OWFBYkJdW2EtZjAtOV17M30tW2EtZjAtOV17MTJ9JC9pO1xudmFyIFpvZFN0cmluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kU3RyaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZFN0cmluZygpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICBfdGhpcy5taW4gPSBmdW5jdGlvbiAobWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEubGVuZ3RoID49IG1pbkxlbmd0aDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX3NtYWxsLCBtaW5pbXVtOiBtaW5MZW5ndGgsIHR5cGU6ICdzdHJpbmcnLCBpbmNsdXNpdmU6IHRydWUgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm1heCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YS5sZW5ndGggPD0gbWF4TGVuZ3RoOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fYmlnLCBtYXhpbXVtOiBtYXhMZW5ndGgsIHR5cGU6ICdzdHJpbmcnLCBpbmNsdXNpdmU6IHRydWUgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9yZWdleCA9IGZ1bmN0aW9uIChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgdmFsaWRhdGlvbjogdmFsaWRhdGlvbiwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9zdHJpbmcsIGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gcmVnZXgudGVzdChkYXRhKTsgfSB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZW1haWwgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWdleChlbWFpbFJlZ2V4LCAnZW1haWwnLCBtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudXJsID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9zdHJpbmcsIHZhbGlkYXRpb246ICd1cmwnIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB1cmwgPSAobWVzc2FnZT86IGVycm9yVXRpbC5FcnJNZXNzYWdlKSA9PiB0aGlzLl9yZWdleCh1cmxSZWdleCwgJ3VybCcsIG1lc3NhZ2UpO1xuICAgICAgICBfdGhpcy51dWlkID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVnZXgodXVpZFJlZ2V4LCAndXVpZCcsIG1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZWdleCA9IGZ1bmN0aW9uIChyZWdleHAsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVnZXgocmVnZXhwLCAncmVnZXgnLCBtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubm9uZW1wdHkgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1pbigxLCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZFN0cmluZy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4obGVuLCBtZXNzYWdlKS5tYXgobGVuLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIFpvZFN0cmluZy5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjoge30sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZFN0cmluZztcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZFN0cmluZyA9IFpvZFN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kVHVwbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZFR1cGxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZFR1cGxlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHQ6IF90aGlzLl9kZWYudCxcbiAgICAgICAgICAgIGl0ZW1zOiBfdGhpcy5fZGVmLml0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS50b0pTT04oKTsgfSksXG4gICAgICAgIH0pOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgWm9kVHVwbGUuY3JlYXRlID0gZnVuY3Rpb24gKHNjaGVtYXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLnR1cGxlLFxuICAgICAgICAgICAgaXRlbXM6IHNjaGVtYXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZFR1cGxlO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kVHVwbGUgPSBab2RUdXBsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR1cGxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RVbmRlZmluZWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZFVuZGVmaW5lZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RVbmRlZmluZWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy51bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZFVuZGVmaW5lZDtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZFVuZGVmaW5lZCA9IFpvZFVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZGVmaW5lZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kVW5pb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZFVuaW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZFVuaW9uKCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICB0OiBfdGhpcy5fZGVmLnQsXG4gICAgICAgICAgICBvcHRpb25zOiBfdGhpcy5fZGVmLm9wdGlvbnMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRvSlNPTigpOyB9KSxcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gZGlzdHJpYnV0ZSA9IDxGIGV4dGVuZHMgKGFyZzogVFtudW1iZXJdKSA9PiB6LlpvZFR5cGVBbnk+KGY6IEYpOiBab2RVbmlvbjx7IFtrIGluIGtleW9mIFRdOiBSZXR1cm5UeXBlPEY+IH0+ID0+IHtcbiAgICAvLyAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUodGhpcy5fZGVmLm9wdGlvbnMubWFwKGYpIGFzIGFueSk7XG4gICAgLy8gfTtcbiAgICBab2RVbmlvbi5jcmVhdGUgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLnVuaW9uLFxuICAgICAgICAgICAgb3B0aW9uczogdHlwZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZFVuaW9uO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kVW5pb24gPSBab2RVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RVbmtub3duID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RVbmtub3duLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZFVua25vd24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RVbmtub3duLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMudW5rbm93bixcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kVW5rbm93bjtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZFVua25vd24gPSBab2RVbmtub3duO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5rbm93bi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kVm9pZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kVm9pZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RWb2lkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kVm9pZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLnZvaWQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZFZvaWQ7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RWb2lkID0gWm9kVm9pZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZvaWQuanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG4gICAgdmFyIHJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgY29uZmlnLnRyYW5zaXRpb25hbCAmJiBjb25maWcudHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyAnRVRJTUVET1VUJyA6ICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vY29yZS9tZXJnZUNvbmZpZycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhheGlvcy5kZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0F4aW9zRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcbnZhciB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ZhbGlkYXRvcicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWw7XG5cbiAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4sICcxLjAuMCcpLFxuICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKVxuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgdmFyIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHZhciBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2U7XG5cbiAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICBjaGFpbiA9IGNoYWluLmNvbmNhdChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuXG4gIHZhciBuZXdDb25maWcgPSBjb25maWc7XG4gIHdoaWxlIChyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICB2YXIgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHZhciBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25SZWplY3RlZChlcnJvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QobmV3Q29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG5cbiAgd2hpbGUgKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZCxcbiAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICBydW5XaGVuOiBvcHRpb25zID8gb3B0aW9ucy5ydW5XaGVuIDogbnVsbFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICB2YXIgdmFsdWVGcm9tQ29uZmlnMktleXMgPSBbJ3VybCcsICdtZXRob2QnLCAnZGF0YSddO1xuICB2YXIgbWVyZ2VEZWVwUHJvcGVydGllc0tleXMgPSBbJ2hlYWRlcnMnLCAnYXV0aCcsICdwcm94eScsICdwYXJhbXMnXTtcbiAgdmFyIGRlZmF1bHRUb0NvbmZpZzJLZXlzID0gW1xuICAgICdiYXNlVVJMJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAndGltZW91dE1lc3NhZ2UnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLCAnZGVjb21wcmVzcycsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnLCAnbWF4Qm9keUxlbmd0aCcsICdtYXhSZWRpcmVjdHMnLCAndHJhbnNwb3J0JywgJ2h0dHBBZ2VudCcsXG4gICAgJ2h0dHBzQWdlbnQnLCAnY2FuY2VsVG9rZW4nLCAnc29ja2V0UGF0aCcsICdyZXNwb25zZUVuY29kaW5nJ1xuICBdO1xuICB2YXIgZGlyZWN0TWVyZ2VLZXlzID0gWyd2YWxpZGF0ZVN0YXR1cyddO1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdXRpbHMuZm9yRWFjaCh2YWx1ZUZyb21Db25maWcyS2V5cywgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHV0aWxzLmZvckVhY2goZGVmYXVsdFRvQ29uZmlnMktleXMsIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKGRpcmVjdE1lcmdlS2V5cywgZnVuY3Rpb24gbWVyZ2UocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGF4aW9zS2V5cyA9IHZhbHVlRnJvbUNvbmZpZzJLZXlzXG4gICAgLmNvbmNhdChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cylcbiAgICAuY29uY2F0KGRlZmF1bHRUb0NvbmZpZzJLZXlzKVxuICAgIC5jb25jYXQoZGlyZWN0TWVyZ2VLZXlzKTtcblxuICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0XG4gICAgLmtleXMoY29uZmlnMSlcbiAgICAuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQXhpb3NLZXlzKGtleSkge1xuICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICB2YXIgY29udGV4dCA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29udGV4dCwgZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vY29yZS9lbmhhbmNlRXJyb3InKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDoge1xuICAgIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG4gIH0sXG5cbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSB8fCAoaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsO1xuICAgIHZhciBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgdmFyIGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICB2YXIgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmIChzdHJpY3RKU09OUGFyc2luZyB8fCAoZm9yY2VkSlNPTlBhcnNpbmcgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZW5oYW5jZUVycm9yKGUsIHRoaXMsICdFX0pTT05fUEFSU0UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGtnID0gcmVxdWlyZSgnLi8uLi8uLi9wYWNrYWdlLmpzb24nKTtcblxudmFyIHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUsIGkpIHtcbiAgdmFsaWRhdG9yc1t0eXBlXSA9IGZ1bmN0aW9uIHZhbGlkYXRvcih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IHR5cGUgfHwgJ2EnICsgKGkgPCAxID8gJ24gJyA6ICcgJykgKyB0eXBlO1xuICB9O1xufSk7XG5cbnZhciBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcbnZhciBjdXJyZW50VmVyQXJyID0gcGtnLnZlcnNpb24uc3BsaXQoJy4nKTtcblxuLyoqXG4gKiBDb21wYXJlIHBhY2thZ2UgdmVyc2lvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IHRoYW5WZXJzaW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPbGRlclZlcnNpb24odmVyc2lvbiwgdGhhblZlcnNpb24pIHtcbiAgdmFyIHBrZ1ZlcnNpb25BcnIgPSB0aGFuVmVyc2lvbiA/IHRoYW5WZXJzaW9uLnNwbGl0KCcuJykgOiBjdXJyZW50VmVyQXJyO1xuICB2YXIgZGVzdFZlciA9IHZlcnNpb24uc3BsaXQoJy4nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpZiAocGtnVmVyc2lvbkFycltpXSA+IGRlc3RWZXJbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGtnVmVyc2lvbkFycltpXSA8IGRlc3RWZXJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRyYW5zaXRpb25hbCBvcHRpb24gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nP30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIHZhciBpc0RlcHJlY2F0ZWQgPSB2ZXJzaW9uICYmIGlzT2xkZXJWZXJzaW9uKHZlcnNpb24pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBwa2cudmVyc2lvbiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG9wdCwgb3B0cykge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCBpbiAnICsgdmVyc2lvbikpO1xuICAgIH1cblxuICAgIGlmIChpc0RlcHJlY2F0ZWQgJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIG9wdCxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yID8gdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdHMpIDogdHJ1ZTtcbiAgfTtcbn07XG5cbi8qKlxuICogQXNzZXJ0IG9iamVjdCdzIHByb3BlcnRpZXMgdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxuICovXG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCBhbGxvd1Vua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIHZhciBvcHQgPSBrZXlzW2ldO1xuICAgIHZhciB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW29wdF07XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIG9wdGlvbiAnICsgb3B0KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2xkZXJWZXJzaW9uOiBpc09sZGVyVmVyc2lvbixcbiAgYXNzZXJ0T3B0aW9uczogYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yczogdmFsaWRhdG9yc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuY29uc3QgRHJvcGRvd24gPSAoeyBvcHRpb25zLCBzZWxlY3RlZE9wdGlvbiwgc2V0U2VsZWN0ZWRPcHRpb24gfSkgPT4ge1xyXG4gICAgY29uc3QgW2lzT3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBkcm9wZG93biA9IHVzZVJlZihudWxsKTtcclxuXHJcbiAgICAvLyBPcGVuL0Nsb3NlIG9uIGNsaWNrIG9mIGRyb3Bkb3duIGhlYWRlclxyXG4gICAgY29uc3QgdG9nZ2xlRHJvcGRvd24gPSAoKSA9PiBzZXRPcGVuKCFpc09wZW4pO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBzZWxlY3RlZCBvcHRpb24sIGNsb3NlIGRyb3Bkb3duXHJcbiAgICBjb25zdCBoYW5kbGVJdGVtQ2xpY2sgPSAoY3VycmVuY3kpID0+IHtcclxuICAgICAgICBzZXRTZWxlY3RlZE9wdGlvbihjdXJyZW5jeSk7XHJcbiAgICAgICAgc2V0T3BlbihmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENsb3NlIGRyb3Bkb3duIHdoZW4gY2xpY2tlZCBvdXRzaWRlXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrT3V0c2lkZShldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoZHJvcGRvd24uY3VycmVudCAmJiAhZHJvcGRvd24uY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRPcGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVDbGlja091dHNpZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbZHJvcGRvd25dKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHJvcGRvd25cIiByZWY9e2Ryb3Bkb3dufT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkcm9wZG93bi1oZWFkZXJcIiBvbkNsaWNrPXt0b2dnbGVEcm9wZG93bn0+XHJcbiAgICAgICAgICAgICAgICB7c2VsZWN0ZWRPcHRpb25cclxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZmluZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0aW9uKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uY3VycmVuY3kgPT09IHNlbGVjdGVkT3B0aW9uLmN1cnJlbmN5XHJcbiAgICAgICAgICAgICAgICAgICAgICApPy5jdXJyZW5jeVxyXG4gICAgICAgICAgICAgICAgICAgIDogXCJzZWxlY3QgYSB0b2tlblwifVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Bkcm9wZG93bi1ib2R5ICR7aXNPcGVuICYmIFwib3BlblwifWB9PlxyXG4gICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICAgIHsob3B0aW9ucyB8fCBbXSkubWFwKChpdGVtLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImRyb3Bkb3duLWl0ZW1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9e2l0ZW0uY3VycmVuY3l9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2l0ZW0uY3VycmVuY3l9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUl0ZW1DbGljayhpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpdGVtLmN1cnJlbmN5fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHJvcGRvd247XHJcbiIsImltcG9ydCB7IEZyYWdtZW50LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4vQnV0dG9uXCI7XHJcblxyXG5jb25zdCBJbWFnZXNVcGxvYWQgPSAoeyBzZXRGaWxlRmllbGRzIH0pID0+IHtcclxuXHJcbiAgICBjb25zdCBbZmlsZXNQcmV2aWV3QXJyYXksIHNldEZpbGVzUHJldmlld0FycmF5XSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIGNvbnN0IGZpbGVVcGxvYWRGaWVsZCA9IHVzZVJlZigpO1xyXG5cclxuICAgY29uc3QgaGFuZGxlRmlsZXNGaWVsZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgY29uc3QgZmlsZXNMaXN0ID0gZXZlbnQudGFyZ2V0LmZpbGVzO1xyXG4gICAgICAgY29uc3QgdGVtcEFycmF5ID0gW107XHJcbiAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgIHRlbXBBcnJheS5wdXNoKFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZXNMaXN0W2ldKSk7XHJcbiAgICAgICB9XHJcbiAgICAgICBzZXRGaWxlRmllbGRzKGZpbGVzTGlzdCk7XHJcbiAgICAgICBzZXRGaWxlc1ByZXZpZXdBcnJheSh0ZW1wQXJyYXkpO1xyXG4gICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEZyYWdtZW50PlxyXG4gICAgICAgICAgICB7ZmlsZXNQcmV2aWV3QXJyYXkubGVuZ3RoID4gMCAmJiAoXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93IGltYWdlcy1hcnJheVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHsoZmlsZXNQcmV2aWV3QXJyYXkgfHwgW10pLm1hcCgodXJsLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz17dXJsfSBhbHQ9XCJcIiBrZXk9e2luZGV4fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3dcIj5cclxuICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJmaWxlXCJcclxuICAgICAgICAgICAgICAgICAgICBhY2NlcHQ9XCJpbWFnZS8qXCJcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlkPVwicHVyY2hhc2UtaW1hZ2VzXCJcclxuICAgICAgICAgICAgICAgICAgICByZWY9e2ZpbGVVcGxvYWRGaWVsZH1cclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiBoYW5kbGVGaWxlc0ZpZWxkKGV2ZW50KX1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJoaWRkZW5cIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gZmlsZVVwbG9hZEZpZWxkLmN1cnJlbnQuY2xpY2soKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgVXBsb2FkIEltYWdlcyAodXB0byAxMClcclxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAge2ZpbGVzUHJldmlld0FycmF5Lmxlbmd0aCA+IDEwICYmIChcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3cgZXJyb3JcIj5cclxuICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIHVwbG9hZCB1cHRvIDEwIGltYWdlcyBvbmx5IVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgPC9GcmFnbWVudD5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbWFnZXNVcGxvYWQ7XHJcbiIsIi8vIE9wdGlvbnMgbGlzdCBmb3IgZHJvcGRvd25cclxuZXhwb3J0IGNvbnN0IGN1cnJlbmNpZXMgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiWFBSXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwiZW9zaW8udG9rZW5cIixcclxuICAgICAgICBkZWNpbWFsczogXCI0XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGRlY2ltYWxzOiBcIjRcIixcclxuICAgICAgICBjb250cmFjdDogXCJsb2FuLnRva2VuXCIsXHJcbiAgICAgICAgY3VycmVuY3k6IFwiTE9BTlwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjdXJyZW5jeTogXCJGT09CQVJcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNlwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBkZWNpbWFsczogXCI0XCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwic3RvcmV4XCIsXHJcbiAgICAgICAgY3VycmVuY3k6IFwiU1RSWFwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjdXJyZW5jeTogXCJCVENMXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwid3JhcHBlclwiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjhcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiWEFEQVwiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhCQ0hcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiOFwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiOFwiLFxyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhCTkJcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiWEJUQ1wiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI4XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhCVVNEXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiWERPR0VcIixcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNlwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiOFwiLFxyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhET1RcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNFwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBjdXJyZW5jeTogXCJYRU9TXCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI4XCIsXHJcbiAgICAgICAgY3VycmVuY3k6IFwiWEVUSFwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjdXJyZW5jeTogXCJYTFRDXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjhcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNlwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBjdXJyZW5jeTogXCJYTFVOQVwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNlwiLFxyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhNREFcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiWE1UXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiOFwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiWFBBWFwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI2XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhQQVhHXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjhcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiWFNPTFwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI2XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhUVVNEXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgICAgICBjdXJyZW5jeTogXCJYVU5JXCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhVU0RDXCIsXHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY29udHJhY3Q6IFwieHRva2Vuc1wiLFxyXG4gICAgICAgIGRlY2ltYWxzOiBcIjZcIixcclxuICAgICAgICBjdXJyZW5jeTogXCJYVVNEVFwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjb250cmFjdDogXCJ4dG9rZW5zXCIsXHJcbiAgICAgICAgZGVjaW1hbHM6IFwiNlwiLFxyXG4gICAgICAgIGN1cnJlbmN5OiBcIlhVU1RcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiWFhSUFwiLFxyXG4gICAgICAgIGNvbnRyYWN0OiBcInh0b2tlbnNcIixcclxuICAgICAgICBkZWNpbWFsczogXCI2XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGNvbnRyYWN0OiBcInJlYWxlc3RhdGVzZVwiLFxyXG4gICAgICAgIGN1cnJlbmN5OiBcIk1FU1NBR0VcIixcclxuICAgICAgICBkZWNpbWFsczogXCI0XCIsXHJcbiAgICB9LFxyXG5dO1xyXG4iLCJpbXBvcnQgeyBGcmFnbWVudCwgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uL2NvbXBvbmVudHMvdWkvQnV0dG9uXCI7XHJcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vY29tcG9uZW50cy91aS9Nb2RhbFwiO1xyXG5cclxuaW1wb3J0IEF1dGhDb250ZXh0IGZyb20gXCIuLi9zdG9yZS9hdXRoLWNvbnRleHRcIjtcclxuaW1wb3J0IEltYWdlc1VwbG9hZCBmcm9tIFwiLi4vY29tcG9uZW50cy91aS9JbWFnZXNVcGxvYWRcIjtcclxuXHJcbmltcG9ydCBEcm9wZG93biBmcm9tIFwiLi4vY29tcG9uZW50cy91aS9DdXJyZW5jeURyb3Bkb3duXCI7XHJcbmltcG9ydCB7IGN1cnJlbmNpZXMgfSBmcm9tIFwiLi4vY29uc3RhbnRzL0N1cnJlbmN5TGlzdFwiO1xyXG5pbXBvcnQgV2FsbGV0Q29udGV4dCBmcm9tIFwiLi4vc3RvcmUvd2FsbGV0LWNvbnRleHRcIjtcclxuaW1wb3J0IHtcclxuICAgIHN0YXJ0RXNjcm93LFxyXG4gICAgZmlsbEVzY3JvdyxcclxuICAgIGZldGNoRXNjcm93cyxcclxuICAgIHVzZXIyTmVnbyxcclxuICAgIHN0YXJ0UHVyY2hhc2UsXHJcbiAgICBuZWdvUHVyY2hhc2UsXHJcbn0gZnJvbSBcIi4uL3Nkay9lYXN5ZXNjcm93U0RLXCI7XHJcbmltcG9ydCB7IHVzZU5hdmlnYXRlIH0gZnJvbSBcInJlYWN0LXJvdXRlci1kb21cIjtcclxuXHJcbmNvbnN0IFB1cmNoYXNlSXRlbSA9ICgpID0+IHtcclxuICAgIGNvbnN0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcclxuICAgIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQoQXV0aENvbnRleHQpO1xyXG4gICAgY29uc3Qgd2FsbGV0Q3R4ID0gdXNlQ29udGV4dChXYWxsZXRDb250ZXh0KTtcclxuICAgIGNvbnN0IFtzdWNjZXNzUG9wdXAsIHNldFN1Y2Nlc3NQb3B1cF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gICAgY29uc3QgW3N1Y2Nlc3MsIHNldFN1Y2Nlc3NdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgICBjb25zdCBbY2hlY2tFcnJvciwgc2V0Q2hlY2tFcnJvcl0gPSB1c2VTdGF0ZShcIlwiKTtcclxuICAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtmaWxlRmllbGRzLCBzZXRGaWxlRmllbGRzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIGNvbnN0IFthbW91bnRFcnJvciwgc2V0QW1vdW50RXJyb3JdID0gdXNlU3RhdGUoXCJcIik7XHJcblxyXG4gICAgY29uc3QgY2xvc2VTdWNjZXNzUG9wdXAgPSAoKSA9PiB7XHJcbiAgICAgICAgc2V0U3VjY2Vzc1BvcHVwKGZhbHNlKTtcclxuICAgICAgICBuYXZpZ2F0ZShcIi90cmFuc2FjdGlvbnNcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IFt0aXRsZSwgc2V0VGl0bGVdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgICBjb25zdCBbZGVzY3JpcHRpb24sIHNldERlc2NyaXB0aW9uXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gICAgY29uc3QgW2Ftb3VudCwgc2V0QW1vdW50XSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gICAgY29uc3QgW3Rva2VuLCBzZXRUb2tlbl0gPSB1c2VTdGF0ZSh7XHJcbiAgICAgICAgY3VycmVuY3k6IFwiU2VsZWN0IGEgdG9rZW5cIixcclxuICAgICAgICBhbW91bnQ6IFwiMFwiLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBbdG9rZW5zLCBzZXRUb2tlbnNdID0gdXNlU3RhdGUoW1xyXG4gICAgICAgIHsgY3VycmVuY3k6IFwiU2VsZWN0IGEgdG9rZW5cIiwgYW1vdW50OiBcIjBcIiB9LFxyXG4gICAgXSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICh3YWxsZXRDdHguYmFsYW5jZXMgIT0gW10gJiYgd2FsbGV0Q3R4LmJhbGFuY2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgc2V0VG9rZW4od2FsbGV0Q3R4LmJhbGFuY2VzWzBdKTtcclxuICAgICAgICAgICAgc2V0VG9rZW5zKHdhbGxldEN0eC5iYWxhbmNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3dhbGxldEN0eC5iYWxhbmNlc10pO1xyXG4gICAgY29uc3QgW3RyYW5zZmVyRGF0ZSwgc2V0VHJhbnNmZXJEYXRlXSA9IHVzZVN0YXRlKFwiaW1tZWRpYXRlbHlcIik7XHJcbiAgICBjb25zdCBbc2VsbGVyTmFtZSwgc2V0U2VsbGVyTmFtZV0gPSB1c2VTdGF0ZShcIlwiKTtcclxuICAgIGNvbnN0IFtjaGVja0V4Y2hhbmdlLCBzZXRDaGVja0V4Y2hhbmdlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVQdXJjaGFzZUZvcm1TdWJtaXQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGlmICh2YWxpZGF0ZVRyYW5zYWN0aW9uRm9ybSgpKSBoYW5kZWxFeGNoYW5nZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL1ZhbGlkYXRlIEZvcm1cclxuICAgIGNvbnN0IHZhbGlkYXRlVHJhbnNhY3Rpb25Gb3JtID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChmaWxlRmllbGRzLmxlbmd0aCA+IDEwKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgdGl0bGUgPT0gXCJcIiB8fFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9PSBcIlwiIHx8XHJcbiAgICAgICAgICAgIGFtb3VudCA9PSBcIlwiIHx8XHJcbiAgICAgICAgICAgIHRva2VuLmN1cnJlbmN5ID09IFwiXCIgfHxcclxuICAgICAgICAgICAgc2VsbGVyTmFtZSA9PSBcIlwiXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHNldEVycm9yKFwiQWxsIGZpZWxkcyBhcmUgcmVxdWlyZWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmICghY2hlY2tFeGNoYW5nZSkge1xyXG4gICAgICAgICAgICBzZXRFcnJvcihcIlwiKTtcclxuICAgICAgICAgICAgc2V0Q2hlY2tFcnJvcihcIlBsZWFzZSB0aWNrIHRoZSBjaGVja2JveCB0byBjb25maXJtIGV4Y2hhbmdlXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KHRva2VuLmFtb3VudCkgPCBwYXJzZUZsb2F0KGFtb3VudCkpIHtcclxuICAgICAgICAgICAgc2V0QW1vdW50RXJyb3IoXHJcbiAgICAgICAgICAgICAgICBgSW5zdWZmaWNpZW50IGFtb3VudCAke3Rva2VuLmN1cnJlbmN5fSBpbiB5b3VyIHdhbGxldGBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRFcnJvcihcIlwiKTtcclxuICAgICAgICAgICAgc2V0Q2hlY2tFcnJvcihcIlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNsZWVwID0gKG1pbGxpc2Vjb25kcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IG51bGw7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudERhdGUgLSBkYXRlIDwgbWlsbGlzZWNvbmRzKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaGFuZGVsRXhjaGFuZ2UgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjogY3R4LmF1dGguYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbjogY3R4LmF1dGgucGVybWlzc2lvbixcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGxldCBkZWxpdmVyVHlwZSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2ZlckRhdGUgPT0gXCJpbW1lZGlhdGVseVwiKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxpdmVyVHlwZSA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNmZXJEYXRlID09IFwiZGVsaXZlcnlcIikge1xyXG4gICAgICAgICAgICAgICAgZGVsaXZlclR5cGUgPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGVJZCA9IDM7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWRlVG9Ub2tlbiA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWRlVG9BbW91bnQgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBleHBpcnkgPSAwO1xyXG4gICAgICAgICAgICBhd2FpdCBzdGFydEVzY3JvdyhcclxuICAgICAgICAgICAgICAgIHR5cGVJZCxcclxuICAgICAgICAgICAgICAgIGN0eC5hdXRoLmFjdG9yLFxyXG4gICAgICAgICAgICAgICAgc2VsbGVyTmFtZSxcclxuICAgICAgICAgICAgICAgIHRva2VuLFxyXG4gICAgICAgICAgICAgICAgdHJhZGVUb1Rva2VuLFxyXG4gICAgICAgICAgICAgICAgYW1vdW50LFxyXG4gICAgICAgICAgICAgICAgdHJhZGVUb0Ftb3VudCxcclxuICAgICAgICAgICAgICAgIGRlbGl2ZXJUeXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwaXJ5LFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcclxuICAgICAgICAgICAgICAgIHdhbGxldEN0eC5zZXNzaW9uXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHNsZWVwKDIwMDApO1xyXG4gICAgICAgICAgICBsZXQgZXNjcm93cyA9IGF3YWl0IGZldGNoRXNjcm93cyhjdHguYXV0aC5hY3Rvcik7XHJcbiAgICAgICAgICAgIGxldCBteUVzY3Jvd3MgPSBlc2Nyb3dzLmZpbHRlcihcclxuICAgICAgICAgICAgICAgIChlc2Nyb3cpID0+IGVzY3Jvdy5mcm9tID09IGN0eC5hdXRoLmFjdG9yICYmIHR5cGVJZCA9PSAzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGxldCBsb29wSWQgPSAyO1xyXG4gICAgICAgICAgICBpZiAoIW15RXNjcm93cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICghbXlFc2Nyb3dzLmxlbmd0aCAmJiBsb29wSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbGVlcCgyMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBmZXRjaEVzY3Jvd3MoY3R4LmF1dGguYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIG15RXNjcm93cyA9IGVzY3Jvd3MuZmlsdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXNjcm93KSA9PiBlc2Nyb3cuZnJvbSA9PSBjdHguYXV0aC5hY3RvciAmJiB0eXBlSWQgPT0gM1xyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9vcElkLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGVzY3Jvd0lkID0gXCIwXCI7XHJcbiAgICAgICAgICAgIGlmIChteUVzY3Jvd3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBlc2Nyb3dJZCA9IG15RXNjcm93c1tteUVzY3Jvd3MubGVuZ3RoIC0gMV0uaWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibXlcIiwgbXlFc2Nyb3dzKTtcclxuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcInR5cGVfaWRcIiwgMyk7XHJcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImFtb3VudFwiLCBhbW91bnQpO1xyXG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJ0b2tlblwiLCB0b2tlbi5jdXJyZW5jeSk7XHJcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcInRyYWRlX3VzZXJuYW1lXCIsIHNlbGxlck5hbWUpO1xyXG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJ0aXRsZVwiLCB0aXRsZSk7XHJcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwidHJhbnNmZXJfdHlwZVwiLCB0cmFuc2ZlckRhdGUpO1xyXG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJlc2Nyb3dfaWRcIiwgTnVtYmVyKGVzY3Jvd0lkKSk7XHJcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImVzY3Jvd19zdGF0dXNcIiwgXCJyZWFkeVwiKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVGaWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImltYWdlW11cIiwgZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXdhaXQgc3RhcnRQdXJjaGFzZShcclxuICAgICAgICAgICAgLy8gICAgIGN0eC5hdXRoLmFjdG9yLFxyXG4gICAgICAgICAgICAvLyAgICAgbXlFc2Nyb3dzW215RXNjcm93cy5sZW5ndGggLSAxXS5mcm9tVG9rZW5zWzBdLFxyXG4gICAgICAgICAgICAvLyAgICAgYXV0aG9yaXphdGlvbixcclxuICAgICAgICAgICAgLy8gICAgIHdhbGxldEN0eC5zZXNzaW9uXHJcbiAgICAgICAgICAgIC8vICk7XHJcbiAgICAgICAgICAgIC8vIGF3YWl0IGZpbGxFc2Nyb3coXHJcbiAgICAgICAgICAgIC8vICAgICBlc2Nyb3dJZCxcclxuICAgICAgICAgICAgLy8gICAgIDMsXHJcbiAgICAgICAgICAgIC8vICAgICBjdHguYXV0aC5hY3RvcixcclxuICAgICAgICAgICAgLy8gICAgIG51bGwsXHJcbiAgICAgICAgICAgIC8vICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgICAgICAvLyAgICAgd2FsbGV0Q3R4LnNlc3Npb25cclxuICAgICAgICAgICAgLy8gKTtcclxuICAgICAgICAgICAgLy8gYXdhaXQgbmVnb1B1cmNoYXNlKFxyXG4gICAgICAgICAgICAvLyAgICAgMjIsXHJcbiAgICAgICAgICAgIC8vICAgICB0eXBlSWQsXHJcbiAgICAgICAgICAgIC8vICAgICBcImVzY3Jvd3VzZXIyXCIsXHJcbiAgICAgICAgICAgIC8vICAgICBjdHguYXV0aC5hY3RvcixcclxuICAgICAgICAgICAgLy8gICAgIHRva2VuLFxyXG4gICAgICAgICAgICAvLyAgICAgbnVsbCxcclxuICAgICAgICAgICAgLy8gICAgIGFtb3VudCxcclxuICAgICAgICAgICAgLy8gICAgIG51bGwsXHJcbiAgICAgICAgICAgIC8vICAgICBkZWxpdmVyVHlwZSxcclxuICAgICAgICAgICAgLy8gICAgIGV4cGlyeSxcclxuICAgICAgICAgICAgLy8gICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgICAgIC8vICAgICB3YWxsZXRDdHguc2Vzc2lvblxyXG4gICAgICAgICAgICAvLyApO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIi0tLS0tIEZvcm0gQXJyYXkgLS0tLS1cIik7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGZpbGVGaWVsZHMpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIi0tLS0tIEZvcm0gRGF0YSAtLS0tLVwiKTtcclxuICAgICAgICAgICAgLy8gZm9yICh2YXIgcGFpciBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKHBhaXJbMF0gKyBcIjogXCIgKyBwYWlyWzFdKTtcclxuICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgLy8gZmV0Y2goYCR7cHJvY2Vzcy5lbnYuTUlYX0FQSV9VUkx9L3VzZXIvYWRkZXNjcm93YCwge1xyXG4gICAgICAgICAgICAvLyAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICAgICAgLy8gICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4gICAgICAgICAgICAvLyAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIEF1dGhvcml6YXRpb246IFwiQmVhcmVyIFwiICsgY3R4LndhbGxldE5hbWUsXHJcbiAgICAgICAgICAgIC8vICAgICB9LFxyXG4gICAgICAgICAgICAvLyB9KVxyXG4gICAgICAgICAgICAvLyAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIHRocm93IHJlc3BvbnNlLnN0YXR1cyArIFwiOiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQ7XHJcbiAgICAgICAgICAgIC8vICAgICB9KVxyXG4gICAgICAgICAgICAvLyAgICAgLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIGlmIChkYXRhLnZhbGlkKSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHNldFN1Y2Nlc3NQb3B1cCh0cnVlKTtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgc2V0U3VjY2VzcyhkYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHNldEVycm9yKGRhdGEubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyAgICAgfSlcclxuICAgICAgICAgICAgLy8gICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBzZXRFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vICAgICB9KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SXCIsIGVycm9yKTtcclxuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxGcmFnbWVudD5cclxuICAgICAgICAgICAgPG1haW4+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBiYW5uZXItaW5uZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aDE+UHVyY2hhc2UgYW4gSXRlbTwvaDE+XHJcbiAgICAgICAgICAgICAgICAgICAgPGgzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGVzY3JvdyBhbGxvd3MgYW55IHVzZXIgdG8gZWFzaWx5IHV0aWxpemUgYSBzbWFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdCB0byB2ZXJpZnkgYW5kIHBheSBmb3IgYW55IGl0ZW0gd2l0aCBzZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3J5cHRvY3VycmVuY2llc1xyXG4gICAgICAgICAgICAgICAgICAgIDwvaDM+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIGJsb2NrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVB1cmNoYXNlRm9ybVN1Ym1pdH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwicHVyY2hhc2UtdGl0bGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBZGQgYSB0aXRsZSBmb3IgdGhlIGl0ZW0gdG8gcHVyY2hhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJwdXJjaGFzZS10aXRsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RpdGxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpdGxlKGV2ZW50LnRhcmdldC52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLXJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJwdXJjaGFzZS1kZXNjXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVzY3JpcHRpb24gb2YgcHVyY2hhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD1cInB1cmNoYXNlLWRlc2NcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtkZXNjcmlwdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXREZXNjcmlwdGlvbihldmVudC50YXJnZXQudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvdGV4dGFyZWE+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2VzVXBsb2FkIHNldEZpbGVGaWVsZHM9e3NldEZpbGVGaWVsZHN9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwicHVyY2hhc2UtYW1vdW50XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW50ZXIgYSBudW1lcmljYWwgYW1vdW50IG9mIHRva2VucyBhcyB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXJjaGFzZSBwcmljZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwPVwiMC4wMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJwdXJjaGFzZS1hbW91bnRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXthbW91bnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QW1vdW50KGV2ZW50LnRhcmdldC52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLXJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJwdXJjaGFzZV90b2tlblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlbGVjdCBhIHRva2VuOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEcm9wZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e3Rva2Vuc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE9wdGlvbj17dG9rZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRPcHRpb249e3NldFRva2VufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwicHVyY2hhc2VfdG9rZW5cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2ZlciBEYXRlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaW9cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJpbW1lZGlhdGVseVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJwdXJjaGFzZS1kYXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJpbW1lZGlhdGVseVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3RyYW5zZmVyRGF0ZSA9PSBcImltbWVkaWF0ZWx5XCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNmZXJEYXRlKFwiaW1tZWRpYXRlbHlcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJpbW1lZGlhdGVseVwiPkltbWVkaWF0ZWx5PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYWRpb1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD1cIm9uLWRlbGl2ZXJ5XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cInB1cmNoYXNlLWRhdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIm9uIGRlbGl2ZXJ5XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17dHJhbnNmZXJEYXRlID09IFwiZGVsaXZlcnlcIn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldFRyYW5zZmVyRGF0ZShcImRlbGl2ZXJ5XCIpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJvbi1kZWxpdmVyeVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcG9uIERlbGl2ZXJ5IG9mIFB1cmNoYXNlZCBJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLXJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJzZWxsZXItbmFtZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVudGVyIHRoZSBQcm90b24gQG5hbWUgb2YgdGhlIHNlbGxlcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlucHV0LWdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPkA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJzZWxsZXItbmFtZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzZWxsZXJOYW1lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsbGVyTmFtZShldmVudC50YXJnZXQudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQbGVhc2UgY29uZmlybSB0aGUgZm9sbG93aW5nIHByb3Bvc2VkIHB1cmNoYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93IGNvbmZpcm0tY2hlY2tcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJjcnlwdG9fZXhjaGFuZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJjcnlwdG9fZXhjaGFuZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtjaGVja0V4Y2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENoZWNrRXhjaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiY3J5cHRvX2V4Y2hhbmdlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2BQbGVhc2UgY29uZmlybSB0aGlzIHRyYW5zYWN0aW9uIGFuZCAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQgfHwgXCIodG9rZW4gbnVtZXJpY2FsIGFtb3VudClcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gJHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uY3VycmVuY3kgfHwgXCIodG9rZW4gbmFtZSlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2lsbCBiZSBtb3ZlZCBvdXQgb2YgeW91ciBQcm90b24gd2FsbGV0IGludG8gdGhlIEVhc3lFc2Nyb3cgU21hcnQgQ29udHJhY3QuIEAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxsZXJOYW1lIHx8IFwiKHNlY29uZCB1c2VyKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aWxsIGJlIG5vdGlmaWVkIHRvIHJldmlldyB0aGlzIHRyYW5zYWN0aW9uLmB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLXJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0aGlzIGlzIGNvcnJlY3QgcGxlYXNlIGNvbmZpcm0gYW5kIHlvdXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3J5cHRvIHdpbGwgYmUgbW92ZWQgb3V0IG9mIHlvdXIgUHJvdG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldCBpbnRvIHRoZSBFYXN5RXNjcm93IFNtYXJ0IENvbnRyYWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc21hbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hlY2tFcnJvciAhPT0gXCJcIiAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93IGVycm9yXCI+e2NoZWNrRXJyb3J9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtlcnJvciAhPT0gXCJcIiAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93IGVycm9yXCI+e2Vycm9yfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7YW1vdW50RXJyb3IgIT09IFwiXCIgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLXJvdyBlcnJvclwiPnthbW91bnRFcnJvcn08L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAge2N0eC5pc0xvZ2dlZEluICYmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiQ29uZmlybVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsb2FkaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgeyFjdHguaXNMb2dnZWRJbiAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkxvZ2luXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17YXN5bmMgKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhbGxldEN0eC5wcm90b25Db25uZWN0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsb2FkaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9tYWluPlxyXG5cclxuICAgICAgICAgICAge3N1Y2Nlc3NQb3B1cCAmJiAoXHJcbiAgICAgICAgICAgICAgICA8TW9kYWwgaGlkZVBvcHVwPXsoKSA9PiBzZXRTdWNjZXNzUG9wdXAoZmFsc2UpfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwibW9kYWwtaGVhZGVyXCI+UHVyY2hhc2UgYW4gSXRlbTwvaDM+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3cgc3VjY2Vzc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+e3N1Y2Nlc3N9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1jb25maXJtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJDb250aW51ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17Y2xvc2VTdWNjZXNzUG9wdXB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgPC9GcmFnbWVudD5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQdXJjaGFzZUl0ZW07XHJcbiIsIi8vVXNlIEFQSSB0byBzYXZlIHRyYW5zYWN0aW9uIGRldGFpbHNcclxuaW1wb3J0IHsgQXBpQ2xhc3MgfSBmcm9tIFwiQHByb3Rvbi9hcGlcIjtcclxuaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xyXG5pbXBvcnQgeyBjdXJyZW50X25ldHdvcmsgfSBmcm9tIFwiLi4vY29uc3RhbnRzL25ldHdvcmtzLmpzXCI7XHJcbmltcG9ydCB7IHRyYW5zYWN0IH0gZnJvbSBcIi4vcHJvdG9uQVBJLmpzXCI7XHJcblxyXG5jb25zdCBhcGkgPSBuZXcgQXBpQ2xhc3MoY3VycmVudF9uZXR3b3JrLmNoYWluKTtcclxuY29uc3QgY29udHJhY3QgPSBcImVhc3llc2Nyb3cyXCI7XHJcblxyXG5jb25zdCBmZWVDb250cmFjdCA9IFwieHRva2Vuc1wiO1xyXG5jb25zdCBmZWVRdWFudGl0eSA9IFwiMC4yNTAwMDAgWFVTRENcIjtcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoRXNjcm93QWxsKCkge1xyXG4gICAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBhcGkucnBjLmdldF90YWJsZV9yb3dzKHtcclxuICAgICAgICBjb2RlOiBjb250cmFjdCxcclxuICAgICAgICBzY29wZTogY29udHJhY3QsXHJcbiAgICAgICAgdGFibGU6IFwiZXNjcm93c1wiLFxyXG4gICAgICAgIGluZGV4X3Bvc2l0aW9uOiAyLFxyXG4gICAgICAgIGtleV90eXBlOiBcImk2NFwiLFxyXG4gICAgICAgIGxpbWl0OiAtMSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJvd3M7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEVzY3Jvd3MoYWNjb3VudE5hbWUpIHtcclxuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgYXBpLnJwYy5nZXRfdGFibGVfcm93cyh7XHJcbiAgICAgICAgY29kZTogY29udHJhY3QsXHJcbiAgICAgICAgc2NvcGU6IGNvbnRyYWN0LFxyXG4gICAgICAgIHRhYmxlOiBcImVzY3Jvd3NcIixcclxuICAgICAgICBpbmRleF9wb3NpdGlvbjogMixcclxuICAgICAgICBrZXlfdHlwZTogXCJpNjRcIixcclxuICAgICAgICBsb3dlcl9ib3VuZDogYWNjb3VudE5hbWUsXHJcbiAgICAgICAgdXBwZXJfYm91bmQ6IGFjY291bnROYW1lLFxyXG4gICAgICAgIGxpbWl0OiAtMSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJvd3M7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydEVzY3JvdyhcclxuICAgIHR5cGVJZCxcclxuICAgIGZyb20sXHJcbiAgICB0byxcclxuICAgIGZyb21Ub2tlbixcclxuICAgIHRvVG9rZW4sXHJcbiAgICBmcm9tQW1vdW50LFxyXG4gICAgdG9BbW91bnQsXHJcbiAgICBkZWxpdmVyVHlwZSxcclxuICAgIGV4cGlyeSxcclxuICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICBzZXNzaW9uXHJcbikge1xyXG4gICAgY29uc3QgYW1vdW50SW4gPSBwYXJzZUZsb2F0KGZyb21BbW91bnQpXHJcbiAgICAgICAgLnRvRml4ZWQoTnVtYmVyKGZyb21Ub2tlbi5kZWNpbWFscykpXHJcbiAgICAgICAgLnRvU3RyaW5nKCk7XHJcbiAgICBjb25zdCBmcm9tUXVhbnRpdHkgPSBhbW91bnRJbiArIFwiIFwiICsgZnJvbVRva2VuLmN1cnJlbmN5O1xyXG4gICAgbGV0IGFjdGlvbnMgPSBbXTtcclxuICAgIGlmICh0eXBlSWQgPT0gMSkge1xyXG4gICAgICAgIGNvbnN0IGFtb3VudE91dCA9IHBhcnNlRmxvYXQodG9BbW91bnQpXHJcbiAgICAgICAgICAgIC50b0ZpeGVkKE51bWJlcih0b1Rva2VuLmRlY2ltYWxzKSlcclxuICAgICAgICAgICAgLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgdG9RdWFudGl0eSA9IGFtb3VudE91dCArIFwiIFwiICsgdG9Ub2tlbi5jdXJyZW5jeTtcclxuICAgICAgICBhY3Rpb25zID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBmZWVDb250cmFjdCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiBjb250cmFjdCxcclxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZmVlUXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgbWVtbzogYCR7ZnJvbX0gZGVwb3NpdCBhIGZlZSBmb3IgZXhjaGFuZ2UuYCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBmcm9tVG9rZW4uY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRyYW5zZmVyXCIsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcclxuICAgICAgICAgICAgICAgICAgICB0bzogY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGZyb21RdWFudGl0eSxcclxuICAgICAgICAgICAgICAgICAgICBtZW1vOiBgJHtmcm9tfSBkZXBvc2l0IGZvciBleGNoYW5nZS5gLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFjY291bnQ6IGNvbnRyYWN0LFxyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydGVzY3Jvd1wiLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZDogdHlwZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgdG86IHRvLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21Ub2tlbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3Q6IGZyb21Ub2tlbi5jb250cmFjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBmcm9tUXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tTmZ0czogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgdG9Ub2tlbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3Q6IHRvVG9rZW4uY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogdG9RdWFudGl0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvTmZ0czogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsaXZlclR5cGU6IGRlbGl2ZXJUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyeTogZXhwaXJ5LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0gZWxzZSBpZiAodHlwZUlkID09IDIpIHtcclxuICAgICAgICBhY3Rpb25zID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBmZWVDb250cmFjdCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiBjb250cmFjdCxcclxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZmVlUXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgbWVtbzogYCR7ZnJvbX0gZGVwb3NpdCBhIGZlZSBmb3IgYSBnaWZ0LmAsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYWNjb3VudDogZnJvbVRva2VuLmNvbnRyYWN0LFxyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0cmFuc2ZlclwiLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgdG86IGNvbnRyYWN0LFxyXG4gICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBmcm9tUXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgbWVtbzogYCR7ZnJvbX0gZGVwb3NpdCBmb3IgYSBnaWZ0YCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBjb250cmFjdCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRlc2Nyb3dcIixcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSWQ6IHR5cGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0byxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tVG9rZW5zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBmcm9tVG9rZW4uY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZnJvbVF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbU5mdHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvVG9rZW5zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB0b05mdHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJUeXBlOiBkZWxpdmVyVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBleHBpcnk6IE1hdGguZmxvb3IoZXhwaXJ5IC8gMTAwMCksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlSWQgPT0gMyB8fCB0eXBlSWQgPT0gNCkge1xyXG4gICAgICAgIGxldCBtZW1vID0gYCR7ZnJvbX0gZGVwb3NpdGVkIGZvciBQdXJjaGFzZSBJdGVtLmA7XHJcbiAgICAgICAgaWYgKHR5cGVJZCA9PSA0KSB7XHJcbiAgICAgICAgICAgIG1lbW8gPSBgJHtmcm9tfSBkZXBvc2l0ZWQgZm9yIFB1cmNoYXNlIFNlcnZpY2UuYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9pbiB0aGlzIGNhc2Ugb25seSBzdG9yZSB0byBwcm90b24gZGIuIG5vdCBzZW5kIGNvaW5cclxuICAgICAgICBhY3Rpb25zID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBjb250cmFjdCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRlc2Nyb3dcIixcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSWQ6IHR5cGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0byxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tVG9rZW5zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBmcm9tVG9rZW4uY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZnJvbVF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbU5mdHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvVG9rZW5zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB0b05mdHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJUeXBlOiBkZWxpdmVyVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBleHBpcnk6IGV4cGlyeSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgYXdhaXQgc2Vzc2lvbi50cmFuc2FjdCh7XHJcbiAgICAgICAgdHJhbnNhY3Rpb246IHtcclxuICAgICAgICAgICAgYWN0aW9ucyxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaWxsRXNjcm93KFxyXG4gICAgZXNjcm93SWQsXHJcbiAgICB0eXBlSWQsXHJcbiAgICBhY3RvcixcclxuICAgIHRvVG9rZW4sXHJcbiAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgc2Vzc2lvblxyXG4pIHtcclxuICAgIGxldCBhY3Rpb25zID0gW107XHJcbiAgICBpZiAodHlwZUlkID09IDEpIHtcclxuICAgICAgICBhY3Rpb25zID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBmZWVDb250cmFjdCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBhY3RvcixcclxuICAgICAgICAgICAgICAgICAgICB0bzogY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGZlZVF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIG1lbW86IGAke2FjdG9yfSBkZXBvc2l0IGEgZmVlIGZvciBleGNoYW5nZS5gLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFjY291bnQ6IHRvVG9rZW4uY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRyYW5zZmVyXCIsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgdG86IGNvbnRyYWN0LFxyXG4gICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiB0b1Rva2VuLnF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIG1lbW86IGAke2FjdG9yfSBkZXBvc2l0IGZvciBleGNoYW5nZS5gLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFjY291bnQ6IGNvbnRyYWN0LFxyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmaWxsZXNjcm93XCIsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3I6IGFjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBlc2Nyb3dJZC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0gZWxzZSBpZiAodHlwZUlkID09IDIpIHtcclxuICAgICAgICBjb25zdCBjb250cmFjdGF1dGggPSBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yOiBjb250cmFjdCxcclxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb246IFwiYWN0aXZlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICBhY3Rpb25zID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBjb250cmFjdCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZmlsbGVzY3Jvd1wiLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yOiBhY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBpZDogZXNjcm93SWQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBjb250cmFjdGF1dGgsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0cmFuc2FjdChhY3Rpb25zKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZXN1bHRcIiwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgaGVyZT8/XCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVJZCA9PSAzIHx8IHR5cGVJZCA9PSA0KSB7XHJcbiAgICAgICAgYWN0aW9ucyA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYWNjb3VudDogY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImZpbGxlc2Nyb3dcIixcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjogYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGVzY3Jvd0lkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVJZCAhPSAyKSB7XHJcbiAgICAgICAgYXdhaXQgc2Vzc2lvbi50cmFuc2FjdCh7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25zLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYW5jZWxFc2Nyb3coZXNjcm93SWQsIGFjdG9yLCBhdXRob3JpemF0aW9uLCBzZXNzaW9uKSB7XHJcbiAgICBjb25zdCBhY3Rpb25zID0gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWNjb3VudDogY29udHJhY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IFwiY2FuY2VsZXNjcm93XCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGFjdG9yOiBhY3RvcixcclxuICAgICAgICAgICAgICAgIGlkOiBlc2Nyb3dJZC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uLFxyXG4gICAgICAgIH0sXHJcbiAgICBdO1xyXG4gICAgYXdhaXQgc2Vzc2lvbi50cmFuc2FjdCh7XHJcbiAgICAgICAgdHJhbnNhY3Rpb246IHtcclxuICAgICAgICAgICAgYWN0aW9ucyxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydFB1cmNoYXNlKGZyb20sIHRva2VuLCBhdXRob3JpemF0aW9uLCBzZXNzaW9uKSB7XHJcbiAgICBjb25zdCBhY3Rpb25zID0gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWNjb3VudDogZmVlQ29udHJhY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcclxuICAgICAgICAgICAgICAgIHRvOiBjb250cmFjdCxcclxuICAgICAgICAgICAgICAgIHF1YW50aXR5OiBmZWVRdWFudGl0eSxcclxuICAgICAgICAgICAgICAgIG1lbW86IGAke2Zyb219IGRlcG9zaXQgYSBmZWUgZm9yIGEgcHVyY2hhc2UuYCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWNjb3VudDogdG9rZW4uY29udHJhY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcclxuICAgICAgICAgICAgICAgIHRvOiBjb250cmFjdCxcclxuICAgICAgICAgICAgICAgIHF1YW50aXR5OiB0b2tlbi5xdWFudGl0eSxcclxuICAgICAgICAgICAgICAgIG1lbW86IGAke2Zyb219IGRlcG9zaXQgZm9yIHB1cmNoYXNlLmAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgfSxcclxuICAgIF07XHJcbiAgICBhd2FpdCBzZXNzaW9uLnRyYW5zYWN0KHtcclxuICAgICAgICB0cmFuc2FjdGlvbjoge1xyXG4gICAgICAgICAgICBhY3Rpb25zLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5lZ29QdXJjaGFzZShcclxuICAgIGVzY3Jvd0lkLFxyXG4gICAgdHlwZUlkLFxyXG4gICAgZnJvbSxcclxuICAgIHRvLFxyXG4gICAgZnJvbVRva2VuLFxyXG4gICAgdG9Ub2tlbixcclxuICAgIGZyb21BbW91bnQsXHJcbiAgICB0b0Ftb3VudCxcclxuICAgIGRlbGl2ZXJUeXBlLFxyXG4gICAgZXhwaXJ5LFxyXG4gICAgYXV0aG9yaXphdGlvbixcclxuICAgIHNlc3Npb25cclxuKSB7XHJcbiAgICBjb25zdCBhbW91bnRJbiA9IHBhcnNlRmxvYXQoZnJvbUFtb3VudClcclxuICAgICAgICAudG9GaXhlZChOdW1iZXIoZnJvbVRva2VuLmRlY2ltYWxzKSlcclxuICAgICAgICAudG9TdHJpbmcoKTtcclxuICAgIGNvbnN0IGZyb21RdWFudGl0eSA9IGFtb3VudEluICsgXCIgXCIgKyBmcm9tVG9rZW4uY3VycmVuY3k7XHJcbiAgICBjb25zdCBhY3Rpb25zID0gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWNjb3VudDogY29udHJhY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IFwibmVnb3B1cmNoYXNlXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGVzY3Jvd0lkOiBlc2Nyb3dJZCxcclxuICAgICAgICAgICAgICAgIHR5cGVJZDogdHlwZUlkLFxyXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcclxuICAgICAgICAgICAgICAgIHRvOiB0byxcclxuICAgICAgICAgICAgICAgIGZyb21Ub2tlbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBmcm9tVG9rZW4uY29udHJhY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBmcm9tUXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBmcm9tTmZ0czogW10sXHJcbiAgICAgICAgICAgICAgICB0b1Rva2VuczogW10sXHJcbiAgICAgICAgICAgICAgICB0b05mdHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgZGVsaXZlclR5cGU6IGRlbGl2ZXJUeXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwaXJ5OiBleHBpcnksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXHJcbiAgICAgICAgfSxcclxuICAgIF07XHJcbiAgICBhd2FpdCBzZXNzaW9uLnRyYW5zYWN0KHtcclxuICAgICAgICB0cmFuc2FjdGlvbjoge1xyXG4gICAgICAgICAgICBhY3Rpb25zLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxyXG5cclxuY29uc3QgdGFibGVyb3dzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgcHJvdG9ucm93cyA9IGF3YWl0IGZldGNoRXNjcm93QWxsKCk7XHJcbiAgICBjb25zb2xlLmxvZyhwcm90b25yb3dzKTtcclxuICAgIGlmIChPYmplY3Qua2V5cyhwcm90b25yb3dzKS5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIHByb3RvbnJvd3MpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3ZGF0ZXRlbm1pbnV0ZXMgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gbmV3ZGF0ZXRlbm1pbnV0ZXMuZ2V0TWludXRlcygpIC0gMTA7XHJcbiAgICAgICAgICAgIG5ld2RhdGV0ZW5taW51dGVzLnNldE1pbnV0ZXMoZGlmZmVyZW5jZSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBvYmouZXhwaXJ5ICogMTAwMDtcclxuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0ZSA+IG5ld2RhdGV0ZW5taW51dGVzICYmIGRhdGUgPD0gbmV3IERhdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjdXJyZW50IGRhdGVcIiwgbmV3IERhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhbGxpbmcgZmlsbCBnaWZ0IGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJydW5uaW5nIGVzY3Jvd1wiLCBvYmouaWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJydW5uaW5nIGVzY3JvdyBkYXRlXCIsIGRhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdpZnRyZXNwb25zZWNhbGwoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2lmdHJlc3BvbnNlID0gYXdhaXQgZmlsbEVzY3JvdyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouZnJvbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdpZnRyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjcm93X2lkOiBvYmouaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlX2lkOiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YXMgPSBKU09OLnN0cmluZ2lmeShyZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlvcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImh0dHBzOi8vZWFzeWVzY3Jvdy5pby9hcGkvdXNlci9naWZ0LXVwZGF0ZS1zdGF0dXNcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLmRhdGEucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhnaWZ0cmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGdpZnRyZXNwb25zZWNhbGwoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2tpcCBlc2Nyb3dcIiwgb2JqLmlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2tpcCBlc2Nyb3cgZGF0ZVwiLCBkYXRlKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY3VycmVudCBkYXRlXCIsIG5ldyBEYXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm5vIHJvd3MgZm91bmRcIik7XHJcbiAgICB9XHJcbn07XHJcbnRhYmxlcm93cygpO1xyXG5cclxuLy8gY29uc3QgaGlzdG9yeSA9IGF3YWl0IGFwaS5nZXRBY3Rpb25zRnJvbUh5cGVyaW9uKGN0eC5hdXRoLmFjdG9yLCB7XHJcbi8vICAgICBsaW1pdDogMTAsXHJcbi8vICAgICBza2lwOiAwLFxyXG4vLyAgICAgc29ydDogXCJkZXNjXCIsXHJcbi8vICAgICBmaWx0ZXI6IGNvbnRyYWN0KlwiLFxyXG4vLyB9KTtcclxuXHJcbi8vIGNvbnNvbGUubG9nKFwiSGlzdG9yeVwiLCBoaXN0b3J5KTtcclxuIiwiaW1wb3J0IHsgSnNvblJwYywgQXBpLCBKc1NpZ25hdHVyZVByb3ZpZGVyIH0gZnJvbSBcIkBwcm90b24vanNcIjtcclxuaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCI7XHJcbmltcG9ydCB7IGN1cnJlbnRfbmV0d29yayB9IGZyb20gXCIuLi9jb25zdGFudHMvbmV0d29ya3NcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBycGMgPSBuZXcgSnNvblJwYyhbY3VycmVudF9uZXR3b3JrLmVuZHBvaW50XSwgeyBmZXRjaDogZmV0Y2ggfSk7XHJcbmV4cG9ydCBjb25zdCBhcGkgPSBuZXcgQXBpKHtcclxuICAgIHJwYyxcclxuICAgIHNpZ25hdHVyZVByb3ZpZGVyOiBuZXcgSnNTaWduYXR1cmVQcm92aWRlcihbXHJcbiAgICAgICAgXCJQVlRfSzFfMlNnM2pkYmdBZmM4ZkpjdDJNVkhwVWpSV0p2dERoaXR4RDVwNTl3YXJYU1FyWFhXQTNcIixcclxuICAgIF0pLFxyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2FjdChhY3Rpb25zKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcImNvbWUgaGVyZSwgdGhlbiB3aHk/XCIpO1xyXG4gICAgYXBpLnRyYW5zYWN0KFxyXG4gICAgICAgIHsgYWN0aW9ucyB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmxvY2tzQmVoaW5kOiAzMDAsXHJcbiAgICAgICAgICAgIGV4cGlyZVNlY29uZHM6IDMwMDAsXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufVxyXG4iLCJcbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cbiIsIjsoZnVuY3Rpb24gKGdsb2JhbE9iamVjdCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjAuMlxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIxIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxuICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgIHN1ZmZpeDogJydcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcclxuICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICAgIGlmIChiID09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAgICpcclxuICAgICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICpcclxuICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICAgKlxyXG4gICAgICogRS5nLlxyXG4gICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgKlxyXG4gICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIHAsIHY7XHJcblxyXG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdi5zbGljZSgwLCAxMCkgPT0gJzAxMjM0NTY3ODknO1xyXG4gICAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIHYge2FueX1cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBpLCBuLFxyXG4gICAgICAgIGMgPSB2LmMsXHJcbiAgICAgICAgZSA9IHYuZSxcclxuICAgICAgICBzID0gdi5zO1xyXG5cclxuICAgICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmx0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmd0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGosXHJcbiAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIC0tZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gICAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbWV0aG9kKSB7XHJcbiAgICAgIHZhciBuLFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcblxyXG4gICAgICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gICAgICAgIGlmICghbi5zKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmNhbGwobSwgbikpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShuLCBjLCBlKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICBmb3IgKGogPSBjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgIG4uYyA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICBzID0gaXNOdW0gPyBzdHIgOiBzdHIucmVwbGFjZSh3aGl0ZXNwYWNlT3JQbHVzLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IGI7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5hTlxyXG4gICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgIGZvciAoZCA9IDEsIGsgPSB4Y1swXTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgICBuID0geGNbbmkgPSAwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgKi9cclxuICAgIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC8gMCA9IElcclxuICAgICAqICBuIC8gTiA9IE5cclxuICAgICAqICBuIC8gSSA9IDBcclxuICAgICAqICAwIC8gbiA9IDBcclxuICAgICAqICAwIC8gMCA9IE5cclxuICAgICAqICAwIC8gTiA9IE5cclxuICAgICAqICAwIC8gSSA9IDBcclxuICAgICAqICBOIC8gbiA9IE5cclxuICAgICAqICBOIC8gMCA9IE5cclxuICAgICAqICBOIC8gTiA9IE5cclxuICAgICAqICBOIC8gSSA9IE5cclxuICAgICAqICBJIC8gbiA9IElcclxuICAgICAqICBJIC8gMCA9IElcclxuICAgICAqICBJIC8gTiA9IE5cclxuICAgICAqICBJIC8gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICovXHJcbiAgICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gMiAtIGlzT2RkKG4pIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB0ID0geWMsIHljID0geGMsIHhjID0gdCwgYiA9IGE7XHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwKys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBGT1JNQVQgPSB7XHJcbiAgICAgKiAgIHByZWZpeDogJycsXHJcbiAgICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICogICBzdWZmaXg6ICcnXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgICAgaWYgKHguYykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZzIpIGkgPSBnMSwgZzEgPSBnMiwgZzIgPSBpLCBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYztcclxuXHJcbiAgICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICBmb3IgKDsgOykgIHtcclxuICAgICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICAgIG4gPSBkMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgKi9cclxuICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgIHMgPSBuLnMsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKToodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmRheWpzPWUoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD0xZTMsZT02ZTQsbj0zNmU1LHI9XCJtaWxsaXNlY29uZFwiLGk9XCJzZWNvbmRcIixzPVwibWludXRlXCIsdT1cImhvdXJcIixhPVwiZGF5XCIsbz1cIndlZWtcIixmPVwibW9udGhcIixoPVwicXVhcnRlclwiLGM9XCJ5ZWFyXCIsZD1cImRhdGVcIiwkPVwiSW52YWxpZCBEYXRlXCIsbD0vXihcXGR7NH0pWy0vXT8oXFxkezEsMn0pP1stL10/KFxcZHswLDJ9KVtUdFxcc10qKFxcZHsxLDJ9KT86PyhcXGR7MSwyfSk/Oj8oXFxkezEsMn0pP1suOl0/KFxcZCspPyQvLHk9L1xcWyhbXlxcXV0rKV18WXsxLDR9fE17MSw0fXxEezEsMn18ZHsxLDR9fEh7MSwyfXxoezEsMn18YXxBfG17MSwyfXxzezEsMn18WnsxLDJ9fFNTUy9nLE09e25hbWU6XCJlblwiLHdlZWtkYXlzOlwiU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXlcIi5zcGxpdChcIl9cIiksbW9udGhzOlwiSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlclwiLnNwbGl0KFwiX1wiKX0sbT1mdW5jdGlvbih0LGUsbil7dmFyIHI9U3RyaW5nKHQpO3JldHVybiFyfHxyLmxlbmd0aD49ZT90OlwiXCIrQXJyYXkoZSsxLXIubGVuZ3RoKS5qb2luKG4pK3R9LGc9e3M6bSx6OmZ1bmN0aW9uKHQpe3ZhciBlPS10LnV0Y09mZnNldCgpLG49TWF0aC5hYnMoZSkscj1NYXRoLmZsb29yKG4vNjApLGk9biU2MDtyZXR1cm4oZTw9MD9cIitcIjpcIi1cIikrbShyLDIsXCIwXCIpK1wiOlwiK20oaSwyLFwiMFwiKX0sbTpmdW5jdGlvbiB0KGUsbil7aWYoZS5kYXRlKCk8bi5kYXRlKCkpcmV0dXJuLXQobixlKTt2YXIgcj0xMioobi55ZWFyKCktZS55ZWFyKCkpKyhuLm1vbnRoKCktZS5tb250aCgpKSxpPWUuY2xvbmUoKS5hZGQocixmKSxzPW4taTwwLHU9ZS5jbG9uZSgpLmFkZChyKyhzPy0xOjEpLGYpO3JldHVybisoLShyKyhuLWkpLyhzP2ktdTp1LWkpKXx8MCl9LGE6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD9NYXRoLmNlaWwodCl8fDA6TWF0aC5mbG9vcih0KX0scDpmdW5jdGlvbih0KXtyZXR1cm57TTpmLHk6Yyx3Om8sZDphLEQ6ZCxoOnUsbTpzLHM6aSxtczpyLFE6aH1bdF18fFN0cmluZyh0fHxcIlwiKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL3MkLyxcIlwiKX0sdTpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dH19LHY9XCJlblwiLEQ9e307RFt2XT1NO3ZhciBwPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgX30sUz1mdW5jdGlvbiB0KGUsbixyKXt2YXIgaTtpZighZSlyZXR1cm4gdjtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIHM9ZS50b0xvd2VyQ2FzZSgpO0Rbc10mJihpPXMpLG4mJihEW3NdPW4saT1zKTt2YXIgdT1lLnNwbGl0KFwiLVwiKTtpZighaSYmdS5sZW5ndGg+MSlyZXR1cm4gdCh1WzBdKX1lbHNle3ZhciBhPWUubmFtZTtEW2FdPWUsaT1hfXJldHVybiFyJiZpJiYodj1pKSxpfHwhciYmdn0sdz1mdW5jdGlvbih0LGUpe2lmKHAodCkpcmV0dXJuIHQuY2xvbmUoKTt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZT9lOnt9O3JldHVybiBuLmRhdGU9dCxuLmFyZ3M9YXJndW1lbnRzLG5ldyBfKG4pfSxPPWc7Ty5sPVMsTy5pPXAsTy53PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCx7bG9jYWxlOmUuJEwsdXRjOmUuJHUseDplLiR4LCRvZmZzZXQ6ZS4kb2Zmc2V0fSl9O3ZhciBfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTSh0KXt0aGlzLiRMPVModC5sb2NhbGUsbnVsbCwhMCksdGhpcy5wYXJzZSh0KX12YXIgbT1NLnByb3RvdHlwZTtyZXR1cm4gbS5wYXJzZT1mdW5jdGlvbih0KXt0aGlzLiRkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0ZSxuPXQudXRjO2lmKG51bGw9PT1lKXJldHVybiBuZXcgRGF0ZShOYU4pO2lmKE8udShlKSlyZXR1cm4gbmV3IERhdGU7aWYoZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYhL1okL2kudGVzdChlKSl7dmFyIHI9ZS5tYXRjaChsKTtpZihyKXt2YXIgaT1yWzJdLTF8fDAscz0ocls3XXx8XCIwXCIpLnN1YnN0cmluZygwLDMpO3JldHVybiBuP25ldyBEYXRlKERhdGUuVVRDKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpKTpuZXcgRGF0ZShyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKX19cmV0dXJuIG5ldyBEYXRlKGUpfSh0KSx0aGlzLiR4PXQueHx8e30sdGhpcy5pbml0KCl9LG0uaW5pdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldEZ1bGxZZWFyKCksdGhpcy4kTT10LmdldE1vbnRoKCksdGhpcy4kRD10LmdldERhdGUoKSx0aGlzLiRXPXQuZ2V0RGF5KCksdGhpcy4kSD10LmdldEhvdXJzKCksdGhpcy4kbT10LmdldE1pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0U2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0TWlsbGlzZWNvbmRzKCl9LG0uJHV0aWxzPWZ1bmN0aW9uKCl7cmV0dXJuIE99LG0uaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiEodGhpcy4kZC50b1N0cmluZygpPT09JCl9LG0uaXNTYW1lPWZ1bmN0aW9uKHQsZSl7dmFyIG49dyh0KTtyZXR1cm4gdGhpcy5zdGFydE9mKGUpPD1uJiZuPD10aGlzLmVuZE9mKGUpfSxtLmlzQWZ0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdyh0KTx0aGlzLnN0YXJ0T2YoZSl9LG0uaXNCZWZvcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmRPZihlKTx3KHQpfSxtLiRnPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTy51KHQpP3RoaXNbZV06dGhpcy5zZXQobix0KX0sbS51bml4PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkvMWUzKX0sbS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQuZ2V0VGltZSgpfSxtLnN0YXJ0T2Y9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9ISFPLnUoZSl8fGUsaD1PLnAodCksJD1mdW5jdGlvbih0LGUpe3ZhciBpPU8udyhuLiR1P0RhdGUuVVRDKG4uJHksZSx0KTpuZXcgRGF0ZShuLiR5LGUsdCksbik7cmV0dXJuIHI/aTppLmVuZE9mKGEpfSxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE8udyhuLnRvRGF0ZSgpW3RdLmFwcGx5KG4udG9EYXRlKFwic1wiKSwocj9bMCwwLDAsMF06WzIzLDU5LDU5LDk5OV0pLnNsaWNlKGUpKSxuKX0seT10aGlzLiRXLE09dGhpcy4kTSxtPXRoaXMuJEQsZz1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIik7c3dpdGNoKGgpe2Nhc2UgYzpyZXR1cm4gcj8kKDEsMCk6JCgzMSwxMSk7Y2FzZSBmOnJldHVybiByPyQoMSxNKTokKDAsTSsxKTtjYXNlIG86dmFyIHY9dGhpcy4kbG9jYWxlKCkud2Vla1N0YXJ0fHwwLEQ9KHk8dj95Kzc6eSktdjtyZXR1cm4gJChyP20tRDptKyg2LUQpLE0pO2Nhc2UgYTpjYXNlIGQ6cmV0dXJuIGwoZytcIkhvdXJzXCIsMCk7Y2FzZSB1OnJldHVybiBsKGcrXCJNaW51dGVzXCIsMSk7Y2FzZSBzOnJldHVybiBsKGcrXCJTZWNvbmRzXCIsMik7Y2FzZSBpOnJldHVybiBsKGcrXCJNaWxsaXNlY29uZHNcIiwzKTtkZWZhdWx0OnJldHVybiB0aGlzLmNsb25lKCl9fSxtLmVuZE9mPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXJ0T2YodCwhMSl9LG0uJHNldD1mdW5jdGlvbih0LGUpe3ZhciBuLG89Ty5wKHQpLGg9XCJzZXRcIisodGhpcy4kdT9cIlVUQ1wiOlwiXCIpLCQ9KG49e30sblthXT1oK1wiRGF0ZVwiLG5bZF09aCtcIkRhdGVcIixuW2ZdPWgrXCJNb250aFwiLG5bY109aCtcIkZ1bGxZZWFyXCIsblt1XT1oK1wiSG91cnNcIixuW3NdPWgrXCJNaW51dGVzXCIsbltpXT1oK1wiU2Vjb25kc1wiLG5bcl09aCtcIk1pbGxpc2Vjb25kc1wiLG4pW29dLGw9bz09PWE/dGhpcy4kRCsoZS10aGlzLiRXKTplO2lmKG89PT1mfHxvPT09Yyl7dmFyIHk9dGhpcy5jbG9uZSgpLnNldChkLDEpO3kuJGRbJF0obCkseS5pbml0KCksdGhpcy4kZD15LnNldChkLE1hdGgubWluKHRoaXMuJEQseS5kYXlzSW5Nb250aCgpKSkuJGR9ZWxzZSAkJiZ0aGlzLiRkWyRdKGwpO3JldHVybiB0aGlzLmluaXQoKSx0aGlzfSxtLnNldD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNsb25lKCkuJHNldCh0LGUpfSxtLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1tPLnAodCldKCl9LG0uYWRkPWZ1bmN0aW9uKHIsaCl7dmFyIGQsJD10aGlzO3I9TnVtYmVyKHIpO3ZhciBsPU8ucChoKSx5PWZ1bmN0aW9uKHQpe3ZhciBlPXcoJCk7cmV0dXJuIE8udyhlLmRhdGUoZS5kYXRlKCkrTWF0aC5yb3VuZCh0KnIpKSwkKX07aWYobD09PWYpcmV0dXJuIHRoaXMuc2V0KGYsdGhpcy4kTStyKTtpZihsPT09YylyZXR1cm4gdGhpcy5zZXQoYyx0aGlzLiR5K3IpO2lmKGw9PT1hKXJldHVybiB5KDEpO2lmKGw9PT1vKXJldHVybiB5KDcpO3ZhciBNPShkPXt9LGRbc109ZSxkW3VdPW4sZFtpXT10LGQpW2xdfHwxLG09dGhpcy4kZC5nZXRUaW1lKCkrcipNO3JldHVybiBPLncobSx0aGlzKX0sbS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFkZCgtMSp0LGUpfSxtLmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy4kbG9jYWxlKCk7aWYoIXRoaXMuaXNWYWxpZCgpKXJldHVybiBuLmludmFsaWREYXRlfHwkO3ZhciByPXR8fFwiWVlZWS1NTS1ERFRISDptbTpzc1pcIixpPU8ueih0aGlzKSxzPXRoaXMuJEgsdT10aGlzLiRtLGE9dGhpcy4kTSxvPW4ud2Vla2RheXMsZj1uLm1vbnRocyxoPWZ1bmN0aW9uKHQsbixpLHMpe3JldHVybiB0JiYodFtuXXx8dChlLHIpKXx8aVtuXS5zbGljZSgwLHMpfSxjPWZ1bmN0aW9uKHQpe3JldHVybiBPLnMocyUxMnx8MTIsdCxcIjBcIil9LGQ9bi5tZXJpZGllbXx8ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQ8MTI/XCJBTVwiOlwiUE1cIjtyZXR1cm4gbj9yLnRvTG93ZXJDYXNlKCk6cn0sbD17WVk6U3RyaW5nKHRoaXMuJHkpLnNsaWNlKC0yKSxZWVlZOnRoaXMuJHksTTphKzEsTU06Ty5zKGErMSwyLFwiMFwiKSxNTU06aChuLm1vbnRoc1Nob3J0LGEsZiwzKSxNTU1NOmgoZixhKSxEOnRoaXMuJEQsREQ6Ty5zKHRoaXMuJEQsMixcIjBcIiksZDpTdHJpbmcodGhpcy4kVyksZGQ6aChuLndlZWtkYXlzTWluLHRoaXMuJFcsbywyKSxkZGQ6aChuLndlZWtkYXlzU2hvcnQsdGhpcy4kVyxvLDMpLGRkZGQ6b1t0aGlzLiRXXSxIOlN0cmluZyhzKSxISDpPLnMocywyLFwiMFwiKSxoOmMoMSksaGg6YygyKSxhOmQocyx1LCEwKSxBOmQocyx1LCExKSxtOlN0cmluZyh1KSxtbTpPLnModSwyLFwiMFwiKSxzOlN0cmluZyh0aGlzLiRzKSxzczpPLnModGhpcy4kcywyLFwiMFwiKSxTU1M6Ty5zKHRoaXMuJG1zLDMsXCIwXCIpLFo6aX07cmV0dXJuIHIucmVwbGFjZSh5LChmdW5jdGlvbih0LGUpe3JldHVybiBlfHxsW3RdfHxpLnJlcGxhY2UoXCI6XCIsXCJcIil9KSl9LG0udXRjT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDE1Ki1NYXRoLnJvdW5kKHRoaXMuJGQuZ2V0VGltZXpvbmVPZmZzZXQoKS8xNSl9LG0uZGlmZj1mdW5jdGlvbihyLGQsJCl7dmFyIGwseT1PLnAoZCksTT13KHIpLG09KE0udXRjT2Zmc2V0KCktdGhpcy51dGNPZmZzZXQoKSkqZSxnPXRoaXMtTSx2PU8ubSh0aGlzLE0pO3JldHVybiB2PShsPXt9LGxbY109di8xMixsW2ZdPXYsbFtoXT12LzMsbFtvXT0oZy1tKS82MDQ4ZTUsbFthXT0oZy1tKS84NjRlNSxsW3VdPWcvbixsW3NdPWcvZSxsW2ldPWcvdCxsKVt5XXx8ZywkP3Y6Ty5hKHYpfSxtLmRheXNJbk1vbnRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kT2YoZikuJER9LG0uJGxvY2FsZT1mdW5jdGlvbigpe3JldHVybiBEW3RoaXMuJExdfSxtLmxvY2FsZT1mdW5jdGlvbih0LGUpe2lmKCF0KXJldHVybiB0aGlzLiRMO3ZhciBuPXRoaXMuY2xvbmUoKSxyPVModCxlLCEwKTtyZXR1cm4gciYmKG4uJEw9ciksbn0sbS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBPLncodGhpcy4kZCx0aGlzKX0sbS50b0RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpfSxtLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzVmFsaWQoKT90aGlzLnRvSVNPU3RyaW5nKCk6bnVsbH0sbS50b0lTT1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvSVNPU3RyaW5nKCl9LG0udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b1VUQ1N0cmluZygpfSxNfSgpLFQ9Xy5wcm90b3R5cGU7cmV0dXJuIHcucHJvdG90eXBlPVQsW1tcIiRtc1wiLHJdLFtcIiRzXCIsaV0sW1wiJG1cIixzXSxbXCIkSFwiLHVdLFtcIiRXXCIsYV0sW1wiJE1cIixmXSxbXCIkeVwiLGNdLFtcIiREXCIsZF1dLmZvckVhY2goKGZ1bmN0aW9uKHQpe1RbdFsxXV09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuJGcoZSx0WzBdLHRbMV0pfX0pKSx3LmV4dGVuZD1mdW5jdGlvbih0LGUpe3JldHVybiB0LiRpfHwodChlLF8sdyksdC4kaT0hMCksd30sdy5sb2NhbGU9Uyx3LmlzRGF5anM9cCx3LnVuaXg9ZnVuY3Rpb24odCl7cmV0dXJuIHcoMWUzKnQpfSx3LmVuPURbdl0sdy5Mcz1ELHcucD17fSx3fSkpOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKHQpOihlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6ZXx8c2VsZikuZGF5anNfcGx1Z2luX2FkdmFuY2VkRm9ybWF0PXQoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXQucHJvdG90eXBlLHM9bi5mb3JtYXQ7ci5lbi5vcmRpbmFsPWZ1bmN0aW9uKGUpe3ZhciB0PVtcInRoXCIsXCJzdFwiLFwibmRcIixcInJkXCJdLHI9ZSUxMDA7cmV0dXJuXCJbXCIrZSsodFsoci0yMCklMTBdfHx0W3JdfHx0WzBdKStcIl1cIn0sbi5mb3JtYXQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPXRoaXMuJGxvY2FsZSgpO2lmKCF0aGlzLmlzVmFsaWQoKSlyZXR1cm4gcy5iaW5kKHRoaXMpKGUpO3ZhciBuPXRoaXMuJHV0aWxzKCksYT0oZXx8XCJZWVlZLU1NLUREVEhIOm1tOnNzWlwiKS5yZXBsYWNlKC9cXFsoW15cXF1dKyldfFF8d298d3d8d3xXV3xXfHp6enx6fGdnZ2d8R0dHR3xEb3xYfHh8a3sxLDJ9fFMvZywoZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcIlFcIjpyZXR1cm4gTWF0aC5jZWlsKCh0LiRNKzEpLzMpO2Nhc2VcIkRvXCI6cmV0dXJuIHIub3JkaW5hbCh0LiREKTtjYXNlXCJnZ2dnXCI6cmV0dXJuIHQud2Vla1llYXIoKTtjYXNlXCJHR0dHXCI6cmV0dXJuIHQuaXNvV2Vla1llYXIoKTtjYXNlXCJ3b1wiOnJldHVybiByLm9yZGluYWwodC53ZWVrKCksXCJXXCIpO2Nhc2VcIndcIjpjYXNlXCJ3d1wiOnJldHVybiBuLnModC53ZWVrKCksXCJ3XCI9PT1lPzE6MixcIjBcIik7Y2FzZVwiV1wiOmNhc2VcIldXXCI6cmV0dXJuIG4ucyh0Lmlzb1dlZWsoKSxcIldcIj09PWU/MToyLFwiMFwiKTtjYXNlXCJrXCI6Y2FzZVwia2tcIjpyZXR1cm4gbi5zKFN0cmluZygwPT09dC4kSD8yNDp0LiRIKSxcImtcIj09PWU/MToyLFwiMFwiKTtjYXNlXCJYXCI6cmV0dXJuIE1hdGguZmxvb3IodC4kZC5nZXRUaW1lKCkvMWUzKTtjYXNlXCJ4XCI6cmV0dXJuIHQuJGQuZ2V0VGltZSgpO2Nhc2VcInpcIjpyZXR1cm5cIltcIit0Lm9mZnNldE5hbWUoKStcIl1cIjtjYXNlXCJ6enpcIjpyZXR1cm5cIltcIit0Lm9mZnNldE5hbWUoXCJsb25nXCIpK1wiXVwiO2RlZmF1bHQ6cmV0dXJuIGV9fSkpO3JldHVybiBzLmJpbmQodGhpcykoYSl9fX0pKTsiLCIhZnVuY3Rpb24ocixlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKToocj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnJ8fHNlbGYpLmRheWpzX3BsdWdpbl9yZWxhdGl2ZVRpbWU9ZSgpfSh0aGlzLChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3JldHVybiBmdW5jdGlvbihyLGUsdCl7cj1yfHx7fTt2YXIgbj1lLnByb3RvdHlwZSxvPXtmdXR1cmU6XCJpbiAlc1wiLHBhc3Q6XCIlcyBhZ29cIixzOlwiYSBmZXcgc2Vjb25kc1wiLG06XCJhIG1pbnV0ZVwiLG1tOlwiJWQgbWludXRlc1wiLGg6XCJhbiBob3VyXCIsaGg6XCIlZCBob3Vyc1wiLGQ6XCJhIGRheVwiLGRkOlwiJWQgZGF5c1wiLE06XCJhIG1vbnRoXCIsTU06XCIlZCBtb250aHNcIix5OlwiYSB5ZWFyXCIseXk6XCIlZCB5ZWFyc1wifTtmdW5jdGlvbiBpKHIsZSx0LG8pe3JldHVybiBuLmZyb21Ub0Jhc2UocixlLHQsbyl9dC5lbi5yZWxhdGl2ZVRpbWU9byxuLmZyb21Ub0Jhc2U9ZnVuY3Rpb24oZSxuLGksZCx1KXtmb3IodmFyIGYsYSxzLGw9aS4kbG9jYWxlKCkucmVsYXRpdmVUaW1lfHxvLGg9ci50aHJlc2hvbGRzfHxbe2w6XCJzXCIscjo0NCxkOlwic2Vjb25kXCJ9LHtsOlwibVwiLHI6ODl9LHtsOlwibW1cIixyOjQ0LGQ6XCJtaW51dGVcIn0se2w6XCJoXCIscjo4OX0se2w6XCJoaFwiLHI6MjEsZDpcImhvdXJcIn0se2w6XCJkXCIscjozNX0se2w6XCJkZFwiLHI6MjUsZDpcImRheVwifSx7bDpcIk1cIixyOjQ1fSx7bDpcIk1NXCIscjoxMCxkOlwibW9udGhcIn0se2w6XCJ5XCIscjoxN30se2w6XCJ5eVwiLGQ6XCJ5ZWFyXCJ9XSxtPWgubGVuZ3RoLGM9MDtjPG07Yys9MSl7dmFyIHk9aFtjXTt5LmQmJihmPWQ/dChlKS5kaWZmKGkseS5kLCEwKTppLmRpZmYoZSx5LmQsITApKTt2YXIgcD0oci5yb3VuZGluZ3x8TWF0aC5yb3VuZCkoTWF0aC5hYnMoZikpO2lmKHM9Zj4wLHA8PXkucnx8IXkucil7cDw9MSYmYz4wJiYoeT1oW2MtMV0pO3ZhciB2PWxbeS5sXTt1JiYocD11KFwiXCIrcCkpLGE9XCJzdHJpbmdcIj09dHlwZW9mIHY/di5yZXBsYWNlKFwiJWRcIixwKTp2KHAsbix5Lmwscyk7YnJlYWt9fWlmKG4pcmV0dXJuIGE7dmFyIE09cz9sLmZ1dHVyZTpsLnBhc3Q7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgTT9NKGEpOk0ucmVwbGFjZShcIiVzXCIsYSl9LG4udG89ZnVuY3Rpb24ocixlKXtyZXR1cm4gaShyLGUsdGhpcywhMCl9LG4uZnJvbT1mdW5jdGlvbihyLGUpe3JldHVybiBpKHIsZSx0aGlzKX07dmFyIGQ9ZnVuY3Rpb24ocil7cmV0dXJuIHIuJHU/dC51dGMoKTp0KCl9O24udG9Ob3c9ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMudG8oZCh0aGlzKSxyKX0sbi5mcm9tTm93PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLmZyb20oZCh0aGlzKSxyKX19fSkpOyIsIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGUpOih0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6dHx8c2VsZikuZGF5anNfcGx1Z2luX3RpbWV6b25lPWUoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD17eWVhcjowLG1vbnRoOjEsZGF5OjIsaG91cjozLG1pbnV0ZTo0LHNlY29uZDo1fSxlPXt9O3JldHVybiBmdW5jdGlvbihuLGksbyl7dmFyIHIsYT1mdW5jdGlvbih0LG4saSl7dm9pZCAwPT09aSYmKGk9e30pO3ZhciBvPW5ldyBEYXRlKHQpLHI9ZnVuY3Rpb24odCxuKXt2b2lkIDA9PT1uJiYobj17fSk7dmFyIGk9bi50aW1lWm9uZU5hbWV8fFwic2hvcnRcIixvPXQrXCJ8XCIraSxyPWVbb107cmV0dXJuIHJ8fChyPW5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIix7aG91cjEyOiExLHRpbWVab25lOnQseWVhcjpcIm51bWVyaWNcIixtb250aDpcIjItZGlnaXRcIixkYXk6XCIyLWRpZ2l0XCIsaG91cjpcIjItZGlnaXRcIixtaW51dGU6XCIyLWRpZ2l0XCIsc2Vjb25kOlwiMi1kaWdpdFwiLHRpbWVab25lTmFtZTppfSksZVtvXT1yKSxyfShuLGkpO3JldHVybiByLmZvcm1hdFRvUGFydHMobyl9LHU9ZnVuY3Rpb24oZSxuKXtmb3IodmFyIGk9YShlLG4pLHI9W10sdT0wO3U8aS5sZW5ndGg7dSs9MSl7dmFyIGY9aVt1XSxzPWYudHlwZSxtPWYudmFsdWUsYz10W3NdO2M+PTAmJihyW2NdPXBhcnNlSW50KG0sMTApKX12YXIgZD1yWzNdLGw9MjQ9PT1kPzA6ZCx2PXJbMF0rXCItXCIrclsxXStcIi1cIityWzJdK1wiIFwiK2wrXCI6XCIrcls0XStcIjpcIityWzVdK1wiOjAwMFwiLGg9K2U7cmV0dXJuKG8udXRjKHYpLnZhbHVlT2YoKS0oaC09aCUxZTMpKS82ZTR9LGY9aS5wcm90b3R5cGU7Zi50ej1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PXQmJih0PXIpO3ZhciBuPXRoaXMudXRjT2Zmc2V0KCksaT10aGlzLnRvRGF0ZSgpLGE9aS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIse3RpbWVab25lOnR9KSx1PU1hdGgucm91bmQoKGktbmV3IERhdGUoYSkpLzFlMy82MCksZj1vKGEpLiRzZXQoXCJtaWxsaXNlY29uZFwiLHRoaXMuJG1zKS51dGNPZmZzZXQoMTUqLU1hdGgucm91bmQoaS5nZXRUaW1lem9uZU9mZnNldCgpLzE1KS11LCEwKTtpZihlKXt2YXIgcz1mLnV0Y09mZnNldCgpO2Y9Zi5hZGQobi1zLFwibWludXRlXCIpfXJldHVybiBmLiR4LiR0aW1lem9uZT10LGZ9LGYub2Zmc2V0TmFtZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLiR4LiR0aW1lem9uZXx8by50ei5ndWVzcygpLG49YSh0aGlzLnZhbHVlT2YoKSxlLHt0aW1lWm9uZU5hbWU6dH0pLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVyblwidGltZXpvbmVuYW1lXCI9PT10LnR5cGUudG9Mb3dlckNhc2UoKX0pKTtyZXR1cm4gbiYmbi52YWx1ZX07dmFyIHM9Zi5zdGFydE9mO2Yuc3RhcnRPZj1mdW5jdGlvbih0LGUpe2lmKCF0aGlzLiR4fHwhdGhpcy4keC4kdGltZXpvbmUpcmV0dXJuIHMuY2FsbCh0aGlzLHQsZSk7dmFyIG49byh0aGlzLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3M6U1NTXCIpKTtyZXR1cm4gcy5jYWxsKG4sdCxlKS50eih0aGlzLiR4LiR0aW1lem9uZSwhMCl9LG8udHo9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4mJmUsYT1ufHxlfHxyLGY9dSgrbygpLGEpO2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0KXJldHVybiBvKHQpLnR6KGEpO3ZhciBzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LTYwKmUqMWUzLG89dShpLG4pO2lmKGU9PT1vKXJldHVybltpLGVdO3ZhciByPXUoaS09NjAqKG8tZSkqMWUzLG4pO3JldHVybiBvPT09cj9baSxvXTpbdC02MCpNYXRoLm1pbihvLHIpKjFlMyxNYXRoLm1heChvLHIpXX0oby51dGModCxpKS52YWx1ZU9mKCksZixhKSxtPXNbMF0sYz1zWzFdLGQ9byhtKS51dGNPZmZzZXQoYyk7cmV0dXJuIGQuJHguJHRpbWV6b25lPWEsZH0sby50ei5ndWVzcz1mdW5jdGlvbigpe3JldHVybiBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmV9LG8udHouc2V0RGVmYXVsdD1mdW5jdGlvbih0KXtyPXR9fX0pKTsiLCIhZnVuY3Rpb24odCxpKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1pKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShpKToodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmRheWpzX3BsdWdpbl91dGM9aSgpfSh0aGlzLChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciB0PVwibWludXRlXCIsaT0vWystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZyxlPS8oWystXXxcXGRcXGQpL2c7cmV0dXJuIGZ1bmN0aW9uKHMsZixuKXt2YXIgdT1mLnByb3RvdHlwZTtuLnV0Yz1mdW5jdGlvbih0KXt2YXIgaT17ZGF0ZTp0LHV0YzohMCxhcmdzOmFyZ3VtZW50c307cmV0dXJuIG5ldyBmKGkpfSx1LnV0Yz1mdW5jdGlvbihpKXt2YXIgZT1uKHRoaXMudG9EYXRlKCkse2xvY2FsZTp0aGlzLiRMLHV0YzohMH0pO3JldHVybiBpP2UuYWRkKHRoaXMudXRjT2Zmc2V0KCksdCk6ZX0sdS5sb2NhbD1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMudG9EYXRlKCkse2xvY2FsZTp0aGlzLiRMLHV0YzohMX0pfTt2YXIgbz11LnBhcnNlO3UucGFyc2U9ZnVuY3Rpb24odCl7dC51dGMmJih0aGlzLiR1PSEwKSx0aGlzLiR1dGlscygpLnUodC4kb2Zmc2V0KXx8KHRoaXMuJG9mZnNldD10LiRvZmZzZXQpLG8uY2FsbCh0aGlzLHQpfTt2YXIgcj11LmluaXQ7dS5pbml0PWZ1bmN0aW9uKCl7aWYodGhpcy4kdSl7dmFyIHQ9dGhpcy4kZDt0aGlzLiR5PXQuZ2V0VVRDRnVsbFllYXIoKSx0aGlzLiRNPXQuZ2V0VVRDTW9udGgoKSx0aGlzLiREPXQuZ2V0VVRDRGF0ZSgpLHRoaXMuJFc9dC5nZXRVVENEYXkoKSx0aGlzLiRIPXQuZ2V0VVRDSG91cnMoKSx0aGlzLiRtPXQuZ2V0VVRDTWludXRlcygpLHRoaXMuJHM9dC5nZXRVVENTZWNvbmRzKCksdGhpcy4kbXM9dC5nZXRVVENNaWxsaXNlY29uZHMoKX1lbHNlIHIuY2FsbCh0aGlzKX07dmFyIGE9dS51dGNPZmZzZXQ7dS51dGNPZmZzZXQ9ZnVuY3Rpb24ocyxmKXt2YXIgbj10aGlzLiR1dGlscygpLnU7aWYobihzKSlyZXR1cm4gdGhpcy4kdT8wOm4odGhpcy4kb2Zmc2V0KT9hLmNhbGwodGhpcyk6dGhpcy4kb2Zmc2V0O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBzJiYocz1mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD1cIlwiKTt2YXIgcz10Lm1hdGNoKGkpO2lmKCFzKXJldHVybiBudWxsO3ZhciBmPShcIlwiK3NbMF0pLm1hdGNoKGUpfHxbXCItXCIsMCwwXSxuPWZbMF0sdT02MCorZlsxXSsgK2ZbMl07cmV0dXJuIDA9PT11PzA6XCIrXCI9PT1uP3U6LXV9KHMpLG51bGw9PT1zKSlyZXR1cm4gdGhpczt2YXIgdT1NYXRoLmFicyhzKTw9MTY/NjAqczpzLG89dGhpcztpZihmKXJldHVybiBvLiRvZmZzZXQ9dSxvLiR1PTA9PT1zLG87aWYoMCE9PXMpe3ZhciByPXRoaXMuJHU/dGhpcy50b0RhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpOi0xKnRoaXMudXRjT2Zmc2V0KCk7KG89dGhpcy5sb2NhbCgpLmFkZCh1K3IsdCkpLiRvZmZzZXQ9dSxvLiR4LiRsb2NhbE9mZnNldD1yfWVsc2Ugbz10aGlzLnV0YygpO3JldHVybiBvfTt2YXIgaD11LmZvcm1hdDt1LmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgaT10fHwodGhpcy4kdT9cIllZWVktTU0tRERUSEg6bW06c3NbWl1cIjpcIlwiKTtyZXR1cm4gaC5jYWxsKHRoaXMsaSl9LHUudmFsdWVPZj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJHV0aWxzKCkudSh0aGlzLiRvZmZzZXQpPzA6dGhpcy4kb2Zmc2V0Kyh0aGlzLiR4LiRsb2NhbE9mZnNldHx8dGhpcy4kZC5nZXRUaW1lem9uZU9mZnNldCgpKTtyZXR1cm4gdGhpcy4kZC52YWx1ZU9mKCktNmU0KnR9LHUuaXNVVEM9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuJHV9LHUudG9JU09TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpfSx1LnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9EYXRlKCkudG9VVENTdHJpbmcoKX07dmFyIGw9dS50b0RhdGU7dS50b0RhdGU9ZnVuY3Rpb24odCl7cmV0dXJuXCJzXCI9PT10JiZ0aGlzLiRvZmZzZXQ/bih0aGlzLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3M6U1NTXCIpKS50b0RhdGUoKTpsLmNhbGwodGhpcyl9O3ZhciBjPXUuZGlmZjt1LmRpZmY9ZnVuY3Rpb24odCxpLGUpe2lmKHQmJnRoaXMuJHU9PT10LiR1KXJldHVybiBjLmNhbGwodGhpcyx0LGksZSk7dmFyIHM9dGhpcy5sb2NhbCgpLGY9bih0KS5sb2NhbCgpO3JldHVybiBjLmNhbGwocyxmLGksZSl9fX0pKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG52YXIgJGV4ZWMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kL2csIG5hbWUpID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZScpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTWFwTGlrZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IHt9O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cygpLmxlbmd0aDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX21hcCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX21hcFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5fbWFwW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBba2V5XTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX21hcCk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21hcFtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuX21hcFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1hcExpa2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBMaWtlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRlbWl0dGVyM1wiKTtcbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubWV0aG9kcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTWVzc2FnZShzb2NrZXQsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gICAgICAgIGxldCBpc0JpbmFyeSA9IGZhbHNlO1xuICAgICAgICBsZXQgaXNBcnJheSA9IGZhbHNlO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBpc0JpbmFyeSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICBpc0JpbmFyeSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGlzQmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRhdGEgPSBcIltcIiArIGRhdGEubWFwKGJ1ZiA9PiBidWYudG9TdHJpbmcoKSkuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICBpc0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLywgbnVsbCwgXCJFbXB0eSBBcnJheVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHJlcyksIGlzQmluYXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxscy5wdXNoKC4uLm9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxscy5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBjb21tb25fMS5jcmVhdGVFcnJvcigtMzI3MDAgLyogUGFyc2VFcnJvciAqLywgbnVsbCwgXCJJbnZhbGlkIEpTT05cIiksXG4gICAgICAgICAgICAgICAgaWQ6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShyZXMpLCBpc0JpbmFyeSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGNhbGxzKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9wcm9jZXNzQ2FsbChzb2NrZXQsIGNhbGwpO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShpc0FycmF5ID8gcmVzcG9uc2VzIDogcmVzcG9uc2VzWzBdKSwgaXNCaW5hcnkpO1xuICAgIH1cbiAgICBhc3luYyBfcHJvY2Vzc0NhbGwoc29ja2V0LCBjYWxsKSB7XG4gICAgICAgIGNvbnN0IHJlcUlkID0gY2FsbC5pZDtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIGlkOiByZXFJZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHJlcUlkXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmVzLmVycm9yID0gY29tbW9uXzEuY3JlYXRlRXJyb3IoLTMyNjAwIC8qIEludmFsaWRSZXF1ZXN0ICovKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGwuanNvbnJwYyAhPT0gXCIyLjBcIiAmJiAodGhpcy5vcHRpb25zLmpzb25ycGNWZXJzaW9uQ2hlY2sgPT09IDAgLyogU1RSSUNUICovIHx8XG4gICAgICAgICAgICAodGhpcy5vcHRpb25zLmpzb25ycGNWZXJzaW9uQ2hlY2sgPT09IDEgLyogTE9PU0UgKi8gJiYgY2FsbC5qc29ucnBjICE9PSB1bmRlZmluZWQpKSkge1xuICAgICAgICAgICAgcmVzLmVycm9yID0gY29tbW9uXzEuY3JlYXRlRXJyb3IoLTMyNjAwIC8qIEludmFsaWRSZXF1ZXN0ICovLCBudWxsLCBcIkludmFsaWQgSlNPTi1SUEMgVmVyc2lvblwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1vbl8xLmlzUmVzcG9uc2UoY2FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInJlc3BvbnNlXCIsIHNvY2tldCwgY2FsbCk7XG4gICAgICAgICAgICBpZiAoY2FsbC5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm1ldGhvZF9yZXNwb25zZVwiLCBzb2NrZXQsIGNhbGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsbC5lcnJvcikge1xuICAgICAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yX3Jlc3BvbnNlXCIsIHNvY2tldCwgY2FsbCk7XG4gICAgICAgICAgICBpZiAoY2FsbC5lcnJvci5jb2RlID09PSAtMzI3MDAgLyogUGFyc2VFcnJvciAqLyB8fCBjYWxsLmVycm9yLmNvZGUgPT09IC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm5vdGlmaWNhdGlvbl9lcnJvclwiLCBzb2NrZXQsIGNhbGwuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FsbC5tZXRob2QpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMSAvKiBNZXRob2ROb3RGb3VuZCAqLywgbnVsbCwgXCJNZXRob2Qgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsLm1ldGhvZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmVzLmVycm9yID0gY29tbW9uXzEuY3JlYXRlRXJyb3IoLTMyNjAwIC8qIEludmFsaWRSZXF1ZXN0ICovLCBudWxsLCBcIkludmFsaWQgdHlwZSBvZiBtZXRob2QgbmFtZVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwicGFyYW1zXCIgaW4gY2FsbCAmJiAodHlwZW9mIGNhbGwucGFyYW1zICE9PSBcIm9iamVjdFwiIHx8IGNhbGwucGFyYW1zID09PSBudWxsKSkge1xuICAgICAgICAgICAgcmVzLmVycm9yID0gY29tbW9uXzEuY3JlYXRlRXJyb3IoLTMyNjAwIC8qIEludmFsaWRSZXF1ZXN0ICovKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kcy5oYXMoY2FsbC5tZXRob2QpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzLmVycm9yID0gY29tbW9uXzEuY3JlYXRlRXJyb3IoLTMyNjAxIC8qIE1ldGhvZE5vdEZvdW5kICovKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCB0aGlzLm1ldGhvZHMuZ2V0KGNhbGwubWV0aG9kKShzb2NrZXQsIGNhbGwucGFyYW1zKSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAocmVxSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuZXJyb3IgPSBjb21tb25fMS5jcmVhdGVFcnJvcigtMzIwMDAgLyogU2VydmVyRXJyb3IgKi8sIGUubmFtZSwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5lcnJvciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWVzc2FnZUhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNzYWdlSGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uZmlnRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKFwiaXNvbW9ycGhpYy13c1wiKTtcbmNvbnN0IEJhY2tvZmYgPSByZXF1aXJlKFwiYmFja28yXCIpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbmNvbnN0IE1lc3NhZ2VIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9NZXNzYWdlSGFuZGxlclwiKTtcbmV4cG9ydHMuQ29uZmlnRGVmYXVsdHMgPSBPYmplY3QuZnJlZXplKHtcbiAgICByZWNvbm5lY3Rpb246IHRydWUsXG4gICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IEluZmluaXR5LFxuICAgIHJlY29ubmVjdGlvbkRlbGF5OiAxMDAwLFxuICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4OiA1MDAwLFxuICAgIHJlY29ubmVjdGlvbkppdHRlcjogMC41LFxuICAgIG1ldGhvZENhbGxUaW1lb3V0OiAyMDAwMCxcbiAgICBhdXRvQ29ubmVjdDogdHJ1ZSxcbiAgICBidWZmZXJTZW5kaW5nTWVzc2FnZXM6IHRydWUsXG4gICAgcXVlcnk6IHt9LFxuICAgIHByb3RvY29sczogXCJcIlxufSk7XG4vKipcbiAqIEpTT04tUlBDIDIuMCBDbGllbnRcbiAqL1xuY2xhc3MgQ2xpZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBVUkkgdG8gY29ubmVjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJpLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy51cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuc2VuZGluZ01lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NraXBSZWNvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFJlcXVlc3RJZCA9IDA7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgLi4uZXhwb3J0cy5Db25maWdEZWZhdWx0cyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICAgICAgICAgIG1pbjogdGhpcy5jb25maWcucmVjb25uZWN0aW9uRGVsYXksXG4gICAgICAgICAgICBtYXg6IHRoaXMuY29uZmlnLnJlY29ubmVjdGlvbkRlbGF5TWF4LFxuICAgICAgICAgICAgaml0dGVyOiB0aGlzLmNvbmZpZy5yZWNvbm5lY3Rpb25KaXR0ZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyXzEuZGVmYXVsdCh0aGlzLmNvbmZpZyk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm9uKFwibWV0aG9kX3Jlc3BvbnNlXCIsIChzb2NrZXQsIHJlc3BvbnNlKSA9PiB0aGlzLl9oYW5kbGVNZXRob2RSZXNwb25zZShyZXNwb25zZSkpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcImVycm9yX3Jlc3BvbnNlXCIsIChzb2NrZXQsIHJlc3BvbnNlKSA9PiB0aGlzLmVtaXQoXCJlcnJvcl9yZXNwb25zZVwiLCByZXNwb25zZSkpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcIm5vdGlmaWNhdGlvbl9lcnJvclwiLCAoc29ja2V0LCBlcnJvcikgPT4gdGhpcy5lbWl0KFwibm90aWZpY2F0aW9uX2Vycm9yXCIsIGVycm9yKSk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRvQ29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2goKCkgPT4gdm9pZCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbWV0aG9kcygpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm1ldGhvZHM7IH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5fd3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW5nXCIpO1xuICAgICAgICBjb25zdCB3cyA9IHRoaXMuX3dzID0gbmV3IFdlYlNvY2tldCh0aGlzLnVyaSwgdGhpcy5jb25maWcucHJvdG9jb2xzLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIGlmICh3cy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3IgPT4gdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpKTtcbiAgICAgICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoeyBjb2RlLCByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93cyA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh7IGRhdGEgfSkgPT4gdGhpcy5fbWVzc2FnZUhhbmRsZXIuaGFuZGxlTWVzc2FnZSh0aGlzLCBkYXRhKS5jYXRjaChlID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3cy5vbihcImVycm9yXCIsIGVycm9yID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gICAgICAgICAgICB3cy5vbihcImNsb3NlXCIsIChjb2RlLCByZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3MgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3cy5vbihcIm1lc3NhZ2VcIiwgZGF0YSA9PiB0aGlzLl9tZXNzYWdlSGFuZGxlci5oYW5kbGVNZXNzYWdlKHRoaXMsIGRhdGEpLmNhdGNoKGUgPT4gdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWcucmVjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9za2lwUmVjb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAod3MuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoKSA9PiB0aGlzLnJlY29ubmVjdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdzLm9uKFwiY2xvc2VcIiwgKCkgPT4gdGhpcy5yZWNvbm5lY3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdzLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdzLm9uY2UoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd3Mub2ZmKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdzLm9uY2UoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2VuZEJ1ZmZlcmVkTWVzc2FnZXMoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IHRoZSBjb25uZWN0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAqL1xuICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuX3NraXBSZWNvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmFja29mZi5yZXNldCgpO1xuICAgICAgICAvLyBjbGVhciBtZXRob2QgY2FsbCB0aW1lb3V0LlxuICAgICAgICBmb3IgKGNvbnN0IFt0aW1lcl0gb2YgdGhpcy5fcmVzcG9uc2VIYW5kbGVycykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmNsZWFyKCk7XG4gICAgICAgIC8vIGNsZWFyIHJlY29ubmVjdGlvbiB0aW1lci5cbiAgICAgICAgaWYgKHRoaXMuX3JlY29ubmVjdGlvblNsZWVwVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWNvbm5lY3Rpb25TbGVlcFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGlvblNsZWVwVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdzID0gdGhpcy5fd3M7XG4gICAgICAgIGlmICghd3MpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOIHx8IHdzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdzLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsICgpID0+IHJlc29sdmUoKSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd3Mub25jZShcImNsb3NlXCIsICgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dzID0gbnVsbDtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgaWYgKHdzLnJlbW92ZUFsbExpc3RlbmVycykge1xuICAgICAgICAgICAgLy8gZm9yIG5vZGVcbiAgICAgICAgICAgIHdzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZm9yIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgYXQgdGhpcyB0aW1lLlxuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmQoZGF0YSwgYmluYXJ5ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGJpbmFyeSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU2VuZGluZ01lc3NhZ2UoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3Muc2VuZChkYXRhLCBlID0+IGUgPyB0aGlzLl9idWZmZXJTZW5kaW5nTWVzc2FnZShkYXRhKSA6IG51bGwpO1xuICAgIH1cbiAgICBjbGVhclNlbmRpbmdNZXNzYWdlQnVmZmVyKCkge1xuICAgICAgICB0aGlzLnNlbmRpbmdNZXNzYWdlQnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIG5vdGlmeShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIH1cbiAgICBjYWxsKG1ldGhvZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLl9jdXJyZW50UmVxdWVzdElkKys7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgaWRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkpTT04tUlBDOiBtZXRob2QgY2FsbCB0aW1lb3V0XCIpKTtcbiAgICAgICAgICAgIH0sIHRoaXMuY29uZmlnLm1ldGhvZENhbGxUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuc2V0KGlkLCBbdGltZW91dCwgcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICE9PSBudWxsICYmIHRoaXMuX3dzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOO1xuICAgIH1cbiAgICBhc3luYyByZWNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWNvbm5lY3RpbmcgfHwgdGhpcy5fc2tpcFJlY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhY2tvZmYgPSB0aGlzLl9iYWNrb2ZmO1xuICAgICAgICBpZiAoYmFja29mZi5hdHRlbXB0cyA+IHRoaXMuY29uZmlnLnJlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWNvbm5lY3RfZmFpbGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsYXkgPSBiYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5fcmVjb25uZWN0aW9uU2xlZXBUaW1lciA9IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW9uU2xlZXBUaW1lciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9za2lwUmVjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwicmVjb25uZWN0aW5nXCIsIGJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgICBpZiAodGhpcy5fc2tpcFJlY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWNvbm5lY3RfZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRlbXB0cyA9IGJhY2tvZmYuYXR0ZW1wdHM7XG4gICAgICAgIGJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdChcInJlY29ubmVjdGVkXCIsIGF0dGVtcHRzKTtcbiAgICB9XG4gICAgX2hhbmRsZU1ldGhvZFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuaWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVua293bl9yZXNwb25zZVwiLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuZ2V0KHJlc3BvbnNlLmlkKTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1bmtvd25fcmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuZGVsZXRlKHJlc3BvbnNlLmlkKTtcbiAgICAgICAgY29uc3QgW3RpbWVyLCByZXNvbHZlLCByZWplY3RdID0gaGFuZGxlcjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgaWYgKGNvbW1vbl8xLmlzU3VjY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYnVmZmVyU2VuZGluZ01lc3NhZ2UoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYnVmZmVyU2VuZGluZ01lc3NhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRpbmdNZXNzYWdlQnVmZmVyLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXNzYWdlIGlzIHJlamVjdGVkOiAgVGhlIHNvY2tldCBpcyBjbG9zZSB3aXRob3V0IG1lc3NhZ2UgYnVmZmVyaW5nLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2VuZEJ1ZmZlcmVkTWVzc2FnZXMoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuc2VuZGluZ01lc3NhZ2VCdWZmZXI7XG4gICAgICAgIGNvbnN0IHdzID0gdGhpcy5fd3M7XG4gICAgICAgIGZvciAobGV0IGRhdGEgPSBidWZmZXIuc2hpZnQoKTsgZGF0YTsgZGF0YSA9IGJ1ZmZlci5zaGlmdCgpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHdzLnNlbmQoZGF0YSwgZSA9PiBlID8gcmVqZWN0KGUpIDogcmVzb2x2ZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci51bnNoaWZ0KGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImJ1ZmZlcl9zZW5kaW5nX2Vycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVFcnJvciA9IGV4cG9ydHMuZXJyb3JDb2RlTWFwID0gZXhwb3J0cy5pc1N1Y2Nlc3NSZXNwb25zZSA9IGV4cG9ydHMuaXNSZXNwb25zZSA9IHZvaWQgMDtcbi8qKlxuICogQ2hlY2sgdHlwZSBvZiBjYWxsIGlzIGFuIFJlcG9uc2Ugb3Igbm90XG4gKiBAcGFyYW0gY2FsbCBhbiBDYWxsIG9iamVjdCB3aGljaCB3aWxsIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzUmVzcG9uc2UoY2FsbCkge1xuICAgIHJldHVybiBcImlkXCIgaW4gY2FsbCAmJiAoXCJyZXN1bHRcIiBpbiBjYWxsIHx8IFwiZXJyb3JcIiBpbiBjYWxsKTtcbn1cbmV4cG9ydHMuaXNSZXNwb25zZSA9IGlzUmVzcG9uc2U7XG4vKipcbiAqIENoZWNrIHR5cGUgb2YgcmVzcG9uc2UgaXMgU3VjY2Vzc1Jlc3BvbnNlIG9yIG5vdFxuICpcbiAqIEBwYXJhbSByZXNwb25zZSBhbiBSZXNwb25zZSBvYmplY3Qgd2hpY2ggd2lsbCBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc1N1Y2Nlc3NSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiBcInJlc3VsdFwiIGluIHJlc3BvbnNlICYmIHJlc3BvbnNlLmlkICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc1N1Y2Nlc3NSZXNwb25zZSA9IGlzU3VjY2Vzc1Jlc3BvbnNlO1xuLyoqXG4gKiBKU09OLVJQQyAyLjAgRXJyb3IgQ29kZXNcbiAqL1xuZXhwb3J0cy5lcnJvckNvZGVNYXAgPSBuZXcgTWFwKFtcbiAgICBbLTMyNzAwLCBcIlBhcnNlIGVycm9yXCJdLFxuICAgIFstMzI2MDAsIFwiSW52YWxpZCBSZXF1ZXN0XCJdLFxuICAgIFstMzI2MDEsIFwiTWV0aG9kIG5vdCBmb3VuZFwiXSxcbiAgICBbLTMyNjAyLCBcIkludmFsaWQgcGFyYW1zXCJdLFxuICAgIFstMzI2MDMsIFwiSW50ZXJuYWwgZXJyb3JcIl0sXG4gICAgWy0zMjAwMCwgXCJTZXJ2ZXIgZXJyb3JcIl1cbl0pO1xuLyoqXG4gKiBDcmVhdGVzIGEgSlNPTi1SUEMgMi4wIGNvbXBsaWFudCBFcnJvciBPYmplY3RcbiAqIEBwYXJhbSBjb2RlIEEgTnVtYmVyIHRoYXQgaW5kaWNhdGVzIHRoZSBlcnJvciB0eXBlIHRoYXQgb2NjdXJyZWQuIChJbnRlZ2VyKVxuICogQHBhcmFtIGRhdGEgQSBQcmltaXRpdmUgb3IgU3RydWN0dXJlZCB2YWx1ZSB0aGF0IGNvbnRhaW5zIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgY29uc3QgZXJyb3IgPSB7XG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgZXhwb3J0cy5lcnJvckNvZGVNYXAuZ2V0KGNvZGUpIHx8IFwiU2VydmVyIGVycm9yXCJcbiAgICB9O1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXJyb3IuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cbmV4cG9ydHMuY3JlYXRlRXJyb3IgPSBjcmVhdGVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50ID0gZXhwb3J0cy5TZXJ2ZXIgPSB2b2lkIDA7XG52YXIgc2VydmVyXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5jb25zdCB3c18xID0gcmVxdWlyZShcIndzXCIpO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBNZXNzYWdlSGFuZGxlcl8xID0gcmVxdWlyZShcIi4vTWVzc2FnZUhhbmRsZXJcIik7XG5jb25zdCBNYXBMaWtlXzEgPSByZXF1aXJlKFwiLi9NYXBMaWtlXCIpO1xuLyoqXG4gKiBKU09OLVJQQyAyLjAgV2ViU29ja2V0IFNlcnZlclxuICovXG5jbGFzcyBTZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIGNhbGxiYWNrIEEgbGlzdGVuZXIgZm9yIHRoZSBgbGlzdGVuaW5nYCBldmVudCAod3MpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGFzdFBpbmdBdCA9IDA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgcGluZ1RpbWVvdXQ6IDUwMDAsXG4gICAgICAgICAgICBwaW5nSW50ZXJ2YWw6IDI1MDAwLFxuICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIGpzb25ycGNWZXJzaW9uQ2hlY2s6IDAgLyogU1RSSUNUICovLFxuICAgICAgICAgICAgdXdzOiBmYWxzZVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXJfMS5kZWZhdWx0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm9uKFwiZXJyb3JfcmVzcG9uc2VcIiwgKHNvY2tldCwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yX3Jlc3BvbnNlXCIsIHNvY2tldCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgc29ja2V0LmVtaXQoXCJlcnJvcl9yZXNwb25zZVwiLCByZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcIm5vdGlmaWNhdGlvbl9lcnJvclwiLCAoc29ja2V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwibm90aWZpY2F0aW9uX2Vycm9yXCIsIHNvY2tldCwgZXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LmVtaXQoXCJub3RpZmljYXRpb25fZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtZXRob2RzKCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZUhhbmRsZXIubWV0aG9kczsgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBjYWxsYmFjayBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnQgKHdzKS5cbiAgICAgKi9cbiAgICBvcGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy53c3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImB3c2AgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud3NFbmdpbmUpIHtcbiAgICAgICAgICAgIHRoaXMud3NzID0gbmV3IHRoaXMub3B0aW9ucy53c0VuZ2luZSh0aGlzLm9wdGlvbnMud3NzLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndzcyA9IG5ldyB3c18xLlNlcnZlcih0aGlzLm9wdGlvbnMud3NzLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53c3Mub25jZShcImxpc3RlbmluZ1wiLCBmdW5jdGlvbiBfb25MaXN0ZW5pbmdXU1MoKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoXCJsaXN0ZW5pbmdcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndzcy5vbihcImNvbm5lY3Rpb25cIiwgZnVuY3Rpb24gX29uQ29ubmVjdGlvbldTUyh3cywgcmVxKSB7XG4gICAgICAgICAgICBsZXQgc29ja2V0ID0gbmV3IFNvY2tldCh3cyk7XG4gICAgICAgICAgICBzZWxmLnNvY2tldHMuc2V0KHNvY2tldC5pZCwgc29ja2V0KTtcbiAgICAgICAgICAgIHdzLm9uY2UoXCJjbG9zZVwiLCBmdW5jdGlvbiBfb25DbG9zZVdTKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc29ja2V0cy5kZWxldGUoc29ja2V0LmlkKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQud3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNvY2tldC5yb29tcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5kYXRhLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc29ja2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB3cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB3cyA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdzLm9uKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBfb25NZXNzYWdlV1MoZGF0YSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX21lc3NhZ2VIYW5kbGVyLmhhbmRsZU1lc3NhZ2Uoc29ja2V0LCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gX29uRXJyb3JIYW5kbGVNZXNzYWdlKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdzLm9uKFwicG9uZ1wiLCBmdW5jdGlvbiBfb25Qb25nV1MoKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Ll9wb25nQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmVtaXQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCwgcmVxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3NzLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gX29uRXJyb3JXU1MoZSkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9waW5nVGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLl9waW5nLmJpbmQodGhpcyksIHRoaXMub3B0aW9ucy5waW5nSW50ZXJ2YWwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBzZXJ2ZXIgYW5kIHRlcm1pbmF0ZXMgYWxsIHNvY2tldHMuXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcGluZ1RpbWVyKTtcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53c3MuY2xvc2UoZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53c3MucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLndzcztcbiAgICAgICAgdGhpcy5zb2NrZXRzLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgYSBub3RpZmljYXRpb24uXG4gICAgICogQHBhcmFtIG1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGJlIGludm9rZWQuXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyBvZiB0aGUgbWV0aG9kLlxuICAgICAqL1xuICAgIGJyb2FkY2FzdChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNvY2tldC5zZW5kKGpzb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgYSBub3RpZmljYXRpb24gdG8gdGhlIHJvb20uXG4gICAgICogQHBhcmFtIHJvb20gVGhlIG5hbWUgb2YgdGhlIHJvb20uXG4gICAgICogQHBhcmFtIG1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGJlIGludm9rZWQuXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyBvZiB0aGUgbWV0aG9kLlxuICAgICAqL1xuICAgIG5vdGlmeVRvKHJvb20sIG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHNvY2tldC5yb29tcy5oYXMocm9vbSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGEgKHJhdykgbWVzc2FnZSB0byB0aGUgcm9vbS5cbiAgICAgKiBAcGFyYW0gcm9vbSBUaGUgbmFtZSBvZiB0aGUgcm9vbS5cbiAgICAgKiBAcGFyYW0gZGF0YSAocmF3KSBtZXNzYWdlLlxuICAgICAqL1xuICAgIHNlbmRUbyhyb29tLCBkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHNvY2tldC5yb29tcy5oYXMocm9vbSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHNvY2tldHMgaW4gdGhlIHJvb20uXG4gICAgICogQHBhcmFtIHJvb20gVGhlIG5hbWUgb2YgdGhlIHJvb20uXG4gICAgICovXG4gICAgaW4ocm9vbSkge1xuICAgICAgICBjb25zdCBzb2NrZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQucm9vbXMuaGFzKHJvb20pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0cy5zZXQoc29ja2V0LmlkLCBzb2NrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb2NrZXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJ2ZXIgaXMgb3BlbiBvciBub3RcbiAgICAgKi9cbiAgICBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndzcyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaW5nIHRvIGFsbCBzb2NrZXRzLlxuICAgICAqL1xuICAgIF9waW5nKCkge1xuICAgICAgICBjb25zdCBkZWFkbGluZSA9IHRoaXMuX2xhc3RQaW5nQXQgKyB0aGlzLm9wdGlvbnMucGluZ1RpbWVvdXQ7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHNvY2tldC5fcG9uZ0F0ID09PSAtMSB8fCBzb2NrZXQuX3BvbmdBdCA+IGRlYWRsaW5lKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0Ll9wb25nQXQgPSAtMTtcbiAgICAgICAgICAgIGlmIChzb2NrZXQuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQud3MucGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RQaW5nQXQgPSBEYXRlLm5vdygpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNlcnZlcjtcbmNsYXNzIFNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iod3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53cyA9IHdzO1xuICAgICAgICB0aGlzLmlkID0gdXVpZF8xLnY0KCk7XG4gICAgICAgIHRoaXMucm9vbXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKiBjdXN0b20gZGF0YSBzdG9yZSAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwTGlrZV8xLmRlZmF1bHQoKTtcbiAgICAgICAgLyoqIChpbnRlcm5hbCB1c2luZyBmb3IgaGVhcnRiZWF0KSAqL1xuICAgICAgICB0aGlzLl9wb25nQXQgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG5vdGlmaWNhdGlvbiB0byB0aGUgc29ja2V0LlxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiZSBpbnZva2VkLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgb2YgdGhlIG1ldGhvZC5cbiAgICAgKi9cbiAgICBub3RpZnkobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgKHJhdykgbWVzc2FnZSB0byB0aGUgc29ja2V0LlxuICAgICAqIEBwYXJhbSBkYXRhIChyYXcpIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIGJpbmFyeSBiaW5hcnkgZmxhZy5cbiAgICAgKi9cbiAgICBzZW5kKGRhdGEsIGJpbmFyeSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgICAgICB0aGlzLndzLnNlbmQoZGF0YSwgeyBiaW5hcnkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbnMgYSByb29tLiBZb3UgY2FuIGpvaW4gbXVsdGlwbGUgcm9vbXMuXG4gICAgICogQHBhcmFtIHJvb20gVGhlIG5hbWUgb2YgdGhlIHJvb20gdGhhdCB3ZSB3YW50IHRvIGpvaW4uXG4gICAgICovXG4gICAgam9pblRvKHJvb20pIHtcbiAgICAgICAgaWYgKHRoaXMucm9vbXMuaGFzKHJvb20pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5yb29tcy5hZGQocm9vbSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyBhIHJvb20uXG4gICAgICogQHBhcmFtIHJvb20gVGhlIG5hbWUgb2YgdGhlIHJvb20gdG8gbGVhdmUuXG4gICAgICovXG4gICAgbGVhdmVGcm9tKHJvb20pIHtcbiAgICAgICAgaWYgKHRoaXMucm9vbXMuaGFzKHJvb20pID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnJvb21zLmRlbGV0ZShyb29tKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmVzIGFsbCB0aGUgcm9vbXMgdGhhdCB3ZSd2ZSBqb2luZWQuXG4gICAgICovXG4gICAgbGVhdmVGcm9tQWxsKCkge1xuICAgICAgICB0aGlzLnJvb21zLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgY2xvc2luZyBoYW5kc2hha2UuXG4gICAgICogQHBhcmFtIGNvZGUgQSBudW1lcmljIHZhbHVlIGluZGljYXRpbmcgdGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGJlaW5nIGNsb3NlZC5cbiAgICAgKiBAcGFyYW0gcmVhc29uIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmcuXG4gICAgICovXG4gICAgY2xvc2UoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgdGVybWluYXRlKCkge1xuICAgICAgICB0aGlzLndzLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbm5lY3Rpb24gaXMgb3BlbiBvciBub3RcbiAgICAgKi9cbiAgICBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndzICE9PSB1bmRlZmluZWQgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSB3c18xLk9QRU47XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXQgPSBTb2NrZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXIuanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSBMb25nO1xyXG5cclxuLyoqXHJcbiAqIHdhc20gb3B0aW1pemF0aW9ucywgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXHJcbiAqL1xyXG52YXIgd2FzbSA9IG51bGw7XHJcblxyXG50cnkge1xyXG4gIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbXHJcbiAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMVxyXG4gIF0pKSwge30pLmV4cG9ydHM7XHJcbn0gY2F0Y2ggKGUpIHtcclxuICAvLyBubyB3YXNtIHN1cHBvcnQgOihcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXHJcbiAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxyXG4gKiBAZXhwb3J0cyBMb25nXHJcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbn1cclxuXHJcbi8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbi8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXHJcbi8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxyXG4vLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbi8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XHJcbi8vIG9yIGNoYW5nZSBpbiBzaWduLlxyXG4vL1xyXG4vLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXHJcbi8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxyXG4vLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xyXG4vLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXHJcbi8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuLy9cclxuLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXHJcbi8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4vKipcclxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGNvbnN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Mb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcclxuICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZy5pc0xvbmcgPSBpc0xvbmc7XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICogQHR5cGUgeyFPYmplY3R9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xyXG4gICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgfD0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgIGlmIChpc05hTih2YWx1ZSkpXHJcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgcmFkaXggPSB1bnNpZ25lZCxcclxuICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB1bnNpZ25lZCA9ICEhIHVuc2lnbmVkO1xyXG4gICAgfVxyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgIHZhciBwO1xyXG4gICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgIGVsc2UgaWYgKHAgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBaRVJPO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgIGlmIChzaXplIDwgOCkge1xyXG4gICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcclxuICAgIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XHJcbiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4vLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogVW5zaWduZWQgemVyby5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VWkVSTyA9IFVaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk9ORSA9IE9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4RkZGRkZGRkZ8MCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XHJcblxyXG4vKipcclxuICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBvdmVycmlkZVxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcclxuICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXHJcbiAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxyXG4gICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXHJcbiAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIHJlbSA9IHJlbURpdjtcclxuICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XHJcbiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKVxyXG4gICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG5cclxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcclxuICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCArIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKyBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICsgYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCArIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcclxuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcclxuICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIuaGlnaCk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcbiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xyXG4gICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XHJcblxyXG4gICAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxyXG4gICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxyXG4gICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxyXG4gKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIHBvc2l0aXZlIG51bWJlciwgZHVlIHRvIHR3bydzIGNvbXBsZW1lbnQuXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcclxuICAgICAgICAgICAgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKFxyXG4gICAgICAgICAgICB0aGlzLmxvdyxcclxuICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyxcclxuICAgICAgICAgICAgZGl2aXNvci5oaWdoXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcclxuICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXHJcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XHJcbiAgICAgICAgcmVzID0gWkVSTztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXHJcbiAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcclxuICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcclxuICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgcmVzID0gVVpFUk87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcclxuICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgcmVtID0gdGhpcztcclxuICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxyXG4gICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cclxuICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXHJcblxyXG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxyXG4gICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcclxuICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBPTkU7XHJcblxyXG4gICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcclxuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgbnVtQml0cyAmPSA2MztcclxuICAgIGlmIChudW1CaXRzID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAyNFxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBoaSA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvICAgICAgICAmIDB4ZmZcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1swXSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1szXSA8PCAyNCxcclxuICAgICAgICBieXRlc1s0XSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1s3XSA8PCAyNCxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKFxyXG4gICAgICAgIGJ5dGVzWzRdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1s1XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbNl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzddLFxyXG4gICAgICAgIGJ5dGVzWzBdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1sxXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbMl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzNdLFxyXG4gICAgICAgIHVuc2lnbmVkXHJcbiAgICApO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuXHQvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcblx0Ly8gSG93ZXZlciwgdGhpcyBjYXVzZXMgQ1NQIHZpb2xhdGlvbnMgaW4gQ2hyb21lIGFwcHMuXG5cdGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH1cblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cblx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH1cblx0dGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn1cblxudmFyIGdsb2JhbCA9IGdldEdsb2JhbCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBnbG9iYWwuZmV0Y2g7XG5cbi8vIE5lZWRlZCBmb3IgVHlwZVNjcmlwdCBhbmQgV2VicGFjay5cbmlmIChnbG9iYWwuZmV0Y2gpIHtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZ2xvYmFsLmZldGNoLmJpbmQoZ2xvYmFsKTtcbn1cblxuZXhwb3J0cy5IZWFkZXJzID0gZ2xvYmFsLkhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBnbG9iYWwuUmVxdWVzdDtcbmV4cG9ydHMuUmVzcG9uc2UgPSBnbG9iYWwuUmVzcG9uc2U7IiwidmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgTWFwLnByb3RvdHlwZTtcbnZhciBtYXBTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzTWFwID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNYXAucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBtYXBTaXplID0gaGFzTWFwICYmIG1hcFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBtYXBTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBtYXBTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIG1hcEZvckVhY2ggPSBoYXNNYXAgJiYgTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZTtcbnZhciBzZXRTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzU2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTZXQucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBzZXRTaXplID0gaGFzU2V0ICYmIHNldFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBzZXRTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBzZXRTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIHNldEZvckVhY2ggPSBoYXNTZXQgJiYgU2V0LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrTWFwLnByb3RvdHlwZTtcbnZhciB3ZWFrTWFwSGFzID0gaGFzV2Vha01hcCA/IFdlYWtNYXAucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgaGFzV2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nICYmIFdlYWtTZXQucHJvdG90eXBlO1xudmFyIHdlYWtTZXRIYXMgPSBoYXNXZWFrU2V0ID8gV2Vha1NldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrUmVmID0gdHlwZW9mIFdlYWtSZWYgPT09ICdmdW5jdGlvbicgJiYgV2Vha1JlZi5wcm90b3R5cGU7XG52YXIgd2Vha1JlZkRlcmVmID0gaGFzV2Vha1JlZiA/IFdlYWtSZWYucHJvdG90eXBlLmRlcmVmIDogbnVsbDtcbnZhciBib29sZWFuVmFsdWVPZiA9IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgJG1hdGNoID0gU3RyaW5nLnByb3RvdHlwZS5tYXRjaDtcbnZhciAkc2xpY2UgPSBTdHJpbmcucHJvdG90eXBlLnNsaWNlO1xudmFyICRyZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyICR0b1VwcGVyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2U7XG52YXIgJHRvTG93ZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZTtcbnZhciAkdGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbnZhciAkY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciAkam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xudmFyICRhcnJTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciAkZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGJpZ0ludFZhbHVlT2YgPSB0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nID8gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mIDogbnVsbDtcbnZhciBnT1BTID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBzeW1Ub1N0cmluZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogbnVsbDtcbnZhciBoYXNTaGFtbWVkU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ29iamVjdCc7XG4vLyBpZSwgYGhhcy10b3N0cmluZ3RhZy9zaGFtc1xudmFyIHRvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IGhhc1NoYW1tZWRTeW1ib2xzID8gJ29iamVjdCcgOiAnc3ltYm9sJylcbiAgICA/IFN5bWJvbC50b1N0cmluZ1RhZ1xuICAgIDogbnVsbDtcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgZ1BPID0gKHR5cGVvZiBSZWZsZWN0ID09PSAnZnVuY3Rpb24nID8gUmVmbGVjdC5nZXRQcm90b3R5cGVPZiA6IE9iamVjdC5nZXRQcm90b3R5cGVPZikgfHwgKFxuICAgIFtdLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgPyBmdW5jdGlvbiAoTykge1xuICAgICAgICAgICAgcmV0dXJuIE8uX19wcm90b19fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsXG4pO1xuXG5mdW5jdGlvbiBhZGROdW1lcmljU2VwYXJhdG9yKG51bSwgc3RyKSB7XG4gICAgaWYgKFxuICAgICAgICBudW0gPT09IEluZmluaXR5XG4gICAgICAgIHx8IG51bSA9PT0gLUluZmluaXR5XG4gICAgICAgIHx8IG51bSAhPT0gbnVtXG4gICAgICAgIHx8IChudW0gJiYgbnVtID4gLTEwMDAgJiYgbnVtIDwgMTAwMClcbiAgICAgICAgfHwgJHRlc3QuY2FsbCgvZS8sIHN0cilcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgdmFyIHNlcFJlZ2V4ID0gL1swLTldKD89KD86WzAtOV17M30pKyg/IVswLTldKSkvZztcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGludCA9IG51bSA8IDAgPyAtJGZsb29yKC1udW0pIDogJGZsb29yKG51bSk7IC8vIHRydW5jKG51bSlcbiAgICAgICAgaWYgKGludCAhPT0gbnVtKSB7XG4gICAgICAgICAgICB2YXIgaW50U3RyID0gU3RyaW5nKGludCk7XG4gICAgICAgICAgICB2YXIgZGVjID0gJHNsaWNlLmNhbGwoc3RyLCBpbnRTdHIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChpbnRTdHIsIHNlcFJlZ2V4LCAnJCZfJykgKyAnLicgKyAkcmVwbGFjZS5jYWxsKCRyZXBsYWNlLmNhbGwoZGVjLCAvKFswLTldezN9KS9nLCAnJCZfJyksIC9fJC8sICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChzdHIsIHNlcFJlZ2V4LCAnJCZfJyk7XG59XG5cbnZhciB1dGlsSW5zcGVjdCA9IHJlcXVpcmUoJy4vdXRpbC5pbnNwZWN0Jyk7XG52YXIgaW5zcGVjdEN1c3RvbSA9IHV0aWxJbnNwZWN0LmN1c3RvbTtcbnZhciBpbnNwZWN0U3ltYm9sID0gaXNTeW1ib2woaW5zcGVjdEN1c3RvbSkgPyBpbnNwZWN0Q3VzdG9tIDogbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnNwZWN0XyhvYmosIG9wdGlvbnMsIGRlcHRoLCBzZWVuKSB7XG4gICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpICYmIChvcHRzLnF1b3RlU3R5bGUgIT09ICdzaW5nbGUnICYmIG9wdHMucXVvdGVTdHlsZSAhPT0gJ2RvdWJsZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcInF1b3RlU3R5bGVcIiBtdXN0IGJlIFwic2luZ2xlXCIgb3IgXCJkb3VibGVcIicpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnbWF4U3RyaW5nTGVuZ3RoJykgJiYgKHR5cGVvZiBvcHRzLm1heFN0cmluZ0xlbmd0aCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gb3B0cy5tYXhTdHJpbmdMZW5ndGggPCAwICYmIG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBJbmZpbml0eVxuICAgICAgICAgICAgOiBvcHRzLm1heFN0cmluZ0xlbmd0aCAhPT0gbnVsbFxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm1heFN0cmluZ0xlbmd0aFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIEluZmluaXR5LCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgdmFyIGN1c3RvbUluc3BlY3QgPSBoYXMob3B0cywgJ2N1c3RvbUluc3BlY3QnKSA/IG9wdHMuY3VzdG9tSW5zcGVjdCA6IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0ICE9PSAnYm9vbGVhbicgJiYgY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiY3VzdG9tSW5zcGVjdFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBgdHJ1ZWAsIGBmYWxzZWAsIG9yIGBcXCdzeW1ib2xcXCdgJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ2luZGVudCcpXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSBudWxsXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSAnXFx0J1xuICAgICAgICAmJiAhKHBhcnNlSW50KG9wdHMuaW5kZW50LCAxMCkgPT09IG9wdHMuaW5kZW50ICYmIG9wdHMuaW5kZW50ID4gMClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiaW5kZW50XCIgbXVzdCBiZSBcIlxcXFx0XCIsIGFuIGludGVnZXIgPiAwLCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgaWYgKGhhcyhvcHRzLCAnbnVtZXJpY1NlcGFyYXRvcicpICYmIHR5cGVvZiBvcHRzLm51bWVyaWNTZXBhcmF0b3IgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJudW1lcmljU2VwYXJhdG9yXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCBvciBgZmFsc2VgJyk7XG4gICAgfVxuICAgIHZhciBudW1lcmljU2VwYXJhdG9yID0gb3B0cy5udW1lcmljU2VwYXJhdG9yO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvYmogPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhvYmosIG9wdHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5IC8gb2JqID4gMCA/ICcwJyA6ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhvYmopO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBzdHIpIDogc3RyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFyIGJpZ0ludFN0ciA9IFN0cmluZyhvYmopICsgJ24nO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBiaWdJbnRTdHIpIDogYmlnSW50U3RyO1xuICAgIH1cblxuICAgIHZhciBtYXhEZXB0aCA9IHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDUgOiBvcHRzLmRlcHRoO1xuICAgIGlmICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnKSB7IGRlcHRoID0gMDsgfVxuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDAgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdbQXJyYXldJyA6ICdbT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IGdldEluZGVudChvcHRzLCBkZXB0aCk7XG5cbiAgICBpZiAodHlwZW9mIHNlZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlZW4gPSBbXTtcbiAgICB9IGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHNlZW4gPSAkYXJyU2xpY2UuY2FsbChzZWVuKTtcbiAgICAgICAgICAgIHNlZW4ucHVzaChmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9JbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdPcHRzID0ge1xuICAgICAgICAgICAgICAgIGRlcHRoOiBvcHRzLmRlcHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0cy5xdW90ZVN0eWxlID0gb3B0cy5xdW90ZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBuZXdPcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgb3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNSZWdFeHAob2JqKSkgeyAvLyBpbiBvbGRlciBlbmdpbmVzLCByZWdleGVzIGFyZSBjYWxsYWJsZVxuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPZihvYmopO1xuICAgICAgICB2YXIga2V5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgcmV0dXJuICdbRnVuY3Rpb24nICsgKG5hbWUgPyAnOiAnICsgbmFtZSA6ICcgKGFub255bW91cyknKSArICddJyArIChrZXlzLmxlbmd0aCA+IDAgPyAnIHsgJyArICRqb2luLmNhbGwoa2V5cywgJywgJykgKyAnIH0nIDogJycpO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wob2JqKSkge1xuICAgICAgICB2YXIgc3ltU3RyaW5nID0gaGFzU2hhbW1lZFN5bWJvbHMgPyAkcmVwbGFjZS5jYWxsKFN0cmluZyhvYmopLCAvXihTeW1ib2xcXCguKlxcKSlfW14pXSokLywgJyQxJykgOiBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaGFzU2hhbW1lZFN5bWJvbHMgPyBtYXJrQm94ZWQoc3ltU3RyaW5nKSA6IHN5bVN0cmluZztcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChvYmopKSB7XG4gICAgICAgIHZhciBzID0gJzwnICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpO1xuICAgICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyc1tpXS5uYW1lICsgJz0nICsgd3JhcFF1b3RlcyhxdW90ZShhdHRyc1tpXS52YWx1ZSksICdkb3VibGUnLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcbiAgICAgICAgaWYgKG9iai5jaGlsZE5vZGVzICYmIG9iai5jaGlsZE5vZGVzLmxlbmd0aCkgeyBzICs9ICcuLi4nOyB9XG4gICAgICAgIHMgKz0gJzwvJyArICR0b0xvd2VyQ2FzZS5jYWxsKFN0cmluZyhvYmoubm9kZU5hbWUpKSArICc+JztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbXSc7IH1cbiAgICAgICAgdmFyIHhzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICBpZiAoaW5kZW50ICYmICFzaW5nbGVMaW5lVmFsdWVzKHhzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGluZGVudGVkSm9pbih4cywgaW5kZW50KSArICddJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1sgJyArICRqb2luLmNhbGwoeHMsICcsICcpICsgJyBdJztcbiAgICB9XG4gICAgaWYgKGlzRXJyb3Iob2JqKSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmICghKCdjYXVzZScgaW4gRXJyb3IucHJvdG90eXBlKSAmJiAnY2F1c2UnIGluIG9iaiAmJiAhaXNFbnVtZXJhYmxlLmNhbGwob2JqLCAnY2F1c2UnKSkge1xuICAgICAgICAgICAgcmV0dXJuICd7IFsnICsgU3RyaW5nKG9iaikgKyAnXSAnICsgJGpvaW4uY2FsbCgkY29uY2F0LmNhbGwoJ1tjYXVzZV06ICcgKyBpbnNwZWN0KG9iai5jYXVzZSksIHBhcnRzKSwgJywgJykgKyAnIH0nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbJyArIFN0cmluZyhvYmopICsgJ10nOyB9XG4gICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArICRqb2luLmNhbGwocGFydHMsICcsICcpICsgJyB9JztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGN1c3RvbUluc3BlY3QpIHtcbiAgICAgICAgaWYgKGluc3BlY3RTeW1ib2wgJiYgdHlwZW9mIG9ialtpbnNwZWN0U3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJyAmJiB1dGlsSW5zcGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxJbnNwZWN0KG9iaiwgeyBkZXB0aDogbWF4RGVwdGggLSBkZXB0aCB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJyAmJiB0eXBlb2Ygb2JqLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouaW5zcGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc01hcChvYmopKSB7XG4gICAgICAgIHZhciBtYXBQYXJ0cyA9IFtdO1xuICAgICAgICBtYXBGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgbWFwUGFydHMucHVzaChpbnNwZWN0KGtleSwgb2JqLCB0cnVlKSArICcgPT4gJyArIGluc3BlY3QodmFsdWUsIG9iaikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25PZignTWFwJywgbWFwU2l6ZS5jYWxsKG9iaiksIG1hcFBhcnRzLCBpbmRlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNTZXQob2JqKSkge1xuICAgICAgICB2YXIgc2V0UGFydHMgPSBbXTtcbiAgICAgICAgc2V0Rm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRQYXJ0cy5wdXNoKGluc3BlY3QodmFsdWUsIG9iaikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25PZignU2V0Jywgc2V0U2l6ZS5jYWxsKG9iaiksIHNldFBhcnRzLCBpbmRlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrTWFwKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtNYXAnKTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha1NldChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrU2V0Jyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1JlZicpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoTnVtYmVyKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnSW50KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KGJpZ0ludFZhbHVlT2YuY2FsbChvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4ob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGJvb2xlYW5WYWx1ZU9mLmNhbGwob2JqKSk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChTdHJpbmcob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoIWlzRGF0ZShvYmopICYmICFpc1JlZ0V4cChvYmopKSB7XG4gICAgICAgIHZhciB5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgdmFyIGlzUGxhaW5PYmplY3QgPSBnUE8gPyBnUE8ob2JqKSA9PT0gT2JqZWN0LnByb3RvdHlwZSA6IG9iaiBpbnN0YW5jZW9mIE9iamVjdCB8fCBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICAgICAgdmFyIHByb3RvVGFnID0gb2JqIGluc3RhbmNlb2YgT2JqZWN0ID8gJycgOiAnbnVsbCBwcm90b3R5cGUnO1xuICAgICAgICB2YXIgc3RyaW5nVGFnID0gIWlzUGxhaW5PYmplY3QgJiYgdG9TdHJpbmdUYWcgJiYgT2JqZWN0KG9iaikgPT09IG9iaiAmJiB0b1N0cmluZ1RhZyBpbiBvYmogPyAkc2xpY2UuY2FsbCh0b1N0cihvYmopLCA4LCAtMSkgOiBwcm90b1RhZyA/ICdPYmplY3QnIDogJyc7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvclRhZyA9IGlzUGxhaW5PYmplY3QgfHwgdHlwZW9mIG9iai5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJyA/ICcnIDogb2JqLmNvbnN0cnVjdG9yLm5hbWUgPyBvYmouY29uc3RydWN0b3IubmFtZSArICcgJyA6ICcnO1xuICAgICAgICB2YXIgdGFnID0gY29uc3RydWN0b3JUYWcgKyAoc3RyaW5nVGFnIHx8IHByb3RvVGFnID8gJ1snICsgJGpvaW4uY2FsbCgkY29uY2F0LmNhbGwoW10sIHN0cmluZ1RhZyB8fCBbXSwgcHJvdG9UYWcgfHwgW10pLCAnOiAnKSArICddICcgOiAnJyk7XG4gICAgICAgIGlmICh5cy5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRhZyArICd7fSc7IH1cbiAgICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZyArICd7JyArIGluZGVudGVkSm9pbih5cywgaW5kZW50KSArICd9JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnICsgJ3sgJyArICRqb2luLmNhbGwoeXMsICcsICcpICsgJyB9JztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhvYmopO1xufTtcblxuZnVuY3Rpb24gd3JhcFF1b3RlcyhzLCBkZWZhdWx0U3R5bGUsIG9wdHMpIHtcbiAgICB2YXIgcXVvdGVDaGFyID0gKG9wdHMucXVvdGVTdHlsZSB8fCBkZWZhdWx0U3R5bGUpID09PSAnZG91YmxlJyA/ICdcIicgOiBcIidcIjtcbiAgICByZXR1cm4gcXVvdGVDaGFyICsgcyArIHF1b3RlQ2hhcjtcbn1cblxuZnVuY3Rpb24gcXVvdGUocykge1xuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKFN0cmluZyhzKSwgL1wiL2csICcmcXVvdDsnKTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBEYXRlXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNFcnJvcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEVycm9yXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cblxuLy8gU3ltYm9sIGFuZCBCaWdJbnQgZG8gaGF2ZSBTeW1ib2wudG9TdHJpbmdUYWcgYnkgc3BlYywgc28gdGhhdCBjYW4ndCBiZSB1c2VkIHRvIGVsaW1pbmF0ZSBmYWxzZSBwb3NpdGl2ZXNcbmZ1bmN0aW9uIGlzU3ltYm9sKG9iaikge1xuICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scykge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiBpbnN0YW5jZW9mIFN5bWJvbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCAhc3ltVG9TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0JpZ0ludChvYmopIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCAhYmlnSW50VmFsdWVPZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGJpZ0ludFZhbHVlT2YuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5IGluIHRoaXM7IH07XG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufVxuXG5mdW5jdGlvbiB0b1N0cihvYmopIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBuYW1lT2YoZikge1xuICAgIGlmIChmLm5hbWUpIHsgcmV0dXJuIGYubmFtZTsgfVxuICAgIHZhciBtID0gJG1hdGNoLmNhbGwoZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGYpLCAvXmZ1bmN0aW9uXFxzKihbXFx3JF0rKS8pO1xuICAgIGlmIChtKSB7IHJldHVybiBtWzFdOyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgeyByZXR1cm4geHMuaW5kZXhPZih4KTsgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0geCkgeyByZXR1cm4gaTsgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzTWFwKHgpIHtcbiAgICBpZiAoIW1hcFNpemUgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0U2l6ZS5jYWxsKHgpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIE1hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha01hcCh4KSB7XG4gICAgaWYgKCF3ZWFrTWFwSGFzIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtNYXBIYXMuY2FsbCh4LCB3ZWFrTWFwSGFzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdlYWtTZXRIYXMuY2FsbCh4LCB3ZWFrU2V0SGFzKTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXZWFrTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrUmVmKHgpIHtcbiAgICBpZiAoIXdlYWtSZWZEZXJlZiB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrUmVmRGVyZWYuY2FsbCh4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU2V0KHgpIHtcbiAgICBpZiAoIXNldFNpemUgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc2V0U2l6ZS5jYWxsKHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xuICAgICAgICB9IGNhdGNoIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFNldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha1NldCh4KSB7XG4gICAgaWYgKCF3ZWFrU2V0SGFzIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtTZXRIYXMuY2FsbCh4LCB3ZWFrU2V0SGFzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdlYWtNYXBIYXMuY2FsbCh4LCB3ZWFrTWFwSGFzKTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXZWFrU2V0OyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50KHgpIHtcbiAgICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB4Lm5vZGVOYW1lID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgeC5nZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RTdHJpbmcoc3RyLCBvcHRzKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPiBvcHRzLm1heFN0cmluZ0xlbmd0aCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gc3RyLmxlbmd0aCAtIG9wdHMubWF4U3RyaW5nTGVuZ3RoO1xuICAgICAgICB2YXIgdHJhaWxlciA9ICcuLi4gJyArIHJlbWFpbmluZyArICcgbW9yZSBjaGFyYWN0ZXInICsgKHJlbWFpbmluZyA+IDEgPyAncycgOiAnJyk7XG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKCRzbGljZS5jYWxsKHN0ciwgMCwgb3B0cy5tYXhTdHJpbmdMZW5ndGgpLCBvcHRzKSArIHRyYWlsZXI7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgdmFyIHMgPSAkcmVwbGFjZS5jYWxsKCRyZXBsYWNlLmNhbGwoc3RyLCAvKFsnXFxcXF0pL2csICdcXFxcJDEnKSwgL1tcXHgwMC1cXHgxZl0vZywgbG93Ynl0ZSk7XG4gICAgcmV0dXJuIHdyYXBRdW90ZXMocywgJ3NpbmdsZScsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBsb3dieXRlKGMpIHtcbiAgICB2YXIgbiA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgeCA9IHtcbiAgICAgICAgODogJ2InLFxuICAgICAgICA5OiAndCcsXG4gICAgICAgIDEwOiAnbicsXG4gICAgICAgIDEyOiAnZicsXG4gICAgICAgIDEzOiAncidcbiAgICB9W25dO1xuICAgIGlmICh4KSB7IHJldHVybiAnXFxcXCcgKyB4OyB9XG4gICAgcmV0dXJuICdcXFxceCcgKyAobiA8IDB4MTAgPyAnMCcgOiAnJykgKyAkdG9VcHBlckNhc2UuY2FsbChuLnRvU3RyaW5nKDE2KSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtCb3hlZChzdHIpIHtcbiAgICByZXR1cm4gJ09iamVjdCgnICsgc3RyICsgJyknO1xufVxuXG5mdW5jdGlvbiB3ZWFrQ29sbGVjdGlvbk9mKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSArICcgeyA/IH0nO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uT2YodHlwZSwgc2l6ZSwgZW50cmllcywgaW5kZW50KSB7XG4gICAgdmFyIGpvaW5lZEVudHJpZXMgPSBpbmRlbnQgPyBpbmRlbnRlZEpvaW4oZW50cmllcywgaW5kZW50KSA6ICRqb2luLmNhbGwoZW50cmllcywgJywgJyk7XG4gICAgcmV0dXJuIHR5cGUgKyAnICgnICsgc2l6ZSArICcpIHsnICsgam9pbmVkRW50cmllcyArICd9Jztcbn1cblxuZnVuY3Rpb24gc2luZ2xlTGluZVZhbHVlcyh4cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluZGV4T2YoeHNbaV0sICdcXG4nKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEluZGVudChvcHRzLCBkZXB0aCkge1xuICAgIHZhciBiYXNlSW5kZW50O1xuICAgIGlmIChvcHRzLmluZGVudCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgYmFzZUluZGVudCA9ICdcXHQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuaW5kZW50ID09PSAnbnVtYmVyJyAmJiBvcHRzLmluZGVudCA+IDApIHtcbiAgICAgICAgYmFzZUluZGVudCA9ICRqb2luLmNhbGwoQXJyYXkob3B0cy5pbmRlbnQgKyAxKSwgJyAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZTogYmFzZUluZGVudCxcbiAgICAgICAgcHJldjogJGpvaW4uY2FsbChBcnJheShkZXB0aCArIDEpLCBiYXNlSW5kZW50KVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGluZGVudGVkSm9pbih4cywgaW5kZW50KSB7XG4gICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJyc7IH1cbiAgICB2YXIgbGluZUpvaW5lciA9ICdcXG4nICsgaW5kZW50LnByZXYgKyBpbmRlbnQuYmFzZTtcbiAgICByZXR1cm4gbGluZUpvaW5lciArICRqb2luLmNhbGwoeHMsICcsJyArIGxpbmVKb2luZXIpICsgJ1xcbicgKyBpbmRlbnQucHJldjtcbn1cblxuZnVuY3Rpb24gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iaik7XG4gICAgdmFyIHhzID0gW107XG4gICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHhzLmxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4c1tpXSA9IGhhcyhvYmosIGkpID8gaW5zcGVjdChvYmpbaV0sIG9iaikgOiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3ltcyA9IHR5cGVvZiBnT1BTID09PSAnZnVuY3Rpb24nID8gZ09QUyhvYmopIDogW107XG4gICAgdmFyIHN5bU1hcDtcbiAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMpIHtcbiAgICAgICAgc3ltTWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3ltcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgc3ltTWFwWyckJyArIHN5bXNba11dID0gc3ltc1trXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBpZiAoIWhhcyhvYmosIGtleSkpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgaWYgKGlzQXJyICYmIFN0cmluZyhOdW1iZXIoa2V5KSkgPT09IGtleSAmJiBrZXkgPCBvYmoubGVuZ3RoKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scyAmJiBzeW1NYXBbJyQnICsga2V5XSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBwcmV2ZW50IHNoYW1tZWQgU3ltYm9scywgd2hpY2ggYXJlIHN0b3JlZCBhcyBzdHJpbmdzLCBmcm9tIGJlaW5nIGluY2x1ZGVkIGluIHRoZSBzdHJpbmcga2V5IHNlY3Rpb25cbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKCR0ZXN0LmNhbGwoL1teXFx3JF0vLCBrZXkpKSB7XG4gICAgICAgICAgICB4cy5wdXNoKGluc3BlY3Qoa2V5LCBvYmopICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeHMucHVzaChrZXkgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnT1BTID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ltcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltc1tqXSkpIHtcbiAgICAgICAgICAgICAgICB4cy5wdXNoKCdbJyArIGluc3BlY3Qoc3ltc1tqXSkgKyAnXTogJyArIGluc3BlY3Qob2JqW3N5bXNbal1dLCBvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geHM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyIHBlcmNlbnRUd2VudGllcyA9IC8lMjAvZztcblxudmFyIEZvcm1hdCA9IHtcbiAgICBSRkMxNzM4OiAnUkZDMTczOCcsXG4gICAgUkZDMzk4NjogJ1JGQzM5ODYnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6IEZvcm1hdC5SRkMzOTg2LFxuICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgUkZDMTczODogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZS5jYWxsKHZhbHVlLCBwZXJjZW50VHdlbnRpZXMsICcrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJGQzM5ODY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFJGQzE3Mzg6IEZvcm1hdC5SRkMxNzM4LFxuICAgIFJGQzM5ODY6IEZvcm1hdC5SRkMzOTg2XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd1Byb3RvdHlwZXM6IGZhbHNlLFxuICAgIGFsbG93U3BhcnNlOiBmYWxzZSxcbiAgICBhcnJheUxpbWl0OiAyMCxcbiAgICBjaGFyc2V0OiAndXRmLTgnLFxuICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG4gICAgY29tbWE6IGZhbHNlLFxuICAgIGRlY29kZXI6IHV0aWxzLmRlY29kZSxcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBkZXB0aDogNSxcbiAgICBpZ25vcmVRdWVyeVByZWZpeDogZmFsc2UsXG4gICAgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzOiBmYWxzZSxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMCxcbiAgICBwYXJzZUFycmF5czogdHJ1ZSxcbiAgICBwbGFpbk9iamVjdHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBpbnRlcnByZXROdW1lcmljRW50aXRpZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIyhcXGQrKTsvZywgZnVuY3Rpb24gKCQwLCBudW1iZXJTdHIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobnVtYmVyU3RyLCAxMCkpO1xuICAgIH0pO1xufTtcblxudmFyIHBhcnNlQXJyYXlWYWx1ZSA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuY29tbWEgJiYgdmFsLmluZGV4T2YoJywnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB2YWwuc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyB3aGF0IGJyb3dzZXJzIHdpbGwgc3VibWl0IHdoZW4gdGhlIOKckyBjaGFyYWN0ZXIgb2NjdXJzIGluIGFuXG4vLyBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgYm9keSBhbmQgdGhlIGVuY29kaW5nIG9mIHRoZSBwYWdlIGNvbnRhaW5pbmdcbi8vIHRoZSBmb3JtIGlzIGlzby04ODU5LTEsIG9yIHdoZW4gdGhlIHN1Ym1pdHRlZCBmb3JtIGhhcyBhbiBhY2NlcHQtY2hhcnNldFxuLy8gYXR0cmlidXRlIG9mIGlzby04ODU5LTEuIFByZXN1bWFibHkgYWxzbyB3aXRoIG90aGVyIGNoYXJzZXRzIHRoYXQgZG8gbm90IGNvbnRhaW5cbi8vIHRoZSDinJMgY2hhcmFjdGVyLCBzdWNoIGFzIHVzLWFzY2lpLlxudmFyIGlzb1NlbnRpbmVsID0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0InOyAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JylcblxuLy8gVGhlc2UgYXJlIHRoZSBwZXJjZW50LWVuY29kZWQgdXRmLTggb2N0ZXRzIHJlcHJlc2VudGluZyBhIGNoZWNrbWFyaywgaW5kaWNhdGluZyB0aGF0IHRoZSByZXF1ZXN0IGFjdHVhbGx5IGlzIHV0Zi04IGVuY29kZWQuXG52YXIgY2hhcnNldFNlbnRpbmVsID0gJ3V0Zjg9JUUyJTlDJTkzJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuXG52YXIgcGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nVmFsdWVzKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgY2xlYW5TdHIgPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID8gc3RyLnJlcGxhY2UoL15cXD8vLCAnJykgOiBzdHI7XG4gICAgdmFyIGxpbWl0ID0gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0O1xuICAgIHZhciBwYXJ0cyA9IGNsZWFuU3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBsaW1pdCk7XG4gICAgdmFyIHNraXBJbmRleCA9IC0xOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXJlIHRoZSB1dGY4IHNlbnRpbmVsIHdhcyBmb3VuZFxuICAgIHZhciBpO1xuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQ7XG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJ3V0Zjg9JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gPT09IGNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ3V0Zi04JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldID09PSBpc29TZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ2lzby04ODU5LTEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGkgPSBwYXJ0cy5sZW5ndGg7IC8vIFRoZSBlc2xpbnQgc2V0dGluZ3MgZG8gbm90IGFsbG93IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpID09PSBza2lwSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG4gICAgICAgIHZhciBwb3MgPSBicmFja2V0RXF1YWxzUG9zID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogYnJhY2tldEVxdWFsc1BvcyArIDE7XG5cbiAgICAgICAgdmFyIGtleSwgdmFsO1xuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQsIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID8gbnVsbCA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UoMCwgcG9zKSwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuICAgICAgICAgICAgdmFsID0gdXRpbHMubWF5YmVNYXAoXG4gICAgICAgICAgICAgICAgcGFyc2VBcnJheVZhbHVlKHBhcnQuc2xpY2UocG9zICsgMSksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbmNvZGVkVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlY29kZXIoZW5jb2RlZFZhbCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgJiYgb3B0aW9ucy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgJiYgY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICB2YWwgPSBpbnRlcnByZXROdW1lcmljRW50aXRpZXModmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0LmluZGV4T2YoJ1tdPScpID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IGlzQXJyYXkodmFsKSA/IFt2YWxdIDogdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1dGlscy5jb21iaW5lKG9ialtrZXldLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIHZhciBsZWFmID0gdmFsdWVzUGFyc2VkID8gdmFsIDogcGFyc2VBcnJheVZhbHVlKHZhbCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJyAmJiBvcHRpb25zLnBhcnNlQXJyYXlzKSB7XG4gICAgICAgICAgICBvYmogPSBbXS5jb25jYXQobGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBhcnNlQXJyYXlzICYmIGNsZWFuUm9vdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB7IDA6IGxlYWYgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgICAgICYmIHJvb3QgIT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIFN0cmluZyhpbmRleCkgPT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIGluZGV4ID49IDBcbiAgICAgICAgICAgICAgICAmJiAob3B0aW9ucy5wYXJzZUFycmF5cyAmJiBpbmRleCA8PSBvcHRpb25zLmFycmF5TGltaXQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgICAgICBvYmpbaW5kZXhdID0gbGVhZjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xlYW5Sb290ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gbGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWYgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYWY7XG59O1xuXG52YXIgcGFyc2VLZXlzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ0tleXMoZ2l2ZW5LZXksIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKSB7XG4gICAgaWYgKCFnaXZlbktleSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhbnNmb3JtIGRvdCBub3RhdGlvbiB0byBicmFja2V0IG5vdGF0aW9uXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuYWxsb3dEb3RzID8gZ2l2ZW5LZXkucmVwbGFjZSgvXFwuKFteLltdKykvZywgJ1skMV0nKSA6IGdpdmVuS2V5O1xuXG4gICAgLy8gVGhlIHJlZ2V4IGNodW5rc1xuXG4gICAgdmFyIGJyYWNrZXRzID0gLyhcXFtbXltcXF1dKl0pLztcbiAgICB2YXIgY2hpbGQgPSAvKFxcW1teW1xcXV0qXSkvZztcblxuICAgIC8vIEdldCB0aGUgcGFyZW50XG5cbiAgICB2YXIgc2VnbWVudCA9IG9wdGlvbnMuZGVwdGggPiAwICYmIGJyYWNrZXRzLmV4ZWMoa2V5KTtcbiAgICB2YXIgcGFyZW50ID0gc2VnbWVudCA/IGtleS5zbGljZSgwLCBzZWdtZW50LmluZGV4KSA6IGtleTtcblxuICAgIC8vIFN0YXNoIHRoZSBwYXJlbnQgaWYgaXQgZXhpc3RzXG5cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIHBsYWluIG9iamVjdHMsIG9wdGlvbmFsbHkgcHJlZml4IGtleXMgdGhhdCB3b3VsZCBvdmVyd3JpdGUgb2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgcGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMucHVzaChwYXJlbnQpO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBjaGlsZHJlbiBhcHBlbmRpbmcgdG8gdGhlIGFycmF5IHVudGlsIHdlIGhpdCBkZXB0aFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChvcHRpb25zLmRlcHRoID4gMCAmJiAoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNlZ21lbnRbMV0uc2xpY2UoMSwgLTEpKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goc2VnbWVudFsxXSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHJlbWFpbmRlciwganVzdCBhZGQgd2hhdGV2ZXIgaXMgbGVmdFxuXG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAga2V5cy5wdXNoKCdbJyArIGtleS5zbGljZShzZWdtZW50LmluZGV4KSArICddJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KGtleXMsIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKTtcbn07XG5cbnZhciBub3JtYWxpemVQYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZGVjb2RlciAhPT0gbnVsbCAmJiBvcHRzLmRlY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0cy5kZWNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmNoYXJzZXQgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuY2hhcnNldCAhPT0gJ3V0Zi04JyAmJiBvcHRzLmNoYXJzZXQgIT09ICdpc28tODg1OS0xJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICB2YXIgY2hhcnNldCA9IHR5cGVvZiBvcHRzLmNoYXJzZXQgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuY2hhcnNldCA6IG9wdHMuY2hhcnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXG4gICAgICAgIGFsbG93UHJvdG90eXBlczogdHlwZW9mIG9wdHMuYWxsb3dQcm90b3R5cGVzID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93UHJvdG90eXBlcyA6IGRlZmF1bHRzLmFsbG93UHJvdG90eXBlcyxcbiAgICAgICAgYWxsb3dTcGFyc2U6IHR5cGVvZiBvcHRzLmFsbG93U3BhcnNlID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93U3BhcnNlIDogZGVmYXVsdHMuYWxsb3dTcGFyc2UsXG4gICAgICAgIGFycmF5TGltaXQ6IHR5cGVvZiBvcHRzLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0cy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdCxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBjb21tYTogdHlwZW9mIG9wdHMuY29tbWEgPT09ICdib29sZWFuJyA/IG9wdHMuY29tbWEgOiBkZWZhdWx0cy5jb21tYSxcbiAgICAgICAgZGVjb2RlcjogdHlwZW9mIG9wdHMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXIsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRzLmRlbGltaXRlcikgPyBvcHRzLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcixcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uLCBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgZGVwdGg6ICh0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ251bWJlcicgfHwgb3B0cy5kZXB0aCA9PT0gZmFsc2UpID8gK29wdHMuZGVwdGggOiBkZWZhdWx0cy5kZXB0aCxcbiAgICAgICAgaWdub3JlUXVlcnlQcmVmaXg6IG9wdHMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWUsXG4gICAgICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogdHlwZW9mIG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID09PSAnYm9vbGVhbicgPyBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA6IGRlZmF1bHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyxcbiAgICAgICAgcGFyYW1ldGVyTGltaXQ6IHR5cGVvZiBvcHRzLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdCxcbiAgICAgICAgcGFyc2VBcnJheXM6IG9wdHMucGFyc2VBcnJheXMgIT09IGZhbHNlLFxuICAgICAgICBwbGFpbk9iamVjdHM6IHR5cGVvZiBvcHRzLnBsYWluT2JqZWN0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5wbGFpbk9iamVjdHMgOiBkZWZhdWx0cy5wbGFpbk9iamVjdHMsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKTtcblxuICAgIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBwYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMsIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbG93U3BhcnNlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLmNvbXBhY3Qob2JqKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRTaWRlQ2hhbm5lbCA9IHJlcXVpcmUoJ3NpZGUtY2hhbm5lbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgfSxcbiAgICBjb21tYTogJ2NvbW1hJyxcbiAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKHByZWZpeCwga2V5KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSxcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdChwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgc3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0O1xudmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbnZhciBwdXNoVG9BcnJheSA9IGZ1bmN0aW9uIChhcnIsIHZhbHVlT3JBcnJheSkge1xuICAgIHB1c2guYXBwbHkoYXJyLCBpc0FycmF5KHZhbHVlT3JBcnJheSkgPyB2YWx1ZU9yQXJyYXkgOiBbdmFsdWVPckFycmF5XSk7XG59O1xuXG52YXIgdG9JU08gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGRlZmF1bHRGb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWRkUXVlcnlQcmVmaXg6IGZhbHNlLFxuICAgIGFsbG93RG90czogZmFsc2UsXG4gICAgY2hhcnNldDogJ3V0Zi04JyxcbiAgICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGVuY29kZTogdHJ1ZSxcbiAgICBlbmNvZGVyOiB1dGlscy5lbmNvZGUsXG4gICAgZW5jb2RlVmFsdWVzT25seTogZmFsc2UsXG4gICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0LFxuICAgIGZvcm1hdHRlcjogZm9ybWF0cy5mb3JtYXR0ZXJzW2RlZmF1bHRGb3JtYXRdLFxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBpbmRpY2VzOiBmYWxzZSxcbiAgICBzZXJpYWxpemVEYXRlOiBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoZGF0ZSk7XG4gICAgfSxcbiAgICBza2lwTnVsbHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBpc05vbk51bGxpc2hQcmltaXRpdmUgPSBmdW5jdGlvbiBpc05vbk51bGxpc2hQcmltaXRpdmUodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZydcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYm9vbGVhbidcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdzeW1ib2wnXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYmlnaW50Jztcbn07XG5cbnZhciBzZW50aW5lbCA9IHt9O1xuXG52YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KFxuICAgIG9iamVjdCxcbiAgICBwcmVmaXgsXG4gICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICBjb21tYVJvdW5kVHJpcCxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgc2tpcE51bGxzLFxuICAgIGVuY29kZXIsXG4gICAgZmlsdGVyLFxuICAgIHNvcnQsXG4gICAgYWxsb3dEb3RzLFxuICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgZm9ybWF0LFxuICAgIGZvcm1hdHRlcixcbiAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgIGNoYXJzZXQsXG4gICAgc2lkZUNoYW5uZWxcbikge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG5cbiAgICB2YXIgdG1wU2MgPSBzaWRlQ2hhbm5lbDtcbiAgICB2YXIgc3RlcCA9IDA7XG4gICAgdmFyIGZpbmRGbGFnID0gZmFsc2U7XG4gICAgd2hpbGUgKCh0bXBTYyA9IHRtcFNjLmdldChzZW50aW5lbCkpICE9PSB2b2lkIHVuZGVmaW5lZCAmJiAhZmluZEZsYWcpIHtcbiAgICAgICAgLy8gV2hlcmUgb2JqZWN0IGxhc3QgYXBwZWFyZWQgaW4gdGhlIHJlZiB0cmVlXG4gICAgICAgIHZhciBwb3MgPSB0bXBTYy5nZXQob2JqZWN0KTtcbiAgICAgICAgc3RlcCArPSAxO1xuICAgICAgICBpZiAodHlwZW9mIHBvcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT09IHN0ZXApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ3ljbGljIG9iamVjdCB2YWx1ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5kRmxhZyA9IHRydWU7IC8vIEJyZWFrIHdoaWxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0bXBTYy5nZXQoc2VudGluZWwpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3RlcCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmogPSBmaWx0ZXIocHJlZml4LCBvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvYmogPSBzZXJpYWxpemVEYXRlKG9iaik7XG4gICAgfSBlbHNlIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzQXJyYXkob2JqKSkge1xuICAgICAgICBvYmogPSB1dGlscy5tYXliZU1hcChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc3RyaWN0TnVsbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlciAmJiAhZW5jb2RlVmFsdWVzT25seSA/IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KSA6IHByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9ICcnO1xuICAgIH1cblxuICAgIGlmIChpc05vbk51bGxpc2hQcmltaXRpdmUob2JqKSB8fCB1dGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknLCBmb3JtYXQpO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgZW5jb2RlVmFsdWVzT25seSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXNBcnJheSA9IHNwbGl0LmNhbGwoU3RyaW5nKG9iaiksICcsJyk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlc0pvaW5lZCA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzSm9pbmVkICs9IChpID09PSAwID8gJycgOiAnLCcpICsgZm9ybWF0dGVyKGVuY29kZXIodmFsdWVzQXJyYXlbaV0sIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICd2YWx1ZScsIGZvcm1hdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAoY29tbWFSb3VuZFRyaXAgJiYgaXNBcnJheShvYmopICYmIHZhbHVlc0FycmF5Lmxlbmd0aCA9PT0gMSA/ICdbXScgOiAnJykgKyAnPScgKyB2YWx1ZXNKb2luZWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIoa2V5VmFsdWUpICsgJz0nICsgZm9ybWF0dGVyKGVuY29kZXIob2JqLCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAndmFsdWUnLCBmb3JtYXQpKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIocHJlZml4KSArICc9JyArIGZvcm1hdHRlcihTdHJpbmcob2JqKSldO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIHZhciBvYmpLZXlzO1xuICAgIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzQXJyYXkob2JqKSkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGpvaW4gZWxlbWVudHMgaW5cbiAgICAgICAgb2JqS2V5cyA9IFt7IHZhbHVlOiBvYmoubGVuZ3RoID4gMCA/IG9iai5qb2luKCcsJykgfHwgbnVsbCA6IHZvaWQgdW5kZWZpbmVkIH1dO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBvYmpLZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG4gICAgfVxuXG4gICAgdmFyIGFkanVzdGVkUHJlZml4ID0gY29tbWFSb3VuZFRyaXAgJiYgaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDEgPyBwcmVmaXggKyAnW10nIDogcHJlZml4O1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmpLZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2pdO1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5LnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGtleS52YWx1ZSA6IG9ialtrZXldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleVByZWZpeCA9IGlzQXJyYXkob2JqKVxuICAgICAgICAgICAgPyB0eXBlb2YgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2Z1bmN0aW9uJyA/IGdlbmVyYXRlQXJyYXlQcmVmaXgoYWRqdXN0ZWRQcmVmaXgsIGtleSkgOiBhZGp1c3RlZFByZWZpeFxuICAgICAgICAgICAgOiBhZGp1c3RlZFByZWZpeCArIChhbGxvd0RvdHMgPyAnLicgKyBrZXkgOiAnWycgKyBrZXkgKyAnXScpO1xuXG4gICAgICAgIHNpZGVDaGFubmVsLnNldChvYmplY3QsIHN0ZXApO1xuICAgICAgICB2YXIgdmFsdWVTaWRlQ2hhbm5lbCA9IGdldFNpZGVDaGFubmVsKCk7XG4gICAgICAgIHZhbHVlU2lkZUNoYW5uZWwuc2V0KHNlbnRpbmVsLCBzaWRlQ2hhbm5lbCk7XG4gICAgICAgIHB1c2hUb0FycmF5KHZhbHVlcywgc3RyaW5naWZ5KFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBrZXlQcmVmaXgsXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgY29tbWFSb3VuZFRyaXAsXG4gICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICBlbmNvZGVyLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgY2hhcnNldCxcbiAgICAgICAgICAgIHZhbHVlU2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbnZhciBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5lbmNvZGVyICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcnNldCA9IG9wdHMuY2hhcnNldCB8fCBkZWZhdWx0cy5jaGFyc2V0O1xuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5mb3JtYXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghaGFzLmNhbGwoZm9ybWF0cy5mb3JtYXR0ZXJzLCBvcHRzLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBvcHRzLmZvcm1hdDtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgdmFyIGZpbHRlciA9IGRlZmF1bHRzLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIG9wdHMuZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGlzQXJyYXkob3B0cy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdHMuZmlsdGVyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZFF1ZXJ5UHJlZml4OiB0eXBlb2Ygb3B0cy5hZGRRdWVyeVByZWZpeCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hZGRRdWVyeVByZWZpeCA6IGRlZmF1bHRzLmFkZFF1ZXJ5UHJlZml4LFxuICAgICAgICBhbGxvd0RvdHM6IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzLFxuICAgICAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgICAgICBjaGFyc2V0U2VudGluZWw6IHR5cGVvZiBvcHRzLmNoYXJzZXRTZW50aW5lbCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaGFyc2V0U2VudGluZWwgOiBkZWZhdWx0cy5jaGFyc2V0U2VudGluZWwsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmRlbGltaXRlciA6IG9wdHMuZGVsaW1pdGVyLFxuICAgICAgICBlbmNvZGU6IHR5cGVvZiBvcHRzLmVuY29kZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGUgOiBkZWZhdWx0cy5lbmNvZGUsXG4gICAgICAgIGVuY29kZXI6IHR5cGVvZiBvcHRzLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyLFxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5OiB0eXBlb2Ygb3B0cy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICAgICAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgc2tpcE51bGxzOiB0eXBlb2Ygb3B0cy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdHMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzLFxuICAgICAgICBzb3J0OiB0eXBlb2Ygb3B0cy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0cy5zb3J0IDogbnVsbCxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpO1xuXG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5hcnJheUZvcm1hdCBpbiBhcnJheVByZWZpeEdlbmVyYXRvcnMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmFycmF5Rm9ybWF0O1xuICAgIH0gZWxzZSBpZiAob3B0cyAmJiAnaW5kaWNlcycgaW4gb3B0cykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdHMuaW5kaWNlcyA/ICdpbmRpY2VzJyA6ICdyZXBlYXQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gJ2luZGljZXMnO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZUFycmF5UHJlZml4ID0gYXJyYXlQcmVmaXhHZW5lcmF0b3JzW2FycmF5Rm9ybWF0XTtcbiAgICBpZiAob3B0cyAmJiAnY29tbWFSb3VuZFRyaXAnIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMuY29tbWFSb3VuZFRyaXAgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgY29tbWFSb3VuZFRyaXBgIG11c3QgYmUgYSBib29sZWFuLCBvciBhYnNlbnQnKTtcbiAgICB9XG4gICAgdmFyIGNvbW1hUm91bmRUcmlwID0gZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBvcHRzICYmIG9wdHMuY29tbWFSb3VuZFRyaXA7XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5za2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hUb0FycmF5KGtleXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBvcHRpb25zLnNraXBOdWxscyxcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jb2RlID8gb3B0aW9ucy5lbmNvZGVyIDogbnVsbCxcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5zb3J0LFxuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd0RvdHMsXG4gICAgICAgICAgICBvcHRpb25zLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBvcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgb3B0aW9ucy5jaGFyc2V0LFxuICAgICAgICAgICAgc2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMuYWRkUXVlcnlQcmVmaXggPT09IHRydWUgPyAnPycgOiAnJztcblxuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKSwgdGhlIFwibnVtZXJpYyBlbnRpdHlcIiByZXByZXNlbnRhdGlvbiBvZiBhIGNoZWNrbWFya1xuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG4gICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JUUyJTlDJTkzJic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgaGV4VGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgYXJyYXkucHVzaCgnJScgKyAoKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpKS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59KCkpO1xuXG52YXIgY29tcGFjdFF1ZXVlID0gZnVuY3Rpb24gY29tcGFjdFF1ZXVlKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBhcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gYXJyYXlUb09iamVjdChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucyAmJiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgIC8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogMCAqL1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgJiYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSkgfHwgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFt0YXJnZXRdLmNvbmNhdChzb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBtZXJnZVRhcmdldCA9IHRhcmdldDtcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmICFpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgbWVyZ2VUYXJnZXQgPSBhcnJheVRvT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbCh0YXJnZXQsIGkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0YXJnZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW0gJiYgdHlwZW9mIHRhcmdldEl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IG1lcmdlKHRhcmdldEl0ZW0sIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaGFzLmNhbGwoYWNjLCBrZXkpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IG1lcmdlKGFjY1trZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbWVyZ2VUYXJnZXQpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnblNpbmdsZVNvdXJjZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB0YXJnZXQpO1xufTtcblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uIChzdHIsIGRlY29kZXIsIGNoYXJzZXQpIHtcbiAgICB2YXIgc3RyV2l0aG91dFBsdXMgPSBzdHIucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAvLyB1bmVzY2FwZSBuZXZlciB0aHJvd3MsIG5vIHRyeS4uLmNhdGNoIG5lZWRlZDpcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzLnJlcGxhY2UoLyVbMC05YS1mXXsyfS9naSwgdW5lc2NhcGUpO1xuICAgIH1cbiAgICAvLyB1dGYtOFxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyV2l0aG91dFBsdXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzO1xuICAgIH1cbn07XG5cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoc3RyLCBkZWZhdWx0RW5jb2RlciwgY2hhcnNldCwga2luZCwgZm9ybWF0KSB7XG4gICAgLy8gVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQnJpYW4gV2hpdGUgKG1zY2RleCkgZm9yIHRoZSBpby5qcyBjb3JlIHF1ZXJ5c3RyaW5nIGxpYnJhcnkuXG4gICAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSBzdHI7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyaW5nID0gU3RyaW5nKHN0cik7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyUyNiUyMycgKyBwYXJzZUludCgkMC5zbGljZSgyKSwgMTYpICsgJyUzQic7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICAgICAgfHwgKGZvcm1hdCA9PT0gZm9ybWF0cy5SRkMxNzM4ICYmIChjID09PSAweDI4IHx8IGMgPT09IDB4MjkpKSAvLyAoIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXQgKz0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyBoZXhUYWJsZVtjXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4RTAgfCAoYyA+PiAxMildICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzdHJpbmcuY2hhckNvZGVBdChpKSAmIDB4M0ZGKSk7XG4gICAgICAgIC8qIGVzbGludCBvcGVyYXRvci1saW5lYnJlYWs6IFsyLCBcImJlZm9yZVwiXSAqL1xuICAgICAgICBvdXQgKz0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn07XG5cbnZhciBtYXliZU1hcCA9IGZ1bmN0aW9uIG1heWJlTWFwKHZhbCwgZm4pIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbih2YWwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21iaW5lOiBjb21iaW5lLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtYXliZU1hcDogbWF5YmVNYXAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWluc3BlY3QnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG52YXIgJFdlYWtNYXAgPSBHZXRJbnRyaW5zaWMoJyVXZWFrTWFwJScsIHRydWUpO1xudmFyICRNYXAgPSBHZXRJbnRyaW5zaWMoJyVNYXAlJywgdHJ1ZSk7XG5cbnZhciAkd2Vha01hcEdldCA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuZ2V0JywgdHJ1ZSk7XG52YXIgJHdlYWtNYXBTZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xudmFyICR3ZWFrTWFwSGFzID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcbnZhciAkbWFwR2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xudmFyICRtYXBTZXQgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuc2V0JywgdHJ1ZSk7XG52YXIgJG1hcEhhcyA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gdHJhdmVyc2VzIHRoZSBsaXN0IHJldHVybmluZyB0aGUgbm9kZSBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICogZ2l2ZW4ga2V5LlxuICpcbiAqIFRoYXQgbm9kZSBpcyBhbHNvIG1vdmVkIHRvIHRoZSBoZWFkIG9mIHRoZSBsaXN0LCBzbyB0aGF0IGlmIGl0J3MgYWNjZXNzZWRcbiAqIGFnYWluIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHdob2xlIGxpc3QuIEJ5IGRvaW5nIHNvLCBhbGwgdGhlIHJlY2VudGx5XG4gKiB1c2VkIG5vZGVzIGNhbiBiZSBhY2Nlc3NlZCByZWxhdGl2ZWx5IHF1aWNrbHkuXG4gKi9cbnZhciBsaXN0R2V0Tm9kZSA9IGZ1bmN0aW9uIChsaXN0LCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRmb3IgKHZhciBwcmV2ID0gbGlzdCwgY3VycjsgKGN1cnIgPSBwcmV2Lm5leHQpICE9PSBudWxsOyBwcmV2ID0gY3Vycikge1xuXHRcdGlmIChjdXJyLmtleSA9PT0ga2V5KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBjdXJyLm5leHQ7XG5cdFx0XHRjdXJyLm5leHQgPSBsaXN0Lm5leHQ7XG5cdFx0XHRsaXN0Lm5leHQgPSBjdXJyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0XHRyZXR1cm4gY3Vycjtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBsaXN0R2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdHJldHVybiBub2RlICYmIG5vZGUudmFsdWU7XG59O1xudmFyIGxpc3RTZXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5LCB2YWx1ZSkge1xuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdGlmIChub2RlKSB7XG5cdFx0bm9kZS52YWx1ZSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFByZXBlbmQgdGhlIG5ldyBub2RlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3Rcblx0XHRvYmplY3RzLm5leHQgPSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHRcdGtleToga2V5LFxuXHRcdFx0bmV4dDogb2JqZWN0cy5uZXh0LFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxufTtcbnZhciBsaXN0SGFzID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHRyZXR1cm4gISFsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTaWRlQ2hhbm5lbCgpIHtcblx0dmFyICR3bTtcblx0dmFyICRtO1xuXHR2YXIgJG87XG5cdHZhciBjaGFubmVsID0ge1xuXHRcdGFzc2VydDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCFjaGFubmVsLmhhcyhrZXkpKSB7XG5cdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdTaWRlIGNoYW5uZWwgZG9lcyBub3QgY29udGFpbiAnICsgaW5zcGVjdChrZXkpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldDogZnVuY3Rpb24gKGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoJHdtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICR3ZWFrTWFwR2V0KCR3bSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICgkbSkge1xuXHRcdFx0XHRcdHJldHVybiAkbWFwR2V0KCRtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRyZXR1cm4gbGlzdEdldCgkbywga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGFzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoJHdtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICR3ZWFrTWFwSGFzKCR3bSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICgkbSkge1xuXHRcdFx0XHRcdHJldHVybiAkbWFwSGFzKCRtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRyZXR1cm4gbGlzdEhhcygkbywga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCEkd20pIHtcblx0XHRcdFx0XHQkd20gPSBuZXcgJFdlYWtNYXAoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkd2Vha01hcFNldCgkd20sIGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICghJG0pIHtcblx0XHRcdFx0XHQkbSA9IG5ldyAkTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JG1hcFNldCgkbSwga2V5LCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoISRvKSB7XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQgKiBJbml0aWFsaXplIHRoZSBsaW5rZWQgbGlzdCBhcyBhbiBlbXB0eSBub2RlLCBzbyB0aGF0IHdlIGRvbid0IGhhdmVcblx0XHRcdFx0XHQgKiB0byBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2YgdGhlIGZpcnN0IG5vZGU6IHdlIGNhbiBhbHdheXMgcmVmZXIgdG9cblx0XHRcdFx0XHQgKiBpdCBhcyAocHJldmlvdXMgbm9kZSkubmV4dCwgaW5zdGVhZCBvZiBzb21ldGhpbmcgbGlrZSAobGlzdCkuaGVhZFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdCRvID0geyBrZXk6IHt9LCBuZXh0OiBudWxsIH07XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdFNldCgkbywga2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gY2hhbm5lbDtcbn07XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIHYxIH0gZnJvbSAnLi92MS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJzsiLCIvKlxuICogQnJvd3Nlci1jb21wYXRpYmxlIEphdmFTY3JpcHQgTUQ1XG4gKlxuICogTW9kaWZpY2F0aW9uIG9mIEphdmFTY3JpcHQgTUQ1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvblxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgbGVuZ3RoMzIgPSBpbnB1dC5sZW5ndGggKiAzMjtcbiAgdmFyIGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICB2YXIgeCA9IGlucHV0W2kgPj4gNV0gPj4+IGkgJSAzMiAmIDB4ZmY7XG4gICAgdmFyIGhleCA9IHBhcnNlSW50KGhleFRhYi5jaGFyQXQoeCA+Pj4gNCAmIDB4MGYpICsgaGV4VGFiLmNoYXJBdCh4ICYgMHgwZiksIDE2KTtcbiAgICBvdXRwdXQucHVzaChoZXgpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG91dHB1dCBsZW5ndGggd2l0aCBwYWRkaW5nIGFuZCBiaXQgbGVuZ3RoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRPdXRwdXRMZW5ndGgoaW5wdXRMZW5ndGg4KSB7XG4gIHJldHVybiAoaW5wdXRMZW5ndGg4ICsgNjQgPj4+IDkgPDwgNCkgKyAxNCArIDE7XG59XG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdvcmRzVG9NZDUoeCwgbGVuKSB7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgbGVuICUgMzI7XG4gIHhbZ2V0T3V0cHV0TGVuZ3RoKGxlbikgLSAxXSA9IGxlbjtcbiAgdmFyIGEgPSAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gMjcxNzMzODc4O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XG4gIHZhciBvdXRwdXQgPSBuZXcgVWludDMyQXJyYXkoZ2V0T3V0cHV0TGVuZ3RoKGxlbmd0aDgpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xuICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dFtpIC8gOF0gJiAweGZmKSA8PCBpICUgMzI7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcbiAgdmFyIGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gbXN3IDw8IDE2IHwgbHN3ICYgMHhmZmZmO1xufVxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpdFJvdGF0ZUxlZnQobnVtLCBjbnQpIHtcbiAgcmV0dXJuIG51bSA8PCBjbnQgfCBudW0gPj4+IDMyIC0gY250O1xufVxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICByZXR1cm4gc2FmZUFkZChiaXRSb3RhdGVMZWZ0KHNhZmVBZGQoc2FmZUFkZChhLCBxKSwgc2FmZUFkZCh4LCB0KSksIHMpLCBiKTtcbn1cblxuZnVuY3Rpb24gbWQ1ZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBjIHwgfmIgJiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1Z2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBkIHwgYyAmIH5kLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZDU7IiwiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgdmFyIHY7XG4gIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7IiwiLy8gQWRhcHRlZCBmcm9tIENocmlzIFZlbmVzcycgU0hBMSBjb2RlIGF0XG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL3NoYTEuaHRtbFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxufVxuXG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgcmV0dXJuIHggPDwgbiB8IHggPj4+IDMyIC0gbjtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICB2YXIgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF07XG5cbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcbiAgICBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIHZhciBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIHZhciBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gIHZhciBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBOOyArK19pKSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW19pICogNjQgKyBqICogNF0gPDwgMjQgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAzXTtcbiAgICB9XG5cbiAgICBNW19pXSA9IGFycjtcbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgKytfaTIpIHtcbiAgICB2YXIgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW19pMl1bdF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3QgPSAxNjsgX3QgPCA4MDsgKytfdCkge1xuICAgICAgV1tfdF0gPSBST1RMKFdbX3QgLSAzXSBeIFdbX3QgLSA4XSBeIFdbX3QgLSAxNF0gXiBXW190IC0gMTZdLCAxKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IEhbMF07XG4gICAgdmFyIGIgPSBIWzFdO1xuICAgIHZhciBjID0gSFsyXTtcbiAgICB2YXIgZCA9IEhbM107XG4gICAgdmFyIGUgPSBIWzRdO1xuXG4gICAgZm9yICh2YXIgX3QyID0gMDsgX3QyIDwgODA7ICsrX3QyKSB7XG4gICAgICB2YXIgcyA9IE1hdGguZmxvb3IoX3QyIC8gMjApO1xuICAgICAgdmFyIFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1tfdDJdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IEhbMF0gKyBhID4+PiAwO1xuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcbiAgICBIWzJdID0gSFsyXSArIGMgPj4+IDA7XG4gICAgSFszXSA9IEhbM10gKyBkID4+PiAwO1xuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYTE7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJzsgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcblxudmFyIF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgbmV3IEFycmF5KDE2KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICB2YXIgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwOyAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfSAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG5cblxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfSAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG5cblxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTsgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG5cbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7IC8vIGB0aW1lX2xvd2BcblxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmOyAvLyBgdGltZV9taWRgXG5cbiAgdmFyIHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgc3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiLCJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xudmFyIHYzID0gdjM1KCd2MycsIDB4MzAsIG1kNSk7XG5leHBvcnQgZGVmYXVsdCB2MzsiLCJpbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmV4cG9ydCB2YXIgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgdmFyIFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59IiwiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgc2hhMSBmcm9tICcuL3NoYTEuanMnO1xudmFyIHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd3cyBkb2VzIG5vdCB3b3JrIGluIHRoZSBicm93c2VyLiBCcm93c2VyIGNsaWVudHMgbXVzdCB1c2UgdGhlIG5hdGl2ZSAnICtcbiAgICAgICdXZWJTb2NrZXQgb2JqZWN0J1xuICApO1xufTtcbiIsIi8qIChpZ25vcmVkKSAqLyIsInZhciB1dGlsO1xuKGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgICAgICAgIC5tYXAoKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBgJyR7dmFsfSdgIDogdmFsKSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbmNvbnN0IFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcInN0cmluZ1wiLFxuICAgIFwibmFuXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwicHJvbWlzZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm1hcFwiLFxuICAgIFwic2V0XCIsXG5dKTtcbmNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBpc05hTihkYXRhKSA/IFpvZFBhcnNlZFR5cGUubmFuIDogWm9kUGFyc2VkVHlwZS5udW1iZXI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5ib29sZWFuO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5iaWdpbnQ7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuXG5jb25zdCBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuXSk7XG5jb25zdCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gW107XG4gICAgICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZXMgPSAoc3VicyA9IFtdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3VlcywgLi4uc3Vic107XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gbmV3LnRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICAgIH1cbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG4gICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmlzc3VlcywgbnVsbCwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSA9IGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gICAgfVxuICAgIGdldCBmb3JtRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgfVxufVxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcbmNvbnN0IGRlZmF1bHRFcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCl9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkICR7aXNzdWUudmFsaWRhdGlvbn1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBtb3JlIHRoYW5gfSAke2lzc3VlLm1pbmltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgZ3JlYXRlciB0aGFuICR7aXNzdWUuaW5jbHVzaXZlID8gYG9yIGVxdWFsIHRvIGAgOiBgYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYHVuZGVyYH0gJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGxlc3MgdGhhbiAke2lzc3VlLmluY2x1c2l2ZSA/IGBvciBlcXVhbCB0byBgIDogYGB9JHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmN1c3RvbTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludGVyc2VjdGlvbiByZXN1bHRzIGNvdWxkIG5vdCBiZSBtZXJnZWRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLm11bHRpcGxlT2Z9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5sZXQgb3ZlcnJpZGVFcnJvck1hcCA9IGRlZmF1bHRFcnJvck1hcDtcbmNvbnN0IHNldEVycm9yTWFwID0gKG1hcCkgPT4ge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59O1xuXG5jb25zdCBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgsIC4uLihpc3N1ZURhdGEucGF0aCB8fCBbXSldO1xuICAgIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICB9O1xuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSB8fCBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5jb25zdCBFTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICAgICAgaXNzdWVEYXRhOiBpc3N1ZURhdGEsXG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgIG92ZXJyaWRlRXJyb3JNYXAsXG4gICAgICAgICAgICBkZWZhdWx0RXJyb3JNYXAsXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogYXdhaXQgcGFpci5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IHBhaXIudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkge1xuICAgICAgICAgICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gICAgfVxufVxuY29uc3QgSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmNvbnN0IERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG5jb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xuY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcbmNvbnN0IGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcbmNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbmNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IHVuZGVmaW5lZCAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcblxudmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcblxuY2xhc3MgUGFyc2VJbnB1dExhenlQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoLCBrZXkpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGguY29uY2F0KHRoaXMuX2tleSk7XG4gICAgfVxufVxuY29uc3QgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGlzVmFsaWQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghY3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvciB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkXCIgb3IgXCJyZXF1aXJlZFwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgICB9XG4gICAgaWYgKGVycm9yTWFwKVxuICAgICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAsIGRlc2NyaXB0aW9uIH07XG4gICAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgICAgIGlmIChpc3MuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIiAmJiByZXF1aXJlZF9lcnJvcilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHJlcXVpcmVkX2Vycm9yIH07XG4gICAgICAgIGlmIChwYXJhbXMuaW52YWxpZF90eXBlX2Vycm9yKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogcGFyYW1zLmludmFsaWRfdHlwZV9lcnJvciB9O1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuY2xhc3MgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgICAgIC8qKiBBbGlhcyBvZiBzYWZlUGFyc2VBc3luYyAqL1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XG4gICAgICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLl9yZWZpbmVtZW50O1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBfZ2V0VHlwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wYXJzZUFzeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBwYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdClcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgbnVsbGlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWwoKS5udWxsYWJsZSgpO1xuICAgIH1cbiAgICBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBvcihvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSk7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZyk7XG4gICAgfVxuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQoZGVmKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuY29uc3QgY3VpZFJlZ2V4ID0gL15jW15cXHMtXXs4LH0kL2k7XG5jb25zdCB1dWlkUmVnZXggPSAvXihbYS1mMC05XXs4fS1bYS1mMC05XXs0fS1bMS01XVthLWYwLTldezN9LVthLWYwLTldezR9LVthLWYwLTldezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oKFtePD4oKVtcXF1cXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChbXjw+KClbXFxdXFwuLDs6XFxzQFxcXCJdK1xcLikrW148PigpW1xcXVxcLiw7Olxcc0BcXFwiXXsyLH0pJC9pO1xuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3JlZ2V4ID0gKHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSA9PiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIHouc3RyaW5nKCkubWluKDEpIGluc3RlYWQuXG4gICAgICAgICAqIEBzZWUge0BsaW5rIFpvZFN0cmluZy5taW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbmVtcHR5ID0gKG1lc3NhZ2UpID0+IHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgICAgIHRoaXMudHJpbSA9ICgpID0+IG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1haWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbWFpbFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVybChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXVpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXVpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICByZWdleChyZWdleCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJyZWdleFwiLFxuICAgICAgICAgICAgcmVnZXg6IHJlZ2V4LFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heExlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKGxlbiwgbWVzc2FnZSkubWF4KGxlbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInV1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZFwiKTtcbiAgICB9XG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1pbiA9IC1JbmZpbml0eTtcbiAgICAgICAgdGhpcy5fZGVmLmNoZWNrcy5tYXAoKGNoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZi5jaGVja3MubWFwKChjaCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IHBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IHBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyBNYXRoLnBvdygxMCwgZGVjQ291bnQpO1xufVxuY2xhc3MgWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBpc0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIik7XG4gICAgfVxufVxuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYmlnaW50KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmRhdGUsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbn1cblpvZERhdGUuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVuZGVmaW5lZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS51bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuZGVmaW5lZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5kZWZpbmVkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGwoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RBbnkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gdG8gcHJldmVudCBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3NlcyBmcm9tIGV4dGVuZGluZyBab2RBbnkuIHRoaXMgY2F1c2VzIGlzc3VlcyB3aXRoIGNhdGNoYWxsIGluIFpvZE9iamVjdC5cbiAgICAgICAgdGhpcy5fYW55ID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RBbnkuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQW55KHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmtub3duIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuX3Vua25vd24gPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVua25vd24uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5rbm93bixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE5ldmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmV2ZXIsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG59XG5ab2ROZXZlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROZXZlcih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RWb2lkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnZvaWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVm9pZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RWb2lkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RWb2lkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQXJyYXkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHN0YXR1cyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1pbkxlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5taW5MZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjdHguZGF0YS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlQXN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY3R4LmRhdGEubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihsZW4sIG1lc3NhZ2UpLm1heChsZW4sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBcnJheSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2RPYmplY3QgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsXG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuY29uc3QgQXVnbWVudEZhY3RvcnkgPSAoZGVmKSA9PiAoYXVnbWVudGF0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAuLi5kZWYsXG4gICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgLi4uZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIH0pLFxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLnNoYXBlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHNjaGVtYS5zaGFwZVtrZXldO1xuICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShmaWVsZFNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIHRoaXMuYXVnbWVudCA9IEF1Z21lbnRGYWN0b3J5KHRoaXMuX2RlZik7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gQXVnbWVudEZhY3RvcnkodGhpcy5fZGVmKTtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIGlmICghc2hhcGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IHBhaXIudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpc3N1ZSwgY3R4KS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoX2QgPSBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgICAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcbiAgICAgICAgLy8gKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXMobWFzaykubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRvIHNoYXBlIGlmIGtleSBjb3JyZXNwb25kcyB0byBhbiBlbGVtZW50IG9mIHRoZSBjdXJyZW50IHNoYXBlXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFwZVtrZXldKVxuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbWl0KG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodXRpbC5vYmplY3RLZXlzKG1hc2spLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVlcFBhcnRpYWwoKSB7XG4gICAgICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgICB9XG4gICAgcGFydGlhbChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5vYmplY3RLZXlzKG1hc2spLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV0ub3B0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQoKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gbmV3RmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RPYmplY3QuY3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLnZhbGlkRGlzY3JpbWluYXRvclZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCB2YWxpZERpc2NyaW1pbmF0b3JWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMub3B0aW9ucy5rZXlzKCkpO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgICAqIEhvd2V2ZXIsIGl0IG9ubHkgYWxsb3dzIGEgdW5pb24gb2Ygb2JqZWN0cywgYWxsIG9mIHdoaWNoIG5lZWQgdG8gc2hhcmUgYSBkaXNjcmltaW5hdG9yIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IG11c3RcbiAgICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXG4gICAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gdHlwZXMgYW4gYXJyYXkgb2Ygb2JqZWN0IHNjaGVtYXNcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkaXNjcmltaW5hdG9yLCB0eXBlcywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0eXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gdHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXS52YWx1ZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldChkaXNjcmltaW5hdG9yVmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkaXNjcmltaW5hdG9yIHZhbHVlIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgdGhlIHByb3ZpZGVkIHNjaGVtYXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZXJ0IHRoYXQgYWxsIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlcyBhcmUgdW5pcXVlXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZSBvZiB0aGUgZGlzY3JpbWluYXRvciB2YWx1ZXMgYXJlIG5vdCB1bmlxdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICAgIGNvbnN0IGFUeXBlID0gZ2V0UGFyc2VkVHlwZShhKTtcbiAgICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICBjb25zdCBiS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhiKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWxcbiAgICAgICAgICAgIC5vYmplY3RLZXlzKGEpXG4gICAgICAgICAgICAuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmXG4gICAgICAgICthID09PSArYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgfVxufVxuY2xhc3MgWm9kSW50ZXJzZWN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZVBhcnNlZCA9IChwYXJzZWRMZWZ0LCBwYXJzZWRSaWdodCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEaXJ0eShwYXJzZWRMZWZ0KSB8fCBpc0RpcnR5KHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBtZXJnZWQuZGF0YSB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYubGVmdC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IGhhbmRsZVBhcnNlZChsZWZ0LCByaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pLCB0aGlzLl9kZWYucmlnaHQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RJbnRlcnNlY3Rpb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RUdXBsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBjdHguZGF0YVxuICAgICAgICAgICAgLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpdGVtSW5kZXgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+ICEheCk7IC8vIGZpbHRlciBudWxsc1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xuICAgIH1cbiAgICByZXN0KHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXN0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgY3R4LmRhdGFba2V5XSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcbiAgICAgICAgaWYgKHNlY29uZCBpbnN0YW5jZW9mIFpvZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgICAgICBrZXlUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGU6IHNlY29uZCxcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgIGtleVR5cGU6IFpvZFN0cmluZy5jcmVhdGUoKSxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogZmlyc3QsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMoc2Vjb25kKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kTWFwIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVTZXQoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRTZXQuYWRkKGVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBwYXJzZWRTZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbGVtZW50cykudGhlbigoZWxlbWVudHMpID0+IGZpbmFsaXplU2V0KGVsZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxpemVTZXQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1pbihtaW5TaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pblNpemU6IHsgdmFsdWU6IG1pblNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heFNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4U2l6ZTogeyB2YWx1ZTogbWF4U2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaXplKHNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBtaW5TaXplOiBudWxsLFxuICAgICAgICBtYXhTaXplOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFNldCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlQXJnc0lzc3VlKGFyZ3MsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gT0soYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IHRoaXMuX2RlZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbiguLi5wYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgdGhpcy5fZGVmLnJldHVybnMuX2RlZi50eXBlXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKHJlc3VsdCwgcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPSygoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSB0aGlzLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oLi4ucGFyc2VkQXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gdGhpcy5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxufVxuWm9kRnVuY3Rpb24uY3JlYXRlID0gKGFyZ3MsIHJldHVybnMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICBhcmdzOiAoYXJnc1xuICAgICAgICAgICAgPyBhcmdzLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSlcbiAgICAgICAgICAgIDogWm9kVHVwbGUuY3JlYXRlKFtdKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpKSxcbiAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTGF6eSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGxhenlTY2hlbWEuX3BhcnNlKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICB9XG59XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgICAgIGdldHRlcjogZ2V0dGVyLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuY2xhc3MgWm9kRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVmLnZhbHVlcy5pbmRleE9mKGlucHV0LmRhdGEpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxufVxuWm9kRW51bS5jcmVhdGUgPSBjcmVhdGVab2RFbnVtO1xuY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXRpdmVFbnVtVmFsdWVzLmluZGV4T2YoaW5wdXQuZGF0YSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbn1cblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFByb21pc2UgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmXG4gICAgICAgICAgICBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlXG4gICAgICAgICAgICA/IGN0eC5kYXRhXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGlubmVyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbigocHJvY2Vzc2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2NcbiAgICAgICAgICAgIC8vIGVmZmVjdDogUmVmaW5lbWVudEVmZmVjdDxhbnk+XG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYmFzZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYmFzZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIC8vICAgcmV0dXJuIHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlOiBiYXNlLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGJhc2Uuc3RhdHVzID09PSBcImFib3J0ZWRcIikgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChiYXNlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgcmV0dXJuIHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlOiBiYXNlLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KSkudGhlbigocmVzdWx0KSA9PiAoeyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICAgIH1cbn1cblpvZEVmZmVjdHMuY3JlYXRlID0gKHNjaGVtYSwgZWZmZWN0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgZWZmZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChwcmVwcm9jZXNzLCBzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kT3B0aW9uYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kT3B0aW9uYWwuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGVmYXVsdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2REZWZhdWx0LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNvbnN0IGN1c3RvbSA9IChjaGVjaywgcGFyYW1zID0ge30sIGZhdGFsKSA9PiB7XG4gICAgaWYgKGNoZWNrKVxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hlY2soZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGRhdGEpIDogcGFyYW1zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucDIsIGZhdGFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpO1xufTtcbmNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG52YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKGNscywgcGFyYW1zID0ge1xuICAgIG1lc3NhZ2U6IGBJbnB1dCBub3QgaW5zdGFuY2Ugb2YgJHtjbHMubmFtZX1gLFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMsIHRydWUpO1xuY29uc3Qgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XG5jb25zdCBudW1iZXJUeXBlID0gWm9kTnVtYmVyLmNyZWF0ZTtcbmNvbnN0IG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xuY29uc3QgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XG5jb25zdCBib29sZWFuVHlwZSA9IFpvZEJvb2xlYW4uY3JlYXRlO1xuY29uc3QgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuXG52YXIgbW9kID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXRQYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlLFxuICAgIFpvZFBhcnNlZFR5cGU6IFpvZFBhcnNlZFR5cGUsXG4gICAgbWFrZUlzc3VlOiBtYWtlSXNzdWUsXG4gICAgRU1QVFlfUEFUSDogRU1QVFlfUEFUSCxcbiAgICBhZGRJc3N1ZVRvQ29udGV4dDogYWRkSXNzdWVUb0NvbnRleHQsXG4gICAgUGFyc2VTdGF0dXM6IFBhcnNlU3RhdHVzLFxuICAgIElOVkFMSUQ6IElOVkFMSUQsXG4gICAgRElSVFk6IERJUlRZLFxuICAgIE9LOiBPSyxcbiAgICBpc0Fib3J0ZWQ6IGlzQWJvcnRlZCxcbiAgICBpc0RpcnR5OiBpc0RpcnR5LFxuICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgaXNBc3luYzogaXNBc3luYyxcbiAgICBab2RUeXBlOiBab2RUeXBlLFxuICAgIFpvZFN0cmluZzogWm9kU3RyaW5nLFxuICAgIFpvZE51bWJlcjogWm9kTnVtYmVyLFxuICAgIFpvZEJpZ0ludDogWm9kQmlnSW50LFxuICAgIFpvZEJvb2xlYW46IFpvZEJvb2xlYW4sXG4gICAgWm9kRGF0ZTogWm9kRGF0ZSxcbiAgICBab2RVbmRlZmluZWQ6IFpvZFVuZGVmaW5lZCxcbiAgICBab2ROdWxsOiBab2ROdWxsLFxuICAgIFpvZEFueTogWm9kQW55LFxuICAgIFpvZFVua25vd246IFpvZFVua25vd24sXG4gICAgWm9kTmV2ZXI6IFpvZE5ldmVyLFxuICAgIFpvZFZvaWQ6IFpvZFZvaWQsXG4gICAgWm9kQXJyYXk6IFpvZEFycmF5LFxuICAgIGdldCBvYmplY3RVdGlsICgpIHsgcmV0dXJuIG9iamVjdFV0aWw7IH0sXG4gICAgWm9kT2JqZWN0OiBab2RPYmplY3QsXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxuICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgIFpvZEludGVyc2VjdGlvbjogWm9kSW50ZXJzZWN0aW9uLFxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcbiAgICBab2RSZWNvcmQ6IFpvZFJlY29yZCxcbiAgICBab2RNYXA6IFpvZE1hcCxcbiAgICBab2RTZXQ6IFpvZFNldCxcbiAgICBab2RGdW5jdGlvbjogWm9kRnVuY3Rpb24sXG4gICAgWm9kTGF6eTogWm9kTGF6eSxcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxuICAgIFpvZEVudW06IFpvZEVudW0sXG4gICAgWm9kTmF0aXZlRW51bTogWm9kTmF0aXZlRW51bSxcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxuICAgIFpvZEVmZmVjdHM6IFpvZEVmZmVjdHMsXG4gICAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxuICAgIFpvZE51bGxhYmxlOiBab2ROdWxsYWJsZSxcbiAgICBab2REZWZhdWx0OiBab2REZWZhdWx0LFxuICAgIFpvZE5hTjogWm9kTmFOLFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIFNjaGVtYTogWm9kVHlwZSxcbiAgICBab2RTY2hlbWE6IFpvZFR5cGUsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcbiAgICBhbnk6IGFueVR5cGUsXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcbiAgICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXG4gICAgZGF0ZTogZGF0ZVR5cGUsXG4gICAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcbiAgICAnZnVuY3Rpb24nOiBmdW5jdGlvblR5cGUsXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gICAgbGF6eTogbGF6eVR5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXG4gICAgbWFwOiBtYXBUeXBlLFxuICAgIG5hbjogbmFuVHlwZSxcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxuICAgICdudWxsJzogbnVsbFR5cGUsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFR5cGUsXG4gICAgb3N0cmluZzogb3N0cmluZyxcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcbiAgICBwcm9taXNlOiBwcm9taXNlVHlwZSxcbiAgICByZWNvcmQ6IHJlY29yZFR5cGUsXG4gICAgc2V0OiBzZXRUeXBlLFxuICAgIHN0cmljdE9iamVjdDogc3RyaWN0T2JqZWN0VHlwZSxcbiAgICBzdHJpbmc6IHN0cmluZ1R5cGUsXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXG4gICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZFR5cGUsXG4gICAgdW5pb246IHVuaW9uVHlwZSxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgICAndm9pZCc6IHZvaWRUeXBlLFxuICAgIFpvZElzc3VlQ29kZTogWm9kSXNzdWVDb2RlLFxuICAgIHF1b3RlbGVzc0pzb246IHF1b3RlbGVzc0pzb24sXG4gICAgWm9kRXJyb3I6IFpvZEVycm9yLFxuICAgIGRlZmF1bHRFcnJvck1hcDogZGVmYXVsdEVycm9yTWFwLFxuICAgIGdldCBvdmVycmlkZUVycm9yTWFwICgpIHsgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7IH0sXG4gICAgc2V0RXJyb3JNYXA6IHNldEVycm9yTWFwXG59KTtcblxuZXhwb3J0IHsgRElSVFksIEVNUFRZX1BBVEgsIElOVkFMSUQsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kRGF0ZSwgWm9kRGVmYXVsdCwgWm9kRGlzY3JpbWluYXRlZFVuaW9uLCBab2RFZmZlY3RzLCBab2RFbnVtLCBab2RFcnJvciwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLCBab2RGdW5jdGlvbiwgWm9kSW50ZXJzZWN0aW9uLCBab2RJc3N1ZUNvZGUsIFpvZExhenksIFpvZExpdGVyYWwsIFpvZE1hcCwgWm9kTmFOLCBab2ROYXRpdmVFbnVtLCBab2ROZXZlciwgWm9kTnVsbCwgWm9kTnVsbGFibGUsIFpvZE51bWJlciwgWm9kT2JqZWN0LCBab2RPcHRpb25hbCwgWm9kUGFyc2VkVHlwZSwgWm9kUHJvbWlzZSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZEVmZmVjdHMgYXMgWm9kVHJhbnNmb3JtZXIsIFpvZFR1cGxlLCBab2RUeXBlLCBab2RVbmRlZmluZWQsIFpvZFVuaW9uLCBab2RVbmtub3duLCBab2RWb2lkLCBhZGRJc3N1ZVRvQ29udGV4dCwgYW55VHlwZSBhcyBhbnksIGFycmF5VHlwZSBhcyBhcnJheSwgYmlnSW50VHlwZSBhcyBiaWdpbnQsIGJvb2xlYW5UeXBlIGFzIGJvb2xlYW4sIGN1c3RvbSwgZGF0ZVR5cGUgYXMgZGF0ZSwgbW9kIGFzIGRlZmF1bHQsIGRlZmF1bHRFcnJvck1hcCwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgb3ZlcnJpZGVFcnJvck1hcCwgcHJlcHJvY2Vzc1R5cGUgYXMgcHJlcHJvY2VzcywgcHJvbWlzZVR5cGUgYXMgcHJvbWlzZSwgcXVvdGVsZXNzSnNvbiwgcmVjb3JkVHlwZSBhcyByZWNvcmQsIHNldFR5cGUgYXMgc2V0LCBzZXRFcnJvck1hcCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB2b2lkVHlwZSBhcyB2b2lkLCBtb2QgYXMgeiB9O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiRHJvcGRvd24iLCJvcHRpb25zIiwic2VsZWN0ZWRPcHRpb24iLCJzZXRTZWxlY3RlZE9wdGlvbiIsImlzT3BlbiIsInNldE9wZW4iLCJkcm9wZG93biIsInRvZ2dsZURyb3Bkb3duIiwiaGFuZGxlSXRlbUNsaWNrIiwiY3VycmVuY3kiLCJoYW5kbGVDbGlja091dHNpZGUiLCJldmVudCIsImN1cnJlbnQiLCJjb250YWlucyIsInRhcmdldCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmaW5kIiwib3B0aW9uIiwibWFwIiwiaXRlbSIsImluZGV4IiwiZSIsIkZyYWdtZW50IiwiQnV0dG9uIiwiSW1hZ2VzVXBsb2FkIiwic2V0RmlsZUZpZWxkcyIsImZpbGVzUHJldmlld0FycmF5Iiwic2V0RmlsZXNQcmV2aWV3QXJyYXkiLCJmaWxlVXBsb2FkRmllbGQiLCJoYW5kbGVGaWxlc0ZpZWxkIiwiZmlsZXNMaXN0IiwiZmlsZXMiLCJ0ZW1wQXJyYXkiLCJpIiwibGVuZ3RoIiwicHVzaCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInVybCIsImNsaWNrIiwiY3VycmVuY2llcyIsImNvbnRyYWN0IiwiZGVjaW1hbHMiLCJ1c2VDb250ZXh0IiwiTW9kYWwiLCJBdXRoQ29udGV4dCIsIldhbGxldENvbnRleHQiLCJzdGFydEVzY3JvdyIsImZpbGxFc2Nyb3ciLCJmZXRjaEVzY3Jvd3MiLCJ1c2VyMk5lZ28iLCJzdGFydFB1cmNoYXNlIiwibmVnb1B1cmNoYXNlIiwidXNlTmF2aWdhdGUiLCJQdXJjaGFzZUl0ZW0iLCJuYXZpZ2F0ZSIsImN0eCIsIndhbGxldEN0eCIsInN1Y2Nlc3NQb3B1cCIsInNldFN1Y2Nlc3NQb3B1cCIsImVycm9yIiwic2V0RXJyb3IiLCJzdWNjZXNzIiwic2V0U3VjY2VzcyIsImNoZWNrRXJyb3IiLCJzZXRDaGVja0Vycm9yIiwibG9hZGluZyIsInNldExvYWRpbmciLCJmaWxlRmllbGRzIiwiYW1vdW50RXJyb3IiLCJzZXRBbW91bnRFcnJvciIsImNsb3NlU3VjY2Vzc1BvcHVwIiwidGl0bGUiLCJzZXRUaXRsZSIsImRlc2NyaXB0aW9uIiwic2V0RGVzY3JpcHRpb24iLCJhbW91bnQiLCJzZXRBbW91bnQiLCJ0b2tlbiIsInNldFRva2VuIiwidG9rZW5zIiwic2V0VG9rZW5zIiwiYmFsYW5jZXMiLCJ0cmFuc2ZlckRhdGUiLCJzZXRUcmFuc2ZlckRhdGUiLCJzZWxsZXJOYW1lIiwic2V0U2VsbGVyTmFtZSIsImNoZWNrRXhjaGFuZ2UiLCJzZXRDaGVja0V4Y2hhbmdlIiwiaGFuZGxlUHVyY2hhc2VGb3JtU3VibWl0IiwicHJldmVudERlZmF1bHQiLCJ2YWxpZGF0ZVRyYW5zYWN0aW9uRm9ybSIsImhhbmRlbEV4Y2hhbmdlIiwicGFyc2VGbG9hdCIsInNsZWVwIiwibWlsbGlzZWNvbmRzIiwiZGF0ZSIsIkRhdGUiLCJub3ciLCJjdXJyZW50RGF0ZSIsImF1dGhvcml6YXRpb24iLCJhY3RvciIsImF1dGgiLCJwZXJtaXNzaW9uIiwiZGVsaXZlclR5cGUiLCJ0eXBlSWQiLCJ0cmFkZVRvVG9rZW4iLCJ0cmFkZVRvQW1vdW50IiwiZXhwaXJ5Iiwic2Vzc2lvbiIsImVzY3Jvd3MiLCJteUVzY3Jvd3MiLCJmaWx0ZXIiLCJlc2Nyb3ciLCJmcm9tIiwibG9vcElkIiwiZXNjcm93SWQiLCJpZCIsInRvU3RyaW5nIiwiY29uc29sZSIsImxvZyIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJOdW1iZXIiLCJmaWxlIiwidmFsdWUiLCJjaGVja2VkIiwiaXNMb2dnZWRJbiIsInByb3RvbkNvbm5lY3Rpb24iLCJBcGlDbGFzcyIsImF4aW9zIiwiY3VycmVudF9uZXR3b3JrIiwidHJhbnNhY3QiLCJhcGkiLCJjaGFpbiIsImZlZUNvbnRyYWN0IiwiZmVlUXVhbnRpdHkiLCJmZXRjaEVzY3Jvd0FsbCIsInJwYyIsImdldF90YWJsZV9yb3dzIiwiY29kZSIsInNjb3BlIiwidGFibGUiLCJpbmRleF9wb3NpdGlvbiIsImtleV90eXBlIiwibGltaXQiLCJyb3dzIiwiYWNjb3VudE5hbWUiLCJsb3dlcl9ib3VuZCIsInVwcGVyX2JvdW5kIiwidG8iLCJmcm9tVG9rZW4iLCJ0b1Rva2VuIiwiZnJvbUFtb3VudCIsInRvQW1vdW50IiwiYW1vdW50SW4iLCJ0b0ZpeGVkIiwiZnJvbVF1YW50aXR5IiwiYWN0aW9ucyIsImFtb3VudE91dCIsInRvUXVhbnRpdHkiLCJhY2NvdW50IiwibmFtZSIsImRhdGEiLCJxdWFudGl0eSIsIm1lbW8iLCJmcm9tVG9rZW5zIiwiZnJvbU5mdHMiLCJ0b1Rva2VucyIsInRvTmZ0cyIsIk1hdGgiLCJmbG9vciIsInRyYW5zYWN0aW9uIiwiY29udHJhY3RhdXRoIiwicmVzdWx0IiwiY2FuY2VsRXNjcm93IiwidGFibGVyb3dzIiwicHJvdG9ucm93cyIsIk9iamVjdCIsImtleXMiLCJvYmoiLCJuZXdkYXRldGVubWludXRlcyIsImRpZmZlcmVuY2UiLCJnZXRNaW51dGVzIiwic2V0TWludXRlcyIsInRpbWVzdGFtcCIsImdpZnRyZXNwb25zZWNhbGwiLCJnaWZ0cmVzcG9uc2UiLCJyZXMiLCJlc2Nyb3dfaWQiLCJ0eXBlX2lkIiwiZGF0YXMiLCJKU09OIiwic3RyaW5naWZ5IiwibWV0aG9kIiwiY29uZmlnIiwiaGVhZGVycyIsInRoZW4iLCJyZXNwb25zZSIsIkpzb25ScGMiLCJBcGkiLCJKc1NpZ25hdHVyZVByb3ZpZGVyIiwiZmV0Y2giLCJlbmRwb2ludCIsInNpZ25hdHVyZVByb3ZpZGVyIiwiYmxvY2tzQmVoaW5kIiwiZXhwaXJlU2Vjb25kcyJdLCJzb3VyY2VSb290IjoiIn0=