(self["webpackChunk"] = self["webpackChunk"] || []).push([["resources_js_components_Transactions_ExchangeAction_js"],{

/***/ "./node_modules/@bloks/constants/dist/constants.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bloks/constants/dist/constants.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ANCHOR": () => (/* binding */ ANCHOR),
/* harmony export */   "CLEOS": () => (/* binding */ CLEOS),
/* harmony export */   "CLIO": () => (/* binding */ CLIO),
/* harmony export */   "Constants": () => (/* binding */ Constants),
/* harmony export */   "DEFAULT_CHAIN": () => (/* binding */ DEFAULT_CHAIN),
/* harmony export */   "DEFAULT_SYMBOL": () => (/* binding */ DEFAULT_SYMBOL),
/* harmony export */   "DEFAULT_SYSTEM_DOMAIN": () => (/* binding */ DEFAULT_SYSTEM_DOMAIN),
/* harmony export */   "EOSAUTH": () => (/* binding */ EOSAUTH),
/* harmony export */   "EOSC": () => (/* binding */ EOSC),
/* harmony export */   "KEYCAT": () => (/* binding */ KEYCAT),
/* harmony export */   "LEDGER": () => (/* binding */ LEDGER),
/* harmony export */   "LEDGER_BLE": () => (/* binding */ LEDGER_BLE),
/* harmony export */   "LEDGER_USB": () => (/* binding */ LEDGER_USB),
/* harmony export */   "LEDGER_WEBHID": () => (/* binding */ LEDGER_WEBHID),
/* harmony export */   "LEDGER_WEBUSB": () => (/* binding */ LEDGER_WEBUSB),
/* harmony export */   "LYNX": () => (/* binding */ LYNX),
/* harmony export */   "PROTON": () => (/* binding */ PROTON),
/* harmony export */   "PROTON_WEB": () => (/* binding */ PROTON_WEB),
/* harmony export */   "SCATTER_DESKTOP": () => (/* binding */ SCATTER_DESKTOP),
/* harmony export */   "SCATTER_DESKTOP_MANUAL": () => (/* binding */ SCATTER_DESKTOP_MANUAL),
/* harmony export */   "SCATTER_EXTENSION": () => (/* binding */ SCATTER_EXTENSION),
/* harmony export */   "SIMPLEOS": () => (/* binding */ SIMPLEOS),
/* harmony export */   "SQRL": () => (/* binding */ SQRL),
/* harmony export */   "TREZOR": () => (/* binding */ TREZOR),
/* harmony export */   "WAX_CLOUD_WALLET": () => (/* binding */ WAX_CLOUD_WALLET),
/* harmony export */   "WOMBAT": () => (/* binding */ WOMBAT),
/* harmony export */   "chainInfo": () => (/* binding */ chainInfo),
/* harmony export */   "chainToNetworkConstantsMap": () => (/* binding */ chainToNetworkConstantsMap),
/* harmony export */   "constants": () => (/* binding */ constants$c),
/* harmony export */   "dapps": () => (/* binding */ dapps),
/* harmony export */   "exchanges": () => (/* binding */ exchanges),
/* harmony export */   "getContractConstants": () => (/* binding */ getContractConstants),
/* harmony export */   "historyTypesFeatures": () => (/* binding */ historyTypesFeatures)
/* harmony export */ });
var DEFAULT_SYMBOL = 'EOS';
var DEFAULT_SYSTEM_DOMAIN = 'eosio';
var DEFAULT_CHAIN = 'eos';

var getContractConstants = function getContractConstants(chain, systemDomain) {
  if (chain === void 0) {
    chain = DEFAULT_CHAIN;
  }

  if (systemDomain === void 0) {
    systemDomain = DEFAULT_SYSTEM_DOMAIN;
  }

  // Proxy Information Account
  var proxyInfo;

  if (['eos', 'bos', 'wax'].includes(chain)) {
    proxyInfo = 'regproxyinfo';
  } else if (chain === 'telos') {
    proxyInfo = 'tlsproxyinfo';
  }

  return {
    // Accounts
    EOSIO: systemDomain,
    EOSIO_TOKEN: !['fio', 'fio-test'].includes(chain) ? systemDomain + ".token" : 'fio.token',
    ACCOUNT_INFO: 'account.info',
    PROXY_INFO_ACCOUNT: proxyInfo,
    EOSIO_MSIG: systemDomain + ".msig",
    EOSIO_RAM: systemDomain + ".ram",
    EOSIO_STAKE: systemDomain + ".stake",
    EOSIO_PRODS: systemDomain + ".prods",
    EOSIO_NULL: systemDomain + ".null",
    EOSIO_RAMFEE: systemDomain + ".ramfee",
    EOSIO_VPAY: systemDomain + ".vpay",
    EOSIO_BPAY: systemDomain + ".bpay",
    EOSIO_REX: systemDomain + ".rex",
    // Params
    NEWACCOUNT_NAME_PARAM: chain.indexOf('bos') === -1 ? 'name' : 'newact',
    // Tables
    EOSIO_MSIG_APPROVALS_TABLE: 'approvals2',
    EOSIO_MSIG_PROPOSALS_TABLE: 'proposal',
    // Actions
    TRANSFER_ACTION: 'transfer',
    DELEGATE_BW_ACTION: 'delegatebw',
    UNDELEGATE_BW_ACTION: 'undelegatebw',
    VOTE_PRODUCER_ACTION: 'voteproducer',
    BUY_RAM_ACTION: 'buyram',
    BUY_RAM_BYTES_ACTION: 'buyrambyes',
    SELL_RAM_ACTION: 'sellram'
  };
};

var dapps = [{
  name: 'Alcor.exchange',
  description: 'The first self-listing DEX. With Alcor you can trade any EOS.IO tokens for system EOS tokens, atomically, without the participation of third parties! Create markets in one click, list your dapp token for one click, trade whatever you want.',
  shortDescription: 'The first self-listing DEX. With Alcor you can trade any EOS.IO tokens for system EOS tokens.',
  symbol: '',
  statistics: true,
  accounts: ['eostokensdex'],
  logo: 'https://i.ibb.co/dKDYDMc/vectorpaint.png',
  website: 'https://alcor.exchange/',
  app: 'https://alcor.exchange/',
  telegram: 'https://t.me/alcorexchange',
  medium: 'https://medium.com/@avral',
  twitter: 'https://twitter.com/avral_pro',
  github: 'https://github.com/avral/alcor-ui',
  chains: ['eos', 'wax', 'telos']
}, {
  name: 'SX',
  description: 'Building secure & reliable financial blockchain instruments',
  shortDescription: 'DeFi Swap & Flashloan',
  symbol: 'SX',
  accounts: ['swap.sx', 'vigor.sx', 'stable.sx', 'flash.sx', 'push.sx', 'network.sx', 'registry.sx', 'miner.sx', 'cross.sx', 'nav.sx', 'fee.sx', 'trade.sx', 'vaults.sx', 'proxy.sx', 'dust.sx', 'curve.sx'],
  logo: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/sx.png',
  website: 'https://github.com/stableex',
  app: 'https://xnation.io',
  telegram: 'https://t.me/xnationio',
  medium: '',
  twitter: '',
  github: 'https://github.com/stableex',
  chains: ['eos']
}, {
  name: 'EOSNameService',
  description: 'EOS Name Service is the most comprehensive platform to register premium/base EOS/WAX account names.',
  shortDescription: 'EOS/WAX Name Service',
  symbol: '',
  partner: false,
  accounts: ['names'],
  logo: 'https://avatars1.githubusercontent.com/u/73891041',
  website: 'http://eosnameservice.io',
  app: 'http://eosnameservice.io',
  telegram: 'https://t.me/eosnameservice',
  medium: '',
  twitter: 'https://twitter.com/eosnameservice',
  github: 'https://github.com/eosnameservice',
  chains: ['eos', 'wax']
}, {
  name: 'Prospectors',
  description: 'Massive Multiplayer Online Real-Time Economic Strategy Game  MINE GOLD - BUILD YOUR WORLD',
  shortDescription: 'Massive Multiplayer Online Real-Time Economic Strategy Game',
  symbol: '',
  accounts: ['prospectorsc'],
  logo: 'https://bloks.io/img/dapps/prospectors.png',
  website: 'https://prospectors.io',
  app: 'https://prospectors.io',
  telegram: 'https://t.me/prospectorsgame',
  medium: 'https://medium.com/@prospectorsgame',
  twitter: 'https://twitter.com/prospectorsgame',
  github: 'https://github.com/prospectors/public/issues',
  chains: ['eos']
}, {
  name: 'APPICS',
  description: 'APPICS is the most engaged social media dApp that makes it easy to get rewarded with cryptocurrency for your social media activity like creating & curating content. The mobile interface is intuitive to use without any prior blockchain knowledge. Get rewarded for your passion!',
  shortDescription: 'APPICS is the most engaged social media dApp - earn APX Tokens for posting, commenting, and up-voting photos & videos!',
  symbol: 'APX',
  statistics: true,
  accounts: ['appicsappics'],
  logo: 'https://i.imgur.com/Ts9CNN5.png',
  website: 'https://appics.com',
  app: 'https://appics.com',
  telegram: 'https://t.me/appics_official',
  medium: 'https://medium.com/@appics',
  twitter: 'https://twitter.com/appics_official',
  github: 'https://github.com/phenom-company/appics_eos_token',
  chains: ['eos']
}, {
  name: 'Boid',
  description: 'Contribute your excess computing resources towards important causes while earning rewards. Join a team and rank up on the social leaderboards.',
  shortDescription: 'The Social Supercomputer. Contribute your excess computing resources towards important causes.',
  symbol: '',
  accounts: ['boidcomtoken', 'boidcompower', 'boidcommint1', 'boidcompromo'],
  logo: 'https://raw.githubusercontent.com/boid-com/assets/master/boidLogo-lg.png',
  website: 'https://boid.com',
  app: 'https://app.boid.com',
  telegram: 'https://t.me/Boidcom_official',
  medium: 'https://medium.com/@boidcom',
  twitter: 'https://twitter.com/boidcom',
  github: 'https://github.com/boid-com',
  chains: ['eos']
}, {
  name: 'The Billionaire Token',
  description: 'Most other coins or tokens have some sort of mining system. Billionaire Token has the exact opposite: It features a deflationary mechanism that destroys 30% of the gambled coins. Thus the tokens become more and more rare as more and more people gamble.',
  shortDescription: 'Billionaire Token has the opposite of a mining system: It features a deflationary mechanism that destroys 30% of the gambled coins.',
  symbol: 'XBL',
  accounts: ['billionairet', 'billionraffl', 'billionburnr', 'billionbot11', 'billionbot12', 'billionbot13', 'billionbot14'],
  app: 'https://BillionaireToken.com/',
  logo: 'https://BillionaireToken.com/images/logo_big.png',
  website: 'https://BillionaireToken.com/',
  telegram: 'https://t.me/BillionaireToken',
  medium: 'https://medium.com/@billionaire_3373',
  twitter: 'https://twitter.com/BillionaireTkn',
  github: 'https://github.com/BillionaireToken',
  chains: ['eos']
}, {
  name: 'Crypto Sword & Magic',
  description: 'Crypto Sword & Magic is the first blockbuster RPG on EOS blockchain, traditional turn-based RPG raising heroes to challenge new dungeons. Game assets are recorded on Blockchain and transactions run on smart contracts',
  shortDescription: 'Crypto Sword & Magic is the first blockbuster RPG on EOS blockchain.',
  symbol: 'CSM',
  accounts: ['swordnmagicm'],
  app: 'https://www.cryptoswordandmagic.com',
  logo: 'https://bloks.io/img/dapps/cryptosnm.png',
  website: 'https://www.cryptoswordandmagic.com',
  telegram: 'https://t.me/cryptosnm_comm_en',
  medium: 'https://medium.com/@cryptoswordandmagic',
  twitter: 'https://twitter.com/sword_and_magic',
  github: '',
  chains: ['eos']
}, {
  name: 'dmail',
  description: 'Welcome to dmail Beta! We are so excited to have you participate as we launch our Beta platform. In the early stages we are covering the simplest of functionality, which is sending and receiving messages. In the very near future, we will be adding a bunch of new features which we know the community is going to ask for.',
  shortDescription: 'dmail is the first decentralized email on the blockchain',
  symbol: 'MAIL',
  statistics: true,
  accounts: ['dmaildotcobp'],
  logo: 'https://www.dmail.co/logosym_256.png',
  website: 'https://dmail.co',
  app: '',
  telegram: 'https://t.me/dmailcommunity',
  medium: 'https://medium.com/@dmail',
  twitter: 'https://twitter.com/dmaildotco',
  github: '',
  chains: ['eos', 'telos']
}, {
  name: 'Murmur',
  description: 'Murmur is a new age decentralized microblogging platform on EOS that is censorship-resistant, spam-proof and rewarding to use.',
  shortDescription: 'Murmur is a new age decentralized microblogging platform on EOS that is censorship-resistant, spam-proof and rewarding to use.',
  symbol: 'MUR',
  partner: true,
  accounts: ['murmurdappco', 'murmurtokens', 'murmurfreeac'],
  app: 'https://play.google.com/store/apps/details?id=com.murmurdapp',
  logo: 'https://bloks.io/img/dapps/murmur.png',
  website: 'http://murmurdapp.com',
  telegram: 'http://t.me/murmurdapp',
  medium: '',
  twitter: 'http://twitter.com/murmurdapp',
  github: '',
  chains: ['eos']
}, {
  name: 'Emanate',
  description: 'Emanate is EOS for the music industry. An automated, realtime music collaboration and monetisation platform.',
  shortDescription: 'Emanate is decentralised technology for the future of music',
  symbol: 'EMT',
  partner: true,
  accounts: ['emanateoneos', 'emanateissue'],
  app: 'https://emanate.live/',
  logo: 'https://bloks.io/img/dapps/emanate.png',
  website: 'https://emanate.live',
  telegram: 'https://t.me/emanateofficial',
  medium: '',
  twitter: 'https://twitter.com/emanateofficial',
  github: '',
  chains: ['eos']
}, {
  name: 'pixEOS',
  description: 'pixEOS is the first tokenized smart economy for gamers, artists and art enthusiasts.',
  shortDescription: 'pixEOS is the first tokenized smart economy for gamers, artists and art enthusiasts.',
  symbol: 'PIXEOS',
  partner: true,
  accounts: ['pixeos1token', 'pixeos1admin', 'pixeos1start'],
  app: 'https://pixeos.io',
  logo: 'https://bloks.io/img/dapps/pixeos.png',
  website: 'https://pixeos.io',
  telegram: 'https://t.me/PIXEOS',
  medium: '',
  twitter: 'https://twitter.com/eos_pix',
  github: '',
  chains: ['eos']
}, {
  name: 'Everipedia',
  description: 'The Everipedia team plans to build a modern, convenient and decentralized new encyclopedia website, and this goal will be realized with the development of blockchain technology. The new version of Everipedia under development will be based on the EOS network, which will have features such as community autonomy, shielding preventation, and contribution incentives compared to the current version of Everipedia. Founded in 2014, the business network encyclopedia Everipedia, whose name derives from the English words Everything and Encyclopedia, is owned by Everipedia.Inc and has not yet adopted blockchain technology. As of December 2017, Everipedia is the largest English encyclopedia with more than six million entries, including all English entries of Wikipedia. Everipedias requirements for attention are more relaxed, so it has more entries than Wikipedia.',
  shortDescription: 'The Everipedia team plans to build a modern, convenient and decentralized new encyclopedia.',
  symbol: 'IQ',
  partner: true,
  statistics: false,
  accounts: ['everipediaiq', 'eparticlectr'],
  logo: 'https://bloks.io/img/dapps/everipedia.jpg',
  website: '',
  app: 'https://everipedia.org',
  telegram: 'https://t.me/everipedia',
  medium: '',
  twitter: '',
  github: '',
  chains: ['eos']
}, {
  name: 'eosDAC',
  description: 'eosDAC is a Community Owned Blockproducer and a DAC enabler, born out of Dan Larimers concept of Decentralized Autonomous Communities or DACs, around which Block.one developed EOS software.  The vision of eosDAC is that EOS.IO block production should be open for everyone to contribute and benefit. To realize this vision, eosDAC is an evolving Decentralised Autonomous Community (DAC) focused on EOS.IO Block Production serving the EOS communities worldwide. In doing this, eosDAC is creating the tools and smart contracts it needs to function. It will share these with the EOS communities to help other DACs thrive on the EOS.IO blockchains.  In order to function as a DAC, eosDAC is creating open source tools and will be sharing them as a DAC Toolkit, that anyone can use, modify to setup and run a DAC.',
  shortDescription: 'eosDAC is creating open source tools and will be sharing them as a DAC Toolkit to enable DACs',
  symbol: 'EOSDAC',
  partner: false,
  statistics: false,
  accounts: ['eosdactokens', 'eosdacserver', 'eosdacthedac', 'daccustodian'],
  logo: 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/eosdac.png',
  website: '',
  app: 'members.eosdac.io',
  discord: 'https://discord.io/eosdac',
  telegram: 'https://t.me/eosdacio',
  medium: '',
  twitter: '',
  github: 'https://github.com/eosdac',
  chains: ['eos']
}, {
  name: 'DEOS Games',
  description: 'Deos Games are casino games built on EOS blockchain. Play zero edge games with our DEOS token and participate in bankroll staking.',
  shortDescription: 'Deos Games are casino games built on the EOS blockchain. Play zero edge games with DEOS token.',
  symbol: 'DEOS',
  statistics: false,
  accounts: ['thedeosgames', 'deosgameissu'],
  logo: 'https://bloks.io/img/dapps/deosgames.png',
  website: 'https://deosgames.com',
  app: 'https://app.deosgames.com',
  telegram: 'https://t.me/deosgameschat',
  medium: 'https://medium.com/deos-games',
  twitter: '',
  github: '',
  chains: ['eos']
}, {
  name: 'Chintai',
  description: 'Chintai is a community-owned, feeless, 100% on-chain, multisig decentralized token leasing platform where users can lend their EOS on the market to earn interest from other users to borrow who need access to CPU/NET bandwidth.',
  shortDescription: 'Chintai is a community-owned, feeless, 100% on-chain, multisig decentralized token leasing platform.',
  symbol: '',
  statistics: false,
  accounts: ['chintailease', 'chintaiproxy', 'bidchextoken', 'chexchexchex'],
  logo: 'https://bloks.io/img/dapps/chintai.png',
  website: 'http://chintai.io',
  app: 'https://eos.chintai.io/exchange/EOS28D',
  telegram: 'https://t.me/ChintaiEOS',
  medium: 'https://medium.com/@ChintaiEOS',
  twitter: 'https://twitter.com/chintaieos',
  github: 'https://github.com/chintai-platform',
  chains: ['eos']
}, {
  name: 'Newdex',
  description: 'Newdex is the first EOS based decentralized exchange in the world, upholding the characteristics of safe, fast and transparent, devoting to create a new-generation platform for digital assets exchange, leading the industry into an ideal new era.',
  shortDescription: 'Newdex is the first EOS based decentralized exchange in the world.',
  symbol: '',
  accounts: ['newdexpocket'],
  logo: 'https://bloks.io/img/dapps/newdex.png',
  website: 'https://newdex.io',
  app: 'https://newdex.io',
  telegram: '',
  medium: '',
  twitter: 'https://twitter.com/NewdexOfficial',
  github: '',
  chains: ['eos']
}, {
  name: 'EOS Name Swaps',
  description: 'An open-source EOS account exchange that puts the security of its users first.',
  shortDescription: 'An open-source EOS account exchange that puts the security of its users first.',
  symbol: '',
  statistics: false,
  accounts: ['eosnameswaps'],
  logo: 'https://bloks.io/img/dapps/eosnameswaps.png',
  website: 'https://www.eosnameswaps.com/',
  app: 'https://www.eosnameswaps.com/',
  telegram: 'https://t.me/eosnameswaps',
  medium: '',
  twitter: 'https://twitter.com/Starry3017Night',
  github: 'https://github.com/StarryJapanNight/eosnameswaps',
  chains: ['eos']
}];

var exchanges = {
  'Bithumb': {
    'name': 'Bithumb',
    'description': '비트코인, 이더리움, 비트코인캐시, 리플, 라이트코인, 대시, 모네로, 비트코인골드, 이오스, 이더리움클래식, 퀀텀, 제트캐시, 실시간 시세, 쉽고 안전한 거래.',
    'accounts': ['bithumbshiny'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.bithumb.com/'
  },
  'OKEx': {
    'name': 'OKEx',
    'description': 'OKEx is the leading global bitcoin exchange. Secured with bank-level SSL encryption and cold storage.',
    'accounts': ['okexoffiline'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.okex.com/'
  },
  'Bitfinex': {
    'name': 'Bitfinex',
    'description': 'Bitfinex is a full-featured spot trading platform for major digital assets & cryptocurrencies, including Bitcoin, Ethereum, EOS, Litecoin, Ripple, NEO, Monero and many more.',
    'accounts': ['bitfinexcw55', 'bitfinexcw13', 'bitfinexcw11', 'bitfinexcw24', 'bitfinexcw15', 'bitfinexcw32', 'bitfinexcw21', 'bitfinexcw31', 'bitfinexcw25', 'bitfinexcw23', 'bitfinexcw33', 'bitfinexcw22', 'bitfinexcw12', 'bitfinexcw14'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://bitfinex.com/'
  },
  'Gate.io': {
    'name': 'Gate.io',
    'description': 'Gate.io is a bitcoin exchange platform which supports BTC, LTC, Ethereum, Qtum and more blockchain assets trading.',
    'accounts': ['gateiowallet'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.gate.io/'
  },
  'Kraken': {
    'name': 'Kraken',
    'description': 'Buy, sell and margin trade Bitcoin (BTC) and Etherum (ETH) in exchange with EUR, USD, CAD, GBP, and JPY.',
    'accounts': ['krakenkraken'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-dapps/master/logos/placeholder.png',
    'website': 'https://www.kraken.com/'
  },
  'Newdex': {
    'name': 'Newdex',
    'description': 'The first EOS based decentralized exchange in the world.',
    'accounts': ['newdexpocket'],
    'logo': '/img/exchanges/newdex.png',
    'website': 'https://newdex.io/',
    linkGenerator: function linkGenerator(token, pair) {
      return "https://newdex.io/trade/" + token.account + "-" + pair.pair_base.toLowerCase() + "-" + pair.pair_quote.toLowerCase();
    }
  },
  'DefiBox': {
    'name': 'DefiBox',
    'description': 'One-stop DeFi application platform on EOS..',
    'accounts': ['token.defi', 'swap.defi'],
    'logo': 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/token.defi-box.png',
    'website': 'https://defibox.io/',
    linkGenerator: function linkGenerator(_, __) {
      return "https://defibox.io/";
    }
  },
  'Chaince': {
    'name': 'Chaince',
    'description': 'A Superior Blockchain Asset Trading Platform Focusing on EOS Projects',
    'accounts': ['chainceoneos'],
    'logo': '/img/exchanges/chaince.png',
    'website': 'https://chaince.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://chaince.com/trade/" + pair.pair_base.toLowerCase() + pair.pair_quote.toLowerCase();
    }
  },
  'Dexeos': {
    'name': 'Dexeos',
    'description': 'The World\'s First EOS-based Decentralized Exchange',
    'accounts': ['dexeoswallet'],
    'logo': '/img/exchanges/dexeos.svg',
    'website': 'https://dexeos.io/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://dexeos.io/trade/" + pair.pair_base.toUpperCase();
    }
  },
  'Hoo': {
    'name': 'Hoo',
    'description': 'One-stop blockchain asset service platform',
    'accounts': ['hoo.com'],
    'logo': '/img/exchanges/hoo.jpg',
    'website': 'https://hoo.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://hoo.com/trade/" + pair.pair_base.toLowerCase() + "-" + pair.pair_quote.toLowerCase();
    }
  },
  'Whaleex': {
    'name': 'Whaleex',
    'description': '#1 Decentralized Exchange in the World',
    'accounts': ['whaleextrust'],
    'logo': '/img/exchanges/whaleex.png',
    'website': 'https://www.whaleex.com',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://www.whaleex.com/trade/" + pair.pair_base + "_" + pair.pair_quote;
    }
  },
  'Chainrift': {
    'name': 'Chainrift',
    'description': 'A marketplace for digital currencies',
    'accounts': [],
    'logo': '/img/exchanges/chainrift.png',
    'website': 'https://www.chainrift.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://www.chainrift.com/trading?coinpair=" + pair.pair_base + "/" + pair.pair_quote;
    }
  },
  'Eosdaq': {
    'name': 'EOSDAQ',
    'description': 'A Standard of On-Chain DEX',
    'accounts': [],
    'logo': '/img/exchanges/eosdaq.png',
    'website': 'https://www.eosdaq.com/',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://eosdaq.com/exchange/" + pair.pair_base + "_" + pair.pair_quote;
    }
  },
  'BigONE': {
    'name': 'BigONE',
    'description': 'A Standard of On-Chain DEX',
    'accounts': [],
    'logo': '/img/exchanges/bigONE.jpg',
    'website': 'https://big.one',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://big.one/trade/" + pair.pair_base + "-" + pair.pair_quote;
    }
  },
  'YOLO': {
    'name': 'YOLO',
    'description': 'Instant Token Swaps on EOS',
    'accounts': [],
    'logo': '/img/exchanges/yolo.png',
    'website': 'https://yoloswap.com',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://yoloswap.com/swap/" + pair.pair_quote.toLowerCase() + "-" + pair.pair_base.toLowerCase();
    }
  },
  'Bancor': {
    'name': 'Bancor',
    'description': 'Instant Liquidity.',
    'accounts': [],
    'logo': '/img/exchanges/bancor.png',
    'website': 'https://bancor.network',
    linkGenerator: function linkGenerator(_, pair) {
      return "https://www.bancor.network/token/" + pair.pair_base;
    }
  },
  'Alcor': {
    'name': 'Alcor',
    'description': 'The first self-listing decentralized exchange',
    'accounts': [],
    'logo': '/img/exchanges/alcor.png',
    'website': 'https://alcor.exchange',
    linkGenerator: function linkGenerator(_, __) {
      return "https://www.alcor.exchange/markets";
    }
  },
  'Defis.Network': {
    'name': 'Defis.Network',
    'description': 'An open finance network that integrates a series of DeFi protocols',
    'accounts': [],
    'logo': '/img/exchanges/defis-uncache.png',
    'website': 'https://defis.network',
    linkGenerator: function linkGenerator(_, __) {
      return "https://apps.defis.network/";
    }
  },
  'DolphinSwap': {
    'name': 'DolphinSwap',
    'description': 'DolphinSwap',
    'accounts': [],
    'logo': '/img/exchanges/dolphinswap.png',
    'website': 'https://dolphinswap.io/exchange',
    linkGenerator: function linkGenerator(_, __) {
      return 'https://dolphinswap.io/exchange';
    }
  },
  'Proton': {
    'name': 'ProtonSwap',
    'description': 'ProtonSwap',
    'accounts': [],
    'logo': '/img/exchanges/protonswap.png',
    'website': 'https://protonswap.com',
    linkGenerator: function linkGenerator(_, __) {
      return 'https://protonswap.com';
    }
  },
  'Coingecko': {
    'name': 'CoinGecko',
    'description': 'CoinGecko',
    'accounts': [],
    'logo': '/img/exchanges/coingecko.png',
    'website': 'https://coingecko.com',
    linkGenerator: function linkGenerator(_, __) {
      return 'https://coingecko.com';
    }
  }
};

var SCATTER_DESKTOP = 'ScatterSockets';
var SCATTER_DESKTOP_MANUAL = 'ScatterSocketsManual';
var SCATTER_EXTENSION = 'ScatterExtension';
var LEDGER = 'ledger';
var LEDGER_USB = 'TransportU2F';
var LEDGER_BLE = 'TransportWebBLE';
var LEDGER_WEBUSB = 'TransportWebusb';
var LEDGER_WEBHID = 'TransportWebHID';
var LYNX = 'lynx';
var PROTON = 'proton';
var PROTON_WEB = 'protonweb';
var ANCHOR = 'anchor';
var SIMPLEOS = 'simpleos';
var EOSAUTH = 'eosauth';
var CLEOS = 'cleos';
var EOSC = 'eosc';
var CLIO = 'clio';
var KEYCAT = 'keycat';
var TREZOR = 'trezor';
var SQRL = 'sqrl';
var WOMBAT = 'wombat';
var WAX_CLOUD_WALLET = 'WaxCW';

var historyTypesFeatures = {
  "native": {
    name: 'native',
    actionFilter: false,
    tokenFilter: false,
    dateFilter: false,
    contractActionFilter: false,
    total: 0
  },
  dfuse: {
    name: 'dfuse',
    actionFilter: true,
    tokenFilter: true,
    dateFilter: true,
    contractActionFilter: true,
    total: 4
  },
  hyperion: {
    name: 'hyperion',
    actionFilter: true,
    tokenFilter: true,
    dateFilter: true,
    contractActionFilter: true,
    total: 3
  }
};

var _chainInfo;

var chainInfo = (_chainInfo = {}, _chainInfo['proton-test'] = {
  key: 'proton-test',
  text: 'Proton Testnet',
  value: 'https://testnet.protonscan.io',
  image: '/img/chains/proton.png',
  testnet: true
}, _chainInfo.local = {
  key: 'local',
  text: 'Local Testnet',
  value: 'https://local.bloks.io',
  image: '/img/chains/local.png',
  testnet: true
}, _chainInfo['wax-test'] = {
  key: 'wax-test',
  text: 'WAX Testnet',
  value: 'https://wax-test.bloks.io',
  image: '/img/chains/wax.png',
  testnet: true
}, _chainInfo['fio-test'] = {
  key: 'fio-test',
  text: 'FIO Testnet',
  value: 'https://fio-test.bloks.io',
  image: '/img/chains/fio.png',
  testnet: true
}, _chainInfo.jungle3 = {
  key: 'jungle3',
  text: 'Jungle3 Testnet',
  value: 'https://jungle3.bloks.io',
  image: '/img/chains/jungle.png',
  testnet: true
}, _chainInfo.kylin = {
  key: 'kylin',
  text: 'Kylin Testnet',
  value: 'https://kylin.bloks.io',
  image: '/img/chains/kylin.png',
  testnet: true
}, _chainInfo.proton = {
  key: 'proton',
  text: 'Proton',
  value: 'https://protonscan.io',
  image: '/img/chains/proton.png'
}, _chainInfo.eos = {
  key: 'eos',
  text: 'EOS',
  value: 'https://bloks.io',
  image: '/img/chains/eos.png'
}, _chainInfo.wax = {
  key: 'wax',
  text: 'WAX',
  value: 'https://wax.bloks.io',
  image: '/img/chains/wax.png'
}, _chainInfo.fio = {
  key: 'fio',
  text: 'FIO',
  value: 'https://fio.bloks.io',
  image: '/img/chains/fio.png'
}, _chainInfo);

var getCommonConstants = function getCommonConstants(chain) {
  return {
    MAX_RPC_SYNC_SECONDS_BEHIND: 20,
    IMAGE_PROXY: 'https://www.api.bloks.io/image-proxy',
    WRAP_CONTRACT: 'proton.wrap',
    BLOKS_API: 'https://www.api.bloks.io',
    ESR_PROTOCOL: chain === 'proton' ? 'proton' : 'proton-dev',
    METAL_PROTON_ENDPOINT: chain === 'proton' ? 'https://api.protonchain.com' : 'https://api-dev.protonchain.com',
    SWAP_URL: chain === 'proton' ? 'https://otc.protonswap.com' : 'https://otc-test.protonswap.com',
    WRAP_SERVER_URL: chain === 'proton' ? 'https://www.api.bloks.io/proton-wrap-public2' : 'https://www.api.bloks.io/proton-wrap-testnet-public2'
  };
};

var generateProviderEndpoints = function generateProviderEndpoints(chainId, actionEndpoints) {
  return [{
    chainId: chainId,
    port: 443,
    protocol: 'https',
    host: actionEndpoints[0].substr(8),
    httpEndpoint: actionEndpoints[0],
    blockchain: 'eos'
  }];
};

var DEFAULT_ENDPOINTS = ['https://eos.greymass.com', 'https://eos.eoscafeblock.com', 'https://api.main.alohaeos.com', 'https://api.eossweden.org'];
var ACTIONS_ENDPOINTS = ['https://eos.greymass.com'];
var TRANSACTIONS_ENDPOINTS = ['https://eos.greymass.com', 'https://api.eossweden.org'];
var ALOHA_PROXY_URL = 'https://www.alohaeos.com/vote/proxy';
var API_URL = 'https://www.api.bloks.io';
var ATOMICASSETS_API = 'https://eos.api.atomicassets.io';
var BLOKS_PROXY = 'bloksioproxy';
var CHAIN = 'eos';
var CHAIN_ID = 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906';
var CHAIN_START_DATE = /*#__PURE__*/new Date('2018-06-08');
var CORE_PRECISION = 4;
var CORE_SYMBOL = 'EOS';
var DISPLAY_CHAIN = 'EOS';
var DOMAIN_TITLE = 'EOS Bloks.io';
var HISTORY_TYPES = ['native', 'hyperion'];
var HYPERION_URL = 'https://eos.hyperion.eosrio.io';
var KEY_PREFIX = 'EOS';
var LIGHT_API = 'https://api.light.xeos.me';
var NFTS_ENABLED = true;
var PROVIDER_ENDPOINTS = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID, ACTIONS_ENDPOINTS);
var REX_ENABLED = true;
var SIMPLEASSETS_API = 'https://eos.api.simpleassets.io';
var SUPPORTS_FREE_CPU = true;
var SUPPORTS_RENTBW = true;
var VOTING_ENABLED = true;
var constants = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS,
  ALOHA_PROXY_URL: ALOHA_PROXY_URL,
  API_URL: API_URL,
  ATOMICASSETS_API: ATOMICASSETS_API,
  BLOKS_PROXY: BLOKS_PROXY,
  CHAIN: CHAIN,
  CHAIN_ID: CHAIN_ID,
  CHAIN_START_DATE: CHAIN_START_DATE,
  CORE_PRECISION: CORE_PRECISION,
  CORE_SYMBOL: CORE_SYMBOL,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS,
  DISPLAY_CHAIN: DISPLAY_CHAIN,
  DOMAIN_TITLE: DOMAIN_TITLE,
  HISTORY_TYPES: HISTORY_TYPES,
  HYPERION_URL: HYPERION_URL,
  KEY_PREFIX: KEY_PREFIX,
  LIGHT_API: LIGHT_API,
  NFTS_ENABLED: NFTS_ENABLED,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS,
  REX_ENABLED: REX_ENABLED,
  SIMPLEASSETS_API: SIMPLEASSETS_API,
  SUPPORTS_FREE_CPU: SUPPORTS_FREE_CPU,
  SUPPORTS_RENTBW: SUPPORTS_RENTBW,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS,
  VOTING_ENABLED: VOTING_ENABLED
};

var DEFAULT_ENDPOINTS$1 = ['https://wax.greymass.com', 'https://wax.eoscafeblock.com', 'https://api.waxsweden.org', 'https://chain.wax.io', 'https://wax.eosrio.io'];
var ACTIONS_ENDPOINTS$1 = ['https://wax.greymass.com', 'https://api.waxsweden.org', 'https://wax.eosrio.io', 'https://chain.wax.io'];
var TRANSACTIONS_ENDPOINTS$1 = ['https://wax.greymass.com', 'https://api.waxsweden.org', 'https://wax.eosrio.io', 'https://chain.wax.io'];
var ALOHA_PROXY_URL$1 = 'https://www.alohaeos.com/vote/proxy/waxmain';
var API_URL$1 = 'https://www.api.bloks.io/wax';
var ATOMICASSETS_API$1 = 'https://wax.api.atomicassets.io';
var BLOKS_PROXY$1 = 'bloksioproxy';
var CHAIN$1 = 'wax';
var CHAIN_ID$1 = '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4';
var CHAIN_START_DATE$1 = /*#__PURE__*/new Date('2019-06-24');
var CORE_PRECISION$1 = 8;
var CORE_SYMBOL$1 = 'WAX';
var DISPLAY_CHAIN$1 = 'WAX';
var DOMAIN_TITLE$1 = 'WAX | Bloks.io';
var HISTORY_TYPES$1 = ['native', 'hyperion'];
var HYPERION_URL$1 = 'https://wax.eosrio.io';
var KEY_PREFIX$1 = 'EOS';
var LIGHT_API$1 = 'https://lightapi.eosamsterdam.net';
var NFTS_ENABLED$1 = true;
var PROVIDER_ENDPOINTS$1 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$1, ACTIONS_ENDPOINTS$1);
var SIMPLEASSETS_API$1 = 'https://wax.api.simpleassets.io';
var VOTING_ENABLED$1 = true;
var constants$1 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$1,
  ALOHA_PROXY_URL: ALOHA_PROXY_URL$1,
  API_URL: API_URL$1,
  ATOMICASSETS_API: ATOMICASSETS_API$1,
  BLOKS_PROXY: BLOKS_PROXY$1,
  CHAIN: CHAIN$1,
  CHAIN_ID: CHAIN_ID$1,
  CHAIN_START_DATE: CHAIN_START_DATE$1,
  CORE_PRECISION: CORE_PRECISION$1,
  CORE_SYMBOL: CORE_SYMBOL$1,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$1,
  DISPLAY_CHAIN: DISPLAY_CHAIN$1,
  DOMAIN_TITLE: DOMAIN_TITLE$1,
  HISTORY_TYPES: HISTORY_TYPES$1,
  HYPERION_URL: HYPERION_URL$1,
  KEY_PREFIX: KEY_PREFIX$1,
  LIGHT_API: LIGHT_API$1,
  NFTS_ENABLED: NFTS_ENABLED$1,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$1,
  SIMPLEASSETS_API: SIMPLEASSETS_API$1,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$1,
  VOTING_ENABLED: VOTING_ENABLED$1
};

var DEFAULT_ENDPOINTS$2 = ['https://proton.greymass.com', 'https://proton.cryptolions.io', 'https://proton.eosusa.news', "https://frankfurt.protondata.net"];
var TRANSACTIONS_ENDPOINTS$2 = ['https://proton.greymass.com', 'https://proton.cryptolions.io'];
var ACTIONS_ENDPOINTS$2 = ['https://proton.greymass.com'];
var API_URL$2 = 'https://www.api.bloks.io/proton';
var ATOMICASSETS_API$2 = 'https://proton.api.atomicassets.io';
var CHAIN$2 = 'proton';
var CHAIN_ID$2 = '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0';
var CHAIN_START_DATE$2 = /*#__PURE__*/new Date('Apr 22, 2020');
var CORE_PRECISION$2 = 4;
var CORE_SYMBOL$2 = 'XPR';
var DISPLAY_CHAIN$2 = 'Proton';
var DOMAIN_TITLE$2 = 'ProtonScan';
var HISTORY_TYPES$2 = ['native', 'hyperion'];
var HYPERION_URL$2 = 'http://proton.pink.gg';
var KEY_PREFIX$2 = 'EOS';
var LIGHT_API$2 = 'https://lightapi.eosamsterdam.net';
var MAX_VOTES = 4;
var NFTS_ENABLED$2 = true;
var PROVIDER_ENDPOINTS$2 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$2, ACTIONS_ENDPOINTS$2);
var VOTING_ENABLED$2 = true;
var constants$2 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$2,
  API_URL: API_URL$2,
  ATOMICASSETS_API: ATOMICASSETS_API$2,
  CHAIN: CHAIN$2,
  CHAIN_ID: CHAIN_ID$2,
  CHAIN_START_DATE: CHAIN_START_DATE$2,
  CORE_PRECISION: CORE_PRECISION$2,
  CORE_SYMBOL: CORE_SYMBOL$2,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$2,
  DISPLAY_CHAIN: DISPLAY_CHAIN$2,
  DOMAIN_TITLE: DOMAIN_TITLE$2,
  HISTORY_TYPES: HISTORY_TYPES$2,
  HYPERION_URL: HYPERION_URL$2,
  KEY_PREFIX: KEY_PREFIX$2,
  LIGHT_API: LIGHT_API$2,
  MAX_VOTES: MAX_VOTES,
  NFTS_ENABLED: NFTS_ENABLED$2,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$2,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$2,
  VOTING_ENABLED: VOTING_ENABLED$2
};

var DEFAULT_ENDPOINTS$3 = ['https://fio.greymass.com', 'https://fio.eossweden.org', 'https://fio.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$3 = ['https://fio.greymass.com', 'https://fio.eossweden.org', 'https://fio.eosusa.news'];
var ACTIONS_ENDPOINTS$3 = ['https://fio.greymass.com', 'https://fio.eossweden.org', 'https://fio.eosusa.news'];
var ALOHA_PROXY_URL$2 = 'https://www.alohaeos.com/vote/proxy/fiomain';
var API_URL$3 = 'https://www.api.bloks.io/fio';
var CHAIN$3 = 'fio';
var CHAIN_ID$3 = '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c';
var CHAIN_START_DATE$3 = /*#__PURE__*/new Date('Mar 24, 2020');
var CORE_PRECISION$3 = 9;
var CORE_SYMBOL$3 = 'FIO';
var DISABLE_MEMO = true;
var DISPLAY_CHAIN$3 = 'FIO';
var DOMAIN_TITLE$3 = 'FIO Bloks.io';
var FIO_FEES_ACCOUNT = 'fees@bloks';
var HISTORY_TYPES$3 = ['native', 'hyperion'];
var HYPERION_URL$3 = 'https://fio.eossweden.org';
var KEY_PREFIX$3 = 'FIO';
var PROVIDER_ENDPOINTS$3 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$3, ACTIONS_ENDPOINTS$3);
var VOTING_ENABLED$3 = true;
var constants$3 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$3,
  ALOHA_PROXY_URL: ALOHA_PROXY_URL$2,
  API_URL: API_URL$3,
  CHAIN: CHAIN$3,
  CHAIN_ID: CHAIN_ID$3,
  CHAIN_START_DATE: CHAIN_START_DATE$3,
  CORE_PRECISION: CORE_PRECISION$3,
  CORE_SYMBOL: CORE_SYMBOL$3,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$3,
  DISABLE_MEMO: DISABLE_MEMO,
  DISPLAY_CHAIN: DISPLAY_CHAIN$3,
  DOMAIN_TITLE: DOMAIN_TITLE$3,
  FIO_FEES_ACCOUNT: FIO_FEES_ACCOUNT,
  HISTORY_TYPES: HISTORY_TYPES$3,
  HYPERION_URL: HYPERION_URL$3,
  KEY_PREFIX: KEY_PREFIX$3,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$3,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$3,
  VOTING_ENABLED: VOTING_ENABLED$3
};

var DEFAULT_ENDPOINTS$4 = [];
var ACTIONS_ENDPOINTS$4 = [];
var TRANSACTIONS_ENDPOINTS$4 = [];
var API_URL$4 = '';
var CHAIN$4 = 'local';
var CHAIN_ID$4 = '';
var CHAIN_START_DATE$4 = undefined;
var CORE_PRECISION$4 = 4;
var CORE_SYMBOL$4 = 'EOS';
var DISPLAY_CHAIN$4 = 'Local';
var DOMAIN_TITLE$4 = 'Local Bloks.io';
var HISTORY_TYPES$4 = ['native'];
var KEY_PREFIX$4 = 'EOS';
var PROVIDER_ENDPOINTS$4 = [];
var VOTING_ENABLED$4 = true;
var constants$4 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$4,
  API_URL: API_URL$4,
  CHAIN: CHAIN$4,
  CHAIN_ID: CHAIN_ID$4,
  CHAIN_START_DATE: CHAIN_START_DATE$4,
  CORE_PRECISION: CORE_PRECISION$4,
  CORE_SYMBOL: CORE_SYMBOL$4,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$4,
  DISPLAY_CHAIN: DISPLAY_CHAIN$4,
  DOMAIN_TITLE: DOMAIN_TITLE$4,
  HISTORY_TYPES: HISTORY_TYPES$4,
  KEY_PREFIX: KEY_PREFIX$4,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$4,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$4,
  VOTING_ENABLED: VOTING_ENABLED$4
};

var DEFAULT_ENDPOINTS$5 = [// 'https://jungleapi.eossweden.org',
'https://api.jungle.alohaeos.com', 'https://jungle2.cryptolions.io', 'https://jungle.eosphere.io', 'https://eos-jungle.eosblocksmith.io'];
var ACTIONS_ENDPOINTS$5 = ['https://jungle.eossweden.org'];
var TRANSACTIONS_ENDPOINTS$5 = ['https://jungle.eossweden.org'];
var API_URL$5 = 'https://www.api.bloks.io/jungle';
var BLOKS_PROXY$2 = 'blokspartner';
var CHAIN$5 = 'jungle';
var CHAIN_ID$5 = 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473';
var CHAIN_START_DATE$5 = /*#__PURE__*/new Date('Nov 23, 2018');
var CORE_PRECISION$5 = 4;
var CORE_SYMBOL$5 = 'EOS';
var DISPLAY_CHAIN$5 = 'Jungle';
var DOMAIN_TITLE$5 = 'Jungle Bloks.io';
var HISTORY_TYPES$5 = ['hyperion', 'native'];
var HYPERION_URL$4 = 'https://jungle2.cryptolions.io';
var KEY_PREFIX$5 = 'EOS';
var LIGHT_API$3 = 'https://lightapi.eosgeneva.io';
var NFTS_ENABLED$3 = true;
var PROVIDER_ENDPOINTS$5 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$5, ACTIONS_ENDPOINTS$5);
var REX_ENABLED$1 = true;
var VOTING_ENABLED$5 = true;
var constants$5 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$5,
  API_URL: API_URL$5,
  BLOKS_PROXY: BLOKS_PROXY$2,
  CHAIN: CHAIN$5,
  CHAIN_ID: CHAIN_ID$5,
  CHAIN_START_DATE: CHAIN_START_DATE$5,
  CORE_PRECISION: CORE_PRECISION$5,
  CORE_SYMBOL: CORE_SYMBOL$5,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$5,
  DISPLAY_CHAIN: DISPLAY_CHAIN$5,
  DOMAIN_TITLE: DOMAIN_TITLE$5,
  HISTORY_TYPES: HISTORY_TYPES$5,
  HYPERION_URL: HYPERION_URL$4,
  KEY_PREFIX: KEY_PREFIX$5,
  LIGHT_API: LIGHT_API$3,
  NFTS_ENABLED: NFTS_ENABLED$3,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$5,
  REX_ENABLED: REX_ENABLED$1,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$5,
  VOTING_ENABLED: VOTING_ENABLED$5
};

var DEFAULT_ENDPOINTS$6 = ['https://jungle3.cryptolions.io', 'https://api.jungle3.alohaeos.com', 'https://jungle3.eosusa.news'];
var ACTIONS_ENDPOINTS$6 = ['https://jungle3.cryptolions.io', 'https://jungle3.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$6 = ['https://jungle3.cryptolions.io', 'https://jungle3.eosusa.news'];
var API_URL$6 = 'https://www.api.bloks.io/jungle3';
var CHAIN$6 = 'jungle3';
var CHAIN_ID$6 = '2a02a0053e5a8cf73a56ba0fda11e4d92e0238a4a2aa74fccf46d5a910746840';
var CHAIN_START_DATE$6 = /*#__PURE__*/new Date('Feb 19, 2020');
var CORE_PRECISION$6 = 4;
var CORE_SYMBOL$6 = 'EOS';
var DISPLAY_CHAIN$6 = 'Jungle 3';
var DOMAIN_TITLE$6 = 'Jungle 3 Bloks.io';
var HISTORY_TYPES$6 = ['hyperion'];
var HYPERION_URL$5 = 'https://jungle3.cryptolions.io';
var KEY_PREFIX$6 = 'EOS';
var PROVIDER_ENDPOINTS$6 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$6, ACTIONS_ENDPOINTS$6);
var REX_ENABLED$2 = true;
var SUPPORTS_RENTBW$1 = true;
var VOTING_ENABLED$6 = true;
var constants$6 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$6,
  API_URL: API_URL$6,
  CHAIN: CHAIN$6,
  CHAIN_ID: CHAIN_ID$6,
  CHAIN_START_DATE: CHAIN_START_DATE$6,
  CORE_PRECISION: CORE_PRECISION$6,
  CORE_SYMBOL: CORE_SYMBOL$6,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$6,
  DISPLAY_CHAIN: DISPLAY_CHAIN$6,
  DOMAIN_TITLE: DOMAIN_TITLE$6,
  HISTORY_TYPES: HISTORY_TYPES$6,
  HYPERION_URL: HYPERION_URL$5,
  KEY_PREFIX: KEY_PREFIX$6,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$6,
  REX_ENABLED: REX_ENABLED$2,
  SUPPORTS_RENTBW: SUPPORTS_RENTBW$1,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$6,
  VOTING_ENABLED: VOTING_ENABLED$6
};

var DEFAULT_ENDPOINTS$7 = ['https://kylin.eosn.io'];
var ACTIONS_ENDPOINTS$7 = ['https://kylin.eosn.io'];
var TRANSACTIONS_ENDPOINTS$7 = ['https://kylin.eosn.io'];
var API_URL$7 = 'https://www.api.bloks.io/kylin';
var BLOKS_PROXY$3 = 'blokspartner';
var CHAIN$7 = 'kylin';
var CHAIN_ID$7 = '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191';
var CHAIN_START_DATE$7 = /*#__PURE__*/new Date('Jul 10, 2018');
var CORE_PRECISION$7 = 4;
var CORE_SYMBOL$7 = 'EOS';
var DISPLAY_CHAIN$7 = 'Kylin';
var DOMAIN_TITLE$7 = 'Kylin Bloks.io';
var HISTORY_TYPES$7 = ['hyperion', 'native'];
var HYPERION_URL$6 = 'https://kylin.eosusa.news';
var KEY_PREFIX$7 = 'EOS';
var PROVIDER_ENDPOINTS$7 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$7, ACTIONS_ENDPOINTS$7);
var VOTING_ENABLED$7 = true;
var constants$7 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$7,
  API_URL: API_URL$7,
  BLOKS_PROXY: BLOKS_PROXY$3,
  CHAIN: CHAIN$7,
  CHAIN_ID: CHAIN_ID$7,
  CHAIN_START_DATE: CHAIN_START_DATE$7,
  CORE_PRECISION: CORE_PRECISION$7,
  CORE_SYMBOL: CORE_SYMBOL$7,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$7,
  DISPLAY_CHAIN: DISPLAY_CHAIN$7,
  DOMAIN_TITLE: DOMAIN_TITLE$7,
  HISTORY_TYPES: HISTORY_TYPES$7,
  HYPERION_URL: HYPERION_URL$6,
  KEY_PREFIX: KEY_PREFIX$7,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$7,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$7,
  VOTING_ENABLED: VOTING_ENABLED$7
};

var DEFAULT_ENDPOINTS$8 = ['https://www.api.bloks.io/eos-test-node'];
var ACTIONS_ENDPOINTS$8 = ['https://www.api.bloks.io/eos-test-node'];
var TRANSACTIONS_ENDPOINTS$8 = ['https://www.api.bloks.io/eos-test-node'];
var API_URL$8 = 'https://www.api.bloks.io/eos-test';
var CHAIN$8 = 'eos-test';
var CHAIN_ID$8 = '0db13ab9b321c37c0ba8481cb4681c2788b622c3abfd1f12f0e5353d44ba6e72';
var CHAIN_START_DATE$8 = /*#__PURE__*/new Date('2020-01-14');
var CORE_PRECISION$8 = 4;
var CORE_SYMBOL$8 = 'TNT';
var DISPLAY_CHAIN$8 = 'EOSIO Test';
var DOMAIN_TITLE$8 = 'Bloks.io';
var HISTORY_TYPES$8 = ['native'];
var KEY_PREFIX$8 = 'EOS';
var PROVIDER_ENDPOINTS$8 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$8, ACTIONS_ENDPOINTS$8);
var constants$8 = {
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$8,
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$8,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$8,
  API_URL: API_URL$8,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$8,
  CORE_SYMBOL: CORE_SYMBOL$8,
  CHAIN: CHAIN$8,
  DISPLAY_CHAIN: DISPLAY_CHAIN$8,
  HISTORY_TYPES: HISTORY_TYPES$8,
  CHAIN_ID: CHAIN_ID$8,
  DOMAIN_TITLE: DOMAIN_TITLE$8,
  CHAIN_START_DATE: CHAIN_START_DATE$8,
  KEY_PREFIX: KEY_PREFIX$8,
  CORE_PRECISION: CORE_PRECISION$8
};

var DEFAULT_ENDPOINTS$9 = ['https://protontestnet.greymass.com', 'https://proton-testnet.eoscafeblock.com', 'https://testnet.protonchain.com', 'https://test.proton.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$9 = ['https://protontestnet.greymass.com', 'https://testnet.protonchain.com', 'https://test.proton.eosusa.news'];
var ACTIONS_ENDPOINTS$9 = ['https://protontestnet.greymass.com', 'https://testnet.protonchain.com', 'https://test.proton.eosusa.news'];
var API_URL$9 = 'https://www.api.bloks.io/proton-test';
var ATOMICASSETS_API$3 = 'https://test.proton.api.atomicassets.io';
var CHAIN$9 = 'proton-test';
var CHAIN_ID$9 = '71ee83bcf52142d61019d95f9cc5427ba6a0d7ff8accd9e2088ae2abeaf3d3dd';
var CHAIN_START_DATE$9 = /*#__PURE__*/new Date('April 3, 2020');
var CORE_PRECISION$9 = 4;
var CORE_SYMBOL$9 = 'XPR';
var DISPLAY_CHAIN$9 = 'Proton-T';
var DOMAIN_TITLE$9 = 'Proton Testnet';
var HISTORY_TYPES$9 = ['hyperion', 'native'];
var HYPERION_URL$7 = 'https://testnet.proton.pink.gg';
var KEY_PREFIX$9 = 'EOS';
var MAX_VOTES$1 = 4;
var PROVIDER_ENDPOINTS$9 = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$9, ACTIONS_ENDPOINTS$9);
var VOTING_ENABLED$8 = true;
var constants$9 = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$9,
  API_URL: API_URL$9,
  ATOMICASSETS_API: ATOMICASSETS_API$3,
  CHAIN: CHAIN$9,
  CHAIN_ID: CHAIN_ID$9,
  CHAIN_START_DATE: CHAIN_START_DATE$9,
  CORE_PRECISION: CORE_PRECISION$9,
  CORE_SYMBOL: CORE_SYMBOL$9,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$9,
  DISPLAY_CHAIN: DISPLAY_CHAIN$9,
  DOMAIN_TITLE: DOMAIN_TITLE$9,
  HISTORY_TYPES: HISTORY_TYPES$9,
  HYPERION_URL: HYPERION_URL$7,
  KEY_PREFIX: KEY_PREFIX$9,
  MAX_VOTES: MAX_VOTES$1,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$9,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$9,
  VOTING_ENABLED: VOTING_ENABLED$8
};

var DEFAULT_ENDPOINTS$a = ['https://testnet.wax.eosdetroit.io', 'https://testnet.wax.pink.gg', 'https://testnet.waxsweden.org'];
var TRANSACTIONS_ENDPOINTS$a = ['https://testnet.wax.eosdetroit.io', 'https://testnet.wax.pink.gg', 'https://testnet.waxsweden.org'];
var ACTIONS_ENDPOINTS$a = ['https://testnet.wax.eosdetroit.io', 'https://testnet.wax.pink.gg', 'https://testnet.waxsweden.org'];
var API_URL$a = 'https://www.api.bloks.io/wax-test';
var ATOMICASSETS_API$4 = 'https://test.wax.api.atomicassets.io';
var CHAIN$a = 'wax-test';
var CHAIN_ID$a = 'f16b1833c747c43682f4386fca9cbb327929334a762755ebec17f6f23c9b8a12';
var CHAIN_START_DATE$a = /*#__PURE__*/new Date('Dec 5, 2019');
var CORE_PRECISION$a = 8;
var CORE_SYMBOL$a = 'WAX';
var DISPLAY_CHAIN$a = 'WAX-T';
var DOMAIN_TITLE$a = 'WAX Testnet Bloks.io';
var HISTORY_TYPES$a = ['native', 'hyperion'];
var HYPERION_URL$8 = 'https://testnet.waxsweden.org';
var KEY_PREFIX$a = 'EOS';
var LIGHT_API$4 = 'https://testnet-lightapi.eosams.xeos.me';
var PROVIDER_ENDPOINTS$a = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$a, ACTIONS_ENDPOINTS$a);
var constants$a = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$a,
  API_URL: API_URL$a,
  ATOMICASSETS_API: ATOMICASSETS_API$4,
  CHAIN: CHAIN$a,
  CHAIN_ID: CHAIN_ID$a,
  CHAIN_START_DATE: CHAIN_START_DATE$a,
  CORE_PRECISION: CORE_PRECISION$a,
  CORE_SYMBOL: CORE_SYMBOL$a,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$a,
  DISPLAY_CHAIN: DISPLAY_CHAIN$a,
  DOMAIN_TITLE: DOMAIN_TITLE$a,
  HISTORY_TYPES: HISTORY_TYPES$a,
  HYPERION_URL: HYPERION_URL$8,
  KEY_PREFIX: KEY_PREFIX$a,
  LIGHT_API: LIGHT_API$4,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$a,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$a
};

var DEFAULT_ENDPOINTS$b = ['https://fiotestnet.greymass.com', 'https://test.fio.eosusa.news'];
var TRANSACTIONS_ENDPOINTS$b = ['https://fiotestnet.greymass.com', 'https://test.fio.eosusa.news'];
var ACTIONS_ENDPOINTS$b = ['https://fiotestnet.greymass.com', 'https://test.fio.eosusa.news'];
var API_URL$b = 'https://www.api.bloks.io/fio-test';
var CHAIN$b = 'fio-test';
var CHAIN_ID$b = 'b20901380af44ef59c5918439a1f9a41d83669020319a80574b804a5f95cbd7e';
var CHAIN_START_DATE$b = /*#__PURE__*/new Date('Mar 10, 2020');
var CORE_PRECISION$b = 9;
var CORE_SYMBOL$b = 'FIO';
var DISABLE_MEMO$1 = true;
var DISPLAY_CHAIN$b = 'FIO Test';
var DOMAIN_TITLE$b = 'FIO Test Bloks.io';
var HISTORY_TYPES$b = ['native', 'hyperion'];
var HYPERION_URL$9 = 'https://test.fio.eosusa.news';
var KEY_PREFIX$b = 'FIO';
var PROVIDER_ENDPOINTS$b = /*#__PURE__*/generateProviderEndpoints(CHAIN_ID$b, ACTIONS_ENDPOINTS$b);
var VOTING_ENABLED$9 = true;
var constants$b = {
  ACTIONS_ENDPOINTS: ACTIONS_ENDPOINTS$b,
  API_URL: API_URL$b,
  CHAIN: CHAIN$b,
  CHAIN_ID: CHAIN_ID$b,
  CHAIN_START_DATE: CHAIN_START_DATE$b,
  CORE_PRECISION: CORE_PRECISION$b,
  CORE_SYMBOL: CORE_SYMBOL$b,
  DEFAULT_ENDPOINTS: DEFAULT_ENDPOINTS$b,
  DISABLE_MEMO: DISABLE_MEMO$1,
  DISPLAY_CHAIN: DISPLAY_CHAIN$b,
  DOMAIN_TITLE: DOMAIN_TITLE$b,
  HISTORY_TYPES: HISTORY_TYPES$b,
  HYPERION_URL: HYPERION_URL$9,
  KEY_PREFIX: KEY_PREFIX$b,
  PROVIDER_ENDPOINTS: PROVIDER_ENDPOINTS$b,
  TRANSACTIONS_ENDPOINTS: TRANSACTIONS_ENDPOINTS$b,
  VOTING_ENABLED: VOTING_ENABLED$9
};

var _chainToNetworkConsta;

var chainToNetworkConstantsMap = (_chainToNetworkConsta = {
  eos: constants,
  wax: constants$1,
  proton: constants$2,
  local: constants$4,
  jungle: constants$5,
  jungle3: constants$6,
  kylin: constants$7,
  fio: constants$3
}, _chainToNetworkConsta['eos-test'] = constants$8, _chainToNetworkConsta['proton-test'] = constants$9, _chainToNetworkConsta['wax-test'] = constants$a, _chainToNetworkConsta['fio-test'] = constants$b, _chainToNetworkConsta);
var Constants = /*#__PURE__*/function () {
  function Constants() {
    if (!!Constants.instance) {
      return Constants.instance;
    }
  }

  var _proto = Constants.prototype;

  _proto.initialize = function initialize(chain) {
    if (!chain || !chainToNetworkConstantsMap[chain]) {
      chain = DEFAULT_CHAIN;
    }

    this.setNetwork(chain);
    this.setCommon(chain);
  };

  _proto.setNetwork = function setNetwork(chain) {
    // const networkConstants = await import(`'./networks/${chain}`)
    var networkConstants = chainToNetworkConstantsMap[chain];
    this.setConstants(networkConstants);
    this.setContract(chain, networkConstants.SYSTEM_DOMAIN);
  };

  _proto.setCommon = function setCommon(chain) {
    var commonConstants = getCommonConstants(chain);
    this.setConstants(commonConstants);
  };

  _proto.setContract = function setContract(chain, systemDomain) {
    if (systemDomain === void 0) {
      systemDomain = DEFAULT_SYSTEM_DOMAIN;
    }

    var contractConstants = getContractConstants(chain, systemDomain);
    this.setConstants(contractConstants);
  };

  _proto.setConstants = function setConstants(newConstants) {
    for (var _i = 0, _Object$entries = Object.entries(newConstants); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];
      this[key] = value;
    }
  };

  return Constants;
}();
var constants$c = /*#__PURE__*/new Constants();


//# sourceMappingURL=constants.esm.js.map


/***/ }),

/***/ "./node_modules/@bloks/numbers/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@bloks/numbers/dist/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



if (false) {} else {
  module.exports = __webpack_require__(/*! ./numbers.cjs.development.js */ "./node_modules/@bloks/numbers/dist/numbers.cjs.development.js")
}


/***/ }),

/***/ "./node_modules/@bloks/numbers/dist/numbers.cjs.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bloks/numbers/dist/numbers.cjs.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bignumber_js = __webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js");
var numbro = _interopDefault(__webpack_require__(/*! @jafri/numbro */ "./node_modules/@jafri/numbro/dist/numbro.min.js"));
var dayjs = _interopDefault(__webpack_require__(/*! dayjs */ "./node_modules/dayjs/dayjs.min.js"));
var relativeTimePlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/relativeTime */ "./node_modules/dayjs/plugin/relativeTime.js"));
var utcPlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/utc */ "./node_modules/dayjs/plugin/utc.js"));
var timezonePlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/timezone */ "./node_modules/dayjs/plugin/timezone.js"));
var advancedFormatPlugin = _interopDefault(__webpack_require__(/*! dayjs/plugin/advancedFormat */ "./node_modules/dayjs/plugin/advancedFormat.js"));

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var assert = function assert(isTrue, error) {
  if (isTrue) {
    return;
  } else {
    throw new Error(error);
  }
};

(function (Maths) {
  var Operations;

  (function (Operations) {
    Operations["PLUS"] = "plus";
    Operations["MULTIPLY"] = "multipliedBy";
    Operations["DIVIDE"] = "dividedBy";
    Operations["MINUS"] = "minus";
  })(Operations = Maths.Operations || (Maths.Operations = {}));
})(exports.Maths || (exports.Maths = {}));

var Asset = /*#__PURE__*/function () {
  function Asset(asset) {
    this.symbol = new Symbol$1({
      code: asset.code,
      precision: asset.precision
    });
    this.amount = new bignumber_js.BigNumber(asset.amount);
  }

  Asset.fromString = function fromString(asset) {
    var _asset$split = asset.split(' '),
        amount = _asset$split[0],
        code = _asset$split[1];

    var precision = (amount.split('.')[1] || []).length;
    return new Asset({
      code: code,
      precision: precision,
      amount: new bignumber_js.BigNumber(amount)
    });
  };

  Asset.fromSymbol = function fromSymbol(_ref) {
    var symbol = _ref.symbol,
        amount = _ref.amount;

    if (!(symbol instanceof Symbol$1)) {
      throw new Error('Invalid symbol');
    }

    return new Asset({
      code: symbol.code,
      precision: symbol.precision,
      amount: amount
    });
  };

  var _proto = Asset.prototype;

  _proto.isEqualTo = function isEqualTo(asset) {
    return this.isLooselyEqualTo(asset) && this.amount == asset.amount;
  };

  _proto.isLooselyEqualTo = function isLooselyEqualTo(asset) {
    return this.symbol.isEqualTo(asset.symbol);
  };

  _proto.toString = function toString() {
    return new bignumber_js.BigNumber(this.amount).toFixed(this.symbol.precision, bignumber_js.BigNumber.ROUND_DOWN) + " " + this.symbol.code;
  };

  _proto.modifyAmount = function modifyAmount(x, method) {
    var amount = new bignumber_js.BigNumber(0);

    if (typeof x === "number" || bignumber_js.BigNumber.isBigNumber(x)) {
      amount = new bignumber_js.BigNumber(x);
    }

    if (x instanceof Asset) {
      assert(this.isLooselyEqualTo(x), "invalid symbol");
      amount = new bignumber_js.BigNumber(x.amount);
    }

    return Asset.fromSymbol({
      symbol: this.symbol,
      amount: this.amount[method](amount)
    });
  };

  _proto.plus = function plus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.PLUS);
  };

  _proto.minus = function minus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MINUS);
  };

  _proto.multipliedBy = function multipliedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MULTIPLY);
  };

  _proto.dividedBy = function dividedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.DIVIDE);
  };

  _createClass(Asset, [{
    key: "integerAmount",
    get: function get() {
      var factor = Math.pow(10, this.symbol.precision);
      return this.amount.multipliedBy(factor);
    }
  }]);

  return Asset;
}();
var ExtendedAsset = /*#__PURE__*/function () {
  function ExtendedAsset(extendedAsset) {
    if (!(extendedAsset.quantity instanceof Asset)) {
      throw new Error('Invalid quantity');
    }

    this.quantity = extendedAsset.quantity;
    this.contract = extendedAsset.contract;
  }

  ExtendedAsset.fromRaw = function fromRaw(_ref2) {
    var quantity = _ref2.quantity,
        contract = _ref2.contract;
    return new ExtendedAsset({
      quantity: Asset.fromString(quantity),
      contract: contract
    });
  };

  ExtendedAsset.fromExtendedSymbol = function fromExtendedSymbol(symbol, amount) {
    if (!(symbol instanceof ExtendedSymbol)) {
      throw new Error('Invalid extended symbol');
    }

    return new ExtendedAsset({
      quantity: Asset.fromSymbol({
        symbol: symbol.sym,
        amount: amount
      }),
      contract: symbol.contract
    });
  };

  var _proto2 = ExtendedAsset.prototype;

  _proto2.isEqualTo = function isEqualTo(extendedAsset) {
    return this.contract === extendedAsset.contract && this.quantity.isEqualTo(extendedAsset.quantity);
  };

  _proto2.isLooselyEqualTo = function isLooselyEqualTo(extendedAsset) {
    return this.contract === extendedAsset.contract && this.quantity.isLooselyEqualTo(extendedAsset.quantity);
  };

  _proto2.toString = function toString() {
    return this.quantity.toString() + "@" + this.contract;
  };

  _proto2.toExtendedSymbol = function toExtendedSymbol() {
    return new ExtendedSymbol(this.quantity.symbol, this.contract);
  };

  _proto2.modifyAmount = function modifyAmount(x, method) {
    var amount = new bignumber_js.BigNumber(0);

    if (x instanceof ExtendedAsset) {
      assert(this.isLooselyEqualTo(x), "invalid contract or symbol");
      amount = x.quantity;
    } else {
      amount = x;
    }

    return new ExtendedAsset({
      contract: this.contract,
      quantity: this.quantity.modifyAmount(amount, method)
    });
  };

  _proto2.plus = function plus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.PLUS);
  };

  _proto2.minus = function minus(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MINUS);
  };

  _proto2.multipliedBy = function multipliedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.MULTIPLY);
  };

  _proto2.dividedBy = function dividedBy(x) {
    return this.modifyAmount(x, exports.Maths.Operations.DIVIDE);
  };

  return ExtendedAsset;
}();
var Symbol$1 = /*#__PURE__*/function () {
  function Symbol(symbol) {
    this.precision = symbol.precision;
    this.code = symbol.code;
  }

  Symbol.fromString = function fromString(symbol) {
    var _symbol$split = symbol.split(','),
        precision = _symbol$split[0],
        code = _symbol$split[1];

    return new Symbol({
      precision: +precision,
      code: code
    });
  };

  var _proto3 = Symbol.prototype;

  _proto3.isEqualTo = function isEqualTo(symbol) {
    return this.code === symbol.code && this.precision === symbol.precision;
  };

  _proto3.toString = function toString() {
    return this.precision + "," + this.code;
  };

  return Symbol;
}();
var ExtendedSymbol = /*#__PURE__*/function () {
  function ExtendedSymbol(sym, contract) {
    this.sym = sym;
    this.contract = contract;
  }

  ExtendedSymbol.fromRaw = function fromRaw(_ref3) {
    var sym = _ref3.sym,
        contract = _ref3.contract;
    return new ExtendedSymbol(Symbol$1.fromString(sym), contract);
  };

  var _proto4 = ExtendedSymbol.prototype;

  _proto4.isEqualTo = function isEqualTo(extendedSymbol) {
    return this.sym.isEqualTo(extendedSymbol.sym) && this.contract === extendedSymbol.contract;
  };

  _proto4.toString = function toString() {
    return this.sym.toString() + "@" + this.contract;
  };

  return ExtendedSymbol;
}();

var currencyMap = {
  // Fiat
  GBP: {
    symbol: '£',
    precision: 2
  },
  EUR: {
    symbol: '€',
    precision: 2
  },
  JPY: {
    symbol: '¥',
    precision: 0
  },
  CAD: {
    symbol: 'CA$',
    precision: 2
  },
  USD: {
    symbol: '$',
    precision: 2
  },
  INR: {
    symbol: '₹',
    precision: 2
  },
  CNY: {
    symbol: 'CN¥',
    precision: 2
  },
  HKD: {
    symbol: 'HK$',
    precision: 2
  },
  KRW: {
    symbol: '₩',
    precision: 0
  },
  AUD: {
    symbol: 'AUD$',
    precision: 2
  },
  SAR: {
    symbol: 'SR',
    precision: 2
  },
  // Crypto
  ETH: {
    symbol: 'Ξ',
    precision: 4
  },
  BTC: {
    symbol: '₿',
    precision: 8
  },
  EOS: {
    symbol: 'EOS',
    precision: 4
  }
};
var assetFormat = {
  decimalSeparator: '.',
  groupSeparator: ',',
  groupSize: 3
};

function toBN(number) {
  return new bignumber_js.BigNumber(number);
}
function numberToAmount(number, precision, round) {
  if (round === void 0) {
    round = bignumber_js.BigNumber.ROUND_DOWN;
  }

  if (number === undefined || typeof number === "number" && isNaN(number)) {
    number = 0;
  }

  return new bignumber_js.BigNumber(number).toFixed(precision, round);
}
function numberToAmountFormatted(number, precision, round) {
  if (round === void 0) {
    round = bignumber_js.BigNumber.ROUND_DOWN;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  return new bignumber_js.BigNumber(number).toFormat(precision, round, assetFormat);
}
function calculatePercentage(balance, percentage, precision) {
  var _final = new bignumber_js.BigNumber(balance).multipliedBy(percentage);

  return numberToAmount(_final, precision, bignumber_js.BigNumber.ROUND_DOWN);
}
function eosDisplayFormatting(value, symbol, precision) {
  return numberToAmountFormatted(value, precision) + " " + symbol;
}
function numberToEos(number, symbol, precision) {
  return numberToAmount(number, precision) + " " + symbol;
}
function numberToEosRoundUp(number, symbol, precision) {
  return numberToAmount(number, precision, bignumber_js.BigNumber.ROUND_UP) + " " + symbol;
}
function parseRex(rex) {
  return new bignumber_js.BigNumber(rex).dividedBy(10000);
}
/**
 * Converts USD to { symbol: "USD", precision: 4 }
 * @param {*} currency
 */

function currencyToSymbol(currency) {
  return currencyMap[currency];
}
/**
 * Converts "1000.0000 EOS" to { amount: 1000, symbol: { code: "EOS", precision: 4 }}
 * @param {*} quantity
 */

function split(quantity) {
  var _quantity$split = quantity.split(' '),
      amount = _quantity$split[0],
      code = _quantity$split[1];

  var precision = (amount.split('.')[1] || []).length;
  return {
    amount: +amount,
    symbol: {
      code: code,
      precision: precision
    }
  };
}
function toNumbro(number) {
  return numbro(number);
}
/**
 * Converts 1000 to "1000.0000 EOS"
 * @param {*} asset
 */

function numberToAsset(number, symbol, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  var amount = numbro(number).format({
    thousandSeparated: false,
    mantissa: precision,
    trimMantissa: trimMantissa
  });
  return amount + " " + symbol;
}
/**
 * DISPLAY FUNCTIONS
 */

/**
 * Converts 1000 to 1,000
 * @param {*} number
 */

function displayNumber(number, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  return numbro(number).format({
    thousandSeparated: true,
    trimMantissa: trimMantissa
  });
}
/**
 * Converts 1000 to $1,000 USD
 * @param {*} number
 */

function displayNumberAsCurrency(_ref) {
  var number = _ref.number,
      precision = _ref.precision,
      _ref$average = _ref.average,
      average = _ref$average === void 0 ? false : _ref$average,
      _ref$lowPrecision = _ref.lowPrecision,
      lowPrecision = _ref$lowPrecision === void 0 ? true : _ref$lowPrecision,
      _ref$trimMantissa = _ref.trimMantissa,
      trimMantissa = _ref$trimMantissa === void 0 ? false : _ref$trimMantissa,
      _ref$currency = _ref.currency,
      currency = _ref$currency === void 0 ? 'USD' : _ref$currency;

  if (!currencyMap[currency]) {
    throw new Error('Unsupported currency');
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  var _currencyMap$currency = currencyMap[currency],
      symbol = _currencyMap$currency.symbol,
      defaultPrecision = _currencyMap$currency.precision;
  var format = {
    thousandSeparated: true,
    mantissa: precision !== undefined ? precision : defaultPrecision,
    trimMantissa: trimMantissa,
    average: average
  };

  if (average) {
    format.lowPrecision = lowPrecision;
  }

  var formattedNumber = numbro(number).format(format);
  return "" + symbol + formattedNumber;
}
/**
 * Converts "1000.0000 EOS" to "1,000.0000 EOS"
 * @param {*} asset
 */

function displayAsset(asset) {
  var _split = split(asset),
      amount = _split.amount,
      code = _split.symbol.code;

  return displayNumber(amount) + " " + code;
}
/**
 * Converts 1000 to 1,000.0000
 * @param {*} number
 */

function displayNumberAsAmount(number, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  return numbro(number).format({
    thousandSeparated: true,
    mantissa: precision,
    trimMantissa: trimMantissa
  });
}
/**
 * Converts 1000 to "1,000.0000 EOS"
 * @param {*} number
 */

function displayNumberAsAsset(number, symbol, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  if (number === undefined || isNaN(number)) {
    number = 0;
  }

  var amount = numbro(number).format({
    thousandSeparated: true,
    mantissa: precision,
    trimMantissa: trimMantissa
  });
  return amount + " " + symbol;
}
/**
 * Converts 10000000 to "1,000.0000 EOS"
 * @param {*} number
 */

function displayRawNumberAsAsset(number, symbol, precision, trimMantissa) {
  if (trimMantissa === void 0) {
    trimMantissa = false;
  }

  return displayNumberAsAsset(number / Math.pow(10, precision), symbol, precision, trimMantissa);
}

bignumber_js.BigNumber.set({
  ROUNDING_MODE: 1
});
function add() {
  var start = new bignumber_js.BigNumber(0);

  for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
    numbers[_key] = arguments[_key];
  }

  if (numbers.length) {
    for (var _iterator = _createForOfIteratorHelperLoose(numbers), _step; !(_step = _iterator()).done;) {
      var number = _step.value;
      start = start.plus(number);
    }
  }

  return start;
}
function substract(a, b) {
  return new bignumber_js.BigNumber(a).minus(b);
}
function multiply(a, b) {
  return new bignumber_js.BigNumber(a).multipliedBy(b);
}
function divide(a, b) {
  return new bignumber_js.BigNumber(a).dividedBy(b);
}

function bytesToKB(bytes) {
  if (bytes === void 0) {
    bytes = 0;
  }

  return numbro(bytes / 1024).format({
    thousandSeparated: false,
    mantissa: 2
  });
}
function parseNetAndRam(bytes) {
  var parsedValue = 0;
  var parsedText = '';

  if (bytes < 1024) {
    parsedValue = bytes;
    parsedText = 'Bytes';
  } else if (bytes < 1048576) {
    parsedValue = bytes / 1024;
    parsedText = 'KB';
  } else if (bytes < 1073741824) {
    parsedValue = bytes / 1048576;
    parsedText = 'MB';
  } else if (bytes < 1099511627776) {
    parsedValue = bytes / 1073741824;
    parsedText = 'GB';
  } else if (bytes < 1125899906842624) {
    parsedValue = bytes / 1099511627776;
    parsedText = 'TB';
  }

  return displayNumberAsAmount(parsedValue, 2, true) + " " + parsedText;
}
function parseCpu(us) {
  var parsedValue = 0;
  var parsedText = '';

  if (us < 1000) {
    parsedValue = us;
    parsedText = 'µs';
  } else if (us < 1000000) {
    parsedValue = us / 1000;
    parsedText = 'ms';
  } else if (us < 60000000) {
    parsedValue = us / 1000000;
    parsedText = 's';
  } else if (us < 3600000000) {
    parsedValue = us / 60000000;
    parsedText = 'min';
  } else if (us < 3600000000000) {
    parsedValue = us / 3600000000;
    parsedText = 'hours';
  } else {
    parsedValue = us / 86400000000;
    parsedText = 'days';
  }

  return displayNumberAsAmount(parsedValue, 2, true) + " " + parsedText;
}

dayjs.extend(relativeTimePlugin);
dayjs.extend(utcPlugin);
dayjs.extend(timezonePlugin);
dayjs.extend(advancedFormatPlugin);
var COMMON_DATE_FORMAT = 'MMM-DD-YYYY, hh:mm:ss A';
/**
 * Time utilities
 */

function time(date) {
  return dayjs(date);
}
function utcTime(date) {
  return dayjs(date).utc();
}
function utcTimeToLocal(date) {
  return dayjs(date).local();
}
function unixTime(unixTimestamp) {
  return dayjs.unix(unixTimestamp);
}
function formatDate(date, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return dayjs(date).format(format);
}
function formatDateLocal(date, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return dayjs(date).utc().format(format);
}
function timestampToDate(timestamp) {
  return new Date(timestamp);
}
function utcTimestampToDate(timestamp) {
  timestamp = timestamp.slice(-1) === 'Z' ? timestamp : timestamp + 'Z';
  return new Date(timestamp);
}
function timestampFromNow(timestamp) {
  return time(timestamp).fromNow();
}
function utcTimestampFromNow(timestamp) {
  timestamp = timestamp.slice(-1) === 'Z' ? timestamp : timestamp + 'Z';
  return time(timestamp).fromNow();
}
function parseTimestamp(timestamp, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return formatDate(timestampToDate(timestamp), format);
}
function parseUtcTimestamp(timestamp, format) {
  if (format === void 0) {
    format = COMMON_DATE_FORMAT;
  }

  return formatDate(utcTimestampToDate(timestamp), format);
}
function inFuture(date, utc) {
  if (utc === void 0) {
    utc = false;
  }

  return utc ? utcTime(date).isAfter(utcTime()) : time(date).isAfter(time());
}
function inPast(date, utc) {
  if (utc === void 0) {
    utc = false;
  }

  return utc ? utcTime(date).isBefore(utcTime()) : time(date).isBefore(time());
}
function isSameDay(start, end) {
  if (end === void 0) {
    end = time();
  }

  return dayjs(start).isSame(dayjs(end), 'day');
} // Seconds till now if second param empty

function secondsFrom(start, end) {
  if (end === void 0) {
    end = time();
  }

  return dayjs(start).diff(dayjs(end), 'second');
}
function millisecondsFrom(start, end) {
  if (end === void 0) {
    end = time();
  }

  return dayjs(start).diff(dayjs(end));
}
/**
 * Specific to EOS
 */

function startDate(startDate, days) {
  if (days === void 0) {
    days = 3;
  }

  return dayjs(startDate).clone().subtract(days, 'days');
}
function formatStartDate(startTimestamp) {
  return startDate(startTimestamp).format('MMM-DD-YYYY, hh:mm:ss A');
}
function endDate(endDate, days) {
  if (days === void 0) {
    days = 3;
  }

  return dayjs(endDate).clone().add(days, 'days');
}
function formatEndDate(endTimestamp) {
  return endDate(endTimestamp).format('MMM-DD-YYYY, hh:mm:ss A');
}
function dateToUtcTimePoint(date) {
  if (date === void 0) {
    date = time();
  }

  return dayjs(date).utc().format('YYYY-MM-DDTHH:mm:ss.SSS');
}
var emptyTimePoint = '1970-01-01T00:00:00.000';
function parseSeconds(seconds) {
  var days = 0;
  var hours = 0;
  var minutes = 0;
  var parsedDate = ''; // Days

  if (seconds > 86400) {
    days += Math.floor(seconds / 86400);
    seconds -= days * 86400;
    parsedDate += days.toFixed(0) + " " + (days === 1 ? 'Day' : 'Days') + " ";
  } // Hours


  if (seconds > 3600) {
    hours += Math.floor(seconds / 3600);
    seconds -= hours * 3600;
    parsedDate += hours.toFixed(0) + " " + (hours === 1 ? 'Hour' : 'Hours') + " ";
  } // Minutes


  if (seconds > 60) {
    minutes += Math.floor(seconds / 60);
    seconds -= minutes * 60;
    parsedDate += minutes.toFixed(0) + " " + (minutes === 1 ? 'Minute' : 'Minutes') + " ";
  } // Seconds


  if (seconds > 0) {
    parsedDate += seconds.toFixed(0) + " Seconds ";
  }

  return parsedDate;
}

exports.Asset = Asset;
exports.ExtendedAsset = ExtendedAsset;
exports.ExtendedSymbol = ExtendedSymbol;
exports.Symbol = Symbol$1;
exports.add = add;
exports.bytesToKB = bytesToKB;
exports.calculatePercentage = calculatePercentage;
exports.currencyToSymbol = currencyToSymbol;
exports.dateToUtcTimePoint = dateToUtcTimePoint;
exports.displayAsset = displayAsset;
exports.displayNumber = displayNumber;
exports.displayNumberAsAmount = displayNumberAsAmount;
exports.displayNumberAsAsset = displayNumberAsAsset;
exports.displayNumberAsCurrency = displayNumberAsCurrency;
exports.displayRawNumberAsAsset = displayRawNumberAsAsset;
exports.divide = divide;
exports.emptyTimePoint = emptyTimePoint;
exports.endDate = endDate;
exports.eosDisplayFormatting = eosDisplayFormatting;
exports.formatDate = formatDate;
exports.formatDateLocal = formatDateLocal;
exports.formatEndDate = formatEndDate;
exports.formatStartDate = formatStartDate;
exports.inFuture = inFuture;
exports.inPast = inPast;
exports.isSameDay = isSameDay;
exports.millisecondsFrom = millisecondsFrom;
exports.multiply = multiply;
exports.numberToAmount = numberToAmount;
exports.numberToAmountFormatted = numberToAmountFormatted;
exports.numberToAsset = numberToAsset;
exports.numberToEos = numberToEos;
exports.numberToEosRoundUp = numberToEosRoundUp;
exports.parseCpu = parseCpu;
exports.parseNetAndRam = parseNetAndRam;
exports.parseRex = parseRex;
exports.parseSeconds = parseSeconds;
exports.parseTimestamp = parseTimestamp;
exports.parseUtcTimestamp = parseUtcTimestamp;
exports.secondsFrom = secondsFrom;
exports.split = split;
exports.startDate = startDate;
exports.substract = substract;
exports.time = time;
exports.timestampFromNow = timestampFromNow;
exports.timestampToDate = timestampToDate;
exports.toBN = toBN;
exports.toNumbro = toNumbro;
exports.unixTime = unixTime;
exports.utcTime = utcTime;
exports.utcTimeToLocal = utcTimeToLocal;
exports.utcTimestampFromNow = utcTimestampFromNow;
exports.utcTimestampToDate = utcTimestampToDate;
//# sourceMappingURL=numbers.cjs.development.js.map


/***/ }),

/***/ "./node_modules/@bloks/utils/dist/utils.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/@bloks/utils/dist/utils.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DbopOp": () => (/* binding */ DbopOp),
/* harmony export */   "Nft": () => (/* binding */ Nft),
/* harmony export */   "bytesToString": () => (/* binding */ bytesToString),
/* harmony export */   "charidx": () => (/* binding */ charidx),
/* harmony export */   "cloneDeepArrayOfObj": () => (/* binding */ cloneDeepArrayOfObj),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "decodeName": () => (/* binding */ decodeName),
/* harmony export */   "dfuseDepthFirstExtract": () => (/* binding */ dfuseDepthFirstExtract),
/* harmony export */   "dfuseTransformDeferredAction": () => (/* binding */ dfuseTransformDeferredAction),
/* harmony export */   "dfuseTransformDeferredTransaction": () => (/* binding */ dfuseTransformDeferredTransaction),
/* harmony export */   "dfuseTransformGetActions": () => (/* binding */ dfuseTransformGetActions),
/* harmony export */   "dfuseTransformTrace": () => (/* binding */ dfuseTransformTrace),
/* harmony export */   "dfuseTransformTransaction": () => (/* binding */ dfuseTransformTransaction),
/* harmony export */   "dfuseTransformTransactionResult": () => (/* binding */ dfuseTransformTransactionResult),
/* harmony export */   "encodeName": () => (/* binding */ encodeName),
/* harmony export */   "fioKeyToActor": () => (/* binding */ fioKeyToActor),
/* harmony export */   "hexToUint8Array": () => (/* binding */ hexToUint8Array),
/* harmony export */   "historyTransformDeferredAction": () => (/* binding */ historyTransformDeferredAction),
/* harmony export */   "historyTransformDeferredTransaction": () => (/* binding */ historyTransformDeferredTransaction),
/* harmony export */   "historyTransformFlatTraces": () => (/* binding */ historyTransformFlatTraces),
/* harmony export */   "historyTransformRecursiveTrace": () => (/* binding */ historyTransformRecursiveTrace),
/* harmony export */   "historyTransformTransaction": () => (/* binding */ historyTransformTransaction),
/* harmony export */   "hyperionTransformFlatTraces": () => (/* binding */ hyperionTransformFlatTraces),
/* harmony export */   "hyperionTransformGetActions": () => (/* binding */ hyperionTransformGetActions),
/* harmony export */   "hyperionTransformTransaction": () => (/* binding */ hyperionTransformTransaction),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "nativeTransformGetActions": () => (/* binding */ nativeTransformGetActions),
/* harmony export */   "parseAaNft": () => (/* binding */ parseAaNft),
/* harmony export */   "parseSaNft": () => (/* binding */ parseSaNft),
/* harmony export */   "sha": () => (/* binding */ sha),
/* harmony export */   "string_to_uint128_hash": () => (/* binding */ string_to_uint128_hash),
/* harmony export */   "urlBuilder": () => (/* binding */ urlBuilder),
/* harmony export */   "wait": () => (/* binding */ wait)
/* harmony export */ });
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fast_text_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-text-encoding */ "./node_modules/fast-text-encoding/text.min.js");
/* harmony import */ var fast_text_encoding__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_text_encoding__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(qs__WEBPACK_IMPORTED_MODULE_2__);




function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function cloneDeepArrayOfObj(array) {
  return [].concat(array).map(function (i) {
    return _extends({}, i);
  });
}

var charmap = '.12345abcdefghijklmnopqrstuvwxyz';
function charidx(ch) {
  var idx = charmap.indexOf(ch);

  if (idx === -1) {
    throw new TypeError("Invalid character: '" + ch + "'");
  }

  return idx;
}
function encodeName(name, littleEndian) {
  if (littleEndian === void 0) {
    littleEndian = false;
  }

  if (typeof name !== 'string') {
    throw new TypeError('name parameter is a required string');
  }

  if (name.length > 12) {
    throw new TypeError('A name can be up to 12 characters long');
  }

  var bitstr = '';

  for (var i = 0; i <= 12; i++) {
    // process all 64 bits (even if name is short)
    var c = i < name.length ? charidx(name[i]) : 0;
    var bitlen = i < 12 ? 5 : 4;
    var bits = Number(c).toString(2);

    if (bits.length > bitlen) {
      throw new TypeError('Invalid name ' + name);
    }

    bits = '0'.repeat(bitlen - bits.length) + bits;
    bitstr += bits;
  }

  var value = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(bitstr, true, 2); // convert to LITTLE_ENDIAN

  var leHex = '';
  var bytes = littleEndian ? value.toBytesLE() : value.toBytesBE();

  for (var _iterator = _createForOfIteratorHelperLoose(bytes), _step; !(_step = _iterator()).done;) {
    var b = _step.value;
    var n = Number(b).toString(16);
    leHex += (n.length === 1 ? '0' : '') + n;
  }

  var ulName = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(leHex, true, 16).toString(); // console.log('encodeName', name, value.toString(), ulName.toString(), JSON.stringify(bitstr.split(/(.....)/).slice(1)))

  return ulName.toString();
}
function decodeName(encodedName, littleEndian) {
  if (littleEndian === void 0) {
    littleEndian = true;
  }

  var value = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(encodedName); // convert from LITTLE_ENDIAN

  var beHex = '';
  var bytes = littleEndian ? value.toBytesLE() : value.toBytesBE();

  for (var _iterator2 = _createForOfIteratorHelperLoose(bytes), _step2; !(_step2 = _iterator2()).done;) {
    var b = _step2.value;
    var n = Number(b).toString(16);
    beHex += (n.length === 1 ? '0' : '') + n;
  }

  beHex += '0'.repeat(16 - beHex.length);
  var fiveBits = long__WEBPACK_IMPORTED_MODULE_0___default().fromNumber(0x1f, true);
  var fourBits = long__WEBPACK_IMPORTED_MODULE_0___default().fromNumber(0x0f, true);
  var beValue = long__WEBPACK_IMPORTED_MODULE_0___default().fromString(beHex, true, 16);
  var str = '';
  var tmp = beValue;

  for (var i = 0; i <= 12; i++) {
    var c = charmap[tmp.and(i === 0 ? fourBits : fiveBits)];
    str = c + str;
    tmp = tmp.shiftRight(i === 0 ? 4 : 5);
  }

  str = str.replace(/\.+$/, ''); // remove trailing dots (all of them)
  // console.log('decodeName', str, beValue.toString(), value.toString(), JSON.stringify(beValue.toString(2).split(/(.....)/).slice(1)))

  return str;
}
/**
 * FIO SPECIFIC
 * @param key FIO
 */

var shorten_key = function shorten_key(key) {
  var res = new (long__WEBPACK_IMPORTED_MODULE_0___default())(0, 0, true);
  var i = 1; // Ignore key head

  var len = 0;

  while (len <= 12) {
    if (i >= 33) throw new Error('FIO: i too large');
    var trimmed_char = key[i] & (len == 12 ? 0x0f : 0x1f);

    if (trimmed_char == 0) {
      i++;
      continue;
    } // Skip a zero and move to next


    var shuffle = len == 12 ? 0 : 5 * (12 - len) - 1;
    res = res.or(long__WEBPACK_IMPORTED_MODULE_0___default().fromNumber(shift(trimmed_char, shuffle), true));
    len++;
    i++;
  }

  return res;
};

function shift(number, shift) {
  return number * Math.pow(2, shift);
}

var fioKeyToActor = function fioKeyToActor(key, stringToPublicKey) {
  var pubKey = stringToPublicKey(key, 'FIO').data;
  var shortenedPubKey = shorten_key(pubKey);
  var decodedName = decodeName(shortenedPubKey.toString(), false);
  return decodedName.substr(0, 12);
}; // convert bytes to a String

function bytesToString(bytes) {
  if (typeof bytes === 'string') {
    return bytes;
  }

  return bytes.reduce(function (acc, _byte) {
    return acc + String.fromCharCode(_byte);
  }, '');
}
/**
 * Checks if string
 */

function isString(string) {
  return Object.prototype.toString.call(string) === '[object String]';
}
/**
 *
 * @param message Sha256
 */

function sha(_x, _x2, _x3) {
  return _sha.apply(this, arguments);
}
/**
 * FIO function
 *
 * @param str example: coinomi
 * @returns returns: 968ba84617b73b8e2a73b59170976f41
 */

function _sha() {
  _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(message, binaryRepresentationOfHex, type) {
    var encodedMessage, matched, mapped, hashBuffer, hashArray, hashHex;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (binaryRepresentationOfHex === void 0) {
              binaryRepresentationOfHex = false;
            }

            if (type === void 0) {
              type = 'SHA-256';
            }

            if (!binaryRepresentationOfHex) {
              _context.next = 10;
              break;
            }

            matched = message.match(/[\da-f]{2}/gi);

            if (matched) {
              _context.next = 6;
              break;
            }

            throw Error('Empty message');

          case 6:
            mapped = matched.map(function (h) {
              return parseInt(h, 16);
            });
            encodedMessage = new Uint8Array(mapped);
            _context.next = 11;
            break;

          case 10:
            encodedMessage = new TextEncoder().encode(message);

          case 11:
            _context.next = 13;
            return crypto.subtle.digest(type, encodedMessage);

          case 13:
            hashBuffer = _context.sent;
            // hash the message
            hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array

            hashHex = hashArray.map(function (b) {
              return b.toString(16).padStart(2, '0');
            }).join(''); // convert bytes to hex string

            return _context.abrupt("return", hashHex);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _sha.apply(this, arguments);
}

function string_to_uint128_hash(_x4) {
  return _string_to_uint128_hash.apply(this, arguments);
}

function _string_to_uint128_hash() {
  _string_to_uint128_hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(str) {
    var hexBytes;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return sha(str, false, 'SHA-1');

          case 2:
            hexBytes = _context2.sent.match(/../g);

            if (!hexBytes) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", hexBytes.slice(0, -4).reverse().join(''));

          case 7:
            return _context2.abrupt("return", 0);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _string_to_uint128_hash.apply(this, arguments);
}

function nativeTransformGetActions(result, constants) {
  result.actions = result.actions.map(function (action) {
    if (action['action_trace']['act']['account'] === constants.EOSIO && action['action_trace']['act']['name'] === 'claimrewards' && action['action_trace']['inline_traces']) {
      var totalAmount = 0;
      var totalSymbol = '';

      for (var _iterator = _createForOfIteratorHelperLoose(action['action_trace']['inline_traces']), _step; !(_step = _iterator()).done;) {
        var inline_trace = _step.value;

        if (inline_trace['act']['data']['from'] === constants.EOSIO_VPAY || inline_trace['act']['data']['from'] === constants.EOSIO_BPAY) {
          var _inline_trace$act$dat = inline_trace['act']['data']['quantity'].split(' '),
              amount = _inline_trace$act$dat[0],
              symbol = _inline_trace$act$dat[1];

          totalAmount += Number(amount);
          totalSymbol = symbol;
        }
      }

      action['action_trace']['act']['data']['quantity'] = totalAmount.toFixed(constants.CORE_PRECISION) + " " + totalSymbol;
    }

    return action;
  }).reverse();
  result.numOfTxLoaded = result.actions.length;
  return result;
}
function hyperionTransformGetActions(_ref) {
  var query_time = _ref.query_time,
      lib = _ref.lib,
      actions = _ref.actions,
      _ref$total = _ref.total,
      relation = _ref$total.relation,
      value = _ref$total.value;
  var transformedActions = [];
  var act_digest = 0;

  for (var _iterator2 = _createForOfIteratorHelperLoose(actions), _step2; !(_step2 = _iterator2()).done;) {
    var action = _step2.value;
    action.receipt = {
      act_digest: act_digest++
    };
    action.block_time = action['@timestamp']; // Set quantity

    if (action.act.data && action.act.data.amount && action.act.data.symbol) {
      action.act.data.quantity = action.act.data.amount + " " + action.act.data.symbol;
    }

    transformedActions.push({
      action_trace: action
    });
  }

  return {
    lib: lib,
    actions: transformedActions,
    query_time: query_time,
    numOfTxLoaded: actions.length,
    total: {
      relation: relation,
      value: value
    }
  };
}
function dfuseTransformGetActions(_ref2, accountName, constants) {
  var transactions = _ref2.transactions,
      cursor = _ref2.cursor;

  // Error checking
  if (!transactions) {
    return {
      cursor: cursor,
      actions: [],
      numOfTxLoaded: 0
    };
  }

  var actions = [];

  for (var _iterator3 = _createForOfIteratorHelperLoose(transactions), _step3; !(_step3 = _iterator3()).done;) {
    var transaction = _step3.value;
    var lifecycle = transaction.lifecycle,
        action_idx = transaction.action_idx; // GRAPHQL -> DOesnt give action_idx since its match

    if (!action_idx) {
      actions = actions.concat(lifecycle['execution_trace']['action_traces'].map(function (action) {
        return {
          action_trace: action
        };
      }).reverse());
      continue;
    }

    var current_idx = 0;

    for (var _iterator4 = _createForOfIteratorHelperLoose(lifecycle['execution_trace']['action_traces']), _step4; !(_step4 = _iterator4()).done;) {
      var action_trace = _step4.value;
      // Fix holes
      if (!action_trace['inline_traces']) action_trace['inline_traces'] = []; // BP CLAIM REWARDS

      if (action_trace['act']['account'] === constants.EOSIO && action_trace['act']['name'] === 'claimrewards') {
        var totalAmount = 0;
        var totalSymbol = '';

        for (var _iterator5 = _createForOfIteratorHelperLoose(action_trace['inline_traces']), _step5; !(_step5 = _iterator5()).done;) {
          var inline_trace = _step5.value;

          if (inline_trace['act']['data']['from'] === constants.EOSIO_VPAY || inline_trace['act']['data']['from'] === constants.EOSIO_BPAY) {
            actions.push({
              action_trace: inline_trace
            });

            var _inline_trace$act$dat2 = inline_trace['act']['data']['quantity'].split(' '),
                amount = _inline_trace$act$dat2[0],
                symbol = _inline_trace$act$dat2[1];

            totalAmount += Number(amount);
            totalSymbol = symbol;
          }
        }

        action_trace['act']['data']['quantity'] = totalAmount.toFixed(constants.CORE_PRECISION) + " " + totalSymbol;
        delete action_trace.inline_traces;
        actions.push({
          action_trace: action_trace
        }); // REX sell
      } else if (action_trace['act']['account'] === constants.EOSIO && action_trace['act']['name'] === 'sellrex') {
        for (var _iterator6 = _createForOfIteratorHelperLoose(action_trace['inline_traces']), _step6; !(_step6 = _iterator6()).done;) {
          var _inline_trace = _step6.value;

          if (_inline_trace['act']['account'] === constants.EOSIO_REX || _inline_trace['act']['name'] === 'sellresult') {
            actions.push({
              action_trace: _inline_trace
            });
          }
        }

        delete action_trace.inline_traces;
        actions.push({
          action_trace: action_trace
        });
      } else {
        // This is done for ordering of TX
        var local_actions = [];
        current_idx = dfuseExtractActions(accountName, action_trace, local_actions, action_idx, current_idx);
        actions = actions.concat(local_actions.reverse());
      }

      current_idx++;
    }
  }

  return {
    cursor: cursor,
    actions: actions,
    numOfTxLoaded: transactions.length
  };
}

function dfuseExtractActions(accountName, action, traces, action_idx, current_idx) {
  if (action_idx.includes(current_idx)) {
    traces.push({
      action_trace: action
    });
  }

  if (action['inline_traces']) {
    for (var _iterator7 = _createForOfIteratorHelperLoose(action['inline_traces']), _step7; !(_step7 = _iterator7()).done;) {
      var inline_trace = _step7.value;
      current_idx++;
      current_idx = dfuseExtractActions(accountName, inline_trace, traces, action_idx, current_idx);
    }

    delete action['inline_traces'];
  }

  return current_idx;
}

function dfuseDepthFirstExtract(result) {
  var transactions = result.transactions,
      cursor = result.cursor;
  var actions = [];

  if (transactions) {
    for (var _iterator8 = _createForOfIteratorHelperLoose(transactions), _step8; !(_step8 = _iterator8()).done;) {
      var transaction = _step8.value;
      var lifecycle = transaction.lifecycle,
          action_idx = transaction.action_idx;
      var traces = lifecycle['execution_trace']['action_traces'];
      var current_idx = 0;

      for (var _iterator9 = _createForOfIteratorHelperLoose(traces), _step9; !(_step9 = _iterator9()).done;) {
        var trace = _step9.value;
        current_idx = dfuseDepthFirstExtractHelper(trace, lifecycle['dbops'], actions, action_idx, current_idx);
        current_idx++;
      }
    }
  }

  return {
    actions: actions,
    cursor: cursor
  };
}

function dfuseDepthFirstExtractHelper(action, dbops, allActions, action_idx, currentIdx) {
  if (action_idx && action_idx.includes(currentIdx)) {
    allActions.push({
      action_trace: action,
      dbops: dbops.filter(function (op) {
        return op.action_idx === currentIdx;
      })
    });
  }

  if (action['inline_traces']) {
    for (var _iterator10 = _createForOfIteratorHelperLoose(action['inline_traces']), _step10; !(_step10 = _iterator10()).done;) {
      var trace = _step10.value;
      currentIdx = dfuseDepthFirstExtractHelper(trace, dbops, allActions, action_idx, ++currentIdx);
    }
  }

  return currentIdx;
}

function hyperionTransformFlatTraces(traces) {
  var tracesByOrdinal = traces.reduce(function (acc, trace) {
    acc[trace.action_ordinal] = _extends({}, trace, {
      traces: [],
      account_ram_deltas: trace.account_ram_deltas,
      receivers: trace.notified
    });
    return acc;
  }, {});

  for (var _iterator11 = _createForOfIteratorHelperLoose(traces.sort(function (a, b) {
    return b.action_ordinal - a.action_ordinal;
  })), _step11; !(_step11 = _iterator11()).done;) {
    var trace = _step11.value;

    // Skip top level actions
    if (trace.creator_action_ordinal === 0 || !tracesByOrdinal[trace.creator_action_ordinal]) {
      continue;
    }

    var currentInlineTraces = tracesByOrdinal[trace.creator_action_ordinal].traces || [];
    var newInlineTraces = [tracesByOrdinal[trace.action_ordinal]];
    delete tracesByOrdinal[trace.action_ordinal];
    tracesByOrdinal[trace.creator_action_ordinal].traces = newInlineTraces.concat(currentInlineTraces);
  }

  var result = Object.values(tracesByOrdinal);
  return result;
}
function hyperionTransformTransaction(transaction) {
  var actions = transaction.actions,
      lib = transaction.lib,
      trx_id = transaction.trx_id;
  var firstAction = actions[0]; // Parent only on < 1.8

  var transformedActions = firstAction.parent ? actions.filter(function (trace) {
    return trace.parent === 0;
  }) : actions;
  var traces = hyperionTransformFlatTraces(actions);
  return {
    status: 'Executed',
    cpu_usage: firstAction.cpu_usage_us,
    net_usage: firstAction.net_usage_words * 8,
    id: trx_id,
    block_time: firstAction['@timestamp'],
    block_num: firstAction['block_num'],
    delay_sec: 'N/A',
    expiration: 'N/A',
    lib: lib,
    actions: transformedActions,
    traces: traces
  };
}
function dfuseTransformTrace(_ref3) {
  var trace = _ref3.trace,
      _ref3$dbops = _ref3.dbops,
      dbops = _ref3$dbops === void 0 ? [] : _ref3$dbops,
      _ref3$ramops = _ref3.ramops,
      ramops = _ref3$ramops === void 0 ? [] : _ref3$ramops,
      _ref3$index = _ref3.index,
      index = _ref3$index === void 0 ? 0 : _ref3$index;
  var transformed = {
    act: trace.act,
    account_ram_deltas: trace.account_ram_deltas,
    receivers: [trace.receipt.receiver],
    act_digest: trace.receipt.act_digest,
    dbops: (dbops || []).filter(function (op) {
      return op.action_idx === index;
    }),
    ramops: (ramops || []).filter(function (op) {
      return op.action_idx === index;
    }),
    traces: []
  };

  if (trace.inline_traces && trace.inline_traces.length) {
    trace.inline_traces.map(function (itrace) {
      index++; // If TX data is different

      if (itrace.act.hex_data !== transformed.act.hex_data || itrace.act.name !== transformed.act.name || itrace.act.account !== transformed.act.account) {
        transformed.traces.push(dfuseTransformTrace({
          trace: itrace,
          index: index,
          ramops: ramops,
          dbops: dbops
        })); // Hex data is same, but still add in inline
      } else {
        if (itrace.inline_traces && itrace.inline_traces.length) {
          for (var _iterator12 = _createForOfIteratorHelperLoose(itrace.inline_traces), _step12; !(_step12 = _iterator12()).done;) {
            var iitrace = _step12.value;
            index++;
            transformed.traces.push(dfuseTransformTrace({
              trace: iitrace,
              index: index,
              ramops: ramops,
              dbops: dbops
            }));
          }
        } // Add Receivers even if not different


        if (!transformed.receivers.includes(itrace.receipt.receiver)) {
          transformed.receivers.push(itrace.receipt.receiver);
        } // Add db ops and ram ops even if not different


        transformed.dbops = transformed.dbops.concat((dbops || []).filter(function (op) {
          return op.action_idx === index;
        }));
        transformed.ramops = transformed.ramops.concat((ramops || []).filter(function (op) {
          return op.action_idx === index;
        }));
      }
    });
  }

  return transformed;
}
function dfuseTransformTransaction(result) {
  var execution_trace = result.execution_trace,
      transaction = result.transaction,
      ramops = result.ramops,
      dbops = result.dbops,
      created_by = result.created_by;
  var count = 0;
  var actions = (execution_trace['action_traces'] || []).map(function (trace) {
    var transformedTrace = dfuseTransformTrace({
      trace: trace,
      ramops: ramops,
      dbops: dbops,
      index: count
    }); // Increment counts

    var traceCount = inlineTraceCountHelper([trace]);
    count += traceCount;
    return transformedTrace;
  });
  return {
    status: execution_trace.receipt.status,
    cpu_usage: execution_trace.receipt.cpu_usage_us,
    net_usage: execution_trace.receipt.net_usage_words * 8,
    id: execution_trace.id,
    block_time: execution_trace.block_time,
    block_num: execution_trace.block_num,
    delay_sec: transaction.delay_sec,
    expiration: transaction.expiration,
    created_by: created_by,
    actions: actions,
    traces: actions
  };
}
function dfuseTransformDeferredAction(action) {
  return {
    act: _extends({}, action),
    account_ram_deltas: [],
    receivers: [],
    act_digest: '',
    traces: []
  };
}
function dfuseTransformDeferredTransaction(result) {
  var actions = result.transaction.actions.map(dfuseTransformDeferredAction);
  return {
    id: result.id,
    status: 'deferred',
    dfuse_status: result.transaction_status,
    sender: result.created_by.sender,
    payer: result.created_by.payer,
    published: result.created_by.published_at,
    delay_until: result.created_by.delay_until,
    expiration: result.transaction.expiration,
    delay_sec: result.transaction.delay_sec,
    actions: actions,
    traces: actions
  };
}
function dfuseTransformTransactionResult(result) {
  return result.execution_trace ? dfuseTransformTransaction(result) : dfuseTransformDeferredTransaction(result);
}
function historyTransformDeferredAction(action) {
  return _extends({}, action, {
    account_ram_deltas: [],
    receiver: '',
    act_digest: '',
    traces: []
  });
}
function historyTransformDeferredTransaction(transaction) {
  return {
    id: transaction.trx_id,
    status: 'deferred',
    sender: transaction.sender,
    payer: transaction.payer,
    published: transaction.published,
    expiration: transaction.expiration,
    delay_until: transaction.delay_until,
    delay_sec: transaction.transaction.delay_sec,
    actions: transaction.transaction.actions,
    traces: transaction.transaction.actions.map(function (action) {
      return historyTransformDeferredAction(action);
    })
  };
}
function historyTransformRecursiveTrace(action) {
  var transformed = {
    act: action.act,
    account_ram_deltas: action.account_ram_deltas || [],
    receivers: [action.receipt.receiver],
    act_digest: action.receipt.act_digest,
    traces: []
  };

  if (action.inline_traces && action.inline_traces.length) {
    action.inline_traces.forEach(function (trace) {
      var sameAsParent = trace.receipt.act_digest === action.receipt.act_digest; // Actions done in response to notification -> Add in inline traces

      if (sameAsParent && trace.inline_traces && trace.inline_traces.length) {
        transformed.traces = transformed.traces.concat(trace.inline_traces.map(historyTransformRecursiveTrace));

        if (!transformed.receivers.includes(trace.receipt.receiver)) {
          transformed.receivers.push(trace.receipt.receiver);
        } // Normal action

      } else if (!sameAsParent) {
        transformed.traces.push(historyTransformRecursiveTrace(trace)); // Normal notification
      } else {
        if (!transformed.receivers.includes(trace.receipt.receiver)) {
          transformed.receivers.push(trace.receipt.receiver);
        }
      }
    });
  }

  return transformed;
}
function historyTransformFlatTraces(traces) {
  var tracesByOrdinal = traces.reduce(function (acc, trace) {
    acc[trace.action_ordinal] = trace;
    return acc;
  }, {});

  for (var _iterator13 = _createForOfIteratorHelperLoose(traces.sort(function (a, b) {
    return b.action_ordinal - a.action_ordinal;
  })), _step13; !(_step13 = _iterator13()).done;) {
    var trace = _step13.value;

    // Skip top level actions
    if (trace.creator_action_ordinal === 0) {
      continue;
    }

    var currentInlineTraces = tracesByOrdinal[trace.creator_action_ordinal].inline_traces || [];
    var newInlineTraces = [tracesByOrdinal[trace.action_ordinal]];
    tracesByOrdinal[trace.creator_action_ordinal].inline_traces = newInlineTraces.concat(currentInlineTraces);
  }

  var result = Object.values(tracesByOrdinal).filter(function (trace) {
    return trace.creator_action_ordinal === 0;
  }).map(function (trace) {
    return _extends({}, trace, {
      receivers: [trace.receipt.receiver],
      act_digest: trace.receipt.act_digest
    });
  });
  return result;
}

function findIfSameTx(inline_traces, act) {
  var match = false;

  for (var _iterator14 = _createForOfIteratorHelperLoose(inline_traces), _step14; !(_step14 = _iterator14()).done;) {
    var trace = _step14.value;

    if (trace.act.hex_data === act.hex_data && trace.act.name === act.name && trace.act.account === act.account || findIfSameTx(trace.inline_traces, act)) {
      return true;
    }
  }

  return match;
}

function inlineTraceCountHelper(traces) {
  return traces.reduce(function (acc, trace) {
    return acc + 1 + inlineTraceCountHelper(trace.inline_traces || []);
  }, 0);
}

function historyTransformTransaction(transaction) {
  if (transaction.trx) {
    var actions = [];
    var delay_sec;
    var expiration;
    var traces; // >= 1.8 traces

    if (transaction.traces && transaction.traces.length && 'creator_action_ordinal' in transaction.traces[0]) {
      traces = historyTransformFlatTraces(transaction.traces).map(historyTransformRecursiveTrace);
      actions = transaction.traces.filter(function (trace) {
        return trace.creator_action_ordinal === 0;
      }); // 1.7 and under nodeos
    } else {
      var _loop = function _loop() {
        var _step15$value = _step15.value,
            i = _step15$value[0],
            action = _step15$value[1];
        var tempTraces = transaction.traces.slice();
        tempTraces.splice(i, i + 1);
        var foundSameHex = tempTraces.find(function (trace) {
          return findIfSameTx(trace.inline_traces.slice(), action.act);
        });

        if (!foundSameHex) {
          actions.push(action);
        }
      };

      for (var _iterator15 = _createForOfIteratorHelperLoose(transaction.traces.entries()), _step15; !(_step15 = _iterator15()).done;) {
        _loop();
      }

      traces = actions.map(function (action) {
        return historyTransformRecursiveTrace(action);
      }); // Normal not deferred TX

      if (transaction.trx.trx) {
        delay_sec = transaction.trx.trx.delay_sec;
        expiration = transaction.trx.trx.expiration; // Deferred TX
      } else {
        delay_sec = 'N/A';
        expiration = 'N/A';
      } // Fix for empty array (hex data fucked up) WTF?


      if (transaction.traces.length > 0 && actions.length === 0) {
        actions = [];
        var counter = 0;
        var i = 0;

        for (var _iterator16 = _createForOfIteratorHelperLoose(transaction.traces), _step16; !(_step16 = _iterator16()).done;) {
          var _tx = _step16.value;

          if (i >= counter) {
            actions.push(_tx);
          }

          counter += inlineTraceCountHelper(_tx.inline_traces);
          i++;
        }

        traces = actions.map(function (action) {
          return historyTransformRecursiveTrace(action);
        });
      } // Fix for empty trace (block hint used?)


      if (transaction.traces.length === 0 && actions.length === 0 && transaction.trx.trx && transaction.trx.trx.actions && transaction.trx.trx.actions.length) {
        traces = transaction.trx.trx.actions.map(function (action) {
          return {
            act: action,
            account_ram_deltas: [],
            receivers: action.authorization.map(function (auth) {
              return auth.actor;
            }),
            act_digest: '',
            traces: []
          };
        });
        actions = traces;
      }
    } // For display


    var extraFields = _extends({}, transaction, transaction.trx.receipt, transaction.trx.trx || {});

    var tx = _extends({}, extraFields, {
      status: transaction.trx.receipt.status,
      cpu_usage: transaction.trx.receipt.cpu_usage_us,
      net_usage: transaction.trx.receipt.net_usage_words * 8,
      id: transaction.id,
      block_time: transaction.block_time,
      block_num: transaction.block_num,
      delay_sec: delay_sec,
      expiration: expiration,
      actions: actions,
      traces: traces
    });

    return tx; // MEETONE history
  } else if (transaction.action_traces) {
    return dfuseTransformTransaction(transaction); // On block
  } else {
    var _traces = transaction.traces.map(function (trace) {
      return historyTransformRecursiveTrace(trace);
    });

    return {
      status: 'executed',
      cpu_usage: 0,
      net_usage: 0,
      id: transaction.id,
      block_time: transaction.block_time,
      block_num: transaction.block_num,
      delay_sec: 0,
      expiration: 0,
      actions: _traces,
      traces: _traces
    };
  }
}

function hexToUint8Array(hex) {
  if (typeof hex !== 'string') {
    throw new Error('Expected string containing hex digits');
  }

  if (hex.length % 2) {
    throw new Error('Odd number of hex digits');
  }

  var l = hex.length / 2;
  var result = new Uint8Array(l);

  for (var i = 0; i < l; ++i) {
    var x = parseInt(hex.substr(i * 2, 2), 16);

    if (Number.isNaN(x)) {
      throw new Error('Expected hex string');
    }

    result[i] = x;
  }

  return result;
}

function urlBuilder(url, id, params) {
  params = params || {};

  if (typeof id !== 'undefined' && id !== null) {
    url += "/" + encodeURIComponent(id);
  }

  if (Object.keys(params).length !== 0) {
    var queryString = qs__WEBPACK_IMPORTED_MODULE_2___default().stringify(params);
    url += "?" + queryString;
  }

  return url;
}

function copy(text) {
  var selected = false;
  var el = document.createElement('textarea');
  el.value = text;
  el.setAttribute('readonly', '');
  el.style.position = 'absolute';
  el.style.left = '-9999px';
  document.body.appendChild(el);
  var selection = document.getSelection();

  if (selection && selection.rangeCount > 0) {
    selected = selection.getRangeAt(0);
  }

  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);

  if (selection && selected) {
    selection.removeAllRanges();
    selection.addRange(selected);
  }
}

var Nft = function Nft(_ref) {
  var idata = _ref.idata,
      mdata = _ref.mdata,
      name = _ref.name,
      image = _ref.image,
      video = _ref.video,
      model = _ref.model,
      audio = _ref.audio,
      stage = _ref.stage,
      skybox = _ref.skybox,
      pdf = _ref.pdf,
      id = _ref.id,
      contract = _ref.contract,
      link = _ref.link,
      owner = _ref.owner,
      author = _ref.author,
      collection = _ref.collection,
      mint = _ref.mint,
      edition_size = _ref.edition_size;
  this.idata = idata;
  this.mdata = mdata;
  this.name = name;
  this.image = image;
  this.video = video;
  this.model = model;
  this.audio = audio;
  this.stage = stage;
  this.skybox = skybox;
  this.pdf = pdf;
  this.id = id;
  this.contract = contract;
  this.link = link;
  this.owner = owner;
  this.author = author;
  this.collection = collection;
  this.mint = mint;
  this.edition_size = edition_size;
};

function parseIpfs(imageUrl) {
  if (!imageUrl) {
    return imageUrl;
  }

  if (imageUrl.substring(0, 2) === 'Qm') {
    imageUrl = "https://cloudflare-ipfs.com/ipfs/" + imageUrl;
  }

  return imageUrl;
}

function parseSaNft(nft) {
  var name = nft.idata && nft.idata.name || nft.mdata && nft.mdata.name;
  var imageUrl = parseIpfs(nft.idata && (nft.idata.img || nft.idata.image) || nft.mdata && (nft.mdata.img || nft.mdata.img));
  var videoUrl = parseIpfs(nft.idata && nft.idata.video || nft.mdata && nft.mdata.video);
  var audioUrl = parseIpfs(nft.idata && nft.idata.audio || nft.mdata && nft.mdata.audio);
  var modelUrl = parseIpfs(nft.idata && nft.idata.model || nft.mdata && nft.mdata.model);
  var stageUrl = parseIpfs(nft.idata && nft.idata.stage || nft.mdata && nft.mdata.stage);
  var pdfUrl = parseIpfs(nft.idata && nft.idata.pdf || nft.mdata && nft.mdata.pdf);
  var skyboxUrl = parseIpfs(nft.idata && nft.idata.skybox || nft.mdata && nft.mdata.skybox);
  var nftObj = new Nft({
    idata: nft.idata,
    mdata: nft.mdata,
    name: name,
    image: imageUrl,
    video: videoUrl,
    model: modelUrl,
    audio: audioUrl,
    stage: stageUrl,
    skybox: skyboxUrl,
    pdf: pdfUrl,
    id: nft.assetId,
    contract: 'simpleassets',
    link: "/nft/" + nft.assetId,
    owner: nft.owner,
    author: nft.author,
    mint: nft.extra && nft.extra.mintNumber,
    collection: nft.category,
    edition_size: nft.extra && nft.extra.totalMinted
  });
  return nftObj;
}
function parseAaNft(nft) {
  var imageUrl = parseIpfs(nft.data.img || nft.data.image);
  var videoUrl = parseIpfs(nft.data.video);
  var audioUrl = parseIpfs(nft.data.audio);
  var modelUrl = parseIpfs(nft.data.model);
  var stageUrl = parseIpfs(nft.data.stage);
  var skyboxUrl = parseIpfs(nft.data.skybox);
  var pdfUrl = parseIpfs(nft.data.pdf);
  var idata = nft.immutable_data;

  if (nft.template && nft.template.immutable_data) {
    idata = _extends({}, idata, nft.template.immutable_data);
  }

  var nftObj = new Nft({
    idata: idata,
    mdata: nft.mutable_data,
    name: nft.name || nft.data.name || nft.asset_id,
    image: imageUrl,
    video: videoUrl,
    model: modelUrl,
    audio: audioUrl,
    stage: stageUrl,
    skybox: skyboxUrl,
    pdf: pdfUrl,
    id: nft.asset_id,
    contract: 'atomicassets',
    link: "/nft/" + nft.asset_id,
    owner: nft.owner,
    author: nft.collection.author,
    collection: nft.collection.collection_name,
    mint: nft.template_mint ? +nft.template_mint : undefined,
    edition_size: nft.template ? +nft.template.max_supply || +nft.template.issued_supply : undefined
  });
  return nftObj;
}

function wait(_x) {
  return _wait.apply(this, arguments);
}

function _wait() {
  _wait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ms) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new Promise(function (resolve) {
              setTimeout(resolve, ms);
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _wait.apply(this, arguments);
}

/**
 * Native
 */
var DbopOp;

(function (DbopOp) {
  DbopOp["Ins"] = "INS";
  DbopOp["Rem"] = "REM";
  DbopOp["Upd"] = "UPD";
})(DbopOp || (DbopOp = {}));


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./node_modules/@jafri/numbro/dist/numbro.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jafri/numbro/dist/numbro.min.js ***!
  \*******************************************************/
/***/ ((module) => {

!function(e){if(true)module.exports=e();else {}}(function(){return function a(o,u,c){function s(t,e){if(!u[t]){if(!o[t]){var r=undefined;if(!e&&r)return require(t,!0);if(l)return l(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=u[t]={exports:{}};o[t][0].call(i.exports,function(e){return s(o[t][1][e]||e)},i,i.exports,a,o,u,c)}return u[t].exports}for(var l=undefined,e=0;e<c.length;e++)s(c[e]);return s}({1:[function(e,r,t){!function(e){"use strict";var t,C=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,T=Math.ceil,U=Math.floor,R="[BigNumber Error] ",I=R+"Number primitive has more than 15 significant digits: ",$=1e14,G=14,V=9007199254740991,q=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],Z=1e7,z=1e9;function W(e){var t=0|e;return 0<e||e===t?t:t-1}function H(e){for(var t,r,n=1,i=e.length,a=e[0]+"";n<i;){for(t=e[n++]+"",r=G-t.length;r--;t="0"+t);a+=t}for(i=a.length;48===a.charCodeAt(--i););return a.slice(0,i+1||1)}function Y(e,t){var r,n,i=e.c,a=t.c,o=e.s,u=t.s,c=e.e,s=t.e;if(!o||!u)return null;if(r=i&&!i[0],n=a&&!a[0],r||n)return r?n?0:-u:o;if(o!=u)return o;if(r=o<0,n=c==s,!i||!a)return n?0:!i^r?1:-1;if(!n)return s<c^r?1:-1;for(u=(c=i.length)<(s=a.length)?c:s,o=0;o<u;o++)if(i[o]!=a[o])return i[o]>a[o]^r?1:-1;return c==s?0:s<c^r?1:-1}function K(e,t,r,n){if(e<t||r<e||e!==U(e))throw Error(R+(n||"Argument")+("number"==typeof e?e<t||r<e?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function J(e){var t=e.c.length-1;return W(e.e/G)==t&&e.c[t]%2!=0}function X(e,t){return(1<e.length?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function Q(e,t,r){var n,i;if(t<0){for(i=r+".";++t;i+=r);e=i+e}else if(++t>(n=e.length)){for(i=r,t-=n;--t;i+=r);e+=i}else t<n&&(e=e.slice(0,t)+"."+e.slice(t));return e}(t=function e(t){var v,f,p,r,s,m,o,u,c,l,g,n=A.prototype={constructor:A,toString:null,valueOf:null},h=new A(1),y=20,b=4,d=-7,w=21,S=-1e7,x=1e7,O=!1,a=1,N=0,B={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:" ",suffix:""},M="0123456789abcdefghijklmnopqrstuvwxyz";function A(e,t){var r,n,i,a,o,u,c,s,l=this;if(!(l instanceof A))return new A(e,t);if(null==t){if(e&&!0===e._isBigNumber)return l.s=e.s,void(!e.c||e.e>x?l.c=l.e=null:e.e<S?l.c=[l.e=0]:(l.e=e.e,l.c=e.c.slice()));if((u="number"==typeof e)&&0*e==0){if(l.s=1/e<0?(e=-e,-1):1,e===~~e){for(a=0,o=e;10<=o;o/=10,a++);return void(x<a?l.c=l.e=null:(l.e=a,l.c=[e]))}s=String(e)}else{if(!C.test(s=String(e)))return p(l,s,u);l.s=45==s.charCodeAt(0)?(s=s.slice(1),-1):1}-1<(a=s.indexOf("."))&&(s=s.replace(".","")),0<(o=s.search(/e/i))?(a<0&&(a=o),a+=+s.slice(o+1),s=s.substring(0,o)):a<0&&(a=s.length)}else{if(K(t,2,M.length,"Base"),10==t)return P(l=new A(e),y+l.e+1,b);if(s=String(e),u="number"==typeof e){if(0*e!=0)return p(l,s,u,t);if(l.s=1/e<0?(s=s.slice(1),-1):1,A.DEBUG&&15<s.replace(/^0\.0*|\./,"").length)throw Error(I+e)}else l.s=45===s.charCodeAt(0)?(s=s.slice(1),-1):1;for(r=M.slice(0,t),a=o=0,c=s.length;o<c;o++)if(r.indexOf(n=s.charAt(o))<0){if("."==n){if(a<o){a=c;continue}}else if(!i&&(s==s.toUpperCase()&&(s=s.toLowerCase())||s==s.toLowerCase()&&(s=s.toUpperCase()))){i=!0,o=-1,a=0;continue}return p(l,String(e),u,t)}u=!1,-1<(a=(s=f(s,t,10,l.s)).indexOf("."))?s=s.replace(".",""):a=s.length}for(o=0;48===s.charCodeAt(o);o++);for(c=s.length;48===s.charCodeAt(--c););if(s=s.slice(o,++c)){if(c-=o,u&&A.DEBUG&&15<c&&(V<e||e!==U(e)))throw Error(I+l.s*e);if((a=a-o-1)>x)l.c=l.e=null;else if(a<S)l.c=[l.e=0];else{if(l.e=a,l.c=[],o=(a+1)%G,a<0&&(o+=G),o<c){for(o&&l.c.push(+s.slice(0,o)),c-=G;o<c;)l.c.push(+s.slice(o,o+=G));o=G-(s=s.slice(o)).length}else o-=c;for(;o--;s+="0");l.c.push(+s)}}else l.c=[l.e=0]}function D(e,t,r,n){for(var i,a,o=[0],u=0,c=e.length;u<c;){for(a=o.length;a--;o[a]*=t);for(o[0]+=n.indexOf(e.charAt(u++)),i=0;i<o.length;i++)o[i]>r-1&&(null==o[i+1]&&(o[i+1]=0),o[i+1]+=o[i]/r|0,o[i]%=r)}return o.reverse()}function E(e,t,r){var n,i,a,o,u=0,c=e.length,s=t%Z,l=t/Z|0;for(e=e.slice();c--;)u=((i=s*(a=e[c]%Z)+(n=l*a+(o=e[c]/Z|0)*s)%Z*Z+u)/r|0)+(n/Z|0)+l*o,e[c]=i%r;return u&&(e=[u].concat(e)),e}function F(e,t,r,n){var i,a;if(r!=n)a=n<r?1:-1;else for(i=a=0;i<r;i++)if(e[i]!=t[i]){a=e[i]>t[i]?1:-1;break}return a}function k(e,t,r,n){for(var i=0;r--;)e[r]-=i,i=e[r]<t[r]?1:0,e[r]=i*n+e[r]-t[r];for(;!e[0]&&1<e.length;e.splice(0,1));}function i(e,t,r,n){var i,a,o,u,c;if(null==r?r=b:K(r,0,8),!e.c)return e.toString();if(i=e.c[0],o=e.e,null==t)c=H(e.c),c=1==n||2==n&&(o<=d||w<=o)?X(c,o):Q(c,o,"0");else if(a=(e=P(new A(e),t,r)).e,u=(c=H(e.c)).length,1==n||2==n&&(t<=a||a<=d)){for(;u<t;c+="0",u++);c=X(c,a)}else if(t-=o,c=Q(c,a,"0"),u<a+1){if(0<--t)for(c+=".";t--;c+="0");}else if(0<(t+=a-u))for(a+1==u&&(c+=".");t--;c+="0");return e.s<0&&i?"-"+c:c}function _(e,t){for(var r,n=1,i=new A(e[0]);n<e.length;n++){if(!(r=new A(e[n])).s){i=r;break}t.call(i,r)&&(i=r)}return i}function L(e,t,r){for(var n=1,i=t.length;!t[--i];t.pop());for(i=t[0];10<=i;i/=10,n++);return(r=n+r*G-1)>x?e.c=e.e=null:r<S?e.c=[e.e=0]:(e.e=r,e.c=t),e}function P(e,t,r,n){var i,a,o,u,c,s,l,f=e.c,p=q;if(f){e:{for(i=1,u=f[0];10<=u;u/=10,i++);if((a=t-i)<0)a+=G,o=t,l=(c=f[s=0])/p[i-o-1]%10|0;else if((s=T((a+1)/G))>=f.length){if(!n)break e;for(;f.length<=s;f.push(0));c=l=0,o=(a%=G)-G+(i=1)}else{for(c=u=f[s],i=1;10<=u;u/=10,i++);l=(o=(a%=G)-G+i)<0?0:c/p[i-o-1]%10|0}if(n=n||t<0||null!=f[s+1]||(o<0?c:c%p[i-o-1]),n=r<4?(l||n)&&(0==r||r==(e.s<0?3:2)):5<l||5==l&&(4==r||n||6==r&&(0<a?0<o?c/p[i-o]:0:f[s-1])%10&1||r==(e.s<0?8:7)),t<1||!f[0])return f.length=0,n?(t-=e.e+1,f[0]=p[(G-t%G)%G],e.e=-t||0):f[0]=e.e=0,e;if(0==a?(f.length=s,u=1,s--):(f.length=s+1,u=p[G-a],f[s]=0<o?U(c/p[i-o]%p[o])*u:0),n)for(;;){if(0==s){for(a=1,o=f[0];10<=o;o/=10,a++);for(o=f[0]+=u,u=1;10<=o;o/=10,u++);a!=u&&(e.e++,f[0]==$&&(f[0]=1));break}if(f[s]+=u,f[s]!=$)break;f[s--]=0,u=1}for(a=f.length;0===f[--a];f.pop());}e.e>x?e.c=e.e=null:e.e<S&&(e.c=[e.e=0])}return e}function j(e){var t,r=e.e;return null===r?e.toString():(t=H(e.c),t=r<=d||w<=r?X(t,r):Q(t,r,"0"),e.s<0?"-"+t:t)}return A.clone=e,A.ROUND_UP=0,A.ROUND_DOWN=1,A.ROUND_CEIL=2,A.ROUND_FLOOR=3,A.ROUND_HALF_UP=4,A.ROUND_HALF_DOWN=5,A.ROUND_HALF_EVEN=6,A.ROUND_HALF_CEIL=7,A.ROUND_HALF_FLOOR=8,A.EUCLID=9,A.config=A.set=function(e){var t,r;if(null!=e){if("object"!=typeof e)throw Error(R+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(K(r=e[t],0,z,t),y=r),e.hasOwnProperty(t="ROUNDING_MODE")&&(K(r=e[t],0,8,t),b=r),e.hasOwnProperty(t="EXPONENTIAL_AT")&&((r=e[t])&&r.pop?(K(r[0],-z,0,t),K(r[1],0,z,t),d=r[0],w=r[1]):(K(r,-z,z,t),d=-(w=r<0?-r:r))),e.hasOwnProperty(t="RANGE"))if((r=e[t])&&r.pop)K(r[0],-z,-1,t),K(r[1],1,z,t),S=r[0],x=r[1];else{if(K(r,-z,z,t),!r)throw Error(R+t+" cannot be zero: "+r);S=-(x=r<0?-r:r)}if(e.hasOwnProperty(t="CRYPTO")){if((r=e[t])!==!!r)throw Error(R+t+" not true or false: "+r);if(r){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw O=!r,Error(R+"crypto unavailable");O=r}else O=r}if(e.hasOwnProperty(t="MODULO_MODE")&&(K(r=e[t],0,9,t),a=r),e.hasOwnProperty(t="POW_PRECISION")&&(K(r=e[t],0,z,t),N=r),e.hasOwnProperty(t="FORMAT")){if("object"!=typeof(r=e[t]))throw Error(R+t+" not an object: "+r);B=r}if(e.hasOwnProperty(t="ALPHABET")){if("string"!=typeof(r=e[t])||/^.?$|[+\-.\s]|(.).*\1/.test(r))throw Error(R+t+" invalid: "+r);M=r}}return{DECIMAL_PLACES:y,ROUNDING_MODE:b,EXPONENTIAL_AT:[d,w],RANGE:[S,x],CRYPTO:O,MODULO_MODE:a,POW_PRECISION:N,FORMAT:B,ALPHABET:M}},A.isBigNumber=function(e){if(!e||!0!==e._isBigNumber)return!1;if(!A.DEBUG)return!0;var t,r,n=e.c,i=e.e,a=e.s;e:if("[object Array]"=={}.toString.call(n)){if((1===a||-1===a)&&-z<=i&&i<=z&&i===U(i)){if(0===n[0]){if(0===i&&1===n.length)return!0;break e}if((t=(i+1)%G)<1&&(t+=G),String(n[0]).length==t){for(t=0;t<n.length;t++)if((r=n[t])<0||$<=r||r!==U(r))break e;if(0!==r)return!0}}}else if(null===n&&null===i&&(null===a||1===a||-1===a))return!0;throw Error(R+"Invalid BigNumber: "+e)},A.maximum=A.max=function(){return _(arguments,n.lt)},A.minimum=A.min=function(){return _(arguments,n.gt)},A.random=(r=9007199254740992,s=Math.random()*r&2097151?function(){return U(Math.random()*r)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var t,r,n,i,a,o=0,u=[],c=new A(h);if(null==e?e=y:K(e,0,z),i=T(e/G),O)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(i*=2));o<i;)9e15<=(a=131072*t[o]+(t[o+1]>>>11))?(r=crypto.getRandomValues(new Uint32Array(2)),t[o]=r[0],t[o+1]=r[1]):(u.push(a%1e14),o+=2);o=i/2}else{if(!crypto.randomBytes)throw O=!1,Error(R+"crypto unavailable");for(t=crypto.randomBytes(i*=7);o<i;)9e15<=(a=281474976710656*(31&t[o])+1099511627776*t[o+1]+4294967296*t[o+2]+16777216*t[o+3]+(t[o+4]<<16)+(t[o+5]<<8)+t[o+6])?crypto.randomBytes(7).copy(t,o):(u.push(a%1e14),o+=7);o=i/7}if(!O)for(;o<i;)(a=s())<9e15&&(u[o++]=a%1e14);for(i=u[--o],e%=G,i&&e&&(a=q[G-e],u[o]=U(i/a)*a);0===u[o];u.pop(),o--);if(o<0)u=[n=0];else{for(n=-1;0===u[0];u.splice(0,1),n-=G);for(o=1,a=u[0];10<=a;a/=10,o++);o<G&&(n-=G-o)}return c.e=n,c.c=u,c}),A.sum=function(){for(var e=1,t=arguments,r=new A(t[0]);e<t.length;)r=r.plus(t[e++]);return r},m="0123456789",f=function(e,t,r,n,i){var a,o,u,c,s,l,f,p,g=e.indexOf("."),d=y,h=b;for(0<=g&&(c=N,N=0,e=e.replace(".",""),l=(p=new A(t)).pow(e.length-g),N=c,p.c=D(Q(H(l.c),l.e,"0"),10,r,m),p.e=p.c.length),u=c=(f=D(e,t,r,i?(a=M,m):(a=m,M))).length;0==f[--c];f.pop());if(!f[0])return a.charAt(0);if(g<0?--u:(l.c=f,l.e=u,l.s=n,f=(l=v(l,p,d,h,r)).c,s=l.r,u=l.e),g=f[o=u+d+1],c=r/2,s=s||o<0||null!=f[o+1],s=h<4?(null!=g||s)&&(0==h||h==(l.s<0?3:2)):c<g||g==c&&(4==h||s||6==h&&1&f[o-1]||h==(l.s<0?8:7)),o<1||!f[0])e=s?Q(a.charAt(1),-d,a.charAt(0)):a.charAt(0);else{if(f.length=o,s)for(--r;++f[--o]>r;)f[o]=0,o||(++u,f=[1].concat(f));for(c=f.length;!f[--c];);for(g=0,e="";g<=c;e+=a.charAt(f[g++]));e=Q(e,u,a.charAt(0))}return e},v=function(e,t,r,n,i){var a,o,u,c,s,l,f,p,g,d,h,v,m,y,b,w,S,x=e.s==t.s?1:-1,O=e.c,N=t.c;if(!(O&&O[0]&&N&&N[0]))return new A(e.s&&t.s&&(O?!N||O[0]!=N[0]:N)?O&&0==O[0]||!N?0*x:x/0:NaN);for(g=(p=new A(x)).c=[],x=r+(o=e.e-t.e)+1,i||(i=$,o=W(e.e/G)-W(t.e/G),x=x/G|0),u=0;N[u]==(O[u]||0);u++);if(N[u]>(O[u]||0)&&o--,x<0)g.push(1),c=!0;else{for(y=O.length,w=N.length,x+=2,1<(s=U(i/(N[u=0]+1)))&&(N=E(N,s,i),O=E(O,s,i),w=N.length,y=O.length),m=w,h=(d=O.slice(0,w)).length;h<w;d[h++]=0);S=N.slice(),S=[0].concat(S),b=N[0],N[1]>=i/2&&b++;do{if(s=0,(a=F(N,d,w,h))<0){if(v=d[0],w!=h&&(v=v*i+(d[1]||0)),1<(s=U(v/b)))for(i<=s&&(s=i-1),f=(l=E(N,s,i)).length,h=d.length;1==F(l,d,f,h);)s--,k(l,w<f?S:N,f,i),f=l.length,a=1;else 0==s&&(a=s=1),f=(l=N.slice()).length;if(f<h&&(l=[0].concat(l)),k(d,l,h,i),h=d.length,-1==a)for(;F(N,d,w,h)<1;)s++,k(d,w<h?S:N,h,i),h=d.length}else 0===a&&(s++,d=[0]);g[u++]=s,d[0]?d[h++]=O[m]||0:(d=[O[m]],h=1)}while((m++<y||null!=d[0])&&x--);c=null!=d[0],g[0]||g.splice(0,1)}if(i==$){for(u=1,x=g[0];10<=x;x/=10,u++);P(p,r+(p.e=u+o*G-1)+1,n,c)}else p.e=o,p.r=+c;return p},o=/^(-?)0([xbo])(?=\w[\w.]*$)/i,u=/^([^.]+)\.$/,c=/^\.([^.]+)$/,l=/^-?(Infinity|NaN)$/,g=/^\s*\+(?=[\w.])|^\s+|\s+$/g,p=function(e,t,r,n){var i,a=r?t:t.replace(g,"");if(l.test(a))e.s=isNaN(a)?null:a<0?-1:1;else{if(!r&&(a=a.replace(o,function(e,t,r){return i="x"==(r=r.toLowerCase())?16:"b"==r?2:8,n&&n!=i?e:t}),n&&(i=n,a=a.replace(u,"$1").replace(c,"0.$1")),t!=a))return new A(a,i);if(A.DEBUG)throw Error(R+"Not a"+(n?" base "+n:"")+" number: "+t);e.s=null}e.c=e.e=null},n.absoluteValue=n.abs=function(){var e=new A(this);return e.s<0&&(e.s=1),e},n.comparedTo=function(e,t){return Y(this,new A(e,t))},n.decimalPlaces=n.dp=function(e,t){var r,n,i;if(null!=e)return K(e,0,z),null==t?t=b:K(t,0,8),P(new A(this),e+this.e+1,t);if(!(r=this.c))return null;if(n=((i=r.length-1)-W(this.e/G))*G,i=r[i])for(;i%10==0;i/=10,n--);return n<0&&(n=0),n},n.dividedBy=n.div=function(e,t){return v(this,new A(e,t),y,b)},n.dividedToIntegerBy=n.idiv=function(e,t){return v(this,new A(e,t),0,1)},n.exponentiatedBy=n.pow=function(e,t){var r,n,i,a,o,u,c,s,l=this;if((e=new A(e)).c&&!e.isInteger())throw Error(R+"Exponent not an integer: "+j(e));if(null!=t&&(t=new A(t)),o=14<e.e,!l.c||!l.c[0]||1==l.c[0]&&!l.e&&1==l.c.length||!e.c||!e.c[0])return s=new A(Math.pow(+j(l),o?2-J(e):+j(e))),t?s.mod(t):s;if(u=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new A(NaN);(n=!u&&l.isInteger()&&t.isInteger())&&(l=l.mod(t))}else{if(9<e.e&&(0<l.e||l.e<-1||(0==l.e?1<l.c[0]||o&&24e7<=l.c[1]:l.c[0]<8e13||o&&l.c[0]<=9999975e7)))return a=l.s<0&&J(e)?-0:0,-1<l.e&&(a=1/a),new A(u?1/a:a);N&&(a=T(N/G+2))}for(c=o?(r=new A(.5),u&&(e.s=1),J(e)):(i=Math.abs(+j(e)))%2,s=new A(h);;){if(c){if(!(s=s.times(l)).c)break;a?s.c.length>a&&(s.c.length=a):n&&(s=s.mod(t))}if(i){if(0===(i=U(i/2)))break;c=i%2}else if(P(e=e.times(r),e.e+1,1),14<e.e)c=J(e);else{if(0==(i=+j(e)))break;c=i%2}l=l.times(l),a?l.c&&l.c.length>a&&(l.c.length=a):n&&(l=l.mod(t))}return n?s:(u&&(s=h.div(s)),t?s.mod(t):a?P(s,N,b,void 0):s)},n.integerValue=function(e){var t=new A(this);return null==e?e=b:K(e,0,8),P(t,t.e+1,e)},n.isEqualTo=n.eq=function(e,t){return 0===Y(this,new A(e,t))},n.isFinite=function(){return!!this.c},n.isGreaterThan=n.gt=function(e,t){return 0<Y(this,new A(e,t))},n.isGreaterThanOrEqualTo=n.gte=function(e,t){return 1===(t=Y(this,new A(e,t)))||0===t},n.isInteger=function(){return!!this.c&&W(this.e/G)>this.c.length-2},n.isLessThan=n.lt=function(e,t){return Y(this,new A(e,t))<0},n.isLessThanOrEqualTo=n.lte=function(e,t){return-1===(t=Y(this,new A(e,t)))||0===t},n.isNaN=function(){return!this.s},n.isNegative=function(){return this.s<0},n.isPositive=function(){return 0<this.s},n.isZero=function(){return!!this.c&&0==this.c[0]},n.minus=function(e,t){var r,n,i,a,o=this,u=o.s;if(t=(e=new A(e,t)).s,!u||!t)return new A(NaN);if(u!=t)return e.s=-t,o.plus(e);var c=o.e/G,s=e.e/G,l=o.c,f=e.c;if(!c||!s){if(!l||!f)return l?(e.s=-t,e):new A(f?o:NaN);if(!l[0]||!f[0])return f[0]?(e.s=-t,e):new A(l[0]?o:3==b?-0:0)}if(c=W(c),s=W(s),l=l.slice(),u=c-s){for((i=(a=u<0)?(u=-u,l):(s=c,f)).reverse(),t=u;t--;i.push(0));i.reverse()}else for(n=(a=(u=l.length)<(t=f.length))?u:t,u=t=0;t<n;t++)if(l[t]!=f[t]){a=l[t]<f[t];break}if(a&&(i=l,l=f,f=i,e.s=-e.s),0<(t=(n=f.length)-(r=l.length)))for(;t--;l[r++]=0);for(t=$-1;u<n;){if(l[--n]<f[n]){for(r=n;r&&!l[--r];l[r]=t);--l[r],l[n]+=$}l[n]-=f[n]}for(;0==l[0];l.splice(0,1),--s);return l[0]?L(e,l,s):(e.s=3==b?-1:1,e.c=[e.e=0],e)},n.modulo=n.mod=function(e,t){var r,n,i=this;return e=new A(e,t),!i.c||!e.s||e.c&&!e.c[0]?new A(NaN):!e.c||i.c&&!i.c[0]?new A(i):(9==a?(n=e.s,e.s=1,r=v(i,e,0,3),e.s=n,r.s*=n):r=v(i,e,0,a),(e=i.minus(r.times(e))).c[0]||1!=a||(e.s=i.s),e)},n.multipliedBy=n.times=function(e,t){var r,n,i,a,o,u,c,s,l,f,p,g,d,h,v,m=this,y=m.c,b=(e=new A(e,t)).c;if(!(y&&b&&y[0]&&b[0]))return!m.s||!e.s||y&&!y[0]&&!b||b&&!b[0]&&!y?e.c=e.e=e.s=null:(e.s*=m.s,y&&b?(e.c=[0],e.e=0):e.c=e.e=null),e;for(n=W(m.e/G)+W(e.e/G),e.s*=m.s,(c=y.length)<(f=b.length)&&(d=y,y=b,b=d,i=c,c=f,f=i),i=c+f,d=[];i--;d.push(0));for(h=$,v=Z,i=f;0<=--i;){for(r=0,p=b[i]%v,g=b[i]/v|0,a=i+(o=c);i<a;)r=((s=p*(s=y[--o]%v)+(u=g*s+(l=y[o]/v|0)*p)%v*v+d[a]+r)/h|0)+(u/v|0)+g*l,d[a--]=s%h;d[a]=r}return r?++n:d.splice(0,1),L(e,d,n)},n.negated=function(){var e=new A(this);return e.s=-e.s||null,e},n.plus=function(e,t){var r,n=this,i=n.s;if(t=(e=new A(e,t)).s,!i||!t)return new A(NaN);if(i!=t)return e.s=-t,n.minus(e);var a=n.e/G,o=e.e/G,u=n.c,c=e.c;if(!a||!o){if(!u||!c)return new A(i/0);if(!u[0]||!c[0])return c[0]?e:new A(u[0]?n:0*i)}if(a=W(a),o=W(o),u=u.slice(),i=a-o){for((r=0<i?(o=a,c):(i=-i,u)).reverse();i--;r.push(0));r.reverse()}for((i=u.length)-(t=c.length)<0&&(r=c,c=u,u=r,t=i),i=0;t;)i=(u[--t]=u[t]+c[t]+i)/$|0,u[t]=$===u[t]?0:u[t]%$;return i&&(u=[i].concat(u),++o),L(e,u,o)},n.precision=n.sd=function(e,t){var r,n,i;if(null!=e&&e!==!!e)return K(e,1,z),null==t?t=b:K(t,0,8),P(new A(this),e,t);if(!(r=this.c))return null;if(n=(i=r.length-1)*G+1,i=r[i]){for(;i%10==0;i/=10,n--);for(i=r[0];10<=i;i/=10,n++);}return e&&this.e+1>n&&(n=this.e+1),n},n.shiftedBy=function(e){return K(e,-V,V),this.times("1e"+e)},n.squareRoot=n.sqrt=function(){var e,t,r,n,i,a=this,o=a.c,u=a.s,c=a.e,s=y+4,l=new A("0.5");if(1!==u||!o||!o[0])return new A(!u||u<0&&(!o||o[0])?NaN:o?a:1/0);if((r=0==(u=Math.sqrt(+j(a)))||u==1/0?(((t=H(o)).length+c)%2==0&&(t+="0"),u=Math.sqrt(+t),c=W((c+1)/2)-(c<0||c%2),new A(t=u==1/0?"5e"+c:(t=u.toExponential()).slice(0,t.indexOf("e")+1)+c)):new A(u+"")).c[0])for((u=(c=r.e)+s)<3&&(u=0);;)if(i=r,r=l.times(i.plus(v(a,i,s,1))),H(i.c).slice(0,u)===(t=H(r.c)).slice(0,u)){if(r.e<c&&--u,"9999"!=(t=t.slice(u-3,u+1))&&(n||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(P(r,r.e+y+2,1),e=!r.times(r).eq(a));break}if(!n&&(P(i,i.e+y+2,0),i.times(i).eq(a))){r=i;break}s+=4,u+=4,n=1}return P(r,r.e+y+1,b,e)},n.toExponential=function(e,t){return null!=e&&(K(e,0,z),e++),i(this,e,t,1)},n.toFixed=function(e,t){return null!=e&&(K(e,0,z),e=e+this.e+1),i(this,e,t)},n.toFormat=function(e,t,r){var n;if(null==r)null!=e&&t&&"object"==typeof t?(r=t,t=null):e&&"object"==typeof e?(r=e,e=t=null):r=B;else if("object"!=typeof r)throw Error(R+"Argument not an object: "+r);if(n=this.toFixed(e,t),this.c){var i,a=n.split("."),o=+r.groupSize,u=+r.secondaryGroupSize,c=r.groupSeparator||"",s=a[0],l=a[1],f=this.s<0,p=f?s.slice(1):s,g=p.length;if(u&&(i=o,o=u,g-=u=i),0<o&&0<g){for(i=g%o||o,s=p.substr(0,i);i<g;i+=o)s+=c+p.substr(i,o);0<u&&(s+=c+p.slice(i)),f&&(s="-"+s)}n=l?s+(r.decimalSeparator||"")+((u=+r.fractionGroupSize)?l.replace(new RegExp("\\d{"+u+"}\\B","g"),"$&"+(r.fractionGroupSeparator||"")):l):s}return(r.prefix||"")+n+(r.suffix||"")},n.toFraction=function(e){var t,r,n,i,a,o,u,c,s,l,f,p,g=this,d=g.c;if(null!=e&&(!(u=new A(e)).isInteger()&&(u.c||1!==u.s)||u.lt(h)))throw Error(R+"Argument "+(u.isInteger()?"out of range: ":"not an integer: ")+j(u));if(!d)return new A(g);for(t=new A(h),s=r=new A(h),n=c=new A(h),p=H(d),a=t.e=p.length-g.e-1,t.c[0]=q[(o=a%G)<0?G+o:o],e=!e||0<u.comparedTo(t)?0<a?t:s:u,o=x,x=1/0,u=new A(p),c.c[0]=0;l=v(u,t,0,1),1!=(i=r.plus(l.times(n))).comparedTo(e);)r=n,n=i,s=c.plus(l.times(i=s)),c=i,t=u.minus(l.times(i=t)),u=i;return i=v(e.minus(r),n,0,1),c=c.plus(i.times(s)),r=r.plus(i.times(n)),c.s=s.s=g.s,f=v(s,n,a*=2,b).minus(g).abs().comparedTo(v(c,r,a,b).minus(g).abs())<1?[s,n]:[c,r],x=o,f},n.toNumber=function(){return+j(this)},n.toPrecision=function(e,t){return null!=e&&K(e,1,z),i(this,e,t,2)},n.toString=function(e){var t,r=this,n=r.s,i=r.e;return null===i?n?(t="Infinity",n<0&&(t="-"+t)):t="NaN":(t=null==e?i<=d||w<=i?X(H(r.c),i):Q(H(r.c),i,"0"):10===e?Q(H((r=P(new A(r),y+i+1,b)).c),r.e,"0"):(K(e,2,M.length,"Base"),f(Q(H(r.c),i,"0"),10,e,n,!0)),n<0&&r.c[0]&&(t="-"+t)),t},n.valueOf=n.toJSON=function(){return j(this)},n._isBigNumber=!0,null!=t&&A.set(t),A}()).default=t.BigNumber=t,void 0!==r&&r.exports?r.exports=t:(e=e||("undefined"!=typeof self&&self?self:window)).BigNumber=t}(this)},{}],2:[function(e,t,r){"use strict";t.exports={languageTag:"en-US",delimiters:{thousands:",",decimal:"."},abbreviations:{thousand:"k",million:"m",billion:"b",trillion:"t"},spaceSeparated:!1,ordinal:function(e){var t=e%10;return 1==~~(e%100/10)?"th":1==t?"st":2==t?"nd":3==t?"rd":"th"},bytes:{binarySuffixes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],decimalSuffixes:["B","KB","MB","GB","TB","PB","EB","ZB","YB"]},currency:{symbol:"$",position:"prefix",code:"USD"},currencyFormat:{thousandSeparated:!0,totalLength:4,spaceSeparated:!0,spaceSeparatedCurrency:!0},formats:{fourDigits:{totalLength:4,spaceSeparated:!0},fullWithTwoDecimals:{output:"currency",thousandSeparated:!0,mantissa:2},fullWithTwoDecimalsNoCurrency:{thousandSeparated:!0,mantissa:2},fullWithNoDecimals:{output:"currency",thousandSeparated:!0,mantissa:0}}}},{}],3:[function(e,t,r){"use strict";function I(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var r=[],n=!0,i=!1,a=void 0;try{for(var o,u=e[Symbol.iterator]();!(n=(o=u.next()).done)&&(r.push(o.value),!t||r.length!==t);n=!0);}catch(e){i=!0,a=e}finally{try{n||null==u.return||u.return()}finally{if(i)throw a}}return r}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var $=e("./globalState"),o=e("./validating"),u=e("./parsing"),G={trillion:Math.pow(10,12),billion:Math.pow(10,9),million:Math.pow(10,6),thousand:Math.pow(10,3)},V={totalLength:0,characteristic:0,forceAverage:!1,average:!1,mantissa:-1,optionalMantissa:!0,thousandSeparated:!1,spaceSeparated:!1,negative:"sign",forceSign:!1,roundingFunction:Math.round,spaceSeparatedAbbreviation:!1},n=$.currentBytes(),d=n.binarySuffixes,h=n.decimalSuffixes,i={general:{scale:1024,suffixes:h,marker:"bd"},binary:{scale:1024,suffixes:d,marker:"b"},decimal:{scale:1e3,suffixes:h,marker:"d"}};function a(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=2<arguments.length?arguments[2]:void 0;if("string"==typeof t&&(t=u.parseFormat(t)),!o.validateFormat(t))return"ERROR: invalid format";var n=t.prefix||"",i=t.postfix||"",a=function(e,t,r){switch(t.output){case"currency":return t=c(t,$.currentCurrencyDefaultFormat()),function(e,t,r){var n=r.currentCurrency(),i=Object.assign({},V,t),a=void 0,o="",u=!!i.totalLength||!!i.forceAverage||i.average,c=t.currencyPosition||n.position,s=t.currencySymbol||n.symbol,l=void 0!==i.spaceSeparatedCurrency?i.spaceSeparatedCurrency:i.spaceSeparated;void 0===t.lowPrecision&&(t.lowPrecision=!1);l&&(o=" ");"infix"===c&&(a=o+s+o);var f=m({instance:e,providedFormat:t,state:r,decimalSeparator:a});"prefix"===c&&(f=e._value<0&&"sign"===i.negative?"-".concat(o).concat(s).concat(f.slice(1)):0<e._value&&i.forceSign?"+".concat(o).concat(s).concat(f.slice(1)):s+o+f);c&&"postfix"!==c||(o=!i.spaceSeparatedAbbreviation&&u?"":o,f=f+o+s);return f}(e,t,$);case"percent":return t=c(t,$.currentPercentageDefaultFormat()),function(e,t,r,n){var i=t.prefixSymbol,a=m({instance:n(100*e._value),providedFormat:t,state:r}),o=Object.assign({},V,t);if(i)return"%".concat(o.spaceSeparated?" ":"").concat(a);return"".concat(a).concat(o.spaceSeparated?" ":"","%")}(e,t,$,r);case"byte":return t=c(t,$.currentByteDefaultFormat()),function(e,t,r,n){var i=t.base||"binary",a=Object.assign({},V,t),o=r.currentBytes(),u=o.binarySuffixes,c=o.decimalSuffixes,s={general:{scale:1024,suffixes:c||h,marker:"bd"},binary:{scale:1024,suffixes:u||d,marker:"b"},decimal:{scale:1e3,suffixes:c||h,marker:"d"}}[i],l=v(e._value,s.suffixes,s.scale),f=l.value,p=l.suffix,g=m({instance:n(f),providedFormat:t,state:r,defaults:r.currentByteDefaultFormat()});return"".concat(g).concat(a.spaceSeparated?" ":"").concat(p)}(e,t,$,r);case"time":return t=c(t,$.currentTimeDefaultFormat()),function(e){var t=Math.floor(e._value/60/60),r=Math.floor((e._value-60*t*60)/60),n=Math.round(e._value-60*t*60-60*r);return"".concat(t,":").concat(r<10?"0":"").concat(r,":").concat(n<10?"0":"").concat(n)}(e);case"ordinal":return t=c(t,$.currentOrdinalDefaultFormat()),function(e,t,r){var n=r.currentOrdinal(),i=Object.assign({},V,t),a=m({instance:e,providedFormat:t,state:r}),o=n(e._value);return"".concat(a).concat(i.spaceSeparated?" ":"").concat(o)}(e,t,$);case"number":default:return m({instance:e,providedFormat:t,numbro:r})}}(e,t,r);return a=(a=n+a)+i}function v(e,t,r){var n=t[0],i=Math.abs(e);if(r<=i){for(var a=1;a<t.length;++a){var o=Math.pow(r,a),u=Math.pow(r,a+1);if(o<=i&&i<u){n=t[a],e/=o;break}}n===t[0]&&(e/=Math.pow(r,t.length-1),n=t[t.length-1])}return{value:e,suffix:n}}function p(e){for(var t="",r=0;r<e;r++)t+="0";return t}function q(e,t,r){var n=2<arguments.length&&void 0!==r?r:Math.round;return-1!==e.toString().indexOf("e")?function(e,t){var r=e.toString(),n=I(r.split("e"),2),i=n[0],a=n[1],o=I(i.split("."),2),u=o[0],c=o[1],s=void 0===c?"":c;if(0<+a)r=u+s+p(a-s.length);else{var l=".";l=+u<0?"-0".concat(l):"0".concat(l);var f=(p(-a-1)+Math.abs(u)+s).substr(0,t);f.length<t&&(f+=p(t-f.length)),r=l+f}return 0<+a&&0<t&&(r+=".".concat(p(t))),r}(e,t):(n(+"".concat(e,"e+").concat(t))/Math.pow(10,t)).toFixed(t)}function Z(e,t,r,n,i){var a=n.currentDelimiters(),o=a.thousands;i=i||a.decimal;var u=a.thousandsSize||3,c=e.toString(),s=c.split(".")[0],l=c.split(".")[1],f=t<0&&0===s.indexOf("-");r&&(f&&(s=s.slice(1)),function(e,t){for(var r=[],n=0,i=e;0<i;i--)n===t&&(r.unshift(i),n=0),n++;return r}(s.length,u).forEach(function(e,t){s=s.slice(0,e+t)+o+s.slice(e+t)}),f&&(s="-".concat(s)));return c=l?s+i+l:s}function m(e){var t=e.instance,r=e.providedFormat,n=e.state,i=void 0===n?$:n,a=e.decimalSeparator,o=e.defaults,u=void 0===o?i.currentDefaults():o,c=t._value;if(0===c&&i.hasZeroFormat())return i.getZeroFormat();if(!isFinite(c))return c.toString();var s,l,f,p,g,d,h,v,m=Object.assign({},V,u,r),y=m.totalLength,b=y?0:m.characteristic,w=m.optionalCharacteristic,S=m.forceAverage,x=m.lowPrecision,O=!!y||!!S||m.average,N=y?-1:O&&void 0===r.mantissa?0:m.mantissa,B=!y&&(void 0===r.optionalMantissa?-1===N:m.optionalMantissa),M=m.trimMantissa,A=m.thousandSeparated,D=m.spaceSeparated,E=m.negative,F=m.forceSign,k=m.exponential,_=m.roundingFunction,L="";if(O){var P=function(e){var t=e.value,r=e.forceAverage,n=e.lowPrecision,i=void 0===n||n,a=e.abbreviations,o=e.spaceSeparated,u=void 0!==o&&o,c=e.totalLength,s=void 0===c?0:c,l=e.roundingFunction,f=void 0===l?Math.round:l,p="",g=Math.abs(t),d=-1;if(r&&a[r]&&G[r]?(p=a[r],t/=G[r]):g>=G.trillion||i&&1===f(g/G.trillion)?(p=a.trillion,t/=G.trillion):g<G.trillion&&g>=G.billion||i&&1===f(g/G.billion)?(p=a.billion,t/=G.billion):g<G.billion&&g>=G.million||i&&1===f(g/G.million)?(p=a.million,t/=G.million):(g<G.million&&g>=G.thousand||i&&1===f(g/G.thousand))&&(p=a.thousand,t/=G.thousand),p=p&&(u?" ":"")+p,s){var h=t<0,v=t.toString().split(".")[0],m=h?v.length-1:v.length;d=Math.max(s-m,0)}return{value:t,abbreviation:p,mantissaPrecision:d}}({value:c,forceAverage:S,lowPrecision:x,abbreviations:i.currentAbbreviations(),spaceSeparated:D,roundingFunction:_,totalLength:y});c=P.value,L+=P.abbreviation,y&&(N=P.mantissaPrecision)}if(k){var j=(l=(s={value:c,characteristicPrecision:b}).value,f=s.characteristicPrecision,p=void 0===f?0:f,g=I(l.toExponential().split("e"),2),d=g[0],h=g[1],v=+d,p&&1<p&&(v*=Math.pow(10,p-1),h=0<=(h-=p-1)?"+".concat(h):h),{value:v,abbreviation:"e".concat(h)});c=j.value,L=j.abbreviation+L}var C,T,U,R=function(e,t,r,n,i,a){if(-1===n)return e;var o=q(t,n,a),u=I(o.toString().split("."),2),c=u[0],s=u[1],l=void 0===s?"":s;if(l.match(/^0+$/)&&(r||i))return c;var f=l.match(/0+$/);return i&&f?"".concat(c,".").concat(l.toString().slice(0,f.index)):o.toString()}(c.toString(),c,B,N,M,_);return R=Z(R=function(e,t,r,n){var i=e,a=I(i.toString().split("."),2),o=a[0],u=a[1];if(o.match(/^-?0$/)&&r)return u?"".concat(o.replace("0",""),".").concat(u):o.replace("0","");var c=t<0&&0===o.indexOf("-");if(c&&(o=o.slice(1),i=i.slice(1)),o.length<n)for(var s=n-o.length,l=0;l<s;l++)i="0".concat(i);return c&&(i="-".concat(i)),i.toString()}(R,c,w,b),c,A,i,a),(O||k)&&(R=R+L),(F||c<0)&&(C=R,U=E,R=0===(T=c)?C:0==+C?C.replace("-",""):0<T?"+".concat(C):"sign"===U?C:"(".concat(C.replace("-",""),")")),R}function c(e,t){if(!e)return t;var r=Object.keys(e);return 1===r.length&&"output"===r[0]?t:e}t.exports=function(n){return{format:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return a.apply(void 0,t.concat([n]))},getByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=i.general;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getBinaryByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=i.binary;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getDecimalByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=i.decimal;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},formatOrDefault:c}}},{"./globalState":4,"./parsing":8,"./validating":10}],4:[function(e,t,r){"use strict";var i=e("./en-US"),n=e("./validating"),a=e("./parsing"),o={},u=void 0,c={},s=null,l={};function f(e){u=e}function p(){return c[u]}o.languages=function(){return Object.assign({},c)},o.currentLanguage=function(){return u},o.currentBytes=function(){return p().bytes||{}},o.currentCurrency=function(){return p().currency},o.currentAbbreviations=function(){return p().abbreviations},o.currentDelimiters=function(){return p().delimiters},o.currentOrdinal=function(){return p().ordinal},o.currentDefaults=function(){return Object.assign({},p().defaults,l)},o.currentOrdinalDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().ordinalFormat)},o.currentByteDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().byteFormat)},o.currentPercentageDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().percentageFormat)},o.currentCurrencyDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().currencyFormat)},o.currentTimeDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().timeFormat)},o.setDefaults=function(e){e=a.parseFormat(e),n.validateFormat(e)&&(l=e)},o.getZeroFormat=function(){return s},o.setZeroFormat=function(e){return s="string"==typeof e?e:null},o.hasZeroFormat=function(){return null!==s},o.languageData=function(e){if(e){if(c[e])return c[e];throw new Error('Unknown tag "'.concat(e,'"'))}return p()},o.registerLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1];if(!n.validateLanguage(e))throw new Error("Invalid language data");c[e.languageTag]=e,t&&f(e.languageTag)},o.setLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:i.languageTag;if(!c[e]){var r=e.split("-")[0],n=Object.keys(c).find(function(e){return e.split("-")[0]===r});return c[n]?void f(n):void f(t)}f(e)},o.registerLanguage(i),u=i.languageTag,t.exports=o},{"./en-US":2,"./parsing":8,"./validating":10}],5:[function(n,e,t){"use strict";e.exports=function(t){return{loadLanguagesInNode:function(e){return r=t,void e.forEach(function(t){var e=void 0;try{e=n("../languages/".concat(t))}catch(e){console.error('Unable to load "'.concat(t,'". No matching language file found.'))}e&&r.registerLanguage(e)});var r}}}},{}],6:[function(e,t,r){"use strict";var c=e("bignumber.js");function a(e,t,r){var n=new c(e._value),i=t;return r.isNumbro(t)&&(i=t._value),i=new c(i),e._value=n.minus(i).toNumber(),e}t.exports=function(u){return{add:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.plus(o).toNumber(),r;var r,n,i,a,o},subtract:function(e,t){return a(e,t,u)},multiply:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.times(o).toNumber(),r;var r,n,i,a,o},divide:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.dividedBy(o).toNumber(),r;var r,n,i,a,o},set:function(e,t){return r=e,i=n=t,u.isNumbro(n)&&(i=n._value),r._value=i,r;var r,n,i},difference:function(e,t){return r=t,a(i=(n=u)(e._value),r,n),Math.abs(i._value);var r,n,i},BigNumber:c}}},{"bignumber.js":1}],7:[function(e,t,r){"use strict";function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var a=e("./globalState"),n=e("./validating"),o=e("./loading")(g),u=e("./unformatting"),c=e("./formatting")(g),s=e("./manipulating")(g),l=e("./parsing"),f=function(){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._value=e}var e,r,n;return e=t,(r=[{key:"clone",value:function(){return g(this._value)}},{key:"format",value:function(e){var t=0<arguments.length&&void 0!==e?e:{};return c.format(this,t)}},{key:"formatCurrency",value:function(e){return"string"==typeof e&&(e=l.parseFormat(e)),(e=c.formatOrDefault(e,a.currentCurrencyDefaultFormat())).output="currency",c.format(this,e)}},{key:"formatTime",value:function(e){var t=0<arguments.length&&void 0!==e?e:{};return t.output="time",c.format(this,t)}},{key:"binaryByteUnits",value:function(){return c.getBinaryByteUnit(this)}},{key:"decimalByteUnits",value:function(){return c.getDecimalByteUnit(this)}},{key:"byteUnits",value:function(){return c.getByteUnit(this)}},{key:"difference",value:function(e){return s.difference(this,e)}},{key:"add",value:function(e){return s.add(this,e)}},{key:"subtract",value:function(e){return s.subtract(this,e)}},{key:"multiply",value:function(e){return s.multiply(this,e)}},{key:"divide",value:function(e){return s.divide(this,e)}},{key:"set",value:function(e){return s.set(this,p(e))}},{key:"value",value:function(){return this._value}},{key:"valueOf",value:function(){return this._value}}])&&i(e.prototype,r),n&&i(e,n),t}();function p(e){var t=e;return g.isNumbro(e)?t=e._value:"string"==typeof e?t=g.unformat(e):isNaN(e)&&(t=NaN),t}function g(e){return new f(p(e))}g.version="2.3.2",g.isNumbro=function(e){return e instanceof f},g.language=a.currentLanguage,g.registerLanguage=a.registerLanguage,g.setLanguage=a.setLanguage,g.languages=a.languages,g.languageData=a.languageData,g.zeroFormat=a.setZeroFormat,g.defaultFormat=a.currentDefaults,g.setDefaults=a.setDefaults,g.defaultCurrencyFormat=a.currentCurrencyDefaultFormat,g.validate=n.validate,g.loadLanguagesInNode=o.loadLanguagesInNode,g.unformat=u.unformat,g.BigNumber=s.BigNumber,t.exports=g},{"./formatting":3,"./globalState":4,"./loading":5,"./manipulating":6,"./parsing":8,"./unformatting":9,"./validating":10}],8:[function(e,t,r){"use strict";t.exports={parseFormat:function(e){var t,r,n,i,a,o,u,c,s,l,f,p,g,d,h,v,m,y,b,w,S,x,O=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return"string"!=typeof e?e:(r=O,e=(n=(t=e).match(/^{([^}]*)}/))?(r.prefix=n[1],t.slice(n[0].length)):t,a=O,function(e,t){if(-1===e.indexOf("$")){if(-1===e.indexOf("%"))return-1!==e.indexOf("bd")?(t.output="byte",t.base="general"):-1!==e.indexOf("b")?(t.output="byte",t.base="binary"):-1!==e.indexOf("d")?(t.output="byte",t.base="decimal"):-1===e.indexOf(":")?-1!==e.indexOf("o")&&(t.output="ordinal"):t.output="time";t.output="percent"}else t.output="currency"}(e=(o=(i=e).match(/{([^}]*)}$/))?(a.postfix=o[1],i.slice(0,-o[0].length)):i,O),u=O,(c=e.match(/[1-9]+[0-9]*/))&&(u.totalLength=+c[0]),s=O,(l=e.split(".")[0].match(/0+/))&&(s.characteristic=l[0].length),function(e,t){if(-1!==e.indexOf(".")){var r=e.split(".")[0];t.optionalCharacteristic=-1===r.indexOf("0")}}(e,O),f=O,-1!==e.indexOf("a")&&(f.average=!0),g=O,-1!==(p=e).indexOf("K")?g.forceAverage="thousand":-1!==p.indexOf("M")?g.forceAverage="million":-1!==p.indexOf("B")?g.forceAverage="billion":-1!==p.indexOf("T")&&(g.forceAverage="trillion"),function(e,t){var r=e.split(".")[1];if(r){var n=r.match(/0+/);n&&(t.mantissa=n[0].length)}}(e,O),h=O,(d=e).match(/\[\.]/)?h.optionalMantissa=!0:d.match(/\./)&&(h.optionalMantissa=!1),v=O,(m=e.split(".")[1])&&(v.trimMantissa=-1!==m.indexOf("[")),y=O,-1!==e.indexOf(",")&&(y.thousandSeparated=!0),b=O,-1!==e.indexOf(" ")&&(b.spaceSeparated=!0,b.spaceSeparatedCurrency=!0,(b.average||b.forceAverage)&&(b.spaceSeparatedAbbreviation=!0)),S=O,(w=e).match(/^\+?\([^)]*\)$/)&&(S.negative="parenthesis"),w.match(/^\+?-/)&&(S.negative="sign"),x=O,e.match(/^\+/)&&(x.forceSign=!0),O)}}},{}],9:[function(p,e,t){"use strict";var M=[{key:"ZiB",factor:Math.pow(1024,7)},{key:"ZB",factor:Math.pow(1e3,7)},{key:"YiB",factor:Math.pow(1024,8)},{key:"YB",factor:Math.pow(1e3,8)},{key:"TiB",factor:Math.pow(1024,4)},{key:"TB",factor:Math.pow(1e3,4)},{key:"PiB",factor:Math.pow(1024,5)},{key:"PB",factor:Math.pow(1e3,5)},{key:"MiB",factor:Math.pow(1024,2)},{key:"MB",factor:Math.pow(1e3,2)},{key:"KiB",factor:Math.pow(1024,1)},{key:"KB",factor:Math.pow(1e3,1)},{key:"GiB",factor:Math.pow(1024,3)},{key:"GB",factor:Math.pow(1e3,3)},{key:"EiB",factor:Math.pow(1024,6)},{key:"EB",factor:Math.pow(1e3,6)},{key:"B",factor:1}];function A(e){return e.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function g(e,t,r,n,i,a,o){var u=2<arguments.length&&void 0!==r?r:"",c=3<arguments.length?n:void 0,s=4<arguments.length?i:void 0,l=5<arguments.length?a:void 0,f=6<arguments.length?o:void 0;if(""!==e)return e===s?0:function e(t,r,n,i,a,o,u){var c=2<arguments.length&&void 0!==n?n:"",s=3<arguments.length?i:void 0,l=4<arguments.length?a:void 0,f=5<arguments.length?o:void 0,p=6<arguments.length?u:void 0;if(!isNaN(+t))return+t;var g="",d=t.replace(/(^[^(]*)\((.*)\)([^)]*$)/,"$1$2$3");if(d!==t)return-1*e(d,r,c,s,l,f,p);for(var h=0;h<M.length;h++){var v=M[h];if((g=t.replace(RegExp("([0-9 ])(".concat(v.key,")$")),"$1"))!==t)return e(g,r,c,s,l,f,p)*v.factor}if((g=t.replace("%",""))!==t)return e(g,r,c,s,l,f,p)/100;var m=parseFloat(t);if(!isNaN(m)){var y=s(m);if(y&&"."!==y&&(g=t.replace(new RegExp("".concat(A(y),"$")),""))!==t)return e(g,r,c,s,l,f,p);var b={};Object.keys(f).forEach(function(e){b[f[e]]=e});for(var w=Object.keys(b).sort().reverse(),S=w.length,x=0;x<S;x++){var O=w[x],N=b[O];if((g=t.replace(O,""))!==t){var B=void 0;switch(N){case"thousand":B=Math.pow(10,3);break;case"million":B=Math.pow(10,6);break;case"billion":B=Math.pow(10,9);break;case"trillion":B=Math.pow(10,12)}return e(g,r,c,s,l,f,p)*B}}}}(function(e,t,r){var n=2<arguments.length&&void 0!==r?r:"",i=e.replace(n,"");return i=(i=i.replace(new RegExp("([0-9])".concat(A(t.thousands),"([0-9])"),"g"),"$1$2")).replace(t.decimal,".")}(e,t,u),t,u,c,s,l,f)}e.exports={unformat:function(e,t){var r,n,i,a=p("./globalState"),o=a.currentDelimiters(),u=a.currentCurrency().symbol,c=a.currentOrdinal(),s=a.getZeroFormat(),l=a.currentAbbreviations(),f=void 0;if("string"==typeof e)f=function(e,t){if(e.indexOf(":")&&":"!==t.thousands){var r=e.split(":");if(3===r.length){var n=+r[0],i=+r[1],a=+r[2];return!isNaN(n)&&!isNaN(i)&&!isNaN(a)}}}(e,o)?(r=e.split(":"),n=+r[0],i=+r[1],+r[2]+60*i+3600*n):g(e,o,u,c,s,l,t);else{if("number"!=typeof e)return;f=e}if(void 0!==f)return f}}},{"./globalState":4}],10:[function(e,t,r){"use strict";function n(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function f(e){return(f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var i=e("./unformatting"),a=/^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/,p={output:{type:"string",validValues:["currency","percent","byte","time","ordinal","number"]},base:{type:"string",validValues:["decimal","binary","general"],restriction:function(e,t){return"byte"===t.output},message:"`base` must be provided only when the output is `byte`",mandatory:function(e){return"byte"===e.output}},characteristic:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},prefix:"string",postfix:"string",forceAverage:{type:"string",validValues:["trillion","billion","million","thousand"]},average:"boolean",lowPrecision:{type:"boolean",restriction:function(e,t){return!0===t.average},message:"`lowPrecision` must be provided only when the option `average` is set"},currencyPosition:{type:"string",validValues:["prefix","infix","postfix"]},currencySymbol:"string",totalLength:{type:"number",restrictions:[{restriction:function(e){return 0<=e},message:"value must be positive"},{restriction:function(e,t){return!t.exponential},message:"`totalLength` is incompatible with `exponential`"}]},mantissa:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},optionalMantissa:"boolean",trimMantissa:"boolean",roundingFunction:"function",optionalCharacteristic:"boolean",thousandSeparated:"boolean",spaceSeparated:"boolean",spaceSeparatedCurrency:"boolean",spaceSeparatedAbbreviation:"boolean",abbreviations:{type:"object",children:{thousand:"string",million:"string",billion:"string",trillion:"string"}},negative:{type:"string",validValues:["sign","parenthesis"]},forceSign:"boolean",exponential:{type:"boolean"},prefixSymbol:{type:"boolean",restriction:function(e,t){return"percent"===t.output},message:"`prefixSymbol` can be provided only when the output is `percent`"}},o={languageTag:{type:"string",mandatory:!0,restriction:function(e){return e.match(a)},message:"the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)"},delimiters:{type:"object",children:{thousands:"string",decimal:"string",thousandsSize:"number"},mandatory:!0},abbreviations:{type:"object",children:{thousand:{type:"string",mandatory:!0},million:{type:"string",mandatory:!0},billion:{type:"string",mandatory:!0},trillion:{type:"string",mandatory:!0}},mandatory:!0},spaceSeparated:"boolean",spaceSeparatedCurrency:"boolean",ordinal:{type:"function",mandatory:!0},bytes:{type:"object",children:{binarySuffixes:"object",decimalSuffixes:"object"}},currency:{type:"object",children:{symbol:"string",position:"string",code:"string"},mandatory:!0},defaults:"format",ordinalFormat:"format",byteFormat:"format",percentageFormat:"format",currencyFormat:"format",timeDefaults:"format",formats:{type:"object",children:{fourDigits:{type:"format",mandatory:!0},fullWithTwoDecimals:{type:"format",mandatory:!0},fullWithTwoDecimalsNoCurrency:{type:"format",mandatory:!0},fullWithNoDecimals:{type:"format",mandatory:!0}}}};function u(e){return void 0!==i.unformat(e)}function g(c,s,l,e){var t=3<arguments.length&&void 0!==e&&e,r=Object.keys(c).map(function(e){if(!s[e])return console.error("".concat(l," Invalid key: ").concat(e)),!1;var t=c[e],r=s[e];if("string"==typeof r&&(r={type:r}),"format"===r.type){if(!g(t,p,"[Validate ".concat(e,"]"),!0))return!1}else if(f(t)!==r.type)return console.error("".concat(l," ").concat(e,' type mismatched: "').concat(r.type,'" expected, "').concat(f(t),'" provided')),!1;if(r.restrictions&&r.restrictions.length)for(var n=r.restrictions.length,i=0;i<n;i++){var a=r.restrictions[i],o=a.restriction,u=a.message;if(!o(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(u)),!1}if(r.restriction&&!r.restriction(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(r.message)),!1;if(r.validValues&&-1===r.validValues.indexOf(t))return console.error("".concat(l," ").concat(e," invalid value: must be among ").concat(JSON.stringify(r.validValues),', "').concat(t,'" provided')),!1;if(r.children&&!g(t,r.children,"[Validate ".concat(e,"]")))return!1;return!0});return t||r.push.apply(r,n(Object.keys(s).map(function(e){var t=s[e];if("string"==typeof t&&(t={type:t}),t.mandatory){var r=t.mandatory;if("function"==typeof r&&(r=r(c)),r&&void 0===c[e])return console.error("".concat(l,' Missing mandatory key "').concat(e,'"')),!1}return!0}))),r.reduce(function(e,t){return e&&t},!0)}function c(e){return g(e,p,"[Validate format]")}t.exports={validate:function(e,t){var r=u(e),n=c(t);return r&&n},validateFormat:c,validateInput:u,validateLanguage:function(e){return g(e,o,"[Validate language]")}}},{"./unformatting":9}]},{},[7])(7)});
//# sourceMappingURL=numbro.min.js.map


/***/ }),

/***/ "./node_modules/@proton/api/dist/api.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/@proton/api/dist/api.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiClass": () => (/* binding */ ApiClass),
/* harmony export */   "KycStatus": () => (/* binding */ KycStatus)
/* harmony export */ });
/* harmony import */ var _proton_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @proton/js */ "./node_modules/@proton/js/dist/index.js");
/* harmony import */ var _bloks_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bloks/constants */ "./node_modules/@bloks/constants/dist/constants.esm.js");
/* harmony import */ var _proton_hyperion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @proton/hyperion */ "./node_modules/@proton/hyperion/dist/index.js");
/* harmony import */ var _proton_hyperion__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_proton_hyperion__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _proton_light_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @proton/light-api */ "./node_modules/@proton/light-api/dist/index.js");
/* harmony import */ var _proton_light_api__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_proton_light_api__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _bloks_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @bloks/utils */ "./node_modules/@bloks/utils/dist/utils.esm.js");
/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js");
/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js");
/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _proton_wrap_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @proton/wrap-constants */ "./node_modules/@proton/wrap-constants/dist/wrap-constants.esm.js");
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! zod */ "./node_modules/zod/lib/index.mjs");
/* harmony import */ var _bloks_numbers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @bloks/numbers */ "./node_modules/@bloks/numbers/dist/index.js");











function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function getAccount(_x) {
  return _getAccount.apply(this, arguments);
}

function _getAccount() {
  _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName) {
    var _this = this;

    var account;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_account(accountName);

          case 3:
            account = _context.sent;
            account.permissions = account.permissions.map(function (permission) {
              permission.required_auth.keys = permission.required_auth.keys.map(function (key) {
                if (key.key.indexOf(_this.constants.KEY_PREFIX) !== -1) {
                  key.key = _proton_js__WEBPACK_IMPORTED_MODULE_0__.Numeric.convertLegacyPublicKey(key.key, _this.constants.KEY_PREFIX);
                }

                return key;
              });
              return permission;
            });
            return _context.abrupt("return", account);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getAccount.apply(this, arguments);
}

function searchAccount(_x2, _x3) {
  return _searchAccount.apply(this, arguments);
}

function _searchAccount() {
  _searchAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(query, limit) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(!query || !/(^[a-zA-Z12345.]+$)/.test(query))) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt("return", []);

          case 2:
            if (!(query.indexOf('.') === 0)) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", []);

          case 4:
            _context2.prev = 4;
            query = query.trim().toLowerCase();
            _context2.next = 8;
            return this.rpc.get_table_by_scope({
              json: true,
              code: this.constants.EOSIO,
              limit: limit,
              lower_bound: query,
              table: 'userres',
              upper_bound: "" + query + (query.length < 12 ? 'z'.repeat(12 - query.length) : '')
            });

          case 8:
            _yield$this$rpc$get_t = _context2.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context2.abrupt("return", rows.map(function (row) {
              return row.scope;
            }));

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](4);
            console.log(_context2.t0);
            return _context2.abrupt("return", []);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[4, 13]]);
  }));
  return _searchAccount.apply(this, arguments);
}

function getGravatar(_x4) {
  return _getGravatar.apply(this, arguments);
}

function _getGravatar() {
  _getGravatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!(this.constants.CHAIN === 'eos')) {
              _context3.next = 7;
              break;
            }

            _context3.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.ACCOUNT_INFO,
              scope: this.constants.ACCOUNT_INFO,
              table: 'accounts',
              table_key: '',
              key_type: 'name',
              lower_bound: account,
              index_position: 1,
              limit: 1
            });

          case 3:
            result = _context3.sent;
            return _context3.abrupt("return", result.rows.length > 0 && result.rows[0].account_name === account ? result.rows[0] : undefined);

          case 7:
            return _context3.abrupt("return", undefined);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getGravatar.apply(this, arguments);
}

function getParent(_x5) {
  return _getParent.apply(this, arguments);
}

function _getParent() {
  _getParent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!this.constants.HISTORY_TYPES.includes('hyperion')) {
              _context4.next = 8;
              break;
            }

            if (!this.constants.HYPERION_URL) {
              _context4.next = 5;
              break;
            }

            return _context4.abrupt("return", this.hyperion.get_creator(account));

          case 5:
            return _context4.abrupt("return", this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'hyperion', {
              type: 'get_creator',
              account: account
            })));

          case 6:
            _context4.next = 9;
            break;

          case 8:
            return _context4.abrupt("return", null);

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getParent.apply(this, arguments);
}

function getAccountLightData(_x6) {
  return _getAccountLightData.apply(this, arguments);
}

function _getAccountLightData() {
  _getAccountLightData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(accountName) {
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (this.lightApi) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return", undefined);

          case 2:
            _context5.prev = 2;
            _context5.next = 5;
            return this.lightApi.get_account_info(accountName);

          case 5:
            return _context5.abrupt("return", _context5.sent);

          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](2);
            console.log(_context5.t0);
            return _context5.abrupt("return", undefined);

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[2, 8]]);
  }));
  return _getAccountLightData.apply(this, arguments);
}

function getActionsFromNative(_x, _x2, _x3, _x4) {
  return _getActionsFromNative.apply(this, arguments);
}

function _getActionsFromNative() {
  _getActionsFromNative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName, actionSkip, actionsPerPage, historyType) {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (historyType === void 0) {
              historyType = 'native';
            }

            console.log('Fetching actions from:', historyType);
            console.log('Fetch Params:', 'actionSkip', actionSkip, 'actionsPerPage', actionsPerPage); // Request

            _context.next = 5;
            return this.actionsRpc.history_get_actions(accountName, actionSkip, actionsPerPage);

          case 5:
            result = _context.sent;

            if (result) {
              _context.next = 8;
              break;
            }

            throw new Error('Could not retrieve actions');

          case 8:
            if (!(historyType === 'native')) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.nativeTransformGetActions)(result, this.constants));

          case 10:
            return _context.abrupt("return", []);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getActionsFromNative.apply(this, arguments);
}

function getActions(_x5, _x6, _x7) {
  return _getActions.apply(this, arguments);
}

function _getActions() {
  _getActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(accountName, historyType, _temp) {
    var _ref, _ref$actionsPerPage, actionsPerPage, _ref$actionSkip, actionSkip, _ref$sortDirection, sortDirection, _ref$dfuseCursorStack, dfuseCursorStack, tokenFilter, actionFilters, contractFilter, actionFilter, start, end, result, inputCursor;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref = _temp === void 0 ? {} : _temp, _ref$actionsPerPage = _ref.actionsPerPage, actionsPerPage = _ref$actionsPerPage === void 0 ? 100 : _ref$actionsPerPage, _ref$actionSkip = _ref.actionSkip, actionSkip = _ref$actionSkip === void 0 ? 0 : _ref$actionSkip, _ref$sortDirection = _ref.sortDirection, sortDirection = _ref$sortDirection === void 0 ? 'desc' : _ref$sortDirection, _ref$dfuseCursorStack = _ref.dfuseCursorStack, dfuseCursorStack = _ref$dfuseCursorStack === void 0 ? [] : _ref$dfuseCursorStack, tokenFilter = _ref.tokenFilter, actionFilters = _ref.actionFilters, contractFilter = _ref.contractFilter, actionFilter = _ref.actionFilter, start = _ref.start, end = _ref.end;

            if (!start) {
              start = this.constants.CHAIN_START_DATE;
            } // Fallback for history type


            console.log(this.constants.HISTORY_TYPES);

            if (!historyType && this.constants.HISTORY_TYPES.length) {
              historyType = this.constants.HISTORY_TYPES[0];
            } // Fix for firefox and IE and safari


            if (start && end) {
              start = start || this.constants.CHAIN_START_DATE ? new Date(start || this.constants.CHAIN_START_DATE).toISOString() : undefined;
              end = new Date(end || new Date()).toISOString();
            } else {
              start = undefined;
              end = undefined;
            }

            if (!(historyType === 'dfuse')) {
              _context2.next = 12;
              break;
            }

            inputCursor = dfuseCursorStack.length > 0 ? dfuseCursorStack[dfuseCursorStack.length - 1] : '';
            _context2.next = 9;
            return this.getActionsFromDfuse(accountName, {
              limit: actionsPerPage,
              cursor: inputCursor,
              direction: sortDirection,
              query: '',
              after: start,
              before: end,
              tokenFilter: tokenFilter,
              actionFilters: actionFilters,
              contractFilter: contractFilter,
              actionFilter: actionFilter
            });

          case 9:
            result = _context2.sent;
            _context2.next = 21;
            break;

          case 12:
            if (!(historyType === 'hyperion')) {
              _context2.next = 18;
              break;
            }

            _context2.next = 15;
            return this.getActionsFromHyperion(accountName, {
              skip: Math.abs(actionSkip) - 1,
              limit: actionsPerPage,
              sort: sortDirection,
              after: start,
              before: end,
              tokenFilter: tokenFilter,
              actionFilters: actionFilters,
              contractFilter: contractFilter,
              actionFilter: actionFilter
            });

          case 15:
            result = _context2.sent;
            _context2.next = 21;
            break;

          case 18:
            _context2.next = 20;
            return this.getActionsFromNative(accountName, actionSkip, -actionsPerPage, 'native');

          case 20:
            result = _context2.sent;

          case 21:
            return _context2.abrupt("return", result);

          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getActions.apply(this, arguments);
}

function getActionsFromDfuse(_x8, _x9) {
  return _getActionsFromDfuse.apply(this, arguments);
}

function _getActionsFromDfuse() {
  _getActionsFromDfuse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(accountName, _temp2) {
    var _ref2, before, after, _ref2$limit, limit, cursor, query, _ref2$direction, direction, tokenFilter, actionFilters, contractFilter, actionFilter, _ref2$type, type, q, _tokenFilter$split, tokenContract, tokenfilter, actionFiltersLocal, actionFiltersQuery, result;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _ref2 = _temp2 === void 0 ? {} : _temp2, before = _ref2.before, after = _ref2.after, _ref2$limit = _ref2.limit, limit = _ref2$limit === void 0 ? 25 : _ref2$limit, cursor = _ref2.cursor, query = _ref2.query, _ref2$direction = _ref2.direction, direction = _ref2$direction === void 0 ? 'desc' : _ref2$direction, tokenFilter = _ref2.tokenFilter, actionFilters = _ref2.actionFilters, contractFilter = _ref2.contractFilter, actionFilter = _ref2.actionFilter, _ref2$type = _ref2.type, type = _ref2$type === void 0 ? 'search_transactions_graphql' : _ref2$type;
            q = query || "(auth:" + accountName + " OR\n                    receiver:" + accountName + " OR\n                    data.to:" + accountName + " OR\n                    data.from:" + accountName + " OR\n                    data.receiver:" + accountName + ")";

            if (tokenFilter) {
              _tokenFilter$split = tokenFilter.split(' '), tokenContract = _tokenFilter$split[1];
              tokenfilter = "account:" + tokenContract;
              q = q + " " + tokenfilter;
            }

            if (actionFilters) {
              actionFiltersLocal = Object.entries(actionFilters).reduce(function (filters, _ref4) {
                var value = _ref4[1];
                return value.isActive ? filters.concat(value) : filters;
              }, []);

              if (actionFiltersLocal.length) {
                actionFiltersQuery = actionFiltersLocal.map(function (filter) {
                  return filter.dfuseQuery(accountName);
                }).join(' OR '); // Wrap around the action filters

                if (actionFiltersQuery.search('OR') !== -1) {
                  actionFiltersQuery = "(" + actionFiltersQuery + ")";
                } // Set the action filters


                q = q + " " + actionFiltersQuery;
              }

              if (contractFilter) {
                q = q + " account:" + contractFilter;
              }

              if (actionFilter) {
                q = q + " action:" + actionFilter;
              }
            }

            _context3.next = 6;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'dfuse', {
              type: type,
              q: q,
              options: Object.assign({}, {
                sort: direction,
                cursor: cursor,
                limit: limit,
                withReversible: true,
                before: before,
                after: after,
                code: 1
              })
            }));

          case 6:
            result = _context3.sent;

            if (result) {
              _context3.next = 9;
              break;
            }

            throw new Error('Could not retrieve actions');

          case 9:
            return _context3.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.dfuseTransformGetActions)(result, accountName, this.constants));

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getActionsFromDfuse.apply(this, arguments);
}

function getActionsFromHyperion(_x10, _x11) {
  return _getActionsFromHyperion.apply(this, arguments);
}

function _getActionsFromHyperion() {
  _getActionsFromHyperion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account, _temp3) {
    var _ref3, skip, limit, sort, after, before, filter, tokenFilter, actionFilters, contractFilter, actionFilter, params, result, _tokenFilter$split2, tokenContract, actionFiltersLocal, _iterator, _step, eachFilter, uniqueContracts;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _ref3 = _temp3 === void 0 ? {} : _temp3, skip = _ref3.skip, limit = _ref3.limit, sort = _ref3.sort, after = _ref3.after, before = _ref3.before, filter = _ref3.filter, tokenFilter = _ref3.tokenFilter, actionFilters = _ref3.actionFilters, contractFilter = _ref3.contractFilter, actionFilter = _ref3.actionFilter;
            // Initialize
            params = {
              filter: filter,
              skip: skip,
              limit: limit,
              sort: sort,
              after: after,
              before: before
            };
            console.log('Fetching actions from Hyperion');

            // Token filter, we would only receive undefined or *:action
            if (tokenFilter) {
              _tokenFilter$split2 = tokenFilter.split(' '), tokenContract = _tokenFilter$split2[1];

              if (params.filter) {
                params.filter = params.filter.replace('*', tokenContract);
              } else {
                params.filter = tokenContract + ":*";
              }
            }

            if (actionFilters) {
              actionFiltersLocal = Object.entries(actionFilters).reduce(function (filters, _ref5) {
                var value = _ref5[1];
                return value.isActive ? filters.concat(value) : filters;
              }, []);

              if (actionFiltersLocal.length) {
                for (_iterator = _createForOfIteratorHelperLoose(actionFiltersLocal); !(_step = _iterator()).done;) {
                  eachFilter = _step.value;
                  eachFilter.hyperionQuery(account, params);
                }

                console.log(params);
              }
            } // Actions contract filters


            if (contractFilter) {
              if (params.filter) {
                params.filter = params.filter.split(',').map(function (filter) {
                  return contractFilter + ":" + filter.split(':')[1];
                }).join(',');
              } else {
                params.filter = contractFilter + ":*";
              }
            }

            if (actionFilter) {
              if (params.filter) {
                uniqueContracts = Array.from(new Set(params.filter.split(',').map(function (filter) {
                  return filter.split(':')[0];
                })));
                params.filter = uniqueContracts.map(function (contract) {
                  return contract + ":" + actionFilter;
                }).join(',');
              } else {
                params.filter = "*:" + actionFilter;
              }
            } // If hyperion URL provided, do it client side


            if (!this.constants.HYPERION_URL) {
              _context4.next = 13;
              break;
            }

            _context4.next = 10;
            return this.hyperion.get_actions(account, Object.assign({}, params));

          case 10:
            result = _context4.sent;
            _context4.next = 16;
            break;

          case 13:
            _context4.next = 15;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'hyperion', {
              type: 'get_actions',
              account: account,
              options: Object.assign({}, params)
            }));

          case 15:
            result = _context4.sent;

          case 16:
            if (result) {
              _context4.next = 18;
              break;
            }

            throw new Error('Could not retrieve actions');

          case 18:
            return _context4.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.hyperionTransformGetActions)(result));

          case 19:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getActionsFromHyperion.apply(this, arguments);
}

function getDappStats() {
  return _getDappStats.apply(this, arguments);
}

function _getDappStats() {
  _getDappStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1,
              scope: '......2ke1.o4',
              table: 'statext'
            });

          case 3:
            result = _context.sent;

            if (!(!result || !result.rows || !result.rows.length)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", {});

          case 8:
            return _context.abrupt("return", result.rows[0]);

          case 9:
            _context.next = 15;
            break;

          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", {});

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 11]]);
  }));
  return _getDappStats.apply(this, arguments);
}

function getDspPackages() {
  return _getDspPackages.apply(this, arguments);
}

function _getDspPackages() {
  _getDspPackages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var result;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 500,
              scope: 'dappservices',
              table: 'package'
            });

          case 3:
            result = _context2.sent;
            return _context2.abrupt("return", result && result.rows && result.rows.length ? result.rows : []);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            console.log(_context2.t0);
            return _context2.abrupt("return", []);

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 7]]);
  }));
  return _getDspPackages.apply(this, arguments);
}

function getDapphodlBalance(_x) {
  return _getDapphodlBalance.apply(this, arguments);
}

function _getDapphodlBalance() {
  _getDapphodlBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappairhodl1',
              json: true,
              limit: 1,
              scope: account,
              table: 'accounts'
            });

          case 3:
            result = _context3.sent;
            return _context3.abrupt("return", result && result.rows && result.rows.length ? result.rows[0] : {});

          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](0);
            return _context3.abrupt("return", {});

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 7]]);
  }));
  return _getDapphodlBalance.apply(this, arguments);
}

function getDappBalance(_x2) {
  return _getDappBalance.apply(this, arguments);
}

function _getDappBalance() {
  _getDappBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1,
              scope: account,
              table: 'accounts'
            });

          case 3:
            result = _context4.sent;
            return _context4.abrupt("return", result && result.rows && result.rows.length ? result.rows[0] : {});

          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](0);
            return _context4.abrupt("return", {});

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 7]]);
  }));
  return _getDappBalance.apply(this, arguments);
}

function getDappStakes(_x3) {
  return _getDappStakes.apply(this, arguments);
}

function _getDappStakes() {
  _getDappStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 100,
              scope: account,
              table: 'staking'
            });

          case 3:
            result = _context5.sent;
            return _context5.abrupt("return", result && result.rows && result.rows.length ? result.rows.map(function (row) {
              row.scope = account;
              return row;
            }) : []);

          case 7:
            _context5.prev = 7;
            _context5.t0 = _context5["catch"](0);
            return _context5.abrupt("return", []);

          case 10:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 7]]);
  }));
  return _getDappStakes.apply(this, arguments);
}

function getDapphodlStakes(_x4, _x5) {
  return _getDapphodlStakes.apply(this, arguments);
}

function _getDapphodlStakes() {
  _getDapphodlStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(account, lower_bound) {
    var result, rows;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (lower_bound === void 0) {
              lower_bound = '';
            }

            _context6.prev = 1;
            _context6.next = 4;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1000,
              scope: 'dappairhodl1',
              table: 'staking',
              lower_bound: lower_bound
            });

          case 4:
            result = _context6.sent;

            if (result) {
              _context6.next = 7;
              break;
            }

            return _context6.abrupt("return", []);

          case 7:
            rows = result.rows;

            if (!result.more) {
              _context6.next = 14;
              break;
            }

            _context6.t0 = rows;
            _context6.next = 12;
            return this.getDapphodlStakes(account, +rows[rows.length - 1].id + 1);

          case 12:
            _context6.t1 = _context6.sent;
            rows = _context6.t0.concat.call(_context6.t0, _context6.t1);

          case 14:
            return _context6.abrupt("return", rows.filter(function (row) {
              return row.account === account;
            }).map(function (row) {
              row.scope = 'dappairhodl1';
              return row;
            }));

          case 17:
            _context6.prev = 17;
            _context6.t2 = _context6["catch"](1);
            return _context6.abrupt("return", []);

          case 20:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[1, 17]]);
  }));
  return _getDapphodlStakes.apply(this, arguments);
}

function getDappUnstakes(_x6) {
  return _getDappUnstakes.apply(this, arguments);
}

function _getDappUnstakes() {
  _getDappUnstakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 100,
              scope: account,
              table: 'refunds'
            });

          case 3:
            result = _context7.sent;
            return _context7.abrupt("return", result && result.rows && result.rows.length ? result.rows.map(function (row) {
              row.scope = account;
              return row;
            }) : []);

          case 7:
            _context7.prev = 7;
            _context7.t0 = _context7["catch"](0);
            return _context7.abrupt("return", []);

          case 10:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 7]]);
  }));
  return _getDappUnstakes.apply(this, arguments);
}

function getDapphodlUnstakes(_x7) {
  return _getDapphodlUnstakes.apply(this, arguments);
}

function _getDapphodlUnstakes() {
  _getDapphodlUnstakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(account) {
    var result, rows;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return this.rpc.get_table_rows({
              code: 'dappservices',
              json: true,
              limit: 1000,
              scope: 'dappairhodl1',
              table: 'refunds'
            });

          case 3:
            result = _context8.sent;

            if (result) {
              _context8.next = 6;
              break;
            }

            return _context8.abrupt("return", []);

          case 6:
            rows = result.rows;

            if (!result.more) {
              _context8.next = 13;
              break;
            }

            _context8.t0 = rows;
            _context8.next = 11;
            return this.getDapphodlUnstakes(account);

          case 11:
            _context8.t1 = _context8.sent;
            rows = _context8.t0.concat.call(_context8.t0, _context8.t1);

          case 13:
            return _context8.abrupt("return", rows.filter(function (row) {
              return row.account === account;
            }).map(function (row) {
              row.scope = 'dappairhodl1';
              return row;
            }));

          case 16:
            _context8.prev = 16;
            _context8.t2 = _context8["catch"](0);
            return _context8.abrupt("return", []);

          case 19:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[0, 16]]);
  }));
  return _getDapphodlUnstakes.apply(this, arguments);
}

var http = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var path, method, body, headers, data, response;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            path = _ref.path, method = _ref.method, body = _ref.body, headers = _ref.headers;
            _context.prev = 1;
            _context.next = 4;
            return cross_fetch__WEBPACK_IMPORTED_MODULE_5___default()(path, {
              method: method,
              body: body,
              headers: headers || {
                'Content-Type': 'application/json'
              }
            });

          case 4:
            response = _context.sent;
            _context.next = 7;
            return response.json();

          case 7:
            data = _context.sent;
            _context.next = 13;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);

          case 13:
            if (response && response.ok) {
              _context.next = 15;
              break;
            }

            throw new _proton_js__WEBPACK_IMPORTED_MODULE_0__.RpcError(data || 'Error');

          case 15:
            return _context.abrupt("return", data);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 10]]);
  }));

  return function http(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var get = /*#__PURE__*/function () {
  var _ref3 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, headers) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return http({
              path: path,
              method: 'GET',
              headers: headers
            });

          case 2:
            return _context2.abrupt("return", _context2.sent);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function get(_x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}();
var post = /*#__PURE__*/function () {
  var _ref4 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path, body) {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return http({
              path: path,
              method: 'POST',
              body: JSON.stringify(body)
            });

          case 2:
            return _context3.abrupt("return", _context3.sent);

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function post(_x4, _x5) {
    return _ref4.apply(this, arguments);
  };
}();

function getFIOVoter(_x) {
  return _getFIOVoter.apply(this, arguments);
}

function _getFIOVoter() {
  _getFIOVoter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              upper_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'voters',
              key_type: 'i64',
              index_position: 3,
              limit: 1
            });

          case 3:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context.abrupt("return", rows.length ? rows[0] : undefined);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getFIOVoter.apply(this, arguments);
}

function getFIOAddressByName(_x2) {
  return _getFIOAddressByName.apply(this, arguments);
}

function _getFIOAddressByName() {
  _getFIOAddressByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name) {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.t0 = this.rpc;
            _context2.next = 4;
            return (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.string_to_uint128_hash)(name);

          case 4:
            _context2.t1 = _context2.sent;
            _context2.t2 = '0x' + _context2.t1;
            _context2.t3 = {
              code: 'fio.address',
              scope: 'fio.address',
              table: 'fionames',
              lower_bound: _context2.t2,
              limit: 1,
              key_type: 'i128',
              index_position: 5
            };
            _context2.next = 9;
            return _context2.t0.get_table_rows.call(_context2.t0, _context2.t3);

          case 9:
            _yield$this$rpc$get_t2 = _context2.sent;
            rows = _yield$this$rpc$get_t2.rows;

            if (!(rows && rows.length && rows[0].name === name)) {
              _context2.next = 15;
              break;
            }

            return _context2.abrupt("return", rows[0]);

          case 15:
            return _context2.abrupt("return", undefined);

          case 16:
            _context2.next = 22;
            break;

          case 18:
            _context2.prev = 18;
            _context2.t4 = _context2["catch"](0);
            console.log(_context2.t4);
            return _context2.abrupt("return", undefined);

          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 18]]);
  }));
  return _getFIOAddressByName.apply(this, arguments);
}

function getNFTsByFioAddress(_x3) {
  return _getNFTsByFioAddress.apply(this, arguments);
}

function _getNFTsByFioAddress() {
  _getNFTsByFioAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(name) {
    var _yield$this$rpc$get_n, nfts;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return this.rpc.get_nfts_fio_address(name);

          case 3:
            _yield$this$rpc$get_n = _context3.sent;
            nfts = _yield$this$rpc$get_n.nfts;

            if (!(nfts && nfts.length)) {
              _context3.next = 9;
              break;
            }

            return _context3.abrupt("return", nfts);

          case 9:
            return _context3.abrupt("return", []);

          case 10:
            _context3.next = 16;
            break;

          case 12:
            _context3.prev = 12;
            _context3.t0 = _context3["catch"](0);
            console.log(_context3.t0);
            return _context3.abrupt("return", []);

          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 12]]);
  }));
  return _getNFTsByFioAddress.apply(this, arguments);
}

function getFIODomainByName(_x4) {
  return _getFIODomainByName.apply(this, arguments);
}

function _getFIODomainByName() {
  _getFIODomainByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(name) {
    var _yield$this$rpc$get_t3, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.t0 = this.rpc;
            _context4.next = 4;
            return (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.string_to_uint128_hash)(name);

          case 4:
            _context4.t1 = _context4.sent;
            _context4.t2 = '0x' + _context4.t1;
            _context4.t3 = {
              code: 'fio.address',
              scope: 'fio.address',
              table: 'domains',
              lower_bound: _context4.t2,
              limit: 1,
              key_type: 'i128',
              index_position: 4
            };
            _context4.next = 9;
            return _context4.t0.get_table_rows.call(_context4.t0, _context4.t3);

          case 9:
            _yield$this$rpc$get_t3 = _context4.sent;
            rows = _yield$this$rpc$get_t3.rows;

            if (!(rows && rows.length && rows[0].name === name)) {
              _context4.next = 15;
              break;
            }

            return _context4.abrupt("return", rows[0]);

          case 15:
            return _context4.abrupt("return", undefined);

          case 16:
            _context4.next = 22;
            break;

          case 18:
            _context4.prev = 18;
            _context4.t4 = _context4["catch"](0);
            console.log(_context4.t4);
            return _context4.abrupt("return", undefined);

          case 22:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 18]]);
  }));
  return _getFIODomainByName.apply(this, arguments);
}

function getDomains(_x5, _x6) {
  return _getDomains.apply(this, arguments);
}

function _getDomains() {
  _getDomains = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(limit, upper_bound) {
    var _yield$this$rpc$get_t4, rows;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (limit === void 0) {
              limit = -1;
            }

            _context5.prev = 1;
            _context5.next = 4;
            return this.rpc.get_table_rows({
              code: 'fio.address',
              scope: 'fio.address',
              table: 'domains',
              reverse: true,
              upper_bound: upper_bound,
              limit: limit
            });

          case 4:
            _yield$this$rpc$get_t4 = _context5.sent;
            rows = _yield$this$rpc$get_t4.rows;

            if (!(rows && rows.length)) {
              _context5.next = 10;
              break;
            }

            return _context5.abrupt("return", rows);

          case 10:
            return _context5.abrupt("return", []);

          case 11:
            _context5.next = 17;
            break;

          case 13:
            _context5.prev = 13;
            _context5.t0 = _context5["catch"](1);
            console.log(_context5.t0);
            return _context5.abrupt("return", []);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[1, 13]]);
  }));
  return _getDomains.apply(this, arguments);
}

function getAddresses(_x7, _x8) {
  return _getAddresses.apply(this, arguments);
}

function _getAddresses() {
  _getAddresses = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(limit, upper_bound) {
    var _yield$this$rpc$get_t5, rows;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (limit === void 0) {
              limit = -1;
            }

            _context6.prev = 1;
            _context6.next = 4;
            return this.rpc.get_table_rows({
              code: 'fio.address',
              scope: 'fio.address',
              table: 'fionames',
              reverse: true,
              upper_bound: upper_bound,
              limit: limit
            });

          case 4:
            _yield$this$rpc$get_t5 = _context6.sent;
            rows = _yield$this$rpc$get_t5.rows;

            if (!(rows && rows.length)) {
              _context6.next = 10;
              break;
            }

            return _context6.abrupt("return", rows);

          case 10:
            return _context6.abrupt("return", []);

          case 11:
            _context6.next = 17;
            break;

          case 13:
            _context6.prev = 13;
            _context6.t0 = _context6["catch"](1);
            console.log(_context6.t0);
            return _context6.abrupt("return", []);

          case 17:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[1, 13]]);
  }));
  return _getAddresses.apply(this, arguments);
}

function getFIOProducers(_x9) {
  return _getFIOProducers.apply(this, arguments);
}

function _getFIOProducers() {
  _getFIOProducers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(limit) {
    var _yield$this$rpc$get_t6, rows;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'producers',
              reverse: true,
              limit: limit
            });

          case 3:
            _yield$this$rpc$get_t6 = _context7.sent;
            rows = _yield$this$rpc$get_t6.rows;

            if (!(rows && rows.length)) {
              _context7.next = 9;
              break;
            }

            return _context7.abrupt("return", rows);

          case 9:
            return _context7.abrupt("return", []);

          case 10:
            _context7.next = 16;
            break;

          case 12:
            _context7.prev = 12;
            _context7.t0 = _context7["catch"](0);
            console.log(_context7.t0);
            return _context7.abrupt("return", []);

          case 16:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 12]]);
  }));
  return _getFIOProducers.apply(this, arguments);
}

function getFIOBalance(_x10) {
  return _getFIOBalance.apply(this, arguments);
}

function _getFIOBalance() {
  _getFIOBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(fio_public_key) {
    var balance;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return this.rpc.fetch('/v1/chain/get_fio_balance', {
              fio_public_key: fio_public_key
            });

          case 3:
            balance = _context8.sent;

            if (!balance) {
              _context8.next = 8;
              break;
            }

            return _context8.abrupt("return", balance);

          case 8:
            return _context8.abrupt("return", null);

          case 9:
            _context8.next = 15;
            break;

          case 11:
            _context8.prev = 11;
            _context8.t0 = _context8["catch"](0);
            console.log(_context8.t0);
            return _context8.abrupt("return", null);

          case 15:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[0, 11]]);
  }));
  return _getFIOBalance.apply(this, arguments);
}

function getFIOSupplyBreakdown() {
  return _getFIOSupplyBreakdown.apply(this, arguments);
}

function _getFIOSupplyBreakdown() {
  _getFIOSupplyBreakdown = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
    var tokenRes, supply, bpRewardRes, bpRewards, bpBucketRes, bpBucket, totalBp, circulating, totalLocked;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.rpc.get_table_rows({
              code: "fio.token",
              scope: "FIO",
              table: "stat"
            });

          case 2:
            tokenRes = _context9.sent;
            supply = +tokenRes.rows[0].supply.split(' ')[0];
            _context9.next = 6;
            return this.rpc.get_table_rows({
              code: "fio.treasury",
              scope: "fio.treasury",
              table: "bprewards"
            });

          case 6:
            bpRewardRes = _context9.sent;
            bpRewards = bpRewardRes.rows[0].rewards / Math.pow(10, this.constants.CORE_PRECISION);
            _context9.next = 10;
            return this.rpc.get_table_rows({
              code: "fio.treasury",
              scope: "fio.treasury",
              table: "bpbucketpool"
            });

          case 10:
            bpBucketRes = _context9.sent;
            bpBucket = bpBucketRes.rows[0].rewards / Math.pow(10, this.constants.CORE_PRECISION);
            totalBp = bpRewards + bpBucket; // const totalLocked = baseLocked + totalBp
            // const circulating = supply - totalLocked

            _context9.next = 15;
            return this.get('https://fioprotocol.io/circulating');

          case 15:
            circulating = _context9.sent;
            totalLocked = supply - +circulating;
            return _context9.abrupt("return", {
              supply: supply,
              totalLocked: totalLocked,
              bpRewards: bpRewards,
              bpBucket: bpBucket,
              totalBp: totalBp,
              circulating: circulating
            });

          case 18:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this);
  }));
  return _getFIOSupplyBreakdown.apply(this, arguments);
}

function getFIOFees() {
  return _getFIOFees.apply(this, arguments);
}

function _getFIOFees() {
  _getFIOFees = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            return _context10.abrupt("return", this.rpc.get_table_rows({
              code: 'fio.fee',
              scope: 'fio.fee',
              table: 'fiofees',
              limit: -1
            }).then(function (result) {
              return result.rows;
            })["catch"](function (_) {
              return [];
            }));

          case 1:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, this);
  }));
  return _getFIOFees.apply(this, arguments);
}

function addFIOFeeToActions(_x11, _x12) {
  return _addFIOFeeToActions.apply(this, arguments);
}

function _addFIOFeeToActions() {
  _addFIOFeeToActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(actions, actor) {
    var _this = this;

    var fioFeesMap, fees, modifiedActions, _loop, _iterator, _step;

    return _regeneratorRuntime().wrap(function _callee11$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            fioFeesMap = {
              'eosio::deleteauth': 'auth_delete',
              'eosio::linkauth': 'auth_link',
              'eosio::regproducer': 'register_producer',
              'eosio::regproxy': 'register_proxy',
              'eosio::unregprod': 'unregister_producer',
              'eosio::unregproxy': 'unregister_proxy',
              'eosio::updateauth': 'auth_update',
              'eosio::voteproducer': 'vote_producer',
              'eosio::voteproxy': 'proxy_vote',
              'fio.token::trnsfiopubky': 'transfer_tokens_pub_key',
              'fio.address::addaddress': 'add_pub_address',
              'fio.address::regaddress': 'register_fio_address',
              'fio.address::regdomain': 'register_fio_domain',
              'fio.address::renewaddress': 'renew_fio_address',
              'fio.address::renewdomain': 'renew_fio_domain',
              'fio.address::setdomainpub': 'set_fio_domain_public',
              'eosio.msig::approve': 'msig_approve',
              'eosio.msig::cancel': 'msig_cancel',
              'eosio.msig::exec': 'msig_exec',
              'eosio.msig::invalidate': 'msig_invalidate',
              'eosio.msig::propose': 'msig_propose',
              'eosio.msig::unapprove': 'msig_approve',
              'fio.reqobt::newfundsreq': 'new_funds_request',
              'fio.reqobt::rejectfndreq': 'reject_funds_request',
              'fio.reqobt::cancelfndreq': 'cancelfndreq',
              'fio.reqobt::recordobt': 'record_obt_data',
              'fio.reqobt::newpubaddreq': 'new_pub_address_request',
              'fio.reqobt::relpubadd': 'release_pub_address',
              'fio.reqobt::rejectaddreq': 'reject_pub_address_request',
              'fio.reqobt::canceladdreq': 'cancel_pub_address_request',
              'fio.lock::trnsloctoks': 'transfer_locked_tokens',
              'fio.lock::locktokens': 'lock_tokens',
              'fio.address::remaddress': 'remove_pub_address',
              'fio.address::remalladdr': 'remove_all_pub_addresses',
              'fio.address::burnaddress': 'burn_fio_address',
              'fio.address::xferdomain': 'transfer_fio_domain',
              'fio.address::xferaddress': 'transfer_fio_address'
            };
            _context12.next = 3;
            return this.getFIOFees();

          case 3:
            fees = _context12.sent;
            modifiedActions = [];
            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
              var action, _yield$_this$api$getC, _yield$_this$api$getC2, abiActions, abiStructs, relevantAction, relevantStruct, maxFeeField, endpoint, relevantFee, actorField, tpidField, addressField, addresses;

              return _regeneratorRuntime().wrap(function _loop$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      action = _step.value;
                      _context11.next = 3;
                      return _this.api.getCachedAbi(action.account);

                    case 3:
                      _yield$_this$api$getC = _context11.sent;
                      _yield$_this$api$getC2 = _yield$_this$api$getC.abi;
                      abiActions = _yield$_this$api$getC2.actions;
                      abiStructs = _yield$_this$api$getC2.structs;
                      relevantAction = abiActions.find(function (abiAction) {
                        return abiAction.name === action.name;
                      });

                      if (!relevantAction) {
                        _context11.next = 23;
                        break;
                      }

                      relevantStruct = abiStructs.find(function (abiStruct) {
                        return abiStruct.name === relevantAction.type;
                      });

                      if (!relevantStruct) {
                        _context11.next = 23;
                        break;
                      }

                      maxFeeField = relevantStruct.fields.find(function (field) {
                        return field.name === "max_fee";
                      });

                      if (maxFeeField && action.data.max_fee === undefined) {
                        endpoint = fioFeesMap[action.account + "::" + action.name];

                        if (endpoint) {
                          relevantFee = fees.find(function (fee) {
                            return fee.end_point === endpoint;
                          });

                          if (relevantFee) {
                            action.data.max_fee = relevantFee.suf_amount;
                          } else {
                            action.data.max_fee = 0;
                          }
                        }
                      }

                      actorField = relevantStruct.fields.find(function (field) {
                        return field.name === "actor";
                      });

                      if (actorField && action.data.actor === undefined) {
                        action.data.actor = actor;
                      }

                      tpidField = relevantStruct.fields.find(function (field) {
                        return field.name === "tpid";
                      });

                      if (tpidField && action.data.tpid === undefined) {
                        action.data.tpid = _this.constants.FIO_FEES_ACCOUNT;
                      }

                      addressField = relevantStruct.fields.find(function (field) {
                        return field.name === "fio_address";
                      });

                      if (!(addressField && action.data.fio_address === undefined)) {
                        _context11.next = 23;
                        break;
                      }

                      _context11.next = 21;
                      return _this.getFIOAddresses(actor);

                    case 21:
                      addresses = _context11.sent;

                      if (addresses.length) {
                        action.data.fio_address = addresses[0].name;
                      }

                    case 23:
                      modifiedActions.push(action);

                    case 24:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _loop);
            });
            _iterator = _createForOfIteratorHelperLoose(actions);

          case 7:
            if ((_step = _iterator()).done) {
              _context12.next = 11;
              break;
            }

            return _context12.delegateYield(_loop(), "t0", 9);

          case 9:
            _context12.next = 7;
            break;

          case 11:
            return _context12.abrupt("return", modifiedActions);

          case 12:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee11, this);
  }));
  return _addFIOFeeToActions.apply(this, arguments);
}

function getFIOAddresses(account) {
  return this.rpc.get_table_rows({
    code: 'fio.address',
    scope: 'fio.address',
    table: 'fionames',
    key_type: 'i64',
    limit: -1,
    lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
    upper_bound: new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)).plus(1).toString(),
    index_position: 4
  }).then(function (result) {
    if (result.rows.length > 0) {
      return result.rows.filter(function (row) {
        return row.owner_account === account;
      });
    } else {
      return [];
    }
  })["catch"](function (_) {
    return [];
  });
}
function getFIODomains(account) {
  return this.rpc.get_table_rows({
    code: 'fio.address',
    scope: 'fio.address',
    table: 'domains',
    key_type: 'i64',
    limit: -1,
    lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
    upper_bound: new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)).plus(1).toString(),
    index_position: 2
  }).then(function (result) {
    if (result.rows.length > 0) {
      return result.rows.filter(function (row) {
        return row.account === account;
      });
    } else {
      return [];
    }
  })["catch"](function (_) {
    return [];
  });
}
function getFIOAddressesAndDomains(fio_public_key) {
  return post(this.constants.DEFAULT_ENDPOINTS[0] + "/v1/get_fio_names", {
    fio_public_key: fio_public_key
  });
}

function getAllMsigs() {
  return _getAllMsigs.apply(this, arguments);
}

function _getAllMsigs() {
  _getAllMsigs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$this$get, tables, rows, lower_bound, result;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!this.constants.HISTORY_TYPES.includes('dfuse')) {
              _context.next = 9;
              break;
            }

            _context.next = 3;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'dfuse', {
              type: 'state_scope_pipeline',
              account: this.constants.EOSIO_MSIG,
              table: this.constants.EOSIO_MSIG_PROPOSALS_TABLE,
              options: {}
            }));

          case 3:
            _yield$this$get = _context.sent;
            tables = _yield$this$get.tables;
            tables = tables.map(function (table) {
              table.rows = table.rows.sort(function (a, b) {
                return b.block - a.block;
              });
              table.highestBlock = table.rows[0].block;
              return table;
            }).sort(function (a, b) {
              return b.highestBlock - a.highestBlock;
            });
            return _context.abrupt("return", tables);

          case 9:
            rows = [];
            lower_bound = '';

          case 11:
            _context.next = 13;
            return this.rpc.get_table_by_scope({
              json: true,
              code: 'eosio.msig',
              limit: 100,
              lower_bound: lower_bound,
              table: 'proposal',
              upper_bound: ''
            });

          case 13:
            result = _context.sent;
            lower_bound = result.more;
            rows = rows.concat(result.rows);

          case 16:
            if (lower_bound) {
              _context.next = 11;
              break;
            }

          case 17:
            return _context.abrupt("return", rows.map(function (row) {
              return {
                scope: row.scope,
                rows: Array(row.count).fill({
                  key: ''
                })
              };
            }));

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getAllMsigs.apply(this, arguments);
}

function getMsigProposal(_x, _x2) {
  return _getMsigProposal.apply(this, arguments);
}

function _getMsigProposal() {
  _getMsigProposal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(accountName, proposalName) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: 'eosio.msig',
              scope: accountName,
              limit: 1,
              lower_bound: proposalName,
              table: 'proposal'
            });

          case 2:
            _yield$this$rpc$get_t = _context2.sent;
            rows = _yield$this$rpc$get_t.rows;

            if (!(rows && rows.length && rows[0].proposal_name === proposalName)) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return", rows[0]);

          case 8:
            return _context2.abrupt("return", undefined);

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getMsigProposal.apply(this, arguments);
}

function parsePackedMsigActions(_x3) {
  return _parsePackedMsigActions.apply(this, arguments);
}

function _parsePackedMsigActions() {
  _parsePackedMsigActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(packedActions) {
    var actions, _iterator, _step, action;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            actions = [];
            _iterator = _createForOfIteratorHelperLoose(packedActions);

          case 2:
            if ((_step = _iterator()).done) {
              _context3.next = 15;
              break;
            }

            action = _step.value;

            if (!(action.account === this.constants.EOSIO_MSIG && action.name === 'propose')) {
              _context3.next = 8;
              break;
            }

            _context3.next = 7;
            return this.api.deserializeActionsSync(action.data.trx.actions);

          case 7:
            action.data.trx.actions = _context3.sent;

          case 8:
            if (!(action.account === this.constants.EOSIO && action.name === 'setabi')) {
              _context3.next = 12;
              break;
            }

            _context3.next = 11;
            return this.api.rawAbiToJson((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.hexToUint8Array)(action.data.abi));

          case 11:
            action.data.abi = _context3.sent;

          case 12:
            actions.push(action);

          case 13:
            _context3.next = 2;
            break;

          case 15:
            actions = actions.map(function (action) {
              return {
                action_trace: {
                  act: action
                }
              };
            });
            return _context3.abrupt("return", actions);

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _parsePackedMsigActions.apply(this, arguments);
}

function parsePackedMsig(_x4) {
  return _parsePackedMsig.apply(this, arguments);
}

function _parsePackedMsig() {
  _parsePackedMsig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(packed_transaction) {
    var tx;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.api.deserializeTransactionWithActions(packed_transaction);

          case 3:
            tx = _context4.sent;
            _context4.next = 6;
            return this.parsePackedMsigActions(tx.actions);

          case 6:
            tx.actions = _context4.sent;
            return _context4.abrupt("return", tx);

          case 10:
            _context4.prev = 10;
            _context4.t0 = _context4["catch"](0);
            console.log('Error parsing packed msig');
            console.log(_context4.t0);

          case 14:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 10]]);
  }));
  return _parsePackedMsig.apply(this, arguments);
}

function getFullMsigProposal(_x5, _x6) {
  return _getFullMsigProposal.apply(this, arguments);
}

function _getFullMsigProposal() {
  _getFullMsigProposal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account_name, proposal_name) {
    var result;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO_MSIG,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account_name, false),
              table: this.constants.EOSIO_MSIG_PROPOSALS_TABLE,
              table_key: '',
              key_type: 'name',
              lower_bound: proposal_name,
              index_position: 1,
              limit: 1
            });

          case 3:
            result = _context5.sent;

            if (!(result && result.rows && result.rows.length)) {
              _context5.next = 8;
              break;
            }

            _context5.next = 7;
            return this.parsePackedMsig(result.rows[0].packed_transaction);

          case 7:
            return _context5.abrupt("return", _context5.sent);

          case 8:
            _context5.next = 13;
            break;

          case 10:
            _context5.prev = 10;
            _context5.t0 = _context5["catch"](0);
            console.log(_context5.t0);

          case 13:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 10]]);
  }));
  return _getFullMsigProposal.apply(this, arguments);
}

function getMsigApprovals(_x7, _x8) {
  return _getMsigApprovals.apply(this, arguments);
}

function _getMsigApprovals() {
  _getMsigApprovals = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(account, table) {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            _context6.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO_MSIG,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: table,
              limit: -1
            });

          case 3:
            _yield$this$rpc$get_t2 = _context6.sent;
            rows = _yield$this$rpc$get_t2.rows;
            return _context6.abrupt("return", rows);

          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](0);
            console.log(_context6.t0);
            return _context6.abrupt("return", []);

          case 12:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[0, 8]]);
  }));
  return _getMsigApprovals.apply(this, arguments);
}

function getAccountsMsigProposals(_x9) {
  return _getAccountsMsigProposals.apply(this, arguments);
}

function _getAccountsMsigProposals() {
  _getAccountsMsigProposals = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(account) {
    var promises, _yield$Promise$all, rows2, rows1;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            promises = [this.getMsigApprovals(account, this.constants.EOSIO_MSIG_APPROVALS_TABLE)];

            if (this.constants.EOSIO_MSIG_APPROVALS_TABLE === 'approvals2') {
              promises.push(this.getMsigApprovals(account, 'approvals'));
            }

            _context7.next = 5;
            return Promise.all(promises);

          case 5:
            _yield$Promise$all = _context7.sent;
            rows2 = _yield$Promise$all[0];
            rows1 = _yield$Promise$all[1];
            return _context7.abrupt("return", rows2.concat(rows1));

          case 11:
            _context7.prev = 11;
            _context7.t0 = _context7["catch"](0);
            console.log(_context7.t0);
            return _context7.abrupt("return", []);

          case 15:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 11]]);
  }));
  return _getAccountsMsigProposals.apply(this, arguments);
}

function hyperionGetMsig(_x10) {
  return _hyperionGetMsig.apply(this, arguments);
}

function _hyperionGetMsig() {
  _hyperionGetMsig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(msigFilters) {
    var res, executionTransaction, transaction, proposal, _yield$Promise$all2, actionsRes, actionsRes2, relevantAction, tx;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (this.hyperion) {
              _context8.next = 2;
              break;
            }

            return _context8.abrupt("return", undefined);

          case 2:
            _context8.next = 4;
            return this.hyperion.get_proposals(msigFilters);

          case 4:
            res = _context8.sent;

            if (!(res && res.proposals && res.proposals.length)) {
              _context8.next = 22;
              break;
            }

            proposal = res.proposals[0];
            _context8.next = 9;
            return Promise.all([this.hyperion.get_actions(this.constants.EOSIO_MSIG, {
              block_num: proposal.block_num,
              limit: 1
            }), this.hyperion.get_deltas(this.constants.EOSIO_MSIG, msigFilters.proposer, 'proposal', undefined, {
              block_num: proposal.block_num
            })]);

          case 9:
            _yield$Promise$all2 = _context8.sent;
            actionsRes = _yield$Promise$all2[0];
            actionsRes2 = _yield$Promise$all2[1];

            if (actionsRes && actionsRes.actions && actionsRes.actions.length) {
              relevantAction = actionsRes.actions.find(function (action) {
                return action.act.data.proposal_name === msigFilters.proposal;
              });

              if (relevantAction) {
                executionTransaction = {
                  payer: relevantAction.act.data.executer || relevantAction.act.data.canceler,
                  trx_id: relevantAction.trx_id,
                  published_at: relevantAction.timestamp,
                  cancelled: relevantAction.act.name === 'cancel'
                };
              }
            }

            if (!(actionsRes2 && actionsRes2.deltas && actionsRes2.deltas.length)) {
              _context8.next = 19;
              break;
            }

            tx = actionsRes2.deltas[0].data.transaction;
            _context8.next = 17;
            return this.parsePackedMsigActions(tx.actions);

          case 17:
            tx.actions = _context8.sent;
            transaction = tx;

          case 19:
            return _context8.abrupt("return", {
              approvals: proposal,
              transaction: transaction,
              executionTransaction: executionTransaction
            });

          case 22:
            return _context8.abrupt("return", undefined);

          case 23:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));
  return _hyperionGetMsig.apply(this, arguments);
}

function getVoter(_x) {
  return _getVoter.apply(this, arguments);
}

function _getVoter() {
  _getVoter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              upper_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'voters',
              limit: 1
            });

          case 3:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context.abrupt("return", rows.length ? rows[0] : undefined);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getVoter.apply(this, arguments);
}

function getProxies() {
  return _getProxies.apply(this, arguments);
}

function _getProxies() {
  _getProxies = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var _this = this;

    var _yield$this$get, proxies, _yield$this$hyperion$, voters;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(this.constants.ALOHA_PROXY_URL !== '')) {
              _context2.next = 8;
              break;
            }

            _context2.next = 3;
            return this.get(this.constants.ALOHA_PROXY_URL + "?output=json");

          case 3:
            _yield$this$get = _context2.sent;
            proxies = _yield$this$get.proxies;
            return _context2.abrupt("return", proxies);

          case 8:
            _context2.next = 10;
            return this.hyperion.get_voters({
              proxy: true,
              limit: 1000
            });

          case 10:
            _yield$this$hyperion$ = _context2.sent;
            voters = _yield$this$hyperion$.voters;
            return _context2.abrupt("return", voters.map(function (voter, index) {
              return _extends({}, voter, {
                weight: voter.weight / Math.pow(10, _this.constants.CORE_PRECISION),
                rank: index + 1
              });
            }));

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getProxies.apply(this, arguments);
}

function getVoters(_x2) {
  return _getVoters.apply(this, arguments);
}

function _getVoters() {
  _getVoters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(producer) {
    var _this2 = this;

    var _yield$this$hyperion$2, voters, voteWeight;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!this.hyperion) {
              _context3.next = 9;
              break;
            }

            _context3.next = 3;
            return this.hyperion.get_voters({
              producer: producer,
              limit: 100
            });

          case 3:
            _yield$this$hyperion$2 = _context3.sent;
            voters = _yield$this$hyperion$2.voters;
            voteWeight = this.calculateVoteWeight();
            return _context3.abrupt("return", voters.map(function (voter) {
              return _extends({}, voter, {
                vote: _this2.weightedVoteToNumber(voter.weight, voteWeight)
              });
            }));

          case 9:
            return _context3.abrupt("return", undefined);

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getVoters.apply(this, arguments);
}

function calculateVoteWeight() {
  var decayWeeks = this.constants.CHAIN === 'wax' ? 13 : 52;
  var timestamp_epoch = 946684800000;
  var dates = Date.now() / 1000 - timestamp_epoch / 1000;
  var weight = Math.floor(dates / (86400 * 7)) / decayWeeks;
  return Math.pow(2, weight);
}
function weightedVoteToNumber(weightedVote, voteWeight) {
  if (!voteWeight) {
    voteWeight = this.calculateVoteWeight();
  }

  return +weightedVote / voteWeight / Math.pow(10, this.constants.CORE_PRECISION);
}
function getProxyData(_x3) {
  return _getProxyData.apply(this, arguments);
}

function _getProxyData() {
  _getProxyData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(accountName) {
    var _yield$this$get2, proxy;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(this.constants.ALOHA_PROXY_URL !== '')) {
              _context4.next = 8;
              break;
            }

            _context4.next = 3;
            return this.get(this.constants.ALOHA_PROXY_URL + "/" + accountName + "?output=json");

          case 3:
            _yield$this$get2 = _context4.sent;
            proxy = _yield$this$get2.proxy;
            return _context4.abrupt("return", proxy);

          case 8:
            return _context4.abrupt("return", undefined);

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getProxyData.apply(this, arguments);
}

function getProducersLocal() {
  return _getProducersLocal.apply(this, arguments);
}

function _getProducersLocal() {
  _getProducersLocal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var more, rows, result, lower_bound;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            more = true;
            rows = [];
            result = null;
            lower_bound = null;

          case 4:
            _context5.next = 6;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'producers',
              lower_bound: lower_bound,
              index_position: 1,
              key_type: 'i64',
              limit: 100
            });

          case 6:
            result = _context5.sent;
            more = result.more;
            rows = rows.concat(result.rows);
            lower_bound = new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(rows[rows.length - 1].owner, false)).plus(1).toString();

          case 10:
            if (more) {
              _context5.next = 4;
              break;
            }

          case 11:
            return _context5.abrupt("return", rows);

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _getProducersLocal.apply(this, arguments);
}

function getProducers(_x4, _x5, _x6) {
  return _getProducers.apply(this, arguments);
}

function _getProducers() {
  _getProducers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(pageNum, perPage, local) {
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (pageNum === void 0) {
              pageNum = 1;
            }

            if (perPage === void 0) {
              perPage = 50;
            }

            if (local === void 0) {
              local = false;
            }

            if (!(this.constants.API_URL !== '' && !local)) {
              _context6.next = 9;
              break;
            }

            _context6.next = 6;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'producers', {
              pageNum: pageNum,
              perPage: perPage
            }));

          case 6:
            return _context6.abrupt("return", _context6.sent);

          case 9:
            return _context6.abrupt("return", this.getProducersLocal());

          case 10:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _getProducers.apply(this, arguments);
}

function getChainTable() {
  return _getChainTable.apply(this, arguments);
}

function _getChainTable() {
  _getChainTable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'global',
              limit: 1
            });

          case 2:
            _yield$this$rpc$get_t2 = _context7.sent;
            rows = _yield$this$rpc$get_t2.rows;
            return _context7.abrupt("return", rows[0]);

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _getChainTable.apply(this, arguments);
}

var KycStatus;

(function (KycStatus) {
  KycStatus["FAILED"] = "FAILED";
  KycStatus["UNSUBMITTED"] = "UNSUBMITTED";
  KycStatus["PENDING"] = "PENDING";
  KycStatus["PASSED"] = "PASSED";
})(KycStatus || (KycStatus = {}));

var countryOptions = [{
  key: 'AF',
  value: 'AF',
  flag: 'af',
  text: 'Afghanistan'
}, {
  key: 'AX',
  value: 'AX',
  flag: 'ax',
  text: 'Aland Islands'
}, {
  key: 'AL',
  value: 'AL',
  flag: 'al',
  text: 'Albania'
}, {
  key: 'DZ',
  value: 'DZ',
  flag: 'dz',
  text: 'Algeria'
}, {
  key: 'AS',
  value: 'AS',
  flag: 'as',
  text: 'American Samoa'
}, {
  key: 'AD',
  value: 'AD',
  flag: 'ad',
  text: 'Andorra'
}, {
  key: 'AO',
  value: 'AO',
  flag: 'ao',
  text: 'Angola'
}, {
  key: 'AI',
  value: 'AI',
  flag: 'ai',
  text: 'Anguilla'
}, {
  key: 'AG',
  value: 'AG',
  flag: 'ag',
  text: 'Antigua'
}, {
  key: 'AR',
  value: 'AR',
  flag: 'ar',
  text: 'Argentina'
}, {
  key: 'AM',
  value: 'AM',
  flag: 'am',
  text: 'Armenia'
}, {
  key: 'AW',
  value: 'AW',
  flag: 'aw',
  text: 'Aruba'
}, {
  key: 'AU',
  value: 'AU',
  flag: 'au',
  text: 'Australia'
}, {
  key: 'AT',
  value: 'AT',
  flag: 'at',
  text: 'Austria'
}, {
  key: 'AZ',
  value: 'AZ',
  flag: 'az',
  text: 'Azerbaijan'
}, {
  key: 'BS',
  value: 'BS',
  flag: 'bs',
  text: 'Bahamas'
}, {
  key: 'BH',
  value: 'BH',
  flag: 'bh',
  text: 'Bahrain'
}, {
  key: 'BD',
  value: 'BD',
  flag: 'bd',
  text: 'Bangladesh'
}, {
  key: 'BB',
  value: 'BB',
  flag: 'bb',
  text: 'Barbados'
}, {
  key: 'BY',
  value: 'BY',
  flag: 'by',
  text: 'Belarus'
}, {
  key: 'BE',
  value: 'BE',
  flag: 'be',
  text: 'Belgium'
}, {
  key: 'BZ',
  value: 'BZ',
  flag: 'bz',
  text: 'Belize'
}, {
  key: 'BJ',
  value: 'BJ',
  flag: 'bj',
  text: 'Benin'
}, {
  key: 'BM',
  value: 'BM',
  flag: 'bm',
  text: 'Bermuda'
}, {
  key: 'BT',
  value: 'BT',
  flag: 'bt',
  text: 'Bhutan'
}, {
  key: 'BO',
  value: 'BO',
  flag: 'bo',
  text: 'Bolivia'
}, {
  key: 'BA',
  value: 'BA',
  flag: 'ba',
  text: 'Bosnia'
}, {
  key: 'BW',
  value: 'BW',
  flag: 'bw',
  text: 'Botswana'
}, {
  key: 'BV',
  value: 'BV',
  flag: 'bv',
  text: 'Bouvet Island'
}, {
  key: 'BR',
  value: 'BR',
  flag: 'br',
  text: 'Brazil'
}, {
  key: 'VG',
  value: 'VG',
  flag: 'vg',
  text: 'British Virgin Islands'
}, {
  key: 'BN',
  value: 'BN',
  flag: 'bn',
  text: 'Brunei'
}, {
  key: 'BG',
  value: 'BG',
  flag: 'bg',
  text: 'Bulgaria'
}, {
  key: 'BF',
  value: 'BF',
  flag: 'bf',
  text: 'Burkina Faso'
}, {
  key: 'BI',
  value: 'BI',
  flag: 'bi',
  text: 'Burundi'
}, {
  key: 'TC',
  value: 'TC',
  flag: 'tc',
  text: 'Caicos Islands'
}, {
  key: 'KH',
  value: 'KH',
  flag: 'kh',
  text: 'Cambodia'
}, {
  key: 'CM',
  value: 'CM',
  flag: 'cm',
  text: 'Cameroon'
}, {
  key: 'CA',
  value: 'CA',
  flag: 'ca',
  text: 'Canada'
}, {
  key: 'CV',
  value: 'CV',
  flag: 'cv',
  text: 'Cape Verde'
}, {
  key: 'KY',
  value: 'KY',
  flag: 'ky',
  text: 'Cayman Islands'
}, {
  key: 'CF',
  value: 'CF',
  flag: 'cf',
  text: 'Central African Republic'
}, {
  key: 'TD',
  value: 'TD',
  flag: 'td',
  text: 'Chad'
}, {
  key: 'CL',
  value: 'CL',
  flag: 'cl',
  text: 'Chile'
}, {
  key: 'CN',
  value: 'CN',
  flag: 'cn',
  text: 'China'
}, {
  key: 'CX',
  value: 'CX',
  flag: 'cx',
  text: 'Christmas Island'
}, {
  key: 'CC',
  value: 'CC',
  flag: 'cc',
  text: 'Cocos Islands'
}, {
  key: 'CO',
  value: 'CO',
  flag: 'co',
  text: 'Colombia'
}, {
  key: 'KM',
  value: 'KM',
  flag: 'km',
  text: 'Comoros'
}, {
  key: 'CG',
  value: 'CG',
  flag: 'cg',
  text: 'Congo Brazzaville'
}, {
  key: 'CD',
  value: 'CD',
  flag: 'cd',
  text: 'Congo'
}, {
  key: 'CK',
  value: 'CK',
  flag: 'ck',
  text: 'Cook Islands'
}, {
  key: 'CR',
  value: 'CR',
  flag: 'cr',
  text: 'Costa Rica'
}, {
  key: 'CI',
  value: 'CI',
  flag: 'ci',
  text: 'Cote Divoire'
}, {
  key: 'HR',
  value: 'HR',
  flag: 'hr',
  text: 'Croatia'
}, {
  key: 'CU',
  value: 'CU',
  flag: 'cu',
  text: 'Cuba'
}, {
  key: 'CY',
  value: 'CY',
  flag: 'cy',
  text: 'Cyprus'
}, {
  key: 'CZ',
  value: 'CZ',
  flag: 'cz',
  text: 'Czech Republic'
}, {
  key: 'DK',
  value: 'DK',
  flag: 'dk',
  text: 'Denmark'
}, {
  key: 'DJ',
  value: 'DJ',
  flag: 'dj',
  text: 'Djibouti'
}, {
  key: 'DM',
  value: 'DM',
  flag: 'dm',
  text: 'Dominica'
}, {
  key: 'DO',
  value: 'DO',
  flag: 'do',
  text: 'Dominican Republic'
}, {
  key: 'EC',
  value: 'EC',
  flag: 'ec',
  text: 'Ecuador'
}, {
  key: 'EG',
  value: 'EG',
  flag: 'eg',
  text: 'Egypt'
}, {
  key: 'SV',
  value: 'SV',
  flag: 'sv',
  text: 'El Salvador'
}, {
  key: 'GB',
  value: 'GB',
  flag: 'gb',
  text: 'England'
}, {
  key: 'GQ',
  value: 'GQ',
  flag: 'gq',
  text: 'Equatorial Guinea'
}, {
  key: 'ER',
  value: 'ER',
  flag: 'er',
  text: 'Eritrea'
}, {
  key: 'EE',
  value: 'EE',
  flag: 'ee',
  text: 'Estonia'
}, {
  key: 'ET',
  value: 'ET',
  flag: 'et',
  text: 'Ethiopia'
}, {
  key: 'EU',
  value: 'EU',
  flag: 'eu',
  text: 'European Union'
}, {
  key: 'FK',
  value: 'FK',
  flag: 'fk',
  text: 'Falkland Islands'
}, {
  key: 'FO',
  value: 'FO',
  flag: 'fo',
  text: 'Faroe Islands'
}, {
  key: 'FJ',
  value: 'FJ',
  flag: 'fj',
  text: 'Fiji'
}, {
  key: 'FI',
  value: 'FI',
  flag: 'fi',
  text: 'Finland'
}, {
  key: 'FR',
  value: 'FR',
  flag: 'fr',
  text: 'France'
}, {
  key: 'GF',
  value: 'GF',
  flag: 'gf',
  text: 'French Guiana'
}, {
  key: 'PF',
  value: 'PF',
  flag: 'pf',
  text: 'French Polynesia'
}, {
  key: 'TF',
  value: 'TF',
  flag: 'tf',
  text: 'French Territories'
}, {
  key: 'GA',
  value: 'GA',
  flag: 'ga',
  text: 'Gabon'
}, {
  key: 'GM',
  value: 'GM',
  flag: 'gm',
  text: 'Gambia'
}, {
  key: 'GE',
  value: 'GE',
  flag: 'ge',
  text: 'Georgia'
}, {
  key: 'DE',
  value: 'DE',
  flag: 'de',
  text: 'Germany'
}, {
  key: 'GH',
  value: 'GH',
  flag: 'gh',
  text: 'Ghana'
}, {
  key: 'GI',
  value: 'GI',
  flag: 'gi',
  text: 'Gibraltar'
}, {
  key: 'GR',
  value: 'GR',
  flag: 'gr',
  text: 'Greece'
}, {
  key: 'GL',
  value: 'GL',
  flag: 'gl',
  text: 'Greenland'
}, {
  key: 'GD',
  value: 'GD',
  flag: 'gd',
  text: 'Grenada'
}, {
  key: 'GP',
  value: 'GP',
  flag: 'gp',
  text: 'Guadeloupe'
}, {
  key: 'GU',
  value: 'GU',
  flag: 'gu',
  text: 'Guam'
}, {
  key: 'GT',
  value: 'GT',
  flag: 'gt',
  text: 'Guatemala'
}, {
  key: 'GW',
  value: 'GW',
  flag: 'gw',
  text: 'Guinea-Bissau'
}, {
  key: 'GN',
  value: 'GN',
  flag: 'gn',
  text: 'Guinea'
}, {
  key: 'GY',
  value: 'GY',
  flag: 'gy',
  text: 'Guyana'
}, {
  key: 'HT',
  value: 'HT',
  flag: 'ht',
  text: 'Haiti'
}, {
  key: 'HM',
  value: 'HM',
  flag: 'hm',
  text: 'Heard Island'
}, {
  key: 'HN',
  value: 'HN',
  flag: 'hn',
  text: 'Honduras'
}, {
  key: 'HK',
  value: 'HK',
  flag: 'hk',
  text: 'Hong Kong'
}, {
  key: 'HU',
  value: 'HU',
  flag: 'hu',
  text: 'Hungary'
}, {
  key: 'IS',
  value: 'IS',
  flag: 'is',
  text: 'Iceland'
}, {
  key: 'IN',
  value: 'IN',
  flag: 'in',
  text: 'India'
}, {
  key: 'IO',
  value: 'IO',
  flag: 'io',
  text: 'Indian Ocean Territory'
}, {
  key: 'ID',
  value: 'ID',
  flag: 'id',
  text: 'Indonesia'
}, {
  key: 'IR',
  value: 'IR',
  flag: 'ir',
  text: 'Iran'
}, {
  key: 'IQ',
  value: 'IQ',
  flag: 'iq',
  text: 'Iraq'
}, {
  key: 'IE',
  value: 'IE',
  flag: 'ie',
  text: 'Ireland'
}, {
  key: 'IL',
  value: 'IL',
  flag: 'il',
  text: 'Israel'
}, {
  key: 'IT',
  value: 'IT',
  flag: 'it',
  text: 'Italy'
}, {
  key: 'JM',
  value: 'JM',
  flag: 'jm',
  text: 'Jamaica'
}, {
  key: 'JP',
  value: 'JP',
  flag: 'jp',
  text: 'Japan'
}, {
  key: 'JO',
  value: 'JO',
  flag: 'jo',
  text: 'Jordan'
}, {
  key: 'KZ',
  value: 'KZ',
  flag: 'kz',
  text: 'Kazakhstan'
}, {
  key: 'KE',
  value: 'KE',
  flag: 'ke',
  text: 'Kenya'
}, {
  key: 'KI',
  value: 'KI',
  flag: 'ki',
  text: 'Kiribati'
}, {
  key: 'KW',
  value: 'KW',
  flag: 'kw',
  text: 'Kuwait'
}, {
  key: 'KG',
  value: 'KG',
  flag: 'kg',
  text: 'Kyrgyzstan'
}, {
  key: 'LA',
  value: 'LA',
  flag: 'la',
  text: 'Laos'
}, {
  key: 'LV',
  value: 'LV',
  flag: 'lv',
  text: 'Latvia'
}, {
  key: 'LB',
  value: 'LB',
  flag: 'lb',
  text: 'Lebanon'
}, {
  key: 'LS',
  value: 'LS',
  flag: 'ls',
  text: 'Lesotho'
}, {
  key: 'LR',
  value: 'LR',
  flag: 'lr',
  text: 'Liberia'
}, {
  key: 'LY',
  value: 'LY',
  flag: 'ly',
  text: 'Libya'
}, {
  key: 'LI',
  value: 'LI',
  flag: 'li',
  text: 'Liechtenstein'
}, {
  key: 'LT',
  value: 'LT',
  flag: 'lt',
  text: 'Lithuania'
}, {
  key: 'LU',
  value: 'LU',
  flag: 'lu',
  text: 'Luxembourg'
}, {
  key: 'MO',
  value: 'MO',
  flag: 'mo',
  text: 'Macau'
}, {
  key: 'MK',
  value: 'MK',
  flag: 'mk',
  text: 'Macedonia'
}, {
  key: 'MG',
  value: 'MG',
  flag: 'mg',
  text: 'Madagascar'
}, {
  key: 'MW',
  value: 'MW',
  flag: 'mw',
  text: 'Malawi'
}, {
  key: 'MY',
  value: 'MY',
  flag: 'my',
  text: 'Malaysia'
}, {
  key: 'MV',
  value: 'MV',
  flag: 'mv',
  text: 'Maldives'
}, {
  key: 'ML',
  value: 'ML',
  flag: 'ml',
  text: 'Mali'
}, {
  key: 'MT',
  value: 'MT',
  flag: 'mt',
  text: 'Malta'
}, {
  key: 'MH',
  value: 'MH',
  flag: 'mh',
  text: 'Marshall Islands'
}, {
  key: 'MQ',
  value: 'MQ',
  flag: 'mq',
  text: 'Martinique'
}, {
  key: 'MR',
  value: 'MR',
  flag: 'mr',
  text: 'Mauritania'
}, {
  key: 'MU',
  value: 'MU',
  flag: 'mu',
  text: 'Mauritius'
}, {
  key: 'YT',
  value: 'YT',
  flag: 'yt',
  text: 'Mayotte'
}, {
  key: 'MX',
  value: 'MX',
  flag: 'mx',
  text: 'Mexico'
}, {
  key: 'FM',
  value: 'FM',
  flag: 'fm',
  text: 'Micronesia'
}, {
  key: 'MD',
  value: 'MD',
  flag: 'md',
  text: 'Moldova'
}, {
  key: 'MC',
  value: 'MC',
  flag: 'mc',
  text: 'Monaco'
}, {
  key: 'MN',
  value: 'MN',
  flag: 'mn',
  text: 'Mongolia'
}, {
  key: 'ME',
  value: 'ME',
  flag: 'me',
  text: 'Montenegro'
}, {
  key: 'MS',
  value: 'MS',
  flag: 'ms',
  text: 'Montserrat'
}, {
  key: 'MA',
  value: 'MA',
  flag: 'ma',
  text: 'Morocco'
}, {
  key: 'MZ',
  value: 'MZ',
  flag: 'mz',
  text: 'Mozambique'
}, {
  key: 'NA',
  value: 'NA',
  flag: 'na',
  text: 'Namibia'
}, {
  key: 'NR',
  value: 'NR',
  flag: 'nr',
  text: 'Nauru'
}, {
  key: 'NP',
  value: 'NP',
  flag: 'np',
  text: 'Nepal'
}, {
  key: 'AN',
  value: 'AN',
  flag: 'an',
  text: 'Netherlands Antilles'
}, {
  key: 'NL',
  value: 'NL',
  flag: 'nl',
  text: 'Netherlands'
}, {
  key: 'NC',
  value: 'NC',
  flag: 'nc',
  text: 'New Caledonia'
}, {
  key: 'PG',
  value: 'PG',
  flag: 'pg',
  text: 'New Guinea'
}, {
  key: 'NZ',
  value: 'NZ',
  flag: 'nz',
  text: 'New Zealand'
}, {
  key: 'NI',
  value: 'NI',
  flag: 'ni',
  text: 'Nicaragua'
}, {
  key: 'NE',
  value: 'NE',
  flag: 'ne',
  text: 'Niger'
}, {
  key: 'NG',
  value: 'NG',
  flag: 'ng',
  text: 'Nigeria'
}, {
  key: 'NU',
  value: 'NU',
  flag: 'nu',
  text: 'Niue'
}, {
  key: 'NF',
  value: 'NF',
  flag: 'nf',
  text: 'Norfolk Island'
}, {
  key: 'KP',
  value: 'KP',
  flag: 'kp',
  text: 'North Korea'
}, {
  key: 'MP',
  value: 'MP',
  flag: 'mp',
  text: 'Northern Mariana Islands'
}, {
  key: 'NO',
  value: 'NO',
  flag: 'no',
  text: 'Norway'
}, {
  key: 'OM',
  value: 'OM',
  flag: 'om',
  text: 'Oman'
}, {
  key: 'PK',
  value: 'PK',
  flag: 'pk',
  text: 'Pakistan'
}, {
  key: 'PW',
  value: 'PW',
  flag: 'pw',
  text: 'Palau'
}, {
  key: 'PS',
  value: 'PS',
  flag: 'ps',
  text: 'Palestine'
}, {
  key: 'PA',
  value: 'PA',
  flag: 'pa',
  text: 'Panama'
}, {
  key: 'PY',
  value: 'PY',
  flag: 'py',
  text: 'Paraguay'
}, {
  key: 'PE',
  value: 'PE',
  flag: 'pe',
  text: 'Peru'
}, {
  key: 'PH',
  value: 'PH',
  flag: 'ph',
  text: 'Philippines'
}, {
  key: 'PN',
  value: 'PN',
  flag: 'pn',
  text: 'Pitcairn Islands'
}, {
  key: 'PL',
  value: 'PL',
  flag: 'pl',
  text: 'Poland'
}, {
  key: 'PT',
  value: 'PT',
  flag: 'pt',
  text: 'Portugal'
}, {
  key: 'PR',
  value: 'PR',
  flag: 'pr',
  text: 'Puerto Rico'
}, {
  key: 'QA',
  value: 'QA',
  flag: 'qa',
  text: 'Qatar'
}, {
  key: 'RE',
  value: 'RE',
  flag: 're',
  text: 'Reunion'
}, {
  key: 'RO',
  value: 'RO',
  flag: 'ro',
  text: 'Romania'
}, {
  key: 'RU',
  value: 'RU',
  flag: 'ru',
  text: 'Russia'
}, {
  key: 'RW',
  value: 'RW',
  flag: 'rw',
  text: 'Rwanda'
}, {
  key: 'SH',
  value: 'SH',
  flag: 'sh',
  text: 'Saint Helena'
}, {
  key: 'KN',
  value: 'KN',
  flag: 'kn',
  text: 'Saint Kitts and Nevis'
}, {
  key: 'LC',
  value: 'LC',
  flag: 'lc',
  text: 'Saint Lucia'
}, {
  key: 'PM',
  value: 'PM',
  flag: 'pm',
  text: 'Saint Pierre'
}, {
  key: 'VC',
  value: 'VC',
  flag: 'vc',
  text: 'Saint Vincent'
}, {
  key: 'WS',
  value: 'WS',
  flag: 'ws',
  text: 'Samoa'
}, {
  key: 'SM',
  value: 'SM',
  flag: 'sm',
  text: 'San Marino'
}, {
  key: 'GS',
  value: 'GS',
  flag: 'gs',
  text: 'Sandwich Islands'
}, {
  key: 'ST',
  value: 'ST',
  flag: 'st',
  text: 'Sao Tome'
}, {
  key: 'SA',
  value: 'SA',
  flag: 'sa',
  text: 'Saudi Arabia'
}, {
  key: 'SN',
  value: 'SN',
  flag: 'sn',
  text: 'Senegal'
}, {
  key: 'CS',
  value: 'CS',
  flag: 'cs',
  text: 'Serbia'
}, {
  key: 'RS',
  value: 'RS',
  flag: 'rs',
  text: 'Serbia'
}, {
  key: 'SC',
  value: 'SC',
  flag: 'sc',
  text: 'Seychelles'
}, {
  key: 'SL',
  value: 'SL',
  flag: 'sl',
  text: 'Sierra Leone'
}, {
  key: 'SG',
  value: 'SG',
  flag: 'sg',
  text: 'Singapore'
}, {
  key: 'SK',
  value: 'SK',
  flag: 'sk',
  text: 'Slovakia'
}, {
  key: 'SI',
  value: 'SI',
  flag: 'si',
  text: 'Slovenia'
}, {
  key: 'SB',
  value: 'SB',
  flag: 'sb',
  text: 'Solomon Islands'
}, {
  key: 'SO',
  value: 'SO',
  flag: 'so',
  text: 'Somalia'
}, {
  key: 'ZA',
  value: 'ZA',
  flag: 'za',
  text: 'South Africa'
}, {
  key: 'KR',
  value: 'KR',
  flag: 'kr',
  text: 'South Korea'
}, {
  key: 'ES',
  value: 'ES',
  flag: 'es',
  text: 'Spain'
}, {
  key: 'LK',
  value: 'LK',
  flag: 'lk',
  text: 'Sri Lanka'
}, {
  key: 'SD',
  value: 'SD',
  flag: 'sd',
  text: 'Sudan'
}, {
  key: 'SR',
  value: 'SR',
  flag: 'sr',
  text: 'Suriname'
}, {
  key: 'SJ',
  value: 'SJ',
  flag: 'sj',
  text: 'Svalbard'
}, {
  key: 'SZ',
  value: 'SZ',
  flag: 'sz',
  text: 'Swaziland'
}, {
  key: 'SE',
  value: 'SE',
  flag: 'se',
  text: 'Sweden'
}, {
  key: 'CH',
  value: 'CH',
  flag: 'ch',
  text: 'Switzerland'
}, {
  key: 'SY',
  value: 'SY',
  flag: 'sy',
  text: 'Syria'
}, {
  key: 'TW',
  value: 'TW',
  flag: 'tw',
  text: 'Taiwan'
}, {
  key: 'TJ',
  value: 'TJ',
  flag: 'tj',
  text: 'Tajikistan'
}, {
  key: 'TZ',
  value: 'TZ',
  flag: 'tz',
  text: 'Tanzania'
}, {
  key: 'TH',
  value: 'TH',
  flag: 'th',
  text: 'Thailand'
}, {
  key: 'TL',
  value: 'TL',
  flag: 'tl',
  text: 'Timorleste'
}, {
  key: 'TG',
  value: 'TG',
  flag: 'tg',
  text: 'Togo'
}, {
  key: 'TK',
  value: 'TK',
  flag: 'tk',
  text: 'Tokelau'
}, {
  key: 'TO',
  value: 'TO',
  flag: 'to',
  text: 'Tonga'
}, {
  key: 'TT',
  value: 'TT',
  flag: 'tt',
  text: 'Trinidad'
}, {
  key: 'TN',
  value: 'TN',
  flag: 'tn',
  text: 'Tunisia'
}, {
  key: 'TR',
  value: 'TR',
  flag: 'tr',
  text: 'Turkey'
}, {
  key: 'TM',
  value: 'TM',
  flag: 'tm',
  text: 'Turkmenistan'
}, {
  key: 'TV',
  value: 'TV',
  flag: 'tv',
  text: 'Tuvalu'
}, {
  key: 'UG',
  value: 'UG',
  flag: 'ug',
  text: 'Uganda'
}, {
  key: 'UA',
  value: 'UA',
  flag: 'ua',
  text: 'Ukraine'
}, {
  key: 'AE',
  value: 'AE',
  flag: 'ae',
  text: 'United Arab Emirates'
}, {
  key: 'US',
  value: 'US',
  flag: 'us',
  text: 'United States'
}, {
  key: 'UY',
  value: 'UY',
  flag: 'uy',
  text: 'Uruguay'
}, {
  key: 'UM',
  value: 'UM',
  flag: 'um',
  text: 'Us Minor Islands'
}, {
  key: 'VI',
  value: 'VI',
  flag: 'vi',
  text: 'Us Virgin Islands'
}, {
  key: 'UZ',
  value: 'UZ',
  flag: 'uz',
  text: 'Uzbekistan'
}, {
  key: 'VU',
  value: 'VU',
  flag: 'vu',
  text: 'Vanuatu'
}, {
  key: 'VA',
  value: 'VA',
  flag: 'va',
  text: 'Vatican City'
}, {
  key: 'VE',
  value: 'VE',
  flag: 've',
  text: 'Venezuela'
}, {
  key: 'VN',
  value: 'VN',
  flag: 'vn',
  text: 'Vietnam'
}, {
  key: 'WF',
  value: 'WF',
  flag: 'wf',
  text: 'Wallis and Futuna'
}, {
  key: 'EH',
  value: 'EH',
  flag: 'eh',
  text: 'Western Sahara'
}, {
  key: 'YE',
  value: 'YE',
  flag: 'ye',
  text: 'Yemen'
}, {
  key: 'ZM',
  value: 'ZM',
  flag: 'zm',
  text: 'Zambia'
}, {
  key: 'ZW',
  value: 'ZW',
  flag: 'zw',
  text: 'Zimbabwe'
}];

function fetchKycCountries(_x) {
  return _fetchKycCountries.apply(this, arguments);
}
/**
 * FAILED
 * UNSUBMITTED
 * PENDING
 * PASSED
 */

function _fetchKycCountries() {
  _fetchKycCountries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var chain, url, _yield$this$get, countries, countriesById;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            chain = _ref.chain;
            url = this.constants.BLOKS_API + "/" + chain + "/kyc?type=countries&chain=" + chain;
            _context.next = 4;
            return this.get(url);

          case 4:
            _yield$this$get = _context.sent;
            countries = _yield$this$get.content;
            countriesById = countries.reduce(function (acc, country) {
              acc[country.id] = country;
              return acc;
            }, {});
            return _context.abrupt("return", countryOptions.filter(function (countryOption) {
              return countriesById[countryOption.key];
            }));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _fetchKycCountries.apply(this, arguments);
}

function checkUserKycStatus(_x2) {
  return _checkUserKycStatus.apply(this, arguments);
}

function _checkUserKycStatus() {
  _checkUserKycStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref2) {
    var _this = this;

    var chain, actor, expectedTier;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            chain = _ref2.chain, actor = _ref2.actor, expectedTier = _ref2.expectedTier;

            if (!(!chain || !actor || !expectedTier)) {
              _context4.next = 3;
              break;
            }

            throw new Error('Invalid parameters');

          case 3:
            return _context4.abrupt("return", new Promise( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject) {
                var getStatus;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        // Get all KYC records for user
                        getStatus = /*#__PURE__*/function () {
                          var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                            var _yield$_this$rpc$isLi, userInfo, url, kyc, matchedTier, status;

                            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                              while (1) {
                                switch (_context2.prev = _context2.next) {
                                  case 0:
                                    _context2.next = 2;
                                    return _this.rpc.isLightKYCVerified(actor);

                                  case 2:
                                    _yield$_this$rpc$isLi = _context2.sent;
                                    userInfo = _yield$_this$rpc$isLi[0];

                                    if (!(userInfo && userInfo.isLightKYCVerified)) {
                                      _context2.next = 6;
                                      break;
                                    }

                                    return _context2.abrupt("return", resolve(KycStatus.PASSED));

                                  case 6:
                                    url = _this.constants.BLOKS_API + "/" + chain + "/kyc?type=status&chain=" + chain + "&actor=" + actor;
                                    _context2.next = 9;
                                    return _this.get(url);

                                  case 9:
                                    kyc = _context2.sent;

                                    if (!(!kyc || !kyc.length)) {
                                      _context2.next = 12;
                                      break;
                                    }

                                    return _context2.abrupt("return", reject(new Error('Could not fetch KYC record')));

                                  case 12:
                                    // Find relevant KYC record
                                    matchedTier = kyc.find(function (_ref5) {
                                      var tier = _ref5.tier;
                                      return tier === String(expectedTier);
                                    });

                                    if (matchedTier) {
                                      _context2.next = 15;
                                      break;
                                    }

                                    return _context2.abrupt("return", reject(new Error('No kyc data matching tier found')));

                                  case 15:
                                    // Unwrap kyc data
                                    status = matchedTier.status;

                                    if (matchedTier.status) {
                                      _context2.next = 18;
                                      break;
                                    }

                                    return _context2.abrupt("return", reject(new Error('KYC Status not found')));

                                  case 18:
                                    if (!(status === KycStatus.PENDING)) {
                                      _context2.next = 22;
                                      break;
                                    }

                                    setTimeout(function () {
                                      return getStatus();
                                    }, 1000 * 2);
                                    _context2.next = 23;
                                    break;

                                  case 22:
                                    return _context2.abrupt("return", resolve(status));

                                  case 23:
                                  case "end":
                                    return _context2.stop();
                                }
                              }
                            }, _callee2);
                          }));

                          return function getStatus() {
                            return _ref4.apply(this, arguments);
                          };
                        }();

                        getStatus();

                      case 2:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x4, _x5) {
                return _ref3.apply(this, arguments);
              };
            }()));

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _checkUserKycStatus.apply(this, arguments);
}

function applyForKyc(_x3) {
  return _applyForKyc.apply(this, arguments);
}

function _applyForKyc() {
  _applyForKyc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(params) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            url = this.constants.BLOKS_API + "/" + params.chain + "/kyc";
            _context5.next = 3;
            return this.post(url, _extends({
              type: 'apply'
            }, params));

          case 3:
            data = _context5.sent;

            if (!data) {
              _context5.next = 8;
              break;
            }

            return _context5.abrupt("return", data);

          case 8:
            throw new Error('Could not apply for KYC');

          case 9:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _applyForKyc.apply(this, arguments);
}

var chainInfoParser = /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.object({
  chainId: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  explorerUrl: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  explorerName: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  resourceTokenSymbol: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  resourceTokenContract: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  systemTokenSymbol: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  systemTokenContract: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string(),
  rpcEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string()),
  actionsRpcEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string()),
  hyperionEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string()),
  lightEndpoints: /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.array( /*#__PURE__*/zod__WEBPACK_IMPORTED_MODULE_9__.z.string())
});

function getChainInfo() {
  return _getChainInfo.apply(this, arguments);
}

function _getChainInfo() {
  _getChainInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = this.constants.CHAIN === 'proton-test' ? 'https://raw.githubusercontent.com/ProtonProtocol/chain-info/main/testnet.json' : 'https://raw.githubusercontent.com/ProtonProtocol/chain-info/main/mainnet.json';
            _context.prev = 1;
            _context.next = 4;
            return this.get(url, {});

          case 4:
            data = _context.sent;
            return _context.abrupt("return", chainInfoParser.parse(data));

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);
            return _context.abrupt("return", undefined);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 8]]);
  }));
  return _getChainInfo.apply(this, arguments);
}

function getTokenPrices() {
  return _getTokenPrices.apply(this, arguments);
}

function _getTokenPrices() {
  _getTokenPrices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v1/chain/exchange-rates/info";
            _context2.prev = 1;
            _context2.next = 4;
            return this.get(url);

          case 4:
            data = _context2.sent;
            return _context2.abrupt("return", _proton_wrap_constants__WEBPACK_IMPORTED_MODULE_7__.exchangeRatesParser.parse(data));

          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](1);
            throw new Error("Could not fetch exchange rates");

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[1, 8]]);
  }));
  return _getTokenPrices.apply(this, arguments);
}

function getWithdrawalFee(_x) {
  return _getWithdrawalFee.apply(this, arguments);
}

function _getWithdrawalFee() {
  _getWithdrawalFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref) {
    var currency, network, url, data;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            currency = _ref.currency, network = _ref.network;
            url = this.constants.METAL_PROTON_ENDPOINT + "/v1/swaps/calculate-estimated-fee";
            _context3.prev = 2;
            _context3.next = 5;
            return this.post(url, {
              currency: currency,
              network: network
            });

          case 5:
            data = _context3.sent;
            return _context3.abrupt("return", _proton_wrap_constants__WEBPACK_IMPORTED_MODULE_7__.withdrawalFeeQuoteParser.parse(data));

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            console.log(_context3.t0);
            return _context3.abrupt("return", undefined);

          case 13:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[2, 9]]);
  }));
  return _getWithdrawalFee.apply(this, arguments);
}

function currentLocation() {
  return _currentLocation.apply(this, arguments);
}

function _currentLocation() {
  _currentLocation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    var url;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v1/kyc/ip-info";
            _context4.next = 3;
            return this.get(url);

          case 3:
            return _context4.abrupt("return", _context4.sent);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _currentLocation.apply(this, arguments);
}

function getAvailableFeatures(_x2) {
  return _getAvailableFeatures.apply(this, arguments);
}

function _getAvailableFeatures() {
  _getAvailableFeatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var url;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + ("/v2/kyc/by-chain-account/" + account + "/available-features");
            _context5.next = 3;
            return this.get(url);

          case 3:
            return _context5.abrupt("return", _context5.sent);

          case 4:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _getAvailableFeatures.apply(this, arguments);
}

function createAccount(_x3) {
  return _createAccount.apply(this, arguments);
}

function _createAccount() {
  _createAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v2/users/create";
            _context6.next = 3;
            return this.post(url, params);

          case 3:
            data = _context6.sent;
            return _context6.abrupt("return", data);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _createAccount.apply(this, arguments);
}

function loginAccount(_x4) {
  return _loginAccount.apply(this, arguments);
}

function _loginAccount() {
  _loginAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(params) {
    var url, data;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            url = this.constants.METAL_PROTON_ENDPOINT + "/v2/users/login";
            _context7.next = 3;
            return this.post(url, params);

          case 3:
            data = _context7.sent;
            return _context7.abrupt("return", data);

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _loginAccount.apply(this, arguments);
}

function otcQuote(_x) {
  return _otcQuote.apply(this, arguments);
}

function _otcQuote() {
  _otcQuote = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = this.constants.SWAP_URL + ("/v1/quote/" + body.baseSymbol + "/" + body.baseAmount + "/" + body.quoteSymbol);
            _context.next = 3;
            return this.get(url);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _otcQuote.apply(this, arguments);
}

function otcOrder(_x2) {
  return _otcOrder.apply(this, arguments);
}

function _otcOrder() {
  _otcOrder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id) {
    var url;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = this.constants.SWAP_URL + ("/v1/order/" + id);
            _context2.next = 3;
            return this.get(url);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _otcOrder.apply(this, arguments);
}

function generateAddress(_x) {
  return _generateAddress.apply(this, arguments);
}

function _generateAddress() {
  _generateAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + '/address/generate';
            _context.next = 3;
            return this.post(url, body);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _generateAddress.apply(this, arguments);
}

function deleteAddress(_x2) {
  return _deleteAddress.apply(this, arguments);
}

function _deleteAddress() {
  _deleteAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + '/address/delete';
            _context2.next = 3;
            return this.post(url, body);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _deleteAddress.apply(this, arguments);
}

function withdrawMetal(_x3) {
  return _withdrawMetal.apply(this, arguments);
}

function _withdrawMetal() {
  _withdrawMetal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(body) {
    var url;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + '/withdraw';
            _context3.next = 3;
            return this.post(url, body);

          case 3:
            return _context3.abrupt("return", _context3.sent);

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _withdrawMetal.apply(this, arguments);
}

function withdrawalHistoryMetal(_x4) {
  return _withdrawalHistoryMetal.apply(this, arguments);
}

function _withdrawalHistoryMetal() {
  _withdrawalHistoryMetal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var url;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            url = this.constants.WRAP_SERVER_URL + ("/withdrawals/" + account);
            _context4.next = 3;
            return this.get(url);

          case 3:
            return _context4.abrupt("return", _context4.sent);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _withdrawalHistoryMetal.apply(this, arguments);
}

function getXprTotalStakedAndApr() {
  return _getXprTotalStakedAndApr.apply(this, arguments);
}

function _getXprTotalStakedAndApr() {
  _getXprTotalStakedAndApr = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$Promise$all, supply, totalStakedUnparsed, _yield$Promise$all$, continuous_rate, inflation_pay_factor, votepay_factor, additionalInflation, new_tokens, to_yieldfarms, bpandsavings, to_producers, to_producers_block, to_producers_vote, savings, to_savings, to_consortium, totalStaked, apr;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return Promise.all([this.getTokenSupply(this.constants.EOSIO_TOKEN, this.constants.CORE_SYMBOL), this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'globalsd',
              limit: 1
            }).then(function (res) {
              return res.rows[0];
            }), this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'global4',
              limit: 1
            }).then(function (res) {
              return res.rows[0];
            })]);

          case 3:
            _yield$Promise$all = _context.sent;
            supply = _yield$Promise$all[0].supply;
            totalStakedUnparsed = _yield$Promise$all[1].totalrstaked;
            _yield$Promise$all$ = _yield$Promise$all[2];
            continuous_rate = _yield$Promise$all$.continuous_rate;
            inflation_pay_factor = _yield$Promise$all$.inflation_pay_factor;
            votepay_factor = _yield$Promise$all$.votepay_factor;
            additionalInflation = +continuous_rate * supply;
            new_tokens = additionalInflation;
            to_yieldfarms = new_tokens / 4;
            bpandsavings = new_tokens - to_yieldfarms;
            to_producers = bpandsavings * (10000 / inflation_pay_factor);
            to_producers_block = to_producers * (10000 / votepay_factor);
            to_producers_vote = to_producers - to_producers_block;
            savings = bpandsavings - to_producers;
            to_savings = 2 * savings / 3;
            to_consortium = savings - to_savings;
            totalStaked = +totalStakedUnparsed / Math.pow(10, this.constants.CORE_PRECISION);
            apr = to_savings / totalStaked * 100;
            return _context.abrupt("return", {
              supply: supply,
              yieldFarming: to_yieldfarms,
              producers: to_producers,
              producersBlock: to_producers_block,
              producersVote: to_producers_vote,
              consortium: to_consortium,
              staking: to_savings,
              totalStaked: totalStaked,
              apr: apr
            });

          case 25:
            _context.prev = 25;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            return _context.abrupt("return", 0);

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 25]]);
  }));
  return _getXprTotalStakedAndApr.apply(this, arguments);
}

function getXprVoter(_x) {
  return _getXprVoter.apply(this, arguments);
}

function _getXprVoter() {
  _getXprVoter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'votersxpr',
              limit: 1
            });

          case 3:
            _yield$this$rpc$get_t = _context2.sent;
            rows = _yield$this$rpc$get_t.rows;

            if (!(rows && rows.length && rows[0].owner === account)) {
              _context2.next = 9;
              break;
            }

            return _context2.abrupt("return", rows[0]);

          case 9:
            return _context2.abrupt("return", undefined);

          case 10:
            _context2.next = 16;
            break;

          case 12:
            _context2.prev = 12;
            _context2.t0 = _context2["catch"](0);
            console.log(_context2.t0);
            return _context2.abrupt("return", undefined);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 12]]);
  }));
  return _getXprVoter.apply(this, arguments);
}

function getXprAccountStakes(_x2) {
  return _getXprAccountStakes.apply(this, arguments);
}

function _getXprAccountStakes() {
  _getXprAccountStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var stakes, _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            stakes = [];
            _context3.prev = 1;
            _context3.next = 4;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'delxpr',
              limit: -1
            });

          case 4:
            _yield$this$rpc$get_t2 = _context3.sent;
            rows = _yield$this$rpc$get_t2.rows;

            if (rows && rows.length) {
              stakes = rows;
            }

            _context3.next = 12;
            break;

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](1);
            console.log(_context3.t0);

          case 12:
            return _context3.abrupt("return", stakes);

          case 13:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[1, 9]]);
  }));
  return _getXprAccountStakes.apply(this, arguments);
}

function getXprAccountRefund(_x3) {
  return _getXprAccountRefund.apply(this, arguments);
}

function _getXprAccountRefund() {
  _getXprAccountRefund = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var refund, _yield$this$rpc$get_t3, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'refundsxpr',
              limit: -1
            });

          case 3:
            _yield$this$rpc$get_t3 = _context4.sent;
            rows = _yield$this$rpc$get_t3.rows;

            if (rows && rows.length) {
              refund = rows[0];
              refund.quantity = +refund.quantity.split(' ')[0];
            }

            _context4.next = 11;
            break;

          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](0);
            console.log(_context4.t0);

          case 11:
            return _context4.abrupt("return", refund);

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 8]]);
  }));
  return _getXprAccountRefund.apply(this, arguments);
}

function getXprOracleData(_x4) {
  return _getXprOracleData.apply(this, arguments);
}

function _getXprOracleData() {
  _getXprOracleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(oracleIndex) {
    var _yield$this$rpc$get_t4, rows;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'data',
              limit: 1,
              lower_bound: oracleIndex,
              upper_bound: oracleIndex
            });

          case 3:
            _yield$this$rpc$get_t4 = _context5.sent;
            rows = _yield$this$rpc$get_t4.rows;

            if (!(rows && rows.length)) {
              _context5.next = 9;
              break;
            }

            return _context5.abrupt("return", rows[0]);

          case 9:
            return _context5.abrupt("return", undefined);

          case 10:
            _context5.next = 16;
            break;

          case 12:
            _context5.prev = 12;
            _context5.t0 = _context5["catch"](0);
            console.log(_context5.t0);
            return _context5.abrupt("return", undefined);

          case 16:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 12]]);
  }));
  return _getXprOracleData.apply(this, arguments);
}

function getAllOracleFeeds(_x5) {
  return _getAllOracleFeeds.apply(this, arguments);
}

function _getAllOracleFeeds() {
  _getAllOracleFeeds = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(lower_bound) {
    var _yield$this$rpc$get_t5, rows, more, next_key, restOfRows;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (lower_bound === void 0) {
              lower_bound = undefined;
            }

            _context6.prev = 1;
            _context6.next = 4;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'feeds',
              limit: -1,
              lower_bound: lower_bound
            });

          case 4:
            _yield$this$rpc$get_t5 = _context6.sent;
            rows = _yield$this$rpc$get_t5.rows;
            more = _yield$this$rpc$get_t5.more;
            next_key = _yield$this$rpc$get_t5.next_key;

            if (!more) {
              _context6.next = 15;
              break;
            }

            _context6.next = 11;
            return this.getAllOracleFeeds(next_key);

          case 11:
            restOfRows = _context6.sent;
            return _context6.abrupt("return", rows.concat(restOfRows));

          case 15:
            return _context6.abrupt("return", rows);

          case 16:
            _context6.next = 22;
            break;

          case 18:
            _context6.prev = 18;
            _context6.t0 = _context6["catch"](1);
            console.log(_context6.t0);
            return _context6.abrupt("return", []);

          case 22:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[1, 18]]);
  }));
  return _getAllOracleFeeds.apply(this, arguments);
}

function getSpecificOracleData(_x6) {
  return _getSpecificOracleData.apply(this, arguments);
} // pub

function _getSpecificOracleData() {
  _getSpecificOracleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(feed_index) {
    var _yield$this$rpc$get_t6, rows;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'data',
              limit: -1,
              lower_bound: feed_index,
              upper_bound: feed_index
            });

          case 3:
            _yield$this$rpc$get_t6 = _context7.sent;
            rows = _yield$this$rpc$get_t6.rows;

            if (!(rows && rows.length && rows[0].feed_index === feed_index)) {
              _context7.next = 7;
              break;
            }

            return _context7.abrupt("return", rows[0]);

          case 7:
            _context7.next = 12;
            break;

          case 9:
            _context7.prev = 9;
            _context7.t0 = _context7["catch"](0);
            console.log(_context7.t0);

          case 12:
            return _context7.abrupt("return", undefined);

          case 13:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[0, 9]]);
  }));
  return _getSpecificOracleData.apply(this, arguments);
}

function getAllOracleData(_x7) {
  return _getAllOracleData.apply(this, arguments);
}

function _getAllOracleData() {
  _getAllOracleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(lower_bound) {
    var _yield$this$rpc$get_t7, rows, more, next_key;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return this.rpc.get_table_rows({
              code: 'oracles',
              scope: 'oracles',
              table: 'data',
              limit: -1,
              lower_bound: lower_bound
            });

          case 3:
            _yield$this$rpc$get_t7 = _context8.sent;
            rows = _yield$this$rpc$get_t7.rows;
            more = _yield$this$rpc$get_t7.more;
            next_key = _yield$this$rpc$get_t7.next_key;

            if (!more) {
              _context8.next = 13;
              break;
            }

            _context8.t0 = rows;
            _context8.next = 11;
            return this.getAllOracleData(next_key);

          case 11:
            _context8.t1 = _context8.sent;
            rows = _context8.t0.concat.call(_context8.t0, _context8.t1);

          case 13:
            return _context8.abrupt("return", rows);

          case 16:
            _context8.prev = 16;
            _context8.t2 = _context8["catch"](0);
            console.log(_context8.t2);
            return _context8.abrupt("return", []);

          case 20:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[0, 16]]);
  }));
  return _getAllOracleData.apply(this, arguments);
}

function getProtonAvatars(_x8, _x9) {
  return _getProtonAvatars.apply(this, arguments);
}

function _getProtonAvatars() {
  _getProtonAvatars = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(account, limit) {
    var result;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (limit === void 0) {
              limit = 10;
            }

            if (!(this.constants.CHAIN.indexOf('proton') !== -1)) {
              _context9.next = 12;
              break;
            }

            _context9.prev = 2;
            _context9.next = 5;
            return this.rpc.get_table_rows({
              json: true,
              code: 'eosio.proton',
              scope: 'eosio.proton',
              table: 'usersinfo',
              table_key: '',
              key_type: 'i64',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 1,
              limit: limit
            });

          case 5:
            result = _context9.sent;
            return _context9.abrupt("return", result.rows);

          case 9:
            _context9.prev = 9;
            _context9.t0 = _context9["catch"](2);
            console.log('getProtonAvatar error', _context9.t0);

          case 12:
            return _context9.abrupt("return", []);

          case 13:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this, [[2, 9]]);
  }));
  return _getProtonAvatars.apply(this, arguments);
}

function getProtonAvatar(_x10) {
  return _getProtonAvatar.apply(this, arguments);
}

function _getProtonAvatar() {
  _getProtonAvatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(account) {
    var result;
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            if (!(this.constants.CHAIN.indexOf('proton') !== -1)) {
              _context10.next = 11;
              break;
            }

            _context10.prev = 1;
            _context10.next = 4;
            return this.rpc.get_table_rows({
              json: true,
              code: 'eosio.proton',
              scope: 'eosio.proton',
              table: 'usersinfo',
              table_key: '',
              key_type: 'i64',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 1,
              limit: 1
            });

          case 4:
            result = _context10.sent;
            return _context10.abrupt("return", result.rows.length > 0 && result.rows[0].acc === account ? result.rows[0] : undefined);

          case 8:
            _context10.prev = 8;
            _context10.t0 = _context10["catch"](1);
            console.log('getProtonAvatar error', _context10.t0);

          case 11:
            return _context10.abrupt("return", undefined);

          case 12:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, this, [[1, 8]]);
  }));
  return _getProtonAvatar.apply(this, arguments);
}

function getRentbwState() {
  return _getRentbwState.apply(this, arguments);
}

function _getRentbwState() {
  _getRentbwState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: 0,
              table: 'powup.state',
              limit: 1
            });

          case 2:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;
            return _context.abrupt("return", rows[0]);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getRentbwState.apply(this, arguments);
}

function delegatedBandwidth(_x, _x2) {
  return _delegatedBandwidth.apply(this, arguments);
}

function _delegatedBandwidth() {
  _delegatedBandwidth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account, lower_bound) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'delband',
              table_key: '',
              limit: -1,
              lower_bound: lower_bound,
              key_type: 'i64',
              index_position: 1
            }));

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _delegatedBandwidth.apply(this, arguments);
}

function getAccountDelegatedBandwidth(_x3) {
  return _getAccountDelegatedBandwidth.apply(this, arguments);
}

function _getAccountDelegatedBandwidth() {
  _getAccountDelegatedBandwidth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var more, rows, result, lower_bound;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            more = true;
            rows = [];
            result = null;
            lower_bound = '';
            _context3.prev = 4;

          case 5:
            _context3.next = 7;
            return this.delegatedBandwidth(account, lower_bound);

          case 7:
            result = _context3.sent;
            more = result.more;
            rows = rows.concat(result.rows);

            if (more) {
              lower_bound = new bignumber_js__WEBPACK_IMPORTED_MODULE_6__.BigNumber((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(rows[rows.length - 1].to, false)).plus(1).toString();
            }

          case 11:
            if (more) {
              _context3.next = 5;
              break;
            }

          case 12:
            _context3.next = 17;
            break;

          case 14:
            _context3.prev = 14;
            _context3.t0 = _context3["catch"](4);
            console.log(_context3.t0);

          case 17:
            return _context3.abrupt("return", rows);

          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[4, 14]]);
  }));
  return _getAccountDelegatedBandwidth.apply(this, arguments);
}

function getAccountResources(_x4) {
  return _getAccountResources.apply(this, arguments);
}

function _getAccountResources() {
  _getAccountResources = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var _yield$this$rpc$get_t2, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              table: 'userres',
              table_key: '',
              limit: 1
            });

          case 2:
            _yield$this$rpc$get_t2 = _context4.sent;
            rows = _yield$this$rpc$get_t2.rows;
            return _context4.abrupt("return", rows[0]);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getAccountResources.apply(this, arguments);
}

function getRamPriceInEos() {
  return _getRamPriceInEos.apply(this, arguments);
}

function _getRamPriceInEos() {
  _getRamPriceInEos = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var ram, baseString, base, quoteString, quote, price, ramPriceEos;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rammarket',
              table_key: '',
              limit: 10
            });

          case 3:
            ram = _context5.sent;
            // Amount of RAM bytes in use
            baseString = ram.rows[0].base.balance;
            base = +baseString.substr(0, baseString.indexOf(' ')); // Amount of EOS in the RAM collector

            quoteString = ram.rows[0].quote.balance;
            quote = quoteString.substr(0, quoteString.indexOf(' ')); // Price in kb

            price = quote / base;
            ramPriceEos = Number(price.toFixed(8)) * 1024;
            return _context5.abrupt("return", ramPriceEos);

          case 13:
            _context5.prev = 13;
            _context5.t0 = _context5["catch"](0);
            console.log(_context5.t0);

          case 16:
            return _context5.abrupt("return", 0);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 13]]);
  }));
  return _getRamPriceInEos.apply(this, arguments);
}

function getEosTopStakes(_x) {
  return _getEosTopStakes.apply(this, arguments);
}

function _getEosTopStakes() {
  _getEosTopStakes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(limit) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (limit === void 0) {
              limit = 500;
            }

            return _context.abrupt("return", this.lightApi.get_topstake(limit));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getEosTopStakes.apply(this, arguments);
}

function getEosTopRams(_x2) {
  return _getEosTopRams.apply(this, arguments);
}

function _getEosTopRams() {
  _getEosTopRams = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(limit) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (limit === void 0) {
              limit = 500;
            }

            return _context2.abrupt("return", this.lightApi.get_topram(limit));

          case 2:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getEosTopRams.apply(this, arguments);
}

function getCurrentNameBids(_x3, _x4) {
  return _getCurrentNameBids.apply(this, arguments);
}

function _getCurrentNameBids() {
  _getCurrentNameBids = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(lower_bound, upper_bound) {
    var _yield$this$rpc$get_t, rows, more, next_key;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (lower_bound === void 0) {
              lower_bound = '';
            }

            if (upper_bound === void 0) {
              upper_bound = '';
            }

            _context3.next = 4;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'namebids',
              key_type: 'i64',
              lower_bound: lower_bound && lower_bound.length <= 12 ? (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(lower_bound, true) : lower_bound,
              upper_bound: upper_bound && upper_bound.length <= 12 ? (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(upper_bound, true) : upper_bound,
              index_position: 1,
              limit: -1
            });

          case 4:
            _yield$this$rpc$get_t = _context3.sent;
            rows = _yield$this$rpc$get_t.rows;
            more = _yield$this$rpc$get_t.more;
            next_key = _yield$this$rpc$get_t.next_key;

            if (!more) {
              _context3.next = 14;
              break;
            }

            _context3.t0 = rows;
            _context3.next = 12;
            return this.getCurrentNameBids(next_key, upper_bound);

          case 12:
            _context3.t1 = _context3.sent;
            rows = _context3.t0.concat.call(_context3.t0, _context3.t1);

          case 14:
            return _context3.abrupt("return", rows);

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getCurrentNameBids.apply(this, arguments);
}

var chainToRexMap = {
  jungle: 'jungle',
  bos: 'bos',
  eos: 'mainnet',
  telos: 'telos'
};
function getRexQueued(_x) {
  return _getRexQueued.apply(this, arguments);
}

function _getRexQueued() {
  _getRexQueued = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var _yield$this$rpc$get_t, rows;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexqueue',
              limit: 1,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)
            });

          case 3:
            _yield$this$rpc$get_t = _context.sent;
            rows = _yield$this$rpc$get_t.rows;

            if (!(rows && rows.length && rows[0].owner === account)) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return", rows[0]);

          case 7:
            _context.next = 12;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);

          case 12:
            return _context.abrupt("return", undefined);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 9]]);
  }));
  return _getRexQueued.apply(this, arguments);
}

function getRexPool() {
  return _getRexPool.apply(this, arguments);
}

function _getRexPool() {
  _getRexPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var _yield$this$rpc$get_t2, rows, pool, assetToNumber, total_lent, total_lendable, total_unlent, total_rex, total_rent, lent_percent, rex_price, resource_price;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexpool'
            });

          case 2:
            _yield$this$rpc$get_t2 = _context2.sent;
            rows = _yield$this$rpc$get_t2.rows;
            pool = rows[0];

            assetToNumber = function assetToNumber(asset) {
              return Number(asset.split(' ')[0]);
            };

            total_lent = assetToNumber(pool.total_lent);
            total_lendable = assetToNumber(pool.total_lendable);
            total_unlent = assetToNumber(pool.total_unlent);
            total_rex = assetToNumber(pool.total_rex);
            total_rent = assetToNumber(pool.total_rent);
            lent_percent = (0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.multiply)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.divide)(total_lent, total_lendable), 100);
            rex_price = +(0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.divide)(total_lendable, total_rex);
            resource_price = +(0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.divide)(total_unlent, total_rent + 1);
            return _context2.abrupt("return", {
              version: pool.version,
              namebid_proceeds: assetToNumber(pool.namebid_proceeds),
              loan_num: pool.loan_num,
              total_lent: total_lent,
              total_unlent: total_unlent,
              total_rent: total_rent,
              total_lendable: total_lendable,
              total_rex: total_rex,
              lent_percent: lent_percent,
              rex_price: rex_price,
              resource_price: resource_price
            });

          case 15:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getRexPool.apply(this, arguments);
}

function getRexBalance(_x2) {
  return _getRexBalance.apply(this, arguments);
}

function _getRexBalance() {
  _getRexBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(account) {
    var _yield$this$rpc$get_t3, rows, bal;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexbal',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)
            });

          case 2:
            _yield$this$rpc$get_t3 = _context3.sent;
            rows = _yield$this$rpc$get_t3.rows;
            bal = rows[0];
            return _context3.abrupt("return", bal.owner === account ? bal : undefined);

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getRexBalance.apply(this, arguments);
}

function getRexCpuLoans(_x3) {
  return _getRexCpuLoans.apply(this, arguments);
}

function _getRexCpuLoans() {
  _getRexCpuLoans = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var _yield$this$rpc$get_t4, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'cpuloan',
              table_key: 'byowner',
              key_type: 'i64',
              limit: 100,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 3
            });

          case 2:
            _yield$this$rpc$get_t4 = _context4.sent;
            rows = _yield$this$rpc$get_t4.rows;
            return _context4.abrupt("return", rows.filter(function (row) {
              return row.from === account;
            }));

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _getRexCpuLoans.apply(this, arguments);
}

function getRexNetLoans(_x4) {
  return _getRexNetLoans.apply(this, arguments);
}

function _getRexNetLoans() {
  _getRexNetLoans = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var _yield$this$rpc$get_t5, rows;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.rpc.get_table_rows({
              json: true,
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'netloan',
              table_key: 'byowner',
              key_type: 'i64',
              limit: 100,
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false),
              index_position: 3
            });

          case 2:
            _yield$this$rpc$get_t5 = _context5.sent;
            rows = _yield$this$rpc$get_t5.rows;
            return _context5.abrupt("return", rows.filter(function (row) {
              return row.from === account;
            }));

          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _getRexNetLoans.apply(this, arguments);
}

function getEosDepositedIntoRex(_x5) {
  return _getEosDepositedIntoRex.apply(this, arguments);
}

function _getEosDepositedIntoRex() {
  _getEosDepositedIntoRex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(account) {
    var _yield$this$rpc$get_t6, rows, row;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.rpc.get_table_rows({
              code: this.constants.EOSIO,
              scope: this.constants.EOSIO,
              table: 'rexfund',
              lower_bound: (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.encodeName)(account, false)
            });

          case 2:
            _yield$this$rpc$get_t6 = _context6.sent;
            rows = _yield$this$rpc$get_t6.rows;
            row = rows[0];
            return _context6.abrupt("return", row.owner === account ? Number(row.balance.split(' ')[0]) : 0);

          case 6:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _getEosDepositedIntoRex.apply(this, arguments);
}

function getRexReturnRate(_x6) {
  return _getRexReturnRate.apply(this, arguments);
}

function _getRexReturnRate() {
  _getRexReturnRate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(type) {
    var chain, _yield$this$post, data;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (type === void 0) {
              type = 'mpr';
            }

            chain = chainToRexMap[this.constants.CHAIN];

            if (!chain) {
              _context7.next = 14;
              break;
            }

            _context7.next = 5;
            return this.post('https://www.api.bloks.io/graphql/v1alpha1/graphql', {
              query: "query {\n        " + chain + "_" + type + " {\n          " + type + "\n        }\n      }",
              variables: null
            });

          case 5:
            _yield$this$post = _context7.sent;
            data = _yield$this$post.data;

            if (!data) {
              _context7.next = 11;
              break;
            }

            return _context7.abrupt("return", Math.abs(data[chain + "_" + type][0][type]));

          case 11:
            return _context7.abrupt("return", 0);

          case 12:
            _context7.next = 15;
            break;

          case 14:
            return _context7.abrupt("return", 0);

          case 15:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _getRexReturnRate.apply(this, arguments);
}

function getRexPriceChart() {
  return _getRexPriceChart.apply(this, arguments);
}

function _getRexPriceChart() {
  _getRexPriceChart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
    var chain, current_time, seven_days_ago, _yield$this$post2, data;

    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            chain = chainToRexMap[this.constants.CHAIN];

            if (!chain) {
              _context8.next = 15;
              break;
            }

            current_time = (0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.formatDate)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.utcTime)());
            seven_days_ago = (0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.formatDate)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.utcTime)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.startDate)((0,_bloks_numbers__WEBPACK_IMPORTED_MODULE_8__.time)(), 7)));
            _context8.next = 6;
            return this.post('https://www.api.bloks.io/graphql/v1alpha1/graphql', {
              query: "query {\n        " + chain + "_pricechart(args: {\n          from_time: \"" + seven_days_ago + "\",\n          to_time: \"" + current_time + "\"\n        }) {\n          t\n          o\n          h\n          l\n          c\n        }\n      }",
              variables: null
            });

          case 6:
            _yield$this$post2 = _context8.sent;
            data = _yield$this$post2.data;

            if (!data) {
              _context8.next = 12;
              break;
            }

            return _context8.abrupt("return", data[chain + "_pricechart"]);

          case 12:
            return _context8.abrupt("return", []);

          case 13:
            _context8.next = 16;
            break;

          case 15:
            return _context8.abrupt("return", {
              actions: []
            });

          case 16:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));
  return _getRexPriceChart.apply(this, arguments);
}

function getEosBalance(_x) {
  return _getEosBalance.apply(this, arguments);
}

function _getEosBalance() {
  _getEosBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName) {
    var _yield$this$rpc$get_c, balance;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.rpc.get_currency_balance(this.constants.EOSIO_TOKEN, accountName, this.constants.CORE_SYMBOL);

          case 2:
            _yield$this$rpc$get_c = _context.sent;
            balance = _yield$this$rpc$get_c[0];
            return _context.abrupt("return", balance);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getEosBalance.apply(this, arguments);
}

function getTokenBalance(_x2, _x3, _x4) {
  return _getTokenBalance.apply(this, arguments);
} // Get Account Tokens

function _getTokenBalance() {
  _getTokenBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(contract, accountName, symbol) {
    var result;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_currency_balance(contract, accountName, symbol)["catch"](function (err) {
              return console.log(err);
            });

          case 2:
            result = _context2.sent;

            if (!(result && result.length)) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", result[0]);

          case 7:
            return _context2.abrupt("return", null);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getTokenBalance.apply(this, arguments);
}

function getAccountTokens(_x5) {
  return _getAccountTokens.apply(this, arguments);
}

function _getAccountTokens() {
  _getAccountTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(accountName) {
    var accountBalances;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (accountBalances) {
              _context3.next = 4;
              break;
            }

            _context3.next = 3;
            return this.lightGetTokens(accountName);

          case 3:
            accountBalances = _context3.sent;

          case 4:
            if (accountBalances) {
              _context3.next = 8;
              break;
            }

            _context3.next = 7;
            return this.hyperionGetTokensForAccount(accountName);

          case 7:
            accountBalances = _context3.sent;

          case 8:
            return _context3.abrupt("return", accountBalances || []);

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getAccountTokens.apply(this, arguments);
}

function lightGetTokens(_x6) {
  return _lightGetTokens.apply(this, arguments);
}

function _lightGetTokens() {
  _lightGetTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(account) {
    var _yield$this$lightApi$, balances;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return this.lightApi.get_balances(account);

          case 3:
            _yield$this$lightApi$ = _context4.sent;
            balances = _yield$this$lightApi$.balances;
            return _context4.abrupt("return", balances.map(function (balance) {
              return {
                currency: balance.currency,
                amount: Number(balance.amount),
                contract: balance.contract,
                decimals: Number(balance.decimals)
              };
            }));

          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](0);
            console.log('lightGetTokens error', _context4.t0);
            return _context4.abrupt("return", undefined);

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 8]]);
  }));
  return _lightGetTokens.apply(this, arguments);
}

function hyperionGetTokensForAccount(_x7) {
  return _hyperionGetTokensForAccount.apply(this, arguments);
}

function _hyperionGetTokensForAccount() {
  _hyperionGetTokensForAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
    var _yield$this$hyperion$, tokens;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return this.hyperion.get_tokens(account);

          case 3:
            _yield$this$hyperion$ = _context5.sent;
            tokens = _yield$this$hyperion$.tokens;
            return _context5.abrupt("return", tokens.map(function (token) {
              return {
                currency: token.symbol,
                amount: Number(token.amount),
                contract: token.contract,
                decimals: Number(token.precision)
              };
            }));

          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](0);
            console.log('hyperionGetTokensForAccount error', _context5.t0);
            return _context5.abrupt("return", undefined);

          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[0, 8]]);
  }));
  return _hyperionGetTokensForAccount.apply(this, arguments);
}

function getTokenSupply(_x8, _x9) {
  return _getTokenSupply.apply(this, arguments);
}

function _getTokenSupply() {
  _getTokenSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(contract, symbol) {
    var stats, _stats$symbol, supply, max_supply;

    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            _context6.next = 3;
            return this.rpc.get_currency_stats(contract, symbol);

          case 3:
            stats = _context6.sent;
            _stats$symbol = stats[symbol], supply = _stats$symbol.supply, max_supply = _stats$symbol.max_supply;
            return _context6.abrupt("return", {
              supply: supply ? +supply.split(' ')[0] : 0,
              max_supply: max_supply ? +max_supply.split(' ')[0] : 0
            });

          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](0);
            console.log(_context6.t0);
            return _context6.abrupt("return", {
              supply: 0,
              max_supply: 0
            });

          case 12:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this, [[0, 8]]);
  }));
  return _getTokenSupply.apply(this, arguments);
}

function getHistoryTransaction(_x, _x2) {
  return _getHistoryTransaction.apply(this, arguments);
}

function _getHistoryTransaction() {
  _getHistoryTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(txId, blockHint) {
    var eosTransactions, tx;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (blockHint === void 0) {
              blockHint = 0;
            }

            eosTransactions = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc(this.constants.TRANSACTIONS_ENDPOINTS);
            _context.next = 4;
            return eosTransactions.history_get_transaction(txId, blockHint);

          case 4:
            tx = _context.sent;

            if (tx) {
              _context.next = 7;
              break;
            }

            throw new Error('TX not found');

          case 7:
            return _context.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.historyTransformTransaction)(tx));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getHistoryTransaction.apply(this, arguments);
}

function getDeferredTransaction(_x3) {
  return _getDeferredTransaction.apply(this, arguments);
}

function _getDeferredTransaction() {
  _getDeferredTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(txId) {
    var _yield$this$rpc$get_s, transactions;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.rpc.get_scheduled_transactions(true, txId, 1);

          case 2:
            _yield$this$rpc$get_s = _context2.sent;
            transactions = _yield$this$rpc$get_s.transactions;

            if (!(transactions.length > 0 && transactions[0].trx_id.substring(0, 6) === txId.substring(0, 6))) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.historyTransformDeferredTransaction)(transactions[0]));

          case 6:
            return _context2.abrupt("return", {});

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getDeferredTransaction.apply(this, arguments);
}

function getHyperionTransaction(_x4) {
  return _getHyperionTransaction.apply(this, arguments);
}

function _getHyperionTransaction() {
  _getHyperionTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id) {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!this.constants.HYPERION_URL) {
              _context3.next = 6;
              break;
            }

            _context3.next = 3;
            return this.hyperion.get_transaction(id);

          case 3:
            result = _context3.sent;
            _context3.next = 9;
            break;

          case 6:
            _context3.next = 8;
            return this.get((0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.urlBuilder)(this.constants.API_URL, 'hyperion', {
              type: 'get_transaction',
              id: id,
              options: {}
            }));

          case 8:
            result = _context3.sent;

          case 9:
            if (!(!result || !result.actions || !result.actions.length)) {
              _context3.next = 11;
              break;
            }

            throw new Error('TX not found');

          case 11:
            return _context3.abrupt("return", (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.hyperionTransformTransaction)(result));

          case 12:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getHyperionTransaction.apply(this, arguments);
}

function generateTransactionSettings(_x5, _x6, _x7) {
  return _generateTransactionSettings.apply(this, arguments);
}

function _generateTransactionSettings() {
  _generateTransactionSettings = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(expireSeconds, blocksBehind, delaySec) {
    var info, refBlock, result;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (expireSeconds === void 0) {
              expireSeconds = 3000;
            }

            if (blocksBehind === void 0) {
              blocksBehind = 12;
            }

            if (delaySec === void 0) {
              delaySec = 0;
            }

            _context4.next = 5;
            return this.rpc.get_info();

          case 5:
            info = _context4.sent;
            result = {};

            if (!info) {
              _context4.next = 12;
              break;
            }

            _context4.next = 10;
            return this.rpc.get_block(info.head_block_num - blocksBehind);

          case 10:
            refBlock = _context4.sent;
            result = _proton_js__WEBPACK_IMPORTED_MODULE_0__.Serialize.transactionHeader(refBlock, expireSeconds);

          case 12:
            return _context4.abrupt("return", _extends({
              max_net_usage_words: 0,
              max_cpu_usage_ms: 0,
              delay_sec: delaySec,
              context_free_actions: [],
              actions: [],
              transaction_extensions: []
            }, result));

          case 13:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _generateTransactionSettings.apply(this, arguments);
}

function getControlledAccounts(accountName) {
  if (this.constants.HISTORY_TYPES.includes('native')) {
    return this.actionsRpc.history_get_controlled_accounts(accountName);
  } else if (this.constants.HISTORY_TYPES.includes('hyperion')) {
    var actionsRpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc([this.constants.HYPERION_URL]);
    return actionsRpc.history_get_controlled_accounts(accountName);
  } else {
    return [];
  }
}
function getPermissionLinks(_x) {
  return _getPermissionLinks.apply(this, arguments);
}

function _getPermissionLinks() {
  _getPermissionLinks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
    var lightAccount, _yield$this$get, linked_permissions, _yield$this$hyperion$, links;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!this.constants.LIGHT_API) {
              _context.next = 12;
              break;
            }

            _context.prev = 1;
            _context.next = 4;
            return this.getAccountLightData(account);

          case 4:
            lightAccount = _context.sent;

            if (!lightAccount) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return", lightAccount.linkauth.map(function (auth) {
              return {
                action: auth.type,
                contract: auth.code,
                permission_name: auth.requirement
              };
            }));

          case 7:
            _context.next = 12;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);

          case 12:
            if (!this.constants.HISTORY_TYPES.includes('dfuse')) {
              _context.next = 25;
              break;
            }

            _context.prev = 13;
            _context.next = 16;
            return this.get(this.constants.API_URL + "/dfuse?type=state_permission_links&account=" + account);

          case 16:
            _yield$this$get = _context.sent;
            linked_permissions = _yield$this$get.linked_permissions;

            if (!linked_permissions) {
              _context.next = 20;
              break;
            }

            return _context.abrupt("return", linked_permissions);

          case 20:
            _context.next = 25;
            break;

          case 22:
            _context.prev = 22;
            _context.t1 = _context["catch"](13);
            console.log(_context.t1);

          case 25:
            if (!this.constants.HISTORY_TYPES.includes('hyperion')) {
              _context.next = 37;
              break;
            }

            _context.prev = 26;
            _context.next = 29;
            return this.hyperion.get_links(account);

          case 29:
            _yield$this$hyperion$ = _context.sent;
            links = _yield$this$hyperion$.links;
            return _context.abrupt("return", links.map(function (link) {
              return {
                action: link.action,
                contract: link.code,
                permission_name: link.permission
              };
            }));

          case 34:
            _context.prev = 34;
            _context.t2 = _context["catch"](26);
            console.log(_context.t2);

          case 37:
            console.log('Permission links not available on chain');
            return _context.abrupt("return", []);

          case 39:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 9], [13, 22], [26, 34]]);
  }));
  return _getPermissionLinks.apply(this, arguments);
}

function dfuseGetKeyAccounts(_x2) {
  return _dfuseGetKeyAccounts.apply(this, arguments);
}

function _dfuseGetKeyAccounts() {
  _dfuseGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {
    var _yield$this$get2, account_names;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.get(this.constants.API_URL + "/dfuse?type=state_key_accounts&publicKey=" + key);

          case 3:
            _yield$this$get2 = _context2.sent;
            account_names = _yield$this$get2.account_names;
            return _context2.abrupt("return", account_names && account_names.length ? account_names : []);

          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](0);
            console.log(_context2.t0);
            console.log('No dfuse accounts found associated with key:', key);
            return _context2.abrupt("return", []);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 8]]);
  }));
  return _dfuseGetKeyAccounts.apply(this, arguments);
}

function nativeGetKeyAccounts(_x3) {
  return _nativeGetKeyAccounts.apply(this, arguments);
}

function _nativeGetKeyAccounts() {
  _nativeGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {
    var keyAccounts, fioAccount, _yield$this$rpc$get_a, accounts;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            keyAccounts = [];

            if (!['fio', 'fio-test'].includes(this.constants.CHAIN)) {
              _context3.next = 7;
              break;
            }

            fioAccount = (0,_bloks_utils__WEBPACK_IMPORTED_MODULE_4__.fioKeyToActor)(key.replace('EOS', 'FIO'), _proton_js__WEBPACK_IMPORTED_MODULE_0__.Numeric.stringToPublicKey);

            if (keyAccounts.indexOf(fioAccount) === -1) {
              keyAccounts.push(fioAccount);
            }

            _context3.next = 12;
            break;

          case 7:
            _context3.next = 9;
            return this.rpc.get_accounts_by_authorizers([], [key]);

          case 9:
            _yield$this$rpc$get_a = _context3.sent;
            accounts = _yield$this$rpc$get_a.accounts;
            keyAccounts = Array.from(new Set(accounts.map(function (account) {
              return account.account_name;
            })));

          case 12:
            return _context3.abrupt("return", keyAccounts);

          case 15:
            _context3.prev = 15;
            _context3.t0 = _context3["catch"](0);
            console.log(_context3.t0);
            throw _context3.t0;

          case 19:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 15]]);
  }));
  return _nativeGetKeyAccounts.apply(this, arguments);
}

function hyperionGetKeyAccounts(_x4) {
  return _hyperionGetKeyAccounts.apply(this, arguments);
}

function _hyperionGetKeyAccounts() {
  _hyperionGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key) {
    var legacyPublicKey, _yield$this$hyperion$2, account_names;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (this.hyperion) {
              _context4.next = 2;
              break;
            }

            throw new Error('Hyperion API not supported');

          case 2:
            legacyPublicKey = _proton_js__WEBPACK_IMPORTED_MODULE_0__.Key.PublicKey.fromString(key).toLegacyString();
            _context4.next = 5;
            return this.hyperion.get_key_accounts(legacyPublicKey);

          case 5:
            _yield$this$hyperion$2 = _context4.sent;
            account_names = _yield$this$hyperion$2.account_names;

            if (!(account_names && account_names.length)) {
              _context4.next = 11;
              break;
            }

            return _context4.abrupt("return", account_names);

          case 11:
            throw new Error('No keys found');

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _hyperionGetKeyAccounts.apply(this, arguments);
}

function lightGetKeyAccounts(_x5) {
  return _lightGetKeyAccounts.apply(this, arguments);
}

function _lightGetKeyAccounts() {
  _lightGetKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {
    var lightChain, accountsByChain, accounts;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (this.lightApi) {
              _context5.next = 2;
              break;
            }

            throw new Error('Light API not supported');

          case 2:
            lightChain = this.constants.CHAIN.toLowerCase().replace('-', '');
            _context5.next = 5;
            return this.lightApi.get_key_accounts(key);

          case 5:
            accountsByChain = _context5.sent;
            accounts = accountsByChain[lightChain].accounts;
            return _context5.abrupt("return", Array.from(new Set(Object.keys(accounts))));

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _lightGetKeyAccounts.apply(this, arguments);
}

function getKeyAccountsByType(_x6, _x7) {
  return _getKeyAccountsByType.apply(this, arguments);
}
/**
 * Tries all histories to get keys.
 * @param {*} key
 */

function _getKeyAccountsByType() {
  _getKeyAccountsByType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key, type) {
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.t0 = type;
            _context6.next = _context6.t0 === 'dfuse' ? 3 : _context6.t0 === 'native' ? 6 : _context6.t0 === 'hyperion' ? 9 : _context6.t0 === 'light' ? 12 : 12;
            break;

          case 3:
            _context6.next = 5;
            return this.dfuseGetKeyAccounts(key);

          case 5:
            return _context6.abrupt("return", _context6.sent);

          case 6:
            _context6.next = 8;
            return this.nativeGetKeyAccounts(key);

          case 8:
            return _context6.abrupt("return", _context6.sent);

          case 9:
            _context6.next = 11;
            return this.hyperionGetKeyAccounts(key);

          case 11:
            return _context6.abrupt("return", _context6.sent);

          case 12:
            _context6.next = 14;
            return this.lightGetKeyAccounts(key);

          case 14:
            return _context6.abrupt("return", _context6.sent);

          case 15:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _getKeyAccountsByType.apply(this, arguments);
}

function getKeyAccounts(_x8) {
  return _getKeyAccounts.apply(this, arguments);
}

function _getKeyAccounts() {
  _getKeyAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(key) {
    var _i, _arr, historyType, res;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (key.startsWith('FIO')) {
              key = key.replace('FIO', 'EOS');
            }

            _i = 0, _arr = [this.constants.HISTORY_TYPES[0], 'light'].concat(this.constants.HISTORY_TYPES.slice(1));

          case 2:
            if (!(_i < _arr.length)) {
              _context7.next = 19;
              break;
            }

            historyType = _arr[_i];
            _context7.prev = 4;
            _context7.next = 7;
            return this.getKeyAccountsByType(key, historyType);

          case 7:
            res = _context7.sent;

            if (!res) {
              _context7.next = 10;
              break;
            }

            return _context7.abrupt("return", res);

          case 10:
            _context7.next = 16;
            break;

          case 12:
            _context7.prev = 12;
            _context7.t0 = _context7["catch"](4);
            console.log(_context7.t0);
            return _context7.abrupt("continue", 16);

          case 16:
            _i++;
            _context7.next = 2;
            break;

          case 19:
            return _context7.abrupt("return", []);

          case 20:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this, [[4, 12]]);
  }));
  return _getKeyAccounts.apply(this, arguments);
}

function getKeyAccountsForAllChains(_x9) {
  return _getKeyAccountsForAllChains.apply(this, arguments);
}
/**
 * Recursively resolves all required permissions
 * @param accountName
 * @param permission
 */

function _getKeyAccountsForAllChains() {
  _getKeyAccountsForAllChains = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(key) {
    var keyAccounts, combined;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (this.lightApi) {
              _context8.next = 2;
              break;
            }

            throw new Error('Light API not supported');

          case 2:
            _context8.prev = 2;
            _context8.next = 5;
            return this.lightApi.get_all_key_accounts(key);

          case 5:
            keyAccounts = _context8.sent;
            combined = keyAccounts.reduce(function (acc, obj) {
              return _extends({}, acc, obj);
            }, {});
            return _context8.abrupt("return", Object.entries(combined).reduce(function (acc, _ref) {
              var chain = _ref[0],
                  accountsByName = _ref[1].accounts;
              var accounts = Object.keys(accountsByName);

              if (accounts.length) {
                acc.push({
                  chain: chain,
                  accounts: accounts
                });
              }

              return acc;
            }, []));

          case 10:
            _context8.prev = 10;
            _context8.t0 = _context8["catch"](2);
            console.log(_context8.t0);
            return _context8.abrupt("return", []);

          case 14:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this, [[2, 10]]);
  }));
  return _getKeyAccountsForAllChains.apply(this, arguments);
}

function getRequiredAccounts(_x10, _x11, _x12, _x13, _x14) {
  return _getRequiredAccounts.apply(this, arguments);
}

function _getRequiredAccounts() {
  _getRequiredAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(accountName, permissionName, allPermissions, currentLevel, maxLevel) {
    var accountInfo, _iterator, _step, permission, accounts, producers, _iterator2, _step2, account;

    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (allPermissions === void 0) {
              allPermissions = [];
            }

            if (currentLevel === void 0) {
              currentLevel = 1;
            }

            if (maxLevel === void 0) {
              maxLevel = 2;
            }

            _context9.next = 5;
            return this.getAccount(accountName);

          case 5:
            accountInfo = _context9.sent;
            _iterator = _createForOfIteratorHelperLoose(accountInfo.permissions);

          case 7:
            if ((_step = _iterator()).done) {
              _context9.next = 31;
              break;
            }

            permission = _step.value;

            if (!(permission.perm_name === permissionName)) {
              _context9.next = 29;
              break;
            }

            // Get all account (e.g. gyy, hartono, thompson)
            accounts = [];

            if (!(accountName === 'eosio' && ['owner', 'active'].includes(permission.perm_name))) {
              _context9.next = 16;
              break;
            }

            _context9.next = 14;
            return this.getProducersLocal();

          case 14:
            producers = _context9.sent;
            accounts = producers.map(function (producer) {
              return {
                actor: producer.owner,
                permission: 'active'
              };
            });

          case 16:
            if (!accounts.length) {
              accounts = permission.required_auth.accounts.map(function (account) {
                return account.permission;
              });
            }

            if (!accounts.length) {
              allPermissions.push({
                actor: accountName,
                permission: permissionName
              });
            } // For each account (e.g. hartono)


            _iterator2 = _createForOfIteratorHelperLoose(accounts);

          case 19:
            if ((_step2 = _iterator2()).done) {
              _context9.next = 29;
              break;
            }

            account = _step2.value;

            if (!(currentLevel < maxLevel)) {
              _context9.next = 26;
              break;
            }

            _context9.next = 24;
            return this.getRequiredAccounts(account.actor, account.permission, allPermissions, ++currentLevel, maxLevel);

          case 24:
            _context9.next = 27;
            break;

          case 26:
            allPermissions.push({
              actor: account.actor,
              permission: account.permission
            });

          case 27:
            _context9.next = 19;
            break;

          case 29:
            _context9.next = 7;
            break;

          case 31:
            return _context9.abrupt("return", allPermissions);

          case 32:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this);
  }));
  return _getRequiredAccounts.apply(this, arguments);
}

function getUsersFromKeys(_x15) {
  return _getUsersFromKeys.apply(this, arguments);
}

function _getUsersFromKeys() {
  _getUsersFromKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(keys) {
    var _this = this;

    var users, promises;
    return _regeneratorRuntime().wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            users = [];
            promises = keys.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(key) {
                var account_names, promises2;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        _context11.next = 2;
                        return _this.getKeyAccounts(key);

                      case 2:
                        account_names = _context11.sent;
                        promises2 = account_names.map( /*#__PURE__*/function () {
                          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(account) {
                            var accountInfo, _iterator3, _step3, permission;

                            return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                              while (1) {
                                switch (_context10.prev = _context10.next) {
                                  case 0:
                                    _context10.next = 2;
                                    return _this.getAccount(account);

                                  case 2:
                                    accountInfo = _context10.sent;

                                    // For every permission, add to array
                                    for (_iterator3 = _createForOfIteratorHelperLoose(accountInfo.permissions); !(_step3 = _iterator3()).done;) {
                                      permission = _step3.value;

                                      // If key exists
                                      if (permission.required_auth.keys.find(function (permKey) {
                                        return permKey.key === key;
                                      })) {
                                        users.push({
                                          actor: account,
                                          permission: permission.perm_name,
                                          publicKey: key
                                        });
                                      }
                                    }

                                  case 4:
                                  case "end":
                                    return _context10.stop();
                                }
                              }
                            }, _callee10);
                          }));

                          return function (_x17) {
                            return _ref3.apply(this, arguments);
                          };
                        }());
                        _context11.next = 6;
                        return Promise.all(promises2);

                      case 6:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee11);
              }));

              return function (_x16) {
                return _ref2.apply(this, arguments);
              };
            }());
            _context12.next = 4;
            return Promise.all(promises);

          case 4:
            return _context12.abrupt("return", users);

          case 5:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));
  return _getUsersFromKeys.apply(this, arguments);
}

var ApiClass = /*#__PURE__*/function () {
  function ApiClass(chain) {
    this.rpc = undefined;
    this.actionsRpc = undefined;
    this.api = undefined;
    this.hyperion = undefined;
    this.lightApi = undefined;
    this.isInitialized = false;
    this.constants = undefined;
    this.http = http;
    this.get = get;
    this.post = post;
    this.getAccount = getAccount;
    this.getGravatar = getGravatar;
    this.searchAccount = searchAccount;
    this.getParent = getParent;
    this.getAccountLightData = getAccountLightData;
    this.getActionsFromNative = getActionsFromNative;
    this.getActions = getActions;
    this.getActionsFromDfuse = getActionsFromDfuse;
    this.getActionsFromHyperion = getActionsFromHyperion;
    this.getDappStats = getDappStats;
    this.getDspPackages = getDspPackages;
    this.getDapphodlBalance = getDapphodlBalance;
    this.getDappBalance = getDappBalance;
    this.getDappStakes = getDappStakes;
    this.getDapphodlStakes = getDapphodlStakes;
    this.getDappUnstakes = getDappUnstakes;
    this.getDapphodlUnstakes = getDapphodlUnstakes;
    this.getFIOVoter = getFIOVoter;
    this.getFIOAddressByName = getFIOAddressByName;
    this.getFIODomainByName = getFIODomainByName;
    this.getNFTsByFioAddress = getNFTsByFioAddress;
    this.getDomains = getDomains;
    this.getAddresses = getAddresses;
    this.getFIOProducers = getFIOProducers;
    this.getFIOSupplyBreakdown = getFIOSupplyBreakdown;
    this.getFIOFees = getFIOFees;
    this.addFIOFeeToActions = addFIOFeeToActions;
    this.getFIOAddresses = getFIOAddresses;
    this.getFIODomains = getFIODomains;
    this.getFIOAddressesAndDomains = getFIOAddressesAndDomains;
    this.getFIOBalance = getFIOBalance;
    this.getControlledAccounts = getControlledAccounts;
    this.getPermissionLinks = getPermissionLinks;
    this.dfuseGetKeyAccounts = dfuseGetKeyAccounts;
    this.nativeGetKeyAccounts = nativeGetKeyAccounts;
    this.hyperionGetKeyAccounts = hyperionGetKeyAccounts;
    this.lightGetKeyAccounts = lightGetKeyAccounts;
    this.getKeyAccountsByType = getKeyAccountsByType;
    this.getKeyAccounts = getKeyAccounts;
    this.getKeyAccountsForAllChains = getKeyAccountsForAllChains;
    this.getRequiredAccounts = getRequiredAccounts;
    this.getUsersFromKeys = getUsersFromKeys;
    this.getAllMsigs = getAllMsigs;
    this.parsePackedMsigActions = parsePackedMsigActions;
    this.parsePackedMsig = parsePackedMsig;
    this.getFullMsigProposal = getFullMsigProposal;
    this.getMsigApprovals = getMsigApprovals;
    this.getAccountsMsigProposals = getAccountsMsigProposals;
    this.hyperionGetMsig = hyperionGetMsig;
    this.getMsigProposal = getMsigProposal;
    this.getRentbwState = getRentbwState;
    this.delegatedBandwidth = delegatedBandwidth;
    this.getAccountDelegatedBandwidth = getAccountDelegatedBandwidth;
    this.getAccountResources = getAccountResources;
    this.getRamPriceInEos = getRamPriceInEos;
    this.getRexQueued = getRexQueued;
    this.getRexPool = getRexPool;
    this.getRexBalance = getRexBalance;
    this.getRexCpuLoans = getRexCpuLoans;
    this.getRexNetLoans = getRexNetLoans;
    this.getEosDepositedIntoRex = getEosDepositedIntoRex;
    this.getRexReturnRate = getRexReturnRate;
    this.getRexPriceChart = getRexPriceChart;
    this.getEosTopStakes = getEosTopStakes;
    this.getEosTopRams = getEosTopRams;
    this.getCurrentNameBids = getCurrentNameBids;
    this.getEosBalance = getEosBalance;
    this.getTokenBalance = getTokenBalance;
    this.hyperionGetTokensForAccount = hyperionGetTokensForAccount;
    this.getTokenSupply = getTokenSupply;
    this.lightGetTokens = lightGetTokens;
    this.getAccountTokens = getAccountTokens;
    this.getHistoryTransaction = getHistoryTransaction;
    this.getDeferredTransaction = getDeferredTransaction;
    this.getHyperionTransaction = getHyperionTransaction;
    this.generateTransactionSettings = generateTransactionSettings;
    this.getProxies = getProxies;
    this.getVoters = getVoters;
    this.calculateVoteWeight = calculateVoteWeight;
    this.weightedVoteToNumber = weightedVoteToNumber;
    this.getProxyData = getProxyData;
    this.getVoter = getVoter;
    this.getProducers = getProducers;
    this.getProducersLocal = getProducersLocal;
    this.getChainTable = getChainTable;
    this.fetchKycCountries = fetchKycCountries;
    this.checkUserKycStatus = checkUserKycStatus;
    this.applyForKyc = applyForKyc;
    this.currentLocation = currentLocation;
    this.getAvailableFeatures = getAvailableFeatures;
    this.otcQuote = otcQuote;
    this.otcOrder = otcOrder;
    this.generateAddress = generateAddress;
    this.deleteAddress = deleteAddress;
    this.withdrawMetal = withdrawMetal;
    this.withdrawalHistoryMetal = withdrawalHistoryMetal;
    this.getTokenPrices = getTokenPrices;
    this.getWithdrawalFee = getWithdrawalFee;
    this.getChainInfo = getChainInfo;
    this.createAccount = createAccount;
    this.loginAccount = loginAccount;
    this.getXprTotalStakedAndApr = getXprTotalStakedAndApr;
    this.getXprVoter = getXprVoter;
    this.getXprAccountStakes = getXprAccountStakes;
    this.getXprAccountRefund = getXprAccountRefund;
    this.getXprOracleData = getXprOracleData;
    this.getAllOracleFeeds = getAllOracleFeeds;
    this.getAllOracleData = getAllOracleData;
    this.getSpecificOracleData = getSpecificOracleData;
    this.getProtonAvatar = getProtonAvatar;
    this.getProtonAvatars = getProtonAvatars;

    if (chain) {
      _bloks_constants__WEBPACK_IMPORTED_MODULE_1__.constants.initialize(chain);
      this.initialize(_bloks_constants__WEBPACK_IMPORTED_MODULE_1__.constants);
    }
  }

  var _proto = ApiClass.prototype;

  _proto.initialize = function initialize(constants, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        rpcEndpoints = _ref.rpcEndpoints,
        actionsRpcEndpoints = _ref.actionsRpcEndpoints,
        lightEndpoint = _ref.lightEndpoint,
        hyperionEndpoint = _ref.hyperionEndpoint;

    this.constants = constants;
    this.rpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc(rpcEndpoints || this.constants.DEFAULT_ENDPOINTS);
    this.actionsRpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc(actionsRpcEndpoints || this.constants.ACTIONS_ENDPOINTS);
    this.api = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.Api({
      rpc: this.rpc
    });
    var lightUrl = lightEndpoint || this.constants.LIGHT_API;

    if (lightUrl) {
      this.lightApi = new _proton_light_api__WEBPACK_IMPORTED_MODULE_3__.JsonRpc(this.constants.CHAIN.toLowerCase().replace('-', ''), {
        endpoint: lightUrl
      });
    }

    var hyperionUrl = hyperionEndpoint || this.constants.HYPERION_URL;

    if (hyperionUrl) {
      this.hyperion = new _proton_hyperion__WEBPACK_IMPORTED_MODULE_2__.JsonRpc(hyperionUrl);
    }

    this.isInitialized = true;
  };

  return ApiClass;
}();


//# sourceMappingURL=api.esm.js.map


/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TypeScript Definitions
__exportStar(__webpack_require__(/*! ./src/types/action_trace */ "./node_modules/@proton/hyperion/dist/src/types/action_trace.js"), exports);
__exportStar(__webpack_require__(/*! ./src/types/api */ "./node_modules/@proton/hyperion/dist/src/types/api.js"), exports);
// Hyperion API
__exportStar(__webpack_require__(/*! ./src/jsonrpc */ "./node_modules/@proton/hyperion/dist/src/jsonrpc.js"), exports);
__exportStar(__webpack_require__(/*! ./src/endpoints */ "./node_modules/@proton/hyperion/dist/src/endpoints.js"), exports);
__exportStar(__webpack_require__(/*! ./src/rpcerror */ "./node_modules/@proton/hyperion/dist/src/rpcerror.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/endpoints.js":
/*!*************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/endpoints.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.V2_GET_TRANSFERS = exports.V2_GET_TRANSACTION = exports.V2_GET_TRANSACTED_ACCOUNTS = exports.V2_GET_DELTAS = exports.V2_GET_CREATOR = exports.V2_GET_CREATED_ACCOUNTS = exports.V2_GET_ACTIONS = exports.V2_GET_ABI_SNAPSHOT = exports.V2_GET_PROPOSALS = exports.V2_GET_LINKS = exports.V2_GET_VOTERS = exports.V2_GET_TOKENS = exports.V2_GET_KEY_ACCOUNTS = exports.V2_ALIVE = void 0;
// State
exports.V2_ALIVE = "/v2/state/alive";
exports.V2_GET_KEY_ACCOUNTS = "/v2/state/get_key_accounts";
exports.V2_GET_TOKENS = "/v2/state/get_tokens";
exports.V2_GET_VOTERS = "/v2/state/get_voters";
exports.V2_GET_LINKS = "/v2/state/get_links";
exports.V2_GET_PROPOSALS = "/v2/state/get_proposals";
// History
exports.V2_GET_ABI_SNAPSHOT = "/v2/history/get_abi_snapshot";
exports.V2_GET_ACTIONS = "/v2/history/get_actions";
exports.V2_GET_CREATED_ACCOUNTS = "/v2/history/get_created_accounts";
exports.V2_GET_CREATOR = "/v2/history/get_creator";
exports.V2_GET_DELTAS = "/v2/history/get_deltas";
exports.V2_GET_TRANSACTED_ACCOUNTS = "/v2/history/get_transacted_accounts";
exports.V2_GET_TRANSACTION = "/v2/history/get_transaction";
exports.V2_GET_TRANSFERS = "/v2/history/get_transfers";
//# sourceMappingURL=endpoints.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/jsonrpc.js":
/*!***********************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/jsonrpc.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpc = void 0;
var endpoints_1 = __webpack_require__(/*! ./endpoints */ "./node_modules/@proton/hyperion/dist/src/endpoints.js");
var rpcerror_1 = __webpack_require__(/*! ./rpcerror */ "./node_modules/@proton/hyperion/dist/src/rpcerror.js");
var cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
function queryParams(params) {
    var entries = [];
    for (var _i = 0, _a = Object.keys(params); _i < _a.length; _i++) {
        var key = _a[_i];
        var value = params[key];
        if (value !== undefined) {
            entries.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
        }
    }
    return entries.join("&");
}
function fetchWithTimeout(resource, options) {
    return __awaiter(this, void 0, void 0, function () {
        var timeout, controller, id, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    timeout = options.timeout;
                    controller = new AbortController();
                    id = setTimeout(function () { return controller.abort(); }, timeout);
                    return [4 /*yield*/, (0, cross_fetch_1.default)(resource, __assign(__assign({}, (options || {})), { signal: controller.signal }))];
                case 1:
                    response = _a.sent();
                    clearTimeout(id);
                    return [2 /*return*/, response];
            }
        });
    });
}
/**
 * JsonRpc
 *
 * @param {string} endpoint hyperion endpoint
 * @example
 *
 * const endpoint = "https://br.eosrio.io"
 * const rpc = new JsonRpc(endpoint, { fetch })
 */
var JsonRpc = /** @class */ (function () {
    function JsonRpc(endpoint, args) {
        if (args === void 0) { args = {}; }
        this.timeout = 8000;
        this.endpoint = endpoint;
        if (args.timeout) {
            this.timeout = args.timeout;
        }
    }
    /**
     * post
     *
     * POST `body` to `endpoint + path`.
     * Throws detailed error information in `RpcError` when available.
     *
     * @private
     */
    JsonRpc.prototype.post = function (path, body) {
        return __awaiter(this, void 0, void 0, function () {
            var response, json, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, fetchWithTimeout(this.endpoint + path, {
                                body: JSON.stringify(body),
                                method: "POST",
                                timeout: this.timeout
                            })];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.json()];
                    case 2:
                        json = _a.sent();
                        if (json.processed && json.processed.except) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        e_1.isFetchError = true;
                        throw e_1;
                    case 4:
                        if (!response.ok) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * get
     *
     * GET `params` to `endpoint + path`.
     * Throws detailed error information in `RpcError` when available.
     *
     * @private
     */
    JsonRpc.prototype.get = function (path, params) {
        return __awaiter(this, void 0, void 0, function () {
            var response, json, url, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endpoint + path + "?" + queryParams(params);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, fetchWithTimeout(url, {
                                method: "GET",
                                timeout: this.timeout
                            })];
                    case 2:
                        response = _a.sent();
                        if (response.status !== 200) {
                            throw new rpcerror_1.RpcStatusError(response);
                        }
                        return [4 /*yield*/, response.json()];
                    case 3:
                        json = _a.sent();
                        if (json.processed && json.processed.except) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_2 = _a.sent();
                        e_2.isFetchError = true;
                        throw e_2;
                    case 5:
                        if (!response.ok) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * [GET /v2/state/alive](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_alive)
     *
     * simple server healthcheck
     *
     * @returns {Promise<Alive>} alive
     * @example
     *
     * const response = await rpc.alive();
     * console.log(response);
     * // => {"status": "OK"}
     */
    JsonRpc.prototype.alive = function () {
        return this.get(endpoints_1.V2_ALIVE, {});
    };
    /**
     * [GET /v2/history/get_abi_snapshot](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_abi_snapshot)
     *
     * fetch contract abi at specific block
     *
     * @param {string} contract contract account
     * @param {number} number target block
     * @returns {Promise<GetAbiSnapshot>} abi snapshot
     * @example
     *
     * const response = await rpc.get_abi_snapshot("eosio", 200);
     * console.log(response.version);
     * // => "eosio::abi/1.0"
     *
     * for (const table of response.tables) {
     *     console.log(table);
     *     // => { name: 'producers', index_type: 'i64', key_names: [ 'owner' ], key_types: [ 'uint64' ], type: 'producer_info' }
     * }
     */
    JsonRpc.prototype.get_abi_snapshot = function (contract, block) {
        var params = {
            contract: contract,
            block: block,
        };
        return this.get(endpoints_1.V2_GET_ABI_SNAPSHOT, params);
    };
    /**
     * [GET /v2/state/get_voters](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_voters)
     *
     * get voters
     *
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.producer] filter by voted producer (comma separated)
     * @param {boolean} [options.proxy] true or false
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @returns {Promise<GetVoters>} voters
     * @example
     *
     * const response = await rpc.get_voters({ producer: "eoscafeblock", limit: 100 });
     * console.log(response.voters);
     * // => "[{
     * //   "account": "guzdkmrtgage",
     * //   "weight": 78434695236505280,
     * //   "last_vote": 64804768
     * // }]"
     */
    JsonRpc.prototype.get_voters = function (options) {
        return this.get(endpoints_1.V2_GET_VOTERS, options);
    };
    /**
     * [GET /v2/state/get_links](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_links)
     *
     * get voters
     *
     * @param {string} [account] account to get links for
     * @returns {Promise<GetLinks>} links
     * @example
     *
     * const response = await rpc.get_links("eoscafeblock");
     * console.log(response.links);
     * // => "[{
     * "block_num":26088072,
     * "timestamp":"2019-11-22T23:17:42.000",
     * "account":"eosriobrazil",
     * "permission":"claim2",
     * "code":"eosio",
     * "action":"voteproducer"
     * }]"
     */
    JsonRpc.prototype.get_links = function (account) {
        return this.get(endpoints_1.V2_GET_LINKS, { account: account });
    };
    /**
     * [GET /v2/state/get_proposals](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_proposals)
     *
     * get proposals
     *
     * @param {string} [account] account to get proposals for
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.proposer] filter by proposer
     * @param {string} [options.proposal] filter by proposal name
     * @param {string} [options.account] filter by either requested or provided account
     * @param {string} [options.requested] filter by requested account
     * @param {string} [options.provided] filter by provided account
     * @param {string} [options.track] total results to track (count) [number or true]
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @returns {Promise<GetProposals>} proposals
     */
    JsonRpc.prototype.get_proposals = function (options) {
        return this.get(endpoints_1.V2_GET_PROPOSALS, options);
    };
    /**
     * [GET /v2/history/get_actions](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_actions)
     *
     * get actions based on notified account
     *
     * @param {string} account notified account
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.filter] code::name filter
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @param {string} [options.sort] sort direction
     * @param {string} [options.after] filter after specified date (ISO8601)
     * @param {string} [options.before] filter before specified date (ISO8601)
     * @param {string} [options.transfer_to] transfer filter to
     * @param {string} [options.transfer_from]  transfer filter from
     * @param {string} [options.transfer_symbol]  transfer filter symbol
     * @param {string} [options.act_name]  act name
     * @param {string} [options.act_account]  act account
     * @returns {Promise<GetActions>} get actions
     * @example
     *
     * const response = await rpc.get_actions("eoscafeblock", {
     *     filter: "eosio.token:*",
     *     skip: 100,
     *     limit: 100,
     * });
     *
     * for (const action of response.actions) {
     *     console.log(action);
     *     // => { act: { account: 'eosio.token', name: 'transfer', ... } }
     * }
     */
    JsonRpc.prototype.get_actions = function (account, options) {
        if (options === void 0) { options = {}; }
        var params = Object.assign({}, { account: account }, options);
        return this.get(endpoints_1.V2_GET_ACTIONS, params);
    };
    /**
     * [GET /v2/history/get_created_accounts](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_created_accounts)
     *
     * get created accounts
     *
     * @param {string} account created account
     * @returns {Promise<GetCreatedAccounts>} get creator
     * @example
     *
     * const response = await rpc.get_created_accounts("eosnationftw");
     * console.log(response);
     * // => {"accounts": [{"name":"eosnationdsp","trx_id":"728d4a4da36a98d9048080461dacaf975ad083e8158ef84edea60cc755ab2c1a","timestamp":"2019-02-28T22:36:45.000"}, ... ]}
     */
    JsonRpc.prototype.get_created_accounts = function (account) {
        var params = {
            account: account,
        };
        return this.get(endpoints_1.V2_GET_CREATED_ACCOUNTS, params);
    };
    /**
     * [GET /v2/history/get_creator](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_creator)
     *
     * get creator
     *
     * @param {string} account created account
     * @returns {Promise<GetCreator>} get creator
     * @example
     *
     * const response = await rpc.get_creator("eosnationftw");
     * console.log(response);
     * // => { account: 'eosnationftw', creator: 'gyztcmrvgqge', timestamp: '2018-06-10T13:06:43.500', ... }
     */
    JsonRpc.prototype.get_creator = function (account) {
        var params = {
            account: account,
        };
        return this.get(endpoints_1.V2_GET_CREATOR, params);
    };
    /**
     * [GET /v2/history/get_deltas](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_deltas)
     *
     * get deltas
     *
     * @param {string} code contract account
     * @param {string} scope table scope
     * @param {string} table table name
     * @param {string} payer payer account
     * @returns {Promise<GetDeltas>} get deltas
     * @example
     *
     * const response = await rpc.get_deltas("eosio.token", "eosnationftw", "accounts", "eosnationftw");
     * console.log(response);
     * // => { "query_time": 19, "total": { "value": 486, "relation": "eq" }, "deltas": [ ... ] }
     */
    JsonRpc.prototype.get_deltas = function (code, scope, table, payer, options) {
        var params = Object.assign({}, options, {
            code: code,
            scope: scope,
            table: table,
            payer: payer,
        });
        return this.get(endpoints_1.V2_GET_DELTAS, params);
    };
    /**
     * [GET/v2/state/get_key_accounts](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_key_accounts)
     *
     * get account by public key
     *
     * @param {string} public_key Contract account targeted by the action.
     * @returns {Promise<GetKeyAccounts>} key accounts
     * @example
     *
     * const response = await rpc.get_key_accounts("EOS5Mto3Km6BCVxowb6LkkFaT9oaUwLVgswgcxvY4Qgc4rhHry4Tv");
     * console.log(response.account_names);
     * // => [ 'eoscafeblock' ]
     */
    JsonRpc.prototype.get_key_accounts = function (public_key) {
        var params = {
            public_key: public_key,
        };
        return this.get(endpoints_1.V2_GET_KEY_ACCOUNTS, params);
    };
    /**
     * [GET /v2/state/get_tokens](https://eos.hyperion.eosrio.io/v2/docs/index.html#/state/get_v2_state_get_tokens)
     *
     * get tokens
     *
     * @param {string} account account
     * @returns {Promise<GetTokens>} get tokens
     * @example
     *
     * const response = await rpc.get_tokens("eosnationftw");
     * for (const token of response.tokens) {
     *     console.log(token);
     *     // => { symbol: 'ZOS', precision: 4, amount: 140, contract: 'zosdiscounts' }
     * }
     */
    JsonRpc.prototype.get_tokens = function (account) {
        var params = {
            account: account,
        };
        return this.get(endpoints_1.V2_GET_TOKENS, params);
    };
    /**
     * [GET /v2/history/get_transacted_accounts](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_transacted_accounts)
     *
     * get all account that interacted with the source account provided
     *
     * @param {string} account source account
     * @param {string} direction search direction (in, out or both)
     * @returns {Promise<GetTransactedAccounts>} transacted accounts
     * @example
     *
     * const response = await rpc.get_transacted_accounts("eoscafeblock", "in");
     * console.log(response);
     * // => { query_time: 268, account: 'eoscafeblock', total_in: 1092369.1827, inputs: [ ... ] }
     */
    JsonRpc.prototype.get_transacted_accounts = function (account, direction, options) {
        if (options === void 0) { options = {}; }
        var params = Object.assign({}, { account: account, direction: direction }, options);
        return this.get(endpoints_1.V2_GET_TRANSACTED_ACCOUNTS, params);
    };
    /**
     * [GET /v2/history/get_transaction](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_transaction)
     *
     * get all actions belonging to the same transaction
     *
     * @param {string} id transaction id
     * @returns {Promise<GetTransaction>} transaction
     * @example
     *
     * const response = await rpc.get_transaction("42dacd5722001b734be46a2140917e06cd21d42425f927f506c07b4388b07f62");
     * for (const action of response.actions) {
     *     console.log(action);
     *     // => { act: { account: 'eosio', name: 'buyrambytes', ... }}
     * }
     */
    JsonRpc.prototype.get_transaction = function (id) {
        var params = {
            id: id,
        };
        return this.get(endpoints_1.V2_GET_TRANSACTION, params);
    };
    /**
     * [GET /v2/history/get_transfers](https://eos.hyperion.eosrio.io/v2/docs/index.html#/history/get_v2_history_get_transfers)
     *
     * get token transfers utilizing the eosio.token standard
     *
     * @param {object} [options={}] Optional parameters
     * @param {string} [options.from] source account
     * @param {string} [options.to] destination account
     * @param {string} [options.symbol] token symbol
     * @param {string} [options.contract] token contract
     * @param {number} [options.skip] skip [n] actions (pagination)
     * @param {number} [options.limit] limit of [n] actions per page
     * @param {string} [options.after] filter after specified date (ISO8601)
     * @param {string} [options.before] filter before specified date (ISO8601)
     * @returns {Promise<GetTransfers>} transfers
     * @example
     *
     * const response = await rpc.get_transfers({to: "eosnewyorkio"});
     * for (const action of response.actions) {
     *     console.log(action.act.data);
     *     // => { from: 'eosio.bpay', to: 'eosnewyorkio', amount: 326.524, symbol: 'EOS', memo: 'producer block pay' }
     * }
     */
    JsonRpc.prototype.get_transfers = function (options) {
        if (options === void 0) { options = {}; }
        var params = Object.assign({}, options);
        return this.get(endpoints_1.V2_GET_TRANSFERS, params);
    };
    return JsonRpc;
}());
exports.JsonRpc = JsonRpc;
//# sourceMappingURL=jsonrpc.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/rpcerror.js":
/*!************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/rpcerror.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcStatusError = exports.RpcError = void 0;
/**
 * @private
 * @module RPC-Error
 *
 * copyright defined in eosjs/LICENSE.txt
 */
var RpcError = /** @class */ (function (_super) {
    __extends(RpcError, _super);
    function RpcError(json) {
        var _this = this;
        if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
        }
        else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
        }
        else {
            _this = _super.call(this, json.message) || this;
        }
        Object.setPrototypeOf(_this, RpcError.prototype);
        _this.json = json;
        return _this;
    }
    return RpcError;
}(Error));
exports.RpcError = RpcError;
/**
 * @private
 */
var RpcStatusError = /** @class */ (function (_super) {
    __extends(RpcStatusError, _super);
    function RpcStatusError(response) {
        var _this = this;
        if (response.status === 405) {
            _this = _super.call(this, response.statusText) || this;
        }
        else {
            _this = _super.call(this) || this;
        }
        Object.setPrototypeOf(_this, RpcStatusError.prototype);
        _this.response = response;
        return _this;
    }
    return RpcStatusError;
}(Error));
exports.RpcStatusError = RpcStatusError;
//# sourceMappingURL=rpcerror.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/types/action_trace.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/types/action_trace.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=action_trace.js.map

/***/ }),

/***/ "./node_modules/@proton/hyperion/dist/src/types/api.js":
/*!*************************************************************!*\
  !*** ./node_modules/@proton/hyperion/dist/src/types/api.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TypeScript Definitions
__exportStar(__webpack_require__(/*! ./src/types/api */ "./node_modules/@proton/light-api/dist/src/types/api.js"), exports);
// Light API
__exportStar(__webpack_require__(/*! ./src/jsonrpc */ "./node_modules/@proton/light-api/dist/src/jsonrpc.js"), exports);
__exportStar(__webpack_require__(/*! ./src/endpoints */ "./node_modules/@proton/light-api/dist/src/endpoints.js"), exports);
__exportStar(__webpack_require__(/*! ./src/rpcerror */ "./node_modules/@proton/light-api/dist/src/rpcerror.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/endpoints.js":
/*!**************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/endpoints.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GET_ACCOUNTS_FROM_KEYS = exports.GET_TOKEN_HOLDERS = exports.GET_TOKEN_HOLDER_COUNT = exports.GET_CODEHASH = exports.GET_TOPSTAKE = exports.GET_TOPRAM = exports.GET_USERCOUNT = exports.GET_TOPHOLDERS = exports.GET_TOKEN_BALANCE = exports.GET_SYNC_INFO = exports.GET_NETWORKS = exports.GET_KEY_ACCOUNTS = exports.GET_BALANCES = exports.GET_ACCOUNT_INFO = exports.GET_ACCOUNT = void 0;
exports.GET_ACCOUNT = "/api/account";
exports.GET_ACCOUNT_INFO = "/api/accinfo";
exports.GET_BALANCES = "/api/balances";
exports.GET_KEY_ACCOUNTS = "/api/key";
exports.GET_NETWORKS = "/api/networks";
exports.GET_SYNC_INFO = "/api/sync";
exports.GET_TOKEN_BALANCE = "/api/tokenbalance";
exports.GET_TOPHOLDERS = "/api/topholders";
exports.GET_USERCOUNT = "/api/usercount";
exports.GET_TOPRAM = "/api/topram";
exports.GET_TOPSTAKE = "/api/topstake";
exports.GET_CODEHASH = "/api/codehash";
exports.GET_TOKEN_HOLDER_COUNT = "/api/holdercount";
exports.GET_TOKEN_HOLDERS = "get_token_holders";
exports.GET_ACCOUNTS_FROM_KEYS = "get_accounts_from_keys";
//# sourceMappingURL=endpoints.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/jsonrpc.js":
/*!************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/jsonrpc.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpc = void 0;
var endpoints_1 = __webpack_require__(/*! ./endpoints */ "./node_modules/@proton/light-api/dist/src/endpoints.js");
var rpcerror_1 = __webpack_require__(/*! ./rpcerror */ "./node_modules/@proton/light-api/dist/src/rpcerror.js");
var cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
var jsonrpc2_ws_1 = __webpack_require__(/*! jsonrpc2-ws */ "./node_modules/jsonrpc2-ws/lib/index.js");
var chainToEndpoint = {
    eos: "https://api.light.xeos.me",
    telos: "https://api.light.xeos.me",
    jungle: "https://lightapi.eosgeneva.io",
    bos: "https://lightapi.eosamsterdam.net",
    instar: "https://lightapi.eosamsterdam.net",
    proton: "https://proton.light-api.net",
    wax: "https://lightapi.eosamsterdam.net",
    worbli: "https://lightapi.eosamsterdam.net",
    xec: "https://lightapi.eosamsterdam.net",
    protontest: "https://testnet-lightapi.eosams.xeos.me",
    telostest: "https://testnet-lightapi.eosams.xeos.me",
    waxtest: "https://testnet-lightapi.eosams.xeos.me",
    coffe: "https://hyperion.coffe.io",
};
function fetchWithTimeout(resource, options) {
    return __awaiter(this, void 0, void 0, function () {
        var timeout, controller, id, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    timeout = options.timeout;
                    controller = new AbortController();
                    id = setTimeout(function () { return controller.abort(); }, timeout);
                    return [4 /*yield*/, (0, cross_fetch_1.default)(resource, __assign(__assign({}, (options || {})), { signal: controller.signal }))];
                case 1:
                    response = _a.sent();
                    clearTimeout(id);
                    return [2 /*return*/, response];
            }
        });
    });
}
/**
 * JsonRpc
 *
 * @param {string} endpoint LIGHT API endpoint
 * @example
 *
 * const rpc = new JsonRpc("proton")
 */
var JsonRpc = /** @class */ (function () {
    function JsonRpc(chain, args) {
        if (args === void 0) { args = {}; }
        this.timeout = 5000;
        this.wsRequestId = 100;
        this.chain = chain;
        this.endpoint = args.endpoint || chainToEndpoint[chain];
        this.wsClient = new jsonrpc2_ws_1.Client(this.endpoint.replace('https:', 'wss:') + '/wsapi');
        if (!this.endpoint) {
            throw new Error("Chain ".concat(chain, " does not have a default endpoint, provide one in args"));
        }
        if (args.timeout) {
            this.timeout = args.timeout;
        }
    }
    /**
     * get
     *
     * GET `params` to `endpoint + path`.
     * Throws detailed error information in `RpcError` when available.
     *
     * @private
     */
    JsonRpc.prototype.get = function (path, endpoint) {
        if (endpoint === void 0) { endpoint = this.endpoint; }
        return __awaiter(this, void 0, void 0, function () {
            var response, json, url, text, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = endpoint + path;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, fetchWithTimeout(url, {
                                method: "GET",
                                timeout: this.timeout,
                            })];
                    case 2:
                        response = _a.sent();
                        if (response.status !== 200) {
                            throw new rpcerror_1.RpcStatusError(response);
                        }
                        return [4 /*yield*/, response.text()];
                    case 3:
                        text = _a.sent();
                        try {
                            json = JSON.parse(text);
                            if (json.processed && json.processed.except) {
                                throw new rpcerror_1.RpcError(json);
                            }
                        }
                        catch (_b) {
                            json = text;
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        e_1.isFetchError = true;
                        throw e_1;
                    case 5:
                        if (!response.ok) {
                            throw new rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /**
     * [GET /api/account]
     *
     * Retrieve all token balances, resources and authorization information for an account:
     *
     * @param {string} accountName name of account
     * @returns {Promise<GetAccount>} account
     */
    JsonRpc.prototype.get_account = function (accountName) {
        var url = "".concat(endpoints_1.GET_ACCOUNT, "/").concat(this.chain, "/").concat(accountName);
        return this.get(url);
    };
    /**
     * [GET /api/accinfo]
     *
     * Retrieve all resources and authorization information for an account:
     *
     * @param {string} accountName name of account
     * @returns {Promise<GetAccountInfo>} account
     */
    JsonRpc.prototype.get_account_info = function (accountName) {
        var url = "".concat(endpoints_1.GET_ACCOUNT_INFO, "/").concat(this.chain, "/").concat(accountName);
        return this.get(url);
    };
    /**
     * [GET /api/balances]
     *
     * Retrieve only token balances for an account
     *
     * @param {string} accountName name of account
     * @returns {Promise<GetBalances>} balances
     */
    JsonRpc.prototype.get_balances = function (accountName) {
        var url = "".concat(endpoints_1.GET_BALANCES, "/").concat(this.chain, "/").concat(accountName);
        return this.get(url);
    };
    /**
     * [GET /api/key]
     *
     * Retrieve all accounts in all known EOS networks dependent on a public key:
     *
     * @param {string} key public key
     * @returns {Promise<GetKeyAccounts[]>} accounts per network
     */
    JsonRpc.prototype.get_all_key_accounts = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = __spreadArray([], __read(new Set(Object.values(chainToEndpoint))), false).map(function (endpoint) {
                            var url = "".concat(endpoints_1.GET_KEY_ACCOUNTS, "/").concat(key);
                            return _this.get(url, endpoint);
                        });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * [GET /api/key]
     *
     * Retrieve all accounts in network
     *
     * @param {string} key public key
     * @returns {Promise<GetKeyAccounts>} accounts
     */
    JsonRpc.prototype.get_key_accounts = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                url = "".concat(endpoints_1.GET_KEY_ACCOUNTS, "/").concat(key);
                return [2 /*return*/, this.get(url)];
            });
        });
    };
    /**
     * [GET /api/networks]
     *
     * Retrieve all accounts in all known EOS networks dependent on a public key:
     *
     * @returns {Promise<GetNetworks>} accounts
     */
    JsonRpc.prototype.get_networks = function () {
        return this.get(endpoints_1.GET_NETWORKS);
    };
    /**
     * [GET /api/sync]
     *
     * returns a plain text with delay in seconds that this server's blockchain database is behind the real time, and a status: OK if the delay is within 180 seconds, or 'OUT_OF_SYNC' otherwise.
     *
     * @returns {Promise<string>} get sync
     */
    JsonRpc.prototype.get_sync_info = function () {
        var url = "".concat(endpoints_1.GET_SYNC_INFO, "/").concat(this.chain);
        return this.get(url);
    };
    /**
     * [GET /api/tokenbalance]
     *
     *  returns a plain text with numeric output indicating the token balance. Zero is returned if the token is not present or does not exist.
     *
     * @param {string} account owner of token
     * @param {string} contract token contract
     * @param {string} token token symbol
     * @returns {Promise<string>} token balance
     */
    JsonRpc.prototype.get_token_balance = function (account, contract, token) {
        var url = "".concat(endpoints_1.GET_TOKEN_BALANCE, "/").concat(this.chain, "/").concat(account, "/").concat(contract, "/").concat(token);
        return this.get(url);
    };
    /**
     * [GET /api/topholders]
     *
     * returns top NUM holders of a specified token in a JSON array containing arrays of (account, amount) pairs. NUM must not be less than 10 or more than 1000.
     *
     * @param {string} contract token contract
     * @param {string} token token symbol
     * @param {string} num number of top holders (min 10, max 1000)
     *
     * @returns {Promise<string>} token balance
     */
    JsonRpc.prototype.get_topholders = function (contract, token, num) {
        var url = "".concat(endpoints_1.GET_TOPHOLDERS, "/").concat(this.chain, "/").concat(contract, "/").concat(token, "/").concat(num);
        return this.get(url);
    };
    /**
     * [GET /api/usercount]
     *
     * returns a plain text with total number of accounts in the network.
     *
     * @returns {Promise<string>} token balance
     */
    JsonRpc.prototype.get_usercount = function () {
        var url = "".concat(endpoints_1.GET_USERCOUNT, "/").concat(this.chain);
        return this.get(url);
    };
    /**
     * [GET /api/topram]
     *
     * returns top NUM RAM buyers in a JSON array containing arrays of (account, bytes) pairs. NUM must not be less than 10 or more than 1000.
     *
     * @param {string} num number of top holders (min 10, max 1000)
     *
     * @returns {Promise<GetTopRam>} top ram holders
     */
    JsonRpc.prototype.get_topram = function (num) {
        var url = "".concat(endpoints_1.GET_TOPRAM, "/").concat(this.chain, "/").concat(num);
        return this.get(url);
    };
    /**
     * [GET /api/topstake]
     *
     * returns top NUM RAM buyers in a JSON array containing arrays of (account, bytes) pairs. NUM must not be less than 10 or more than 1000.
     *
     * @param {string} num returns top NUM stake holders by sum of CPU and Net stakes, in a JSON array containing arrays of (account, cpu_weight, net_weight) tuples. NUM must not be less than 10 or more than 1000.
     *
     * @returns {Promise<GetTopStake>} top stake holders
     */
    JsonRpc.prototype.get_topstake = function (num) {
        var url = "".concat(endpoints_1.GET_TOPSTAKE, "/").concat(this.chain, "/").concat(num);
        return this.get(url);
    };
    /**
     * [GET /api/codehash]
     *
     * retrieves all accounts in all known EOS networks by contract hash.
     *
     * @param {string} num returns top NUM stake holders by sum of CPU and Net stakes, in a JSON array containing arrays of (account, cpu_weight, net_weight) tuples. NUM must not be less than 10 or more than 1000.
     *
     * @returns {Promise<GetCodehash>} accounts
     */
    JsonRpc.prototype.get_codehash = function (hash) {
        var url = "".concat(endpoints_1.GET_CODEHASH, "/").concat(hash);
        return this.get(url);
    };
    /**
     * [GET /api/holdercount]
     *
     * returns a plaintext integer indicating the number of accounts with positive balance for a specified token.
     *
     * @param {string} contract token contract
     * @param {string} token token symbol
     *
     * @returns {Promise<number>} count
     */
    JsonRpc.prototype.get_tokenholder_count = function (contract, token) {
        var url = "".concat(endpoints_1.GET_TOKEN_HOLDER_COUNT, "/").concat(this.chain, "/").concat(contract, "/").concat(token);
        return this.get(url);
    };
    /**
     * [WS get_token_holders]
     *
     * Get all token holders of a contract and symbol
     *
     * @param contract token contract
     * @param token token symbol
     * @returns
     */
    JsonRpc.prototype.get_token_holders = function (contract, token) {
        var _this = this;
        var reqId = ++this.wsRequestId;
        var balances = [];
        return new Promise(function (resolve, reject) {
            _this.wsClient.on('error', function (err) { return reject(err); });
            _this.wsClient.methods.set('reqdata', function (_, params) {
                if (params.end) {
                    resolve(balances);
                }
                balances.push({
                    account: params.data.account,
                    amount: +params.data.amount,
                });
            });
            try {
                _this.wsClient.call(endpoints_1.GET_TOKEN_HOLDERS, {
                    reqid: reqId,
                    network: _this.chain,
                    contract: contract,
                    currency: token,
                });
            }
            catch (err) {
                reject(err);
                return;
            }
        });
    };
    /**
     * [WS get_accounts_from_keys]
     *
     * Get all token holders of a contract and symbol
     *
     * @param keys[] array of keys
     * @returns
     */
    JsonRpc.prototype.get_accounts_from_keys = function (keys) {
        var _this = this;
        var reqId = ++this.wsRequestId;
        var accounts = [];
        return new Promise(function (resolve, reject) {
            _this.wsClient.on('error', function (err) { return reject(err); });
            _this.wsClient.methods.set('reqdata', function (_, params) {
                if (params.end) {
                    resolve(accounts);
                }
                accounts.push({
                    account_name: params.data.account_name,
                    perm: params.data.perm,
                    weight: +params.data.weight,
                    pubkey: params.data.pubkey,
                });
            });
            try {
                _this.wsClient.call(endpoints_1.GET_ACCOUNTS_FROM_KEYS, {
                    reqid: reqId,
                    network: _this.chain,
                    keys: keys,
                });
            }
            catch (err) {
                reject(err);
                return;
            }
        });
    };
    return JsonRpc;
}());
exports.JsonRpc = JsonRpc;
//# sourceMappingURL=jsonrpc.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/rpcerror.js":
/*!*************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/rpcerror.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcStatusError = exports.RpcError = void 0;
/**
 * @private
 * @module RPC-Error
 *
 * copyright defined in eosjs/LICENSE.txt
 */
var RpcError = /** @class */ (function (_super) {
    __extends(RpcError, _super);
    function RpcError(json) {
        var _this = this;
        if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
        }
        else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
        }
        else {
            _this = _super.call(this, json.message) || this;
        }
        Object.setPrototypeOf(_this, RpcError.prototype);
        _this.json = json;
        return _this;
    }
    return RpcError;
}(Error));
exports.RpcError = RpcError;
/**
 * @private
 */
var RpcStatusError = /** @class */ (function (_super) {
    __extends(RpcStatusError, _super);
    function RpcStatusError(response) {
        var _this = this;
        if (response.status === 405) {
            _this = _super.call(this, response.statusText) || this;
        }
        else {
            _this = _super.call(this) || this;
        }
        Object.setPrototypeOf(_this, RpcStatusError.prototype);
        _this.response = response;
        return _this;
    }
    return RpcStatusError;
}(Error));
exports.RpcStatusError = RpcStatusError;
//# sourceMappingURL=rpcerror.js.map

/***/ }),

/***/ "./node_modules/@proton/light-api/dist/src/types/api.js":
/*!**************************************************************!*\
  !*** ./node_modules/@proton/light-api/dist/src/types/api.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/dist/wrap-constants.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/dist/wrap-constants.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Chains": () => (/* binding */ Chains),
/* harmony export */   "ExtendedAssetParser": () => (/* binding */ ExtendedAssetParser),
/* harmony export */   "Networks": () => (/* binding */ Networks),
/* harmony export */   "Status": () => (/* binding */ Status),
/* harmony export */   "Type": () => (/* binding */ Type),
/* harmony export */   "WRAP_AUTH_ACTION": () => (/* binding */ WRAP_AUTH_ACTION),
/* harmony export */   "WRAP_CONTRACT": () => (/* binding */ WRAP_CONTRACT),
/* harmony export */   "accountParser": () => (/* binding */ accountParser),
/* harmony export */   "addressParser": () => (/* binding */ addressParser),
/* harmony export */   "authorizationParser": () => (/* binding */ authorizationParser),
/* harmony export */   "authorizationsParser": () => (/* binding */ authorizationsParser),
/* harmony export */   "baseActionParser": () => (/* binding */ baseActionParser),
/* harmony export */   "baseActionSerializedParser": () => (/* binding */ baseActionSerializedParser),
/* harmony export */   "createAbstractAuthParser": () => (/* binding */ createAbstractAuthParser),
/* harmony export */   "depositBodyParser": () => (/* binding */ depositBodyParser),
/* harmony export */   "exchangeRateParser": () => (/* binding */ exchangeRateParser),
/* harmony export */   "exchangeRatesParser": () => (/* binding */ exchangeRatesParser),
/* harmony export */   "explorerLinkByChain": () => (/* binding */ explorerLinkByChain),
/* harmony export */   "generateAddressBodyParser": () => (/* binding */ generateAddressBodyParser),
/* harmony export */   "generateAddressResponse": () => (/* binding */ generateAddressResponse),
/* harmony export */   "generateAuthParser": () => (/* binding */ generateAuthParser),
/* harmony export */   "initializeCoins": () => (/* binding */ initializeCoins),
/* harmony export */   "initializeConstants": () => (/* binding */ initializeConstants),
/* harmony export */   "isSameToken": () => (/* binding */ isSameToken),
/* harmony export */   "otcOrderResponseParser": () => (/* binding */ otcOrderResponseParser),
/* harmony export */   "otcQuoteBodyParser": () => (/* binding */ otcQuoteBodyParser),
/* harmony export */   "otcQuoteResponseParser": () => (/* binding */ otcQuoteResponseParser),
/* harmony export */   "rateParser": () => (/* binding */ rateParser),
/* harmony export */   "similarChains": () => (/* binding */ similarChains),
/* harmony export */   "singleActionTransactionParser": () => (/* binding */ singleActionTransactionParser),
/* harmony export */   "transactionParser": () => (/* binding */ transactionParser),
/* harmony export */   "webauthActionParser": () => (/* binding */ webauthActionParser),
/* harmony export */   "withdrawBodyParser": () => (/* binding */ withdrawBodyParser),
/* harmony export */   "withdrawHistoryMetalResponseParser": () => (/* binding */ withdrawHistoryMetalResponseParser),
/* harmony export */   "withdrawHistoryMetalSwapParser": () => (/* binding */ withdrawHistoryMetalSwapParser),
/* harmony export */   "withdrawMetalResponseParser": () => (/* binding */ withdrawMetalResponseParser),
/* harmony export */   "withdrawalFeeQuoteParser": () => (/* binding */ withdrawalFeeQuoteParser),
/* harmony export */   "wrapParser": () => (/* binding */ wrapParser),
/* harmony export */   "wrapSetConfParser": () => (/* binding */ wrapSetConfParser),
/* harmony export */   "wrapStartParser": () => (/* binding */ wrapStartParser)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js");
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zod__WEBPACK_IMPORTED_MODULE_0__);


var _similarChains, _explorerLinkByChain;

var Chains;

(function (Chains) {
  Chains["BitcoinMainnet"] = "Bitcoin";
  Chains["BitcoinTestnet"] = "Bitcoin (Testnet)";
  Chains["EthereumMainnet"] = "Ethereum";
  Chains["EthereumRopsten"] = "Ethereum (Ropsten)";
  Chains["LitecoinMainnet"] = "Litecoin";
  Chains["LitecoinTestnet"] = "Litecoin (Testnet)";
  Chains["BitcoinCashMainnet"] = "Bitcoin Cash";
  Chains["BitcoinCashTestnet"] = "Bitcoin Cash (Testnet)";
  Chains["StellarMainnet"] = "Stellar";
  Chains["StellarTestnet"] = "Stellar (Testnet)";
  Chains["ProtonMainnet"] = "Proton";
  Chains["ProtonTestnet"] = "Proton (Testnet)";
  Chains["PolkadotMainnet"] = "Polkadot";
  Chains["BinanceBEP2"] = "Binance (BEP2)";
  Chains["BinanceBEP20"] = "Binance (BEP20)";
  Chains["EosMainnet"] = "EOS";
  Chains["EosTestnet"] = "EOS (Jungle Testnet)";
  Chains["HederaMainnet"] = "Hedera (Mainnet)";
  Chains["HederaTestnet"] = "Hedera (Testnet)";
  Chains["DogeMainnet"] = "Dogecoin";
  Chains["CardanoMainnet"] = "Cardano";
  Chains["AvalancheXChain"] = "Avalanche X-Chain";
  Chains["AvalancheCChain"] = "Avalanche C-Chain";
  Chains["PolygonMainnet"] = "Polygon";
  Chains["TerraMainnet"] = "Terra";
})(Chains || (Chains = {}));

var Networks;

(function (Networks) {
  Networks["Mainnet"] = "mainnet";
  Networks["Testnet"] = "testnet";
  Networks["Ropsten"] = "ropsten";
  Networks["ERC20"] = "erc20";
  Networks["BEP20"] = "bep20";
  Networks["XLM"] = "xlm";
})(Networks || (Networks = {}));

var similarChains = (_similarChains = {}, _similarChains[Chains.EthereumMainnet] = [Chains.BinanceBEP20], _similarChains[Chains.BinanceBEP20] = [Chains.EthereumMainnet], _similarChains);
var explorerLinkByChain = (_explorerLinkByChain = {}, _explorerLinkByChain[Chains.BitcoinMainnet] = function (txid) {
  return "https://blockchain.com/btc/tx/" + txid;
}, _explorerLinkByChain[Chains.BitcoinTestnet] = function (txid) {
  return "https://blockstream.info/testnet/tx/" + txid;
}, _explorerLinkByChain[Chains.EthereumMainnet] = function (txid) {
  return "https://etherscan.io/tx/" + txid;
}, _explorerLinkByChain[Chains.EthereumRopsten] = function (txid) {
  return "https://ropsten.etherscan.io/tx/" + txid;
}, _explorerLinkByChain[Chains.LitecoinMainnet] = function (txid) {
  return "https://blockchair.com/litecoin/transaction/" + txid;
}, _explorerLinkByChain[Chains.LitecoinTestnet] = function (txid) {
  return "https://blockexplorer.one/litecoin/testnet/blockHash/" + txid;
}, _explorerLinkByChain[Chains.BitcoinCashMainnet] = function (txid) {
  return "https://blockchair.com/bitcoin-cash/transaction/" + txid;
}, _explorerLinkByChain[Chains.BitcoinCashTestnet] = function (txid) {
  return "https://blockexplorer.one/bitcoin-cash/testnet/blockHash/" + txid;
}, _explorerLinkByChain[Chains.StellarMainnet] = function (txid) {
  return "https://blockchair.com/stellar/transaction/" + txid;
}, _explorerLinkByChain[Chains.StellarTestnet] = function (txid) {
  return "https://testnet.steexp.com/tx/" + txid;
}, _explorerLinkByChain[Chains.ProtonMainnet] = function (txid) {
  return "https://proton.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.ProtonTestnet] = function (txid) {
  return "https://proton-test.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.PolkadotMainnet] = function (txid) {
  return "https://polkadot.subscan.io/extrinsic/" + txid;
}, _explorerLinkByChain[Chains.BinanceBEP2] = function (txid) {
  return "https://binance.mintscan.io/txs/" + txid;
}, _explorerLinkByChain[Chains.BinanceBEP20] = function (txid) {
  return "https://bscscan.com/tx/" + txid;
}, _explorerLinkByChain[Chains.EosMainnet] = function (txid) {
  return "https://bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.EosTestnet] = function (txid) {
  return "https://jungle.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.HederaMainnet] = function (txid) {
  return "https://app.dragonglass.me/transactions/" + txid;
}, _explorerLinkByChain[Chains.HederaTestnet] = function (txid) {
  return "https://testnet.dragonglass.me/transactions/" + txid;
}, _explorerLinkByChain[Chains.DogeMainnet] = function (txid) {
  return "https://blockchair.com/dogecoin/transaction/" + txid;
}, _explorerLinkByChain[Chains.CardanoMainnet] = function (txid) {
  return "https://explorer.cardano.org/en/transaction?id=" + txid;
}, _explorerLinkByChain[Chains.AvalancheXChain] = function (txid) {
  return "https://avascan.info/blockchain/x/tx/" + txid;
}, _explorerLinkByChain[Chains.AvalancheCChain] = function (txid) {
  return "https://snowtrace.io/tx/" + txid;
}, _explorerLinkByChain[Chains.PolygonMainnet] = function (txid) {
  return "https://polygonscan.com/tx/" + txid;
}, _explorerLinkByChain[Chains.TerraMainnet] = function (txid) {
  return "https://terra.stake.id/?#/tx/" + txid;
}, _explorerLinkByChain);
var initializeCoins = function initializeCoins(protonChain) {
  var IS_MAINNET = protonChain === 'proton';
  var IS_TESTNET = protonChain === 'proton-test';
  var coins = [{
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Proton',
    coin: 'XPR',
    xtokenSymbol: 'XPR',
    xtokenPrecision: 4,
    xtokenContract: 'eosio.token',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'XPR-ERC20',
      symbol: 'XPR',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 4,
      contract: '0xD7EFB00D12C2C13131FD319336FDF952525DA2AF',
      hasWithdrawMemo: false
    }, {
      wallet: 'XPR-BEP20',
      symbol: 'XPR',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 4,
      contract: '0x5DE3939B2F811A61D830E6F52D13B066881412AB',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/eosio-tokenXPR.png',
    coingeckoId: 'proton'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'USD Coin',
    coin: 'USDC',
    xtokenSymbol: 'XUSDC',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'USDC',
      symbol: 'USDC',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 6,
      contract: '0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48',
      hasWithdrawMemo: false
    }, {
      wallet: 'USDC-BEP20',
      symbol: 'USDC',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: '0x8AC76A51CC950D9822D68B83FE1AD97B32CD580D',
      hasWithdrawMemo: false
    }, {
      wallet: 'USDC-XLM',
      symbol: 'USDC',
      chain: Chains.StellarMainnet,
      network: Networks.XLM,
      precision: 7,
      contract: undefined,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'USDC',
      symbol: 'USDC',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 6,
      contract: '0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUSDC.png',
    coingeckoId: 'usd-coin'
  }, {
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Metal',
    coin: 'MTL',
    xtokenSymbol: 'XMT',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'MTL',
      symbol: 'MTL',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 8,
      contract: '0xF433089366899D83A9F26A773D59EC7ECF30355E',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXMT.png',
    coingeckoId: 'metal'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'Bitcoin',
    coin: 'BTC',
    xtokenSymbol: 'XBTC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BTC',
      symbol: 'BTC',
      chain: Chains.BitcoinMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'BTC',
      symbol: 'BTC',
      chain: Chains.BitcoinTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXBTC.png',
    coingeckoId: 'bitcoin'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'Ethereum',
    coin: 'ETH',
    xtokenSymbol: 'XETH',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'ETH',
      symbol: 'ETH',
      chain: Chains.EthereumMainnet,
      network: Networks.Mainnet,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'ETH',
      symbol: 'ETH',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXETH.png',
    coingeckoId: 'ethereum'
  }, {
    allowSwap: true,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Loan',
    coin: 'LOAN',
    xtokenSymbol: 'LOAN',
    xtokenPrecision: 4,
    xtokenContract: 'loan.token',
    wallets: [],
    image: 'https://www.protonchain.com/images/tokens/loan.tokenLOAN.png',
    coingeckoId: 'proton-loan'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Tether',
    coin: 'USDT',
    xtokenSymbol: 'XUSDT',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'USDT',
      symbol: 'USDT',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 6,
      contract: '0xDAC17F958D2EE523A2206206994597C13D831EC7',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'USDT',
      symbol: 'USDT',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 6,
      contract: '0xDAC17F958D2EE523A2206206994597C13D831EC7',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUSDT.png',
    coingeckoId: 'tether'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'TrueUSD',
    coin: 'TUSD',
    xtokenSymbol: 'XTUSD',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'TUSD',
      symbol: 'TUSD',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x0000000000085D4780B73119B644AE5ECD22B376',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXTUSD.png',
    coingeckoId: 'true-usd'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Paxos Standard',
    coin: 'PAX',
    xtokenSymbol: 'XPAX',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'PAX',
      symbol: 'PAX',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x8E870D67F660D95D5BE530380D0EC0BD388289E1',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXPAX.png',
    coingeckoId: 'usdp'
  }, {
    allowSwap: false,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Paxos Gold',
    coin: 'PAXG',
    xtokenSymbol: 'XPAXG',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'PAXG',
      symbol: 'PAXG',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x45804880DE22913DAFE09F4980848ECE6ECBAF78',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'PAXG',
      symbol: 'PAXG',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x45804880DE22913DAFE09F4980848ECE6ECBAF78',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXPAXG.png',
    coingeckoId: 'pax-gold'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Uniswap',
    coin: 'UNI',
    xtokenSymbol: 'XUNI',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'UNI',
      symbol: 'UNI',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x1F9840A85D5AF5BF1D1762F925BDADDC4201F984',
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'UNI',
      symbol: 'UNI',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x1F9840A85D5AF5BF1D1762F925BDADDC4201F984',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUNI.png',
    coingeckoId: 'uniswap'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: '1INCH',
    coin: '1INCH',
    xtokenSymbol: 'XINCH',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: '1INCH',
      symbol: '1INCH',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x111111111117DC0AA78B770FA6A738034120C302',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXINCH.png',
    coingeckoId: '1inch'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Chainlink',
    coin: 'LINK',
    xtokenSymbol: 'XLINK',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LINK',
      symbol: 'LINK',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x514910771AF9CA656AF840DFF83E8264ECF986CA',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXLINK.png',
    coingeckoId: 'chainlink'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Litecoin',
    coin: 'LTC',
    xtokenSymbol: 'XLTC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LTC',
      symbol: 'LTC',
      chain: Chains.LitecoinMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'LTC',
      symbol: 'LTC',
      chain: Chains.LitecoinTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXLTC.png',
    coingeckoId: 'litecoin'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Bitcoin Cash',
    coin: 'BCH',
    xtokenSymbol: 'XBCH',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BCH',
      symbol: 'BCH',
      chain: Chains.BitcoinCashMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'BCH',
      symbol: 'BCH',
      chain: Chains.BitcoinCashTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXBCH.png',
    coingeckoId: 'bitcoin-cash'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Stellar',
    coin: 'XLM',
    xtokenSymbol: 'XXLM',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'XLM',
      symbol: 'XLM',
      chain: Chains.StellarMainnet,
      network: Networks.Mainnet,
      precision: 7,
      contract: undefined,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'XLM',
      symbol: 'XLM',
      chain: Chains.StellarTestnet,
      network: Networks.Testnet,
      precision: 7,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXXLM.png',
    coingeckoId: 'stellar'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Sense',
    coin: 'SENSE',
    xtokenSymbol: 'XSENSE',
    xtokenPrecision: 4,
    xtokenContract: 'sense',
    wallets: [],
    image: 'https://www.protonchain.com/images/tokens/senseXSENSE.png',
    coingeckoId: 'sense'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Polkadot',
    coin: 'DOT',
    xtokenSymbol: 'XDOT',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'DOT',
      symbol: 'DOT',
      chain: Chains.PolkadotMainnet,
      network: Networks.Mainnet,
      precision: 10,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXDOT.png',
    coingeckoId: 'polkadot'
  }, {
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Binance Coin',
    coin: 'BNB',
    xtokenSymbol: 'XBNB',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BNB',
      symbol: 'BNB',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXBNB.png',
    coingeckoId: 'binancecoin'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'EOS',
    coin: 'EOS',
    xtokenSymbol: 'XEOS',
    xtokenPrecision: 4,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'EOS',
      symbol: 'EOS',
      chain: Chains.EosMainnet,
      network: Networks.Mainnet,
      precision: 4,
      contract: undefined,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'EOS',
      symbol: 'EOS',
      chain: Chains.EosTestnet,
      network: Networks.Testnet,
      precision: 4,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXEOS.png',
    coingeckoId: 'eos'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Dogecoin',
    coin: 'DOGE',
    xtokenSymbol: 'XDOGE',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'DOGE',
      symbol: 'DOGE',
      chain: Chains.DogeMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXDOGE.png',
    coingeckoId: 'dogecoin'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Cardano',
    coin: 'ADA',
    xtokenSymbol: 'XADA',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'ADA',
      symbol: 'ADA',
      chain: Chains.CardanoMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXADA.png',
    coingeckoId: 'cardano'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Avalanche',
    coin: 'AVAX',
    xtokenSymbol: 'XAVAX',
    xtokenPrecision: 9,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'AVAX',
      symbol: 'AVAX',
      chain: Chains.AvalancheXChain,
      network: Networks.Mainnet,
      precision: 9,
      contract: undefined,
      hasWithdrawMemo: false
    }, {
      wallet: 'AVAX',
      symbol: 'AVAX',
      chain: Chains.AvalancheCChain,
      network: Networks.Mainnet,
      precision: 9,
      contract: undefined,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXAVAX.png',
    coingeckoId: 'avalanche-2'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Polygon',
    coin: 'MATIC',
    xtokenSymbol: 'XMATIC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'MATIC',
      symbol: 'MATIC',
      chain: Chains.PolygonMainnet,
      network: Networks.Mainnet,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXMATIC.png',
    coingeckoId: 'matic-network'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Luna',
    coin: 'LUNA',
    xtokenSymbol: 'XLUNA',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LUNA',
      symbol: 'LUNA',
      chain: Chains.TerraMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXLUNA.png',
    coingeckoId: 'terra-luna'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'TerraUSD',
    coin: 'UST',
    xtokenSymbol: 'XUST',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'UST',
      symbol: 'UST',
      chain: Chains.TerraMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXUST.png',
    coingeckoId: 'terrausd'
  }, {
    allowSwap: false,
    allowBridge: IS_TESTNET,
    allowLend: false,
    allowBorrow: false,
    name: 'HBAR',
    coin: 'HBAR',
    xtokenSymbol: 'XHBAR',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_TESTNET ? [{
      wallet: 'HBAR',
      symbol: 'HBAR',
      chain: Chains.HederaTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.protonchain.com/images/tokens/xtokensXHBAR.png',
    coingeckoId: 'hedera-hashgraph'
  }]; // Validation

  var walletWithDuplicateChains = coins.find(function (coin) {
    var chains = coin.wallets.map(function (wallet) {
      return wallet.chain;
    });
    return new Set(chains).size !== chains.length;
  });

  if (walletWithDuplicateChains) {
    throw new Error("Coin " + walletWithDuplicateChains.coin + " has duplicate chains in wallet");
  }

  return {
    allCoins: coins,
    swapCoins: coins.filter(function (coin) {
      return coin.allowSwap;
    }),
    bridgeCoins: coins.filter(function (coin) {
      return coin.allowBridge;
    }),
    lendCoins: coins.filter(function (coin) {
      return coin.allowLend;
    }),
    borrowCoins: coins.filter(function (coin) {
      return coin.allowBorrow;
    }),
    loanCoins: coins.filter(function (coin) {
      return coin.allowLend || coin.allowBorrow;
    }),
    allEnabledCoins: coins.filter(function (coin) {
      return coin.allowSwap || coin.allowBridge;
    })
  };
};

var accountParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().regex(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
var authorizationParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  actor: accountParser,
  permission: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var authorizationsParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(authorizationParser).min(1);
var ExtendedAssetParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  quantity: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  contract: accountParser
});

var rawTransactionParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  expiration: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  ref_block_num: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  ref_block_prefix: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  max_net_usage_words: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  max_cpu_usage_ms: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  delay_sec: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  context_free_actions: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)( /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.any)()),
  transaction_extensions: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)( /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.any)())
});
var baseActionParser = function baseActionParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    account: contract === '*' ? accountParser : (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(contract),
    name: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(action),
    data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)(data),
    authorization: authorizationsParser
  });
};
var baseActionSerializedParser = function baseActionSerializedParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    account: contract === '*' ? accountParser : (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(contract),
    name: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(action),
    data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().or((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)(data)),
    authorization: authorizationsParser
  });
};
var webauthActionParser = function webauthActionParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    account: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)('webauthn'),
    name: (0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)('exec'),
    data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
      account: accountParser,
      key: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
        key: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)((0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().or((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
          modulus: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
          exponent: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
        }))),
        user_presence: (0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
        rpid: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
      }),
      nonce: (0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
      permissions: authorizationsParser,
      signature: (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
        auth_data: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
        client_json: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
        signature: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
      }),
      trx: rawTransactionParser.merge((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
        actions: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(baseActionSerializedParser(contract, action, data)).length(1)
      }))
    }),
    authorization: authorizationsParser
  });
};
var singleActionTransactionParser = function singleActionTransactionParser(contract, action, data) {
  var baseAction = baseActionParser(contract, action, data);
  var webauthAction = webauthActionParser(contract, action, data);
  return rawTransactionParser.merge((0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    actions: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(baseAction.or(webauthAction)).length(1)
  }));
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var WRAP_CONTRACT = 'proton.wrap';
var WRAP_AUTH_ACTION = 'generateauth';
var initializeConstants = function initializeConstants(chain) {
  var _initializeCoins = initializeCoins(chain),
      swapCoins = _initializeCoins.swapCoins,
      bridgeCoins = _initializeCoins.bridgeCoins,
      allEnabledCoins = _initializeCoins.allEnabledCoins,
      allCoins = _initializeCoins.allCoins,
      lendCoins = _initializeCoins.lendCoins,
      borrowCoins = _initializeCoins.borrowCoins,
      loanCoins = _initializeCoins.loanCoins;

  var constants = {
    SWAP_CONTRACT: 'proton.swaps',
    FEE_FACTOR: 10000,
    GOOGLE_MAPS_KEY: 'AIzaSyDb2_CrK032kSIqBXbkdwmaLKWELl0SxVs',
    SWAP_URL: chain === 'proton' ? 'https://otc.protonswap.com' : 'https://otc-test.protonswap.com',
    WRAP_SERVER_URL: chain === 'proton' ? 'https://www.api.bloks.io/proton-wrap-public2' : 'https://www.api.bloks.io/proton-wrap-testnet-public2',
    WRAP_CONTRACT: WRAP_CONTRACT,
    WRAP_ACTIONS: {
      SAVE_ADDRESS: 'saveaddress2',
      DELETE_ADDRESS: 'deladdress2',
      WRAP_START: 'wrapstart2',
      WRAP_FINISH: 'wrapfinish2',
      WRAP_PROCESS: 'wrapprocess2',
      WRAP_SET_CONF: 'wrapsetconf2'
    },
    WRAP_TABLES: {
      ADDRESSES: 'addresses2',
      WRAPS: 'wraps2'
    },
    ADDRESSES_INDEXES: {
      BY_ACCOUNT: 2,
      BY_ADDR_HASH: 3
    },
    WRAPS_INDEXES: {
      BY_ACCOUNT: 2,
      BY_STATUS: 3,
      BY_WRAP_HASH: 4
    },
    WRAP_PROCESS_TIMER: 5000,
    FARM_CONTRACT: 'yield.farms',
    WEBHOOK_PERMISSION: 'webhook',
    PUBLIC_PERMISSION: 'public',
    LIGHT_PERMISSION: 'light',
    WRAP_AUTH_ACTION: WRAP_AUTH_ACTION,
    METAL_ENDPOINT: chain === 'proton' ? 'https://cirrus.metalpay.com' : 'https://cirrus-dev.metalpay.com',
    METAL_PROTON_ENDPOINT: chain === 'proton' ? 'https://api.protonchain.com' : 'https://api-dev.protonchain.com',
    PROTON_ENDPOINTS: chain === 'proton' ? ['https://proton.greymass.com', 'https://proton.eoscafeblock.com', 'https://proton.cryptolions.io', 'https://proton.eosusa.news'] : ['https://testnet.protonchain.com'],
    CHAIN_ID: chain === 'proton' ? '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0' : '71ee83bcf52142d61019d95f9cc5427ba6a0d7ff8accd9e2088ae2abeaf3d3dd',
    CHAIN: chain,
    SWAP_COINS: swapCoins,
    BRIDGE_COINS: bridgeCoins,
    ALL_ENABLED_COINS: allEnabledCoins,
    LEND_COINS: lendCoins,
    BORROW_COINS: borrowCoins,
    LOAN_COINS: loanCoins,
    ALL_COINS: allCoins,
    findBridgeCoinWalletByXtokenAndChain: function findBridgeCoinWalletByXtokenAndChain(xtokenSymbol, chain) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.xtokenSymbol === xtokenSymbol;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.chain === chain;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    },
    findBridgeCoinWallet: function findBridgeCoinWallet(coin, wallet) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.coin === coin;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.wallet === wallet;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    },
    findBridgeCoinNetwork: function findBridgeCoinNetwork(coin, network) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.coin === coin;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.network === network;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    }
  };
  return constants;
};

var createAbstractAuthParser = function createAbstractAuthParser(contract, action, data) {
  return (0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
    signer: authorizationParser,
    signatures: (0,zod__WEBPACK_IMPORTED_MODULE_0__.array)((0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()).length(1),
    transaction: singleActionTransactionParser(contract, action, data)
  });
};
var generateAuthData = {
  time: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  protonAccount: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
};
var generateAuthParser = /*#__PURE__*/createAbstractAuthParser(WRAP_CONTRACT, WRAP_AUTH_ACTION, generateAuthData);

var addressParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  index: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  account: accountParser,
  chain: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address_hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var generateAddressBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  coin: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: (0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
}).merge(generateAuthParser);
var generateAddressResponse = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  coin: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  memo: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});

var rateParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  counterCurrency: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  price: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  priceChangePercent: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  marketCap: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  volume: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  timestamp: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});
var exchangeRateParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  contract: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  symbol: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  rank: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  rates: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(rateParser)
});
var exchangeRatesParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(exchangeRateParser);

var Type;

(function (Type) {
  Type["RECEIVE"] = "receive";
  Type["SEND"] = "send";
})(Type || (Type = {}));

var depositBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  type: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.nativeEnum)(Type),
  hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  coin: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var transactionParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wallet: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  value: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  valueString: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  type: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.nativeEnum)(Type),
  state: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  blockHash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional().nullable(),
  blockHeight: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)().optional().nullable()
});

var otcOrderResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  success: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.boolean)(),
  transaction_id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  errormsg: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});
var otcQuoteBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  baseAmount: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  baseSymbol: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  quoteSymbol: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var otcQuoteResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  success: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.boolean)(),
  token: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  qty: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  errormsg: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});

var withdrawData = {
  from: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().refine(function (val) {
    return val !== WRAP_CONTRACT;
  }, {
    message: WRAP_CONTRACT + " must be receiver"
  }),
  to: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.literal)(WRAP_CONTRACT),
  quantity: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  memo: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
};
var withdrawBodyParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  signer: authorizationParser,
  signatures: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)((0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()).length(1),
  transaction: /*#__PURE__*/singleActionTransactionParser('*', 'transfer', withdrawData),
  quoteId: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  provider: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});
var withdrawMetalResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  success: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.boolean)(),
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});
var withdrawalFeeQuoteParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  quoteId: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  estimatedFee: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  currency: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  network: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)()
});

var withdrawHistoryMetalSwapParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  status: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  amount: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  currency: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  network: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  created: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  withdrawalAddress: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  withdrawalHash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)().optional()
});
var withdrawHistoryMetalResponseParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  swaps: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.array)(withdrawHistoryMetalSwapParser),
  page: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  pageSize: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  numberOfElements: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  totalPages: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  totalElements: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});

var Status;

(function (Status) {
  Status["PENDING"] = "pending";
  Status["SUCCESS"] = "success";
  Status["FAIL"] = "fail";
  Status["PROCESSING"] = "processing";
})(Status || (Status = {}));

var wrapStartParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  balance: ExtendedAssetParser,
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  txid: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  chain: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  deposit_address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});
var wrapSetConfParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  wrap_hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});
var wrapParser = /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.object)({
  index: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)(),
  proton_account: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  balance: ExtendedAssetParser,
  id: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  txid: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  chain: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  deposit_address: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  status: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.nativeEnum)(Status),
  finish_txid: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  wrap_hash: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.string)(),
  confirmations: /*#__PURE__*/(0,zod__WEBPACK_IMPORTED_MODULE_0__.number)()
});

var isSameToken = function isSameToken(token1, token2) {
  return token1.xtokenSymbol === token2.xtokenSymbol && token1.xtokenPrecision === token2.xtokenPrecision && token1.xtokenContract === token2.xtokenContract;
};


//# sourceMappingURL=wrap-constants.esm.js.map


/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
exports.ZodErrorCode = util_1.util.arrayToEnum([
    'invalid_type',
    'nonempty_array_is_empty',
    'custom_error',
    'invalid_union',
    'invalid_literal_value',
    'invalid_enum_value',
    'unrecognized_keys',
    'invalid_arguments',
    'invalid_return_type',
    'invalid_date',
    'invalid_string',
    'too_small',
    'too_big',
]);
exports.quotelessJson = function (obj) {
    var json = JSON.stringify(obj, null, 2); // {"name":"John Smith"}
    return json.replace(/"([^"]+)":/g, '$1:');
};
var ZodError = /** @class */ (function (_super) {
    __extends(ZodError, _super);
    function ZodError(errors) {
        var _newTarget = this.constructor;
        var _this = _super.call(this) || this;
        _this.errors = [];
        _this.addError = function (sub) {
            _this.errors = _this.errors.concat([sub]);
        };
        _this.addErrors = function (subs) {
            if (subs === void 0) { subs = []; }
            _this.errors = _this.errors.concat(subs);
        };
        _this.flatten = function () {
            var fieldErrors = {};
            var formErrors = [];
            for (var _i = 0, _a = _this.errors; _i < _a.length; _i++) {
                var sub = _a[_i];
                if (sub.path.length > 0) {
                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                    fieldErrors[sub.path[0]].push(sub.message);
                }
                else {
                    formErrors.push(sub.message);
                }
            }
            return { formErrors: formErrors, fieldErrors: fieldErrors };
        };
        // restore prototype chain
        var actualProto = _newTarget.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(_this, actualProto);
        }
        else {
            _this.__proto__ = actualProto;
        }
        _this.errors = errors;
        return _this;
    }
    Object.defineProperty(ZodError.prototype, "message", {
        get: function () {
            // return JSON.stringify(this.errors, null, 2);
            var errorMessage = [
                this.errors.length + " validation issue(s)",
                '',
            ];
            for (var _i = 0, _a = this.errors; _i < _a.length; _i++) {
                var err = _a[_i];
                var pathString = err.path.join('.') || '[[root]]';
                errorMessage.push("  Issue #" + this.errors.indexOf(err) + ": " + err.code + " at " + pathString);
                errorMessage.push("  " + err.message);
                errorMessage.push('');
            }
            return errorMessage.join('\n');
            // return quotelessJson(this);
            // .map(({ path, message }) => {
            //   return path.length ? `${path.join('./index')}: ${message}` : `${message}`;
            // })
            // .join('\n');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodError.prototype, "isEmpty", {
        get: function () {
            return this.errors.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodError.prototype, "formErrors", {
        get: function () {
            return this.flatten();
        },
        enumerable: true,
        configurable: true
    });
    ZodError.create = function (errors) {
        var error = new ZodError(errors);
        return error;
    };
    return ZodError;
}(Error));
exports.ZodError = ZodError;
//# sourceMappingURL=ZodError.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/codegen.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/codegen.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./index */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js"));
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
var isOptional = function (schema) {
    var def = schema._def;
    if (def.t === z.ZodTypes.undefined)
        return true;
    else if (def.t === z.ZodTypes.intersection) {
        return isOptional(def.right) && isOptional(def.left);
    }
    else if (def.t === z.ZodTypes.union) {
        return def.options.map(isOptional).some(function (x) { return x === true; });
    }
    return false;
};
var ZodCodeGenerator = /** @class */ (function () {
    function ZodCodeGenerator() {
        var _this = this;
        this.seen = [];
        this.serial = 0;
        this.randomId = function () {
            return "IZod" + _this.serial++;
        };
        this.findBySchema = function (schema) {
            return _this.seen.find(function (s) { return s.schema === schema; });
        };
        this.findById = function (id) {
            var found = _this.seen.find(function (s) { return s.id === id; });
            if (!found)
                throw new Error("Unfound ID: " + id);
            return found;
        };
        this.dump = function () {
            return "\ntype Identity<T> = T;\n\n" + _this.seen
                .map(function (item) { return "type " + item.id + " = Identity<" + item.type + ">;"; })
                .join('\n\n') + "\n";
        };
        this.setType = function (id, type) {
            var found = _this.findById(id);
            found.type = type;
            return found;
        };
        this.generate = function (schema) {
            var found = _this.findBySchema(schema);
            if (found)
                return found;
            var def = schema._def;
            var id = _this.randomId();
            var ty = {
                schema: schema,
                id: id,
                type: "__INCOMPLETE__",
            };
            _this.seen.push(ty);
            switch (def.t) {
                case z.ZodTypes.string:
                    return _this.setType(id, "string");
                case z.ZodTypes.number:
                    return _this.setType(id, "number");
                case z.ZodTypes.bigint:
                    return _this.setType(id, "bigint");
                case z.ZodTypes.boolean:
                    return _this.setType(id, "boolean");
                case z.ZodTypes.date:
                    return _this.setType(id, "Date");
                case z.ZodTypes.undefined:
                    return _this.setType(id, "undefined");
                case z.ZodTypes.null:
                    return _this.setType(id, "null");
                case z.ZodTypes.any:
                    return _this.setType(id, "any");
                case z.ZodTypes.unknown:
                    return _this.setType(id, "unknown");
                case z.ZodTypes.void:
                    return _this.setType(id, "void");
                case z.ZodTypes.literal:
                    var val = def.value;
                    var literalType = typeof val === 'string' ? "\"" + val + "\"" : "" + val;
                    return _this.setType(id, literalType);
                case z.ZodTypes.enum:
                    return _this.setType(id, def.values.map(function (v) { return "\"" + v + "\""; }).join(' | '));
                case z.ZodTypes.object:
                    var objectLines = [];
                    var shape = def.shape();
                    for (var key in shape) {
                        var childSchema = shape[key];
                        var childType = _this.generate(childSchema);
                        var OPTKEY = isOptional(childSchema) ? '?' : '';
                        objectLines.push("" + key + OPTKEY + ": " + childType.id);
                    }
                    var baseStruct = "{\n" + objectLines
                        .map(function (line) { return "  " + line + ";"; })
                        .join('\n') + "\n}";
                    _this.setType(id, "" + baseStruct);
                    break;
                case z.ZodTypes.tuple:
                    var tupleLines = [];
                    for (var _i = 0, _a = def.items; _i < _a.length; _i++) {
                        var elSchema = _a[_i];
                        var elType = _this.generate(elSchema);
                        tupleLines.push(elType.id);
                    }
                    var baseTuple = "[\n" + tupleLines
                        .map(function (line) { return "  " + line + ","; })
                        .join('\n') + "\n]";
                    return _this.setType(id, "" + baseTuple);
                case z.ZodTypes.array:
                    return _this.setType(id, _this.generate(def.type).id + "[]");
                case z.ZodTypes.function:
                    var args = _this.generate(def.args);
                    var returns = _this.generate(def.returns);
                    return _this.setType(id, "(...args: " + args.id + ")=>" + returns.id);
                case z.ZodTypes.promise:
                    var promValue = _this.generate(def.type);
                    return _this.setType(id, "Promise<" + promValue.id + ">");
                case z.ZodTypes.union:
                    var unionLines = [];
                    for (var _b = 0, _c = def.options; _b < _c.length; _b++) {
                        var elSchema = _c[_b];
                        var elType = _this.generate(elSchema);
                        unionLines.push(elType.id);
                    }
                    return _this.setType(id, unionLines.join(" | "));
                case z.ZodTypes.intersection:
                    return _this.setType(id, _this.generate(def.left).id + " & " + _this.generate(def.right).id);
                case z.ZodTypes.record:
                    return _this.setType(id, "{[k:string]: " + _this.generate(def.valueType).id + "}");
                case z.ZodTypes.lazy:
                    var lazyType = def.getter();
                    return _this.setType(id, _this.generate(lazyType).id);
                case z.ZodTypes.nativeEnum:
                    // const lazyType = def.getter();
                    return _this.setType(id, 'asdf');
                case z.ZodTypes.keyof:
                    // const lazyType = def.getter();
                    return _this.setType(id, "keyof [" + def.values
                        .map(function (val) { return (typeof val === 'string' ? "\"" + val + "\"" : val); })
                        .join(', ') + "]");
                default:
                    util_1.util.assertNever(def);
            }
            return _this.findById(id);
        };
    }
    ZodCodeGenerator.create = function () { return new ZodCodeGenerator(); };
    return ZodCodeGenerator;
}());
exports.ZodCodeGenerator = ZodCodeGenerator;
//# sourceMappingURL=codegen.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/defaultErrorMap.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/defaultErrorMap.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ZodError_1 = __webpack_require__(/*! ./ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
exports.defaultErrorMap = function (error, _ctx) {
    var message;
    switch (error.code) {
        case ZodError_1.ZodErrorCode.invalid_type:
            if (error.received === 'undefined') {
                message = 'Required';
            }
            else {
                message = "Expected " + error.expected + ", received " + error.received;
            }
            break;
        case ZodError_1.ZodErrorCode.nonempty_array_is_empty:
            message = "List must contain at least one item";
            break;
        case ZodError_1.ZodErrorCode.unrecognized_keys:
            message = "Unrecognized key(s) in object: " + error.keys.map(function (k) { return "'" + k + "'"; }).join(', ');
            break;
        case ZodError_1.ZodErrorCode.invalid_union:
            message = "Invalid input";
            break;
        // case ZodErrorCode.invalid_tuple_length:
        //   message = `Expected list of ${error.expected} items, received ${error.received} items`;
        //   break;
        case ZodError_1.ZodErrorCode.invalid_literal_value:
            message = "Input must be \"" + error.expected + "\"";
            break;
        case ZodError_1.ZodErrorCode.invalid_enum_value:
            message = "Input must be one of these values: " + error.options.join(', ');
            break;
        case ZodError_1.ZodErrorCode.invalid_arguments:
            message = "Invalid function arguments";
            break;
        case ZodError_1.ZodErrorCode.invalid_return_type:
            message = "Invalid function return type";
            break;
        case ZodError_1.ZodErrorCode.invalid_date:
            message = "Invalid date";
            break;
        // case ZodErrorCode.too_small:
        //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
        //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
        //   break;
        // case ZodErrorCode.too_big:
        //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
        //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
        //   break;
        case ZodError_1.ZodErrorCode.invalid_string:
            if (error.validation !== 'regex')
                message = "Invalid " + error.validation;
            else
                message = 'Invalid';
            break;
        // case ZodErrorCode.invalid_url:
        //   message = 'Invalid URL.';
        //   break;
        // case ZodErrorCode.invalid_uuid:
        //   message = 'Invalid UUID.';
        //   break;
        case ZodError_1.ZodErrorCode.too_small:
            if (error.type === 'array')
                message = "Should have " + (error.inclusive ? "at least" : "more than") + " " + error.minimum + " items";
            else if (error.type === 'string')
                message = "Should be " + (error.inclusive ? "at least" : "over") + " " + error.minimum + " characters";
            else if (error.type === 'number')
                message = "Value should be greater than " + (error.inclusive ? "or equal to " : "") + error.minimum;
            else
                message = 'Invalid input';
            break;
        case ZodError_1.ZodErrorCode.too_big:
            if (error.type === 'array')
                message = "Should have " + (error.inclusive ? "at most" : "less than") + " " + error.maximum + " items";
            else if (error.type === 'string')
                message = "Should be " + (error.inclusive ? "at most" : "under") + " " + error.maximum + " characters long";
            else if (error.type === 'number')
                message = "Value should be less than " + (error.inclusive ? "or equal to " : "") + error.maximum;
            else
                message = 'Invalid input';
            break;
        case ZodError_1.ZodErrorCode.custom_error:
            message = "Invalid input.";
            break;
        default:
            message = "Invalid input.";
            util_1.util.assertNever(error);
    }
    return { message: message };
    // return `Invalid input.`;
};
//# sourceMappingURL=defaultErrorMap.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = function (message) { return (typeof message === 'string' ? { message: message } : message || {}); };
})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));
//# sourceMappingURL=errorUtil.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/objectUtil.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/objectUtil.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_1 = __webpack_require__(/*! ../types/base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js");
var intersection_1 = __webpack_require__(/*! ../types/intersection */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js");
var object_1 = __webpack_require__(/*! ../types/object */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js");
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = function (first, second) {
        var firstKeys = Object.keys(first);
        var secondKeys = Object.keys(second);
        var sharedKeys = firstKeys.filter(function (k) { return secondKeys.indexOf(k) !== -1; });
        var sharedShape = {};
        for (var _i = 0, sharedKeys_1 = sharedKeys; _i < sharedKeys_1.length; _i++) {
            var k = sharedKeys_1[_i];
            sharedShape[k] = intersection_1.ZodIntersection.create(first[k], second[k]);
        }
        return __assign({}, first, second, sharedShape);
    };
    objectUtil.mergeObjects = function (first) { return function (second) {
        var mergedShape = objectUtil.mergeShapes(first._def.shape(), second._def.shape());
        var merged = new object_1.ZodObject({
            t: base_1.ZodTypes.object,
            checks: (first._def.checks || []).concat((second._def.checks || [])),
            params: {
                strict: first.params.strict && second.params.strict,
            },
            shape: function () { return mergedShape; },
        });
        return merged;
    }; };
})(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
//# sourceMappingURL=objectUtil.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var util;
(function (util) {
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = function (items) {
        var obj = {};
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = function (obj) {
        var validKeys = Object.keys(obj).filter(function (k) { return typeof obj[obj[k]] !== 'number'; });
        var filtered = {};
        for (var _i = 0, validKeys_1 = validKeys; _i < validKeys_1.length; _i++) {
            var k = validKeys_1[_i];
            filtered[k] = obj[k];
        }
        return util.getValues(filtered);
    };
    util.getValues = function (obj) {
        return Object.keys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectValues = function (obj) {
        return Object.keys(obj).map(function (e) {
            return obj[e];
        });
    };
})(util = exports.util || (exports.util = {}));
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* ZOD */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
var string_1 = __webpack_require__(/*! ./types/string */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/string.js");
exports.ZodString = string_1.ZodString;
var number_1 = __webpack_require__(/*! ./types/number */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/number.js");
exports.ZodNumber = number_1.ZodNumber;
var bigint_1 = __webpack_require__(/*! ./types/bigint */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/bigint.js");
exports.ZodBigInt = bigint_1.ZodBigInt;
var boolean_1 = __webpack_require__(/*! ./types/boolean */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/boolean.js");
exports.ZodBoolean = boolean_1.ZodBoolean;
var date_1 = __webpack_require__(/*! ./types/date */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/date.js");
exports.ZodDate = date_1.ZodDate;
var undefined_1 = __webpack_require__(/*! ./types/undefined */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/undefined.js");
exports.ZodUndefined = undefined_1.ZodUndefined;
var null_1 = __webpack_require__(/*! ./types/null */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/null.js");
exports.ZodNull = null_1.ZodNull;
var any_1 = __webpack_require__(/*! ./types/any */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/any.js");
exports.ZodAny = any_1.ZodAny;
var unknown_1 = __webpack_require__(/*! ./types/unknown */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js");
exports.ZodUnknown = unknown_1.ZodUnknown;
var void_1 = __webpack_require__(/*! ./types/void */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/void.js");
exports.ZodVoid = void_1.ZodVoid;
var array_1 = __webpack_require__(/*! ./types/array */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/array.js");
exports.ZodArray = array_1.ZodArray;
var object_1 = __webpack_require__(/*! ./types/object */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js");
exports.ZodObject = object_1.ZodObject;
var union_1 = __webpack_require__(/*! ./types/union */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/union.js");
exports.ZodUnion = union_1.ZodUnion;
var intersection_1 = __webpack_require__(/*! ./types/intersection */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js");
exports.ZodIntersection = intersection_1.ZodIntersection;
var tuple_1 = __webpack_require__(/*! ./types/tuple */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js");
exports.ZodTuple = tuple_1.ZodTuple;
var record_1 = __webpack_require__(/*! ./types/record */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/record.js");
exports.ZodRecord = record_1.ZodRecord;
var function_1 = __webpack_require__(/*! ./types/function */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/function.js");
exports.ZodFunction = function_1.ZodFunction;
var lazy_1 = __webpack_require__(/*! ./types/lazy */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/lazy.js");
exports.ZodLazy = lazy_1.ZodLazy;
var literal_1 = __webpack_require__(/*! ./types/literal */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/literal.js");
exports.ZodLiteral = literal_1.ZodLiteral;
var enum_1 = __webpack_require__(/*! ./types/enum */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/enum.js");
exports.ZodEnum = enum_1.ZodEnum;
var nativeEnum_1 = __webpack_require__(/*! ./types/nativeEnum */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/nativeEnum.js");
exports.ZodNativeEnum = nativeEnum_1.ZodNativeEnum;
var keyof_1 = __webpack_require__(/*! ./types/keyof */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/keyof.js");
var promise_1 = __webpack_require__(/*! ./types/promise */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/promise.js");
exports.ZodPromise = promise_1.ZodPromise;
var base_1 = __webpack_require__(/*! ./types/base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js");
exports.ZodType = base_1.ZodType;
exports.Schema = base_1.ZodType;
exports.ZodSchema = base_1.ZodType;
exports.ZodTypes = base_1.ZodTypes;
// import { ZodError, ZodErrorCode, ZodInvalidTypeError,
// ZodNonEmptyArrayIsEmptyError,
// ZodUnrecognizedKeysError,
// ZodInvalidUnionError,
// ZodInvalidLiteralValueError,
// ZodInvalidEnumValueError,
// ZodInvalidArgumentsError,
// ZodInvalidReturnTypeError,
// ZodInvalidDateError,
// ZodInvalidStringError,
// ZodTooSmallError,
// ZodTooBigError,
// ZodCustomError } from './ZodError';
var parser_1 = __webpack_require__(/*! ./parser */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js");
exports.ZodParsedType = parser_1.ZodParsedType;
var codegen_1 = __webpack_require__(/*! ./codegen */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/codegen.js");
exports.ZodCodeGenerator = codegen_1.ZodCodeGenerator;
var stringType = string_1.ZodString.create;
exports.string = stringType;
var numberType = number_1.ZodNumber.create;
exports.number = numberType;
var bigIntType = bigint_1.ZodBigInt.create;
exports.bigint = bigIntType;
var booleanType = boolean_1.ZodBoolean.create;
exports.boolean = booleanType;
var dateType = date_1.ZodDate.create;
exports.date = dateType;
var undefinedType = undefined_1.ZodUndefined.create;
exports.undefined = undefinedType;
var nullType = null_1.ZodNull.create;
exports["null"] = nullType;
var anyType = any_1.ZodAny.create;
exports.any = anyType;
var unknownType = unknown_1.ZodUnknown.create;
exports.unknown = unknownType;
var voidType = void_1.ZodVoid.create;
exports["void"] = voidType;
var arrayType = array_1.ZodArray.create;
exports.array = arrayType;
var objectType = object_1.ZodObject.create;
exports.object = objectType;
var unionType = union_1.ZodUnion.create;
exports.union = unionType;
var intersectionType = intersection_1.ZodIntersection.create;
exports.intersection = intersectionType;
var tupleType = tuple_1.ZodTuple.create;
exports.tuple = tupleType;
var recordType = record_1.ZodRecord.create;
exports.record = recordType;
var functionType = function_1.ZodFunction.create;
exports["function"] = functionType;
var lazyType = lazy_1.ZodLazy.create;
exports.lazy = lazyType;
var literalType = literal_1.ZodLiteral.create;
exports.literal = literalType;
var enumType = enum_1.ZodEnum.create;
exports["enum"] = enumType;
var nativeEnumType = nativeEnum_1.ZodNativeEnum.create;
exports.nativeEnum = nativeEnumType;
var promiseType = promise_1.ZodPromise.create;
exports.promise = promiseType;
var keyofType = keyof_1.ZodKeyof.create;
exports.keyof = keyofType;
var ostring = function () { return stringType().optional(); };
exports.ostring = ostring;
var onumber = function () { return numberType().optional(); };
exports.onumber = onumber;
var oboolean = function () { return booleanType().optional(); };
exports.oboolean = oboolean;
var codegen = codegen_1.ZodCodeGenerator.create;
exports.codegen = codegen;
exports.custom = function (check, params) { return anyType().refine(check, params); };
var instanceOfType = function (cls, params) {
    if (params === void 0) { params = {
        message: "Input not instance of " + cls.name,
    }; }
    return exports.custom(function (data) { return data instanceof cls; }, params);
};
exports["instanceof"] = instanceOfType;
exports.late = {
    object: object_1.ZodObject.lazycreate,
};
__export(__webpack_require__(/*! ./ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/isScalar.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/isScalar.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./index */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js"));
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
exports.isScalar = function (schema, params) {
    if (params === void 0) { params = { root: true }; }
    var def = schema._def;
    var returnValue = false;
    switch (def.t) {
        case z.ZodTypes.string:
            returnValue = true;
            break;
        case z.ZodTypes.number:
            returnValue = true;
            break;
        case z.ZodTypes.bigint:
            returnValue = true;
            break;
        case z.ZodTypes.boolean:
            returnValue = true;
            break;
        case z.ZodTypes.undefined:
            returnValue = true;
            break;
        case z.ZodTypes.null:
            returnValue = true;
            break;
        case z.ZodTypes.any:
            returnValue = false;
            break;
        case z.ZodTypes.unknown:
            returnValue = false;
            break;
        case z.ZodTypes.void:
            returnValue = false;
            break;
        case z.ZodTypes.array:
            if (params.root === false)
                return false;
            returnValue = exports.isScalar(def.type, { root: false });
            break;
        case z.ZodTypes.object:
            returnValue = false;
            break;
        case z.ZodTypes.union:
            returnValue = def.options.every(function (x) { return exports.isScalar(x); });
            break;
        case z.ZodTypes.intersection:
            returnValue = exports.isScalar(def.left) && exports.isScalar(def.right);
            break;
        case z.ZodTypes.tuple:
            returnValue = false;
            break;
        case z.ZodTypes.lazy:
            returnValue = exports.isScalar(def.getter());
            break;
        case z.ZodTypes.literal:
            returnValue = true;
            break;
        case z.ZodTypes.enum:
            returnValue = true;
            break;
        case z.ZodTypes.nativeEnum:
            returnValue = true;
            break;
        case z.ZodTypes.function:
            returnValue = false;
            break;
        case z.ZodTypes.record:
            returnValue = false;
            break;
        case z.ZodTypes.date:
            returnValue = true;
            break;
        case z.ZodTypes.promise:
            returnValue = false;
            break;
        case z.ZodTypes.keyof:
            returnValue = true;
            break;
        default:
            util_1.util.assertNever(def);
        // returnValue = false; break;
    }
    return returnValue;
};
//# sourceMappingURL=isScalar.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var _this = this;
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./types/base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodError_1 = __webpack_require__(/*! ./ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var util_1 = __webpack_require__(/*! ./helpers/util */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/util.js");
var defaultErrorMap_1 = __webpack_require__(/*! ./defaultErrorMap */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/defaultErrorMap.js");
exports.getParsedType = function (data) {
    if (typeof data === 'string')
        return 'string';
    if (typeof data === 'number') {
        if (Number.isNaN(data))
            return 'nan';
        return 'number';
    }
    if (typeof data === 'boolean')
        return 'boolean';
    if (typeof data === 'bigint')
        return 'bigint';
    if (typeof data === 'symbol')
        return 'symbol';
    if (data instanceof Date)
        return 'date';
    if (typeof data === 'function')
        return 'function';
    if (data === undefined)
        return 'undefined';
    if (typeof data === 'undefined')
        return 'undefined';
    if (typeof data === 'object') {
        if (Array.isArray(data))
            return 'array';
        if (!data)
            return 'null';
        if (data.then &&
            typeof data.then === 'function' &&
            data.catch &&
            typeof data.catch === 'function') {
            return 'promise';
        }
        return 'object';
    }
    return 'unknown';
};
exports.ZodParsedType = util_1.util.arrayToEnum([
    'string',
    'nan',
    'number',
    'integer',
    'boolean',
    'date',
    'bigint',
    'symbol',
    'function',
    'undefined',
    'null',
    'array',
    'object',
    'unknown',
    'promise',
    'void',
]);
exports.find = function (arr, checker) {
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var item = arr_1[_i];
        if (checker(item))
            return item;
    }
    return undefined;
};
var makeError = function (params, obj, errorData) {
    var errorArg = __assign({}, errorData, { path: params.path.concat((errorData.path || [])) });
    var ctxArg = { data: obj };
    var defaultError = defaultErrorMap_1.defaultErrorMap === params.errorMap
        ? { message: "Invalid value." }
        : defaultErrorMap_1.defaultErrorMap(errorArg, __assign({}, ctxArg, { defaultError: "Invalid value." }));
    return __assign({}, errorData, { path: params.path.concat((errorData.path || [])), message: errorData.message ||
            params.errorMap(errorArg, __assign({}, ctxArg, { defaultError: defaultError.message })).message });
};
exports.ZodParser = function (schemaDef) { return function (obj, baseParams) {
    if (baseParams === void 0) { baseParams = { seen: [], errorMap: defaultErrorMap_1.defaultErrorMap, path: [] }; }
    var params = {
        seen: baseParams.seen || [],
        path: baseParams.path || [],
        errorMap: baseParams.errorMap || defaultErrorMap_1.defaultErrorMap,
    };
    var def = schemaDef;
    var parsedType = exports.getParsedType(obj);
    var schemaSeen = exports.find(params.seen, function (x) { return x.schema === schemaDef; });
    var isNonprimitive = ['array', 'object'].indexOf(parsedType) !== -1;
    if (isNonprimitive) {
        if (schemaSeen) {
            var found = exports.find(schemaSeen.objects, function (x) { return x.data === obj; });
            if (found) {
                if (found.error) {
                    throw found.error;
                }
                found.times = found.times + 1;
                if (found.times > 5 && isNonprimitive) {
                    return Symbol('recursion depth exceeded.');
                }
                else if (found.times > 2) {
                }
            }
            else {
                //
                schemaSeen.objects.push(obj);
            }
        }
        else {
            params.seen.push({
                schema: schemaDef,
                objects: [{ data: obj, error: undefined, times: 1 }],
            });
        }
    }
    // const setError = (error: Error) => {
    //   const schemaSeen = params.seen.find(x => x.schema === schemaDef);
    //   if (schemaSeen) {
    //     const found = schemaSeen.objects.find(x => x.data === obj);
    //     if (found) {
    //       found.error = error;
    //     }
    //   }
    // };
    var error = new ZodError_1.ZodError([]);
    var returnValue = obj;
    switch (def.t) {
        case z.ZodTypes.string:
            if (parsedType !== exports.ZodParsedType.string) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.string,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.number:
            if (parsedType !== exports.ZodParsedType.number) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.number,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            if (Number.isNaN(obj)) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.number,
                    received: exports.ZodParsedType.nan,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.bigint:
            if (parsedType !== exports.ZodParsedType.bigint) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.number,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.boolean:
            if (parsedType !== exports.ZodParsedType.boolean) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.boolean,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.undefined:
            if (parsedType !== exports.ZodParsedType.undefined) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.undefined,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.null:
            if (parsedType !== exports.ZodParsedType.null) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.null,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.any:
            break;
        case z.ZodTypes.unknown:
            break;
        case z.ZodTypes.void:
            if (parsedType !== exports.ZodParsedType.undefined &&
                parsedType !== exports.ZodParsedType.null) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.void,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.array:
            if (parsedType !== exports.ZodParsedType.array) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.array,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            var data = obj;
            if (def.nonempty === true && obj.length === 0) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.nonempty_array_is_empty,
                }));
                // setError(error);
                throw error;
            }
            data.map(function (item, i) {
                try {
                    var parsedItem = def.type.parse(item, __assign({}, params, { path: params.path.concat([i]) }));
                    return parsedItem;
                }
                catch (err) {
                    var zerr = err;
                    error.addErrors(zerr.errors);
                }
            });
            if (!error.isEmpty) {
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.object:
            if (parsedType !== exports.ZodParsedType.object) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.object,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            var shape = def.shape();
            if (def.params.strict) {
                var shapeKeys_1 = Object.keys(shape);
                var objKeys = Object.keys(obj);
                var extraKeys = objKeys.filter(function (k) { return shapeKeys_1.indexOf(k) === -1; });
                if (extraKeys.length) {
                    error.addError(makeError(params, obj, {
                        code: ZodError_1.ZodErrorCode.unrecognized_keys,
                        keys: extraKeys,
                    }));
                }
            }
            for (var key in shape) {
                try {
                    def
                        .shape()[key].parse(obj[key], __assign({}, params, { path: params.path.concat([key]) }));
                }
                catch (err) {
                    var zerr = err;
                    error.addErrors(zerr.errors);
                }
            }
            break;
        case z.ZodTypes.union:
            var isValid = false;
            var unionErrors = [];
            for (var _i = 0, _a = def.options; _i < _a.length; _i++) {
                var option = _a[_i];
                try {
                    option.parse(obj, params);
                    isValid = true;
                }
                catch (err) {
                    unionErrors.push(err);
                }
            }
            if (!isValid) {
                var filteredErrors = unionErrors.filter(function (err) {
                    return err.errors[0].code !== 'invalid_type';
                });
                if (filteredErrors.length === 1) {
                    error.addErrors(filteredErrors[0].errors);
                }
                else {
                    error.addError(makeError(params, obj, {
                        code: ZodError_1.ZodErrorCode.invalid_union,
                        unionErrors: unionErrors,
                    }));
                }
            }
            break;
        case z.ZodTypes.intersection:
            try {
                def.left.parse(obj, params);
            }
            catch (err) {
                error.addErrors(err.errors);
            }
            try {
                def.right.parse(obj, params);
            }
            catch (err) {
                error.addErrors(err.errors);
            }
            break;
        case z.ZodTypes.tuple:
            if (parsedType !== exports.ZodParsedType.array) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.array,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            if (obj.length > def.items.length) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.too_big,
                    maximum: def.items.length,
                    inclusive: true,
                    type: 'array',
                }));
            }
            else if (obj.length < def.items.length) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.too_small,
                    minimum: def.items.length,
                    inclusive: true,
                    type: 'array',
                }));
            }
            var parsedTuple = [];
            var tupleData = obj;
            for (var index in tupleData) {
                var item = tupleData[index];
                var itemParser = def.items[index];
                try {
                    parsedTuple.push(itemParser.parse(item, __assign({}, params, { path: params.path.concat([index]) })));
                }
                catch (err) {
                    error.addErrors(err.errors);
                }
            }
            break;
        case z.ZodTypes.lazy:
            var lazySchema = def.getter();
            lazySchema.parse(obj, params);
            break;
        case z.ZodTypes.literal:
            if (obj !== def.value) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_literal_value,
                    expected: def.value,
                }));
            }
            break;
        case z.ZodTypes.enum:
            if (def.values.indexOf(obj) === -1) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_enum_value,
                    options: def.values,
                }));
            }
            break;
        case z.ZodTypes.nativeEnum:
            if (util_1.util.getValidEnumValues(def.values).indexOf(obj) === -1) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_enum_value,
                    options: util_1.util.getValues(def.values),
                }));
            }
            break;
        case z.ZodTypes.keyof:
            if (util_1.util.getValidEnumValues(def.values).indexOf(obj) === -1) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_enum_value,
                    options: util_1.util.getValues(def.values),
                }));
            }
            break;
        case z.ZodTypes.function:
            if (parsedType !== exports.ZodParsedType.function) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.function,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            var validatedFunc = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    def.args.parse(args);
                }
                catch (err) {
                    if (err instanceof ZodError_1.ZodError) {
                        var argsError = new ZodError_1.ZodError([]);
                        argsError.addError(makeError(params, obj, {
                            code: ZodError_1.ZodErrorCode.invalid_arguments,
                            argumentsError: err,
                        }));
                        throw argsError;
                    }
                    throw err;
                }
                var result = obj.apply(void 0, args);
                try {
                    return def.returns.parse(result);
                }
                catch (err) {
                    if (err instanceof ZodError_1.ZodError) {
                        var returnsError = new ZodError_1.ZodError([]);
                        returnsError.addError(makeError(params, obj, {
                            code: ZodError_1.ZodErrorCode.invalid_return_type,
                            returnTypeError: err,
                        }));
                        throw returnsError;
                    }
                    throw err;
                }
            };
            return validatedFunc;
        case z.ZodTypes.record:
            if (parsedType !== exports.ZodParsedType.object) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.object,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            for (var key in obj) {
                try {
                    def.valueType.parse(obj[key], __assign({}, params, { path: params.path.concat([key]) }));
                }
                catch (err) {
                    error.addErrors(err.errors);
                }
            }
            break;
        case z.ZodTypes.date:
            if (!(obj instanceof Date)) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.date,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            if (isNaN(obj.getTime())) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_date,
                }));
                // setError(error);
                throw error;
            }
            break;
        case z.ZodTypes.promise:
            if (parsedType !== exports.ZodParsedType.promise) {
                error.addError(makeError(params, obj, {
                    code: ZodError_1.ZodErrorCode.invalid_type,
                    expected: exports.ZodParsedType.promise,
                    received: parsedType,
                }));
                // setError(error);
                throw error;
            }
            return new Promise(function (res, rej) { return __awaiter(_this, void 0, void 0, function () {
                var objValue, parsed;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, obj];
                        case 1:
                            objValue = _a.sent();
                            try {
                                parsed = def.type.parse(objValue, params);
                                res(parsed);
                            }
                            catch (err) {
                                rej(err);
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
        default:
            util_1.util.assertNever(def);
    }
    var customChecks = def.checks || [];
    for (var _b = 0, customChecks_1 = customChecks; _b < customChecks_1.length; _b++) {
        var check = customChecks_1[_b];
        if (!check.check(returnValue)) {
            var checkMethod = check.check, noMethodCheck = __rest(check, ["check"]);
            error.addError(makeError(params, obj, noMethodCheck));
        }
    }
    if (!error.isEmpty) {
        // setError(error);
        throw error;
    }
    return returnValue;
}; };
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/any.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/any.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodAny = /** @class */ (function (_super) {
    __extends(ZodAny, _super);
    function ZodAny() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodAny.create = function () {
        return new ZodAny({
            t: z.ZodTypes.any,
        });
    };
    return ZodAny;
}(z.ZodType));
exports.ZodAny = ZodAny;
//# sourceMappingURL=any.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/array.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/array.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
// import { ZodUndefined } from './undefined';
// import { ZodNull } from './null';
// import { ZodUnion } from './union';
var ZodError_1 = __webpack_require__(/*! ../ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var ZodArray = /** @class */ (function (_super) {
    __extends(ZodArray, _super);
    function ZodArray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                nonempty: _this._def.nonempty,
                type: _this._def.type.toJSON(),
            };
        };
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.min = function (minLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: ZodError_1.ZodErrorCode.too_small, type: 'array', inclusive: true, minimum: minLength }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.max = function (maxLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: ZodError_1.ZodErrorCode.too_big, type: 'array', inclusive: true, maximum: maxLength }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.length = function (len, message) { return _this.min(len, { message: message }).max(len, { message: message }); };
        _this.nonempty = function () {
            return new ZodNonEmptyArray(__assign({}, _this._def, { nonempty: true }));
        };
        return _this;
    }
    Object.defineProperty(ZodArray.prototype, "element", {
        get: function () {
            return this._def.type;
        },
        enumerable: true,
        configurable: true
    });
    ZodArray.create = function (schema) {
        return new ZodArray({
            t: z.ZodTypes.array,
            type: schema,
            nonempty: false,
        });
    };
    return ZodArray;
}(z.ZodType));
exports.ZodArray = ZodArray;
var ZodNonEmptyArray = /** @class */ (function (_super) {
    __extends(ZodNonEmptyArray, _super);
    function ZodNonEmptyArray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                type: _this._def.type.toJSON(),
            };
        };
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.min = function (minLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: ZodError_1.ZodErrorCode.too_small, minimum: minLength, type: 'array', inclusive: true }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.max = function (maxLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: ZodError_1.ZodErrorCode.too_big, maximum: maxLength, type: 'array', inclusive: true }, (typeof message === 'string' ? { message: message } : message)));
        };
        _this.length = function (len, message) { return _this.min(len, { message: message }).max(len, { message: message }); };
        return _this;
    }
    return ZodNonEmptyArray;
}(z.ZodType));
exports.ZodNonEmptyArray = ZodNonEmptyArray;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var parser_1 = __webpack_require__(/*! ../parser */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/parser.js");
var index_1 = __webpack_require__(/*! ../index */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/index.js");
var ZodTypes;
(function (ZodTypes) {
    ZodTypes["string"] = "string";
    ZodTypes["number"] = "number";
    ZodTypes["bigint"] = "bigint";
    ZodTypes["boolean"] = "boolean";
    ZodTypes["date"] = "date";
    ZodTypes["undefined"] = "undefined";
    ZodTypes["null"] = "null";
    ZodTypes["array"] = "array";
    ZodTypes["object"] = "object";
    ZodTypes["union"] = "union";
    ZodTypes["intersection"] = "intersection";
    ZodTypes["tuple"] = "tuple";
    ZodTypes["record"] = "record";
    ZodTypes["function"] = "function";
    ZodTypes["lazy"] = "lazy";
    ZodTypes["literal"] = "literal";
    ZodTypes["enum"] = "enum";
    ZodTypes["nativeEnum"] = "nativeEnum";
    ZodTypes["promise"] = "promise";
    ZodTypes["any"] = "any";
    ZodTypes["unknown"] = "unknown";
    ZodTypes["void"] = "void";
    ZodTypes["keyof"] = "keyof";
})(ZodTypes = exports.ZodTypes || (exports.ZodTypes = {}));
var ZodType = /** @class */ (function () {
    function ZodType(def) {
        var _this = this;
        this.safeParse = function (data, params) {
            try {
                var parsed = _this.parse(data, params);
                return {
                    success: true,
                    data: parsed,
                };
            }
            catch (err) {
                if (err instanceof index_1.ZodError) {
                    return {
                        success: false,
                        error: err,
                    };
                }
                throw err;
            }
        };
        this.parseAsync = function (value, params) {
            return new Promise(function (res, rej) {
                try {
                    var parsed = _this.parse(value, params);
                    return res(parsed);
                }
                catch (err) {
                    return rej(err);
                }
            });
        };
        this.refine = function (check, message) {
            if (message === void 0) { message = 'Invalid value.'; }
            if (typeof message === 'string') {
                return _this.refinement({ check: check, message: message });
            }
            return _this.refinement(__assign({ check: check }, message));
        };
        this.refinement = function (refinement) {
            return _this._refinement(__assign({ code: index_1.ZodErrorCode.custom_error }, refinement));
        };
        this._refinement = function (refinement) {
            return new _this.constructor(__assign({}, _this._def, { checks: (_this._def.checks || []).concat([refinement]) }));
        };
        //  abstract // opt optional: () => any;
        this.optional = function () {
            return index_1.ZodUnion.create([_this, index_1.ZodUndefined.create()]);
        };
        this.nullable = function () {
            return index_1.ZodUnion.create([_this, index_1.ZodNull.create()]);
        };
        this.array = function () { return index_1.ZodArray.create(_this); };
        this.or = function (arg) {
            return index_1.ZodUnion.create([_this, arg]);
        };
        this._def = def;
        this.parse = parser_1.ZodParser(def);
    }
    ZodType.prototype.is = function (u) {
        try {
            this.parse(u);
            return true;
        }
        catch (err) {
            return false;
        }
    };
    ZodType.prototype.check = function (u) {
        try {
            this.parse(u);
            return true;
        }
        catch (err) {
            return false;
        }
    };
    return ZodType;
}());
exports.ZodType = ZodType;
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/bigint.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/bigint.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodBigInt = /** @class */ (function (_super) {
    __extends(ZodBigInt, _super);
    function ZodBigInt() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodBigInt.create = function () {
        return new ZodBigInt({
            t: z.ZodTypes.bigint,
        });
    };
    return ZodBigInt;
}(z.ZodType));
exports.ZodBigInt = ZodBigInt;
//# sourceMappingURL=bigint.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/boolean.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/boolean.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodBoolean = /** @class */ (function (_super) {
    __extends(ZodBoolean, _super);
    function ZodBoolean() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodBoolean.create = function () {
        return new ZodBoolean({
            t: z.ZodTypes.boolean,
        });
    };
    return ZodBoolean;
}(z.ZodType));
exports.ZodBoolean = ZodBoolean;
//# sourceMappingURL=boolean.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/date.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/date.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodDate = /** @class */ (function (_super) {
    __extends(ZodDate, _super);
    function ZodDate() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodDate.create = function () {
        return new ZodDate({
            t: z.ZodTypes.date,
        });
    };
    return ZodDate;
}(z.ZodType));
exports.ZodDate = ZodDate;
//# sourceMappingURL=date.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/enum.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/enum.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodEnum = /** @class */ (function (_super) {
    __extends(ZodEnum, _super);
    function ZodEnum() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    Object.defineProperty(ZodEnum.prototype, "options", {
        get: function () {
            return this._def.values;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodEnum.prototype, "enum", {
        get: function () {
            var enumValues = {};
            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {
                var val = _a[_i];
                enumValues[val] = val;
            }
            return enumValues;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodEnum.prototype, "Values", {
        get: function () {
            var enumValues = {};
            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {
                var val = _a[_i];
                enumValues[val] = val;
            }
            return enumValues;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodEnum.prototype, "Enum", {
        get: function () {
            var enumValues = {};
            for (var _i = 0, _a = this._def.values; _i < _a.length; _i++) {
                var val = _a[_i];
                enumValues[val] = val;
            }
            return enumValues;
        },
        enumerable: true,
        configurable: true
    });
    ZodEnum.create = function (values) {
        return new ZodEnum({
            t: z.ZodTypes.enum,
            values: values,
        });
    };
    return ZodEnum;
}(z.ZodType));
exports.ZodEnum = ZodEnum;
//# sourceMappingURL=enum.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/function.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/function.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js");
var unknown_1 = __webpack_require__(/*! ./unknown */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js");
var ZodFunction = /** @class */ (function (_super) {
    __extends(ZodFunction, _super);
    function ZodFunction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.args = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return new ZodFunction(__assign({}, _this._def, { args: tuple_1.ZodTuple.create(items) }));
        };
        _this.returns = function (returnType) {
            return new ZodFunction(__assign({}, _this._def, { returns: returnType }));
        };
        _this.implement = function (func) {
            var validatedFunc = _this.parse(func);
            return validatedFunc;
        };
        _this.validate = _this.implement;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                args: _this._def.args.toJSON(),
                returns: _this._def.returns.toJSON(),
            };
        };
        return _this;
    }
    ZodFunction.create = function (args, returns) {
        return new ZodFunction({
            t: z.ZodTypes.function,
            args: args || tuple_1.ZodTuple.create([]),
            returns: returns || unknown_1.ZodUnknown.create(),
        });
    };
    return ZodFunction;
}(z.ZodType));
exports.ZodFunction = ZodFunction;
//# sourceMappingURL=function.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/intersection.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodIntersection = /** @class */ (function (_super) {
    __extends(ZodIntersection, _super);
    function ZodIntersection() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return ({
            t: _this._def.t,
            left: _this._def.left.toJSON(),
            right: _this._def.right.toJSON(),
        }); };
        return _this;
    }
    ZodIntersection.create = function (left, right) {
        return new ZodIntersection({
            t: z.ZodTypes.intersection,
            left: left,
            right: right,
        });
    };
    return ZodIntersection;
}(z.ZodType));
exports.ZodIntersection = ZodIntersection;
//# sourceMappingURL=intersection.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/keyof.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/keyof.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodKeyof = /** @class */ (function (_super) {
    __extends(ZodKeyof, _super);
    function ZodKeyof() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return ({
            t: _this._def.t,
            values: _this._def.values.map(function (x) { return x.toString(); }),
        }); };
        return _this;
    }
    ZodKeyof.create = function (object) {
        return new ZodKeyof({
            t: z.ZodTypes.keyof,
            // Note that this cast is not correct in the general case
            // See e.g. https://github.com/Microsoft/TypeScript/issues/12870
            values: Object.keys(object),
        });
    };
    return ZodKeyof;
}(z.ZodType));
exports.ZodKeyof = ZodKeyof;
//# sourceMappingURL=keyof.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/lazy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/lazy.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodLazy = /** @class */ (function (_super) {
    __extends(ZodLazy, _super);
    function ZodLazy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () {
            throw new Error("Can't JSONify recursive structure");
        };
        return _this;
    }
    Object.defineProperty(ZodLazy.prototype, "schema", {
        get: function () {
            return this._def.getter();
        },
        enumerable: true,
        configurable: true
    });
    ZodLazy.create = function (getter) {
        return new ZodLazy({
            t: z.ZodTypes.lazy,
            getter: getter,
        });
    };
    return ZodLazy;
}(z.ZodType));
exports.ZodLazy = ZodLazy;
//# sourceMappingURL=lazy.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/literal.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/literal.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodLiteral = /** @class */ (function (_super) {
    __extends(ZodLiteral, _super);
    function ZodLiteral() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodLiteral.create = function (value) {
        return new ZodLiteral({
            t: z.ZodTypes.literal,
            value: value,
        });
    };
    return ZodLiteral;
}(z.ZodType));
exports.ZodLiteral = ZodLiteral;
//# sourceMappingURL=literal.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/nativeEnum.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/nativeEnum.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodNativeEnum = /** @class */ (function (_super) {
    __extends(ZodNativeEnum, _super);
    function ZodNativeEnum() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodNativeEnum.create = function (values) {
        return new ZodNativeEnum({
            t: z.ZodTypes.nativeEnum,
            values: values,
        });
    };
    return ZodNativeEnum;
}(z.ZodType));
exports.ZodNativeEnum = ZodNativeEnum;
//# sourceMappingURL=nativeEnum.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/null.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/null.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodNull = /** @class */ (function (_super) {
    __extends(ZodNull, _super);
    function ZodNull() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodNull.create = function () {
        return new ZodNull({
            t: z.ZodTypes.null,
        });
    };
    return ZodNull;
}(z.ZodType));
exports.ZodNull = ZodNull;
//# sourceMappingURL=null.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/number.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/number.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
// import { ZodUndefined } from './undefined';
// import { ZodNull } from './null';
// import { ZodUnion } from './union';
var ZodError_1 = __webpack_require__(/*! ../ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var errorUtil_1 = __webpack_require__(/*! ../helpers/errorUtil */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js");
var ZodNumber = /** @class */ (function (_super) {
    __extends(ZodNumber, _super);
    function ZodNumber() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        _this.min = function (minimum, message) {
            return _this._refinement(__assign({ check: function (data) { return data >= minimum; }, code: ZodError_1.ZodErrorCode.too_small, minimum: minimum, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.max = function (maximum, message) {
            return _this._refinement(__assign({ check: function (data) { return data <= maximum; }, code: ZodError_1.ZodErrorCode.too_big, maximum: maximum, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.int = function (message) {
            return _this._refinement(__assign({ check: function (data) { return Number.isInteger(data); }, code: ZodError_1.ZodErrorCode.invalid_type, expected: 'integer', received: 'number' }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.positive = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data > 0; }, code: ZodError_1.ZodErrorCode.too_small, minimum: 0, type: 'number', inclusive: false }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.negative = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data < 0; }, code: ZodError_1.ZodErrorCode.too_big, maximum: 0, type: 'number', inclusive: false }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.nonpositive = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data <= 0; }, code: ZodError_1.ZodErrorCode.too_big, maximum: 0, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.nonnegative = function (message) {
            return _this._refinement(__assign({ check: function (data) { return data >= 0; }, code: ZodError_1.ZodErrorCode.too_small, minimum: 0, type: 'number', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        return _this;
    }
    ZodNumber.create = function () {
        return new ZodNumber({
            t: z.ZodTypes.number,
        });
    };
    return ZodNumber;
}(z.ZodType));
exports.ZodNumber = ZodNumber;
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/object.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var objectUtil_1 = __webpack_require__(/*! ../helpers/objectUtil */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/objectUtil.js");
var isScalar_1 = __webpack_require__(/*! ../isScalar */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/isScalar.js");
var AugmentFactory = function (def) { return function (augmentation) {
    return new ZodObject(__assign({}, def, { shape: function () { return (__assign({}, def.shape(), augmentation)); } }));
}; };
var objectDefToJson = function (def) { return ({
    t: def.t,
    shape: Object.assign({}, Object.keys(def.shape()).map(function (k) {
        var _a;
        return (_a = {},
            _a[k] = def.shape()[k].toJSON(),
            _a);
    })),
}); };
var ZodObject = /** @class */ (function (_super) {
    __extends(ZodObject, _super);
    function ZodObject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return objectDefToJson(_this._def); };
        _this.nonstrict = function () {
            return new ZodObject({
                shape: _this._def.shape,
                t: z.ZodTypes.object,
                params: __assign({}, _this._params, { strict: false }),
            });
        };
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.augment = AugmentFactory(_this._def);
        _this.extend = AugmentFactory(_this._def);
        /**
         * Prior to zod@1.0.12 there was a bug in the
         * inferred type of merged objects. Please
         * upgrade if you are experiencing issues.
         */
        _this.merge = objectUtil_1.objectUtil.mergeObjects(_this);
        _this.pick = function (mask) {
            var shape = {};
            Object.keys(mask).map(function (key) {
                shape[key] = _this.shape[key];
            });
            return new ZodObject(__assign({}, _this._def, { shape: function () { return shape; } }));
        };
        _this.omit = function (mask) {
            var shape = {};
            Object.keys(_this.shape).map(function (key) {
                if (Object.keys(mask).indexOf(key) === -1) {
                    shape[key] = _this.shape[key];
                }
            });
            return new ZodObject(__assign({}, _this._def, { shape: function () { return shape; } }));
        };
        _this.partial = function () {
            var newShape = {};
            for (var key in _this.shape) {
                newShape[key] = _this.shape[key].optional();
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        _this.primitives = function () {
            var newShape = {};
            for (var key in _this.shape) {
                if (isScalar_1.isScalar(_this.shape[key])) {
                    newShape[key] = _this.shape[key];
                }
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        _this.nonprimitives = function () {
            var newShape = {};
            for (var key in _this.shape) {
                if (!isScalar_1.isScalar(_this.shape[key])) {
                    newShape[key] = _this.shape[key];
                }
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        _this.deepPartial = function () {
            var newShape = {};
            for (var key in _this.shape) {
                var fieldSchema = _this.shape[key];
                if (fieldSchema instanceof ZodObject) {
                    newShape[key] = fieldSchema.deepPartial().optional();
                }
                else {
                    newShape[key] = _this.shape[key].optional();
                }
            }
            return new ZodObject(__assign({}, _this._def, { shape: function () { return newShape; } }));
        };
        return _this;
    }
    Object.defineProperty(ZodObject.prototype, "shape", {
        get: function () {
            return this._def.shape();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZodObject.prototype, "params", {
        get: function () {
            return this._def.params;
        },
        enumerable: true,
        configurable: true
    });
    ZodObject.create = function (shape) {
        return new ZodObject({
            t: z.ZodTypes.object,
            shape: function () { return shape; },
            params: {
                strict: true,
            },
        });
    };
    ZodObject.lazycreate = function (shape) {
        return new ZodObject({
            t: z.ZodTypes.object,
            shape: shape,
            params: {
                strict: true,
            },
        });
    };
    return ZodObject;
}(z.ZodType));
exports.ZodObject = ZodObject;
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/promise.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/promise.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodPromise = /** @class */ (function (_super) {
    __extends(ZodPromise, _super);
    function ZodPromise() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () {
            return {
                t: _this._def.t,
                type: _this._def.type.toJSON(),
            };
        };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodPromise.create = function (schema) {
        return new ZodPromise({
            t: z.ZodTypes.promise,
            type: schema,
        });
    };
    return ZodPromise;
}(z.ZodType));
exports.ZodPromise = ZodPromise;
//# sourceMappingURL=promise.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/record.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/record.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodRecord = /** @class */ (function (_super) {
    __extends(ZodRecord, _super);
    function ZodRecord() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return ({
            t: _this._def.t,
            valueType: _this._def.valueType.toJSON(),
        }); };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodRecord.create = function (valueType) {
        return new ZodRecord({
            t: z.ZodTypes.record,
            valueType: valueType,
        });
    };
    return ZodRecord;
}(z.ZodType));
exports.ZodRecord = ZodRecord;
//# sourceMappingURL=record.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/string.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/string.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
// import { ZodUndefined } from './undefined';
// import { ZodNull } from './null';
// import { ZodUnion } from './union';
var ZodError_1 = __webpack_require__(/*! ../ZodError */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/ZodError.js");
var errorUtil_1 = __webpack_require__(/*! ../helpers/errorUtil */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/helpers/errorUtil.js");
var emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
var uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/i;
var ZodString = /** @class */ (function (_super) {
    __extends(ZodString, _super);
    function ZodString() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        _this.min = function (minLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length >= minLength; }, code: ZodError_1.ZodErrorCode.too_small, minimum: minLength, type: 'string', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.max = function (maxLength, message) {
            return _this._refinement(__assign({ check: function (data) { return data.length <= maxLength; }, code: ZodError_1.ZodErrorCode.too_big, maximum: maxLength, type: 'string', inclusive: true }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this._regex = function (regex, validation, message) {
            return _this._refinement(__assign({ validation: validation, code: ZodError_1.ZodErrorCode.invalid_string, check: function (data) { return regex.test(data); } }, errorUtil_1.errorUtil.errToObj(message)));
        };
        _this.email = function (message) {
            return _this._regex(emailRegex, 'email', message);
        };
        _this.url = function (message) {
            return _this._refinement(__assign({ check: function (data) {
                    try {
                        new URL(data);
                        return true;
                    }
                    catch (_a) {
                        return false;
                    }
                }, code: ZodError_1.ZodErrorCode.invalid_string, validation: 'url' }, errorUtil_1.errorUtil.errToObj(message)));
        };
        // url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
        _this.uuid = function (message) {
            return _this._regex(uuidRegex, 'uuid', message);
        };
        _this.regex = function (regexp, message) {
            return _this._regex(regexp, 'regex', message);
        };
        _this.nonempty = function (message) {
            return _this.min(1, errorUtil_1.errorUtil.errToObj(message));
        };
        return _this;
    }
    ZodString.prototype.length = function (len, message) {
        return this.min(len, message).max(len, message);
    };
    ZodString.create = function () {
        return new ZodString({
            t: z.ZodTypes.string,
            validation: {},
        });
    };
    return ZodString;
}(z.ZodType));
exports.ZodString = ZodString;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/tuple.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodTuple = /** @class */ (function (_super) {
    __extends(ZodTuple, _super);
    function ZodTuple() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return ({
            t: _this._def.t,
            items: _this._def.items.map(function (item) { return item.toJSON(); }),
        }); };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodTuple.create = function (schemas) {
        return new ZodTuple({
            t: z.ZodTypes.tuple,
            items: schemas,
        });
    };
    return ZodTuple;
}(z.ZodType));
exports.ZodTuple = ZodTuple;
//# sourceMappingURL=tuple.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/undefined.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/undefined.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodUndefined = /** @class */ (function (_super) {
    __extends(ZodUndefined, _super);
    function ZodUndefined() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
    // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
    ZodUndefined.create = function () {
        return new ZodUndefined({
            t: z.ZodTypes.undefined,
        });
    };
    return ZodUndefined;
}(z.ZodType));
exports.ZodUndefined = ZodUndefined;
//# sourceMappingURL=undefined.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/union.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/union.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodUnion = /** @class */ (function (_super) {
    __extends(ZodUnion, _super);
    function ZodUnion() {
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return ({
            t: _this._def.t,
            options: _this._def.options.map(function (x) { return x.toJSON(); }),
        }); };
        return _this;
    }
    // distribute = <F extends (arg: T[number]) => z.ZodTypeAny>(f: F): ZodUnion<{ [k in keyof T]: ReturnType<F> }> => {
    //   return ZodUnion.create(this._def.options.map(f) as any);
    // };
    ZodUnion.create = function (types) {
        return new ZodUnion({
            t: z.ZodTypes.union,
            options: types,
        });
    };
    return ZodUnion;
}(z.ZodType));
exports.ZodUnion = ZodUnion;
//# sourceMappingURL=union.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/unknown.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodUnknown = /** @class */ (function (_super) {
    __extends(ZodUnknown, _super);
    function ZodUnknown() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodUnknown.create = function () {
        return new ZodUnknown({
            t: z.ZodTypes.unknown,
        });
    };
    return ZodUnknown;
}(z.ZodType));
exports.ZodUnknown = ZodUnknown;
//# sourceMappingURL=unknown.js.map

/***/ }),

/***/ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/void.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/void.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var z = __importStar(__webpack_require__(/*! ./base */ "./node_modules/@proton/wrap-constants/node_modules/zod/lib/src/types/base.js"));
var ZodVoid = /** @class */ (function (_super) {
    __extends(ZodVoid, _super);
    function ZodVoid() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
        // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
        _this.toJSON = function () { return _this._def; };
        return _this;
    }
    ZodVoid.create = function () {
        return new ZodVoid({
            t: z.ZodTypes.void,
        });
    };
    return ZodVoid;
}(z.ZodType));
exports.ZodVoid = ZodVoid;
//# sourceMappingURL=void.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pkg = __webpack_require__(/*! ./../../package.json */ "./node_modules/axios/package.json");

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./resources/js/components/Transactions/ExchangeAction.js":
/*!****************************************************************!*\
  !*** ./resources/js/components/Transactions/ExchangeAction.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/index.js");
/* harmony import */ var _store_auth_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/auth-context */ "./resources/js/store/auth-context.js");
/* harmony import */ var _store_wallet_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../store/wallet-context */ "./resources/js/store/wallet-context.js");
/* harmony import */ var _ui_Modal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/Modal */ "./resources/js/components/ui/Modal.js");
/* harmony import */ var _ui_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ui/Button */ "./resources/js/components/ui/Button.js");
/* harmony import */ var _sdk_easyescrowSDK__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../sdk/easyescrowSDK */ "./resources/js/sdk/easyescrowSDK.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }












var ExchangeAction = function ExchangeAction(props) {
  var _useParams = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_7__.useParams)(),
      escrowId = _useParams.escrowId,
      user1Acc = _useParams.user1Acc;

  var ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_store_auth_context__WEBPACK_IMPORTED_MODULE_1__["default"]);
  var walletCtx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_store_wallet_context__WEBPACK_IMPORTED_MODULE_2__["default"]);

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState2 = _slicedToArray(_useState, 2),
      confirmationPopup = _useState2[0],
      setConfirmationPopup = _useState2[1];

  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(),
      _useState4 = _slicedToArray(_useState3, 2),
      responseType = _useState4[0],
      setResponseType = _useState4[1];

  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      _useState6 = _slicedToArray(_useState5, 2),
      loading = _useState6[0],
      setLoading = _useState6[1];

  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]),
      _useState8 = _slicedToArray(_useState7, 2),
      myEscrows = _useState8[0],
      setMyEscrows = _useState8[1];

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var escrows, myEscrowss;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!ctx.isLoggedIn) {
              _context.next = 6;
              break;
            }

            _context.next = 3;
            return (0,_sdk_easyescrowSDK__WEBPACK_IMPORTED_MODULE_5__.fetchEscrows)(user1Acc);

          case 3:
            escrows = _context.sent;
            myEscrowss = escrows.filter(function (escrow) {
              return escrow.id.toString() == escrowId && escrow.to.toString() == ctx.walletName;
            });

            if (myEscrowss.length > 0) {
              setMyEscrows(_toConsumableArray(myEscrowss));
            }

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })), [myEscrows.length, ctx.isLoggedIn]);

  var handleAccept = function handleAccept(response_type) {
    setConfirmationPopup(true);
    setResponseType(response_type);
  };

  var handleExchangeAction = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(response_type) {
      var authorization, typeId;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              setLoading(true);
              authorization = [{
                actor: ctx.auth.actor,
                permission: ctx.auth.permission
              }];
              typeId = 1;

              if (!(response_type == "completed")) {
                _context2.next = 9;
                break;
              }

              _context2.next = 6;
              return (0,_sdk_easyescrowSDK__WEBPACK_IMPORTED_MODULE_5__.fillEscrow)(myEscrows[0].id, typeId, ctx.walletName, myEscrows[0].toTokens[0], authorization, walletCtx.session);

            case 6:
              setMyEscrows([]); //success toast

              _context2.next = 12;
              break;

            case 9:
              _context2.next = 11;
              return (0,_sdk_easyescrowSDK__WEBPACK_IMPORTED_MODULE_5__.cancelEscrow)(myEscrows[0].id, ctx.walletName, authorization, walletCtx.session);

            case 11:
              setMyEscrows([]); //cancel toast

            case 12:
              setConfirmationPopup(false);
              setLoading(false); // fetch(`${process.env.MIX_API_URL}/user/escrow_response`, {
              //     method: "POST",
              //     body: JSON.stringify({
              //         type_id: props.type_id,
              //         escrow_id: props.escrow_id,
              //         status: response_type,
              //     }),
              //     headers: {
              //         Authorization: "Bearer " + ctx.token,
              //         "Content-Type": "application/json",
              //     },
              // })
              //     .then((response) => {
              //         if (response.ok) return response.json();
              //         throw response.status + ": " + response.statusText;
              //     })
              //     .then((data) => {
              //         //console.log(data);
              //         if (data.valid) {
              //             props.reloadTransactions(props.escrow_id);
              //             setConfirmationPopup(false);
              //             //console.log(data.message);
              //         } else {
              //             console.log(data.message);
              //         }
              //         setLoading(false);
              //     })
              //     .catch((error) => {
              //         console.log(error);
              //     });

            case 14:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function handleExchangeAction(_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("main", {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: "container banner-inner",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h2", {
        children: "Transaction Details"
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: "container block",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
        className: "transactions",
        children: [ctx.isLoggedIn && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
          children: [myEscrows.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("p", {
              className: "transaction-detail",
              children: [myEscrows[0].from, " wants to exchange", " ", myEscrows[0].fromTokens[0].quantity, " ", "with ", myEscrows[0].toTokens[0].quantity, " ", "with you(", ctx.walletName, ")!"]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
              className: "transaction-actions",
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("p", {
                children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_ui_Button__WEBPACK_IMPORTED_MODULE_4__["default"], {
                  label: "Accept",
                  className: "btn-accept",
                  onClick: function onClick() {
                    return handleAccept("completed");
                  }
                })
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("p", {
                children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_ui_Button__WEBPACK_IMPORTED_MODULE_4__["default"], {
                  label: "Cancel",
                  className: "btn btn-cancel",
                  onClick: function onClick() {
                    return handleAccept("cancelled");
                  }
                })
              })]
            }), confirmationPopup && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(_ui_Modal__WEBPACK_IMPORTED_MODULE_3__["default"], {
              hidePopup: function hidePopup() {
                return setConfirmationPopup(false);
              },
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h3", {
                className: "modal-header",
                children: "Crypto Exchange"
              }), responseType === "completed" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("p", {
                children: "If you agree to this exchange, please ACCEPT"
              }), responseType === "cancelled" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("p", {
                children: "If you do NOT agree, hit this button to CANCEL"
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("p", {
                children: "Note: This action can not be undone"
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
                className: "form-row",
                children: [responseType === "completed" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_ui_Button__WEBPACK_IMPORTED_MODULE_4__["default"], {
                  label: "Accept",
                  className: "btn-accept",
                  onClick: function onClick() {
                    return handleExchangeAction("completed");
                  },
                  loading: loading
                }), responseType === "cancelled" && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_ui_Button__WEBPACK_IMPORTED_MODULE_4__["default"], {
                  label: "Cancel",
                  className: "btn-cancel",
                  onClick: function onClick() {
                    return handleExchangeAction("cancelled");
                  },
                  loading: loading
                })]
              })]
            })]
          }), myEscrows.length == 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
            className: "transaction-empty",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("span", {
              children: "There is no escrow for this request"
            })
          })]
        }), !ctx.isLoggedIn && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
          className: "transaction-empty",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("span", {
            children: ["You must login to continue. (", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("a", {
              href: "https://www.proton.org/wallet",
              target: "_blank",
              children: "Download Proton Wallet"
            }), ")"]
          })
        })]
      })
    })]
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExchangeAction);

/***/ }),

/***/ "./resources/js/sdk/easyescrowSDK.js":
/*!*******************************************!*\
  !*** ./resources/js/sdk/easyescrowSDK.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cancelEscrow": () => (/* binding */ cancelEscrow),
/* harmony export */   "fetchEscrowAll": () => (/* binding */ fetchEscrowAll),
/* harmony export */   "fetchEscrows": () => (/* binding */ fetchEscrows),
/* harmony export */   "fillEscrow": () => (/* binding */ fillEscrow),
/* harmony export */   "negoPurchase": () => (/* binding */ negoPurchase),
/* harmony export */   "startEscrow": () => (/* binding */ startEscrow),
/* harmony export */   "startPurchase": () => (/* binding */ startPurchase)
/* harmony export */ });
/* harmony import */ var _proton_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @proton/api */ "./node_modules/@proton/api/dist/api.esm.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants_networks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/networks.js */ "./resources/js/constants/networks.js");
/* harmony import */ var _protonAPI_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./protonAPI.js */ "./resources/js/sdk/protonAPI.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

//Use API to save transaction details




var api = new _proton_api__WEBPACK_IMPORTED_MODULE_0__.ApiClass(_constants_networks_js__WEBPACK_IMPORTED_MODULE_2__.current_network.chain);
var contract = "easyescrow2";
function fetchEscrowAll() {
  return _fetchEscrowAll.apply(this, arguments);
}

function _fetchEscrowAll() {
  _fetchEscrowAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var _yield$api$rpc$get_ta, rows;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return api.rpc.get_table_rows({
              code: contract,
              scope: contract,
              table: "escrows",
              index_position: 2,
              key_type: "i64",
              limit: -1
            });

          case 2:
            _yield$api$rpc$get_ta = _context3.sent;
            rows = _yield$api$rpc$get_ta.rows;
            return _context3.abrupt("return", rows);

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _fetchEscrowAll.apply(this, arguments);
}

function fetchEscrows(_x) {
  return _fetchEscrows.apply(this, arguments);
}

function _fetchEscrows() {
  _fetchEscrows = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(accountName) {
    var _yield$api$rpc$get_ta2, rows;

    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return api.rpc.get_table_rows({
              code: contract,
              scope: contract,
              table: "escrows",
              index_position: 2,
              key_type: "i64",
              lower_bound: accountName,
              upper_bound: accountName,
              limit: -1
            });

          case 2:
            _yield$api$rpc$get_ta2 = _context4.sent;
            rows = _yield$api$rpc$get_ta2.rows;
            return _context4.abrupt("return", rows);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _fetchEscrows.apply(this, arguments);
}

function startEscrow(_x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12) {
  return _startEscrow.apply(this, arguments);
}

function _startEscrow() {
  _startEscrow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(typeId, from, to, fromToken, toToken, fromAmount, toAmount, deliverType, expiry, authorization, session) {
    var amountIn, fromQuantity, actions, amountOut, toQuantity, memo;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            amountIn = parseFloat(fromAmount).toFixed(Number(fromToken.decimals)).toString();
            fromQuantity = amountIn + " " + fromToken.currency;
            actions = [];

            if (typeId == 1) {
              amountOut = parseFloat(toAmount).toFixed(Number(toToken.decimals)).toString();
              toQuantity = amountOut + " " + toToken.currency;
              actions = [{
                account: fromToken.contract,
                name: "transfer",
                data: {
                  from: from,
                  to: contract,
                  quantity: fromQuantity,
                  memo: "User1 deposit for escrow"
                },
                authorization: authorization
              }, {
                account: contract,
                name: "startescrow",
                data: {
                  typeId: typeId,
                  from: from,
                  to: to,
                  fromTokens: [{
                    contract: fromToken.contract,
                    quantity: fromQuantity
                  }],
                  fromNfts: [],
                  toTokens: [{
                    contract: toToken.contract,
                    quantity: toQuantity
                  }],
                  toNfts: [],
                  deliverType: deliverType,
                  expiry: expiry
                },
                authorization: authorization
              }];
            } else if (typeId == 2) {
              actions = [{
                account: fromToken.contract,
                name: "transfer",
                data: {
                  from: from,
                  to: contract,
                  quantity: fromQuantity,
                  memo: "User1 deposit for a gift"
                },
                authorization: authorization
              }, {
                account: contract,
                name: "startescrow",
                data: {
                  typeId: typeId,
                  from: from,
                  to: to,
                  fromTokens: [{
                    contract: fromToken.contract,
                    quantity: fromQuantity
                  }],
                  fromNfts: [],
                  toTokens: [],
                  toNfts: [],
                  deliverType: deliverType,
                  expiry: Math.floor(expiry / 1000)
                },
                authorization: authorization
              }];
            } else if (typeId == 3 || typeId == 4) {
              memo = "User1 deposited for Purchase Item!";

              if (typeId == 4) {
                memo = "User1 deposited for Purchase Service!";
              } //in this case only store to proton db. not send coin


              actions = [{
                account: contract,
                name: "startescrow",
                data: {
                  typeId: typeId,
                  from: from,
                  to: to,
                  fromTokens: [{
                    contract: fromToken.contract,
                    quantity: fromQuantity
                  }],
                  fromNfts: [],
                  toTokens: [],
                  toNfts: [],
                  deliverType: deliverType,
                  expiry: expiry
                },
                authorization: authorization
              }];
            }

            _context5.next = 6;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 6:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _startEscrow.apply(this, arguments);
}

function fillEscrow(_x13, _x14, _x15, _x16, _x17, _x18) {
  return _fillEscrow.apply(this, arguments);
}

function _fillEscrow() {
  _fillEscrow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(escrowId, typeId, actor, toToken, authorization, session) {
    var actions, contractauth, result;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            actions = [];

            if (!(typeId == 1)) {
              _context6.next = 5;
              break;
            }

            actions = [{
              account: toToken.contract,
              name: "transfer",
              data: {
                from: actor,
                to: contract,
                quantity: toToken.quantity,
                memo: "User2 deposit for escrow"
              },
              authorization: authorization
            }, {
              account: contract,
              name: "fillescrow",
              data: {
                actor: actor,
                id: escrowId.toString()
              },
              authorization: authorization
            }];
            _context6.next = 22;
            break;

          case 5:
            if (!(typeId == 2)) {
              _context6.next = 21;
              break;
            }

            contractauth = [{
              actor: contract,
              permission: "active"
            }];
            actions = [{
              account: contract,
              name: "fillescrow",
              data: {
                actor: actor,
                id: escrowId.toString()
              },
              authorization: contractauth
            }];
            _context6.prev = 8;
            _context6.next = 11;
            return (0,_protonAPI_js__WEBPACK_IMPORTED_MODULE_3__.transact)(actions);

          case 11:
            result = _context6.sent;
            console.log("result", result);
            return _context6.abrupt("return", result);

          case 16:
            _context6.prev = 16;
            _context6.t0 = _context6["catch"](8);
            console.error("error here??", _context6.t0);

          case 19:
            _context6.next = 22;
            break;

          case 21:
            if (typeId == 3 || typeId == 4) {
              actions = [{
                account: contract,
                name: "fillescrow",
                data: {
                  actor: actor,
                  id: escrowId.toString()
                },
                authorization: authorization
              }];
            }

          case 22:
            if (!(typeId != 2)) {
              _context6.next = 25;
              break;
            }

            _context6.next = 25;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 25:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[8, 16]]);
  }));
  return _fillEscrow.apply(this, arguments);
}

function cancelEscrow(_x19, _x20, _x21, _x22) {
  return _cancelEscrow.apply(this, arguments);
}

function _cancelEscrow() {
  _cancelEscrow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(escrowId, actor, authorization, session) {
    var actions;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            actions = [{
              account: contract,
              name: "cancelescrow",
              data: {
                actor: actor,
                id: escrowId.toString()
              },
              authorization: authorization
            }];
            _context7.next = 3;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _cancelEscrow.apply(this, arguments);
}

function startPurchase(_x23, _x24, _x25, _x26) {
  return _startPurchase.apply(this, arguments);
}

function _startPurchase() {
  _startPurchase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(from, token, authorization, session) {
    var actions;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            actions = [{
              account: token.contract,
              name: "transfer",
              data: {
                from: from,
                to: contract,
                quantity: token.quantity,
                memo: "User2 deposit for escrow"
              },
              authorization: authorization
            }];
            _context8.next = 3;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 3:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _startPurchase.apply(this, arguments);
}

function negoPurchase(_x27, _x28, _x29, _x30, _x31, _x32, _x33, _x34, _x35, _x36, _x37, _x38) {
  return _negoPurchase.apply(this, arguments);
}

function _negoPurchase() {
  _negoPurchase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(escrowId, typeId, from, to, fromToken, toToken, fromAmount, toAmount, deliverType, expiry, authorization, session) {
    var amountIn, fromQuantity, actions;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            amountIn = parseFloat(fromAmount).toFixed(Number(fromToken.decimals)).toString();
            fromQuantity = amountIn + " " + fromToken.currency;
            actions = [{
              account: contract,
              name: "negopurchase",
              data: {
                escrowId: escrowId,
                typeId: typeId,
                from: from,
                to: to,
                fromTokens: [{
                  contract: fromToken.contract,
                  quantity: fromQuantity
                }],
                fromNfts: [],
                toTokens: [],
                toNfts: [],
                deliverType: deliverType,
                expiry: expiry
              },
              authorization: authorization
            }];
            _context9.next = 5;
            return session.transact({
              transaction: {
                actions: actions
              }
            });

          case 5:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _negoPurchase.apply(this, arguments);
}

var tablerows = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var protonrows, _iterator, _step, _loop;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return fetchEscrowAll();

          case 2:
            protonrows = _context2.sent;
            console.log(protonrows);

            if (Object.keys(protonrows).length != 0) {
              _iterator = _createForOfIteratorHelper(protonrows);

              try {
                _loop = function _loop() {
                  var obj = _step.value;
                  var newdatetenminutes = new Date();
                  var difference = newdatetenminutes.getMinutes() - 10;
                  newdatetenminutes.setMinutes(difference);
                  var timestamp = obj.expiry * 1000;
                  var date = new Date(timestamp);

                  if (date > newdatetenminutes && date <= new Date()) {
                    var giftresponsecall = /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                        var giftresponse, res, datas;
                        return _regeneratorRuntime().wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _context.next = 2;
                                return fillEscrow(obj.id, 2, obj.from, null, null, null);

                              case 2:
                                giftresponse = _context.sent;

                                if (giftresponse) {
                                  res = {
                                    escrow_id: obj.id,
                                    type_id: 2
                                  };
                                  datas = JSON.stringify(res);
                                  axios__WEBPACK_IMPORTED_MODULE_1___default()({
                                    method: "post",
                                    url: "https://easyescrow.io/api/user/gift-update-status",
                                    data: datas,
                                    config: {
                                      headers: {
                                        "Content-Type": "application/json"
                                      }
                                    }
                                  }).then(function (response) {
                                    console.log(response.data.response);
                                  })["catch"](function (response) {
                                    console.log(response);
                                  });
                                } else {
                                  console.log(giftresponse);
                                }

                              case 4:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function giftresponsecall() {
                        return _ref2.apply(this, arguments);
                      };
                    }();

                    console.log("current date", new Date());
                    console.log("calling fill gift function");
                    console.log("running escrow", obj.id);
                    console.log("running escrow date", date);
                    giftresponsecall();
                  } else {
                    console.log("skip escrow", obj.id);
                    console.log("skip escrow date", date);
                    console.log("current date", new Date());
                  }
                };

                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  _loop();
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            } else {
              console.log("no rows found");
            }

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function tablerows() {
    return _ref.apply(this, arguments);
  };
}();

tablerows(); // const history = await api.getActionsFromHyperion(ctx.auth.actor, {
//     limit: 10,
//     skip: 0,
//     sort: "desc",
//     filter: contract*",
// });
// console.log("History", history);

/***/ }),

/***/ "./resources/js/sdk/protonAPI.js":
/*!***************************************!*\
  !*** ./resources/js/sdk/protonAPI.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "api": () => (/* binding */ api),
/* harmony export */   "rpc": () => (/* binding */ rpc),
/* harmony export */   "transact": () => (/* binding */ transact)
/* harmony export */ });
/* harmony import */ var _proton_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @proton/js */ "./node_modules/@proton/js/dist/index.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants_networks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/networks */ "./resources/js/constants/networks.js");



var rpc = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpc([_constants_networks__WEBPACK_IMPORTED_MODULE_2__.current_network.endpoint], {
  fetch: (node_fetch__WEBPACK_IMPORTED_MODULE_1___default())
});
var api = new _proton_js__WEBPACK_IMPORTED_MODULE_0__.Api({
  rpc: rpc,
  signatureProvider: new _proton_js__WEBPACK_IMPORTED_MODULE_0__.JsSignatureProvider(["PVT_K1_2Sg3jdbgAfc8fJct2MVHpUjRWJvtDhitxD5p59warXSQrXXWA3"])
});
function transact(actions) {
  console.log("come here, then why?");
  api.transact({
    actions: actions
  }, {
    blocksBehind: 300,
    expireSeconds: 3000
  });
}

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/***/ ((module) => {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  // Node.js and other environments that support module.exports.
  } else {}
})(this);


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/dayjs/dayjs.min.js":
/*!*****************************************!*\
  !*** ./node_modules/dayjs/dayjs.min.js ***!
  \*****************************************/
/***/ (function(module) {

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},v="en",D={};D[v]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return v;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(v=i),i||!r&&v},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var v=this.$locale().weekStart||0,D=(y<v?y+7:y)-v;return $(r?m-D:m+(6-D),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,v=O.m(this,M);return v=(l={},l[c]=v/12,l[f]=v,l[h]=v/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?v:O.a(v)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[v],w.Ls=D,w.p={},w}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/advancedFormat.js":
/*!*****************************************************!*\
  !*** ./node_modules/dayjs/plugin/advancedFormat.js ***!
  \*****************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(function(){"use strict";return function(e,t,r){var n=t.prototype,s=n.format;r.en.ordinal=function(e){var t=["th","st","nd","rd"],r=e%100;return"["+e+(t[(r-20)%10]||t[r]||t[0])+"]"},n.format=function(e){var t=this,r=this.$locale();if(!this.isValid())return s.bind(this)(e);var n=this.$utils(),a=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return r.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return r.ordinal(t.week(),"W");case"w":case"ww":return n.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return n.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return n.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return"["+t.offsetName()+"]";case"zzz":return"["+t.offsetName("long")+"]";default:return e}}));return s.bind(this)(a)}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/relativeTime.js":
/*!***************************************************!*\
  !*** ./node_modules/dayjs/plugin/relativeTime.js ***!
  \***************************************************/
/***/ (function(module) {

!function(r,e){ true?module.exports=e():0}(this,(function(){"use strict";return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return"function"==typeof M?M(a):M.replace("%s",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/timezone.js":
/*!***********************************************!*\
  !*** ./node_modules/dayjs/plugin/timezone.js ***!
  \***********************************************/
/***/ (function(module) {

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||"short",o=t+"|"+i,r=e[o];return r||(r=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:t,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],l=24===d?0:d,v=r[0]+"-"+r[1]+"-"+r[2]+" "+l+":"+r[4]+":"+r[5]+":000",h=+e;return(o.utc(v).valueOf()-(h-=h%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n=this.utcOffset(),i=this.toDate(),a=i.toLocaleString("en-US",{timeZone:t}),u=Math.round((i-new Date(a))/1e3/60),f=o(a).$set("millisecond",this.$ms).utcOffset(15*-Math.round(i.getTimezoneOffset()/15)-u,!0);if(e){var s=f.utcOffset();f=f.add(n-s,"minute")}return f.$x.$timezone=t,f},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return"timezonename"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format("YYYY-MM-DD HH:mm:ss:SSS"));return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if("string"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/utc.js":
/*!******************************************!*\
  !*** ./node_modules/dayjs/plugin/utc.js ***!
  \******************************************/
/***/ (function(module) {

!function(t,i){ true?module.exports=i():0}(this,(function(){"use strict";var t="minute",i=/[+-]\d\d(?::?\d\d)?/g,e=/([+-]|\d\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t)};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else r.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if("string"==typeof s&&(s=function(t){void 0===t&&(t="");var s=t.match(i);if(!s)return null;var f=(""+s[0]).match(e)||["-",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:"+"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return"s"===t&&this.$offset?n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/g, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/MapLike.js":
/*!*************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/MapLike.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class MapLike {
    constructor() {
        this._map = {};
    }
    get size() {
        return this.keys().length;
    }
    clear() {
        for (const key in this._map) {
            delete this._map[key];
        }
    }
    delete(key) {
        if (this.has(key)) {
            return delete this._map[key];
        }
        return false;
    }
    get(key) {
        return this._map[key];
    }
    has(key) {
        return this._map[key] !== undefined;
    }
    keys() {
        return Object.keys(this._map);
    }
    set(key, value) {
        this._map[key] = value;
        return this;
    }
    values() {
        const values = [];
        for (const key in this._map) {
            values.push(this._map[key]);
        }
        return values;
    }
}
exports["default"] = MapLike;
//# sourceMappingURL=MapLike.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/MessageHandler.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/MessageHandler.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/jsonrpc2-ws/lib/common.js");
const EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
class MessageHandler extends EventEmitter {
    constructor(options) {
        super();
        this.options = options;
        this.methods = new Map();
    }
    async handleMessage(socket, data) {
        const calls = [];
        const responses = [];
        let isBinary = false;
        let isArray = false;
        if (data instanceof ArrayBuffer) {
            isBinary = true;
            data = Buffer.from(data).toString();
        }
        else if (data instanceof Buffer) {
            isBinary = true;
            data = data.toString();
        }
        else if (Array.isArray(data)) {
            isBinary = true;
            data = "[" + data.map(buf => buf.toString()).join(",") + "]";
        }
        try {
            const obj = JSON.parse(data);
            if (Array.isArray(obj)) {
                isArray = true;
                if (obj.length === 0) {
                    const res = {
                        jsonrpc: "2.0",
                        error: common_1.createError(-32600 /* InvalidRequest */, null, "Empty Array"),
                        id: null
                    };
                    socket.send(JSON.stringify(res), isBinary);
                    return;
                }
                calls.push(...obj);
            }
            else {
                calls.push(obj);
            }
        }
        catch (e) {
            const res = {
                jsonrpc: "2.0",
                error: common_1.createError(-32700 /* ParseError */, null, "Invalid JSON"),
                id: null
            };
            socket.send(JSON.stringify(res), isBinary);
            return;
        }
        for (const call of calls) {
            const res = await this._processCall(socket, call);
            if (res) {
                responses.push(res);
            }
        }
        if (responses.length === 0) {
            return;
        }
        socket.send(JSON.stringify(isArray ? responses : responses[0]), isBinary);
    }
    async _processCall(socket, call) {
        const reqId = call.id;
        const res = {
            jsonrpc: "2.0",
            id: reqId === undefined ? null : reqId
        };
        if (typeof call !== "object") {
            res.error = common_1.createError(-32600 /* InvalidRequest */);
            return res;
        }
        if (call.jsonrpc !== "2.0" && (this.options.jsonrpcVersionCheck === 0 /* STRICT */ ||
            (this.options.jsonrpcVersionCheck === 1 /* LOOSE */ && call.jsonrpc !== undefined))) {
            res.error = common_1.createError(-32600 /* InvalidRequest */, null, "Invalid JSON-RPC Version");
            return res;
        }
        if (common_1.isResponse(call)) {
            this.emit("response", socket, call);
            if (call.id !== null) {
                this.emit("method_response", socket, call);
                return;
            }
            if (!call.error) {
                res.error = common_1.createError(-32600 /* InvalidRequest */);
                return res;
            }
            this.emit("error_response", socket, call);
            if (call.error.code === -32700 /* ParseError */ || call.error.code === -32600 /* InvalidRequest */) {
                return;
            }
            this.emit("notification_error", socket, call.error);
            return;
        }
        if (!call.method) {
            res.error = common_1.createError(-32601 /* MethodNotFound */, null, "Method not specified");
            return res;
        }
        if (typeof call.method !== "string") {
            res.error = common_1.createError(-32600 /* InvalidRequest */, null, "Invalid type of method name");
            return res;
        }
        if ("params" in call && (typeof call.params !== "object" || call.params === null)) {
            res.error = common_1.createError(-32600 /* InvalidRequest */);
            return res;
        }
        if (this.methods.has(call.method) === false) {
            res.error = common_1.createError(-32601 /* MethodNotFound */);
            return res;
        }
        try {
            res.result = await this.methods.get(call.method)(socket, call.params) || null;
            if (reqId === undefined) {
                return;
            }
            return res;
        }
        catch (e) {
            if (reqId === undefined) {
                return;
            }
            if (e instanceof Error) {
                res.error = common_1.createError(-32000 /* ServerError */, e.name, e.message);
            }
            else {
                res.error = e;
            }
            return res;
        }
    }
}
exports["default"] = MessageHandler;
//# sourceMappingURL=MessageHandler.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/client.js":
/*!************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/client.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigDefaults = void 0;
const WebSocket = __webpack_require__(/*! isomorphic-ws */ "./node_modules/isomorphic-ws/browser.js");
const Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");
const EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/jsonrpc2-ws/lib/common.js");
const MessageHandler_1 = __webpack_require__(/*! ./MessageHandler */ "./node_modules/jsonrpc2-ws/lib/MessageHandler.js");
exports.ConfigDefaults = Object.freeze({
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    reconnectionJitter: 0.5,
    methodCallTimeout: 20000,
    autoConnect: true,
    bufferSendingMessages: true,
    query: {},
    protocols: ""
});
/**
 * JSON-RPC 2.0 Client
 */
class Client extends EventEmitter {
    /**
     * Create an instance
     * @param uri The URI to connect.
     * @param options Options
     */
    constructor(uri, options = {}) {
        super();
        this.uri = uri;
        this.sendingMessageBuffer = [];
        this._reconnecting = false;
        this._responseHandlers = new Map();
        this._skipReconnection = false;
        this._currentRequestId = 0;
        this.config = {
            ...exports.ConfigDefaults,
            ...options
        };
        this._backoff = new Backoff({
            min: this.config.reconnectionDelay,
            max: this.config.reconnectionDelayMax,
            jitter: this.config.reconnectionJitter
        });
        this._messageHandler = new MessageHandler_1.default(this.config);
        this._messageHandler.on("method_response", (socket, response) => this._handleMethodResponse(response));
        this._messageHandler.on("error_response", (socket, response) => this.emit("error_response", response));
        this._messageHandler.on("notification_error", (socket, error) => this.emit("notification_error", error));
        if (this.config.autoConnect) {
            this.connect().catch(() => void 0);
        }
    }
    get methods() { return this._messageHandler.methods; }
    /**
     * Connect to the server
     */
    async connect() {
        if (this._ws) {
            return;
        }
        this.emit("connecting");
        const ws = this._ws = new WebSocket(this.uri, this.config.protocols, this.config);
        if (ws.addEventListener) {
            ws.addEventListener("error", error => this.emit("error", error));
            ws.addEventListener("close", ({ code, reason }) => {
                this.emit("close");
                this.emit("disconnect", code, reason);
                this._ws = null;
            });
            ws.addEventListener("message", ({ data }) => this._messageHandler.handleMessage(this, data).catch(e => this.emit("error", e)));
        }
        else {
            ws.on("error", error => this.emit("error", error));
            ws.on("close", (code, reason) => {
                this.emit("close");
                this.emit("disconnect", code, reason);
                this._ws = null;
            });
            ws.on("message", data => this._messageHandler.handleMessage(this, data).catch(e => this.emit("error", e)));
        }
        if (this.config.reconnection) {
            this._skipReconnection = false;
            if (ws.addEventListener) {
                ws.addEventListener("close", () => this.reconnect());
            }
            else {
                ws.on("close", () => this.reconnect());
            }
        }
        await new Promise((resolve, reject) => {
            if (ws.addEventListener) {
                ws.addEventListener("open", () => {
                    ws.removeEventListener("error", reject);
                    resolve();
                }, { once: true });
                ws.addEventListener("error", reject, { once: true });
            }
            else {
                ws.once("open", () => {
                    ws.off("error", reject);
                    resolve();
                });
                ws.once("error", reject);
            }
        });
        await this._sendBufferedMessages();
        this.emit("connected");
    }
    /**
     * Disconnect the connection if it exists
     */
    async disconnect() {
        this._skipReconnection = true;
        this._reconnecting = false;
        this._backoff.reset();
        // clear method call timeout.
        for (const [timer] of this._responseHandlers) {
            clearTimeout(timer);
        }
        this._responseHandlers.clear();
        // clear reconnection timer.
        if (this._reconnectionSleepTimer) {
            clearTimeout(this._reconnectionSleepTimer);
            this._reconnectionSleepTimer = null;
        }
        const ws = this._ws;
        if (!ws) {
            return Promise.resolve();
        }
        let promise;
        if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            promise = new Promise(resolve => {
                if (ws.addEventListener) {
                    ws.addEventListener("close", () => resolve(), { once: true });
                }
                else {
                    ws.once("close", () => resolve());
                }
            });
            ws.close();
        }
        else {
            promise = Promise.resolve();
        }
        this._ws = null;
        await promise;
        if (ws.removeAllListeners) {
            // for node
            ws.removeAllListeners();
        }
        else {
            // for browser
            // not necessary at this time.
        }
    }
    send(data, binary = false) {
        if (binary && typeof data === "string") {
            data = Buffer.from(data).buffer;
        }
        if (!this.isConnected()) {
            this._bufferSendingMessage(data);
            return;
        }
        this._ws.send(data, e => e ? this._bufferSendingMessage(data) : null);
    }
    clearSendingMessageBuffer() {
        this.sendingMessageBuffer.length = 0;
    }
    notify(method, params) {
        const data = {
            jsonrpc: "2.0",
            method,
            params
        };
        this.send(JSON.stringify(data));
    }
    call(method, params = {}) {
        const id = this._currentRequestId++;
        const data = {
            jsonrpc: "2.0",
            method,
            params,
            id
        };
        this.send(JSON.stringify(data));
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this._responseHandlers.delete(id);
                reject(new Error("JSON-RPC: method call timeout"));
            }, this.config.methodCallTimeout);
            this._responseHandlers.set(id, [timeout, resolve, reject]);
        });
    }
    isConnected() {
        return this._ws !== null && this._ws.readyState === WebSocket.OPEN;
    }
    async reconnect() {
        if (this._reconnecting || this._skipReconnection) {
            return;
        }
        const backoff = this._backoff;
        if (backoff.attempts > this.config.reconnectionAttempts) {
            this.emit("reconnect_failed");
            this.disconnect();
            return;
        }
        const delay = backoff.duration();
        this._reconnecting = true;
        await new Promise(resolve => this._reconnectionSleepTimer = setTimeout(resolve, delay));
        this._reconnectionSleepTimer = null;
        if (this._skipReconnection) {
            return;
        }
        this.emit("reconnecting", backoff.attempts);
        if (this._skipReconnection) {
            return;
        }
        try {
            await this.connect();
        }
        catch (err) {
            this._reconnecting = false;
            this.reconnect();
            this.emit("reconnect_error", err);
            return;
        }
        const attempts = backoff.attempts;
        backoff.reset();
        this._reconnecting = false;
        this.emit("reconnected", attempts);
    }
    _handleMethodResponse(response) {
        if (typeof response.id === "string") {
            this.emit("unkown_response", response);
            return;
        }
        const handler = this._responseHandlers.get(response.id);
        if (!handler) {
            this.emit("unkown_response", response);
            return;
        }
        this._responseHandlers.delete(response.id);
        const [timer, resolve, reject] = handler;
        clearTimeout(timer);
        if (common_1.isSuccessResponse(response)) {
            resolve(response.result);
        }
        else {
            reject(response.error);
        }
    }
    _bufferSendingMessage(data) {
        if (this.config.bufferSendingMessages) {
            this.sendingMessageBuffer.push(data);
        }
        else {
            throw new Error("Message is rejected:  The socket is close without message buffering.");
        }
    }
    async _sendBufferedMessages() {
        const buffer = this.sendingMessageBuffer;
        const ws = this._ws;
        for (let data = buffer.shift(); data; data = buffer.shift()) {
            try {
                await new Promise((resolve, reject) => ws.send(data, e => e ? reject(e) : resolve()));
            }
            catch (e) {
                buffer.unshift(data);
                this.emit("buffer_sending_error", e);
                break;
            }
        }
    }
}
exports["default"] = Client;
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/common.js":
/*!************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/common.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createError = exports.errorCodeMap = exports.isSuccessResponse = exports.isResponse = void 0;
/**
 * Check type of call is an Reponse or not
 * @param call an Call object which will be checked.
 */
function isResponse(call) {
    return "id" in call && ("result" in call || "error" in call);
}
exports.isResponse = isResponse;
/**
 * Check type of response is SuccessResponse or not
 *
 * @param response an Response object which will be checked.
 */
function isSuccessResponse(response) {
    return "result" in response && response.id !== null;
}
exports.isSuccessResponse = isSuccessResponse;
/**
 * JSON-RPC 2.0 Error Codes
 */
exports.errorCodeMap = new Map([
    [-32700, "Parse error"],
    [-32600, "Invalid Request"],
    [-32601, "Method not found"],
    [-32602, "Invalid params"],
    [-32603, "Internal error"],
    [-32000, "Server error"]
]);
/**
 * Creates a JSON-RPC 2.0 compliant Error Object
 * @param code A Number that indicates the error type that occurred. (Integer)
 * @param data A Primitive or Structured value that contains additional information about the error.
 */
function createError(code, message, data) {
    const error = {
        code: code,
        message: message || exports.errorCodeMap.get(code) || "Server error"
    };
    if (data !== undefined) {
        error.data = data;
    }
    return error;
}
exports.createError = createError;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = exports.Server = void 0;
var server_1 = __webpack_require__(/*! ./server */ "./node_modules/jsonrpc2-ws/lib/server.js");
Object.defineProperty(exports, "Server", ({ enumerable: true, get: function () { return server_1.default; } }));
var client_1 = __webpack_require__(/*! ./client */ "./node_modules/jsonrpc2-ws/lib/client.js");
Object.defineProperty(exports, "Client", ({ enumerable: true, get: function () { return client_1.default; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/jsonrpc2-ws/lib/server.js":
/*!************************************************!*\
  !*** ./node_modules/jsonrpc2-ws/lib/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Socket = void 0;
const EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
const ws_1 = __webpack_require__(/*! ws */ "./node_modules/ws/browser.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const MessageHandler_1 = __webpack_require__(/*! ./MessageHandler */ "./node_modules/jsonrpc2-ws/lib/MessageHandler.js");
const MapLike_1 = __webpack_require__(/*! ./MapLike */ "./node_modules/jsonrpc2-ws/lib/MapLike.js");
/**
 * JSON-RPC 2.0 WebSocket Server
 */
class Server extends EventEmitter {
    /**
     * Create a instance.
     * @param options
     * @param callback callback A listener for the `listening` event (ws).
     */
    constructor(options, callback) {
        super();
        this.sockets = new Map();
        this._lastPingAt = 0;
        this.options = Object.assign({
            pingTimeout: 5000,
            pingInterval: 25000,
            open: true,
            jsonrpcVersionCheck: 0 /* STRICT */,
            uws: false
        }, options);
        this._messageHandler = new MessageHandler_1.default(this.options);
        this._messageHandler.on("error_response", (socket, response) => {
            this.emit("error_response", socket, response);
            socket.emit("error_response", response);
        });
        this._messageHandler.on("notification_error", (socket, error) => {
            this.emit("notification_error", socket, error);
            socket.emit("notification_error", error);
        });
        if (this.options.open) {
            this.open(callback);
        }
    }
    get methods() { return this._messageHandler.methods; }
    /**
     * Create
     * @param callback callback A listener for the `listening` event (ws).
     */
    open(callback) {
        const self = this;
        if (this.wss) {
            throw new Error("`ws` has already been created");
        }
        if (this.options.wsEngine) {
            this.wss = new this.options.wsEngine(this.options.wss, callback);
        }
        else {
            this.wss = new ws_1.Server(this.options.wss, callback);
        }
        this.wss.once("listening", function _onListeningWSS() {
            self.emit("listening");
        });
        this.wss.on("connection", function _onConnectionWSS(ws, req) {
            let socket = new Socket(ws);
            self.sockets.set(socket.id, socket);
            ws.once("close", function _onCloseWS() {
                self.sockets.delete(socket.id);
                socket.emit("close");
                socket.removeAllListeners();
                socket.ws = null;
                socket.rooms.clear();
                socket.data.clear();
                socket = null;
                ws.removeAllListeners();
                ws = null;
            });
            ws.on("message", function _onMessageWS(data) {
                self._messageHandler.handleMessage(socket, data)
                    .catch(function _onErrorHandleMessage(e) {
                    self.emit("error", e);
                });
            });
            ws.on("pong", function _onPongWS() {
                socket._pongAt = Date.now();
            });
            self.emit("connection", socket, req);
        });
        this.wss.on("error", function _onErrorWSS(e) {
            self.emit("error", e);
        });
        this._pingTimer = setInterval(this._ping.bind(this), this.options.pingInterval);
        return this;
    }
    /**
     * Closes the server and terminates all sockets.
     */
    async close() {
        clearInterval(this._pingTimer);
        for (const socket of this.sockets.values()) {
            socket.terminate();
        }
        await new Promise((resolve, reject) => {
            this.wss.close(err => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
        this.wss.removeAllListeners();
        delete this.wss;
        this.sockets.clear();
    }
    /**
     * Broadcasts a notification.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    broadcast(method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        const json = JSON.stringify(data);
        for (const socket of this.sockets.values()) {
            socket.send(json);
        }
    }
    /**
     * Broadcasts a notification to the room.
     * @param room The name of the room.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notifyTo(room, method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        const json = JSON.stringify(data);
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                socket.send(json);
            }
        }
    }
    /**
     * Broadcasts a (raw) message to the room.
     * @param room The name of the room.
     * @param data (raw) message.
     */
    sendTo(room, data) {
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                socket.send(data);
            }
        }
    }
    /**
     * Get all sockets in the room.
     * @param room The name of the room.
     */
    in(room) {
        const sockets = new Map();
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                sockets.set(socket.id, socket);
            }
        }
        return sockets;
    }
    /**
     * Server is open or not
     */
    isOpen() {
        return this.wss !== undefined;
    }
    /**
     * Ping to all sockets.
     */
    _ping() {
        const deadline = this._lastPingAt + this.options.pingTimeout;
        for (const socket of this.sockets.values()) {
            if (socket._pongAt === -1 || socket._pongAt > deadline) {
                socket.terminate();
                continue;
            }
            socket._pongAt = -1;
            if (socket.isOpen()) {
                socket.ws.ping();
            }
        }
        this._lastPingAt = Date.now();
    }
}
exports["default"] = Server;
class Socket extends EventEmitter {
    constructor(ws) {
        super();
        this.ws = ws;
        this.id = uuid_1.v4();
        this.rooms = new Set();
        /** custom data store */
        this.data = new MapLike_1.default();
        /** (internal using for heartbeat) */
        this._pongAt = 0;
    }
    /**
     * Sends a notification to the socket.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notify(method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        this.send(JSON.stringify(data));
    }
    /**
     * Sends a (raw) message to the socket.
     * @param data (raw) message.
     * @param binary binary flag.
     */
    send(data, binary = false) {
        if (this.isOpen()) {
            this.ws.send(data, { binary });
        }
    }
    /**
     * Joins a room. You can join multiple rooms.
     * @param room The name of the room that we want to join.
     */
    joinTo(room) {
        if (this.rooms.has(room) === false) {
            this.rooms.add(room);
            return true;
        }
        return false;
    }
    /**
     * Leaves a room.
     * @param room The name of the room to leave.
     */
    leaveFrom(room) {
        if (this.rooms.has(room) === true) {
            this.rooms.delete(room);
            return true;
        }
        return false;
    }
    /**
     * Leaves all the rooms that we've joined.
     */
    leaveFromAll() {
        this.rooms.clear();
    }
    /**
     * Initiate a closing handshake.
     * @param code A numeric value indicating the status code explaining why the connection is being closed.
     * @param reason A human-readable string explaining why the connection is closing.
     */
    close(code, reason) {
        this.ws.close(code, reason);
    }
    /**
     * Forcibly close the connection.
     */
    terminate() {
        this.ws.terminate();
    }
    /**
     * Get the connection is open or not
     */
    isOpen() {
        return this.ws !== undefined && this.ws.readyState === ws_1.OPEN;
    }
}
exports.Socket = Socket;
//# sourceMappingURL=server.js.map

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
if (global.fetch) {
	exports["default"] = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(/*! ./util.inspect */ "?2128");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== '__proto__') {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var split = String.prototype.split;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            if (generateArrayPrefix === 'comma' && encodeValuesOnly) {
                var valuesArray = split.call(String(obj), ',');
                var valuesJoined = '';
                for (var i = 0; i < valuesArray.length; ++i) {
                    valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults.encoder, charset, 'value', format));
                }
                return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? '[]' : '') + '=' + valuesJoined];
            }
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        /* eslint operator-linebreak: [2, "before"] */
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NIL": () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "parse": () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "stringify": () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "v1": () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "v3": () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "v4": () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "v5": () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "validate": () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "version": () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/esm-browser/v1.js");
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/esm-browser/v3.js");
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/esm-browser/nil.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/esm-browser/version.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");










/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/esm-browser/md5.js");


var v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ ((module) => {

"use strict";


module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ }),

/***/ "?2128":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DIRTY": () => (/* binding */ DIRTY),
/* harmony export */   "EMPTY_PATH": () => (/* binding */ EMPTY_PATH),
/* harmony export */   "INVALID": () => (/* binding */ INVALID),
/* harmony export */   "OK": () => (/* binding */ OK),
/* harmony export */   "ParseStatus": () => (/* binding */ ParseStatus),
/* harmony export */   "Schema": () => (/* binding */ ZodType),
/* harmony export */   "ZodAny": () => (/* binding */ ZodAny),
/* harmony export */   "ZodArray": () => (/* binding */ ZodArray),
/* harmony export */   "ZodBigInt": () => (/* binding */ ZodBigInt),
/* harmony export */   "ZodBoolean": () => (/* binding */ ZodBoolean),
/* harmony export */   "ZodDate": () => (/* binding */ ZodDate),
/* harmony export */   "ZodDefault": () => (/* binding */ ZodDefault),
/* harmony export */   "ZodDiscriminatedUnion": () => (/* binding */ ZodDiscriminatedUnion),
/* harmony export */   "ZodEffects": () => (/* binding */ ZodEffects),
/* harmony export */   "ZodEnum": () => (/* binding */ ZodEnum),
/* harmony export */   "ZodError": () => (/* binding */ ZodError),
/* harmony export */   "ZodFirstPartyTypeKind": () => (/* binding */ ZodFirstPartyTypeKind),
/* harmony export */   "ZodFunction": () => (/* binding */ ZodFunction),
/* harmony export */   "ZodIntersection": () => (/* binding */ ZodIntersection),
/* harmony export */   "ZodIssueCode": () => (/* binding */ ZodIssueCode),
/* harmony export */   "ZodLazy": () => (/* binding */ ZodLazy),
/* harmony export */   "ZodLiteral": () => (/* binding */ ZodLiteral),
/* harmony export */   "ZodMap": () => (/* binding */ ZodMap),
/* harmony export */   "ZodNaN": () => (/* binding */ ZodNaN),
/* harmony export */   "ZodNativeEnum": () => (/* binding */ ZodNativeEnum),
/* harmony export */   "ZodNever": () => (/* binding */ ZodNever),
/* harmony export */   "ZodNull": () => (/* binding */ ZodNull),
/* harmony export */   "ZodNullable": () => (/* binding */ ZodNullable),
/* harmony export */   "ZodNumber": () => (/* binding */ ZodNumber),
/* harmony export */   "ZodObject": () => (/* binding */ ZodObject),
/* harmony export */   "ZodOptional": () => (/* binding */ ZodOptional),
/* harmony export */   "ZodParsedType": () => (/* binding */ ZodParsedType),
/* harmony export */   "ZodPromise": () => (/* binding */ ZodPromise),
/* harmony export */   "ZodRecord": () => (/* binding */ ZodRecord),
/* harmony export */   "ZodSchema": () => (/* binding */ ZodType),
/* harmony export */   "ZodSet": () => (/* binding */ ZodSet),
/* harmony export */   "ZodString": () => (/* binding */ ZodString),
/* harmony export */   "ZodTransformer": () => (/* binding */ ZodEffects),
/* harmony export */   "ZodTuple": () => (/* binding */ ZodTuple),
/* harmony export */   "ZodType": () => (/* binding */ ZodType),
/* harmony export */   "ZodUndefined": () => (/* binding */ ZodUndefined),
/* harmony export */   "ZodUnion": () => (/* binding */ ZodUnion),
/* harmony export */   "ZodUnknown": () => (/* binding */ ZodUnknown),
/* harmony export */   "ZodVoid": () => (/* binding */ ZodVoid),
/* harmony export */   "addIssueToContext": () => (/* binding */ addIssueToContext),
/* harmony export */   "any": () => (/* binding */ anyType),
/* harmony export */   "array": () => (/* binding */ arrayType),
/* harmony export */   "bigint": () => (/* binding */ bigIntType),
/* harmony export */   "boolean": () => (/* binding */ booleanType),
/* harmony export */   "custom": () => (/* binding */ custom),
/* harmony export */   "date": () => (/* binding */ dateType),
/* harmony export */   "default": () => (/* binding */ mod),
/* harmony export */   "defaultErrorMap": () => (/* binding */ defaultErrorMap),
/* harmony export */   "discriminatedUnion": () => (/* binding */ discriminatedUnionType),
/* harmony export */   "effect": () => (/* binding */ effectsType),
/* harmony export */   "enum": () => (/* binding */ enumType),
/* harmony export */   "function": () => (/* binding */ functionType),
/* harmony export */   "getParsedType": () => (/* binding */ getParsedType),
/* harmony export */   "instanceof": () => (/* binding */ instanceOfType),
/* harmony export */   "intersection": () => (/* binding */ intersectionType),
/* harmony export */   "isAborted": () => (/* binding */ isAborted),
/* harmony export */   "isAsync": () => (/* binding */ isAsync),
/* harmony export */   "isDirty": () => (/* binding */ isDirty),
/* harmony export */   "isValid": () => (/* binding */ isValid),
/* harmony export */   "late": () => (/* binding */ late),
/* harmony export */   "lazy": () => (/* binding */ lazyType),
/* harmony export */   "literal": () => (/* binding */ literalType),
/* harmony export */   "makeIssue": () => (/* binding */ makeIssue),
/* harmony export */   "map": () => (/* binding */ mapType),
/* harmony export */   "nan": () => (/* binding */ nanType),
/* harmony export */   "nativeEnum": () => (/* binding */ nativeEnumType),
/* harmony export */   "never": () => (/* binding */ neverType),
/* harmony export */   "null": () => (/* binding */ nullType),
/* harmony export */   "nullable": () => (/* binding */ nullableType),
/* harmony export */   "number": () => (/* binding */ numberType),
/* harmony export */   "object": () => (/* binding */ objectType),
/* harmony export */   "objectUtil": () => (/* binding */ objectUtil),
/* harmony export */   "oboolean": () => (/* binding */ oboolean),
/* harmony export */   "onumber": () => (/* binding */ onumber),
/* harmony export */   "optional": () => (/* binding */ optionalType),
/* harmony export */   "ostring": () => (/* binding */ ostring),
/* harmony export */   "overrideErrorMap": () => (/* binding */ overrideErrorMap),
/* harmony export */   "preprocess": () => (/* binding */ preprocessType),
/* harmony export */   "promise": () => (/* binding */ promiseType),
/* harmony export */   "quotelessJson": () => (/* binding */ quotelessJson),
/* harmony export */   "record": () => (/* binding */ recordType),
/* harmony export */   "set": () => (/* binding */ setType),
/* harmony export */   "setErrorMap": () => (/* binding */ setErrorMap),
/* harmony export */   "strictObject": () => (/* binding */ strictObjectType),
/* harmony export */   "string": () => (/* binding */ stringType),
/* harmony export */   "transformer": () => (/* binding */ effectsType),
/* harmony export */   "tuple": () => (/* binding */ tupleType),
/* harmony export */   "undefined": () => (/* binding */ undefinedType),
/* harmony export */   "union": () => (/* binding */ unionType),
/* harmony export */   "unknown": () => (/* binding */ unknownType),
/* harmony export */   "void": () => (/* binding */ voidType),
/* harmony export */   "z": () => (/* binding */ mod)
/* harmony export */ });
var util;
(function (util) {
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
})(util || (util = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, null, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};
const defaultErrorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (issue.validation !== "regex")
                message = `Invalid ${issue.validation}`;
            else
                message = "Invalid";
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return { message };
};
let overrideErrorMap = defaultErrorMap;
const setErrorMap = (map) => {
    overrideErrorMap = map;
};

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideErrorMap,
            defaultErrorMap,
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== undefined && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        return this._path.concat(this._key);
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        const error = new ZodError(ctx.common.issues);
        return { success: false, error };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined" && required_error)
            return { message: required_error };
        if (params.invalid_type_error)
            return { message: params.invalid_type_error };
        return { message: ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this.superRefine = this._refinement;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.default = this.default.bind(this);
        this.describe = this.describe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    optional() {
        return ZodOptional.create(this);
    }
    nullable() {
        return ZodNullable.create(this);
    }
    nullish() {
        return this.optional().nullable();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this);
    }
    or(option) {
        return ZodUnion.create([this, option]);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming);
    }
    transform(transform) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
// eslint-disable-next-line
const emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class ZodString extends ZodType {
    constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this.min(len, message).max(len, message);
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get minLength() {
        let min = -Infinity;
        this._def.checks.map((ch) => {
            if (ch.kind === "min") {
                if (min === null || ch.value > min) {
                    min = ch.value;
                }
            }
        });
        return min;
    }
    get maxLength() {
        let max = null;
        this._def.checks.map((ch) => {
            if (ch.kind === "max") {
                if (max === null || ch.value < max) {
                    max = ch.value;
                }
            }
        });
        return max;
    }
}
ZodString.create = (params) => {
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int");
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBigInt.create = (params) => {
    return new ZodBigInt({
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        return {
            status: "valid",
            value: new Date(input.data.getTime()),
        };
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all(ctx.data.map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = ctx.data.map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return this.min(len, message).max(len, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodObject      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second,
        };
    };
})(objectUtil || (objectUtil = {}));
const AugmentFactory = (def) => (augmentation) => {
    return new ZodObject({
        ...def,
        shape: () => ({
            ...def.shape(),
            ...augmentation,
        }),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return ZodArray.create(deepPartialify(schema.element));
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        this.augment = AugmentFactory(this._def);
        this.extend = AugmentFactory(this._def);
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        // const mergedShape = objectUtil.mergeShapes(
        //   this._def.shape(),
        //   merging._def.shape()
        // );
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).map((key) => {
            // only add to shape if key corresponds to an element of the current shape
            if (this.shape[key])
                shape[key] = this.shape[key];
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).map((key) => {
            if (util.objectKeys(mask).indexOf(key) === -1) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        if (mask) {
            util.objectKeys(this.shape).map((key) => {
                if (util.objectKeys(mask).indexOf(key) === -1) {
                    newShape[key] = this.shape[key];
                }
                else {
                    newShape[key] = this.shape[key].optional();
                }
            });
            return new ZodObject({
                ...this._def,
                shape: () => newShape,
            });
        }
        else {
            for (const key in this.shape) {
                const fieldSchema = this.shape[key];
                newShape[key] = fieldSchema.optional();
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required() {
        const newShape = {};
        for (const key in this.shape) {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
            }
            newShape[key] = newField;
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.options.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: this.validDiscriminatorValues,
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get validDiscriminatorValues() {
        return Array.from(this.options.keys());
    }
    get options() {
        return this._def.options;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, types, params) {
        // Get all the valid discriminator values
        const options = new Map();
        try {
            types.forEach((type) => {
                const discriminatorValue = type.shape[discriminator].value;
                options.set(discriminatorValue, type);
            });
        }
        catch (e) {
            throw new Error("The discriminator value could not be extracted from all the provided schemas");
        }
        // Assert that all the discriminator values are unique
        if (options.size !== types.length) {
            throw new Error("Some of the discriminator values are not unique");
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                type: "array",
            });
            status.dirty();
        }
        const items = ctx.data
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    overrideErrorMap,
                    defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    overrideErrorMap,
                    defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            return OK(async (...args) => {
                const error = new ZodError([]);
                const parsedArgs = await this._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await fn(...parsedArgs);
                const parsedReturns = await this._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            return OK((...args) => {
                const parsedArgs = this._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = fn(...parsedArgs.data);
                const parsedReturns = this._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
}
ZodFunction.create = (args, returns, params) => {
    return new ZodFunction({
        args: (args
            ? args.rest(ZodUnknown.create())
            : ZodTuple.create([]).rest(ZodUnknown.create())),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params),
    });
};
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                // if (base.status === "aborted") return INVALID;
                // if (base.status === "dirty") {
                //   return { status: "dirty", value: base.value };
                // }
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    // if (base.status === "aborted") return INVALID;
                    // if (base.status === "dirty") {
                    //   return { status: "dirty", value: base.value };
                    // }
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const custom = (check, params = {}, fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            if (!check(data)) {
                const p = typeof params === "function" ? params(data) : params;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal });
            }
        });
    return ZodAny.create();
};
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params, true);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();

var mod = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getParsedType: getParsedType,
    ZodParsedType: ZodParsedType,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    ZodType: ZodType,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    get objectUtil () { return objectUtil; },
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodNaN: ZodNaN,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError,
    defaultErrorMap: defaultErrorMap,
    get overrideErrorMap () { return overrideErrorMap; },
    setErrorMap: setErrorMap
});




/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvcmVzb3VyY2VzX2pzX2NvbXBvbmVudHNfVHJhbnNhY3Rpb25zX0V4Y2hhbmdlQWN0aW9uX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSw2QkFBNkI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUU0YjtBQUM1Yjs7Ozs7Ozs7Ozs7OztBQy9xQ1k7O0FBRVosSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHlJQUF3RDtBQUMxRDs7Ozs7Ozs7Ozs7O0FDUGE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxnQ0FBZ0M7O0FBRWhDLG1CQUFtQixtQkFBTyxDQUFDLDhEQUFjO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLHNFQUFlO0FBQ3BELDRCQUE0QixtQkFBTyxDQUFDLGdEQUFPO0FBQzNDLHlDQUF5QyxtQkFBTyxDQUFDLDhFQUEyQjtBQUM1RSxnQ0FBZ0MsbUJBQU8sQ0FBQyw0REFBa0I7QUFDMUQscUNBQXFDLG1CQUFPLENBQUMsc0VBQXVCO0FBQ3BFLDJDQUEyQyxtQkFBTyxDQUFDLGtGQUE2Qjs7QUFFaEY7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlEQUF5RDtBQUM1RCxDQUFDLG9CQUFvQixhQUFhLEtBQUs7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pELFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSw0QkFBNEI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHNEQUFlLG1CQUFtQjs7QUFFaEQ7QUFDQTs7QUFFQSxzRUFBc0UsNEJBQTRCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsc0RBQWUsOEJBQThCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxzREFBZSxlQUFlOztBQUU1QztBQUNBOztBQUVBLHdFQUF3RSw4QkFBOEI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsc0RBQWU7QUFDaEMsaUJBQWlCLHNEQUFlO0FBQ2hDLGdCQUFnQixzREFBZTtBQUMvQjtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsNkNBQUk7QUFDcEIsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxpQkFBaUIsc0RBQWU7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsRUFBRTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQSxhQUFhLFlBQVk7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRHQUE0Ryw0QkFBNEI7QUFDeEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEVBQTBFLDhCQUE4QjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtFQUErRSw4QkFBOEI7QUFDN0c7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLGtIQUFrSCw4QkFBOEI7QUFDaEo7QUFDQTtBQUNBLDhFQUE4RTs7QUFFOUU7QUFDQTtBQUNBOztBQUVBLHNHQUFzRyw4QkFBOEI7QUFDcEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWixRQUFRO0FBQ1Isc0dBQXNHLDhCQUE4QjtBQUNwSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDRGQUE0Riw4QkFBOEI7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUZBQWlGLDhCQUE4QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZFQUE2RSw4QkFBOEI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDhGQUE4RixnQ0FBZ0M7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBO0FBQ0EsR0FBRyxhQUFhLGdDQUFnQztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsUUFBUTtBQUNSO0FBQ0EsaUdBQWlHLGdDQUFnQztBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlGQUFpRjs7QUFFakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVixRQUFRO0FBQ1Isd0VBQXdFO0FBQ3hFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7O0FBRVA7QUFDQTtBQUNBLEdBQUcsYUFBYSxnQ0FBZ0M7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtGQUFrRixnQ0FBZ0M7QUFDbEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUdBQXFHLGdDQUFnQztBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZGQUE2RixnQ0FBZ0M7QUFDN0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTs7O0FBR04saUNBQWlDLGlFQUFpRTs7QUFFbEcsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxlQUFlO0FBQ2YsSUFBSTtBQUNKLG1EQUFtRDtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG1EQUFlO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVEQUF1RCx3REFBVTtBQUNqRTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLCtHQUErRzs7QUFFL0c7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSwrR0FBK0c7O0FBRS9HO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0RBQVE7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDLDJCQUEyQix3REFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0VBQXNCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0VBQXNCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLDZEQUFlOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQywyQkFBMkIsd0RBQVU7QUFDckM7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGVBQWU7QUFDZixhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbURBQVMsQ0FBQyx3REFBVTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHdEQUFVO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxtQ0FBbUMseUNBQVE7QUFDM0Msd0JBQXdCLHlDQUFRO0FBQ2hDLDRCQUE0Qix5Q0FBUTtBQUNwQyw2QkFBNkIseUNBQVE7QUFDckMsb0NBQW9DLHlDQUFRO0FBQzVDLHNDQUFzQyx5Q0FBUTtBQUM5QyxrQ0FBa0MseUNBQVE7QUFDMUMsb0NBQW9DLHlDQUFRO0FBQzVDLDZCQUE2Qix3Q0FBTyxlQUFlLHlDQUFRO0FBQzNELG9DQUFvQyx3Q0FBTyxlQUFlLHlDQUFRO0FBQ2xFLGtDQUFrQyx3Q0FBTyxlQUFlLHlDQUFRO0FBQ2hFLCtCQUErQix3Q0FBTyxlQUFlLHlDQUFRO0FBQzdELENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsNkVBQXlCOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsOENBQThDLGtGQUE4Qjs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckM7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBVTtBQUMvQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBVTtBQUMvQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxtREFBUyxDQUFDLHdEQUFVO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHdEQUFVO0FBQy9FLHFFQUFxRSx3REFBVTtBQUMvRTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQyxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBUSxDQUFDLHNEQUFNO0FBQzFDLHlCQUF5QixzREFBTTtBQUMvQiw4QkFBOEIsc0RBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFVO0FBQ3JDLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVU7QUFDckM7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQztBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBVTtBQUNyQyxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDLG1DQUFtQyxTQUFTO0FBQy9HO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMERBQVUsQ0FBQyx1REFBTztBQUM3Qyw2QkFBNkIsMERBQVUsQ0FBQyx1REFBTyxDQUFDLHlEQUFTLENBQUMsb0RBQUk7QUFDOUQ7QUFDQTtBQUNBLDZCQUE2QiwwQ0FBMEMsMEdBQTBHLEdBQUcsNEVBQTRFLFNBQVM7QUFDelE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0MsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQsNENBQTRDLEdBQUcsU0FBUyxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsR0FBRztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWdFO0FBQ3JGLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxV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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQXdEO0FBQ2pGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3REFBd0Q7QUFDakYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQsaUNBQWlDLHVDQUF1QztBQUN4RSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0EsQ0FBQzs7QUFFdWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BibG9rcy9jb25zdGFudHMvZGlzdC9jb25zdGFudHMuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmxva3MvbnVtYmVycy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmxva3MvbnVtYmVycy9kaXN0L251bWJlcnMuY2pzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmxva3MvdXRpbHMvZGlzdC91dGlscy5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqYWZyaS9udW1icm8vZGlzdC9udW1icm8ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2FwaS9kaXN0L2FwaS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vaHlwZXJpb24vZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9oeXBlcmlvbi9kaXN0L3NyYy9lbmRwb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vaHlwZXJpb24vZGlzdC9zcmMvanNvbnJwYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9oeXBlcmlvbi9kaXN0L3NyYy9ycGNlcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi9oeXBlcmlvbi9kaXN0L3NyYy90eXBlcy9hY3Rpb25fdHJhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vaHlwZXJpb24vZGlzdC9zcmMvdHlwZXMvYXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2xpZ2h0LWFwaS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2xpZ2h0LWFwaS9kaXN0L3NyYy9lbmRwb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vbGlnaHQtYXBpL2Rpc3Qvc3JjL2pzb25ycGMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vbGlnaHQtYXBpL2Rpc3Qvc3JjL3JwY2Vycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL2xpZ2h0LWFwaS9kaXN0L3NyYy90eXBlcy9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvZGlzdC93cmFwLWNvbnN0YW50cy5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL1pvZEVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy9jb2RlZ2VuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy9kZWZhdWx0RXJyb3JNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy9oZWxwZXJzL29iamVjdFV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL2hlbHBlcnMvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL2lzU2NhbGFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2FueS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2JpZ2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvYm9vbGVhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvZW51bS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2ludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMva2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2xhenkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL2xpdGVyYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL25hdGl2ZUVudW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL251bGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9uL3dyYXAtY29uc3RhbnRzL25vZGVfbW9kdWxlcy96b2QvbGliL3NyYy90eXBlcy9yZWNvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvdHVwbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3VuZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3Rvbi93cmFwLWNvbnN0YW50cy9ub2RlX21vZHVsZXMvem9kL2xpYi9zcmMvdHlwZXMvdW5pb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3Vua25vd24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b24vd3JhcC1jb25zdGFudHMvbm9kZV9tb2R1bGVzL3pvZC9saWIvc3JjL3R5cGVzL3ZvaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL1RyYW5zYWN0aW9ucy9FeGNoYW5nZUFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc2RrL2Vhc3llc2Nyb3dTREsuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL3Nkay9wcm90b25BUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhY2tvMi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXlqcy9kYXlqcy5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RheWpzL3BsdWdpbi9hZHZhbmNlZEZvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL3JlbGF0aXZlVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL3RpbWV6b25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXlqcy9wbHVnaW4vdXRjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25ycGMyLXdzL2xpYi9NYXBMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc29ucnBjMi13cy9saWIvTWVzc2FnZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25ycGMyLXdzL2xpYi9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25ycGMyLXdzL2xpYi9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25ycGMyLXdzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbnJwYzItd3MvbGliL3NlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NpZGUtY2hhbm5lbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbWQ1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zaGExLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92My5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vaWdub3JlZHwvVXNlcnMvYWxva2phaW4vUHJvamVjdHMvQklEWC9FYXN5RXNjcm93L25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdHwuL3V0aWwuaW5zcGVjdCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERFRkFVTFRfU1lNQk9MID0gJ0VPUyc7XG52YXIgREVGQVVMVF9TWVNURU1fRE9NQUlOID0gJ2Vvc2lvJztcbnZhciBERUZBVUxUX0NIQUlOID0gJ2Vvcyc7XG5cbnZhciBnZXRDb250cmFjdENvbnN0YW50cyA9IGZ1bmN0aW9uIGdldENvbnRyYWN0Q29uc3RhbnRzKGNoYWluLCBzeXN0ZW1Eb21haW4pIHtcbiAgaWYgKGNoYWluID09PSB2b2lkIDApIHtcbiAgICBjaGFpbiA9IERFRkFVTFRfQ0hBSU47XG4gIH1cblxuICBpZiAoc3lzdGVtRG9tYWluID09PSB2b2lkIDApIHtcbiAgICBzeXN0ZW1Eb21haW4gPSBERUZBVUxUX1NZU1RFTV9ET01BSU47XG4gIH1cblxuICAvLyBQcm94eSBJbmZvcm1hdGlvbiBBY2NvdW50XG4gIHZhciBwcm94eUluZm87XG5cbiAgaWYgKFsnZW9zJywgJ2JvcycsICd3YXgnXS5pbmNsdWRlcyhjaGFpbikpIHtcbiAgICBwcm94eUluZm8gPSAncmVncHJveHlpbmZvJztcbiAgfSBlbHNlIGlmIChjaGFpbiA9PT0gJ3RlbG9zJykge1xuICAgIHByb3h5SW5mbyA9ICd0bHNwcm94eWluZm8nO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBBY2NvdW50c1xuICAgIEVPU0lPOiBzeXN0ZW1Eb21haW4sXG4gICAgRU9TSU9fVE9LRU46ICFbJ2ZpbycsICdmaW8tdGVzdCddLmluY2x1ZGVzKGNoYWluKSA/IHN5c3RlbURvbWFpbiArIFwiLnRva2VuXCIgOiAnZmlvLnRva2VuJyxcbiAgICBBQ0NPVU5UX0lORk86ICdhY2NvdW50LmluZm8nLFxuICAgIFBST1hZX0lORk9fQUNDT1VOVDogcHJveHlJbmZvLFxuICAgIEVPU0lPX01TSUc6IHN5c3RlbURvbWFpbiArIFwiLm1zaWdcIixcbiAgICBFT1NJT19SQU06IHN5c3RlbURvbWFpbiArIFwiLnJhbVwiLFxuICAgIEVPU0lPX1NUQUtFOiBzeXN0ZW1Eb21haW4gKyBcIi5zdGFrZVwiLFxuICAgIEVPU0lPX1BST0RTOiBzeXN0ZW1Eb21haW4gKyBcIi5wcm9kc1wiLFxuICAgIEVPU0lPX05VTEw6IHN5c3RlbURvbWFpbiArIFwiLm51bGxcIixcbiAgICBFT1NJT19SQU1GRUU6IHN5c3RlbURvbWFpbiArIFwiLnJhbWZlZVwiLFxuICAgIEVPU0lPX1ZQQVk6IHN5c3RlbURvbWFpbiArIFwiLnZwYXlcIixcbiAgICBFT1NJT19CUEFZOiBzeXN0ZW1Eb21haW4gKyBcIi5icGF5XCIsXG4gICAgRU9TSU9fUkVYOiBzeXN0ZW1Eb21haW4gKyBcIi5yZXhcIixcbiAgICAvLyBQYXJhbXNcbiAgICBORVdBQ0NPVU5UX05BTUVfUEFSQU06IGNoYWluLmluZGV4T2YoJ2JvcycpID09PSAtMSA/ICduYW1lJyA6ICduZXdhY3QnLFxuICAgIC8vIFRhYmxlc1xuICAgIEVPU0lPX01TSUdfQVBQUk9WQUxTX1RBQkxFOiAnYXBwcm92YWxzMicsXG4gICAgRU9TSU9fTVNJR19QUk9QT1NBTFNfVEFCTEU6ICdwcm9wb3NhbCcsXG4gICAgLy8gQWN0aW9uc1xuICAgIFRSQU5TRkVSX0FDVElPTjogJ3RyYW5zZmVyJyxcbiAgICBERUxFR0FURV9CV19BQ1RJT046ICdkZWxlZ2F0ZWJ3JyxcbiAgICBVTkRFTEVHQVRFX0JXX0FDVElPTjogJ3VuZGVsZWdhdGVidycsXG4gICAgVk9URV9QUk9EVUNFUl9BQ1RJT046ICd2b3RlcHJvZHVjZXInLFxuICAgIEJVWV9SQU1fQUNUSU9OOiAnYnV5cmFtJyxcbiAgICBCVVlfUkFNX0JZVEVTX0FDVElPTjogJ2J1eXJhbWJ5ZXMnLFxuICAgIFNFTExfUkFNX0FDVElPTjogJ3NlbGxyYW0nXG4gIH07XG59O1xuXG52YXIgZGFwcHMgPSBbe1xuICBuYW1lOiAnQWxjb3IuZXhjaGFuZ2UnLFxuICBkZXNjcmlwdGlvbjogJ1RoZSBmaXJzdCBzZWxmLWxpc3RpbmcgREVYLiBXaXRoIEFsY29yIHlvdSBjYW4gdHJhZGUgYW55IEVPUy5JTyB0b2tlbnMgZm9yIHN5c3RlbSBFT1MgdG9rZW5zLCBhdG9taWNhbGx5LCB3aXRob3V0IHRoZSBwYXJ0aWNpcGF0aW9uIG9mIHRoaXJkIHBhcnRpZXMhIENyZWF0ZSBtYXJrZXRzIGluIG9uZSBjbGljaywgbGlzdCB5b3VyIGRhcHAgdG9rZW4gZm9yIG9uZSBjbGljaywgdHJhZGUgd2hhdGV2ZXIgeW91IHdhbnQuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ1RoZSBmaXJzdCBzZWxmLWxpc3RpbmcgREVYLiBXaXRoIEFsY29yIHlvdSBjYW4gdHJhZGUgYW55IEVPUy5JTyB0b2tlbnMgZm9yIHN5c3RlbSBFT1MgdG9rZW5zLicsXG4gIHN5bWJvbDogJycsXG4gIHN0YXRpc3RpY3M6IHRydWUsXG4gIGFjY291bnRzOiBbJ2Vvc3Rva2Vuc2RleCddLFxuICBsb2dvOiAnaHR0cHM6Ly9pLmliYi5jby9kS0RZRE1jL3ZlY3RvcnBhaW50LnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL2FsY29yLmV4Y2hhbmdlLycsXG4gIGFwcDogJ2h0dHBzOi8vYWxjb3IuZXhjaGFuZ2UvJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvYWxjb3JleGNoYW5nZScsXG4gIG1lZGl1bTogJ2h0dHBzOi8vbWVkaXVtLmNvbS9AYXZyYWwnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9hdnJhbF9wcm8nLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vYXZyYWwvYWxjb3ItdWknLFxuICBjaGFpbnM6IFsnZW9zJywgJ3dheCcsICd0ZWxvcyddXG59LCB7XG4gIG5hbWU6ICdTWCcsXG4gIGRlc2NyaXB0aW9uOiAnQnVpbGRpbmcgc2VjdXJlICYgcmVsaWFibGUgZmluYW5jaWFsIGJsb2NrY2hhaW4gaW5zdHJ1bWVudHMnLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnRGVGaSBTd2FwICYgRmxhc2hsb2FuJyxcbiAgc3ltYm9sOiAnU1gnLFxuICBhY2NvdW50czogWydzd2FwLnN4JywgJ3ZpZ29yLnN4JywgJ3N0YWJsZS5zeCcsICdmbGFzaC5zeCcsICdwdXNoLnN4JywgJ25ldHdvcmsuc3gnLCAncmVnaXN0cnkuc3gnLCAnbWluZXIuc3gnLCAnY3Jvc3Muc3gnLCAnbmF2LnN4JywgJ2ZlZS5zeCcsICd0cmFkZS5zeCcsICd2YXVsdHMuc3gnLCAncHJveHkuc3gnLCAnZHVzdC5zeCcsICdjdXJ2ZS5zeCddLFxuICBsb2dvOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Vvc2NhZmUvZW9zLWFpcmRyb3BzL21hc3Rlci9sb2dvcy9zeC5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9naXRodWIuY29tL3N0YWJsZWV4JyxcbiAgYXBwOiAnaHR0cHM6Ly94bmF0aW9uLmlvJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUveG5hdGlvbmlvJyxcbiAgbWVkaXVtOiAnJyxcbiAgdHdpdHRlcjogJycsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9zdGFibGVleCcsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnRU9TTmFtZVNlcnZpY2UnLFxuICBkZXNjcmlwdGlvbjogJ0VPUyBOYW1lIFNlcnZpY2UgaXMgdGhlIG1vc3QgY29tcHJlaGVuc2l2ZSBwbGF0Zm9ybSB0byByZWdpc3RlciBwcmVtaXVtL2Jhc2UgRU9TL1dBWCBhY2NvdW50IG5hbWVzLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdFT1MvV0FYIE5hbWUgU2VydmljZScsXG4gIHN5bWJvbDogJycsXG4gIHBhcnRuZXI6IGZhbHNlLFxuICBhY2NvdW50czogWyduYW1lcyddLFxuICBsb2dvOiAnaHR0cHM6Ly9hdmF0YXJzMS5naXRodWJ1c2VyY29udGVudC5jb20vdS83Mzg5MTA0MScsXG4gIHdlYnNpdGU6ICdodHRwOi8vZW9zbmFtZXNlcnZpY2UuaW8nLFxuICBhcHA6ICdodHRwOi8vZW9zbmFtZXNlcnZpY2UuaW8nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9lb3NuYW1lc2VydmljZScsXG4gIG1lZGl1bTogJycsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL2Vvc25hbWVzZXJ2aWNlJyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL2Vvc25hbWVzZXJ2aWNlJyxcbiAgY2hhaW5zOiBbJ2VvcycsICd3YXgnXVxufSwge1xuICBuYW1lOiAnUHJvc3BlY3RvcnMnLFxuICBkZXNjcmlwdGlvbjogJ01hc3NpdmUgTXVsdGlwbGF5ZXIgT25saW5lIFJlYWwtVGltZSBFY29ub21pYyBTdHJhdGVneSBHYW1lICBNSU5FIEdPTEQgLSBCVUlMRCBZT1VSIFdPUkxEJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ01hc3NpdmUgTXVsdGlwbGF5ZXIgT25saW5lIFJlYWwtVGltZSBFY29ub21pYyBTdHJhdGVneSBHYW1lJyxcbiAgc3ltYm9sOiAnJyxcbiAgYWNjb3VudHM6IFsncHJvc3BlY3RvcnNjJ10sXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9wcm9zcGVjdG9ycy5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9wcm9zcGVjdG9ycy5pbycsXG4gIGFwcDogJ2h0dHBzOi8vcHJvc3BlY3RvcnMuaW8nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9wcm9zcGVjdG9yc2dhbWUnLFxuICBtZWRpdW06ICdodHRwczovL21lZGl1bS5jb20vQHByb3NwZWN0b3JzZ2FtZScsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL3Byb3NwZWN0b3JzZ2FtZScsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9wcm9zcGVjdG9ycy9wdWJsaWMvaXNzdWVzJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdBUFBJQ1MnLFxuICBkZXNjcmlwdGlvbjogJ0FQUElDUyBpcyB0aGUgbW9zdCBlbmdhZ2VkIHNvY2lhbCBtZWRpYSBkQXBwIHRoYXQgbWFrZXMgaXQgZWFzeSB0byBnZXQgcmV3YXJkZWQgd2l0aCBjcnlwdG9jdXJyZW5jeSBmb3IgeW91ciBzb2NpYWwgbWVkaWEgYWN0aXZpdHkgbGlrZSBjcmVhdGluZyAmIGN1cmF0aW5nIGNvbnRlbnQuIFRoZSBtb2JpbGUgaW50ZXJmYWNlIGlzIGludHVpdGl2ZSB0byB1c2Ugd2l0aG91dCBhbnkgcHJpb3IgYmxvY2tjaGFpbiBrbm93bGVkZ2UuIEdldCByZXdhcmRlZCBmb3IgeW91ciBwYXNzaW9uIScsXG4gIHNob3J0RGVzY3JpcHRpb246ICdBUFBJQ1MgaXMgdGhlIG1vc3QgZW5nYWdlZCBzb2NpYWwgbWVkaWEgZEFwcCAtIGVhcm4gQVBYIFRva2VucyBmb3IgcG9zdGluZywgY29tbWVudGluZywgYW5kIHVwLXZvdGluZyBwaG90b3MgJiB2aWRlb3MhJyxcbiAgc3ltYm9sOiAnQVBYJyxcbiAgc3RhdGlzdGljczogdHJ1ZSxcbiAgYWNjb3VudHM6IFsnYXBwaWNzYXBwaWNzJ10sXG4gIGxvZ286ICdodHRwczovL2kuaW1ndXIuY29tL1RzOUNOTjUucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vYXBwaWNzLmNvbScsXG4gIGFwcDogJ2h0dHBzOi8vYXBwaWNzLmNvbScsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2FwcGljc19vZmZpY2lhbCcsXG4gIG1lZGl1bTogJ2h0dHBzOi8vbWVkaXVtLmNvbS9AYXBwaWNzJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vYXBwaWNzX29mZmljaWFsJyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL3BoZW5vbS1jb21wYW55L2FwcGljc19lb3NfdG9rZW4nLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ0JvaWQnLFxuICBkZXNjcmlwdGlvbjogJ0NvbnRyaWJ1dGUgeW91ciBleGNlc3MgY29tcHV0aW5nIHJlc291cmNlcyB0b3dhcmRzIGltcG9ydGFudCBjYXVzZXMgd2hpbGUgZWFybmluZyByZXdhcmRzLiBKb2luIGEgdGVhbSBhbmQgcmFuayB1cCBvbiB0aGUgc29jaWFsIGxlYWRlcmJvYXJkcy4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnVGhlIFNvY2lhbCBTdXBlcmNvbXB1dGVyLiBDb250cmlidXRlIHlvdXIgZXhjZXNzIGNvbXB1dGluZyByZXNvdXJjZXMgdG93YXJkcyBpbXBvcnRhbnQgY2F1c2VzLicsXG4gIHN5bWJvbDogJycsXG4gIGFjY291bnRzOiBbJ2JvaWRjb210b2tlbicsICdib2lkY29tcG93ZXInLCAnYm9pZGNvbW1pbnQxJywgJ2JvaWRjb21wcm9tbyddLFxuICBsb2dvOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2JvaWQtY29tL2Fzc2V0cy9tYXN0ZXIvYm9pZExvZ28tbGcucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vYm9pZC5jb20nLFxuICBhcHA6ICdodHRwczovL2FwcC5ib2lkLmNvbScsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL0JvaWRjb21fb2ZmaWNpYWwnLFxuICBtZWRpdW06ICdodHRwczovL21lZGl1bS5jb20vQGJvaWRjb20nLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9ib2lkY29tJyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL2JvaWQtY29tJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdUaGUgQmlsbGlvbmFpcmUgVG9rZW4nLFxuICBkZXNjcmlwdGlvbjogJ01vc3Qgb3RoZXIgY29pbnMgb3IgdG9rZW5zIGhhdmUgc29tZSBzb3J0IG9mIG1pbmluZyBzeXN0ZW0uIEJpbGxpb25haXJlIFRva2VuIGhhcyB0aGUgZXhhY3Qgb3Bwb3NpdGU6IEl0IGZlYXR1cmVzIGEgZGVmbGF0aW9uYXJ5IG1lY2hhbmlzbSB0aGF0IGRlc3Ryb3lzIDMwJSBvZiB0aGUgZ2FtYmxlZCBjb2lucy4gVGh1cyB0aGUgdG9rZW5zIGJlY29tZSBtb3JlIGFuZCBtb3JlIHJhcmUgYXMgbW9yZSBhbmQgbW9yZSBwZW9wbGUgZ2FtYmxlLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdCaWxsaW9uYWlyZSBUb2tlbiBoYXMgdGhlIG9wcG9zaXRlIG9mIGEgbWluaW5nIHN5c3RlbTogSXQgZmVhdHVyZXMgYSBkZWZsYXRpb25hcnkgbWVjaGFuaXNtIHRoYXQgZGVzdHJveXMgMzAlIG9mIHRoZSBnYW1ibGVkIGNvaW5zLicsXG4gIHN5bWJvbDogJ1hCTCcsXG4gIGFjY291bnRzOiBbJ2JpbGxpb25haXJldCcsICdiaWxsaW9ucmFmZmwnLCAnYmlsbGlvbmJ1cm5yJywgJ2JpbGxpb25ib3QxMScsICdiaWxsaW9uYm90MTInLCAnYmlsbGlvbmJvdDEzJywgJ2JpbGxpb25ib3QxNCddLFxuICBhcHA6ICdodHRwczovL0JpbGxpb25haXJlVG9rZW4uY29tLycsXG4gIGxvZ286ICdodHRwczovL0JpbGxpb25haXJlVG9rZW4uY29tL2ltYWdlcy9sb2dvX2JpZy5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly9CaWxsaW9uYWlyZVRva2VuLmNvbS8nLFxuICB0ZWxlZ3JhbTogJ2h0dHBzOi8vdC5tZS9CaWxsaW9uYWlyZVRva2VuJyxcbiAgbWVkaXVtOiAnaHR0cHM6Ly9tZWRpdW0uY29tL0BiaWxsaW9uYWlyZV8zMzczJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vQmlsbGlvbmFpcmVUa24nLFxuICBnaXRodWI6ICdodHRwczovL2dpdGh1Yi5jb20vQmlsbGlvbmFpcmVUb2tlbicsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnQ3J5cHRvIFN3b3JkICYgTWFnaWMnLFxuICBkZXNjcmlwdGlvbjogJ0NyeXB0byBTd29yZCAmIE1hZ2ljIGlzIHRoZSBmaXJzdCBibG9ja2J1c3RlciBSUEcgb24gRU9TIGJsb2NrY2hhaW4sIHRyYWRpdGlvbmFsIHR1cm4tYmFzZWQgUlBHIHJhaXNpbmcgaGVyb2VzIHRvIGNoYWxsZW5nZSBuZXcgZHVuZ2VvbnMuIEdhbWUgYXNzZXRzIGFyZSByZWNvcmRlZCBvbiBCbG9ja2NoYWluIGFuZCB0cmFuc2FjdGlvbnMgcnVuIG9uIHNtYXJ0IGNvbnRyYWN0cycsXG4gIHNob3J0RGVzY3JpcHRpb246ICdDcnlwdG8gU3dvcmQgJiBNYWdpYyBpcyB0aGUgZmlyc3QgYmxvY2tidXN0ZXIgUlBHIG9uIEVPUyBibG9ja2NoYWluLicsXG4gIHN5bWJvbDogJ0NTTScsXG4gIGFjY291bnRzOiBbJ3N3b3Jkbm1hZ2ljbSddLFxuICBhcHA6ICdodHRwczovL3d3dy5jcnlwdG9zd29yZGFuZG1hZ2ljLmNvbScsXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9jcnlwdG9zbm0ucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vd3d3LmNyeXB0b3N3b3JkYW5kbWFnaWMuY29tJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvY3J5cHRvc25tX2NvbW1fZW4nLFxuICBtZWRpdW06ICdodHRwczovL21lZGl1bS5jb20vQGNyeXB0b3N3b3JkYW5kbWFnaWMnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9zd29yZF9hbmRfbWFnaWMnLFxuICBnaXRodWI6ICcnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ2RtYWlsJyxcbiAgZGVzY3JpcHRpb246ICdXZWxjb21lIHRvIGRtYWlsIEJldGEhIFdlIGFyZSBzbyBleGNpdGVkIHRvIGhhdmUgeW91IHBhcnRpY2lwYXRlIGFzIHdlIGxhdW5jaCBvdXIgQmV0YSBwbGF0Zm9ybS4gSW4gdGhlIGVhcmx5IHN0YWdlcyB3ZSBhcmUgY292ZXJpbmcgdGhlIHNpbXBsZXN0IG9mIGZ1bmN0aW9uYWxpdHksIHdoaWNoIGlzIHNlbmRpbmcgYW5kIHJlY2VpdmluZyBtZXNzYWdlcy4gSW4gdGhlIHZlcnkgbmVhciBmdXR1cmUsIHdlIHdpbGwgYmUgYWRkaW5nIGEgYnVuY2ggb2YgbmV3IGZlYXR1cmVzIHdoaWNoIHdlIGtub3cgdGhlIGNvbW11bml0eSBpcyBnb2luZyB0byBhc2sgZm9yLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdkbWFpbCBpcyB0aGUgZmlyc3QgZGVjZW50cmFsaXplZCBlbWFpbCBvbiB0aGUgYmxvY2tjaGFpbicsXG4gIHN5bWJvbDogJ01BSUwnLFxuICBzdGF0aXN0aWNzOiB0cnVlLFxuICBhY2NvdW50czogWydkbWFpbGRvdGNvYnAnXSxcbiAgbG9nbzogJ2h0dHBzOi8vd3d3LmRtYWlsLmNvL2xvZ29zeW1fMjU2LnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL2RtYWlsLmNvJyxcbiAgYXBwOiAnJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvZG1haWxjb21tdW5pdHknLFxuICBtZWRpdW06ICdodHRwczovL21lZGl1bS5jb20vQGRtYWlsJyxcbiAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vZG1haWxkb3RjbycsXG4gIGdpdGh1YjogJycsXG4gIGNoYWluczogWydlb3MnLCAndGVsb3MnXVxufSwge1xuICBuYW1lOiAnTXVybXVyJyxcbiAgZGVzY3JpcHRpb246ICdNdXJtdXIgaXMgYSBuZXcgYWdlIGRlY2VudHJhbGl6ZWQgbWljcm9ibG9nZ2luZyBwbGF0Zm9ybSBvbiBFT1MgdGhhdCBpcyBjZW5zb3JzaGlwLXJlc2lzdGFudCwgc3BhbS1wcm9vZiBhbmQgcmV3YXJkaW5nIHRvIHVzZS4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnTXVybXVyIGlzIGEgbmV3IGFnZSBkZWNlbnRyYWxpemVkIG1pY3JvYmxvZ2dpbmcgcGxhdGZvcm0gb24gRU9TIHRoYXQgaXMgY2Vuc29yc2hpcC1yZXNpc3RhbnQsIHNwYW0tcHJvb2YgYW5kIHJld2FyZGluZyB0byB1c2UuJyxcbiAgc3ltYm9sOiAnTVVSJyxcbiAgcGFydG5lcjogdHJ1ZSxcbiAgYWNjb3VudHM6IFsnbXVybXVyZGFwcGNvJywgJ211cm11cnRva2VucycsICdtdXJtdXJmcmVlYWMnXSxcbiAgYXBwOiAnaHR0cHM6Ly9wbGF5Lmdvb2dsZS5jb20vc3RvcmUvYXBwcy9kZXRhaWxzP2lkPWNvbS5tdXJtdXJkYXBwJyxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL211cm11ci5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cDovL211cm11cmRhcHAuY29tJyxcbiAgdGVsZWdyYW06ICdodHRwOi8vdC5tZS9tdXJtdXJkYXBwJyxcbiAgbWVkaXVtOiAnJyxcbiAgdHdpdHRlcjogJ2h0dHA6Ly90d2l0dGVyLmNvbS9tdXJtdXJkYXBwJyxcbiAgZ2l0aHViOiAnJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdFbWFuYXRlJyxcbiAgZGVzY3JpcHRpb246ICdFbWFuYXRlIGlzIEVPUyBmb3IgdGhlIG11c2ljIGluZHVzdHJ5LiBBbiBhdXRvbWF0ZWQsIHJlYWx0aW1lIG11c2ljIGNvbGxhYm9yYXRpb24gYW5kIG1vbmV0aXNhdGlvbiBwbGF0Zm9ybS4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnRW1hbmF0ZSBpcyBkZWNlbnRyYWxpc2VkIHRlY2hub2xvZ3kgZm9yIHRoZSBmdXR1cmUgb2YgbXVzaWMnLFxuICBzeW1ib2w6ICdFTVQnLFxuICBwYXJ0bmVyOiB0cnVlLFxuICBhY2NvdW50czogWydlbWFuYXRlb25lb3MnLCAnZW1hbmF0ZWlzc3VlJ10sXG4gIGFwcDogJ2h0dHBzOi8vZW1hbmF0ZS5saXZlLycsXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9lbWFuYXRlLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL2VtYW5hdGUubGl2ZScsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2VtYW5hdGVvZmZpY2lhbCcsXG4gIG1lZGl1bTogJycsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL2VtYW5hdGVvZmZpY2lhbCcsXG4gIGdpdGh1YjogJycsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAncGl4RU9TJyxcbiAgZGVzY3JpcHRpb246ICdwaXhFT1MgaXMgdGhlIGZpcnN0IHRva2VuaXplZCBzbWFydCBlY29ub215IGZvciBnYW1lcnMsIGFydGlzdHMgYW5kIGFydCBlbnRodXNpYXN0cy4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAncGl4RU9TIGlzIHRoZSBmaXJzdCB0b2tlbml6ZWQgc21hcnQgZWNvbm9teSBmb3IgZ2FtZXJzLCBhcnRpc3RzIGFuZCBhcnQgZW50aHVzaWFzdHMuJyxcbiAgc3ltYm9sOiAnUElYRU9TJyxcbiAgcGFydG5lcjogdHJ1ZSxcbiAgYWNjb3VudHM6IFsncGl4ZW9zMXRva2VuJywgJ3BpeGVvczFhZG1pbicsICdwaXhlb3Mxc3RhcnQnXSxcbiAgYXBwOiAnaHR0cHM6Ly9waXhlb3MuaW8nLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvcGl4ZW9zLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL3BpeGVvcy5pbycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL1BJWEVPUycsXG4gIG1lZGl1bTogJycsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL2Vvc19waXgnLFxuICBnaXRodWI6ICcnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ0V2ZXJpcGVkaWEnLFxuICBkZXNjcmlwdGlvbjogJ1RoZSBFdmVyaXBlZGlhIHRlYW0gcGxhbnMgdG8gYnVpbGQgYSBtb2Rlcm4sIGNvbnZlbmllbnQgYW5kIGRlY2VudHJhbGl6ZWQgbmV3IGVuY3ljbG9wZWRpYSB3ZWJzaXRlLCBhbmQgdGhpcyBnb2FsIHdpbGwgYmUgcmVhbGl6ZWQgd2l0aCB0aGUgZGV2ZWxvcG1lbnQgb2YgYmxvY2tjaGFpbiB0ZWNobm9sb2d5LiBUaGUgbmV3IHZlcnNpb24gb2YgRXZlcmlwZWRpYSB1bmRlciBkZXZlbG9wbWVudCB3aWxsIGJlIGJhc2VkIG9uIHRoZSBFT1MgbmV0d29yaywgd2hpY2ggd2lsbCBoYXZlIGZlYXR1cmVzIHN1Y2ggYXMgY29tbXVuaXR5IGF1dG9ub215LCBzaGllbGRpbmcgcHJldmVudGF0aW9uLCBhbmQgY29udHJpYnV0aW9uIGluY2VudGl2ZXMgY29tcGFyZWQgdG8gdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBFdmVyaXBlZGlhLiBGb3VuZGVkIGluIDIwMTQsIHRoZSBidXNpbmVzcyBuZXR3b3JrIGVuY3ljbG9wZWRpYSBFdmVyaXBlZGlhLCB3aG9zZSBuYW1lIGRlcml2ZXMgZnJvbSB0aGUgRW5nbGlzaCB3b3JkcyBFdmVyeXRoaW5nIGFuZCBFbmN5Y2xvcGVkaWEsIGlzIG93bmVkIGJ5IEV2ZXJpcGVkaWEuSW5jIGFuZCBoYXMgbm90IHlldCBhZG9wdGVkIGJsb2NrY2hhaW4gdGVjaG5vbG9neS4gQXMgb2YgRGVjZW1iZXIgMjAxNywgRXZlcmlwZWRpYSBpcyB0aGUgbGFyZ2VzdCBFbmdsaXNoIGVuY3ljbG9wZWRpYSB3aXRoIG1vcmUgdGhhbiBzaXggbWlsbGlvbiBlbnRyaWVzLCBpbmNsdWRpbmcgYWxsIEVuZ2xpc2ggZW50cmllcyBvZiBXaWtpcGVkaWEuIEV2ZXJpcGVkaWFzIHJlcXVpcmVtZW50cyBmb3IgYXR0ZW50aW9uIGFyZSBtb3JlIHJlbGF4ZWQsIHNvIGl0IGhhcyBtb3JlIGVudHJpZXMgdGhhbiBXaWtpcGVkaWEuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ1RoZSBFdmVyaXBlZGlhIHRlYW0gcGxhbnMgdG8gYnVpbGQgYSBtb2Rlcm4sIGNvbnZlbmllbnQgYW5kIGRlY2VudHJhbGl6ZWQgbmV3IGVuY3ljbG9wZWRpYS4nLFxuICBzeW1ib2w6ICdJUScsXG4gIHBhcnRuZXI6IHRydWUsXG4gIHN0YXRpc3RpY3M6IGZhbHNlLFxuICBhY2NvdW50czogWydldmVyaXBlZGlhaXEnLCAnZXBhcnRpY2xlY3RyJ10sXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9ldmVyaXBlZGlhLmpwZycsXG4gIHdlYnNpdGU6ICcnLFxuICBhcHA6ICdodHRwczovL2V2ZXJpcGVkaWEub3JnJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvZXZlcmlwZWRpYScsXG4gIG1lZGl1bTogJycsXG4gIHR3aXR0ZXI6ICcnLFxuICBnaXRodWI6ICcnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ2Vvc0RBQycsXG4gIGRlc2NyaXB0aW9uOiAnZW9zREFDIGlzIGEgQ29tbXVuaXR5IE93bmVkIEJsb2NrcHJvZHVjZXIgYW5kIGEgREFDIGVuYWJsZXIsIGJvcm4gb3V0IG9mIERhbiBMYXJpbWVycyBjb25jZXB0IG9mIERlY2VudHJhbGl6ZWQgQXV0b25vbW91cyBDb21tdW5pdGllcyBvciBEQUNzLCBhcm91bmQgd2hpY2ggQmxvY2sub25lIGRldmVsb3BlZCBFT1Mgc29mdHdhcmUuICBUaGUgdmlzaW9uIG9mIGVvc0RBQyBpcyB0aGF0IEVPUy5JTyBibG9jayBwcm9kdWN0aW9uIHNob3VsZCBiZSBvcGVuIGZvciBldmVyeW9uZSB0byBjb250cmlidXRlIGFuZCBiZW5lZml0LiBUbyByZWFsaXplIHRoaXMgdmlzaW9uLCBlb3NEQUMgaXMgYW4gZXZvbHZpbmcgRGVjZW50cmFsaXNlZCBBdXRvbm9tb3VzIENvbW11bml0eSAoREFDKSBmb2N1c2VkIG9uIEVPUy5JTyBCbG9jayBQcm9kdWN0aW9uIHNlcnZpbmcgdGhlIEVPUyBjb21tdW5pdGllcyB3b3JsZHdpZGUuIEluIGRvaW5nIHRoaXMsIGVvc0RBQyBpcyBjcmVhdGluZyB0aGUgdG9vbHMgYW5kIHNtYXJ0IGNvbnRyYWN0cyBpdCBuZWVkcyB0byBmdW5jdGlvbi4gSXQgd2lsbCBzaGFyZSB0aGVzZSB3aXRoIHRoZSBFT1MgY29tbXVuaXRpZXMgdG8gaGVscCBvdGhlciBEQUNzIHRocml2ZSBvbiB0aGUgRU9TLklPIGJsb2NrY2hhaW5zLiAgSW4gb3JkZXIgdG8gZnVuY3Rpb24gYXMgYSBEQUMsIGVvc0RBQyBpcyBjcmVhdGluZyBvcGVuIHNvdXJjZSB0b29scyBhbmQgd2lsbCBiZSBzaGFyaW5nIHRoZW0gYXMgYSBEQUMgVG9vbGtpdCwgdGhhdCBhbnlvbmUgY2FuIHVzZSwgbW9kaWZ5IHRvIHNldHVwIGFuZCBydW4gYSBEQUMuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ2Vvc0RBQyBpcyBjcmVhdGluZyBvcGVuIHNvdXJjZSB0b29scyBhbmQgd2lsbCBiZSBzaGFyaW5nIHRoZW0gYXMgYSBEQUMgVG9vbGtpdCB0byBlbmFibGUgREFDcycsXG4gIHN5bWJvbDogJ0VPU0RBQycsXG4gIHBhcnRuZXI6IGZhbHNlLFxuICBzdGF0aXN0aWNzOiBmYWxzZSxcbiAgYWNjb3VudHM6IFsnZW9zZGFjdG9rZW5zJywgJ2Vvc2RhY3NlcnZlcicsICdlb3NkYWN0aGVkYWMnLCAnZGFjY3VzdG9kaWFuJ10sXG4gIGxvZ286ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZW9zY2FmZS9lb3MtZGFwcHMvbWFzdGVyL2xvZ29zL2Vvc2RhYy5wbmcnLFxuICB3ZWJzaXRlOiAnJyxcbiAgYXBwOiAnbWVtYmVycy5lb3NkYWMuaW8nLFxuICBkaXNjb3JkOiAnaHR0cHM6Ly9kaXNjb3JkLmlvL2Vvc2RhYycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2Vvc2RhY2lvJyxcbiAgbWVkaXVtOiAnJyxcbiAgdHdpdHRlcjogJycsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9lb3NkYWMnLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ0RFT1MgR2FtZXMnLFxuICBkZXNjcmlwdGlvbjogJ0Rlb3MgR2FtZXMgYXJlIGNhc2lubyBnYW1lcyBidWlsdCBvbiBFT1MgYmxvY2tjaGFpbi4gUGxheSB6ZXJvIGVkZ2UgZ2FtZXMgd2l0aCBvdXIgREVPUyB0b2tlbiBhbmQgcGFydGljaXBhdGUgaW4gYmFua3JvbGwgc3Rha2luZy4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnRGVvcyBHYW1lcyBhcmUgY2FzaW5vIGdhbWVzIGJ1aWx0IG9uIHRoZSBFT1MgYmxvY2tjaGFpbi4gUGxheSB6ZXJvIGVkZ2UgZ2FtZXMgd2l0aCBERU9TIHRva2VuLicsXG4gIHN5bWJvbDogJ0RFT1MnLFxuICBzdGF0aXN0aWNzOiBmYWxzZSxcbiAgYWNjb3VudHM6IFsndGhlZGVvc2dhbWVzJywgJ2Rlb3NnYW1laXNzdSddLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvZGVvc2dhbWVzLnBuZycsXG4gIHdlYnNpdGU6ICdodHRwczovL2Rlb3NnYW1lcy5jb20nLFxuICBhcHA6ICdodHRwczovL2FwcC5kZW9zZ2FtZXMuY29tJyxcbiAgdGVsZWdyYW06ICdodHRwczovL3QubWUvZGVvc2dhbWVzY2hhdCcsXG4gIG1lZGl1bTogJ2h0dHBzOi8vbWVkaXVtLmNvbS9kZW9zLWdhbWVzJyxcbiAgdHdpdHRlcjogJycsXG4gIGdpdGh1YjogJycsXG4gIGNoYWluczogWydlb3MnXVxufSwge1xuICBuYW1lOiAnQ2hpbnRhaScsXG4gIGRlc2NyaXB0aW9uOiAnQ2hpbnRhaSBpcyBhIGNvbW11bml0eS1vd25lZCwgZmVlbGVzcywgMTAwJSBvbi1jaGFpbiwgbXVsdGlzaWcgZGVjZW50cmFsaXplZCB0b2tlbiBsZWFzaW5nIHBsYXRmb3JtIHdoZXJlIHVzZXJzIGNhbiBsZW5kIHRoZWlyIEVPUyBvbiB0aGUgbWFya2V0IHRvIGVhcm4gaW50ZXJlc3QgZnJvbSBvdGhlciB1c2VycyB0byBib3Jyb3cgd2hvIG5lZWQgYWNjZXNzIHRvIENQVS9ORVQgYmFuZHdpZHRoLicsXG4gIHNob3J0RGVzY3JpcHRpb246ICdDaGludGFpIGlzIGEgY29tbXVuaXR5LW93bmVkLCBmZWVsZXNzLCAxMDAlIG9uLWNoYWluLCBtdWx0aXNpZyBkZWNlbnRyYWxpemVkIHRva2VuIGxlYXNpbmcgcGxhdGZvcm0uJyxcbiAgc3ltYm9sOiAnJyxcbiAgc3RhdGlzdGljczogZmFsc2UsXG4gIGFjY291bnRzOiBbJ2NoaW50YWlsZWFzZScsICdjaGludGFpcHJveHknLCAnYmlkY2hleHRva2VuJywgJ2NoZXhjaGV4Y2hleCddLFxuICBsb2dvOiAnaHR0cHM6Ly9ibG9rcy5pby9pbWcvZGFwcHMvY2hpbnRhaS5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cDovL2NoaW50YWkuaW8nLFxuICBhcHA6ICdodHRwczovL2Vvcy5jaGludGFpLmlvL2V4Y2hhbmdlL0VPUzI4RCcsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL0NoaW50YWlFT1MnLFxuICBtZWRpdW06ICdodHRwczovL21lZGl1bS5jb20vQENoaW50YWlFT1MnLFxuICB0d2l0dGVyOiAnaHR0cHM6Ly90d2l0dGVyLmNvbS9jaGludGFpZW9zJyxcbiAgZ2l0aHViOiAnaHR0cHM6Ly9naXRodWIuY29tL2NoaW50YWktcGxhdGZvcm0nLFxuICBjaGFpbnM6IFsnZW9zJ11cbn0sIHtcbiAgbmFtZTogJ05ld2RleCcsXG4gIGRlc2NyaXB0aW9uOiAnTmV3ZGV4IGlzIHRoZSBmaXJzdCBFT1MgYmFzZWQgZGVjZW50cmFsaXplZCBleGNoYW5nZSBpbiB0aGUgd29ybGQsIHVwaG9sZGluZyB0aGUgY2hhcmFjdGVyaXN0aWNzIG9mIHNhZmUsIGZhc3QgYW5kIHRyYW5zcGFyZW50LCBkZXZvdGluZyB0byBjcmVhdGUgYSBuZXctZ2VuZXJhdGlvbiBwbGF0Zm9ybSBmb3IgZGlnaXRhbCBhc3NldHMgZXhjaGFuZ2UsIGxlYWRpbmcgdGhlIGluZHVzdHJ5IGludG8gYW4gaWRlYWwgbmV3IGVyYS4nLFxuICBzaG9ydERlc2NyaXB0aW9uOiAnTmV3ZGV4IGlzIHRoZSBmaXJzdCBFT1MgYmFzZWQgZGVjZW50cmFsaXplZCBleGNoYW5nZSBpbiB0aGUgd29ybGQuJyxcbiAgc3ltYm9sOiAnJyxcbiAgYWNjb3VudHM6IFsnbmV3ZGV4cG9ja2V0J10sXG4gIGxvZ286ICdodHRwczovL2Jsb2tzLmlvL2ltZy9kYXBwcy9uZXdkZXgucG5nJyxcbiAgd2Vic2l0ZTogJ2h0dHBzOi8vbmV3ZGV4LmlvJyxcbiAgYXBwOiAnaHR0cHM6Ly9uZXdkZXguaW8nLFxuICB0ZWxlZ3JhbTogJycsXG4gIG1lZGl1bTogJycsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL05ld2RleE9mZmljaWFsJyxcbiAgZ2l0aHViOiAnJyxcbiAgY2hhaW5zOiBbJ2VvcyddXG59LCB7XG4gIG5hbWU6ICdFT1MgTmFtZSBTd2FwcycsXG4gIGRlc2NyaXB0aW9uOiAnQW4gb3Blbi1zb3VyY2UgRU9TIGFjY291bnQgZXhjaGFuZ2UgdGhhdCBwdXRzIHRoZSBzZWN1cml0eSBvZiBpdHMgdXNlcnMgZmlyc3QuJyxcbiAgc2hvcnREZXNjcmlwdGlvbjogJ0FuIG9wZW4tc291cmNlIEVPUyBhY2NvdW50IGV4Y2hhbmdlIHRoYXQgcHV0cyB0aGUgc2VjdXJpdHkgb2YgaXRzIHVzZXJzIGZpcnN0LicsXG4gIHN5bWJvbDogJycsXG4gIHN0YXRpc3RpY3M6IGZhbHNlLFxuICBhY2NvdW50czogWydlb3NuYW1lc3dhcHMnXSxcbiAgbG9nbzogJ2h0dHBzOi8vYmxva3MuaW8vaW1nL2RhcHBzL2Vvc25hbWVzd2Fwcy5wbmcnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly93d3cuZW9zbmFtZXN3YXBzLmNvbS8nLFxuICBhcHA6ICdodHRwczovL3d3dy5lb3NuYW1lc3dhcHMuY29tLycsXG4gIHRlbGVncmFtOiAnaHR0cHM6Ly90Lm1lL2Vvc25hbWVzd2FwcycsXG4gIG1lZGl1bTogJycsXG4gIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tL1N0YXJyeTMwMTdOaWdodCcsXG4gIGdpdGh1YjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9TdGFycnlKYXBhbk5pZ2h0L2Vvc25hbWVzd2FwcycsXG4gIGNoYWluczogWydlb3MnXVxufV07XG5cbnZhciBleGNoYW5nZXMgPSB7XG4gICdCaXRodW1iJzoge1xuICAgICduYW1lJzogJ0JpdGh1bWInLFxuICAgICdkZXNjcmlwdGlvbic6ICfruYTtirjsvZTsnbgsIOydtOuNlOumrOybgCwg67mE7Yq47L2U7J247LqQ7IucLCDrpqztlIwsIOudvOydtO2KuOy9lOyduCwg64yA7IucLCDrqqjrhKTroZwsIOu5hO2KuOy9lOyduOqzqOuTnCwg7J207Jik7IqkLCDsnbTrjZTrpqzsm4DtgbTrnpjsi50sIO2AgO2FgCwg7KCc7Yq47LqQ7IucLCDsi6Tsi5zqsIQg7Iuc7IS4LCDsib3qs6Ag7JWI7KCE7ZWcIOqxsOuemC4nLFxuICAgICdhY2NvdW50cyc6IFsnYml0aHVtYnNoaW55J10sXG4gICAgJ2xvZ28nOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Vvc2NhZmUvZW9zLWRhcHBzL21hc3Rlci9sb2dvcy9wbGFjZWhvbGRlci5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vd3d3LmJpdGh1bWIuY29tLydcbiAgfSxcbiAgJ09LRXgnOiB7XG4gICAgJ25hbWUnOiAnT0tFeCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ09LRXggaXMgdGhlIGxlYWRpbmcgZ2xvYmFsIGJpdGNvaW4gZXhjaGFuZ2UuIFNlY3VyZWQgd2l0aCBiYW5rLWxldmVsIFNTTCBlbmNyeXB0aW9uIGFuZCBjb2xkIHN0b3JhZ2UuJyxcbiAgICAnYWNjb3VudHMnOiBbJ29rZXhvZmZpbGluZSddLFxuICAgICdsb2dvJzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lb3NjYWZlL2Vvcy1kYXBwcy9tYXN0ZXIvbG9nb3MvcGxhY2Vob2xkZXIucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL3d3dy5va2V4LmNvbS8nXG4gIH0sXG4gICdCaXRmaW5leCc6IHtcbiAgICAnbmFtZSc6ICdCaXRmaW5leCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0JpdGZpbmV4IGlzIGEgZnVsbC1mZWF0dXJlZCBzcG90IHRyYWRpbmcgcGxhdGZvcm0gZm9yIG1ham9yIGRpZ2l0YWwgYXNzZXRzICYgY3J5cHRvY3VycmVuY2llcywgaW5jbHVkaW5nIEJpdGNvaW4sIEV0aGVyZXVtLCBFT1MsIExpdGVjb2luLCBSaXBwbGUsIE5FTywgTW9uZXJvIGFuZCBtYW55IG1vcmUuJyxcbiAgICAnYWNjb3VudHMnOiBbJ2JpdGZpbmV4Y3c1NScsICdiaXRmaW5leGN3MTMnLCAnYml0ZmluZXhjdzExJywgJ2JpdGZpbmV4Y3cyNCcsICdiaXRmaW5leGN3MTUnLCAnYml0ZmluZXhjdzMyJywgJ2JpdGZpbmV4Y3cyMScsICdiaXRmaW5leGN3MzEnLCAnYml0ZmluZXhjdzI1JywgJ2JpdGZpbmV4Y3cyMycsICdiaXRmaW5leGN3MzMnLCAnYml0ZmluZXhjdzIyJywgJ2JpdGZpbmV4Y3cxMicsICdiaXRmaW5leGN3MTQnXSxcbiAgICAnbG9nbyc6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZW9zY2FmZS9lb3MtZGFwcHMvbWFzdGVyL2xvZ29zL3BsYWNlaG9sZGVyLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9iaXRmaW5leC5jb20vJ1xuICB9LFxuICAnR2F0ZS5pbyc6IHtcbiAgICAnbmFtZSc6ICdHYXRlLmlvJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnR2F0ZS5pbyBpcyBhIGJpdGNvaW4gZXhjaGFuZ2UgcGxhdGZvcm0gd2hpY2ggc3VwcG9ydHMgQlRDLCBMVEMsIEV0aGVyZXVtLCBRdHVtIGFuZCBtb3JlIGJsb2NrY2hhaW4gYXNzZXRzIHRyYWRpbmcuJyxcbiAgICAnYWNjb3VudHMnOiBbJ2dhdGVpb3dhbGxldCddLFxuICAgICdsb2dvJzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lb3NjYWZlL2Vvcy1kYXBwcy9tYXN0ZXIvbG9nb3MvcGxhY2Vob2xkZXIucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL3d3dy5nYXRlLmlvLydcbiAgfSxcbiAgJ0tyYWtlbic6IHtcbiAgICAnbmFtZSc6ICdLcmFrZW4nLFxuICAgICdkZXNjcmlwdGlvbic6ICdCdXksIHNlbGwgYW5kIG1hcmdpbiB0cmFkZSBCaXRjb2luIChCVEMpIGFuZCBFdGhlcnVtIChFVEgpIGluIGV4Y2hhbmdlIHdpdGggRVVSLCBVU0QsIENBRCwgR0JQLCBhbmQgSlBZLicsXG4gICAgJ2FjY291bnRzJzogWydrcmFrZW5rcmFrZW4nXSxcbiAgICAnbG9nbyc6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZW9zY2FmZS9lb3MtZGFwcHMvbWFzdGVyL2xvZ29zL3BsYWNlaG9sZGVyLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly93d3cua3Jha2VuLmNvbS8nXG4gIH0sXG4gICdOZXdkZXgnOiB7XG4gICAgJ25hbWUnOiAnTmV3ZGV4JyxcbiAgICAnZGVzY3JpcHRpb24nOiAnVGhlIGZpcnN0IEVPUyBiYXNlZCBkZWNlbnRyYWxpemVkIGV4Y2hhbmdlIGluIHRoZSB3b3JsZC4nLFxuICAgICdhY2NvdW50cyc6IFsnbmV3ZGV4cG9ja2V0J10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvbmV3ZGV4LnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9uZXdkZXguaW8vJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKHRva2VuLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL25ld2RleC5pby90cmFkZS9cIiArIHRva2VuLmFjY291bnQgKyBcIi1cIiArIHBhaXIucGFpcl9iYXNlLnRvTG93ZXJDYXNlKCkgKyBcIi1cIiArIHBhaXIucGFpcl9xdW90ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSxcbiAgJ0RlZmlCb3gnOiB7XG4gICAgJ25hbWUnOiAnRGVmaUJveCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ09uZS1zdG9wIERlRmkgYXBwbGljYXRpb24gcGxhdGZvcm0gb24gRU9TLi4nLFxuICAgICdhY2NvdW50cyc6IFsndG9rZW4uZGVmaScsICdzd2FwLmRlZmknXSxcbiAgICAnbG9nbyc6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZW9zY2FmZS9lb3MtYWlyZHJvcHMvbWFzdGVyL2xvZ29zL3Rva2VuLmRlZmktYm94LnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9kZWZpYm94LmlvLycsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBfXykge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9kZWZpYm94LmlvL1wiO1xuICAgIH1cbiAgfSxcbiAgJ0NoYWluY2UnOiB7XG4gICAgJ25hbWUnOiAnQ2hhaW5jZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0EgU3VwZXJpb3IgQmxvY2tjaGFpbiBBc3NldCBUcmFkaW5nIFBsYXRmb3JtIEZvY3VzaW5nIG9uIEVPUyBQcm9qZWN0cycsXG4gICAgJ2FjY291bnRzJzogWydjaGFpbmNlb25lb3MnXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9jaGFpbmNlLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9jaGFpbmNlLmNvbS8nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9jaGFpbmNlLmNvbS90cmFkZS9cIiArIHBhaXIucGFpcl9iYXNlLnRvTG93ZXJDYXNlKCkgKyBwYWlyLnBhaXJfcXVvdGUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0sXG4gICdEZXhlb3MnOiB7XG4gICAgJ25hbWUnOiAnRGV4ZW9zJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnVGhlIFdvcmxkXFwncyBGaXJzdCBFT1MtYmFzZWQgRGVjZW50cmFsaXplZCBFeGNoYW5nZScsXG4gICAgJ2FjY291bnRzJzogWydkZXhlb3N3YWxsZXQnXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9kZXhlb3Muc3ZnJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2RleGVvcy5pby8nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9kZXhlb3MuaW8vdHJhZGUvXCIgKyBwYWlyLnBhaXJfYmFzZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgfSxcbiAgJ0hvbyc6IHtcbiAgICAnbmFtZSc6ICdIb28nLFxuICAgICdkZXNjcmlwdGlvbic6ICdPbmUtc3RvcCBibG9ja2NoYWluIGFzc2V0IHNlcnZpY2UgcGxhdGZvcm0nLFxuICAgICdhY2NvdW50cyc6IFsnaG9vLmNvbSddLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2hvby5qcGcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vaG9vLmNvbS8nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9ob28uY29tL3RyYWRlL1wiICsgcGFpci5wYWlyX2Jhc2UudG9Mb3dlckNhc2UoKSArIFwiLVwiICsgcGFpci5wYWlyX3F1b3RlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuICAnV2hhbGVleCc6IHtcbiAgICAnbmFtZSc6ICdXaGFsZWV4JyxcbiAgICAnZGVzY3JpcHRpb24nOiAnIzEgRGVjZW50cmFsaXplZCBFeGNoYW5nZSBpbiB0aGUgV29ybGQnLFxuICAgICdhY2NvdW50cyc6IFsnd2hhbGVleHRydXN0J10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvd2hhbGVleC5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vd3d3LndoYWxlZXguY29tJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vd3d3LndoYWxlZXguY29tL3RyYWRlL1wiICsgcGFpci5wYWlyX2Jhc2UgKyBcIl9cIiArIHBhaXIucGFpcl9xdW90ZTtcbiAgICB9XG4gIH0sXG4gICdDaGFpbnJpZnQnOiB7XG4gICAgJ25hbWUnOiAnQ2hhaW5yaWZ0JyxcbiAgICAnZGVzY3JpcHRpb24nOiAnQSBtYXJrZXRwbGFjZSBmb3IgZGlnaXRhbCBjdXJyZW5jaWVzJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9jaGFpbnJpZnQucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL3d3dy5jaGFpbnJpZnQuY29tLycsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL3d3dy5jaGFpbnJpZnQuY29tL3RyYWRpbmc/Y29pbnBhaXI9XCIgKyBwYWlyLnBhaXJfYmFzZSArIFwiL1wiICsgcGFpci5wYWlyX3F1b3RlO1xuICAgIH1cbiAgfSxcbiAgJ0Vvc2RhcSc6IHtcbiAgICAnbmFtZSc6ICdFT1NEQVEnLFxuICAgICdkZXNjcmlwdGlvbic6ICdBIFN0YW5kYXJkIG9mIE9uLUNoYWluIERFWCcsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvZW9zZGFxLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly93d3cuZW9zZGFxLmNvbS8nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9lb3NkYXEuY29tL2V4Y2hhbmdlL1wiICsgcGFpci5wYWlyX2Jhc2UgKyBcIl9cIiArIHBhaXIucGFpcl9xdW90ZTtcbiAgICB9XG4gIH0sXG4gICdCaWdPTkUnOiB7XG4gICAgJ25hbWUnOiAnQmlnT05FJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnQSBTdGFuZGFyZCBvZiBPbi1DaGFpbiBERVgnLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2JpZ09ORS5qcGcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vYmlnLm9uZScsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBwYWlyKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL2JpZy5vbmUvdHJhZGUvXCIgKyBwYWlyLnBhaXJfYmFzZSArIFwiLVwiICsgcGFpci5wYWlyX3F1b3RlO1xuICAgIH1cbiAgfSxcbiAgJ1lPTE8nOiB7XG4gICAgJ25hbWUnOiAnWU9MTycsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0luc3RhbnQgVG9rZW4gU3dhcHMgb24gRU9TJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy95b2xvLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly95b2xvc3dhcC5jb20nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly95b2xvc3dhcC5jb20vc3dhcC9cIiArIHBhaXIucGFpcl9xdW90ZS50b0xvd2VyQ2FzZSgpICsgXCItXCIgKyBwYWlyLnBhaXJfYmFzZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSxcbiAgJ0JhbmNvcic6IHtcbiAgICAnbmFtZSc6ICdCYW5jb3InLFxuICAgICdkZXNjcmlwdGlvbic6ICdJbnN0YW50IExpcXVpZGl0eS4nLFxuICAgICdhY2NvdW50cyc6IFtdLFxuICAgICdsb2dvJzogJy9pbWcvZXhjaGFuZ2VzL2JhbmNvci5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vYmFuY29yLm5ldHdvcmsnLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgcGFpcikge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly93d3cuYmFuY29yLm5ldHdvcmsvdG9rZW4vXCIgKyBwYWlyLnBhaXJfYmFzZTtcbiAgICB9XG4gIH0sXG4gICdBbGNvcic6IHtcbiAgICAnbmFtZSc6ICdBbGNvcicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ1RoZSBmaXJzdCBzZWxmLWxpc3RpbmcgZGVjZW50cmFsaXplZCBleGNoYW5nZScsXG4gICAgJ2FjY291bnRzJzogW10sXG4gICAgJ2xvZ28nOiAnL2ltZy9leGNoYW5nZXMvYWxjb3IucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2FsY29yLmV4Y2hhbmdlJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIF9fKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL3d3dy5hbGNvci5leGNoYW5nZS9tYXJrZXRzXCI7XG4gICAgfVxuICB9LFxuICAnRGVmaXMuTmV0d29yayc6IHtcbiAgICAnbmFtZSc6ICdEZWZpcy5OZXR3b3JrJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnQW4gb3BlbiBmaW5hbmNlIG5ldHdvcmsgdGhhdCBpbnRlZ3JhdGVzIGEgc2VyaWVzIG9mIERlRmkgcHJvdG9jb2xzJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9kZWZpcy11bmNhY2hlLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9kZWZpcy5uZXR3b3JrJyxcbiAgICBsaW5rR2VuZXJhdG9yOiBmdW5jdGlvbiBsaW5rR2VuZXJhdG9yKF8sIF9fKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL2FwcHMuZGVmaXMubmV0d29yay9cIjtcbiAgICB9XG4gIH0sXG4gICdEb2xwaGluU3dhcCc6IHtcbiAgICAnbmFtZSc6ICdEb2xwaGluU3dhcCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0RvbHBoaW5Td2FwJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9kb2xwaGluc3dhcC5wbmcnLFxuICAgICd3ZWJzaXRlJzogJ2h0dHBzOi8vZG9scGhpbnN3YXAuaW8vZXhjaGFuZ2UnLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgX18pIHtcbiAgICAgIHJldHVybiAnaHR0cHM6Ly9kb2xwaGluc3dhcC5pby9leGNoYW5nZSc7XG4gICAgfVxuICB9LFxuICAnUHJvdG9uJzoge1xuICAgICduYW1lJzogJ1Byb3RvblN3YXAnLFxuICAgICdkZXNjcmlwdGlvbic6ICdQcm90b25Td2FwJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9wcm90b25zd2FwLnBuZycsXG4gICAgJ3dlYnNpdGUnOiAnaHR0cHM6Ly9wcm90b25zd2FwLmNvbScsXG4gICAgbGlua0dlbmVyYXRvcjogZnVuY3Rpb24gbGlua0dlbmVyYXRvcihfLCBfXykge1xuICAgICAgcmV0dXJuICdodHRwczovL3Byb3RvbnN3YXAuY29tJztcbiAgICB9XG4gIH0sXG4gICdDb2luZ2Vja28nOiB7XG4gICAgJ25hbWUnOiAnQ29pbkdlY2tvJyxcbiAgICAnZGVzY3JpcHRpb24nOiAnQ29pbkdlY2tvJyxcbiAgICAnYWNjb3VudHMnOiBbXSxcbiAgICAnbG9nbyc6ICcvaW1nL2V4Y2hhbmdlcy9jb2luZ2Vja28ucG5nJyxcbiAgICAnd2Vic2l0ZSc6ICdodHRwczovL2NvaW5nZWNrby5jb20nLFxuICAgIGxpbmtHZW5lcmF0b3I6IGZ1bmN0aW9uIGxpbmtHZW5lcmF0b3IoXywgX18pIHtcbiAgICAgIHJldHVybiAnaHR0cHM6Ly9jb2luZ2Vja28uY29tJztcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTQ0FUVEVSX0RFU0tUT1AgPSAnU2NhdHRlclNvY2tldHMnO1xudmFyIFNDQVRURVJfREVTS1RPUF9NQU5VQUwgPSAnU2NhdHRlclNvY2tldHNNYW51YWwnO1xudmFyIFNDQVRURVJfRVhURU5TSU9OID0gJ1NjYXR0ZXJFeHRlbnNpb24nO1xudmFyIExFREdFUiA9ICdsZWRnZXInO1xudmFyIExFREdFUl9VU0IgPSAnVHJhbnNwb3J0VTJGJztcbnZhciBMRURHRVJfQkxFID0gJ1RyYW5zcG9ydFdlYkJMRSc7XG52YXIgTEVER0VSX1dFQlVTQiA9ICdUcmFuc3BvcnRXZWJ1c2InO1xudmFyIExFREdFUl9XRUJISUQgPSAnVHJhbnNwb3J0V2ViSElEJztcbnZhciBMWU5YID0gJ2x5bngnO1xudmFyIFBST1RPTiA9ICdwcm90b24nO1xudmFyIFBST1RPTl9XRUIgPSAncHJvdG9ud2ViJztcbnZhciBBTkNIT1IgPSAnYW5jaG9yJztcbnZhciBTSU1QTEVPUyA9ICdzaW1wbGVvcyc7XG52YXIgRU9TQVVUSCA9ICdlb3NhdXRoJztcbnZhciBDTEVPUyA9ICdjbGVvcyc7XG52YXIgRU9TQyA9ICdlb3NjJztcbnZhciBDTElPID0gJ2NsaW8nO1xudmFyIEtFWUNBVCA9ICdrZXljYXQnO1xudmFyIFRSRVpPUiA9ICd0cmV6b3InO1xudmFyIFNRUkwgPSAnc3FybCc7XG52YXIgV09NQkFUID0gJ3dvbWJhdCc7XG52YXIgV0FYX0NMT1VEX1dBTExFVCA9ICdXYXhDVyc7XG5cbnZhciBoaXN0b3J5VHlwZXNGZWF0dXJlcyA9IHtcbiAgXCJuYXRpdmVcIjoge1xuICAgIG5hbWU6ICduYXRpdmUnLFxuICAgIGFjdGlvbkZpbHRlcjogZmFsc2UsXG4gICAgdG9rZW5GaWx0ZXI6IGZhbHNlLFxuICAgIGRhdGVGaWx0ZXI6IGZhbHNlLFxuICAgIGNvbnRyYWN0QWN0aW9uRmlsdGVyOiBmYWxzZSxcbiAgICB0b3RhbDogMFxuICB9LFxuICBkZnVzZToge1xuICAgIG5hbWU6ICdkZnVzZScsXG4gICAgYWN0aW9uRmlsdGVyOiB0cnVlLFxuICAgIHRva2VuRmlsdGVyOiB0cnVlLFxuICAgIGRhdGVGaWx0ZXI6IHRydWUsXG4gICAgY29udHJhY3RBY3Rpb25GaWx0ZXI6IHRydWUsXG4gICAgdG90YWw6IDRcbiAgfSxcbiAgaHlwZXJpb246IHtcbiAgICBuYW1lOiAnaHlwZXJpb24nLFxuICAgIGFjdGlvbkZpbHRlcjogdHJ1ZSxcbiAgICB0b2tlbkZpbHRlcjogdHJ1ZSxcbiAgICBkYXRlRmlsdGVyOiB0cnVlLFxuICAgIGNvbnRyYWN0QWN0aW9uRmlsdGVyOiB0cnVlLFxuICAgIHRvdGFsOiAzXG4gIH1cbn07XG5cbnZhciBfY2hhaW5JbmZvO1xuXG52YXIgY2hhaW5JbmZvID0gKF9jaGFpbkluZm8gPSB7fSwgX2NoYWluSW5mb1sncHJvdG9uLXRlc3QnXSA9IHtcbiAga2V5OiAncHJvdG9uLXRlc3QnLFxuICB0ZXh0OiAnUHJvdG9uIFRlc3RuZXQnLFxuICB2YWx1ZTogJ2h0dHBzOi8vdGVzdG5ldC5wcm90b25zY2FuLmlvJyxcbiAgaW1hZ2U6ICcvaW1nL2NoYWlucy9wcm90b24ucG5nJyxcbiAgdGVzdG5ldDogdHJ1ZVxufSwgX2NoYWluSW5mby5sb2NhbCA9IHtcbiAga2V5OiAnbG9jYWwnLFxuICB0ZXh0OiAnTG9jYWwgVGVzdG5ldCcsXG4gIHZhbHVlOiAnaHR0cHM6Ly9sb2NhbC5ibG9rcy5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMvbG9jYWwucG5nJyxcbiAgdGVzdG5ldDogdHJ1ZVxufSwgX2NoYWluSW5mb1snd2F4LXRlc3QnXSA9IHtcbiAga2V5OiAnd2F4LXRlc3QnLFxuICB0ZXh0OiAnV0FYIFRlc3RuZXQnLFxuICB2YWx1ZTogJ2h0dHBzOi8vd2F4LXRlc3QuYmxva3MuaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL3dheC5wbmcnLFxuICB0ZXN0bmV0OiB0cnVlXG59LCBfY2hhaW5JbmZvWydmaW8tdGVzdCddID0ge1xuICBrZXk6ICdmaW8tdGVzdCcsXG4gIHRleHQ6ICdGSU8gVGVzdG5ldCcsXG4gIHZhbHVlOiAnaHR0cHM6Ly9maW8tdGVzdC5ibG9rcy5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMvZmlvLnBuZycsXG4gIHRlc3RuZXQ6IHRydWVcbn0sIF9jaGFpbkluZm8uanVuZ2xlMyA9IHtcbiAga2V5OiAnanVuZ2xlMycsXG4gIHRleHQ6ICdKdW5nbGUzIFRlc3RuZXQnLFxuICB2YWx1ZTogJ2h0dHBzOi8vanVuZ2xlMy5ibG9rcy5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMvanVuZ2xlLnBuZycsXG4gIHRlc3RuZXQ6IHRydWVcbn0sIF9jaGFpbkluZm8ua3lsaW4gPSB7XG4gIGtleTogJ2t5bGluJyxcbiAgdGV4dDogJ0t5bGluIFRlc3RuZXQnLFxuICB2YWx1ZTogJ2h0dHBzOi8va3lsaW4uYmxva3MuaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL2t5bGluLnBuZycsXG4gIHRlc3RuZXQ6IHRydWVcbn0sIF9jaGFpbkluZm8ucHJvdG9uID0ge1xuICBrZXk6ICdwcm90b24nLFxuICB0ZXh0OiAnUHJvdG9uJyxcbiAgdmFsdWU6ICdodHRwczovL3Byb3RvbnNjYW4uaW8nLFxuICBpbWFnZTogJy9pbWcvY2hhaW5zL3Byb3Rvbi5wbmcnXG59LCBfY2hhaW5JbmZvLmVvcyA9IHtcbiAga2V5OiAnZW9zJyxcbiAgdGV4dDogJ0VPUycsXG4gIHZhbHVlOiAnaHR0cHM6Ly9ibG9rcy5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMvZW9zLnBuZydcbn0sIF9jaGFpbkluZm8ud2F4ID0ge1xuICBrZXk6ICd3YXgnLFxuICB0ZXh0OiAnV0FYJyxcbiAgdmFsdWU6ICdodHRwczovL3dheC5ibG9rcy5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMvd2F4LnBuZydcbn0sIF9jaGFpbkluZm8uZmlvID0ge1xuICBrZXk6ICdmaW8nLFxuICB0ZXh0OiAnRklPJyxcbiAgdmFsdWU6ICdodHRwczovL2Zpby5ibG9rcy5pbycsXG4gIGltYWdlOiAnL2ltZy9jaGFpbnMvZmlvLnBuZydcbn0sIF9jaGFpbkluZm8pO1xuXG52YXIgZ2V0Q29tbW9uQ29uc3RhbnRzID0gZnVuY3Rpb24gZ2V0Q29tbW9uQ29uc3RhbnRzKGNoYWluKSB7XG4gIHJldHVybiB7XG4gICAgTUFYX1JQQ19TWU5DX1NFQ09ORFNfQkVISU5EOiAyMCxcbiAgICBJTUFHRV9QUk9YWTogJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9pbWFnZS1wcm94eScsXG4gICAgV1JBUF9DT05UUkFDVDogJ3Byb3Rvbi53cmFwJyxcbiAgICBCTE9LU19BUEk6ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8nLFxuICAgIEVTUl9QUk9UT0NPTDogY2hhaW4gPT09ICdwcm90b24nID8gJ3Byb3RvbicgOiAncHJvdG9uLWRldicsXG4gICAgTUVUQUxfUFJPVE9OX0VORFBPSU5UOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyAnaHR0cHM6Ly9hcGkucHJvdG9uY2hhaW4uY29tJyA6ICdodHRwczovL2FwaS1kZXYucHJvdG9uY2hhaW4uY29tJyxcbiAgICBTV0FQX1VSTDogY2hhaW4gPT09ICdwcm90b24nID8gJ2h0dHBzOi8vb3RjLnByb3RvbnN3YXAuY29tJyA6ICdodHRwczovL290Yy10ZXN0LnByb3RvbnN3YXAuY29tJyxcbiAgICBXUkFQX1NFUlZFUl9VUkw6IGNoYWluID09PSAncHJvdG9uJyA/ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vcHJvdG9uLXdyYXAtcHVibGljMicgOiAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL3Byb3Rvbi13cmFwLXRlc3RuZXQtcHVibGljMidcbiAgfTtcbn07XG5cbnZhciBnZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhjaGFpbklkLCBhY3Rpb25FbmRwb2ludHMpIHtcbiAgcmV0dXJuIFt7XG4gICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICBwb3J0OiA0NDMsXG4gICAgcHJvdG9jb2w6ICdodHRwcycsXG4gICAgaG9zdDogYWN0aW9uRW5kcG9pbnRzWzBdLnN1YnN0cig4KSxcbiAgICBodHRwRW5kcG9pbnQ6IGFjdGlvbkVuZHBvaW50c1swXSxcbiAgICBibG9ja2NoYWluOiAnZW9zJ1xuICB9XTtcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyA9IFsnaHR0cHM6Ly9lb3MuZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vZW9zLmVvc2NhZmVibG9jay5jb20nLCAnaHR0cHM6Ly9hcGkubWFpbi5hbG9oYWVvcy5jb20nLCAnaHR0cHM6Ly9hcGkuZW9zc3dlZGVuLm9yZyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTID0gWydodHRwczovL2Vvcy5ncmV5bWFzcy5jb20nXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTID0gWydodHRwczovL2Vvcy5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9hcGkuZW9zc3dlZGVuLm9yZyddO1xudmFyIEFMT0hBX1BST1hZX1VSTCA9ICdodHRwczovL3d3dy5hbG9oYWVvcy5jb20vdm90ZS9wcm94eSc7XG52YXIgQVBJX1VSTCA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8nO1xudmFyIEFUT01JQ0FTU0VUU19BUEkgPSAnaHR0cHM6Ly9lb3MuYXBpLmF0b21pY2Fzc2V0cy5pbyc7XG52YXIgQkxPS1NfUFJPWFkgPSAnYmxva3Npb3Byb3h5JztcbnZhciBDSEFJTiA9ICdlb3MnO1xudmFyIENIQUlOX0lEID0gJ2FjYTM3NmYyMDZiOGZjMjVhNmVkNDRkYmRjNjY1NDdjMzZjNmMzM2UzYTExOWZmYmVhZWY5NDM2NDJmMGU5MDYnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJzIwMTgtMDYtMDgnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiA9IDQ7XG52YXIgQ09SRV9TWU1CT0wgPSAnRU9TJztcbnZhciBESVNQTEFZX0NIQUlOID0gJ0VPUyc7XG52YXIgRE9NQUlOX1RJVExFID0gJ0VPUyBCbG9rcy5pbyc7XG52YXIgSElTVE9SWV9UWVBFUyA9IFsnbmF0aXZlJywgJ2h5cGVyaW9uJ107XG52YXIgSFlQRVJJT05fVVJMID0gJ2h0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pbyc7XG52YXIgS0VZX1BSRUZJWCA9ICdFT1MnO1xudmFyIExJR0hUX0FQSSA9ICdodHRwczovL2FwaS5saWdodC54ZW9zLm1lJztcbnZhciBORlRTX0VOQUJMRUQgPSB0cnVlO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lELCBBQ1RJT05TX0VORFBPSU5UUyk7XG52YXIgUkVYX0VOQUJMRUQgPSB0cnVlO1xudmFyIFNJTVBMRUFTU0VUU19BUEkgPSAnaHR0cHM6Ly9lb3MuYXBpLnNpbXBsZWFzc2V0cy5pbyc7XG52YXIgU1VQUE9SVFNfRlJFRV9DUFUgPSB0cnVlO1xudmFyIFNVUFBPUlRTX1JFTlRCVyA9IHRydWU7XG52YXIgVk9USU5HX0VOQUJMRUQgPSB0cnVlO1xudmFyIGNvbnN0YW50cyA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTLFxuICBBTE9IQV9QUk9YWV9VUkw6IEFMT0hBX1BST1hZX1VSTCxcbiAgQVBJX1VSTDogQVBJX1VSTCxcbiAgQVRPTUlDQVNTRVRTX0FQSTogQVRPTUlDQVNTRVRTX0FQSSxcbiAgQkxPS1NfUFJPWFk6IEJMT0tTX1BST1hZLFxuICBDSEFJTjogQ0hBSU4sXG4gIENIQUlOX0lEOiBDSEFJTl9JRCxcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSxcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OLFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyxcbiAgRElTUExBWV9DSEFJTjogRElTUExBWV9DSEFJTixcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMsXG4gIEhZUEVSSU9OX1VSTDogSFlQRVJJT05fVVJMLFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYLFxuICBMSUdIVF9BUEk6IExJR0hUX0FQSSxcbiAgTkZUU19FTkFCTEVEOiBORlRTX0VOQUJMRUQsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTLFxuICBSRVhfRU5BQkxFRDogUkVYX0VOQUJMRUQsXG4gIFNJTVBMRUFTU0VUU19BUEk6IFNJTVBMRUFTU0VUU19BUEksXG4gIFNVUFBPUlRTX0ZSRUVfQ1BVOiBTVVBQT1JUU19GUkVFX0NQVSxcbiAgU1VQUE9SVFNfUkVOVEJXOiBTVVBQT1JUU19SRU5UQlcsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMsXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRFxufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJDEgPSBbJ2h0dHBzOi8vd2F4LmdyZXltYXNzLmNvbScsICdodHRwczovL3dheC5lb3NjYWZlYmxvY2suY29tJywgJ2h0dHBzOi8vYXBpLndheHN3ZWRlbi5vcmcnLCAnaHR0cHM6Ly9jaGFpbi53YXguaW8nLCAnaHR0cHM6Ly93YXguZW9zcmlvLmlvJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkMSA9IFsnaHR0cHM6Ly93YXguZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vYXBpLndheHN3ZWRlbi5vcmcnLCAnaHR0cHM6Ly93YXguZW9zcmlvLmlvJywgJ2h0dHBzOi8vY2hhaW4ud2F4LmlvJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQxID0gWydodHRwczovL3dheC5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9hcGkud2F4c3dlZGVuLm9yZycsICdodHRwczovL3dheC5lb3NyaW8uaW8nLCAnaHR0cHM6Ly9jaGFpbi53YXguaW8nXTtcbnZhciBBTE9IQV9QUk9YWV9VUkwkMSA9ICdodHRwczovL3d3dy5hbG9oYWVvcy5jb20vdm90ZS9wcm94eS93YXhtYWluJztcbnZhciBBUElfVVJMJDEgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL3dheCc7XG52YXIgQVRPTUlDQVNTRVRTX0FQSSQxID0gJ2h0dHBzOi8vd2F4LmFwaS5hdG9taWNhc3NldHMuaW8nO1xudmFyIEJMT0tTX1BST1hZJDEgPSAnYmxva3Npb3Byb3h5JztcbnZhciBDSEFJTiQxID0gJ3dheCc7XG52YXIgQ0hBSU5fSUQkMSA9ICcxMDY0NDg3YjNjZDFhODk3Y2UwM2FlNWI2YTg2NTY1MTc0N2UyZTE1MjA5MGY5OWMxZDE5ZDQ0ZTAxYWVhNWE0JztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJDEgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJzIwMTktMDYtMjQnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiQxID0gODtcbnZhciBDT1JFX1NZTUJPTCQxID0gJ1dBWCc7XG52YXIgRElTUExBWV9DSEFJTiQxID0gJ1dBWCc7XG52YXIgRE9NQUlOX1RJVExFJDEgPSAnV0FYIHwgQmxva3MuaW8nO1xudmFyIEhJU1RPUllfVFlQRVMkMSA9IFsnbmF0aXZlJywgJ2h5cGVyaW9uJ107XG52YXIgSFlQRVJJT05fVVJMJDEgPSAnaHR0cHM6Ly93YXguZW9zcmlvLmlvJztcbnZhciBLRVlfUFJFRklYJDEgPSAnRU9TJztcbnZhciBMSUdIVF9BUEkkMSA9ICdodHRwczovL2xpZ2h0YXBpLmVvc2Ftc3RlcmRhbS5uZXQnO1xudmFyIE5GVFNfRU5BQkxFRCQxID0gdHJ1ZTtcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkMSA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJDEsIEFDVElPTlNfRU5EUE9JTlRTJDEpO1xudmFyIFNJTVBMRUFTU0VUU19BUEkkMSA9ICdodHRwczovL3dheC5hcGkuc2ltcGxlYXNzZXRzLmlvJztcbnZhciBWT1RJTkdfRU5BQkxFRCQxID0gdHJ1ZTtcbnZhciBjb25zdGFudHMkMSA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJDEsXG4gIEFMT0hBX1BST1hZX1VSTDogQUxPSEFfUFJPWFlfVVJMJDEsXG4gIEFQSV9VUkw6IEFQSV9VUkwkMSxcbiAgQVRPTUlDQVNTRVRTX0FQSTogQVRPTUlDQVNTRVRTX0FQSSQxLFxuICBCTE9LU19QUk9YWTogQkxPS1NfUFJPWFkkMSxcbiAgQ0hBSU46IENIQUlOJDEsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCQxLFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJDEsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiQxLFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkMSxcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJDEsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kMSxcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkMSxcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyQxLFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCQxLFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJDEsXG4gIExJR0hUX0FQSTogTElHSFRfQVBJJDEsXG4gIE5GVFNfRU5BQkxFRDogTkZUU19FTkFCTEVEJDEsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJDEsXG4gIFNJTVBMRUFTU0VUU19BUEk6IFNJTVBMRUFTU0VUU19BUEkkMSxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQxLFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRUQkMVxufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJDIgPSBbJ2h0dHBzOi8vcHJvdG9uLmdyZXltYXNzLmNvbScsICdodHRwczovL3Byb3Rvbi5jcnlwdG9saW9ucy5pbycsICdodHRwczovL3Byb3Rvbi5lb3N1c2EubmV3cycsIFwiaHR0cHM6Ly9mcmFua2Z1cnQucHJvdG9uZGF0YS5uZXRcIl07XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQyID0gWydodHRwczovL3Byb3Rvbi5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly9wcm90b24uY3J5cHRvbGlvbnMuaW8nXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyQyID0gWydodHRwczovL3Byb3Rvbi5ncmV5bWFzcy5jb20nXTtcbnZhciBBUElfVVJMJDIgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL3Byb3Rvbic7XG52YXIgQVRPTUlDQVNTRVRTX0FQSSQyID0gJ2h0dHBzOi8vcHJvdG9uLmFwaS5hdG9taWNhc3NldHMuaW8nO1xudmFyIENIQUlOJDIgPSAncHJvdG9uJztcbnZhciBDSEFJTl9JRCQyID0gJzM4NGRhODg4MTEyMDI3ZjAzMjE4NTBhMTY5ZjczN2MzM2U1M2IzODhhYWQ0OGI1YWRhY2U0YmFiOTdmNDM3ZTAnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkMiA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnQXByIDIyLCAyMDIwJyk7XG52YXIgQ09SRV9QUkVDSVNJT04kMiA9IDQ7XG52YXIgQ09SRV9TWU1CT0wkMiA9ICdYUFInO1xudmFyIERJU1BMQVlfQ0hBSU4kMiA9ICdQcm90b24nO1xudmFyIERPTUFJTl9USVRMRSQyID0gJ1Byb3RvblNjYW4nO1xudmFyIEhJU1RPUllfVFlQRVMkMiA9IFsnbmF0aXZlJywgJ2h5cGVyaW9uJ107XG52YXIgSFlQRVJJT05fVVJMJDIgPSAnaHR0cDovL3Byb3Rvbi5waW5rLmdnJztcbnZhciBLRVlfUFJFRklYJDIgPSAnRU9TJztcbnZhciBMSUdIVF9BUEkkMiA9ICdodHRwczovL2xpZ2h0YXBpLmVvc2Ftc3RlcmRhbS5uZXQnO1xudmFyIE1BWF9WT1RFUyA9IDQ7XG52YXIgTkZUU19FTkFCTEVEJDIgPSB0cnVlO1xudmFyIFBST1ZJREVSX0VORFBPSU5UUyQyID0gLyojX19QVVJFX18qL2dlbmVyYXRlUHJvdmlkZXJFbmRwb2ludHMoQ0hBSU5fSUQkMiwgQUNUSU9OU19FTkRQT0lOVFMkMik7XG52YXIgVk9USU5HX0VOQUJMRUQkMiA9IHRydWU7XG52YXIgY29uc3RhbnRzJDIgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyQyLFxuICBBUElfVVJMOiBBUElfVVJMJDIsXG4gIEFUT01JQ0FTU0VUU19BUEk6IEFUT01JQ0FTU0VUU19BUEkkMixcbiAgQ0hBSU46IENIQUlOJDIsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCQyLFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJDIsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiQyLFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkMixcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJDIsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kMixcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkMixcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyQyLFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCQyLFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJDIsXG4gIExJR0hUX0FQSTogTElHSFRfQVBJJDIsXG4gIE1BWF9WT1RFUzogTUFYX1ZPVEVTLFxuICBORlRTX0VOQUJMRUQ6IE5GVFNfRU5BQkxFRCQyLFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyQyLFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDIsXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRCQyXG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkMyA9IFsnaHR0cHM6Ly9maW8uZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vZmlvLmVvc3N3ZWRlbi5vcmcnLCAnaHR0cHM6Ly9maW8uZW9zdXNhLm5ld3MnXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDMgPSBbJ2h0dHBzOi8vZmlvLmdyZXltYXNzLmNvbScsICdodHRwczovL2Zpby5lb3Nzd2VkZW4ub3JnJywgJ2h0dHBzOi8vZmlvLmVvc3VzYS5uZXdzJ107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkMyA9IFsnaHR0cHM6Ly9maW8uZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vZmlvLmVvc3N3ZWRlbi5vcmcnLCAnaHR0cHM6Ly9maW8uZW9zdXNhLm5ld3MnXTtcbnZhciBBTE9IQV9QUk9YWV9VUkwkMiA9ICdodHRwczovL3d3dy5hbG9oYWVvcy5jb20vdm90ZS9wcm94eS9maW9tYWluJztcbnZhciBBUElfVVJMJDMgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2Zpbyc7XG52YXIgQ0hBSU4kMyA9ICdmaW8nO1xudmFyIENIQUlOX0lEJDMgPSAnMjFkY2FlNDJjMDE4MjIwMGU5M2Y5NTRhMDc0MDExZjkwNDhhNzYyNGM2ZmU4MWQzYzk1NDFhNjE0YTg4YmQxYyc7XG52YXIgQ0hBSU5fU1RBUlRfREFURSQzID0gLyojX19QVVJFX18qL25ldyBEYXRlKCdNYXIgMjQsIDIwMjAnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiQzID0gOTtcbnZhciBDT1JFX1NZTUJPTCQzID0gJ0ZJTyc7XG52YXIgRElTQUJMRV9NRU1PID0gdHJ1ZTtcbnZhciBESVNQTEFZX0NIQUlOJDMgPSAnRklPJztcbnZhciBET01BSU5fVElUTEUkMyA9ICdGSU8gQmxva3MuaW8nO1xudmFyIEZJT19GRUVTX0FDQ09VTlQgPSAnZmVlc0BibG9rcyc7XG52YXIgSElTVE9SWV9UWVBFUyQzID0gWyduYXRpdmUnLCAnaHlwZXJpb24nXTtcbnZhciBIWVBFUklPTl9VUkwkMyA9ICdodHRwczovL2Zpby5lb3Nzd2VkZW4ub3JnJztcbnZhciBLRVlfUFJFRklYJDMgPSAnRklPJztcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkMyA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJDMsIEFDVElPTlNfRU5EUE9JTlRTJDMpO1xudmFyIFZPVElOR19FTkFCTEVEJDMgPSB0cnVlO1xudmFyIGNvbnN0YW50cyQzID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkMyxcbiAgQUxPSEFfUFJPWFlfVVJMOiBBTE9IQV9QUk9YWV9VUkwkMixcbiAgQVBJX1VSTDogQVBJX1VSTCQzLFxuICBDSEFJTjogQ0hBSU4kMyxcbiAgQ0hBSU5fSUQ6IENIQUlOX0lEJDMsXG4gIENIQUlOX1NUQVJUX0RBVEU6IENIQUlOX1NUQVJUX0RBVEUkMyxcbiAgQ09SRV9QUkVDSVNJT046IENPUkVfUFJFQ0lTSU9OJDMsXG4gIENPUkVfU1lNQk9MOiBDT1JFX1NZTUJPTCQzLFxuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkMyxcbiAgRElTQUJMRV9NRU1POiBESVNBQkxFX01FTU8sXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kMyxcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkMyxcbiAgRklPX0ZFRVNfQUNDT1VOVDogRklPX0ZFRVNfQUNDT1VOVCxcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyQzLFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCQzLFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJDMsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJDMsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkMyxcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEJDNcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyQ0ID0gW107XG52YXIgQUNUSU9OU19FTkRQT0lOVFMkNCA9IFtdO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkNCA9IFtdO1xudmFyIEFQSV9VUkwkNCA9ICcnO1xudmFyIENIQUlOJDQgPSAnbG9jYWwnO1xudmFyIENIQUlOX0lEJDQgPSAnJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJDQgPSB1bmRlZmluZWQ7XG52YXIgQ09SRV9QUkVDSVNJT04kNCA9IDQ7XG52YXIgQ09SRV9TWU1CT0wkNCA9ICdFT1MnO1xudmFyIERJU1BMQVlfQ0hBSU4kNCA9ICdMb2NhbCc7XG52YXIgRE9NQUlOX1RJVExFJDQgPSAnTG9jYWwgQmxva3MuaW8nO1xudmFyIEhJU1RPUllfVFlQRVMkNCA9IFsnbmF0aXZlJ107XG52YXIgS0VZX1BSRUZJWCQ0ID0gJ0VPUyc7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJDQgPSBbXTtcbnZhciBWT1RJTkdfRU5BQkxFRCQ0ID0gdHJ1ZTtcbnZhciBjb25zdGFudHMkNCA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJDQsXG4gIEFQSV9VUkw6IEFQSV9VUkwkNCxcbiAgQ0hBSU46IENIQUlOJDQsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCQ0LFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJDQsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiQ0LFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkNCxcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJDQsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kNCxcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkNCxcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyQ0LFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJDQsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJDQsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkNCxcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEJDRcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyQ1ID0gWy8vICdodHRwczovL2p1bmdsZWFwaS5lb3Nzd2VkZW4ub3JnJyxcbidodHRwczovL2FwaS5qdW5nbGUuYWxvaGFlb3MuY29tJywgJ2h0dHBzOi8vanVuZ2xlMi5jcnlwdG9saW9ucy5pbycsICdodHRwczovL2p1bmdsZS5lb3NwaGVyZS5pbycsICdodHRwczovL2Vvcy1qdW5nbGUuZW9zYmxvY2tzbWl0aC5pbyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJDUgPSBbJ2h0dHBzOi8vanVuZ2xlLmVvc3N3ZWRlbi5vcmcnXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDUgPSBbJ2h0dHBzOi8vanVuZ2xlLmVvc3N3ZWRlbi5vcmcnXTtcbnZhciBBUElfVVJMJDUgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL2p1bmdsZSc7XG52YXIgQkxPS1NfUFJPWFkkMiA9ICdibG9rc3BhcnRuZXInO1xudmFyIENIQUlOJDUgPSAnanVuZ2xlJztcbnZhciBDSEFJTl9JRCQ1ID0gJ2U3MGFhYWI4OTk3ZTFkZmNlNThmYmZhYzgwY2JiYjhmZWNlYzdiOTljZjk4MmE5NDQ0MjczY2JjNjRjNDE0NzMnO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkNSA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnTm92IDIzLCAyMDE4Jyk7XG52YXIgQ09SRV9QUkVDSVNJT04kNSA9IDQ7XG52YXIgQ09SRV9TWU1CT0wkNSA9ICdFT1MnO1xudmFyIERJU1BMQVlfQ0hBSU4kNSA9ICdKdW5nbGUnO1xudmFyIERPTUFJTl9USVRMRSQ1ID0gJ0p1bmdsZSBCbG9rcy5pbyc7XG52YXIgSElTVE9SWV9UWVBFUyQ1ID0gWydoeXBlcmlvbicsICduYXRpdmUnXTtcbnZhciBIWVBFUklPTl9VUkwkNCA9ICdodHRwczovL2p1bmdsZTIuY3J5cHRvbGlvbnMuaW8nO1xudmFyIEtFWV9QUkVGSVgkNSA9ICdFT1MnO1xudmFyIExJR0hUX0FQSSQzID0gJ2h0dHBzOi8vbGlnaHRhcGkuZW9zZ2VuZXZhLmlvJztcbnZhciBORlRTX0VOQUJMRUQkMyA9IHRydWU7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJDUgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCQ1LCBBQ1RJT05TX0VORFBPSU5UUyQ1KTtcbnZhciBSRVhfRU5BQkxFRCQxID0gdHJ1ZTtcbnZhciBWT1RJTkdfRU5BQkxFRCQ1ID0gdHJ1ZTtcbnZhciBjb25zdGFudHMkNSA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJDUsXG4gIEFQSV9VUkw6IEFQSV9VUkwkNSxcbiAgQkxPS1NfUFJPWFk6IEJMT0tTX1BST1hZJDIsXG4gIENIQUlOOiBDSEFJTiQ1LFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkNSxcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSQ1LFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kNSxcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJDUsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyQ1LFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJDUsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJDUsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkNSxcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwkNCxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCQ1LFxuICBMSUdIVF9BUEk6IExJR0hUX0FQSSQzLFxuICBORlRTX0VOQUJMRUQ6IE5GVFNfRU5BQkxFRCQzLFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyQ1LFxuICBSRVhfRU5BQkxFRDogUkVYX0VOQUJMRUQkMSxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ1LFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRUQkNVxufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJDYgPSBbJ2h0dHBzOi8vanVuZ2xlMy5jcnlwdG9saW9ucy5pbycsICdodHRwczovL2FwaS5qdW5nbGUzLmFsb2hhZW9zLmNvbScsICdodHRwczovL2p1bmdsZTMuZW9zdXNhLm5ld3MnXTtcbnZhciBBQ1RJT05TX0VORFBPSU5UUyQ2ID0gWydodHRwczovL2p1bmdsZTMuY3J5cHRvbGlvbnMuaW8nLCAnaHR0cHM6Ly9qdW5nbGUzLmVvc3VzYS5uZXdzJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ2ID0gWydodHRwczovL2p1bmdsZTMuY3J5cHRvbGlvbnMuaW8nLCAnaHR0cHM6Ly9qdW5nbGUzLmVvc3VzYS5uZXdzJ107XG52YXIgQVBJX1VSTCQ2ID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9qdW5nbGUzJztcbnZhciBDSEFJTiQ2ID0gJ2p1bmdsZTMnO1xudmFyIENIQUlOX0lEJDYgPSAnMmEwMmEwMDUzZTVhOGNmNzNhNTZiYTBmZGExMWU0ZDkyZTAyMzhhNGEyYWE3NGZjY2Y0NmQ1YTkxMDc0Njg0MCc7XG52YXIgQ0hBSU5fU1RBUlRfREFURSQ2ID0gLyojX19QVVJFX18qL25ldyBEYXRlKCdGZWIgMTksIDIwMjAnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiQ2ID0gNDtcbnZhciBDT1JFX1NZTUJPTCQ2ID0gJ0VPUyc7XG52YXIgRElTUExBWV9DSEFJTiQ2ID0gJ0p1bmdsZSAzJztcbnZhciBET01BSU5fVElUTEUkNiA9ICdKdW5nbGUgMyBCbG9rcy5pbyc7XG52YXIgSElTVE9SWV9UWVBFUyQ2ID0gWydoeXBlcmlvbiddO1xudmFyIEhZUEVSSU9OX1VSTCQ1ID0gJ2h0dHBzOi8vanVuZ2xlMy5jcnlwdG9saW9ucy5pbyc7XG52YXIgS0VZX1BSRUZJWCQ2ID0gJ0VPUyc7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJDYgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCQ2LCBBQ1RJT05TX0VORFBPSU5UUyQ2KTtcbnZhciBSRVhfRU5BQkxFRCQyID0gdHJ1ZTtcbnZhciBTVVBQT1JUU19SRU5UQlckMSA9IHRydWU7XG52YXIgVk9USU5HX0VOQUJMRUQkNiA9IHRydWU7XG52YXIgY29uc3RhbnRzJDYgPSB7XG4gIEFDVElPTlNfRU5EUE9JTlRTOiBBQ1RJT05TX0VORFBPSU5UUyQ2LFxuICBBUElfVVJMOiBBUElfVVJMJDYsXG4gIENIQUlOOiBDSEFJTiQ2LFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkNixcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSQ2LFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kNixcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJDYsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyQ2LFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJDYsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJDYsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkNixcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwkNSxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCQ2LFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyQ2LFxuICBSRVhfRU5BQkxFRDogUkVYX0VOQUJMRUQkMixcbiAgU1VQUE9SVFNfUkVOVEJXOiBTVVBQT1JUU19SRU5UQlckMSxcbiAgVFJBTlNBQ1RJT05TX0VORFBPSU5UUzogVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ2LFxuICBWT1RJTkdfRU5BQkxFRDogVk9USU5HX0VOQUJMRUQkNlxufTtcblxudmFyIERFRkFVTFRfRU5EUE9JTlRTJDcgPSBbJ2h0dHBzOi8va3lsaW4uZW9zbi5pbyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJDcgPSBbJ2h0dHBzOi8va3lsaW4uZW9zbi5pbyddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkNyA9IFsnaHR0cHM6Ly9reWxpbi5lb3NuLmlvJ107XG52YXIgQVBJX1VSTCQ3ID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9reWxpbic7XG52YXIgQkxPS1NfUFJPWFkkMyA9ICdibG9rc3BhcnRuZXInO1xudmFyIENIQUlOJDcgPSAna3lsaW4nO1xudmFyIENIQUlOX0lEJDcgPSAnNWZmZjFkYWU4ZGM4ZTJmYzRkNWIyM2IyYzc2NjVjOTdmOWU5ZDhlZGYyYjY0ODVhODZiYTMxMWMyNTYzOTE5MSc7XG52YXIgQ0hBSU5fU1RBUlRfREFURSQ3ID0gLyojX19QVVJFX18qL25ldyBEYXRlKCdKdWwgMTAsIDIwMTgnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiQ3ID0gNDtcbnZhciBDT1JFX1NZTUJPTCQ3ID0gJ0VPUyc7XG52YXIgRElTUExBWV9DSEFJTiQ3ID0gJ0t5bGluJztcbnZhciBET01BSU5fVElUTEUkNyA9ICdLeWxpbiBCbG9rcy5pbyc7XG52YXIgSElTVE9SWV9UWVBFUyQ3ID0gWydoeXBlcmlvbicsICduYXRpdmUnXTtcbnZhciBIWVBFUklPTl9VUkwkNiA9ICdodHRwczovL2t5bGluLmVvc3VzYS5uZXdzJztcbnZhciBLRVlfUFJFRklYJDcgPSAnRU9TJztcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkNyA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJDcsIEFDVElPTlNfRU5EUE9JTlRTJDcpO1xudmFyIFZPVElOR19FTkFCTEVEJDcgPSB0cnVlO1xudmFyIGNvbnN0YW50cyQ3ID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkNyxcbiAgQVBJX1VSTDogQVBJX1VSTCQ3LFxuICBCTE9LU19QUk9YWTogQkxPS1NfUFJPWFkkMyxcbiAgQ0hBSU46IENIQUlOJDcsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCQ3LFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJDcsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiQ3LFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkNyxcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJDcsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kNyxcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkNyxcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyQ3LFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCQ2LFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJDcsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJDcsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkNyxcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEJDdcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyQ4ID0gWydodHRwczovL3d3dy5hcGkuYmxva3MuaW8vZW9zLXRlc3Qtbm9kZSddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJDggPSBbJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9lb3MtdGVzdC1ub2RlJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ4ID0gWydodHRwczovL3d3dy5hcGkuYmxva3MuaW8vZW9zLXRlc3Qtbm9kZSddO1xudmFyIEFQSV9VUkwkOCA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vZW9zLXRlc3QnO1xudmFyIENIQUlOJDggPSAnZW9zLXRlc3QnO1xudmFyIENIQUlOX0lEJDggPSAnMGRiMTNhYjliMzIxYzM3YzBiYTg0ODFjYjQ2ODFjMjc4OGI2MjJjM2FiZmQxZjEyZjBlNTM1M2Q0NGJhNmU3Mic7XG52YXIgQ0hBSU5fU1RBUlRfREFURSQ4ID0gLyojX19QVVJFX18qL25ldyBEYXRlKCcyMDIwLTAxLTE0Jyk7XG52YXIgQ09SRV9QUkVDSVNJT04kOCA9IDQ7XG52YXIgQ09SRV9TWU1CT0wkOCA9ICdUTlQnO1xudmFyIERJU1BMQVlfQ0hBSU4kOCA9ICdFT1NJTyBUZXN0JztcbnZhciBET01BSU5fVElUTEUkOCA9ICdCbG9rcy5pbyc7XG52YXIgSElTVE9SWV9UWVBFUyQ4ID0gWyduYXRpdmUnXTtcbnZhciBLRVlfUFJFRklYJDggPSAnRU9TJztcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkOCA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJDgsIEFDVElPTlNfRU5EUE9JTlRTJDgpO1xudmFyIGNvbnN0YW50cyQ4ID0ge1xuICBERUZBVUxUX0VORFBPSU5UUzogREVGQVVMVF9FTkRQT0lOVFMkOCxcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJDgsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkOCxcbiAgQVBJX1VSTDogQVBJX1VSTCQ4LFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyQ4LFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkOCxcbiAgQ0hBSU46IENIQUlOJDgsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kOCxcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyQ4LFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkOCxcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkOCxcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSQ4LFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJDgsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiQ4XG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkOSA9IFsnaHR0cHM6Ly9wcm90b250ZXN0bmV0LmdyZXltYXNzLmNvbScsICdodHRwczovL3Byb3Rvbi10ZXN0bmV0LmVvc2NhZmVibG9jay5jb20nLCAnaHR0cHM6Ly90ZXN0bmV0LnByb3RvbmNoYWluLmNvbScsICdodHRwczovL3Rlc3QucHJvdG9uLmVvc3VzYS5uZXdzJ107XG52YXIgVFJBTlNBQ1RJT05TX0VORFBPSU5UUyQ5ID0gWydodHRwczovL3Byb3RvbnRlc3RuZXQuZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vdGVzdG5ldC5wcm90b25jaGFpbi5jb20nLCAnaHR0cHM6Ly90ZXN0LnByb3Rvbi5lb3N1c2EubmV3cyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJDkgPSBbJ2h0dHBzOi8vcHJvdG9udGVzdG5ldC5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly90ZXN0bmV0LnByb3RvbmNoYWluLmNvbScsICdodHRwczovL3Rlc3QucHJvdG9uLmVvc3VzYS5uZXdzJ107XG52YXIgQVBJX1VSTCQ5ID0gJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9wcm90b24tdGVzdCc7XG52YXIgQVRPTUlDQVNTRVRTX0FQSSQzID0gJ2h0dHBzOi8vdGVzdC5wcm90b24uYXBpLmF0b21pY2Fzc2V0cy5pbyc7XG52YXIgQ0hBSU4kOSA9ICdwcm90b24tdGVzdCc7XG52YXIgQ0hBSU5fSUQkOSA9ICc3MWVlODNiY2Y1MjE0MmQ2MTAxOWQ5NWY5Y2M1NDI3YmE2YTBkN2ZmOGFjY2Q5ZTIwODhhZTJhYmVhZjNkM2RkJztcbnZhciBDSEFJTl9TVEFSVF9EQVRFJDkgPSAvKiNfX1BVUkVfXyovbmV3IERhdGUoJ0FwcmlsIDMsIDIwMjAnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiQ5ID0gNDtcbnZhciBDT1JFX1NZTUJPTCQ5ID0gJ1hQUic7XG52YXIgRElTUExBWV9DSEFJTiQ5ID0gJ1Byb3Rvbi1UJztcbnZhciBET01BSU5fVElUTEUkOSA9ICdQcm90b24gVGVzdG5ldCc7XG52YXIgSElTVE9SWV9UWVBFUyQ5ID0gWydoeXBlcmlvbicsICduYXRpdmUnXTtcbnZhciBIWVBFUklPTl9VUkwkNyA9ICdodHRwczovL3Rlc3RuZXQucHJvdG9uLnBpbmsuZ2cnO1xudmFyIEtFWV9QUkVGSVgkOSA9ICdFT1MnO1xudmFyIE1BWF9WT1RFUyQxID0gNDtcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkOSA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJDksIEFDVElPTlNfRU5EUE9JTlRTJDkpO1xudmFyIFZPVElOR19FTkFCTEVEJDggPSB0cnVlO1xudmFyIGNvbnN0YW50cyQ5ID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkOSxcbiAgQVBJX1VSTDogQVBJX1VSTCQ5LFxuICBBVE9NSUNBU1NFVFNfQVBJOiBBVE9NSUNBU1NFVFNfQVBJJDMsXG4gIENIQUlOOiBDSEFJTiQ5LFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkOSxcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSQ5LFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kOSxcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJDksXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyQ5LFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJDksXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJDksXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkOSxcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwkNyxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCQ5LFxuICBNQVhfVk9URVM6IE1BWF9WT1RFUyQxLFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyQ5LFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJDksXG4gIFZPVElOR19FTkFCTEVEOiBWT1RJTkdfRU5BQkxFRCQ4XG59O1xuXG52YXIgREVGQVVMVF9FTkRQT0lOVFMkYSA9IFsnaHR0cHM6Ly90ZXN0bmV0LndheC5lb3NkZXRyb2l0LmlvJywgJ2h0dHBzOi8vdGVzdG5ldC53YXgucGluay5nZycsICdodHRwczovL3Rlc3RuZXQud2F4c3dlZGVuLm9yZyddO1xudmFyIFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkYSA9IFsnaHR0cHM6Ly90ZXN0bmV0LndheC5lb3NkZXRyb2l0LmlvJywgJ2h0dHBzOi8vdGVzdG5ldC53YXgucGluay5nZycsICdodHRwczovL3Rlc3RuZXQud2F4c3dlZGVuLm9yZyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJGEgPSBbJ2h0dHBzOi8vdGVzdG5ldC53YXguZW9zZGV0cm9pdC5pbycsICdodHRwczovL3Rlc3RuZXQud2F4LnBpbmsuZ2cnLCAnaHR0cHM6Ly90ZXN0bmV0LndheHN3ZWRlbi5vcmcnXTtcbnZhciBBUElfVVJMJGEgPSAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL3dheC10ZXN0JztcbnZhciBBVE9NSUNBU1NFVFNfQVBJJDQgPSAnaHR0cHM6Ly90ZXN0LndheC5hcGkuYXRvbWljYXNzZXRzLmlvJztcbnZhciBDSEFJTiRhID0gJ3dheC10ZXN0JztcbnZhciBDSEFJTl9JRCRhID0gJ2YxNmIxODMzYzc0N2M0MzY4MmY0Mzg2ZmNhOWNiYjMyNzkyOTMzNGE3NjI3NTVlYmVjMTdmNmYyM2M5YjhhMTInO1xudmFyIENIQUlOX1NUQVJUX0RBVEUkYSA9IC8qI19fUFVSRV9fKi9uZXcgRGF0ZSgnRGVjIDUsIDIwMTknKTtcbnZhciBDT1JFX1BSRUNJU0lPTiRhID0gODtcbnZhciBDT1JFX1NZTUJPTCRhID0gJ1dBWCc7XG52YXIgRElTUExBWV9DSEFJTiRhID0gJ1dBWC1UJztcbnZhciBET01BSU5fVElUTEUkYSA9ICdXQVggVGVzdG5ldCBCbG9rcy5pbyc7XG52YXIgSElTVE9SWV9UWVBFUyRhID0gWyduYXRpdmUnLCAnaHlwZXJpb24nXTtcbnZhciBIWVBFUklPTl9VUkwkOCA9ICdodHRwczovL3Rlc3RuZXQud2F4c3dlZGVuLm9yZyc7XG52YXIgS0VZX1BSRUZJWCRhID0gJ0VPUyc7XG52YXIgTElHSFRfQVBJJDQgPSAnaHR0cHM6Ly90ZXN0bmV0LWxpZ2h0YXBpLmVvc2Ftcy54ZW9zLm1lJztcbnZhciBQUk9WSURFUl9FTkRQT0lOVFMkYSA9IC8qI19fUFVSRV9fKi9nZW5lcmF0ZVByb3ZpZGVyRW5kcG9pbnRzKENIQUlOX0lEJGEsIEFDVElPTlNfRU5EUE9JTlRTJGEpO1xudmFyIGNvbnN0YW50cyRhID0ge1xuICBBQ1RJT05TX0VORFBPSU5UUzogQUNUSU9OU19FTkRQT0lOVFMkYSxcbiAgQVBJX1VSTDogQVBJX1VSTCRhLFxuICBBVE9NSUNBU1NFVFNfQVBJOiBBVE9NSUNBU1NFVFNfQVBJJDQsXG4gIENIQUlOOiBDSEFJTiRhLFxuICBDSEFJTl9JRDogQ0hBSU5fSUQkYSxcbiAgQ0hBSU5fU1RBUlRfREFURTogQ0hBSU5fU1RBUlRfREFURSRhLFxuICBDT1JFX1BSRUNJU0lPTjogQ09SRV9QUkVDSVNJT04kYSxcbiAgQ09SRV9TWU1CT0w6IENPUkVfU1lNQk9MJGEsXG4gIERFRkFVTFRfRU5EUE9JTlRTOiBERUZBVUxUX0VORFBPSU5UUyRhLFxuICBESVNQTEFZX0NIQUlOOiBESVNQTEFZX0NIQUlOJGEsXG4gIERPTUFJTl9USVRMRTogRE9NQUlOX1RJVExFJGEsXG4gIEhJU1RPUllfVFlQRVM6IEhJU1RPUllfVFlQRVMkYSxcbiAgSFlQRVJJT05fVVJMOiBIWVBFUklPTl9VUkwkOCxcbiAgS0VZX1BSRUZJWDogS0VZX1BSRUZJWCRhLFxuICBMSUdIVF9BUEk6IExJR0hUX0FQSSQ0LFxuICBQUk9WSURFUl9FTkRQT0lOVFM6IFBST1ZJREVSX0VORFBPSU5UUyRhLFxuICBUUkFOU0FDVElPTlNfRU5EUE9JTlRTOiBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJGFcbn07XG5cbnZhciBERUZBVUxUX0VORFBPSU5UUyRiID0gWydodHRwczovL2Zpb3Rlc3RuZXQuZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vdGVzdC5maW8uZW9zdXNhLm5ld3MnXTtcbnZhciBUUkFOU0FDVElPTlNfRU5EUE9JTlRTJGIgPSBbJ2h0dHBzOi8vZmlvdGVzdG5ldC5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly90ZXN0LmZpby5lb3N1c2EubmV3cyddO1xudmFyIEFDVElPTlNfRU5EUE9JTlRTJGIgPSBbJ2h0dHBzOi8vZmlvdGVzdG5ldC5ncmV5bWFzcy5jb20nLCAnaHR0cHM6Ly90ZXN0LmZpby5lb3N1c2EubmV3cyddO1xudmFyIEFQSV9VUkwkYiA9ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vZmlvLXRlc3QnO1xudmFyIENIQUlOJGIgPSAnZmlvLXRlc3QnO1xudmFyIENIQUlOX0lEJGIgPSAnYjIwOTAxMzgwYWY0NGVmNTljNTkxODQzOWExZjlhNDFkODM2NjkwMjAzMTlhODA1NzRiODA0YTVmOTVjYmQ3ZSc7XG52YXIgQ0hBSU5fU1RBUlRfREFURSRiID0gLyojX19QVVJFX18qL25ldyBEYXRlKCdNYXIgMTAsIDIwMjAnKTtcbnZhciBDT1JFX1BSRUNJU0lPTiRiID0gOTtcbnZhciBDT1JFX1NZTUJPTCRiID0gJ0ZJTyc7XG52YXIgRElTQUJMRV9NRU1PJDEgPSB0cnVlO1xudmFyIERJU1BMQVlfQ0hBSU4kYiA9ICdGSU8gVGVzdCc7XG52YXIgRE9NQUlOX1RJVExFJGIgPSAnRklPIFRlc3QgQmxva3MuaW8nO1xudmFyIEhJU1RPUllfVFlQRVMkYiA9IFsnbmF0aXZlJywgJ2h5cGVyaW9uJ107XG52YXIgSFlQRVJJT05fVVJMJDkgPSAnaHR0cHM6Ly90ZXN0LmZpby5lb3N1c2EubmV3cyc7XG52YXIgS0VZX1BSRUZJWCRiID0gJ0ZJTyc7XG52YXIgUFJPVklERVJfRU5EUE9JTlRTJGIgPSAvKiNfX1BVUkVfXyovZ2VuZXJhdGVQcm92aWRlckVuZHBvaW50cyhDSEFJTl9JRCRiLCBBQ1RJT05TX0VORFBPSU5UUyRiKTtcbnZhciBWT1RJTkdfRU5BQkxFRCQ5ID0gdHJ1ZTtcbnZhciBjb25zdGFudHMkYiA9IHtcbiAgQUNUSU9OU19FTkRQT0lOVFM6IEFDVElPTlNfRU5EUE9JTlRTJGIsXG4gIEFQSV9VUkw6IEFQSV9VUkwkYixcbiAgQ0hBSU46IENIQUlOJGIsXG4gIENIQUlOX0lEOiBDSEFJTl9JRCRiLFxuICBDSEFJTl9TVEFSVF9EQVRFOiBDSEFJTl9TVEFSVF9EQVRFJGIsXG4gIENPUkVfUFJFQ0lTSU9OOiBDT1JFX1BSRUNJU0lPTiRiLFxuICBDT1JFX1NZTUJPTDogQ09SRV9TWU1CT0wkYixcbiAgREVGQVVMVF9FTkRQT0lOVFM6IERFRkFVTFRfRU5EUE9JTlRTJGIsXG4gIERJU0FCTEVfTUVNTzogRElTQUJMRV9NRU1PJDEsXG4gIERJU1BMQVlfQ0hBSU46IERJU1BMQVlfQ0hBSU4kYixcbiAgRE9NQUlOX1RJVExFOiBET01BSU5fVElUTEUkYixcbiAgSElTVE9SWV9UWVBFUzogSElTVE9SWV9UWVBFUyRiLFxuICBIWVBFUklPTl9VUkw6IEhZUEVSSU9OX1VSTCQ5LFxuICBLRVlfUFJFRklYOiBLRVlfUFJFRklYJGIsXG4gIFBST1ZJREVSX0VORFBPSU5UUzogUFJPVklERVJfRU5EUE9JTlRTJGIsXG4gIFRSQU5TQUNUSU9OU19FTkRQT0lOVFM6IFRSQU5TQUNUSU9OU19FTkRQT0lOVFMkYixcbiAgVk9USU5HX0VOQUJMRUQ6IFZPVElOR19FTkFCTEVEJDlcbn07XG5cbnZhciBfY2hhaW5Ub05ldHdvcmtDb25zdGE7XG5cbnZhciBjaGFpblRvTmV0d29ya0NvbnN0YW50c01hcCA9IChfY2hhaW5Ub05ldHdvcmtDb25zdGEgPSB7XG4gIGVvczogY29uc3RhbnRzLFxuICB3YXg6IGNvbnN0YW50cyQxLFxuICBwcm90b246IGNvbnN0YW50cyQyLFxuICBsb2NhbDogY29uc3RhbnRzJDQsXG4gIGp1bmdsZTogY29uc3RhbnRzJDUsXG4gIGp1bmdsZTM6IGNvbnN0YW50cyQ2LFxuICBreWxpbjogY29uc3RhbnRzJDcsXG4gIGZpbzogY29uc3RhbnRzJDNcbn0sIF9jaGFpblRvTmV0d29ya0NvbnN0YVsnZW9zLXRlc3QnXSA9IGNvbnN0YW50cyQ4LCBfY2hhaW5Ub05ldHdvcmtDb25zdGFbJ3Byb3Rvbi10ZXN0J10gPSBjb25zdGFudHMkOSwgX2NoYWluVG9OZXR3b3JrQ29uc3RhWyd3YXgtdGVzdCddID0gY29uc3RhbnRzJGEsIF9jaGFpblRvTmV0d29ya0NvbnN0YVsnZmlvLXRlc3QnXSA9IGNvbnN0YW50cyRiLCBfY2hhaW5Ub05ldHdvcmtDb25zdGEpO1xudmFyIENvbnN0YW50cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbnN0YW50cygpIHtcbiAgICBpZiAoISFDb25zdGFudHMuaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBDb25zdGFudHMuaW5zdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IENvbnN0YW50cy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplKGNoYWluKSB7XG4gICAgaWYgKCFjaGFpbiB8fCAhY2hhaW5Ub05ldHdvcmtDb25zdGFudHNNYXBbY2hhaW5dKSB7XG4gICAgICBjaGFpbiA9IERFRkFVTFRfQ0hBSU47XG4gICAgfVxuXG4gICAgdGhpcy5zZXROZXR3b3JrKGNoYWluKTtcbiAgICB0aGlzLnNldENvbW1vbihjaGFpbik7XG4gIH07XG5cbiAgX3Byb3RvLnNldE5ldHdvcmsgPSBmdW5jdGlvbiBzZXROZXR3b3JrKGNoYWluKSB7XG4gICAgLy8gY29uc3QgbmV0d29ya0NvbnN0YW50cyA9IGF3YWl0IGltcG9ydChgJy4vbmV0d29ya3MvJHtjaGFpbn1gKVxuICAgIHZhciBuZXR3b3JrQ29uc3RhbnRzID0gY2hhaW5Ub05ldHdvcmtDb25zdGFudHNNYXBbY2hhaW5dO1xuICAgIHRoaXMuc2V0Q29uc3RhbnRzKG5ldHdvcmtDb25zdGFudHMpO1xuICAgIHRoaXMuc2V0Q29udHJhY3QoY2hhaW4sIG5ldHdvcmtDb25zdGFudHMuU1lTVEVNX0RPTUFJTik7XG4gIH07XG5cbiAgX3Byb3RvLnNldENvbW1vbiA9IGZ1bmN0aW9uIHNldENvbW1vbihjaGFpbikge1xuICAgIHZhciBjb21tb25Db25zdGFudHMgPSBnZXRDb21tb25Db25zdGFudHMoY2hhaW4pO1xuICAgIHRoaXMuc2V0Q29uc3RhbnRzKGNvbW1vbkNvbnN0YW50cyk7XG4gIH07XG5cbiAgX3Byb3RvLnNldENvbnRyYWN0ID0gZnVuY3Rpb24gc2V0Q29udHJhY3QoY2hhaW4sIHN5c3RlbURvbWFpbikge1xuICAgIGlmIChzeXN0ZW1Eb21haW4gPT09IHZvaWQgMCkge1xuICAgICAgc3lzdGVtRG9tYWluID0gREVGQVVMVF9TWVNURU1fRE9NQUlOO1xuICAgIH1cblxuICAgIHZhciBjb250cmFjdENvbnN0YW50cyA9IGdldENvbnRyYWN0Q29uc3RhbnRzKGNoYWluLCBzeXN0ZW1Eb21haW4pO1xuICAgIHRoaXMuc2V0Q29uc3RhbnRzKGNvbnRyYWN0Q29uc3RhbnRzKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0Q29uc3RhbnRzID0gZnVuY3Rpb24gc2V0Q29uc3RhbnRzKG5ld0NvbnN0YW50cykge1xuICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobmV3Q29uc3RhbnRzKTsgX2kgPCBfT2JqZWN0JGVudHJpZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX09iamVjdCRlbnRyaWVzJF9pID0gX09iamVjdCRlbnRyaWVzW19pXSxcbiAgICAgICAgICBrZXkgPSBfT2JqZWN0JGVudHJpZXMkX2lbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfT2JqZWN0JGVudHJpZXMkX2lbMV07XG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvbnN0YW50cztcbn0oKTtcbnZhciBjb25zdGFudHMkYyA9IC8qI19fUFVSRV9fKi9uZXcgQ29uc3RhbnRzKCk7XG5cbmV4cG9ydCB7IEFOQ0hPUiwgQ0xFT1MsIENMSU8sIENvbnN0YW50cywgREVGQVVMVF9DSEFJTiwgREVGQVVMVF9TWU1CT0wsIERFRkFVTFRfU1lTVEVNX0RPTUFJTiwgRU9TQVVUSCwgRU9TQywgS0VZQ0FULCBMRURHRVIsIExFREdFUl9CTEUsIExFREdFUl9VU0IsIExFREdFUl9XRUJISUQsIExFREdFUl9XRUJVU0IsIExZTlgsIFBST1RPTiwgUFJPVE9OX1dFQiwgU0NBVFRFUl9ERVNLVE9QLCBTQ0FUVEVSX0RFU0tUT1BfTUFOVUFMLCBTQ0FUVEVSX0VYVEVOU0lPTiwgU0lNUExFT1MsIFNRUkwsIFRSRVpPUiwgV0FYX0NMT1VEX1dBTExFVCwgV09NQkFULCBjaGFpbkluZm8sIGNoYWluVG9OZXR3b3JrQ29uc3RhbnRzTWFwLCBjb25zdGFudHMkYyBhcyBjb25zdGFudHMsIGRhcHBzLCBleGNoYW5nZXMsIGdldENvbnRyYWN0Q29uc3RhbnRzLCBoaXN0b3J5VHlwZXNGZWF0dXJlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmVzbS5qcy5tYXBcbiIsIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9udW1iZXJzLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbnVtYmVycy5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIGJpZ251bWJlcl9qcyA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xudmFyIG51bWJybyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAamFmcmkvbnVtYnJvJykpO1xudmFyIGRheWpzID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2RheWpzJykpO1xudmFyIHJlbGF0aXZlVGltZVBsdWdpbiA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdkYXlqcy9wbHVnaW4vcmVsYXRpdmVUaW1lJykpO1xudmFyIHV0Y1BsdWdpbiA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdkYXlqcy9wbHVnaW4vdXRjJykpO1xudmFyIHRpbWV6b25lUGx1Z2luID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2RheWpzL3BsdWdpbi90aW1lem9uZScpKTtcbnZhciBhZHZhbmNlZEZvcm1hdFBsdWdpbiA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdkYXlqcy9wbHVnaW4vYWR2YW5jZWRGb3JtYXQnKSk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciBhc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQoaXNUcnVlLCBlcnJvcikge1xuICBpZiAoaXNUcnVlKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbihmdW5jdGlvbiAoTWF0aHMpIHtcbiAgdmFyIE9wZXJhdGlvbnM7XG5cbiAgKGZ1bmN0aW9uIChPcGVyYXRpb25zKSB7XG4gICAgT3BlcmF0aW9uc1tcIlBMVVNcIl0gPSBcInBsdXNcIjtcbiAgICBPcGVyYXRpb25zW1wiTVVMVElQTFlcIl0gPSBcIm11bHRpcGxpZWRCeVwiO1xuICAgIE9wZXJhdGlvbnNbXCJESVZJREVcIl0gPSBcImRpdmlkZWRCeVwiO1xuICAgIE9wZXJhdGlvbnNbXCJNSU5VU1wiXSA9IFwibWludXNcIjtcbiAgfSkoT3BlcmF0aW9ucyA9IE1hdGhzLk9wZXJhdGlvbnMgfHwgKE1hdGhzLk9wZXJhdGlvbnMgPSB7fSkpO1xufSkoZXhwb3J0cy5NYXRocyB8fCAoZXhwb3J0cy5NYXRocyA9IHt9KSk7XG5cbnZhciBBc3NldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFzc2V0KGFzc2V0KSB7XG4gICAgdGhpcy5zeW1ib2wgPSBuZXcgU3ltYm9sJDEoe1xuICAgICAgY29kZTogYXNzZXQuY29kZSxcbiAgICAgIHByZWNpc2lvbjogYXNzZXQucHJlY2lzaW9uXG4gICAgfSk7XG4gICAgdGhpcy5hbW91bnQgPSBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihhc3NldC5hbW91bnQpO1xuICB9XG5cbiAgQXNzZXQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoYXNzZXQpIHtcbiAgICB2YXIgX2Fzc2V0JHNwbGl0ID0gYXNzZXQuc3BsaXQoJyAnKSxcbiAgICAgICAgYW1vdW50ID0gX2Fzc2V0JHNwbGl0WzBdLFxuICAgICAgICBjb2RlID0gX2Fzc2V0JHNwbGl0WzFdO1xuXG4gICAgdmFyIHByZWNpc2lvbiA9IChhbW91bnQuc3BsaXQoJy4nKVsxXSB8fCBbXSkubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgQXNzZXQoe1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgYW1vdW50OiBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihhbW91bnQpXG4gICAgfSk7XG4gIH07XG5cbiAgQXNzZXQuZnJvbVN5bWJvbCA9IGZ1bmN0aW9uIGZyb21TeW1ib2woX3JlZikge1xuICAgIHZhciBzeW1ib2wgPSBfcmVmLnN5bWJvbCxcbiAgICAgICAgYW1vdW50ID0gX3JlZi5hbW91bnQ7XG5cbiAgICBpZiAoIShzeW1ib2wgaW5zdGFuY2VvZiBTeW1ib2wkMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzeW1ib2wnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2V0KHtcbiAgICAgIGNvZGU6IHN5bWJvbC5jb2RlLFxuICAgICAgcHJlY2lzaW9uOiBzeW1ib2wucHJlY2lzaW9uLFxuICAgICAgYW1vdW50OiBhbW91bnRcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gQXNzZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5pc0VxdWFsVG8gPSBmdW5jdGlvbiBpc0VxdWFsVG8oYXNzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xvb3NlbHlFcXVhbFRvKGFzc2V0KSAmJiB0aGlzLmFtb3VudCA9PSBhc3NldC5hbW91bnQ7XG4gIH07XG5cbiAgX3Byb3RvLmlzTG9vc2VseUVxdWFsVG8gPSBmdW5jdGlvbiBpc0xvb3NlbHlFcXVhbFRvKGFzc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3ltYm9sLmlzRXF1YWxUbyhhc3NldC5zeW1ib2wpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcih0aGlzLmFtb3VudCkudG9GaXhlZCh0aGlzLnN5bWJvbC5wcmVjaXNpb24sIGJpZ251bWJlcl9qcy5CaWdOdW1iZXIuUk9VTkRfRE9XTikgKyBcIiBcIiArIHRoaXMuc3ltYm9sLmNvZGU7XG4gIH07XG5cbiAgX3Byb3RvLm1vZGlmeUFtb3VudCA9IGZ1bmN0aW9uIG1vZGlmeUFtb3VudCh4LCBtZXRob2QpIHtcbiAgICB2YXIgYW1vdW50ID0gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoMCk7XG5cbiAgICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIgfHwgYmlnbnVtYmVyX2pzLkJpZ051bWJlci5pc0JpZ051bWJlcih4KSkge1xuICAgICAgYW1vdW50ID0gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIoeCk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBBc3NldCkge1xuICAgICAgYXNzZXJ0KHRoaXMuaXNMb29zZWx5RXF1YWxUbyh4KSwgXCJpbnZhbGlkIHN5bWJvbFwiKTtcbiAgICAgIGFtb3VudCA9IG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKHguYW1vdW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXNzZXQuZnJvbVN5bWJvbCh7XG4gICAgICBzeW1ib2w6IHRoaXMuc3ltYm9sLFxuICAgICAgYW1vdW50OiB0aGlzLmFtb3VudFttZXRob2RdKGFtb3VudClcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1cyA9IGZ1bmN0aW9uIHBsdXMoeCkge1xuICAgIHJldHVybiB0aGlzLm1vZGlmeUFtb3VudCh4LCBleHBvcnRzLk1hdGhzLk9wZXJhdGlvbnMuUExVUyk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzID0gZnVuY3Rpb24gbWludXMoeCkge1xuICAgIHJldHVybiB0aGlzLm1vZGlmeUFtb3VudCh4LCBleHBvcnRzLk1hdGhzLk9wZXJhdGlvbnMuTUlOVVMpO1xuICB9O1xuXG4gIF9wcm90by5tdWx0aXBsaWVkQnkgPSBmdW5jdGlvbiBtdWx0aXBsaWVkQnkoeCkge1xuICAgIHJldHVybiB0aGlzLm1vZGlmeUFtb3VudCh4LCBleHBvcnRzLk1hdGhzLk9wZXJhdGlvbnMuTVVMVElQTFkpO1xuICB9O1xuXG4gIF9wcm90by5kaXZpZGVkQnkgPSBmdW5jdGlvbiBkaXZpZGVkQnkoeCkge1xuICAgIHJldHVybiB0aGlzLm1vZGlmeUFtb3VudCh4LCBleHBvcnRzLk1hdGhzLk9wZXJhdGlvbnMuRElWSURFKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoQXNzZXQsIFt7XG4gICAga2V5OiBcImludGVnZXJBbW91bnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgdGhpcy5zeW1ib2wucHJlY2lzaW9uKTtcbiAgICAgIHJldHVybiB0aGlzLmFtb3VudC5tdWx0aXBsaWVkQnkoZmFjdG9yKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXQ7XG59KCk7XG52YXIgRXh0ZW5kZWRBc3NldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4dGVuZGVkQXNzZXQoZXh0ZW5kZWRBc3NldCkge1xuICAgIGlmICghKGV4dGVuZGVkQXNzZXQucXVhbnRpdHkgaW5zdGFuY2VvZiBBc3NldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBxdWFudGl0eScpO1xuICAgIH1cblxuICAgIHRoaXMucXVhbnRpdHkgPSBleHRlbmRlZEFzc2V0LnF1YW50aXR5O1xuICAgIHRoaXMuY29udHJhY3QgPSBleHRlbmRlZEFzc2V0LmNvbnRyYWN0O1xuICB9XG5cbiAgRXh0ZW5kZWRBc3NldC5mcm9tUmF3ID0gZnVuY3Rpb24gZnJvbVJhdyhfcmVmMikge1xuICAgIHZhciBxdWFudGl0eSA9IF9yZWYyLnF1YW50aXR5LFxuICAgICAgICBjb250cmFjdCA9IF9yZWYyLmNvbnRyYWN0O1xuICAgIHJldHVybiBuZXcgRXh0ZW5kZWRBc3NldCh7XG4gICAgICBxdWFudGl0eTogQXNzZXQuZnJvbVN0cmluZyhxdWFudGl0eSksXG4gICAgICBjb250cmFjdDogY29udHJhY3RcbiAgICB9KTtcbiAgfTtcblxuICBFeHRlbmRlZEFzc2V0LmZyb21FeHRlbmRlZFN5bWJvbCA9IGZ1bmN0aW9uIGZyb21FeHRlbmRlZFN5bWJvbChzeW1ib2wsIGFtb3VudCkge1xuICAgIGlmICghKHN5bWJvbCBpbnN0YW5jZW9mIEV4dGVuZGVkU3ltYm9sKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV4dGVuZGVkIHN5bWJvbCcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRXh0ZW5kZWRBc3NldCh7XG4gICAgICBxdWFudGl0eTogQXNzZXQuZnJvbVN5bWJvbCh7XG4gICAgICAgIHN5bWJvbDogc3ltYm9sLnN5bSxcbiAgICAgICAgYW1vdW50OiBhbW91bnRcbiAgICAgIH0pLFxuICAgICAgY29udHJhY3Q6IHN5bWJvbC5jb250cmFjdFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBfcHJvdG8yID0gRXh0ZW5kZWRBc3NldC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pc0VxdWFsVG8gPSBmdW5jdGlvbiBpc0VxdWFsVG8oZXh0ZW5kZWRBc3NldCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0ID09PSBleHRlbmRlZEFzc2V0LmNvbnRyYWN0ICYmIHRoaXMucXVhbnRpdHkuaXNFcXVhbFRvKGV4dGVuZGVkQXNzZXQucXVhbnRpdHkpO1xuICB9O1xuXG4gIF9wcm90bzIuaXNMb29zZWx5RXF1YWxUbyA9IGZ1bmN0aW9uIGlzTG9vc2VseUVxdWFsVG8oZXh0ZW5kZWRBc3NldCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0ID09PSBleHRlbmRlZEFzc2V0LmNvbnRyYWN0ICYmIHRoaXMucXVhbnRpdHkuaXNMb29zZWx5RXF1YWxUbyhleHRlbmRlZEFzc2V0LnF1YW50aXR5KTtcbiAgfTtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVhbnRpdHkudG9TdHJpbmcoKSArIFwiQFwiICsgdGhpcy5jb250cmFjdDtcbiAgfTtcblxuICBfcHJvdG8yLnRvRXh0ZW5kZWRTeW1ib2wgPSBmdW5jdGlvbiB0b0V4dGVuZGVkU3ltYm9sKCkge1xuICAgIHJldHVybiBuZXcgRXh0ZW5kZWRTeW1ib2wodGhpcy5xdWFudGl0eS5zeW1ib2wsIHRoaXMuY29udHJhY3QpO1xuICB9O1xuXG4gIF9wcm90bzIubW9kaWZ5QW1vdW50ID0gZnVuY3Rpb24gbW9kaWZ5QW1vdW50KHgsIG1ldGhvZCkge1xuICAgIHZhciBhbW91bnQgPSBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcigwKTtcblxuICAgIGlmICh4IGluc3RhbmNlb2YgRXh0ZW5kZWRBc3NldCkge1xuICAgICAgYXNzZXJ0KHRoaXMuaXNMb29zZWx5RXF1YWxUbyh4KSwgXCJpbnZhbGlkIGNvbnRyYWN0IG9yIHN5bWJvbFwiKTtcbiAgICAgIGFtb3VudCA9IHgucXVhbnRpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFtb3VudCA9IHg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFeHRlbmRlZEFzc2V0KHtcbiAgICAgIGNvbnRyYWN0OiB0aGlzLmNvbnRyYWN0LFxuICAgICAgcXVhbnRpdHk6IHRoaXMucXVhbnRpdHkubW9kaWZ5QW1vdW50KGFtb3VudCwgbWV0aG9kKVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzIucGx1cyA9IGZ1bmN0aW9uIHBsdXMoeCkge1xuICAgIHJldHVybiB0aGlzLm1vZGlmeUFtb3VudCh4LCBleHBvcnRzLk1hdGhzLk9wZXJhdGlvbnMuUExVUyk7XG4gIH07XG5cbiAgX3Byb3RvMi5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKHgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RpZnlBbW91bnQoeCwgZXhwb3J0cy5NYXRocy5PcGVyYXRpb25zLk1JTlVTKTtcbiAgfTtcblxuICBfcHJvdG8yLm11bHRpcGxpZWRCeSA9IGZ1bmN0aW9uIG11bHRpcGxpZWRCeSh4KSB7XG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5QW1vdW50KHgsIGV4cG9ydHMuTWF0aHMuT3BlcmF0aW9ucy5NVUxUSVBMWSk7XG4gIH07XG5cbiAgX3Byb3RvMi5kaXZpZGVkQnkgPSBmdW5jdGlvbiBkaXZpZGVkQnkoeCkge1xuICAgIHJldHVybiB0aGlzLm1vZGlmeUFtb3VudCh4LCBleHBvcnRzLk1hdGhzLk9wZXJhdGlvbnMuRElWSURFKTtcbiAgfTtcblxuICByZXR1cm4gRXh0ZW5kZWRBc3NldDtcbn0oKTtcbnZhciBTeW1ib2wkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN5bWJvbChzeW1ib2wpIHtcbiAgICB0aGlzLnByZWNpc2lvbiA9IHN5bWJvbC5wcmVjaXNpb247XG4gICAgdGhpcy5jb2RlID0gc3ltYm9sLmNvZGU7XG4gIH1cblxuICBTeW1ib2wuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3ltYm9sKSB7XG4gICAgdmFyIF9zeW1ib2wkc3BsaXQgPSBzeW1ib2wuc3BsaXQoJywnKSxcbiAgICAgICAgcHJlY2lzaW9uID0gX3N5bWJvbCRzcGxpdFswXSxcbiAgICAgICAgY29kZSA9IF9zeW1ib2wkc3BsaXRbMV07XG5cbiAgICByZXR1cm4gbmV3IFN5bWJvbCh7XG4gICAgICBwcmVjaXNpb246ICtwcmVjaXNpb24sXG4gICAgICBjb2RlOiBjb2RlXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIF9wcm90bzMgPSBTeW1ib2wucHJvdG90eXBlO1xuXG4gIF9wcm90bzMuaXNFcXVhbFRvID0gZnVuY3Rpb24gaXNFcXVhbFRvKHN5bWJvbCkge1xuICAgIHJldHVybiB0aGlzLmNvZGUgPT09IHN5bWJvbC5jb2RlICYmIHRoaXMucHJlY2lzaW9uID09PSBzeW1ib2wucHJlY2lzaW9uO1xuICB9O1xuXG4gIF9wcm90bzMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVjaXNpb24gKyBcIixcIiArIHRoaXMuY29kZTtcbiAgfTtcblxuICByZXR1cm4gU3ltYm9sO1xufSgpO1xudmFyIEV4dGVuZGVkU3ltYm9sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXh0ZW5kZWRTeW1ib2woc3ltLCBjb250cmFjdCkge1xuICAgIHRoaXMuc3ltID0gc3ltO1xuICAgIHRoaXMuY29udHJhY3QgPSBjb250cmFjdDtcbiAgfVxuXG4gIEV4dGVuZGVkU3ltYm9sLmZyb21SYXcgPSBmdW5jdGlvbiBmcm9tUmF3KF9yZWYzKSB7XG4gICAgdmFyIHN5bSA9IF9yZWYzLnN5bSxcbiAgICAgICAgY29udHJhY3QgPSBfcmVmMy5jb250cmFjdDtcbiAgICByZXR1cm4gbmV3IEV4dGVuZGVkU3ltYm9sKFN5bWJvbCQxLmZyb21TdHJpbmcoc3ltKSwgY29udHJhY3QpO1xuICB9O1xuXG4gIHZhciBfcHJvdG80ID0gRXh0ZW5kZWRTeW1ib2wucHJvdG90eXBlO1xuXG4gIF9wcm90bzQuaXNFcXVhbFRvID0gZnVuY3Rpb24gaXNFcXVhbFRvKGV4dGVuZGVkU3ltYm9sKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ltLmlzRXF1YWxUbyhleHRlbmRlZFN5bWJvbC5zeW0pICYmIHRoaXMuY29udHJhY3QgPT09IGV4dGVuZGVkU3ltYm9sLmNvbnRyYWN0O1xuICB9O1xuXG4gIF9wcm90bzQudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zeW0udG9TdHJpbmcoKSArIFwiQFwiICsgdGhpcy5jb250cmFjdDtcbiAgfTtcblxuICByZXR1cm4gRXh0ZW5kZWRTeW1ib2w7XG59KCk7XG5cbnZhciBjdXJyZW5jeU1hcCA9IHtcbiAgLy8gRmlhdFxuICBHQlA6IHtcbiAgICBzeW1ib2w6ICfCoycsXG4gICAgcHJlY2lzaW9uOiAyXG4gIH0sXG4gIEVVUjoge1xuICAgIHN5bWJvbDogJ+KCrCcsXG4gICAgcHJlY2lzaW9uOiAyXG4gIH0sXG4gIEpQWToge1xuICAgIHN5bWJvbDogJ8KlJyxcbiAgICBwcmVjaXNpb246IDBcbiAgfSxcbiAgQ0FEOiB7XG4gICAgc3ltYm9sOiAnQ0EkJyxcbiAgICBwcmVjaXNpb246IDJcbiAgfSxcbiAgVVNEOiB7XG4gICAgc3ltYm9sOiAnJCcsXG4gICAgcHJlY2lzaW9uOiAyXG4gIH0sXG4gIElOUjoge1xuICAgIHN5bWJvbDogJ+KCuScsXG4gICAgcHJlY2lzaW9uOiAyXG4gIH0sXG4gIENOWToge1xuICAgIHN5bWJvbDogJ0NOwqUnLFxuICAgIHByZWNpc2lvbjogMlxuICB9LFxuICBIS0Q6IHtcbiAgICBzeW1ib2w6ICdISyQnLFxuICAgIHByZWNpc2lvbjogMlxuICB9LFxuICBLUlc6IHtcbiAgICBzeW1ib2w6ICfigqknLFxuICAgIHByZWNpc2lvbjogMFxuICB9LFxuICBBVUQ6IHtcbiAgICBzeW1ib2w6ICdBVUQkJyxcbiAgICBwcmVjaXNpb246IDJcbiAgfSxcbiAgU0FSOiB7XG4gICAgc3ltYm9sOiAnU1InLFxuICAgIHByZWNpc2lvbjogMlxuICB9LFxuICAvLyBDcnlwdG9cbiAgRVRIOiB7XG4gICAgc3ltYm9sOiAnzp4nLFxuICAgIHByZWNpc2lvbjogNFxuICB9LFxuICBCVEM6IHtcbiAgICBzeW1ib2w6ICfigr8nLFxuICAgIHByZWNpc2lvbjogOFxuICB9LFxuICBFT1M6IHtcbiAgICBzeW1ib2w6ICdFT1MnLFxuICAgIHByZWNpc2lvbjogNFxuICB9XG59O1xudmFyIGFzc2V0Rm9ybWF0ID0ge1xuICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXG4gIGdyb3VwU2VwYXJhdG9yOiAnLCcsXG4gIGdyb3VwU2l6ZTogM1xufTtcblxuZnVuY3Rpb24gdG9CTihudW1iZXIpIHtcbiAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKG51bWJlcik7XG59XG5mdW5jdGlvbiBudW1iZXJUb0Ftb3VudChudW1iZXIsIHByZWNpc2lvbiwgcm91bmQpIHtcbiAgaWYgKHJvdW5kID09PSB2b2lkIDApIHtcbiAgICByb3VuZCA9IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIuUk9VTkRfRE9XTjtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbnVtYmVyID09PSBcIm51bWJlclwiICYmIGlzTmFOKG51bWJlcikpIHtcbiAgICBudW1iZXIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKG51bWJlcikudG9GaXhlZChwcmVjaXNpb24sIHJvdW5kKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQW1vdW50Rm9ybWF0dGVkKG51bWJlciwgcHJlY2lzaW9uLCByb3VuZCkge1xuICBpZiAocm91bmQgPT09IHZvaWQgMCkge1xuICAgIHJvdW5kID0gYmlnbnVtYmVyX2pzLkJpZ051bWJlci5ST1VORF9ET1dOO1xuICB9XG5cbiAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG51bWJlcikpIHtcbiAgICBudW1iZXIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKG51bWJlcikudG9Gb3JtYXQocHJlY2lzaW9uLCByb3VuZCwgYXNzZXRGb3JtYXQpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUGVyY2VudGFnZShiYWxhbmNlLCBwZXJjZW50YWdlLCBwcmVjaXNpb24pIHtcbiAgdmFyIF9maW5hbCA9IG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKGJhbGFuY2UpLm11bHRpcGxpZWRCeShwZXJjZW50YWdlKTtcblxuICByZXR1cm4gbnVtYmVyVG9BbW91bnQoX2ZpbmFsLCBwcmVjaXNpb24sIGJpZ251bWJlcl9qcy5CaWdOdW1iZXIuUk9VTkRfRE9XTik7XG59XG5mdW5jdGlvbiBlb3NEaXNwbGF5Rm9ybWF0dGluZyh2YWx1ZSwgc3ltYm9sLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuIG51bWJlclRvQW1vdW50Rm9ybWF0dGVkKHZhbHVlLCBwcmVjaXNpb24pICsgXCIgXCIgKyBzeW1ib2w7XG59XG5mdW5jdGlvbiBudW1iZXJUb0VvcyhudW1iZXIsIHN5bWJvbCwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiBudW1iZXJUb0Ftb3VudChudW1iZXIsIHByZWNpc2lvbikgKyBcIiBcIiArIHN5bWJvbDtcbn1cbmZ1bmN0aW9uIG51bWJlclRvRW9zUm91bmRVcChudW1iZXIsIHN5bWJvbCwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiBudW1iZXJUb0Ftb3VudChudW1iZXIsIHByZWNpc2lvbiwgYmlnbnVtYmVyX2pzLkJpZ051bWJlci5ST1VORF9VUCkgKyBcIiBcIiArIHN5bWJvbDtcbn1cbmZ1bmN0aW9uIHBhcnNlUmV4KHJleCkge1xuICByZXR1cm4gbmV3IGJpZ251bWJlcl9qcy5CaWdOdW1iZXIocmV4KS5kaXZpZGVkQnkoMTAwMDApO1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIFVTRCB0byB7IHN5bWJvbDogXCJVU0RcIiwgcHJlY2lzaW9uOiA0IH1cclxuICogQHBhcmFtIHsqfSBjdXJyZW5jeVxyXG4gKi9cblxuZnVuY3Rpb24gY3VycmVuY3lUb1N5bWJvbChjdXJyZW5jeSkge1xuICByZXR1cm4gY3VycmVuY3lNYXBbY3VycmVuY3ldO1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIFwiMTAwMC4wMDAwIEVPU1wiIHRvIHsgYW1vdW50OiAxMDAwLCBzeW1ib2w6IHsgY29kZTogXCJFT1NcIiwgcHJlY2lzaW9uOiA0IH19XHJcbiAqIEBwYXJhbSB7Kn0gcXVhbnRpdHlcclxuICovXG5cbmZ1bmN0aW9uIHNwbGl0KHF1YW50aXR5KSB7XG4gIHZhciBfcXVhbnRpdHkkc3BsaXQgPSBxdWFudGl0eS5zcGxpdCgnICcpLFxuICAgICAgYW1vdW50ID0gX3F1YW50aXR5JHNwbGl0WzBdLFxuICAgICAgY29kZSA9IF9xdWFudGl0eSRzcGxpdFsxXTtcblxuICB2YXIgcHJlY2lzaW9uID0gKGFtb3VudC5zcGxpdCgnLicpWzFdIHx8IFtdKS5sZW5ndGg7XG4gIHJldHVybiB7XG4gICAgYW1vdW50OiArYW1vdW50LFxuICAgIHN5bWJvbDoge1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdG9OdW1icm8obnVtYmVyKSB7XG4gIHJldHVybiBudW1icm8obnVtYmVyKTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0cyAxMDAwIHRvIFwiMTAwMC4wMDAwIEVPU1wiXHJcbiAqIEBwYXJhbSB7Kn0gYXNzZXRcclxuICovXG5cbmZ1bmN0aW9uIG51bWJlclRvQXNzZXQobnVtYmVyLCBzeW1ib2wsIHByZWNpc2lvbiwgdHJpbU1hbnRpc3NhKSB7XG4gIGlmICh0cmltTWFudGlzc2EgPT09IHZvaWQgMCkge1xuICAgIHRyaW1NYW50aXNzYSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG51bWJlcikpIHtcbiAgICBudW1iZXIgPSAwO1xuICB9XG5cbiAgdmFyIGFtb3VudCA9IG51bWJybyhudW1iZXIpLmZvcm1hdCh7XG4gICAgdGhvdXNhbmRTZXBhcmF0ZWQ6IGZhbHNlLFxuICAgIG1hbnRpc3NhOiBwcmVjaXNpb24sXG4gICAgdHJpbU1hbnRpc3NhOiB0cmltTWFudGlzc2FcbiAgfSk7XG4gIHJldHVybiBhbW91bnQgKyBcIiBcIiArIHN5bWJvbDtcbn1cbi8qKlxyXG4gKiBESVNQTEFZIEZVTkNUSU9OU1xyXG4gKi9cblxuLyoqXHJcbiAqIENvbnZlcnRzIDEwMDAgdG8gMSwwMDBcclxuICogQHBhcmFtIHsqfSBudW1iZXJcclxuICovXG5cbmZ1bmN0aW9uIGRpc3BsYXlOdW1iZXIobnVtYmVyLCB0cmltTWFudGlzc2EpIHtcbiAgaWYgKHRyaW1NYW50aXNzYSA9PT0gdm9pZCAwKSB7XG4gICAgdHJpbU1hbnRpc3NhID0gZmFsc2U7XG4gIH1cblxuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQgfHwgaXNOYU4obnVtYmVyKSkge1xuICAgIG51bWJlciA9IDA7XG4gIH1cblxuICByZXR1cm4gbnVtYnJvKG51bWJlcikuZm9ybWF0KHtcbiAgICB0aG91c2FuZFNlcGFyYXRlZDogdHJ1ZSxcbiAgICB0cmltTWFudGlzc2E6IHRyaW1NYW50aXNzYVxuICB9KTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0cyAxMDAwIHRvICQxLDAwMCBVU0RcclxuICogQHBhcmFtIHsqfSBudW1iZXJcclxuICovXG5cbmZ1bmN0aW9uIGRpc3BsYXlOdW1iZXJBc0N1cnJlbmN5KF9yZWYpIHtcbiAgdmFyIG51bWJlciA9IF9yZWYubnVtYmVyLFxuICAgICAgcHJlY2lzaW9uID0gX3JlZi5wcmVjaXNpb24sXG4gICAgICBfcmVmJGF2ZXJhZ2UgPSBfcmVmLmF2ZXJhZ2UsXG4gICAgICBhdmVyYWdlID0gX3JlZiRhdmVyYWdlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkYXZlcmFnZSxcbiAgICAgIF9yZWYkbG93UHJlY2lzaW9uID0gX3JlZi5sb3dQcmVjaXNpb24sXG4gICAgICBsb3dQcmVjaXNpb24gPSBfcmVmJGxvd1ByZWNpc2lvbiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkbG93UHJlY2lzaW9uLFxuICAgICAgX3JlZiR0cmltTWFudGlzc2EgPSBfcmVmLnRyaW1NYW50aXNzYSxcbiAgICAgIHRyaW1NYW50aXNzYSA9IF9yZWYkdHJpbU1hbnRpc3NhID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkdHJpbU1hbnRpc3NhLFxuICAgICAgX3JlZiRjdXJyZW5jeSA9IF9yZWYuY3VycmVuY3ksXG4gICAgICBjdXJyZW5jeSA9IF9yZWYkY3VycmVuY3kgPT09IHZvaWQgMCA/ICdVU0QnIDogX3JlZiRjdXJyZW5jeTtcblxuICBpZiAoIWN1cnJlbmN5TWFwW2N1cnJlbmN5XSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY3VycmVuY3knKTtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IHVuZGVmaW5lZCB8fCBpc05hTihudW1iZXIpKSB7XG4gICAgbnVtYmVyID0gMDtcbiAgfVxuXG4gIHZhciBfY3VycmVuY3lNYXAkY3VycmVuY3kgPSBjdXJyZW5jeU1hcFtjdXJyZW5jeV0sXG4gICAgICBzeW1ib2wgPSBfY3VycmVuY3lNYXAkY3VycmVuY3kuc3ltYm9sLFxuICAgICAgZGVmYXVsdFByZWNpc2lvbiA9IF9jdXJyZW5jeU1hcCRjdXJyZW5jeS5wcmVjaXNpb247XG4gIHZhciBmb3JtYXQgPSB7XG4gICAgdGhvdXNhbmRTZXBhcmF0ZWQ6IHRydWUsXG4gICAgbWFudGlzc2E6IHByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcHJlY2lzaW9uIDogZGVmYXVsdFByZWNpc2lvbixcbiAgICB0cmltTWFudGlzc2E6IHRyaW1NYW50aXNzYSxcbiAgICBhdmVyYWdlOiBhdmVyYWdlXG4gIH07XG5cbiAgaWYgKGF2ZXJhZ2UpIHtcbiAgICBmb3JtYXQubG93UHJlY2lzaW9uID0gbG93UHJlY2lzaW9uO1xuICB9XG5cbiAgdmFyIGZvcm1hdHRlZE51bWJlciA9IG51bWJybyhudW1iZXIpLmZvcm1hdChmb3JtYXQpO1xuICByZXR1cm4gXCJcIiArIHN5bWJvbCArIGZvcm1hdHRlZE51bWJlcjtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0cyBcIjEwMDAuMDAwMCBFT1NcIiB0byBcIjEsMDAwLjAwMDAgRU9TXCJcclxuICogQHBhcmFtIHsqfSBhc3NldFxyXG4gKi9cblxuZnVuY3Rpb24gZGlzcGxheUFzc2V0KGFzc2V0KSB7XG4gIHZhciBfc3BsaXQgPSBzcGxpdChhc3NldCksXG4gICAgICBhbW91bnQgPSBfc3BsaXQuYW1vdW50LFxuICAgICAgY29kZSA9IF9zcGxpdC5zeW1ib2wuY29kZTtcblxuICByZXR1cm4gZGlzcGxheU51bWJlcihhbW91bnQpICsgXCIgXCIgKyBjb2RlO1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIDEwMDAgdG8gMSwwMDAuMDAwMFxyXG4gKiBAcGFyYW0geyp9IG51bWJlclxyXG4gKi9cblxuZnVuY3Rpb24gZGlzcGxheU51bWJlckFzQW1vdW50KG51bWJlciwgcHJlY2lzaW9uLCB0cmltTWFudGlzc2EpIHtcbiAgaWYgKHRyaW1NYW50aXNzYSA9PT0gdm9pZCAwKSB7XG4gICAgdHJpbU1hbnRpc3NhID0gZmFsc2U7XG4gIH1cblxuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQgfHwgaXNOYU4obnVtYmVyKSkge1xuICAgIG51bWJlciA9IDA7XG4gIH1cblxuICByZXR1cm4gbnVtYnJvKG51bWJlcikuZm9ybWF0KHtcbiAgICB0aG91c2FuZFNlcGFyYXRlZDogdHJ1ZSxcbiAgICBtYW50aXNzYTogcHJlY2lzaW9uLFxuICAgIHRyaW1NYW50aXNzYTogdHJpbU1hbnRpc3NhXG4gIH0pO1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIDEwMDAgdG8gXCIxLDAwMC4wMDAwIEVPU1wiXHJcbiAqIEBwYXJhbSB7Kn0gbnVtYmVyXHJcbiAqL1xuXG5mdW5jdGlvbiBkaXNwbGF5TnVtYmVyQXNBc3NldChudW1iZXIsIHN5bWJvbCwgcHJlY2lzaW9uLCB0cmltTWFudGlzc2EpIHtcbiAgaWYgKHRyaW1NYW50aXNzYSA9PT0gdm9pZCAwKSB7XG4gICAgdHJpbU1hbnRpc3NhID0gZmFsc2U7XG4gIH1cblxuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQgfHwgaXNOYU4obnVtYmVyKSkge1xuICAgIG51bWJlciA9IDA7XG4gIH1cblxuICB2YXIgYW1vdW50ID0gbnVtYnJvKG51bWJlcikuZm9ybWF0KHtcbiAgICB0aG91c2FuZFNlcGFyYXRlZDogdHJ1ZSxcbiAgICBtYW50aXNzYTogcHJlY2lzaW9uLFxuICAgIHRyaW1NYW50aXNzYTogdHJpbU1hbnRpc3NhXG4gIH0pO1xuICByZXR1cm4gYW1vdW50ICsgXCIgXCIgKyBzeW1ib2w7XG59XG4vKipcclxuICogQ29udmVydHMgMTAwMDAwMDAgdG8gXCIxLDAwMC4wMDAwIEVPU1wiXHJcbiAqIEBwYXJhbSB7Kn0gbnVtYmVyXHJcbiAqL1xuXG5mdW5jdGlvbiBkaXNwbGF5UmF3TnVtYmVyQXNBc3NldChudW1iZXIsIHN5bWJvbCwgcHJlY2lzaW9uLCB0cmltTWFudGlzc2EpIHtcbiAgaWYgKHRyaW1NYW50aXNzYSA9PT0gdm9pZCAwKSB7XG4gICAgdHJpbU1hbnRpc3NhID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGlzcGxheU51bWJlckFzQXNzZXQobnVtYmVyIC8gTWF0aC5wb3coMTAsIHByZWNpc2lvbiksIHN5bWJvbCwgcHJlY2lzaW9uLCB0cmltTWFudGlzc2EpO1xufVxuXG5iaWdudW1iZXJfanMuQmlnTnVtYmVyLnNldCh7XG4gIFJPVU5ESU5HX01PREU6IDFcbn0pO1xuZnVuY3Rpb24gYWRkKCkge1xuICB2YXIgc3RhcnQgPSBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcigwKTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbnVtYmVycyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBudW1iZXJzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKG51bWJlcnMubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShudW1iZXJzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciBudW1iZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHN0YXJ0ID0gc3RhcnQucGx1cyhudW1iZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGFydDtcbn1cbmZ1bmN0aW9uIHN1YnN0cmFjdChhLCBiKSB7XG4gIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihhKS5taW51cyhiKTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5KGEsIGIpIHtcbiAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanMuQmlnTnVtYmVyKGEpLm11bHRpcGxpZWRCeShiKTtcbn1cbmZ1bmN0aW9uIGRpdmlkZShhLCBiKSB7XG4gIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzLkJpZ051bWJlcihhKS5kaXZpZGVkQnkoYik7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9LQihieXRlcykge1xuICBpZiAoYnl0ZXMgPT09IHZvaWQgMCkge1xuICAgIGJ5dGVzID0gMDtcbiAgfVxuXG4gIHJldHVybiBudW1icm8oYnl0ZXMgLyAxMDI0KS5mb3JtYXQoe1xuICAgIHRob3VzYW5kU2VwYXJhdGVkOiBmYWxzZSxcbiAgICBtYW50aXNzYTogMlxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlTmV0QW5kUmFtKGJ5dGVzKSB7XG4gIHZhciBwYXJzZWRWYWx1ZSA9IDA7XG4gIHZhciBwYXJzZWRUZXh0ID0gJyc7XG5cbiAgaWYgKGJ5dGVzIDwgMTAyNCkge1xuICAgIHBhcnNlZFZhbHVlID0gYnl0ZXM7XG4gICAgcGFyc2VkVGV4dCA9ICdCeXRlcyc7XG4gIH0gZWxzZSBpZiAoYnl0ZXMgPCAxMDQ4NTc2KSB7XG4gICAgcGFyc2VkVmFsdWUgPSBieXRlcyAvIDEwMjQ7XG4gICAgcGFyc2VkVGV4dCA9ICdLQic7XG4gIH0gZWxzZSBpZiAoYnl0ZXMgPCAxMDczNzQxODI0KSB7XG4gICAgcGFyc2VkVmFsdWUgPSBieXRlcyAvIDEwNDg1NzY7XG4gICAgcGFyc2VkVGV4dCA9ICdNQic7XG4gIH0gZWxzZSBpZiAoYnl0ZXMgPCAxMDk5NTExNjI3Nzc2KSB7XG4gICAgcGFyc2VkVmFsdWUgPSBieXRlcyAvIDEwNzM3NDE4MjQ7XG4gICAgcGFyc2VkVGV4dCA9ICdHQic7XG4gIH0gZWxzZSBpZiAoYnl0ZXMgPCAxMTI1ODk5OTA2ODQyNjI0KSB7XG4gICAgcGFyc2VkVmFsdWUgPSBieXRlcyAvIDEwOTk1MTE2Mjc3NzY7XG4gICAgcGFyc2VkVGV4dCA9ICdUQic7XG4gIH1cblxuICByZXR1cm4gZGlzcGxheU51bWJlckFzQW1vdW50KHBhcnNlZFZhbHVlLCAyLCB0cnVlKSArIFwiIFwiICsgcGFyc2VkVGV4dDtcbn1cbmZ1bmN0aW9uIHBhcnNlQ3B1KHVzKSB7XG4gIHZhciBwYXJzZWRWYWx1ZSA9IDA7XG4gIHZhciBwYXJzZWRUZXh0ID0gJyc7XG5cbiAgaWYgKHVzIDwgMTAwMCkge1xuICAgIHBhcnNlZFZhbHVlID0gdXM7XG4gICAgcGFyc2VkVGV4dCA9ICfCtXMnO1xuICB9IGVsc2UgaWYgKHVzIDwgMTAwMDAwMCkge1xuICAgIHBhcnNlZFZhbHVlID0gdXMgLyAxMDAwO1xuICAgIHBhcnNlZFRleHQgPSAnbXMnO1xuICB9IGVsc2UgaWYgKHVzIDwgNjAwMDAwMDApIHtcbiAgICBwYXJzZWRWYWx1ZSA9IHVzIC8gMTAwMDAwMDtcbiAgICBwYXJzZWRUZXh0ID0gJ3MnO1xuICB9IGVsc2UgaWYgKHVzIDwgMzYwMDAwMDAwMCkge1xuICAgIHBhcnNlZFZhbHVlID0gdXMgLyA2MDAwMDAwMDtcbiAgICBwYXJzZWRUZXh0ID0gJ21pbic7XG4gIH0gZWxzZSBpZiAodXMgPCAzNjAwMDAwMDAwMDAwKSB7XG4gICAgcGFyc2VkVmFsdWUgPSB1cyAvIDM2MDAwMDAwMDA7XG4gICAgcGFyc2VkVGV4dCA9ICdob3Vycyc7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkVmFsdWUgPSB1cyAvIDg2NDAwMDAwMDAwO1xuICAgIHBhcnNlZFRleHQgPSAnZGF5cyc7XG4gIH1cblxuICByZXR1cm4gZGlzcGxheU51bWJlckFzQW1vdW50KHBhcnNlZFZhbHVlLCAyLCB0cnVlKSArIFwiIFwiICsgcGFyc2VkVGV4dDtcbn1cblxuZGF5anMuZXh0ZW5kKHJlbGF0aXZlVGltZVBsdWdpbik7XG5kYXlqcy5leHRlbmQodXRjUGx1Z2luKTtcbmRheWpzLmV4dGVuZCh0aW1lem9uZVBsdWdpbik7XG5kYXlqcy5leHRlbmQoYWR2YW5jZWRGb3JtYXRQbHVnaW4pO1xudmFyIENPTU1PTl9EQVRFX0ZPUk1BVCA9ICdNTU0tREQtWVlZWSwgaGg6bW06c3MgQSc7XG4vKipcclxuICogVGltZSB1dGlsaXRpZXNcclxuICovXG5cbmZ1bmN0aW9uIHRpbWUoZGF0ZSkge1xuICByZXR1cm4gZGF5anMoZGF0ZSk7XG59XG5mdW5jdGlvbiB1dGNUaW1lKGRhdGUpIHtcbiAgcmV0dXJuIGRheWpzKGRhdGUpLnV0YygpO1xufVxuZnVuY3Rpb24gdXRjVGltZVRvTG9jYWwoZGF0ZSkge1xuICByZXR1cm4gZGF5anMoZGF0ZSkubG9jYWwoKTtcbn1cbmZ1bmN0aW9uIHVuaXhUaW1lKHVuaXhUaW1lc3RhbXApIHtcbiAgcmV0dXJuIGRheWpzLnVuaXgodW5peFRpbWVzdGFtcCk7XG59XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICBmb3JtYXQgPSBDT01NT05fREFURV9GT1JNQVQ7XG4gIH1cblxuICByZXR1cm4gZGF5anMoZGF0ZSkuZm9ybWF0KGZvcm1hdCk7XG59XG5mdW5jdGlvbiBmb3JtYXREYXRlTG9jYWwoZGF0ZSwgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQgPT09IHZvaWQgMCkge1xuICAgIGZvcm1hdCA9IENPTU1PTl9EQVRFX0ZPUk1BVDtcbiAgfVxuXG4gIHJldHVybiBkYXlqcyhkYXRlKS51dGMoKS5mb3JtYXQoZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcFRvRGF0ZSh0aW1lc3RhbXApIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCk7XG59XG5mdW5jdGlvbiB1dGNUaW1lc3RhbXBUb0RhdGUodGltZXN0YW1wKSB7XG4gIHRpbWVzdGFtcCA9IHRpbWVzdGFtcC5zbGljZSgtMSkgPT09ICdaJyA/IHRpbWVzdGFtcCA6IHRpbWVzdGFtcCArICdaJztcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCk7XG59XG5mdW5jdGlvbiB0aW1lc3RhbXBGcm9tTm93KHRpbWVzdGFtcCkge1xuICByZXR1cm4gdGltZSh0aW1lc3RhbXApLmZyb21Ob3coKTtcbn1cbmZ1bmN0aW9uIHV0Y1RpbWVzdGFtcEZyb21Ob3codGltZXN0YW1wKSB7XG4gIHRpbWVzdGFtcCA9IHRpbWVzdGFtcC5zbGljZSgtMSkgPT09ICdaJyA/IHRpbWVzdGFtcCA6IHRpbWVzdGFtcCArICdaJztcbiAgcmV0dXJuIHRpbWUodGltZXN0YW1wKS5mcm9tTm93KCk7XG59XG5mdW5jdGlvbiBwYXJzZVRpbWVzdGFtcCh0aW1lc3RhbXAsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICBmb3JtYXQgPSBDT01NT05fREFURV9GT1JNQVQ7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0RGF0ZSh0aW1lc3RhbXBUb0RhdGUodGltZXN0YW1wKSwgZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlVXRjVGltZXN0YW1wKHRpbWVzdGFtcCwgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQgPT09IHZvaWQgMCkge1xuICAgIGZvcm1hdCA9IENPTU1PTl9EQVRFX0ZPUk1BVDtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXREYXRlKHV0Y1RpbWVzdGFtcFRvRGF0ZSh0aW1lc3RhbXApLCBmb3JtYXQpO1xufVxuZnVuY3Rpb24gaW5GdXR1cmUoZGF0ZSwgdXRjKSB7XG4gIGlmICh1dGMgPT09IHZvaWQgMCkge1xuICAgIHV0YyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHV0YyA/IHV0Y1RpbWUoZGF0ZSkuaXNBZnRlcih1dGNUaW1lKCkpIDogdGltZShkYXRlKS5pc0FmdGVyKHRpbWUoKSk7XG59XG5mdW5jdGlvbiBpblBhc3QoZGF0ZSwgdXRjKSB7XG4gIGlmICh1dGMgPT09IHZvaWQgMCkge1xuICAgIHV0YyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHV0YyA/IHV0Y1RpbWUoZGF0ZSkuaXNCZWZvcmUodXRjVGltZSgpKSA6IHRpbWUoZGF0ZSkuaXNCZWZvcmUodGltZSgpKTtcbn1cbmZ1bmN0aW9uIGlzU2FtZURheShzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHZvaWQgMCkge1xuICAgIGVuZCA9IHRpbWUoKTtcbiAgfVxuXG4gIHJldHVybiBkYXlqcyhzdGFydCkuaXNTYW1lKGRheWpzKGVuZCksICdkYXknKTtcbn0gLy8gU2Vjb25kcyB0aWxsIG5vdyBpZiBzZWNvbmQgcGFyYW0gZW1wdHlcblxuZnVuY3Rpb24gc2Vjb25kc0Zyb20oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB2b2lkIDApIHtcbiAgICBlbmQgPSB0aW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGF5anMoc3RhcnQpLmRpZmYoZGF5anMoZW5kKSwgJ3NlY29uZCcpO1xufVxuZnVuY3Rpb24gbWlsbGlzZWNvbmRzRnJvbShzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHZvaWQgMCkge1xuICAgIGVuZCA9IHRpbWUoKTtcbiAgfVxuXG4gIHJldHVybiBkYXlqcyhzdGFydCkuZGlmZihkYXlqcyhlbmQpKTtcbn1cbi8qKlxyXG4gKiBTcGVjaWZpYyB0byBFT1NcclxuICovXG5cbmZ1bmN0aW9uIHN0YXJ0RGF0ZShzdGFydERhdGUsIGRheXMpIHtcbiAgaWYgKGRheXMgPT09IHZvaWQgMCkge1xuICAgIGRheXMgPSAzO1xuICB9XG5cbiAgcmV0dXJuIGRheWpzKHN0YXJ0RGF0ZSkuY2xvbmUoKS5zdWJ0cmFjdChkYXlzLCAnZGF5cycpO1xufVxuZnVuY3Rpb24gZm9ybWF0U3RhcnREYXRlKHN0YXJ0VGltZXN0YW1wKSB7XG4gIHJldHVybiBzdGFydERhdGUoc3RhcnRUaW1lc3RhbXApLmZvcm1hdCgnTU1NLURELVlZWVksIGhoOm1tOnNzIEEnKTtcbn1cbmZ1bmN0aW9uIGVuZERhdGUoZW5kRGF0ZSwgZGF5cykge1xuICBpZiAoZGF5cyA9PT0gdm9pZCAwKSB7XG4gICAgZGF5cyA9IDM7XG4gIH1cblxuICByZXR1cm4gZGF5anMoZW5kRGF0ZSkuY2xvbmUoKS5hZGQoZGF5cywgJ2RheXMnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEVuZERhdGUoZW5kVGltZXN0YW1wKSB7XG4gIHJldHVybiBlbmREYXRlKGVuZFRpbWVzdGFtcCkuZm9ybWF0KCdNTU0tREQtWVlZWSwgaGg6bW06c3MgQScpO1xufVxuZnVuY3Rpb24gZGF0ZVRvVXRjVGltZVBvaW50KGRhdGUpIHtcbiAgaWYgKGRhdGUgPT09IHZvaWQgMCkge1xuICAgIGRhdGUgPSB0aW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGF5anMoZGF0ZSkudXRjKCkuZm9ybWF0KCdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycpO1xufVxudmFyIGVtcHR5VGltZVBvaW50ID0gJzE5NzAtMDEtMDFUMDA6MDA6MDAuMDAwJztcbmZ1bmN0aW9uIHBhcnNlU2Vjb25kcyhzZWNvbmRzKSB7XG4gIHZhciBkYXlzID0gMDtcbiAgdmFyIGhvdXJzID0gMDtcbiAgdmFyIG1pbnV0ZXMgPSAwO1xuICB2YXIgcGFyc2VkRGF0ZSA9ICcnOyAvLyBEYXlzXG5cbiAgaWYgKHNlY29uZHMgPiA4NjQwMCkge1xuICAgIGRheXMgKz0gTWF0aC5mbG9vcihzZWNvbmRzIC8gODY0MDApO1xuICAgIHNlY29uZHMgLT0gZGF5cyAqIDg2NDAwO1xuICAgIHBhcnNlZERhdGUgKz0gZGF5cy50b0ZpeGVkKDApICsgXCIgXCIgKyAoZGF5cyA9PT0gMSA/ICdEYXknIDogJ0RheXMnKSArIFwiIFwiO1xuICB9IC8vIEhvdXJzXG5cblxuICBpZiAoc2Vjb25kcyA+IDM2MDApIHtcbiAgICBob3VycyArPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgICBzZWNvbmRzIC09IGhvdXJzICogMzYwMDtcbiAgICBwYXJzZWREYXRlICs9IGhvdXJzLnRvRml4ZWQoMCkgKyBcIiBcIiArIChob3VycyA9PT0gMSA/ICdIb3VyJyA6ICdIb3VycycpICsgXCIgXCI7XG4gIH0gLy8gTWludXRlc1xuXG5cbiAgaWYgKHNlY29uZHMgPiA2MCkge1xuICAgIG1pbnV0ZXMgKz0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIHNlY29uZHMgLT0gbWludXRlcyAqIDYwO1xuICAgIHBhcnNlZERhdGUgKz0gbWludXRlcy50b0ZpeGVkKDApICsgXCIgXCIgKyAobWludXRlcyA9PT0gMSA/ICdNaW51dGUnIDogJ01pbnV0ZXMnKSArIFwiIFwiO1xuICB9IC8vIFNlY29uZHNcblxuXG4gIGlmIChzZWNvbmRzID4gMCkge1xuICAgIHBhcnNlZERhdGUgKz0gc2Vjb25kcy50b0ZpeGVkKDApICsgXCIgU2Vjb25kcyBcIjtcbiAgfVxuXG4gIHJldHVybiBwYXJzZWREYXRlO1xufVxuXG5leHBvcnRzLkFzc2V0ID0gQXNzZXQ7XG5leHBvcnRzLkV4dGVuZGVkQXNzZXQgPSBFeHRlbmRlZEFzc2V0O1xuZXhwb3J0cy5FeHRlbmRlZFN5bWJvbCA9IEV4dGVuZGVkU3ltYm9sO1xuZXhwb3J0cy5TeW1ib2wgPSBTeW1ib2wkMTtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5ieXRlc1RvS0IgPSBieXRlc1RvS0I7XG5leHBvcnRzLmNhbGN1bGF0ZVBlcmNlbnRhZ2UgPSBjYWxjdWxhdGVQZXJjZW50YWdlO1xuZXhwb3J0cy5jdXJyZW5jeVRvU3ltYm9sID0gY3VycmVuY3lUb1N5bWJvbDtcbmV4cG9ydHMuZGF0ZVRvVXRjVGltZVBvaW50ID0gZGF0ZVRvVXRjVGltZVBvaW50O1xuZXhwb3J0cy5kaXNwbGF5QXNzZXQgPSBkaXNwbGF5QXNzZXQ7XG5leHBvcnRzLmRpc3BsYXlOdW1iZXIgPSBkaXNwbGF5TnVtYmVyO1xuZXhwb3J0cy5kaXNwbGF5TnVtYmVyQXNBbW91bnQgPSBkaXNwbGF5TnVtYmVyQXNBbW91bnQ7XG5leHBvcnRzLmRpc3BsYXlOdW1iZXJBc0Fzc2V0ID0gZGlzcGxheU51bWJlckFzQXNzZXQ7XG5leHBvcnRzLmRpc3BsYXlOdW1iZXJBc0N1cnJlbmN5ID0gZGlzcGxheU51bWJlckFzQ3VycmVuY3k7XG5leHBvcnRzLmRpc3BsYXlSYXdOdW1iZXJBc0Fzc2V0ID0gZGlzcGxheVJhd051bWJlckFzQXNzZXQ7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuZW1wdHlUaW1lUG9pbnQgPSBlbXB0eVRpbWVQb2ludDtcbmV4cG9ydHMuZW5kRGF0ZSA9IGVuZERhdGU7XG5leHBvcnRzLmVvc0Rpc3BsYXlGb3JtYXR0aW5nID0gZW9zRGlzcGxheUZvcm1hdHRpbmc7XG5leHBvcnRzLmZvcm1hdERhdGUgPSBmb3JtYXREYXRlO1xuZXhwb3J0cy5mb3JtYXREYXRlTG9jYWwgPSBmb3JtYXREYXRlTG9jYWw7XG5leHBvcnRzLmZvcm1hdEVuZERhdGUgPSBmb3JtYXRFbmREYXRlO1xuZXhwb3J0cy5mb3JtYXRTdGFydERhdGUgPSBmb3JtYXRTdGFydERhdGU7XG5leHBvcnRzLmluRnV0dXJlID0gaW5GdXR1cmU7XG5leHBvcnRzLmluUGFzdCA9IGluUGFzdDtcbmV4cG9ydHMuaXNTYW1lRGF5ID0gaXNTYW1lRGF5O1xuZXhwb3J0cy5taWxsaXNlY29uZHNGcm9tID0gbWlsbGlzZWNvbmRzRnJvbTtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMubnVtYmVyVG9BbW91bnQgPSBudW1iZXJUb0Ftb3VudDtcbmV4cG9ydHMubnVtYmVyVG9BbW91bnRGb3JtYXR0ZWQgPSBudW1iZXJUb0Ftb3VudEZvcm1hdHRlZDtcbmV4cG9ydHMubnVtYmVyVG9Bc3NldCA9IG51bWJlclRvQXNzZXQ7XG5leHBvcnRzLm51bWJlclRvRW9zID0gbnVtYmVyVG9Fb3M7XG5leHBvcnRzLm51bWJlclRvRW9zUm91bmRVcCA9IG51bWJlclRvRW9zUm91bmRVcDtcbmV4cG9ydHMucGFyc2VDcHUgPSBwYXJzZUNwdTtcbmV4cG9ydHMucGFyc2VOZXRBbmRSYW0gPSBwYXJzZU5ldEFuZFJhbTtcbmV4cG9ydHMucGFyc2VSZXggPSBwYXJzZVJleDtcbmV4cG9ydHMucGFyc2VTZWNvbmRzID0gcGFyc2VTZWNvbmRzO1xuZXhwb3J0cy5wYXJzZVRpbWVzdGFtcCA9IHBhcnNlVGltZXN0YW1wO1xuZXhwb3J0cy5wYXJzZVV0Y1RpbWVzdGFtcCA9IHBhcnNlVXRjVGltZXN0YW1wO1xuZXhwb3J0cy5zZWNvbmRzRnJvbSA9IHNlY29uZHNGcm9tO1xuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuZXhwb3J0cy5zdGFydERhdGUgPSBzdGFydERhdGU7XG5leHBvcnRzLnN1YnN0cmFjdCA9IHN1YnN0cmFjdDtcbmV4cG9ydHMudGltZSA9IHRpbWU7XG5leHBvcnRzLnRpbWVzdGFtcEZyb21Ob3cgPSB0aW1lc3RhbXBGcm9tTm93O1xuZXhwb3J0cy50aW1lc3RhbXBUb0RhdGUgPSB0aW1lc3RhbXBUb0RhdGU7XG5leHBvcnRzLnRvQk4gPSB0b0JOO1xuZXhwb3J0cy50b051bWJybyA9IHRvTnVtYnJvO1xuZXhwb3J0cy51bml4VGltZSA9IHVuaXhUaW1lO1xuZXhwb3J0cy51dGNUaW1lID0gdXRjVGltZTtcbmV4cG9ydHMudXRjVGltZVRvTG9jYWwgPSB1dGNUaW1lVG9Mb2NhbDtcbmV4cG9ydHMudXRjVGltZXN0YW1wRnJvbU5vdyA9IHV0Y1RpbWVzdGFtcEZyb21Ob3c7XG5leHBvcnRzLnV0Y1RpbWVzdGFtcFRvRGF0ZSA9IHV0Y1RpbWVzdGFtcFRvRGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlcnMuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIiwiaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgJ2Zhc3QtdGV4dC1lbmNvZGluZyc7XG5pbXBvcnQgcXVlcnkgZnJvbSAncXMnO1xuXG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovXG5cbiAgX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfTtcblxuICB2YXIgZXhwb3J0cyA9IHt9LFxuICAgICAgT3AgPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksXG4gICAgICAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICAgIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICAgIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIixcbiAgICAgIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwXG4gICAgfSksIG9ialtrZXldO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLFxuICAgICAgICBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksXG4gICAgICAgIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvci5faW52b2tlID0gZnVuY3Rpb24gKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuXG4gICAgICAgIGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkge1xuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnO1xuICAgICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgICAgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgICBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KGlubmVyRm4sIHNlbGYsIGNvbnRleHQpLCBnZW5lcmF0b3I7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgYXJnOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7XG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICAgIGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnLFxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWx1ZSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgdGhpcy5faW52b2tlID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcblxuICAgIGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkge1xuICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSkgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7XG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgIHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICB9O1xuICAgIDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBkb25lUmVzdWx0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkb25lOiAhMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSksIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbiksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7XG4gIH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjtcbiAgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX19hd2FpdDogYXJnXG4gICAgfTtcbiAgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpO1xuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICB9KTtcbiAgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpO1xuXG4gICAgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgZm9yICg7IGtleXMubGVuZ3RoOykge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgIH07XG4gIH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kb25lID0gITA7XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uO1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sXG4gICAgICAgICAgICByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLFxuICAgICAgICAgICAgICBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uICh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7XG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG4gICAgZmluaXNoOiBmdW5jdGlvbiAoZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2F0Y2g6IGZ1bmN0aW9uICh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiAoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9LCBleHBvcnRzO1xufVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIGNsb25lRGVlcEFycmF5T2ZPYmooYXJyYXkpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChhcnJheSkubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBpKTtcbiAgfSk7XG59XG5cbnZhciBjaGFybWFwID0gJy4xMjM0NWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcbmZ1bmN0aW9uIGNoYXJpZHgoY2gpIHtcbiAgdmFyIGlkeCA9IGNoYXJtYXAuaW5kZXhPZihjaCk7XG5cbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXI6ICdcIiArIGNoICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGVuY29kZU5hbWUobmFtZSwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmIChsaXR0bGVFbmRpYW4gPT09IHZvaWQgMCkge1xuICAgIGxpdHRsZUVuZGlhbiA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25hbWUgcGFyYW1ldGVyIGlzIGEgcmVxdWlyZWQgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAobmFtZS5sZW5ndGggPiAxMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgbmFtZSBjYW4gYmUgdXAgdG8gMTIgY2hhcmFjdGVycyBsb25nJyk7XG4gIH1cblxuICB2YXIgYml0c3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMTI7IGkrKykge1xuICAgIC8vIHByb2Nlc3MgYWxsIDY0IGJpdHMgKGV2ZW4gaWYgbmFtZSBpcyBzaG9ydClcbiAgICB2YXIgYyA9IGkgPCBuYW1lLmxlbmd0aCA/IGNoYXJpZHgobmFtZVtpXSkgOiAwO1xuICAgIHZhciBiaXRsZW4gPSBpIDwgMTIgPyA1IDogNDtcbiAgICB2YXIgYml0cyA9IE51bWJlcihjKS50b1N0cmluZygyKTtcblxuICAgIGlmIChiaXRzLmxlbmd0aCA+IGJpdGxlbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG5cbiAgICBiaXRzID0gJzAnLnJlcGVhdChiaXRsZW4gLSBiaXRzLmxlbmd0aCkgKyBiaXRzO1xuICAgIGJpdHN0ciArPSBiaXRzO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKGJpdHN0ciwgdHJ1ZSwgMik7IC8vIGNvbnZlcnQgdG8gTElUVExFX0VORElBTlxuXG4gIHZhciBsZUhleCA9ICcnO1xuICB2YXIgYnl0ZXMgPSBsaXR0bGVFbmRpYW4gPyB2YWx1ZS50b0J5dGVzTEUoKSA6IHZhbHVlLnRvQnl0ZXNCRSgpO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYnl0ZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgIHZhciBiID0gX3N0ZXAudmFsdWU7XG4gICAgdmFyIG4gPSBOdW1iZXIoYikudG9TdHJpbmcoMTYpO1xuICAgIGxlSGV4ICs9IChuLmxlbmd0aCA9PT0gMSA/ICcwJyA6ICcnKSArIG47XG4gIH1cblxuICB2YXIgdWxOYW1lID0gTG9uZy5mcm9tU3RyaW5nKGxlSGV4LCB0cnVlLCAxNikudG9TdHJpbmcoKTsgLy8gY29uc29sZS5sb2coJ2VuY29kZU5hbWUnLCBuYW1lLCB2YWx1ZS50b1N0cmluZygpLCB1bE5hbWUudG9TdHJpbmcoKSwgSlNPTi5zdHJpbmdpZnkoYml0c3RyLnNwbGl0KC8oLi4uLi4pLykuc2xpY2UoMSkpKVxuXG4gIHJldHVybiB1bE5hbWUudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZU5hbWUoZW5jb2RlZE5hbWUsIGxpdHRsZUVuZGlhbikge1xuICBpZiAobGl0dGxlRW5kaWFuID09PSB2b2lkIDApIHtcbiAgICBsaXR0bGVFbmRpYW4gPSB0cnVlO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKGVuY29kZWROYW1lKTsgLy8gY29udmVydCBmcm9tIExJVFRMRV9FTkRJQU5cblxuICB2YXIgYmVIZXggPSAnJztcbiAgdmFyIGJ5dGVzID0gbGl0dGxlRW5kaWFuID8gdmFsdWUudG9CeXRlc0xFKCkgOiB2YWx1ZS50b0J5dGVzQkUoKTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShieXRlcyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgdmFyIGIgPSBfc3RlcDIudmFsdWU7XG4gICAgdmFyIG4gPSBOdW1iZXIoYikudG9TdHJpbmcoMTYpO1xuICAgIGJlSGV4ICs9IChuLmxlbmd0aCA9PT0gMSA/ICcwJyA6ICcnKSArIG47XG4gIH1cblxuICBiZUhleCArPSAnMCcucmVwZWF0KDE2IC0gYmVIZXgubGVuZ3RoKTtcbiAgdmFyIGZpdmVCaXRzID0gTG9uZy5mcm9tTnVtYmVyKDB4MWYsIHRydWUpO1xuICB2YXIgZm91ckJpdHMgPSBMb25nLmZyb21OdW1iZXIoMHgwZiwgdHJ1ZSk7XG4gIHZhciBiZVZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKGJlSGV4LCB0cnVlLCAxNik7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIHRtcCA9IGJlVmFsdWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMTI7IGkrKykge1xuICAgIHZhciBjID0gY2hhcm1hcFt0bXAuYW5kKGkgPT09IDAgPyBmb3VyQml0cyA6IGZpdmVCaXRzKV07XG4gICAgc3RyID0gYyArIHN0cjtcbiAgICB0bXAgPSB0bXAuc2hpZnRSaWdodChpID09PSAwID8gNCA6IDUpO1xuICB9XG5cbiAgc3RyID0gc3RyLnJlcGxhY2UoL1xcLiskLywgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgZG90cyAoYWxsIG9mIHRoZW0pXG4gIC8vIGNvbnNvbGUubG9nKCdkZWNvZGVOYW1lJywgc3RyLCBiZVZhbHVlLnRvU3RyaW5nKCksIHZhbHVlLnRvU3RyaW5nKCksIEpTT04uc3RyaW5naWZ5KGJlVmFsdWUudG9TdHJpbmcoMikuc3BsaXQoLyguLi4uLikvKS5zbGljZSgxKSkpXG5cbiAgcmV0dXJuIHN0cjtcbn1cbi8qKlxyXG4gKiBGSU8gU1BFQ0lGSUNcclxuICogQHBhcmFtIGtleSBGSU9cclxuICovXG5cbnZhciBzaG9ydGVuX2tleSA9IGZ1bmN0aW9uIHNob3J0ZW5fa2V5KGtleSkge1xuICB2YXIgcmVzID0gbmV3IExvbmcoMCwgMCwgdHJ1ZSk7XG4gIHZhciBpID0gMTsgLy8gSWdub3JlIGtleSBoZWFkXG5cbiAgdmFyIGxlbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiA8PSAxMikge1xuICAgIGlmIChpID49IDMzKSB0aHJvdyBuZXcgRXJyb3IoJ0ZJTzogaSB0b28gbGFyZ2UnKTtcbiAgICB2YXIgdHJpbW1lZF9jaGFyID0ga2V5W2ldICYgKGxlbiA9PSAxMiA/IDB4MGYgOiAweDFmKTtcblxuICAgIGlmICh0cmltbWVkX2NoYXIgPT0gMCkge1xuICAgICAgaSsrO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBTa2lwIGEgemVybyBhbmQgbW92ZSB0byBuZXh0XG5cblxuICAgIHZhciBzaHVmZmxlID0gbGVuID09IDEyID8gMCA6IDUgKiAoMTIgLSBsZW4pIC0gMTtcbiAgICByZXMgPSByZXMub3IoTG9uZy5mcm9tTnVtYmVyKHNoaWZ0KHRyaW1tZWRfY2hhciwgc2h1ZmZsZSksIHRydWUpKTtcbiAgICBsZW4rKztcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gc2hpZnQobnVtYmVyLCBzaGlmdCkge1xuICByZXR1cm4gbnVtYmVyICogTWF0aC5wb3coMiwgc2hpZnQpO1xufVxuXG52YXIgZmlvS2V5VG9BY3RvciA9IGZ1bmN0aW9uIGZpb0tleVRvQWN0b3Ioa2V5LCBzdHJpbmdUb1B1YmxpY0tleSkge1xuICB2YXIgcHViS2V5ID0gc3RyaW5nVG9QdWJsaWNLZXkoa2V5LCAnRklPJykuZGF0YTtcbiAgdmFyIHNob3J0ZW5lZFB1YktleSA9IHNob3J0ZW5fa2V5KHB1YktleSk7XG4gIHZhciBkZWNvZGVkTmFtZSA9IGRlY29kZU5hbWUoc2hvcnRlbmVkUHViS2V5LnRvU3RyaW5nKCksIGZhbHNlKTtcbiAgcmV0dXJuIGRlY29kZWROYW1lLnN1YnN0cigwLCAxMik7XG59OyAvLyBjb252ZXJ0IGJ5dGVzIHRvIGEgU3RyaW5nXG5cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cblxuICByZXR1cm4gYnl0ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9ieXRlKSB7XG4gICAgcmV0dXJuIGFjYyArIFN0cmluZy5mcm9tQ2hhckNvZGUoX2J5dGUpO1xuICB9LCAnJyk7XG59XG4vKipcclxuICogQ2hlY2tzIGlmIHN0cmluZ1xyXG4gKi9cblxuZnVuY3Rpb24gaXNTdHJpbmcoc3RyaW5nKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RyaW5nKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG4vKipcclxuICpcclxuICogQHBhcmFtIG1lc3NhZ2UgU2hhMjU2XHJcbiAqL1xuXG5mdW5jdGlvbiBzaGEoX3gsIF94MiwgX3gzKSB7XG4gIHJldHVybiBfc2hhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcclxuICogRklPIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSBzdHIgZXhhbXBsZTogY29pbm9taVxyXG4gKiBAcmV0dXJucyByZXR1cm5zOiA5NjhiYTg0NjE3YjczYjhlMmE3M2I1OTE3MDk3NmY0MVxyXG4gKi9cblxuZnVuY3Rpb24gX3NoYSgpIHtcbiAgX3NoYSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShtZXNzYWdlLCBiaW5hcnlSZXByZXNlbnRhdGlvbk9mSGV4LCB0eXBlKSB7XG4gICAgdmFyIGVuY29kZWRNZXNzYWdlLCBtYXRjaGVkLCBtYXBwZWQsIGhhc2hCdWZmZXIsIGhhc2hBcnJheSwgaGFzaEhleDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoYmluYXJ5UmVwcmVzZW50YXRpb25PZkhleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGJpbmFyeVJlcHJlc2VudGF0aW9uT2ZIZXggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0eXBlID0gJ1NIQS0yNTYnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWJpbmFyeVJlcHJlc2VudGF0aW9uT2ZIZXgpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2hlZCA9IG1lc3NhZ2UubWF0Y2goL1tcXGRhLWZdezJ9L2dpKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRW1wdHkgbWVzc2FnZScpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgbWFwcGVkID0gbWF0Y2hlZC5tYXAoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGgsIDE2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZW5jb2RlZE1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtYXBwZWQpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgZW5jb2RlZE1lc3NhZ2UgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWVzc2FnZSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGlnZXN0KHR5cGUsIGVuY29kZWRNZXNzYWdlKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBoYXNoQnVmZmVyID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIC8vIGhhc2ggdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcikpOyAvLyBjb252ZXJ0IGJ1ZmZlciB0byBieXRlIGFycmF5XG5cbiAgICAgICAgICAgIGhhc2hIZXggPSBoYXNoQXJyYXkubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICAgICAgfSkuam9pbignJyk7IC8vIGNvbnZlcnQgYnl0ZXMgdG8gaGV4IHN0cmluZ1xuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGhhc2hIZXgpO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9zaGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nX3RvX3VpbnQxMjhfaGFzaChfeDQpIHtcbiAgcmV0dXJuIF9zdHJpbmdfdG9fdWludDEyOF9oYXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zdHJpbmdfdG9fdWludDEyOF9oYXNoKCkge1xuICBfc3RyaW5nX3RvX3VpbnQxMjhfaGFzaCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoc3RyKSB7XG4gICAgdmFyIGhleEJ5dGVzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gc2hhKHN0ciwgZmFsc2UsICdTSEEtMScpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaGV4Qnl0ZXMgPSBfY29udGV4dDIuc2VudC5tYXRjaCgvLi4vZyk7XG5cbiAgICAgICAgICAgIGlmICghaGV4Qnl0ZXMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgaGV4Qnl0ZXMuc2xpY2UoMCwgLTQpLnJldmVyc2UoKS5qb2luKCcnKSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCAwKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX3N0cmluZ190b191aW50MTI4X2hhc2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbmF0aXZlVHJhbnNmb3JtR2V0QWN0aW9ucyhyZXN1bHQsIGNvbnN0YW50cykge1xuICByZXN1bHQuYWN0aW9ucyA9IHJlc3VsdC5hY3Rpb25zLm1hcChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgaWYgKGFjdGlvblsnYWN0aW9uX3RyYWNlJ11bJ2FjdCddWydhY2NvdW50J10gPT09IGNvbnN0YW50cy5FT1NJTyAmJiBhY3Rpb25bJ2FjdGlvbl90cmFjZSddWydhY3QnXVsnbmFtZSddID09PSAnY2xhaW1yZXdhcmRzJyAmJiBhY3Rpb25bJ2FjdGlvbl90cmFjZSddWydpbmxpbmVfdHJhY2VzJ10pIHtcbiAgICAgIHZhciB0b3RhbEFtb3VudCA9IDA7XG4gICAgICB2YXIgdG90YWxTeW1ib2wgPSAnJztcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY3Rpb25bJ2FjdGlvbl90cmFjZSddWydpbmxpbmVfdHJhY2VzJ10pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgICB2YXIgaW5saW5lX3RyYWNlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgaWYgKGlubGluZV90cmFjZVsnYWN0J11bJ2RhdGEnXVsnZnJvbSddID09PSBjb25zdGFudHMuRU9TSU9fVlBBWSB8fCBpbmxpbmVfdHJhY2VbJ2FjdCddWydkYXRhJ11bJ2Zyb20nXSA9PT0gY29uc3RhbnRzLkVPU0lPX0JQQVkpIHtcbiAgICAgICAgICB2YXIgX2lubGluZV90cmFjZSRhY3QkZGF0ID0gaW5saW5lX3RyYWNlWydhY3QnXVsnZGF0YSddWydxdWFudGl0eSddLnNwbGl0KCcgJyksXG4gICAgICAgICAgICAgIGFtb3VudCA9IF9pbmxpbmVfdHJhY2UkYWN0JGRhdFswXSxcbiAgICAgICAgICAgICAgc3ltYm9sID0gX2lubGluZV90cmFjZSRhY3QkZGF0WzFdO1xuXG4gICAgICAgICAgdG90YWxBbW91bnQgKz0gTnVtYmVyKGFtb3VudCk7XG4gICAgICAgICAgdG90YWxTeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWN0aW9uWydhY3Rpb25fdHJhY2UnXVsnYWN0J11bJ2RhdGEnXVsncXVhbnRpdHknXSA9IHRvdGFsQW1vdW50LnRvRml4ZWQoY29uc3RhbnRzLkNPUkVfUFJFQ0lTSU9OKSArIFwiIFwiICsgdG90YWxTeW1ib2w7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfSkucmV2ZXJzZSgpO1xuICByZXN1bHQubnVtT2ZUeExvYWRlZCA9IHJlc3VsdC5hY3Rpb25zLmxlbmd0aDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGh5cGVyaW9uVHJhbnNmb3JtR2V0QWN0aW9ucyhfcmVmKSB7XG4gIHZhciBxdWVyeV90aW1lID0gX3JlZi5xdWVyeV90aW1lLFxuICAgICAgbGliID0gX3JlZi5saWIsXG4gICAgICBhY3Rpb25zID0gX3JlZi5hY3Rpb25zLFxuICAgICAgX3JlZiR0b3RhbCA9IF9yZWYudG90YWwsXG4gICAgICByZWxhdGlvbiA9IF9yZWYkdG90YWwucmVsYXRpb24sXG4gICAgICB2YWx1ZSA9IF9yZWYkdG90YWwudmFsdWU7XG4gIHZhciB0cmFuc2Zvcm1lZEFjdGlvbnMgPSBbXTtcbiAgdmFyIGFjdF9kaWdlc3QgPSAwO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjdGlvbnMpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgIHZhciBhY3Rpb24gPSBfc3RlcDIudmFsdWU7XG4gICAgYWN0aW9uLnJlY2VpcHQgPSB7XG4gICAgICBhY3RfZGlnZXN0OiBhY3RfZGlnZXN0KytcbiAgICB9O1xuICAgIGFjdGlvbi5ibG9ja190aW1lID0gYWN0aW9uWydAdGltZXN0YW1wJ107IC8vIFNldCBxdWFudGl0eVxuXG4gICAgaWYgKGFjdGlvbi5hY3QuZGF0YSAmJiBhY3Rpb24uYWN0LmRhdGEuYW1vdW50ICYmIGFjdGlvbi5hY3QuZGF0YS5zeW1ib2wpIHtcbiAgICAgIGFjdGlvbi5hY3QuZGF0YS5xdWFudGl0eSA9IGFjdGlvbi5hY3QuZGF0YS5hbW91bnQgKyBcIiBcIiArIGFjdGlvbi5hY3QuZGF0YS5zeW1ib2w7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtZWRBY3Rpb25zLnB1c2goe1xuICAgICAgYWN0aW9uX3RyYWNlOiBhY3Rpb25cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGliOiBsaWIsXG4gICAgYWN0aW9uczogdHJhbnNmb3JtZWRBY3Rpb25zLFxuICAgIHF1ZXJ5X3RpbWU6IHF1ZXJ5X3RpbWUsXG4gICAgbnVtT2ZUeExvYWRlZDogYWN0aW9ucy5sZW5ndGgsXG4gICAgdG90YWw6IHtcbiAgICAgIHJlbGF0aW9uOiByZWxhdGlvbixcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRmdXNlVHJhbnNmb3JtR2V0QWN0aW9ucyhfcmVmMiwgYWNjb3VudE5hbWUsIGNvbnN0YW50cykge1xuICB2YXIgdHJhbnNhY3Rpb25zID0gX3JlZjIudHJhbnNhY3Rpb25zLFxuICAgICAgY3Vyc29yID0gX3JlZjIuY3Vyc29yO1xuXG4gIC8vIEVycm9yIGNoZWNraW5nXG4gIGlmICghdHJhbnNhY3Rpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnNvcjogY3Vyc29yLFxuICAgICAgYWN0aW9uczogW10sXG4gICAgICBudW1PZlR4TG9hZGVkOiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBhY3Rpb25zID0gW107XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodHJhbnNhY3Rpb25zKSwgX3N0ZXAzOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMoKSkuZG9uZTspIHtcbiAgICB2YXIgdHJhbnNhY3Rpb24gPSBfc3RlcDMudmFsdWU7XG4gICAgdmFyIGxpZmVjeWNsZSA9IHRyYW5zYWN0aW9uLmxpZmVjeWNsZSxcbiAgICAgICAgYWN0aW9uX2lkeCA9IHRyYW5zYWN0aW9uLmFjdGlvbl9pZHg7IC8vIEdSQVBIUUwgLT4gRE9lc250IGdpdmUgYWN0aW9uX2lkeCBzaW5jZSBpdHMgbWF0Y2hcblxuICAgIGlmICghYWN0aW9uX2lkeCkge1xuICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KGxpZmVjeWNsZVsnZXhlY3V0aW9uX3RyYWNlJ11bJ2FjdGlvbl90cmFjZXMnXS5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbl90cmFjZTogYWN0aW9uXG4gICAgICAgIH07XG4gICAgICB9KS5yZXZlcnNlKCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRfaWR4ID0gMDtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGxpZmVjeWNsZVsnZXhlY3V0aW9uX3RyYWNlJ11bJ2FjdGlvbl90cmFjZXMnXSksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICB2YXIgYWN0aW9uX3RyYWNlID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgLy8gRml4IGhvbGVzXG4gICAgICBpZiAoIWFjdGlvbl90cmFjZVsnaW5saW5lX3RyYWNlcyddKSBhY3Rpb25fdHJhY2VbJ2lubGluZV90cmFjZXMnXSA9IFtdOyAvLyBCUCBDTEFJTSBSRVdBUkRTXG5cbiAgICAgIGlmIChhY3Rpb25fdHJhY2VbJ2FjdCddWydhY2NvdW50J10gPT09IGNvbnN0YW50cy5FT1NJTyAmJiBhY3Rpb25fdHJhY2VbJ2FjdCddWyduYW1lJ10gPT09ICdjbGFpbXJld2FyZHMnKSB7XG4gICAgICAgIHZhciB0b3RhbEFtb3VudCA9IDA7XG4gICAgICAgIHZhciB0b3RhbFN5bWJvbCA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjdGlvbl90cmFjZVsnaW5saW5lX3RyYWNlcyddKSwgX3N0ZXA1OyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUoKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgaW5saW5lX3RyYWNlID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGlubGluZV90cmFjZVsnYWN0J11bJ2RhdGEnXVsnZnJvbSddID09PSBjb25zdGFudHMuRU9TSU9fVlBBWSB8fCBpbmxpbmVfdHJhY2VbJ2FjdCddWydkYXRhJ11bJ2Zyb20nXSA9PT0gY29uc3RhbnRzLkVPU0lPX0JQQVkpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIGFjdGlvbl90cmFjZTogaW5saW5lX3RyYWNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIF9pbmxpbmVfdHJhY2UkYWN0JGRhdDIgPSBpbmxpbmVfdHJhY2VbJ2FjdCddWydkYXRhJ11bJ3F1YW50aXR5J10uc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICBhbW91bnQgPSBfaW5saW5lX3RyYWNlJGFjdCRkYXQyWzBdLFxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IF9pbmxpbmVfdHJhY2UkYWN0JGRhdDJbMV07XG5cbiAgICAgICAgICAgIHRvdGFsQW1vdW50ICs9IE51bWJlcihhbW91bnQpO1xuICAgICAgICAgICAgdG90YWxTeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWN0aW9uX3RyYWNlWydhY3QnXVsnZGF0YSddWydxdWFudGl0eSddID0gdG90YWxBbW91bnQudG9GaXhlZChjb25zdGFudHMuQ09SRV9QUkVDSVNJT04pICsgXCIgXCIgKyB0b3RhbFN5bWJvbDtcbiAgICAgICAgZGVsZXRlIGFjdGlvbl90cmFjZS5pbmxpbmVfdHJhY2VzO1xuICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgIGFjdGlvbl90cmFjZTogYWN0aW9uX3RyYWNlXG4gICAgICAgIH0pOyAvLyBSRVggc2VsbFxuICAgICAgfSBlbHNlIGlmIChhY3Rpb25fdHJhY2VbJ2FjdCddWydhY2NvdW50J10gPT09IGNvbnN0YW50cy5FT1NJTyAmJiBhY3Rpb25fdHJhY2VbJ2FjdCddWyduYW1lJ10gPT09ICdzZWxscmV4Jykge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY3Rpb25fdHJhY2VbJ2lubGluZV90cmFjZXMnXSksIF9zdGVwNjsgIShfc3RlcDYgPSBfaXRlcmF0b3I2KCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9pbmxpbmVfdHJhY2UgPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICBpZiAoX2lubGluZV90cmFjZVsnYWN0J11bJ2FjY291bnQnXSA9PT0gY29uc3RhbnRzLkVPU0lPX1JFWCB8fCBfaW5saW5lX3RyYWNlWydhY3QnXVsnbmFtZSddID09PSAnc2VsbHJlc3VsdCcpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIGFjdGlvbl90cmFjZTogX2lubGluZV90cmFjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGFjdGlvbl90cmFjZS5pbmxpbmVfdHJhY2VzO1xuICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgIGFjdGlvbl90cmFjZTogYWN0aW9uX3RyYWNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBkb25lIGZvciBvcmRlcmluZyBvZiBUWFxuICAgICAgICB2YXIgbG9jYWxfYWN0aW9ucyA9IFtdO1xuICAgICAgICBjdXJyZW50X2lkeCA9IGRmdXNlRXh0cmFjdEFjdGlvbnMoYWNjb3VudE5hbWUsIGFjdGlvbl90cmFjZSwgbG9jYWxfYWN0aW9ucywgYWN0aW9uX2lkeCwgY3VycmVudF9pZHgpO1xuICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQobG9jYWxfYWN0aW9ucy5yZXZlcnNlKCkpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50X2lkeCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3Vyc29yOiBjdXJzb3IsXG4gICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICBudW1PZlR4TG9hZGVkOiB0cmFuc2FjdGlvbnMubGVuZ3RoXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRmdXNlRXh0cmFjdEFjdGlvbnMoYWNjb3VudE5hbWUsIGFjdGlvbiwgdHJhY2VzLCBhY3Rpb25faWR4LCBjdXJyZW50X2lkeCkge1xuICBpZiAoYWN0aW9uX2lkeC5pbmNsdWRlcyhjdXJyZW50X2lkeCkpIHtcbiAgICB0cmFjZXMucHVzaCh7XG4gICAgICBhY3Rpb25fdHJhY2U6IGFjdGlvblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFjdGlvblsnaW5saW5lX3RyYWNlcyddKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWN0aW9uWydpbmxpbmVfdHJhY2VzJ10pLCBfc3RlcDc7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNygpKS5kb25lOykge1xuICAgICAgdmFyIGlubGluZV90cmFjZSA9IF9zdGVwNy52YWx1ZTtcbiAgICAgIGN1cnJlbnRfaWR4Kys7XG4gICAgICBjdXJyZW50X2lkeCA9IGRmdXNlRXh0cmFjdEFjdGlvbnMoYWNjb3VudE5hbWUsIGlubGluZV90cmFjZSwgdHJhY2VzLCBhY3Rpb25faWR4LCBjdXJyZW50X2lkeCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGFjdGlvblsnaW5saW5lX3RyYWNlcyddO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRfaWR4O1xufVxuXG5mdW5jdGlvbiBkZnVzZURlcHRoRmlyc3RFeHRyYWN0KHJlc3VsdCkge1xuICB2YXIgdHJhbnNhY3Rpb25zID0gcmVzdWx0LnRyYW5zYWN0aW9ucyxcbiAgICAgIGN1cnNvciA9IHJlc3VsdC5jdXJzb3I7XG4gIHZhciBhY3Rpb25zID0gW107XG5cbiAgaWYgKHRyYW5zYWN0aW9ucykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRyYW5zYWN0aW9ucyksIF9zdGVwODsgIShfc3RlcDggPSBfaXRlcmF0b3I4KCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBfc3RlcDgudmFsdWU7XG4gICAgICB2YXIgbGlmZWN5Y2xlID0gdHJhbnNhY3Rpb24ubGlmZWN5Y2xlLFxuICAgICAgICAgIGFjdGlvbl9pZHggPSB0cmFuc2FjdGlvbi5hY3Rpb25faWR4O1xuICAgICAgdmFyIHRyYWNlcyA9IGxpZmVjeWNsZVsnZXhlY3V0aW9uX3RyYWNlJ11bJ2FjdGlvbl90cmFjZXMnXTtcbiAgICAgIHZhciBjdXJyZW50X2lkeCA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRyYWNlcyksIF9zdGVwOTsgIShfc3RlcDkgPSBfaXRlcmF0b3I5KCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciB0cmFjZSA9IF9zdGVwOS52YWx1ZTtcbiAgICAgICAgY3VycmVudF9pZHggPSBkZnVzZURlcHRoRmlyc3RFeHRyYWN0SGVscGVyKHRyYWNlLCBsaWZlY3ljbGVbJ2Rib3BzJ10sIGFjdGlvbnMsIGFjdGlvbl9pZHgsIGN1cnJlbnRfaWR4KTtcbiAgICAgICAgY3VycmVudF9pZHgrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgY3Vyc29yOiBjdXJzb3JcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGZ1c2VEZXB0aEZpcnN0RXh0cmFjdEhlbHBlcihhY3Rpb24sIGRib3BzLCBhbGxBY3Rpb25zLCBhY3Rpb25faWR4LCBjdXJyZW50SWR4KSB7XG4gIGlmIChhY3Rpb25faWR4ICYmIGFjdGlvbl9pZHguaW5jbHVkZXMoY3VycmVudElkeCkpIHtcbiAgICBhbGxBY3Rpb25zLnB1c2goe1xuICAgICAgYWN0aW9uX3RyYWNlOiBhY3Rpb24sXG4gICAgICBkYm9wczogZGJvcHMuZmlsdGVyKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICByZXR1cm4gb3AuYWN0aW9uX2lkeCA9PT0gY3VycmVudElkeDtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cblxuICBpZiAoYWN0aW9uWydpbmxpbmVfdHJhY2VzJ10pIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IxMCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWN0aW9uWydpbmxpbmVfdHJhY2VzJ10pLCBfc3RlcDEwOyAhKF9zdGVwMTAgPSBfaXRlcmF0b3IxMCgpKS5kb25lOykge1xuICAgICAgdmFyIHRyYWNlID0gX3N0ZXAxMC52YWx1ZTtcbiAgICAgIGN1cnJlbnRJZHggPSBkZnVzZURlcHRoRmlyc3RFeHRyYWN0SGVscGVyKHRyYWNlLCBkYm9wcywgYWxsQWN0aW9ucywgYWN0aW9uX2lkeCwgKytjdXJyZW50SWR4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudElkeDtcbn1cblxuZnVuY3Rpb24gaHlwZXJpb25UcmFuc2Zvcm1GbGF0VHJhY2VzKHRyYWNlcykge1xuICB2YXIgdHJhY2VzQnlPcmRpbmFsID0gdHJhY2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0cmFjZSkge1xuICAgIGFjY1t0cmFjZS5hY3Rpb25fb3JkaW5hbF0gPSBfZXh0ZW5kcyh7fSwgdHJhY2UsIHtcbiAgICAgIHRyYWNlczogW10sXG4gICAgICBhY2NvdW50X3JhbV9kZWx0YXM6IHRyYWNlLmFjY291bnRfcmFtX2RlbHRhcyxcbiAgICAgIHJlY2VpdmVyczogdHJhY2Uubm90aWZpZWRcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMTEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRyYWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYWN0aW9uX29yZGluYWwgLSBhLmFjdGlvbl9vcmRpbmFsO1xuICB9KSksIF9zdGVwMTE7ICEoX3N0ZXAxMSA9IF9pdGVyYXRvcjExKCkpLmRvbmU7KSB7XG4gICAgdmFyIHRyYWNlID0gX3N0ZXAxMS52YWx1ZTtcblxuICAgIC8vIFNraXAgdG9wIGxldmVsIGFjdGlvbnNcbiAgICBpZiAodHJhY2UuY3JlYXRvcl9hY3Rpb25fb3JkaW5hbCA9PT0gMCB8fCAhdHJhY2VzQnlPcmRpbmFsW3RyYWNlLmNyZWF0b3JfYWN0aW9uX29yZGluYWxdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudElubGluZVRyYWNlcyA9IHRyYWNlc0J5T3JkaW5hbFt0cmFjZS5jcmVhdG9yX2FjdGlvbl9vcmRpbmFsXS50cmFjZXMgfHwgW107XG4gICAgdmFyIG5ld0lubGluZVRyYWNlcyA9IFt0cmFjZXNCeU9yZGluYWxbdHJhY2UuYWN0aW9uX29yZGluYWxdXTtcbiAgICBkZWxldGUgdHJhY2VzQnlPcmRpbmFsW3RyYWNlLmFjdGlvbl9vcmRpbmFsXTtcbiAgICB0cmFjZXNCeU9yZGluYWxbdHJhY2UuY3JlYXRvcl9hY3Rpb25fb3JkaW5hbF0udHJhY2VzID0gbmV3SW5saW5lVHJhY2VzLmNvbmNhdChjdXJyZW50SW5saW5lVHJhY2VzKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBPYmplY3QudmFsdWVzKHRyYWNlc0J5T3JkaW5hbCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoeXBlcmlvblRyYW5zZm9ybVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25zID0gdHJhbnNhY3Rpb24uYWN0aW9ucyxcbiAgICAgIGxpYiA9IHRyYW5zYWN0aW9uLmxpYixcbiAgICAgIHRyeF9pZCA9IHRyYW5zYWN0aW9uLnRyeF9pZDtcbiAgdmFyIGZpcnN0QWN0aW9uID0gYWN0aW9uc1swXTsgLy8gUGFyZW50IG9ubHkgb24gPCAxLjhcblxuICB2YXIgdHJhbnNmb3JtZWRBY3Rpb25zID0gZmlyc3RBY3Rpb24ucGFyZW50ID8gYWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgcmV0dXJuIHRyYWNlLnBhcmVudCA9PT0gMDtcbiAgfSkgOiBhY3Rpb25zO1xuICB2YXIgdHJhY2VzID0gaHlwZXJpb25UcmFuc2Zvcm1GbGF0VHJhY2VzKGFjdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogJ0V4ZWN1dGVkJyxcbiAgICBjcHVfdXNhZ2U6IGZpcnN0QWN0aW9uLmNwdV91c2FnZV91cyxcbiAgICBuZXRfdXNhZ2U6IGZpcnN0QWN0aW9uLm5ldF91c2FnZV93b3JkcyAqIDgsXG4gICAgaWQ6IHRyeF9pZCxcbiAgICBibG9ja190aW1lOiBmaXJzdEFjdGlvblsnQHRpbWVzdGFtcCddLFxuICAgIGJsb2NrX251bTogZmlyc3RBY3Rpb25bJ2Jsb2NrX251bSddLFxuICAgIGRlbGF5X3NlYzogJ04vQScsXG4gICAgZXhwaXJhdGlvbjogJ04vQScsXG4gICAgbGliOiBsaWIsXG4gICAgYWN0aW9uczogdHJhbnNmb3JtZWRBY3Rpb25zLFxuICAgIHRyYWNlczogdHJhY2VzXG4gIH07XG59XG5mdW5jdGlvbiBkZnVzZVRyYW5zZm9ybVRyYWNlKF9yZWYzKSB7XG4gIHZhciB0cmFjZSA9IF9yZWYzLnRyYWNlLFxuICAgICAgX3JlZjMkZGJvcHMgPSBfcmVmMy5kYm9wcyxcbiAgICAgIGRib3BzID0gX3JlZjMkZGJvcHMgPT09IHZvaWQgMCA/IFtdIDogX3JlZjMkZGJvcHMsXG4gICAgICBfcmVmMyRyYW1vcHMgPSBfcmVmMy5yYW1vcHMsXG4gICAgICByYW1vcHMgPSBfcmVmMyRyYW1vcHMgPT09IHZvaWQgMCA/IFtdIDogX3JlZjMkcmFtb3BzLFxuICAgICAgX3JlZjMkaW5kZXggPSBfcmVmMy5pbmRleCxcbiAgICAgIGluZGV4ID0gX3JlZjMkaW5kZXggPT09IHZvaWQgMCA/IDAgOiBfcmVmMyRpbmRleDtcbiAgdmFyIHRyYW5zZm9ybWVkID0ge1xuICAgIGFjdDogdHJhY2UuYWN0LFxuICAgIGFjY291bnRfcmFtX2RlbHRhczogdHJhY2UuYWNjb3VudF9yYW1fZGVsdGFzLFxuICAgIHJlY2VpdmVyczogW3RyYWNlLnJlY2VpcHQucmVjZWl2ZXJdLFxuICAgIGFjdF9kaWdlc3Q6IHRyYWNlLnJlY2VpcHQuYWN0X2RpZ2VzdCxcbiAgICBkYm9wczogKGRib3BzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7XG4gICAgICByZXR1cm4gb3AuYWN0aW9uX2lkeCA9PT0gaW5kZXg7XG4gICAgfSksXG4gICAgcmFtb3BzOiAocmFtb3BzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7XG4gICAgICByZXR1cm4gb3AuYWN0aW9uX2lkeCA9PT0gaW5kZXg7XG4gICAgfSksXG4gICAgdHJhY2VzOiBbXVxuICB9O1xuXG4gIGlmICh0cmFjZS5pbmxpbmVfdHJhY2VzICYmIHRyYWNlLmlubGluZV90cmFjZXMubGVuZ3RoKSB7XG4gICAgdHJhY2UuaW5saW5lX3RyYWNlcy5tYXAoZnVuY3Rpb24gKGl0cmFjZSkge1xuICAgICAgaW5kZXgrKzsgLy8gSWYgVFggZGF0YSBpcyBkaWZmZXJlbnRcblxuICAgICAgaWYgKGl0cmFjZS5hY3QuaGV4X2RhdGEgIT09IHRyYW5zZm9ybWVkLmFjdC5oZXhfZGF0YSB8fCBpdHJhY2UuYWN0Lm5hbWUgIT09IHRyYW5zZm9ybWVkLmFjdC5uYW1lIHx8IGl0cmFjZS5hY3QuYWNjb3VudCAhPT0gdHJhbnNmb3JtZWQuYWN0LmFjY291bnQpIHtcbiAgICAgICAgdHJhbnNmb3JtZWQudHJhY2VzLnB1c2goZGZ1c2VUcmFuc2Zvcm1UcmFjZSh7XG4gICAgICAgICAgdHJhY2U6IGl0cmFjZSxcbiAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgcmFtb3BzOiByYW1vcHMsXG4gICAgICAgICAgZGJvcHM6IGRib3BzXG4gICAgICAgIH0pKTsgLy8gSGV4IGRhdGEgaXMgc2FtZSwgYnV0IHN0aWxsIGFkZCBpbiBpbmxpbmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdHJhY2UuaW5saW5lX3RyYWNlcyAmJiBpdHJhY2UuaW5saW5lX3RyYWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoaXRyYWNlLmlubGluZV90cmFjZXMpLCBfc3RlcDEyOyAhKF9zdGVwMTIgPSBfaXRlcmF0b3IxMigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGlpdHJhY2UgPSBfc3RlcDEyLnZhbHVlO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLnRyYWNlcy5wdXNoKGRmdXNlVHJhbnNmb3JtVHJhY2Uoe1xuICAgICAgICAgICAgICB0cmFjZTogaWl0cmFjZSxcbiAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICByYW1vcHM6IHJhbW9wcyxcbiAgICAgICAgICAgICAgZGJvcHM6IGRib3BzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEFkZCBSZWNlaXZlcnMgZXZlbiBpZiBub3QgZGlmZmVyZW50XG5cblxuICAgICAgICBpZiAoIXRyYW5zZm9ybWVkLnJlY2VpdmVycy5pbmNsdWRlcyhpdHJhY2UucmVjZWlwdC5yZWNlaXZlcikpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZC5yZWNlaXZlcnMucHVzaChpdHJhY2UucmVjZWlwdC5yZWNlaXZlcik7XG4gICAgICAgIH0gLy8gQWRkIGRiIG9wcyBhbmQgcmFtIG9wcyBldmVuIGlmIG5vdCBkaWZmZXJlbnRcblxuXG4gICAgICAgIHRyYW5zZm9ybWVkLmRib3BzID0gdHJhbnNmb3JtZWQuZGJvcHMuY29uY2F0KChkYm9wcyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgIHJldHVybiBvcC5hY3Rpb25faWR4ID09PSBpbmRleDtcbiAgICAgICAgfSkpO1xuICAgICAgICB0cmFuc2Zvcm1lZC5yYW1vcHMgPSB0cmFuc2Zvcm1lZC5yYW1vcHMuY29uY2F0KChyYW1vcHMgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICByZXR1cm4gb3AuYWN0aW9uX2lkeCA9PT0gaW5kZXg7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2Zvcm1lZDtcbn1cbmZ1bmN0aW9uIGRmdXNlVHJhbnNmb3JtVHJhbnNhY3Rpb24ocmVzdWx0KSB7XG4gIHZhciBleGVjdXRpb25fdHJhY2UgPSByZXN1bHQuZXhlY3V0aW9uX3RyYWNlLFxuICAgICAgdHJhbnNhY3Rpb24gPSByZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICByYW1vcHMgPSByZXN1bHQucmFtb3BzLFxuICAgICAgZGJvcHMgPSByZXN1bHQuZGJvcHMsXG4gICAgICBjcmVhdGVkX2J5ID0gcmVzdWx0LmNyZWF0ZWRfYnk7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBhY3Rpb25zID0gKGV4ZWN1dGlvbl90cmFjZVsnYWN0aW9uX3RyYWNlcyddIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgdmFyIHRyYW5zZm9ybWVkVHJhY2UgPSBkZnVzZVRyYW5zZm9ybVRyYWNlKHtcbiAgICAgIHRyYWNlOiB0cmFjZSxcbiAgICAgIHJhbW9wczogcmFtb3BzLFxuICAgICAgZGJvcHM6IGRib3BzLFxuICAgICAgaW5kZXg6IGNvdW50XG4gICAgfSk7IC8vIEluY3JlbWVudCBjb3VudHNcblxuICAgIHZhciB0cmFjZUNvdW50ID0gaW5saW5lVHJhY2VDb3VudEhlbHBlcihbdHJhY2VdKTtcbiAgICBjb3VudCArPSB0cmFjZUNvdW50O1xuICAgIHJldHVybiB0cmFuc2Zvcm1lZFRyYWNlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IGV4ZWN1dGlvbl90cmFjZS5yZWNlaXB0LnN0YXR1cyxcbiAgICBjcHVfdXNhZ2U6IGV4ZWN1dGlvbl90cmFjZS5yZWNlaXB0LmNwdV91c2FnZV91cyxcbiAgICBuZXRfdXNhZ2U6IGV4ZWN1dGlvbl90cmFjZS5yZWNlaXB0Lm5ldF91c2FnZV93b3JkcyAqIDgsXG4gICAgaWQ6IGV4ZWN1dGlvbl90cmFjZS5pZCxcbiAgICBibG9ja190aW1lOiBleGVjdXRpb25fdHJhY2UuYmxvY2tfdGltZSxcbiAgICBibG9ja19udW06IGV4ZWN1dGlvbl90cmFjZS5ibG9ja19udW0sXG4gICAgZGVsYXlfc2VjOiB0cmFuc2FjdGlvbi5kZWxheV9zZWMsXG4gICAgZXhwaXJhdGlvbjogdHJhbnNhY3Rpb24uZXhwaXJhdGlvbixcbiAgICBjcmVhdGVkX2J5OiBjcmVhdGVkX2J5LFxuICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgdHJhY2VzOiBhY3Rpb25zXG4gIH07XG59XG5mdW5jdGlvbiBkZnVzZVRyYW5zZm9ybURlZmVycmVkQWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIGFjdDogX2V4dGVuZHMoe30sIGFjdGlvbiksXG4gICAgYWNjb3VudF9yYW1fZGVsdGFzOiBbXSxcbiAgICByZWNlaXZlcnM6IFtdLFxuICAgIGFjdF9kaWdlc3Q6ICcnLFxuICAgIHRyYWNlczogW11cbiAgfTtcbn1cbmZ1bmN0aW9uIGRmdXNlVHJhbnNmb3JtRGVmZXJyZWRUcmFuc2FjdGlvbihyZXN1bHQpIHtcbiAgdmFyIGFjdGlvbnMgPSByZXN1bHQudHJhbnNhY3Rpb24uYWN0aW9ucy5tYXAoZGZ1c2VUcmFuc2Zvcm1EZWZlcnJlZEFjdGlvbik7XG4gIHJldHVybiB7XG4gICAgaWQ6IHJlc3VsdC5pZCxcbiAgICBzdGF0dXM6ICdkZWZlcnJlZCcsXG4gICAgZGZ1c2Vfc3RhdHVzOiByZXN1bHQudHJhbnNhY3Rpb25fc3RhdHVzLFxuICAgIHNlbmRlcjogcmVzdWx0LmNyZWF0ZWRfYnkuc2VuZGVyLFxuICAgIHBheWVyOiByZXN1bHQuY3JlYXRlZF9ieS5wYXllcixcbiAgICBwdWJsaXNoZWQ6IHJlc3VsdC5jcmVhdGVkX2J5LnB1Ymxpc2hlZF9hdCxcbiAgICBkZWxheV91bnRpbDogcmVzdWx0LmNyZWF0ZWRfYnkuZGVsYXlfdW50aWwsXG4gICAgZXhwaXJhdGlvbjogcmVzdWx0LnRyYW5zYWN0aW9uLmV4cGlyYXRpb24sXG4gICAgZGVsYXlfc2VjOiByZXN1bHQudHJhbnNhY3Rpb24uZGVsYXlfc2VjLFxuICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgdHJhY2VzOiBhY3Rpb25zXG4gIH07XG59XG5mdW5jdGlvbiBkZnVzZVRyYW5zZm9ybVRyYW5zYWN0aW9uUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LmV4ZWN1dGlvbl90cmFjZSA/IGRmdXNlVHJhbnNmb3JtVHJhbnNhY3Rpb24ocmVzdWx0KSA6IGRmdXNlVHJhbnNmb3JtRGVmZXJyZWRUcmFuc2FjdGlvbihyZXN1bHQpO1xufVxuZnVuY3Rpb24gaGlzdG9yeVRyYW5zZm9ybURlZmVycmVkQWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGFjdGlvbiwge1xuICAgIGFjY291bnRfcmFtX2RlbHRhczogW10sXG4gICAgcmVjZWl2ZXI6ICcnLFxuICAgIGFjdF9kaWdlc3Q6ICcnLFxuICAgIHRyYWNlczogW11cbiAgfSk7XG59XG5mdW5jdGlvbiBoaXN0b3J5VHJhbnNmb3JtRGVmZXJyZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICByZXR1cm4ge1xuICAgIGlkOiB0cmFuc2FjdGlvbi50cnhfaWQsXG4gICAgc3RhdHVzOiAnZGVmZXJyZWQnLFxuICAgIHNlbmRlcjogdHJhbnNhY3Rpb24uc2VuZGVyLFxuICAgIHBheWVyOiB0cmFuc2FjdGlvbi5wYXllcixcbiAgICBwdWJsaXNoZWQ6IHRyYW5zYWN0aW9uLnB1Ymxpc2hlZCxcbiAgICBleHBpcmF0aW9uOiB0cmFuc2FjdGlvbi5leHBpcmF0aW9uLFxuICAgIGRlbGF5X3VudGlsOiB0cmFuc2FjdGlvbi5kZWxheV91bnRpbCxcbiAgICBkZWxheV9zZWM6IHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uLmRlbGF5X3NlYyxcbiAgICBhY3Rpb25zOiB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbi5hY3Rpb25zLFxuICAgIHRyYWNlczogdHJhbnNhY3Rpb24udHJhbnNhY3Rpb24uYWN0aW9ucy5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnlUcmFuc2Zvcm1EZWZlcnJlZEFjdGlvbihhY3Rpb24pO1xuICAgIH0pXG4gIH07XG59XG5mdW5jdGlvbiBoaXN0b3J5VHJhbnNmb3JtUmVjdXJzaXZlVHJhY2UoYWN0aW9uKSB7XG4gIHZhciB0cmFuc2Zvcm1lZCA9IHtcbiAgICBhY3Q6IGFjdGlvbi5hY3QsXG4gICAgYWNjb3VudF9yYW1fZGVsdGFzOiBhY3Rpb24uYWNjb3VudF9yYW1fZGVsdGFzIHx8IFtdLFxuICAgIHJlY2VpdmVyczogW2FjdGlvbi5yZWNlaXB0LnJlY2VpdmVyXSxcbiAgICBhY3RfZGlnZXN0OiBhY3Rpb24ucmVjZWlwdC5hY3RfZGlnZXN0LFxuICAgIHRyYWNlczogW11cbiAgfTtcblxuICBpZiAoYWN0aW9uLmlubGluZV90cmFjZXMgJiYgYWN0aW9uLmlubGluZV90cmFjZXMubGVuZ3RoKSB7XG4gICAgYWN0aW9uLmlubGluZV90cmFjZXMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2UpIHtcbiAgICAgIHZhciBzYW1lQXNQYXJlbnQgPSB0cmFjZS5yZWNlaXB0LmFjdF9kaWdlc3QgPT09IGFjdGlvbi5yZWNlaXB0LmFjdF9kaWdlc3Q7IC8vIEFjdGlvbnMgZG9uZSBpbiByZXNwb25zZSB0byBub3RpZmljYXRpb24gLT4gQWRkIGluIGlubGluZSB0cmFjZXNcblxuICAgICAgaWYgKHNhbWVBc1BhcmVudCAmJiB0cmFjZS5pbmxpbmVfdHJhY2VzICYmIHRyYWNlLmlubGluZV90cmFjZXMubGVuZ3RoKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkLnRyYWNlcyA9IHRyYW5zZm9ybWVkLnRyYWNlcy5jb25jYXQodHJhY2UuaW5saW5lX3RyYWNlcy5tYXAoaGlzdG9yeVRyYW5zZm9ybVJlY3Vyc2l2ZVRyYWNlKSk7XG5cbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1lZC5yZWNlaXZlcnMuaW5jbHVkZXModHJhY2UucmVjZWlwdC5yZWNlaXZlcikpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZC5yZWNlaXZlcnMucHVzaCh0cmFjZS5yZWNlaXB0LnJlY2VpdmVyKTtcbiAgICAgICAgfSAvLyBOb3JtYWwgYWN0aW9uXG5cbiAgICAgIH0gZWxzZSBpZiAoIXNhbWVBc1BhcmVudCkge1xuICAgICAgICB0cmFuc2Zvcm1lZC50cmFjZXMucHVzaChoaXN0b3J5VHJhbnNmb3JtUmVjdXJzaXZlVHJhY2UodHJhY2UpKTsgLy8gTm9ybWFsIG5vdGlmaWNhdGlvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1lZC5yZWNlaXZlcnMuaW5jbHVkZXModHJhY2UucmVjZWlwdC5yZWNlaXZlcikpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZC5yZWNlaXZlcnMucHVzaCh0cmFjZS5yZWNlaXB0LnJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zZm9ybWVkO1xufVxuZnVuY3Rpb24gaGlzdG9yeVRyYW5zZm9ybUZsYXRUcmFjZXModHJhY2VzKSB7XG4gIHZhciB0cmFjZXNCeU9yZGluYWwgPSB0cmFjZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHRyYWNlKSB7XG4gICAgYWNjW3RyYWNlLmFjdGlvbl9vcmRpbmFsXSA9IHRyYWNlO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IxMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodHJhY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hY3Rpb25fb3JkaW5hbCAtIGEuYWN0aW9uX29yZGluYWw7XG4gIH0pKSwgX3N0ZXAxMzsgIShfc3RlcDEzID0gX2l0ZXJhdG9yMTMoKSkuZG9uZTspIHtcbiAgICB2YXIgdHJhY2UgPSBfc3RlcDEzLnZhbHVlO1xuXG4gICAgLy8gU2tpcCB0b3AgbGV2ZWwgYWN0aW9uc1xuICAgIGlmICh0cmFjZS5jcmVhdG9yX2FjdGlvbl9vcmRpbmFsID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudElubGluZVRyYWNlcyA9IHRyYWNlc0J5T3JkaW5hbFt0cmFjZS5jcmVhdG9yX2FjdGlvbl9vcmRpbmFsXS5pbmxpbmVfdHJhY2VzIHx8IFtdO1xuICAgIHZhciBuZXdJbmxpbmVUcmFjZXMgPSBbdHJhY2VzQnlPcmRpbmFsW3RyYWNlLmFjdGlvbl9vcmRpbmFsXV07XG4gICAgdHJhY2VzQnlPcmRpbmFsW3RyYWNlLmNyZWF0b3JfYWN0aW9uX29yZGluYWxdLmlubGluZV90cmFjZXMgPSBuZXdJbmxpbmVUcmFjZXMuY29uY2F0KGN1cnJlbnRJbmxpbmVUcmFjZXMpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IE9iamVjdC52YWx1ZXModHJhY2VzQnlPcmRpbmFsKS5maWx0ZXIoZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgcmV0dXJuIHRyYWNlLmNyZWF0b3JfYWN0aW9uX29yZGluYWwgPT09IDA7XG4gIH0pLm1hcChmdW5jdGlvbiAodHJhY2UpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHRyYWNlLCB7XG4gICAgICByZWNlaXZlcnM6IFt0cmFjZS5yZWNlaXB0LnJlY2VpdmVyXSxcbiAgICAgIGFjdF9kaWdlc3Q6IHRyYWNlLnJlY2VpcHQuYWN0X2RpZ2VzdFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmluZElmU2FtZVR4KGlubGluZV90cmFjZXMsIGFjdCkge1xuICB2YXIgbWF0Y2ggPSBmYWxzZTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IxNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoaW5saW5lX3RyYWNlcyksIF9zdGVwMTQ7ICEoX3N0ZXAxNCA9IF9pdGVyYXRvcjE0KCkpLmRvbmU7KSB7XG4gICAgdmFyIHRyYWNlID0gX3N0ZXAxNC52YWx1ZTtcblxuICAgIGlmICh0cmFjZS5hY3QuaGV4X2RhdGEgPT09IGFjdC5oZXhfZGF0YSAmJiB0cmFjZS5hY3QubmFtZSA9PT0gYWN0Lm5hbWUgJiYgdHJhY2UuYWN0LmFjY291bnQgPT09IGFjdC5hY2NvdW50IHx8IGZpbmRJZlNhbWVUeCh0cmFjZS5pbmxpbmVfdHJhY2VzLCBhY3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbmZ1bmN0aW9uIGlubGluZVRyYWNlQ291bnRIZWxwZXIodHJhY2VzKSB7XG4gIHJldHVybiB0cmFjZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHRyYWNlKSB7XG4gICAgcmV0dXJuIGFjYyArIDEgKyBpbmxpbmVUcmFjZUNvdW50SGVscGVyKHRyYWNlLmlubGluZV90cmFjZXMgfHwgW10pO1xuICB9LCAwKTtcbn1cblxuZnVuY3Rpb24gaGlzdG9yeVRyYW5zZm9ybVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIGlmICh0cmFuc2FjdGlvbi50cngpIHtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIHZhciBkZWxheV9zZWM7XG4gICAgdmFyIGV4cGlyYXRpb247XG4gICAgdmFyIHRyYWNlczsgLy8gPj0gMS44IHRyYWNlc1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnRyYWNlcyAmJiB0cmFuc2FjdGlvbi50cmFjZXMubGVuZ3RoICYmICdjcmVhdG9yX2FjdGlvbl9vcmRpbmFsJyBpbiB0cmFuc2FjdGlvbi50cmFjZXNbMF0pIHtcbiAgICAgIHRyYWNlcyA9IGhpc3RvcnlUcmFuc2Zvcm1GbGF0VHJhY2VzKHRyYW5zYWN0aW9uLnRyYWNlcykubWFwKGhpc3RvcnlUcmFuc2Zvcm1SZWN1cnNpdmVUcmFjZSk7XG4gICAgICBhY3Rpb25zID0gdHJhbnNhY3Rpb24udHJhY2VzLmZpbHRlcihmdW5jdGlvbiAodHJhY2UpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlLmNyZWF0b3JfYWN0aW9uX29yZGluYWwgPT09IDA7XG4gICAgICB9KTsgLy8gMS43IGFuZCB1bmRlciBub2Rlb3NcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBfc3RlcDE1JHZhbHVlID0gX3N0ZXAxNS52YWx1ZSxcbiAgICAgICAgICAgIGkgPSBfc3RlcDE1JHZhbHVlWzBdLFxuICAgICAgICAgICAgYWN0aW9uID0gX3N0ZXAxNSR2YWx1ZVsxXTtcbiAgICAgICAgdmFyIHRlbXBUcmFjZXMgPSB0cmFuc2FjdGlvbi50cmFjZXMuc2xpY2UoKTtcbiAgICAgICAgdGVtcFRyYWNlcy5zcGxpY2UoaSwgaSArIDEpO1xuICAgICAgICB2YXIgZm91bmRTYW1lSGV4ID0gdGVtcFRyYWNlcy5maW5kKGZ1bmN0aW9uICh0cmFjZSkge1xuICAgICAgICAgIHJldHVybiBmaW5kSWZTYW1lVHgodHJhY2UuaW5saW5lX3RyYWNlcy5zbGljZSgpLCBhY3Rpb24uYWN0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFmb3VuZFNhbWVIZXgpIHtcbiAgICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRyYW5zYWN0aW9uLnRyYWNlcy5lbnRyaWVzKCkpLCBfc3RlcDE1OyAhKF9zdGVwMTUgPSBfaXRlcmF0b3IxNSgpKS5kb25lOykge1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuXG4gICAgICB0cmFjZXMgPSBhY3Rpb25zLm1hcChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBoaXN0b3J5VHJhbnNmb3JtUmVjdXJzaXZlVHJhY2UoYWN0aW9uKTtcbiAgICAgIH0pOyAvLyBOb3JtYWwgbm90IGRlZmVycmVkIFRYXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi50cngudHJ4KSB7XG4gICAgICAgIGRlbGF5X3NlYyA9IHRyYW5zYWN0aW9uLnRyeC50cnguZGVsYXlfc2VjO1xuICAgICAgICBleHBpcmF0aW9uID0gdHJhbnNhY3Rpb24udHJ4LnRyeC5leHBpcmF0aW9uOyAvLyBEZWZlcnJlZCBUWFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsYXlfc2VjID0gJ04vQSc7XG4gICAgICAgIGV4cGlyYXRpb24gPSAnTi9BJztcbiAgICAgIH0gLy8gRml4IGZvciBlbXB0eSBhcnJheSAoaGV4IGRhdGEgZnVja2VkIHVwKSBXVEY/XG5cblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnRyYWNlcy5sZW5ndGggPiAwICYmIGFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRyYW5zYWN0aW9uLnRyYWNlcyksIF9zdGVwMTY7ICEoX3N0ZXAxNiA9IF9pdGVyYXRvcjE2KCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF90eCA9IF9zdGVwMTYudmFsdWU7XG5cbiAgICAgICAgICBpZiAoaSA+PSBjb3VudGVyKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goX3R4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb3VudGVyICs9IGlubGluZVRyYWNlQ291bnRIZWxwZXIoX3R4LmlubGluZV90cmFjZXMpO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNlcyA9IGFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gaGlzdG9yeVRyYW5zZm9ybVJlY3Vyc2l2ZVRyYWNlKGFjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBGaXggZm9yIGVtcHR5IHRyYWNlIChibG9jayBoaW50IHVzZWQ/KVxuXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi50cmFjZXMubGVuZ3RoID09PSAwICYmIGFjdGlvbnMubGVuZ3RoID09PSAwICYmIHRyYW5zYWN0aW9uLnRyeC50cnggJiYgdHJhbnNhY3Rpb24udHJ4LnRyeC5hY3Rpb25zICYmIHRyYW5zYWN0aW9uLnRyeC50cnguYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgdHJhY2VzID0gdHJhbnNhY3Rpb24udHJ4LnRyeC5hY3Rpb25zLm1hcChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdDogYWN0aW9uLFxuICAgICAgICAgICAgYWNjb3VudF9yYW1fZGVsdGFzOiBbXSxcbiAgICAgICAgICAgIHJlY2VpdmVyczogYWN0aW9uLmF1dGhvcml6YXRpb24ubWFwKGZ1bmN0aW9uIChhdXRoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhdXRoLmFjdG9yO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhY3RfZGlnZXN0OiAnJyxcbiAgICAgICAgICAgIHRyYWNlczogW11cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aW9ucyA9IHRyYWNlcztcbiAgICAgIH1cbiAgICB9IC8vIEZvciBkaXNwbGF5XG5cblxuICAgIHZhciBleHRyYUZpZWxkcyA9IF9leHRlbmRzKHt9LCB0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24udHJ4LnJlY2VpcHQsIHRyYW5zYWN0aW9uLnRyeC50cnggfHwge30pO1xuXG4gICAgdmFyIHR4ID0gX2V4dGVuZHMoe30sIGV4dHJhRmllbGRzLCB7XG4gICAgICBzdGF0dXM6IHRyYW5zYWN0aW9uLnRyeC5yZWNlaXB0LnN0YXR1cyxcbiAgICAgIGNwdV91c2FnZTogdHJhbnNhY3Rpb24udHJ4LnJlY2VpcHQuY3B1X3VzYWdlX3VzLFxuICAgICAgbmV0X3VzYWdlOiB0cmFuc2FjdGlvbi50cngucmVjZWlwdC5uZXRfdXNhZ2Vfd29yZHMgKiA4LFxuICAgICAgaWQ6IHRyYW5zYWN0aW9uLmlkLFxuICAgICAgYmxvY2tfdGltZTogdHJhbnNhY3Rpb24uYmxvY2tfdGltZSxcbiAgICAgIGJsb2NrX251bTogdHJhbnNhY3Rpb24uYmxvY2tfbnVtLFxuICAgICAgZGVsYXlfc2VjOiBkZWxheV9zZWMsXG4gICAgICBleHBpcmF0aW9uOiBleHBpcmF0aW9uLFxuICAgICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICAgIHRyYWNlczogdHJhY2VzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHg7IC8vIE1FRVRPTkUgaGlzdG9yeVxuICB9IGVsc2UgaWYgKHRyYW5zYWN0aW9uLmFjdGlvbl90cmFjZXMpIHtcbiAgICByZXR1cm4gZGZ1c2VUcmFuc2Zvcm1UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7IC8vIE9uIGJsb2NrXG4gIH0gZWxzZSB7XG4gICAgdmFyIF90cmFjZXMgPSB0cmFuc2FjdGlvbi50cmFjZXMubWFwKGZ1bmN0aW9uICh0cmFjZSkge1xuICAgICAgcmV0dXJuIGhpc3RvcnlUcmFuc2Zvcm1SZWN1cnNpdmVUcmFjZSh0cmFjZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAnZXhlY3V0ZWQnLFxuICAgICAgY3B1X3VzYWdlOiAwLFxuICAgICAgbmV0X3VzYWdlOiAwLFxuICAgICAgaWQ6IHRyYW5zYWN0aW9uLmlkLFxuICAgICAgYmxvY2tfdGltZTogdHJhbnNhY3Rpb24uYmxvY2tfdGltZSxcbiAgICAgIGJsb2NrX251bTogdHJhbnNhY3Rpb24uYmxvY2tfbnVtLFxuICAgICAgZGVsYXlfc2VjOiAwLFxuICAgICAgZXhwaXJhdGlvbjogMCxcbiAgICAgIGFjdGlvbnM6IF90cmFjZXMsXG4gICAgICB0cmFjZXM6IF90cmFjZXNcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhleFRvVWludDhBcnJheShoZXgpIHtcbiAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdHJpbmcgY29udGFpbmluZyBoZXggZGlnaXRzJyk7XG4gIH1cblxuICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09kZCBudW1iZXIgb2YgaGV4IGRpZ2l0cycpO1xuICB9XG5cbiAgdmFyIGwgPSBoZXgubGVuZ3RoIC8gMjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGwpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgdmFyIHggPSBwYXJzZUludChoZXguc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuXG4gICAgaWYgKE51bWJlci5pc05hTih4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBoZXggc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgcmVzdWx0W2ldID0geDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHVybEJ1aWxkZXIodXJsLCBpZCwgcGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGlkICE9PSAndW5kZWZpbmVkJyAmJiBpZCAhPT0gbnVsbCkge1xuICAgIHVybCArPSBcIi9cIiArIGVuY29kZVVSSUNvbXBvbmVudChpZCk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggIT09IDApIHtcbiAgICB2YXIgcXVlcnlTdHJpbmcgPSBxdWVyeS5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICB1cmwgKz0gXCI/XCIgKyBxdWVyeVN0cmluZztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGNvcHkodGV4dCkge1xuICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgZWwudmFsdWUgPSB0ZXh0O1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5JywgJycpO1xuICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICBzZWxlY3RlZCA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICB9XG5cbiAgZWwuc2VsZWN0KCk7XG4gIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXG4gIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0ZWQpIHtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKHNlbGVjdGVkKTtcbiAgfVxufVxuXG52YXIgTmZ0ID0gZnVuY3Rpb24gTmZ0KF9yZWYpIHtcbiAgdmFyIGlkYXRhID0gX3JlZi5pZGF0YSxcbiAgICAgIG1kYXRhID0gX3JlZi5tZGF0YSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBpbWFnZSA9IF9yZWYuaW1hZ2UsXG4gICAgICB2aWRlbyA9IF9yZWYudmlkZW8sXG4gICAgICBtb2RlbCA9IF9yZWYubW9kZWwsXG4gICAgICBhdWRpbyA9IF9yZWYuYXVkaW8sXG4gICAgICBzdGFnZSA9IF9yZWYuc3RhZ2UsXG4gICAgICBza3lib3ggPSBfcmVmLnNreWJveCxcbiAgICAgIHBkZiA9IF9yZWYucGRmLFxuICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgY29udHJhY3QgPSBfcmVmLmNvbnRyYWN0LFxuICAgICAgbGluayA9IF9yZWYubGluayxcbiAgICAgIG93bmVyID0gX3JlZi5vd25lcixcbiAgICAgIGF1dGhvciA9IF9yZWYuYXV0aG9yLFxuICAgICAgY29sbGVjdGlvbiA9IF9yZWYuY29sbGVjdGlvbixcbiAgICAgIG1pbnQgPSBfcmVmLm1pbnQsXG4gICAgICBlZGl0aW9uX3NpemUgPSBfcmVmLmVkaXRpb25fc2l6ZTtcbiAgdGhpcy5pZGF0YSA9IGlkYXRhO1xuICB0aGlzLm1kYXRhID0gbWRhdGE7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgdGhpcy52aWRlbyA9IHZpZGVvO1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuYXVkaW8gPSBhdWRpbztcbiAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICB0aGlzLnNreWJveCA9IHNreWJveDtcbiAgdGhpcy5wZGYgPSBwZGY7XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5jb250cmFjdCA9IGNvbnRyYWN0O1xuICB0aGlzLmxpbmsgPSBsaW5rO1xuICB0aGlzLm93bmVyID0gb3duZXI7XG4gIHRoaXMuYXV0aG9yID0gYXV0aG9yO1xuICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICB0aGlzLm1pbnQgPSBtaW50O1xuICB0aGlzLmVkaXRpb25fc2l6ZSA9IGVkaXRpb25fc2l6ZTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlSXBmcyhpbWFnZVVybCkge1xuICBpZiAoIWltYWdlVXJsKSB7XG4gICAgcmV0dXJuIGltYWdlVXJsO1xuICB9XG5cbiAgaWYgKGltYWdlVXJsLnN1YnN0cmluZygwLCAyKSA9PT0gJ1FtJykge1xuICAgIGltYWdlVXJsID0gXCJodHRwczovL2Nsb3VkZmxhcmUtaXBmcy5jb20vaXBmcy9cIiArIGltYWdlVXJsO1xuICB9XG5cbiAgcmV0dXJuIGltYWdlVXJsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNhTmZ0KG5mdCkge1xuICB2YXIgbmFtZSA9IG5mdC5pZGF0YSAmJiBuZnQuaWRhdGEubmFtZSB8fCBuZnQubWRhdGEgJiYgbmZ0Lm1kYXRhLm5hbWU7XG4gIHZhciBpbWFnZVVybCA9IHBhcnNlSXBmcyhuZnQuaWRhdGEgJiYgKG5mdC5pZGF0YS5pbWcgfHwgbmZ0LmlkYXRhLmltYWdlKSB8fCBuZnQubWRhdGEgJiYgKG5mdC5tZGF0YS5pbWcgfHwgbmZ0Lm1kYXRhLmltZykpO1xuICB2YXIgdmlkZW9VcmwgPSBwYXJzZUlwZnMobmZ0LmlkYXRhICYmIG5mdC5pZGF0YS52aWRlbyB8fCBuZnQubWRhdGEgJiYgbmZ0Lm1kYXRhLnZpZGVvKTtcbiAgdmFyIGF1ZGlvVXJsID0gcGFyc2VJcGZzKG5mdC5pZGF0YSAmJiBuZnQuaWRhdGEuYXVkaW8gfHwgbmZ0Lm1kYXRhICYmIG5mdC5tZGF0YS5hdWRpbyk7XG4gIHZhciBtb2RlbFVybCA9IHBhcnNlSXBmcyhuZnQuaWRhdGEgJiYgbmZ0LmlkYXRhLm1vZGVsIHx8IG5mdC5tZGF0YSAmJiBuZnQubWRhdGEubW9kZWwpO1xuICB2YXIgc3RhZ2VVcmwgPSBwYXJzZUlwZnMobmZ0LmlkYXRhICYmIG5mdC5pZGF0YS5zdGFnZSB8fCBuZnQubWRhdGEgJiYgbmZ0Lm1kYXRhLnN0YWdlKTtcbiAgdmFyIHBkZlVybCA9IHBhcnNlSXBmcyhuZnQuaWRhdGEgJiYgbmZ0LmlkYXRhLnBkZiB8fCBuZnQubWRhdGEgJiYgbmZ0Lm1kYXRhLnBkZik7XG4gIHZhciBza3lib3hVcmwgPSBwYXJzZUlwZnMobmZ0LmlkYXRhICYmIG5mdC5pZGF0YS5za3lib3ggfHwgbmZ0Lm1kYXRhICYmIG5mdC5tZGF0YS5za3lib3gpO1xuICB2YXIgbmZ0T2JqID0gbmV3IE5mdCh7XG4gICAgaWRhdGE6IG5mdC5pZGF0YSxcbiAgICBtZGF0YTogbmZ0Lm1kYXRhLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgaW1hZ2U6IGltYWdlVXJsLFxuICAgIHZpZGVvOiB2aWRlb1VybCxcbiAgICBtb2RlbDogbW9kZWxVcmwsXG4gICAgYXVkaW86IGF1ZGlvVXJsLFxuICAgIHN0YWdlOiBzdGFnZVVybCxcbiAgICBza3lib3g6IHNreWJveFVybCxcbiAgICBwZGY6IHBkZlVybCxcbiAgICBpZDogbmZ0LmFzc2V0SWQsXG4gICAgY29udHJhY3Q6ICdzaW1wbGVhc3NldHMnLFxuICAgIGxpbms6IFwiL25mdC9cIiArIG5mdC5hc3NldElkLFxuICAgIG93bmVyOiBuZnQub3duZXIsXG4gICAgYXV0aG9yOiBuZnQuYXV0aG9yLFxuICAgIG1pbnQ6IG5mdC5leHRyYSAmJiBuZnQuZXh0cmEubWludE51bWJlcixcbiAgICBjb2xsZWN0aW9uOiBuZnQuY2F0ZWdvcnksXG4gICAgZWRpdGlvbl9zaXplOiBuZnQuZXh0cmEgJiYgbmZ0LmV4dHJhLnRvdGFsTWludGVkXG4gIH0pO1xuICByZXR1cm4gbmZ0T2JqO1xufVxuZnVuY3Rpb24gcGFyc2VBYU5mdChuZnQpIHtcbiAgdmFyIGltYWdlVXJsID0gcGFyc2VJcGZzKG5mdC5kYXRhLmltZyB8fCBuZnQuZGF0YS5pbWFnZSk7XG4gIHZhciB2aWRlb1VybCA9IHBhcnNlSXBmcyhuZnQuZGF0YS52aWRlbyk7XG4gIHZhciBhdWRpb1VybCA9IHBhcnNlSXBmcyhuZnQuZGF0YS5hdWRpbyk7XG4gIHZhciBtb2RlbFVybCA9IHBhcnNlSXBmcyhuZnQuZGF0YS5tb2RlbCk7XG4gIHZhciBzdGFnZVVybCA9IHBhcnNlSXBmcyhuZnQuZGF0YS5zdGFnZSk7XG4gIHZhciBza3lib3hVcmwgPSBwYXJzZUlwZnMobmZ0LmRhdGEuc2t5Ym94KTtcbiAgdmFyIHBkZlVybCA9IHBhcnNlSXBmcyhuZnQuZGF0YS5wZGYpO1xuICB2YXIgaWRhdGEgPSBuZnQuaW1tdXRhYmxlX2RhdGE7XG5cbiAgaWYgKG5mdC50ZW1wbGF0ZSAmJiBuZnQudGVtcGxhdGUuaW1tdXRhYmxlX2RhdGEpIHtcbiAgICBpZGF0YSA9IF9leHRlbmRzKHt9LCBpZGF0YSwgbmZ0LnRlbXBsYXRlLmltbXV0YWJsZV9kYXRhKTtcbiAgfVxuXG4gIHZhciBuZnRPYmogPSBuZXcgTmZ0KHtcbiAgICBpZGF0YTogaWRhdGEsXG4gICAgbWRhdGE6IG5mdC5tdXRhYmxlX2RhdGEsXG4gICAgbmFtZTogbmZ0Lm5hbWUgfHwgbmZ0LmRhdGEubmFtZSB8fCBuZnQuYXNzZXRfaWQsXG4gICAgaW1hZ2U6IGltYWdlVXJsLFxuICAgIHZpZGVvOiB2aWRlb1VybCxcbiAgICBtb2RlbDogbW9kZWxVcmwsXG4gICAgYXVkaW86IGF1ZGlvVXJsLFxuICAgIHN0YWdlOiBzdGFnZVVybCxcbiAgICBza3lib3g6IHNreWJveFVybCxcbiAgICBwZGY6IHBkZlVybCxcbiAgICBpZDogbmZ0LmFzc2V0X2lkLFxuICAgIGNvbnRyYWN0OiAnYXRvbWljYXNzZXRzJyxcbiAgICBsaW5rOiBcIi9uZnQvXCIgKyBuZnQuYXNzZXRfaWQsXG4gICAgb3duZXI6IG5mdC5vd25lcixcbiAgICBhdXRob3I6IG5mdC5jb2xsZWN0aW9uLmF1dGhvcixcbiAgICBjb2xsZWN0aW9uOiBuZnQuY29sbGVjdGlvbi5jb2xsZWN0aW9uX25hbWUsXG4gICAgbWludDogbmZ0LnRlbXBsYXRlX21pbnQgPyArbmZ0LnRlbXBsYXRlX21pbnQgOiB1bmRlZmluZWQsXG4gICAgZWRpdGlvbl9zaXplOiBuZnQudGVtcGxhdGUgPyArbmZ0LnRlbXBsYXRlLm1heF9zdXBwbHkgfHwgK25mdC50ZW1wbGF0ZS5pc3N1ZWRfc3VwcGx5IDogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4gbmZ0T2JqO1xufVxuXG5mdW5jdGlvbiB3YWl0KF94KSB7XG4gIHJldHVybiBfd2FpdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfd2FpdCgpIHtcbiAgX3dhaXQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobXMpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3dhaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyoqXHJcbiAqIE5hdGl2ZVxyXG4gKi9cbnZhciBEYm9wT3A7XG5cbihmdW5jdGlvbiAoRGJvcE9wKSB7XG4gIERib3BPcFtcIkluc1wiXSA9IFwiSU5TXCI7XG4gIERib3BPcFtcIlJlbVwiXSA9IFwiUkVNXCI7XG4gIERib3BPcFtcIlVwZFwiXSA9IFwiVVBEXCI7XG59KShEYm9wT3AgfHwgKERib3BPcCA9IHt9KSk7XG5cbmV4cG9ydCB7IERib3BPcCwgTmZ0LCBieXRlc1RvU3RyaW5nLCBjaGFyaWR4LCBjbG9uZURlZXBBcnJheU9mT2JqLCBjb3B5LCBkZWNvZGVOYW1lLCBkZnVzZURlcHRoRmlyc3RFeHRyYWN0LCBkZnVzZVRyYW5zZm9ybURlZmVycmVkQWN0aW9uLCBkZnVzZVRyYW5zZm9ybURlZmVycmVkVHJhbnNhY3Rpb24sIGRmdXNlVHJhbnNmb3JtR2V0QWN0aW9ucywgZGZ1c2VUcmFuc2Zvcm1UcmFjZSwgZGZ1c2VUcmFuc2Zvcm1UcmFuc2FjdGlvbiwgZGZ1c2VUcmFuc2Zvcm1UcmFuc2FjdGlvblJlc3VsdCwgZW5jb2RlTmFtZSwgZmlvS2V5VG9BY3RvciwgaGV4VG9VaW50OEFycmF5LCBoaXN0b3J5VHJhbnNmb3JtRGVmZXJyZWRBY3Rpb24sIGhpc3RvcnlUcmFuc2Zvcm1EZWZlcnJlZFRyYW5zYWN0aW9uLCBoaXN0b3J5VHJhbnNmb3JtRmxhdFRyYWNlcywgaGlzdG9yeVRyYW5zZm9ybVJlY3Vyc2l2ZVRyYWNlLCBoaXN0b3J5VHJhbnNmb3JtVHJhbnNhY3Rpb24sIGh5cGVyaW9uVHJhbnNmb3JtRmxhdFRyYWNlcywgaHlwZXJpb25UcmFuc2Zvcm1HZXRBY3Rpb25zLCBoeXBlcmlvblRyYW5zZm9ybVRyYW5zYWN0aW9uLCBpc1N0cmluZywgbmF0aXZlVHJhbnNmb3JtR2V0QWN0aW9ucywgcGFyc2VBYU5mdCwgcGFyc2VTYU5mdCwgc2hhLCBzdHJpbmdfdG9fdWludDEyOF9oYXNoLCB1cmxCdWlsZGVyLCB3YWl0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5lc20uanMubWFwXG4iLCIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNleyhcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMpLm51bWJybz1lKCl9fShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiBhKG8sdSxjKXtmdW5jdGlvbiBzKHQsZSl7aWYoIXVbdF0pe2lmKCFvW3RdKXt2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFlJiZyKXJldHVybiByKHQsITApO2lmKGwpcmV0dXJuIGwodCwhMCk7dmFyIG49bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIit0K1wiJ1wiKTt0aHJvdyBuLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsbn12YXIgaT11W3RdPXtleHBvcnRzOnt9fTtvW3RdWzBdLmNhbGwoaS5leHBvcnRzLGZ1bmN0aW9uKGUpe3JldHVybiBzKG9bdF1bMV1bZV18fGUpfSxpLGkuZXhwb3J0cyxhLG8sdSxjKX1yZXR1cm4gdVt0XS5leHBvcnRzfWZvcih2YXIgbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGU9MDtlPGMubGVuZ3RoO2UrKylzKGNbZV0pO3JldHVybiBzfSh7MTpbZnVuY3Rpb24oZSxyLHQpeyFmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjt2YXIgdCxDPS9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFQ9TWF0aC5jZWlsLFU9TWF0aC5mbG9vcixSPVwiW0JpZ051bWJlciBFcnJvcl0gXCIsST1SK1wiTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogXCIsJD0xZTE0LEc9MTQsVj05MDA3MTk5MjU0NzQwOTkxLHE9WzEsMTAsMTAwLDFlMywxZTQsMWU1LDFlNiwxZTcsMWU4LDFlOSwxZTEwLDFlMTEsMWUxMiwxZTEzXSxaPTFlNyx6PTFlOTtmdW5jdGlvbiBXKGUpe3ZhciB0PTB8ZTtyZXR1cm4gMDxlfHxlPT09dD90OnQtMX1mdW5jdGlvbiBIKGUpe2Zvcih2YXIgdCxyLG49MSxpPWUubGVuZ3RoLGE9ZVswXStcIlwiO248aTspe2Zvcih0PWVbbisrXStcIlwiLHI9Ry10Lmxlbmd0aDtyLS07dD1cIjBcIit0KTthKz10fWZvcihpPWEubGVuZ3RoOzQ4PT09YS5jaGFyQ29kZUF0KC0taSk7KTtyZXR1cm4gYS5zbGljZSgwLGkrMXx8MSl9ZnVuY3Rpb24gWShlLHQpe3ZhciByLG4saT1lLmMsYT10LmMsbz1lLnMsdT10LnMsYz1lLmUscz10LmU7aWYoIW98fCF1KXJldHVybiBudWxsO2lmKHI9aSYmIWlbMF0sbj1hJiYhYVswXSxyfHxuKXJldHVybiByP24/MDotdTpvO2lmKG8hPXUpcmV0dXJuIG87aWYocj1vPDAsbj1jPT1zLCFpfHwhYSlyZXR1cm4gbj8wOiFpXnI/MTotMTtpZighbilyZXR1cm4gczxjXnI/MTotMTtmb3IodT0oYz1pLmxlbmd0aCk8KHM9YS5sZW5ndGgpP2M6cyxvPTA7bzx1O28rKylpZihpW29dIT1hW29dKXJldHVybiBpW29dPmFbb11ecj8xOi0xO3JldHVybiBjPT1zPzA6czxjXnI/MTotMX1mdW5jdGlvbiBLKGUsdCxyLG4pe2lmKGU8dHx8cjxlfHxlIT09VShlKSl0aHJvdyBFcnJvcihSKyhufHxcIkFyZ3VtZW50XCIpKyhcIm51bWJlclwiPT10eXBlb2YgZT9lPHR8fHI8ZT9cIiBvdXQgb2YgcmFuZ2U6IFwiOlwiIG5vdCBhbiBpbnRlZ2VyOiBcIjpcIiBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiBcIikrU3RyaW5nKGUpKX1mdW5jdGlvbiBKKGUpe3ZhciB0PWUuYy5sZW5ndGgtMTtyZXR1cm4gVyhlLmUvRyk9PXQmJmUuY1t0XSUyIT0wfWZ1bmN0aW9uIFgoZSx0KXtyZXR1cm4oMTxlLmxlbmd0aD9lLmNoYXJBdCgwKStcIi5cIitlLnNsaWNlKDEpOmUpKyh0PDA/XCJlXCI6XCJlK1wiKSt0fWZ1bmN0aW9uIFEoZSx0LHIpe3ZhciBuLGk7aWYodDwwKXtmb3IoaT1yK1wiLlwiOysrdDtpKz1yKTtlPWkrZX1lbHNlIGlmKCsrdD4obj1lLmxlbmd0aCkpe2ZvcihpPXIsdC09bjstLXQ7aSs9cik7ZSs9aX1lbHNlIHQ8biYmKGU9ZS5zbGljZSgwLHQpK1wiLlwiK2Uuc2xpY2UodCkpO3JldHVybiBlfSh0PWZ1bmN0aW9uIGUodCl7dmFyIHYsZixwLHIscyxtLG8sdSxjLGwsZyxuPUEucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpBLHRvU3RyaW5nOm51bGwsdmFsdWVPZjpudWxsfSxoPW5ldyBBKDEpLHk9MjAsYj00LGQ9LTcsdz0yMSxTPS0xZTcseD0xZTcsTz0hMSxhPTEsTj0wLEI9e3ByZWZpeDpcIlwiLGdyb3VwU2l6ZTozLHNlY29uZGFyeUdyb3VwU2l6ZTowLGdyb3VwU2VwYXJhdG9yOlwiLFwiLGRlY2ltYWxTZXBhcmF0b3I6XCIuXCIsZnJhY3Rpb25Hcm91cFNpemU6MCxmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOlwiwqBcIixzdWZmaXg6XCJcIn0sTT1cIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO2Z1bmN0aW9uIEEoZSx0KXt2YXIgcixuLGksYSxvLHUsYyxzLGw9dGhpcztpZighKGwgaW5zdGFuY2VvZiBBKSlyZXR1cm4gbmV3IEEoZSx0KTtpZihudWxsPT10KXtpZihlJiYhMD09PWUuX2lzQmlnTnVtYmVyKXJldHVybiBsLnM9ZS5zLHZvaWQoIWUuY3x8ZS5lPng/bC5jPWwuZT1udWxsOmUuZTxTP2wuYz1bbC5lPTBdOihsLmU9ZS5lLGwuYz1lLmMuc2xpY2UoKSkpO2lmKCh1PVwibnVtYmVyXCI9PXR5cGVvZiBlKSYmMCplPT0wKXtpZihsLnM9MS9lPDA/KGU9LWUsLTEpOjEsZT09PX5+ZSl7Zm9yKGE9MCxvPWU7MTA8PW87by89MTAsYSsrKTtyZXR1cm4gdm9pZCh4PGE/bC5jPWwuZT1udWxsOihsLmU9YSxsLmM9W2VdKSl9cz1TdHJpbmcoZSl9ZWxzZXtpZighQy50ZXN0KHM9U3RyaW5nKGUpKSlyZXR1cm4gcChsLHMsdSk7bC5zPTQ1PT1zLmNoYXJDb2RlQXQoMCk/KHM9cy5zbGljZSgxKSwtMSk6MX0tMTwoYT1zLmluZGV4T2YoXCIuXCIpKSYmKHM9cy5yZXBsYWNlKFwiLlwiLFwiXCIpKSwwPChvPXMuc2VhcmNoKC9lL2kpKT8oYTwwJiYoYT1vKSxhKz0rcy5zbGljZShvKzEpLHM9cy5zdWJzdHJpbmcoMCxvKSk6YTwwJiYoYT1zLmxlbmd0aCl9ZWxzZXtpZihLKHQsMixNLmxlbmd0aCxcIkJhc2VcIiksMTA9PXQpcmV0dXJuIFAobD1uZXcgQShlKSx5K2wuZSsxLGIpO2lmKHM9U3RyaW5nKGUpLHU9XCJudW1iZXJcIj09dHlwZW9mIGUpe2lmKDAqZSE9MClyZXR1cm4gcChsLHMsdSx0KTtpZihsLnM9MS9lPDA/KHM9cy5zbGljZSgxKSwtMSk6MSxBLkRFQlVHJiYxNTxzLnJlcGxhY2UoL14wXFwuMCp8XFwuLyxcIlwiKS5sZW5ndGgpdGhyb3cgRXJyb3IoSStlKX1lbHNlIGwucz00NT09PXMuY2hhckNvZGVBdCgwKT8ocz1zLnNsaWNlKDEpLC0xKToxO2ZvcihyPU0uc2xpY2UoMCx0KSxhPW89MCxjPXMubGVuZ3RoO288YztvKyspaWYoci5pbmRleE9mKG49cy5jaGFyQXQobykpPDApe2lmKFwiLlwiPT1uKXtpZihhPG8pe2E9Yztjb250aW51ZX19ZWxzZSBpZighaSYmKHM9PXMudG9VcHBlckNhc2UoKSYmKHM9cy50b0xvd2VyQ2FzZSgpKXx8cz09cy50b0xvd2VyQ2FzZSgpJiYocz1zLnRvVXBwZXJDYXNlKCkpKSl7aT0hMCxvPS0xLGE9MDtjb250aW51ZX1yZXR1cm4gcChsLFN0cmluZyhlKSx1LHQpfXU9ITEsLTE8KGE9KHM9ZihzLHQsMTAsbC5zKSkuaW5kZXhPZihcIi5cIikpP3M9cy5yZXBsYWNlKFwiLlwiLFwiXCIpOmE9cy5sZW5ndGh9Zm9yKG89MDs0OD09PXMuY2hhckNvZGVBdChvKTtvKyspO2ZvcihjPXMubGVuZ3RoOzQ4PT09cy5jaGFyQ29kZUF0KC0tYyk7KTtpZihzPXMuc2xpY2UobywrK2MpKXtpZihjLT1vLHUmJkEuREVCVUcmJjE1PGMmJihWPGV8fGUhPT1VKGUpKSl0aHJvdyBFcnJvcihJK2wucyplKTtpZigoYT1hLW8tMSk+eClsLmM9bC5lPW51bGw7ZWxzZSBpZihhPFMpbC5jPVtsLmU9MF07ZWxzZXtpZihsLmU9YSxsLmM9W10sbz0oYSsxKSVHLGE8MCYmKG8rPUcpLG88Yyl7Zm9yKG8mJmwuYy5wdXNoKCtzLnNsaWNlKDAsbykpLGMtPUc7bzxjOylsLmMucHVzaCgrcy5zbGljZShvLG8rPUcpKTtvPUctKHM9cy5zbGljZShvKSkubGVuZ3RofWVsc2Ugby09Yztmb3IoO28tLTtzKz1cIjBcIik7bC5jLnB1c2goK3MpfX1lbHNlIGwuYz1bbC5lPTBdfWZ1bmN0aW9uIEQoZSx0LHIsbil7Zm9yKHZhciBpLGEsbz1bMF0sdT0wLGM9ZS5sZW5ndGg7dTxjOyl7Zm9yKGE9by5sZW5ndGg7YS0tO29bYV0qPXQpO2ZvcihvWzBdKz1uLmluZGV4T2YoZS5jaGFyQXQodSsrKSksaT0wO2k8by5sZW5ndGg7aSsrKW9baV0+ci0xJiYobnVsbD09b1tpKzFdJiYob1tpKzFdPTApLG9baSsxXSs9b1tpXS9yfDAsb1tpXSU9cil9cmV0dXJuIG8ucmV2ZXJzZSgpfWZ1bmN0aW9uIEUoZSx0LHIpe3ZhciBuLGksYSxvLHU9MCxjPWUubGVuZ3RoLHM9dCVaLGw9dC9afDA7Zm9yKGU9ZS5zbGljZSgpO2MtLTspdT0oKGk9cyooYT1lW2NdJVopKyhuPWwqYSsobz1lW2NdL1p8MCkqcyklWipaK3UpL3J8MCkrKG4vWnwwKStsKm8sZVtjXT1pJXI7cmV0dXJuIHUmJihlPVt1XS5jb25jYXQoZSkpLGV9ZnVuY3Rpb24gRihlLHQscixuKXt2YXIgaSxhO2lmKHIhPW4pYT1uPHI/MTotMTtlbHNlIGZvcihpPWE9MDtpPHI7aSsrKWlmKGVbaV0hPXRbaV0pe2E9ZVtpXT50W2ldPzE6LTE7YnJlYWt9cmV0dXJuIGF9ZnVuY3Rpb24gayhlLHQscixuKXtmb3IodmFyIGk9MDtyLS07KWVbcl0tPWksaT1lW3JdPHRbcl0/MTowLGVbcl09aSpuK2Vbcl0tdFtyXTtmb3IoOyFlWzBdJiYxPGUubGVuZ3RoO2Uuc3BsaWNlKDAsMSkpO31mdW5jdGlvbiBpKGUsdCxyLG4pe3ZhciBpLGEsbyx1LGM7aWYobnVsbD09cj9yPWI6SyhyLDAsOCksIWUuYylyZXR1cm4gZS50b1N0cmluZygpO2lmKGk9ZS5jWzBdLG89ZS5lLG51bGw9PXQpYz1IKGUuYyksYz0xPT1ufHwyPT1uJiYobzw9ZHx8dzw9byk/WChjLG8pOlEoYyxvLFwiMFwiKTtlbHNlIGlmKGE9KGU9UChuZXcgQShlKSx0LHIpKS5lLHU9KGM9SChlLmMpKS5sZW5ndGgsMT09bnx8Mj09biYmKHQ8PWF8fGE8PWQpKXtmb3IoO3U8dDtjKz1cIjBcIix1KyspO2M9WChjLGEpfWVsc2UgaWYodC09byxjPVEoYyxhLFwiMFwiKSx1PGErMSl7aWYoMDwtLXQpZm9yKGMrPVwiLlwiO3QtLTtjKz1cIjBcIik7fWVsc2UgaWYoMDwodCs9YS11KSlmb3IoYSsxPT11JiYoYys9XCIuXCIpO3QtLTtjKz1cIjBcIik7cmV0dXJuIGUuczwwJiZpP1wiLVwiK2M6Y31mdW5jdGlvbiBfKGUsdCl7Zm9yKHZhciByLG49MSxpPW5ldyBBKGVbMF0pO248ZS5sZW5ndGg7bisrKXtpZighKHI9bmV3IEEoZVtuXSkpLnMpe2k9cjticmVha310LmNhbGwoaSxyKSYmKGk9cil9cmV0dXJuIGl9ZnVuY3Rpb24gTChlLHQscil7Zm9yKHZhciBuPTEsaT10Lmxlbmd0aDshdFstLWldO3QucG9wKCkpO2ZvcihpPXRbMF07MTA8PWk7aS89MTAsbisrKTtyZXR1cm4ocj1uK3IqRy0xKT54P2UuYz1lLmU9bnVsbDpyPFM/ZS5jPVtlLmU9MF06KGUuZT1yLGUuYz10KSxlfWZ1bmN0aW9uIFAoZSx0LHIsbil7dmFyIGksYSxvLHUsYyxzLGwsZj1lLmMscD1xO2lmKGYpe2U6e2ZvcihpPTEsdT1mWzBdOzEwPD11O3UvPTEwLGkrKyk7aWYoKGE9dC1pKTwwKWErPUcsbz10LGw9KGM9ZltzPTBdKS9wW2ktby0xXSUxMHwwO2Vsc2UgaWYoKHM9VCgoYSsxKS9HKSk+PWYubGVuZ3RoKXtpZighbilicmVhayBlO2Zvcig7Zi5sZW5ndGg8PXM7Zi5wdXNoKDApKTtjPWw9MCxvPShhJT1HKS1HKyhpPTEpfWVsc2V7Zm9yKGM9dT1mW3NdLGk9MTsxMDw9dTt1Lz0xMCxpKyspO2w9KG89KGElPUcpLUcraSk8MD8wOmMvcFtpLW8tMV0lMTB8MH1pZihuPW58fHQ8MHx8bnVsbCE9ZltzKzFdfHwobzwwP2M6YyVwW2ktby0xXSksbj1yPDQ/KGx8fG4pJiYoMD09cnx8cj09KGUuczwwPzM6MikpOjU8bHx8NT09bCYmKDQ9PXJ8fG58fDY9PXImJigwPGE/MDxvP2MvcFtpLW9dOjA6ZltzLTFdKSUxMCYxfHxyPT0oZS5zPDA/ODo3KSksdDwxfHwhZlswXSlyZXR1cm4gZi5sZW5ndGg9MCxuPyh0LT1lLmUrMSxmWzBdPXBbKEctdCVHKSVHXSxlLmU9LXR8fDApOmZbMF09ZS5lPTAsZTtpZigwPT1hPyhmLmxlbmd0aD1zLHU9MSxzLS0pOihmLmxlbmd0aD1zKzEsdT1wW0ctYV0sZltzXT0wPG8/VShjL3BbaS1vXSVwW29dKSp1OjApLG4pZm9yKDs7KXtpZigwPT1zKXtmb3IoYT0xLG89ZlswXTsxMDw9bztvLz0xMCxhKyspO2ZvcihvPWZbMF0rPXUsdT0xOzEwPD1vO28vPTEwLHUrKyk7YSE9dSYmKGUuZSsrLGZbMF09PSQmJihmWzBdPTEpKTticmVha31pZihmW3NdKz11LGZbc10hPSQpYnJlYWs7ZltzLS1dPTAsdT0xfWZvcihhPWYubGVuZ3RoOzA9PT1mWy0tYV07Zi5wb3AoKSk7fWUuZT54P2UuYz1lLmU9bnVsbDplLmU8UyYmKGUuYz1bZS5lPTBdKX1yZXR1cm4gZX1mdW5jdGlvbiBqKGUpe3ZhciB0LHI9ZS5lO3JldHVybiBudWxsPT09cj9lLnRvU3RyaW5nKCk6KHQ9SChlLmMpLHQ9cjw9ZHx8dzw9cj9YKHQscik6USh0LHIsXCIwXCIpLGUuczwwP1wiLVwiK3Q6dCl9cmV0dXJuIEEuY2xvbmU9ZSxBLlJPVU5EX1VQPTAsQS5ST1VORF9ET1dOPTEsQS5ST1VORF9DRUlMPTIsQS5ST1VORF9GTE9PUj0zLEEuUk9VTkRfSEFMRl9VUD00LEEuUk9VTkRfSEFMRl9ET1dOPTUsQS5ST1VORF9IQUxGX0VWRU49NixBLlJPVU5EX0hBTEZfQ0VJTD03LEEuUk9VTkRfSEFMRl9GTE9PUj04LEEuRVVDTElEPTksQS5jb25maWc9QS5zZXQ9ZnVuY3Rpb24oZSl7dmFyIHQscjtpZihudWxsIT1lKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBFcnJvcihSK1wiT2JqZWN0IGV4cGVjdGVkOiBcIitlKTtpZihlLmhhc093blByb3BlcnR5KHQ9XCJERUNJTUFMX1BMQUNFU1wiKSYmKEsocj1lW3RdLDAseix0KSx5PXIpLGUuaGFzT3duUHJvcGVydHkodD1cIlJPVU5ESU5HX01PREVcIikmJihLKHI9ZVt0XSwwLDgsdCksYj1yKSxlLmhhc093blByb3BlcnR5KHQ9XCJFWFBPTkVOVElBTF9BVFwiKSYmKChyPWVbdF0pJiZyLnBvcD8oSyhyWzBdLC16LDAsdCksSyhyWzFdLDAseix0KSxkPXJbMF0sdz1yWzFdKTooSyhyLC16LHosdCksZD0tKHc9cjwwPy1yOnIpKSksZS5oYXNPd25Qcm9wZXJ0eSh0PVwiUkFOR0VcIikpaWYoKHI9ZVt0XSkmJnIucG9wKUsoclswXSwteiwtMSx0KSxLKHJbMV0sMSx6LHQpLFM9clswXSx4PXJbMV07ZWxzZXtpZihLKHIsLXoseix0KSwhcil0aHJvdyBFcnJvcihSK3QrXCIgY2Fubm90IGJlIHplcm86IFwiK3IpO1M9LSh4PXI8MD8tcjpyKX1pZihlLmhhc093blByb3BlcnR5KHQ9XCJDUllQVE9cIikpe2lmKChyPWVbdF0pIT09ISFyKXRocm93IEVycm9yKFIrdCtcIiBub3QgdHJ1ZSBvciBmYWxzZTogXCIrcik7aWYocil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGNyeXB0b3x8IWNyeXB0b3x8IWNyeXB0by5nZXRSYW5kb21WYWx1ZXMmJiFjcnlwdG8ucmFuZG9tQnl0ZXMpdGhyb3cgTz0hcixFcnJvcihSK1wiY3J5cHRvIHVuYXZhaWxhYmxlXCIpO089cn1lbHNlIE89cn1pZihlLmhhc093blByb3BlcnR5KHQ9XCJNT0RVTE9fTU9ERVwiKSYmKEsocj1lW3RdLDAsOSx0KSxhPXIpLGUuaGFzT3duUHJvcGVydHkodD1cIlBPV19QUkVDSVNJT05cIikmJihLKHI9ZVt0XSwwLHosdCksTj1yKSxlLmhhc093blByb3BlcnR5KHQ9XCJGT1JNQVRcIikpe2lmKFwib2JqZWN0XCIhPXR5cGVvZihyPWVbdF0pKXRocm93IEVycm9yKFIrdCtcIiBub3QgYW4gb2JqZWN0OiBcIityKTtCPXJ9aWYoZS5oYXNPd25Qcm9wZXJ0eSh0PVwiQUxQSEFCRVRcIikpe2lmKFwic3RyaW5nXCIhPXR5cGVvZihyPWVbdF0pfHwvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHIpKXRocm93IEVycm9yKFIrdCtcIiBpbnZhbGlkOiBcIityKTtNPXJ9fXJldHVybntERUNJTUFMX1BMQUNFUzp5LFJPVU5ESU5HX01PREU6YixFWFBPTkVOVElBTF9BVDpbZCx3XSxSQU5HRTpbUyx4XSxDUllQVE86TyxNT0RVTE9fTU9ERTphLFBPV19QUkVDSVNJT046TixGT1JNQVQ6QixBTFBIQUJFVDpNfX0sQS5pc0JpZ051bWJlcj1mdW5jdGlvbihlKXtpZighZXx8ITAhPT1lLl9pc0JpZ051bWJlcilyZXR1cm4hMTtpZighQS5ERUJVRylyZXR1cm4hMDt2YXIgdCxyLG49ZS5jLGk9ZS5lLGE9ZS5zO2U6aWYoXCJbb2JqZWN0IEFycmF5XVwiPT17fS50b1N0cmluZy5jYWxsKG4pKXtpZigoMT09PWF8fC0xPT09YSkmJi16PD1pJiZpPD16JiZpPT09VShpKSl7aWYoMD09PW5bMF0pe2lmKDA9PT1pJiYxPT09bi5sZW5ndGgpcmV0dXJuITA7YnJlYWsgZX1pZigodD0oaSsxKSVHKTwxJiYodCs9RyksU3RyaW5nKG5bMF0pLmxlbmd0aD09dCl7Zm9yKHQ9MDt0PG4ubGVuZ3RoO3QrKylpZigocj1uW3RdKTwwfHwkPD1yfHxyIT09VShyKSlicmVhayBlO2lmKDAhPT1yKXJldHVybiEwfX19ZWxzZSBpZihudWxsPT09biYmbnVsbD09PWkmJihudWxsPT09YXx8MT09PWF8fC0xPT09YSkpcmV0dXJuITA7dGhyb3cgRXJyb3IoUitcIkludmFsaWQgQmlnTnVtYmVyOiBcIitlKX0sQS5tYXhpbXVtPUEubWF4PWZ1bmN0aW9uKCl7cmV0dXJuIF8oYXJndW1lbnRzLG4ubHQpfSxBLm1pbmltdW09QS5taW49ZnVuY3Rpb24oKXtyZXR1cm4gXyhhcmd1bWVudHMsbi5ndCl9LEEucmFuZG9tPShyPTkwMDcxOTkyNTQ3NDA5OTIscz1NYXRoLnJhbmRvbSgpKnImMjA5NzE1MT9mdW5jdGlvbigpe3JldHVybiBVKE1hdGgucmFuZG9tKCkqcil9OmZ1bmN0aW9uKCl7cmV0dXJuIDgzODg2MDgqKDEwNzM3NDE4MjQqTWF0aC5yYW5kb20oKXwwKSsoODM4ODYwOCpNYXRoLnJhbmRvbSgpfDApfSxmdW5jdGlvbihlKXt2YXIgdCxyLG4saSxhLG89MCx1PVtdLGM9bmV3IEEoaCk7aWYobnVsbD09ZT9lPXk6SyhlLDAseiksaT1UKGUvRyksTylpZihjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXtmb3IodD1jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShpKj0yKSk7bzxpOyk5ZTE1PD0oYT0xMzEwNzIqdFtvXSsodFtvKzFdPj4+MTEpKT8ocj1jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSksdFtvXT1yWzBdLHRbbysxXT1yWzFdKToodS5wdXNoKGElMWUxNCksbys9Mik7bz1pLzJ9ZWxzZXtpZighY3J5cHRvLnJhbmRvbUJ5dGVzKXRocm93IE89ITEsRXJyb3IoUitcImNyeXB0byB1bmF2YWlsYWJsZVwiKTtmb3IodD1jcnlwdG8ucmFuZG9tQnl0ZXMoaSo9Nyk7bzxpOyk5ZTE1PD0oYT0yODE0NzQ5NzY3MTA2NTYqKDMxJnRbb10pKzEwOTk1MTE2Mjc3NzYqdFtvKzFdKzQyOTQ5NjcyOTYqdFtvKzJdKzE2Nzc3MjE2KnRbbyszXSsodFtvKzRdPDwxNikrKHRbbys1XTw8OCkrdFtvKzZdKT9jcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weSh0LG8pOih1LnB1c2goYSUxZTE0KSxvKz03KTtvPWkvN31pZighTylmb3IoO288aTspKGE9cygpKTw5ZTE1JiYodVtvKytdPWElMWUxNCk7Zm9yKGk9dVstLW9dLGUlPUcsaSYmZSYmKGE9cVtHLWVdLHVbb109VShpL2EpKmEpOzA9PT11W29dO3UucG9wKCksby0tKTtpZihvPDApdT1bbj0wXTtlbHNle2ZvcihuPS0xOzA9PT11WzBdO3Uuc3BsaWNlKDAsMSksbi09Ryk7Zm9yKG89MSxhPXVbMF07MTA8PWE7YS89MTAsbysrKTtvPEcmJihuLT1HLW8pfXJldHVybiBjLmU9bixjLmM9dSxjfSksQS5zdW09ZnVuY3Rpb24oKXtmb3IodmFyIGU9MSx0PWFyZ3VtZW50cyxyPW5ldyBBKHRbMF0pO2U8dC5sZW5ndGg7KXI9ci5wbHVzKHRbZSsrXSk7cmV0dXJuIHJ9LG09XCIwMTIzNDU2Nzg5XCIsZj1mdW5jdGlvbihlLHQscixuLGkpe3ZhciBhLG8sdSxjLHMsbCxmLHAsZz1lLmluZGV4T2YoXCIuXCIpLGQ9eSxoPWI7Zm9yKDA8PWcmJihjPU4sTj0wLGU9ZS5yZXBsYWNlKFwiLlwiLFwiXCIpLGw9KHA9bmV3IEEodCkpLnBvdyhlLmxlbmd0aC1nKSxOPWMscC5jPUQoUShIKGwuYyksbC5lLFwiMFwiKSwxMCxyLG0pLHAuZT1wLmMubGVuZ3RoKSx1PWM9KGY9RChlLHQscixpPyhhPU0sbSk6KGE9bSxNKSkpLmxlbmd0aDswPT1mWy0tY107Zi5wb3AoKSk7aWYoIWZbMF0pcmV0dXJuIGEuY2hhckF0KDApO2lmKGc8MD8tLXU6KGwuYz1mLGwuZT11LGwucz1uLGY9KGw9dihsLHAsZCxoLHIpKS5jLHM9bC5yLHU9bC5lKSxnPWZbbz11K2QrMV0sYz1yLzIscz1zfHxvPDB8fG51bGwhPWZbbysxXSxzPWg8ND8obnVsbCE9Z3x8cykmJigwPT1ofHxoPT0obC5zPDA/MzoyKSk6YzxnfHxnPT1jJiYoND09aHx8c3x8Nj09aCYmMSZmW28tMV18fGg9PShsLnM8MD84OjcpKSxvPDF8fCFmWzBdKWU9cz9RKGEuY2hhckF0KDEpLC1kLGEuY2hhckF0KDApKTphLmNoYXJBdCgwKTtlbHNle2lmKGYubGVuZ3RoPW8scylmb3IoLS1yOysrZlstLW9dPnI7KWZbb109MCxvfHwoKyt1LGY9WzFdLmNvbmNhdChmKSk7Zm9yKGM9Zi5sZW5ndGg7IWZbLS1jXTspO2ZvcihnPTAsZT1cIlwiO2c8PWM7ZSs9YS5jaGFyQXQoZltnKytdKSk7ZT1RKGUsdSxhLmNoYXJBdCgwKSl9cmV0dXJuIGV9LHY9ZnVuY3Rpb24oZSx0LHIsbixpKXt2YXIgYSxvLHUsYyxzLGwsZixwLGcsZCxoLHYsbSx5LGIsdyxTLHg9ZS5zPT10LnM/MTotMSxPPWUuYyxOPXQuYztpZighKE8mJk9bMF0mJk4mJk5bMF0pKXJldHVybiBuZXcgQShlLnMmJnQucyYmKE8/IU58fE9bMF0hPU5bMF06Tik/TyYmMD09T1swXXx8IU4/MCp4OngvMDpOYU4pO2ZvcihnPShwPW5ldyBBKHgpKS5jPVtdLHg9cisobz1lLmUtdC5lKSsxLGl8fChpPSQsbz1XKGUuZS9HKS1XKHQuZS9HKSx4PXgvR3wwKSx1PTA7Tlt1XT09KE9bdV18fDApO3UrKyk7aWYoTlt1XT4oT1t1XXx8MCkmJm8tLSx4PDApZy5wdXNoKDEpLGM9ITA7ZWxzZXtmb3IoeT1PLmxlbmd0aCx3PU4ubGVuZ3RoLHgrPTIsMTwocz1VKGkvKE5bdT0wXSsxKSkpJiYoTj1FKE4scyxpKSxPPUUoTyxzLGkpLHc9Ti5sZW5ndGgseT1PLmxlbmd0aCksbT13LGg9KGQ9Ty5zbGljZSgwLHcpKS5sZW5ndGg7aDx3O2RbaCsrXT0wKTtTPU4uc2xpY2UoKSxTPVswXS5jb25jYXQoUyksYj1OWzBdLE5bMV0+PWkvMiYmYisrO2Rve2lmKHM9MCwoYT1GKE4sZCx3LGgpKTwwKXtpZih2PWRbMF0sdyE9aCYmKHY9dippKyhkWzFdfHwwKSksMTwocz1VKHYvYikpKWZvcihpPD1zJiYocz1pLTEpLGY9KGw9RShOLHMsaSkpLmxlbmd0aCxoPWQubGVuZ3RoOzE9PUYobCxkLGYsaCk7KXMtLSxrKGwsdzxmP1M6TixmLGkpLGY9bC5sZW5ndGgsYT0xO2Vsc2UgMD09cyYmKGE9cz0xKSxmPShsPU4uc2xpY2UoKSkubGVuZ3RoO2lmKGY8aCYmKGw9WzBdLmNvbmNhdChsKSksayhkLGwsaCxpKSxoPWQubGVuZ3RoLC0xPT1hKWZvcig7RihOLGQsdyxoKTwxOylzKyssayhkLHc8aD9TOk4saCxpKSxoPWQubGVuZ3RofWVsc2UgMD09PWEmJihzKyssZD1bMF0pO2dbdSsrXT1zLGRbMF0/ZFtoKytdPU9bbV18fDA6KGQ9W09bbV1dLGg9MSl9d2hpbGUoKG0rKzx5fHxudWxsIT1kWzBdKSYmeC0tKTtjPW51bGwhPWRbMF0sZ1swXXx8Zy5zcGxpY2UoMCwxKX1pZihpPT0kKXtmb3IodT0xLHg9Z1swXTsxMDw9eDt4Lz0xMCx1KyspO1AocCxyKyhwLmU9dStvKkctMSkrMSxuLGMpfWVsc2UgcC5lPW8scC5yPStjO3JldHVybiBwfSxvPS9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksdT0vXihbXi5dKylcXC4kLyxjPS9eXFwuKFteLl0rKSQvLGw9L14tPyhJbmZpbml0eXxOYU4pJC8sZz0vXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2cscD1mdW5jdGlvbihlLHQscixuKXt2YXIgaSxhPXI/dDp0LnJlcGxhY2UoZyxcIlwiKTtpZihsLnRlc3QoYSkpZS5zPWlzTmFOKGEpP251bGw6YTwwPy0xOjE7ZWxzZXtpZighciYmKGE9YS5yZXBsYWNlKG8sZnVuY3Rpb24oZSx0LHIpe3JldHVybiBpPVwieFwiPT0ocj1yLnRvTG93ZXJDYXNlKCkpPzE2OlwiYlwiPT1yPzI6OCxuJiZuIT1pP2U6dH0pLG4mJihpPW4sYT1hLnJlcGxhY2UodSxcIiQxXCIpLnJlcGxhY2UoYyxcIjAuJDFcIikpLHQhPWEpKXJldHVybiBuZXcgQShhLGkpO2lmKEEuREVCVUcpdGhyb3cgRXJyb3IoUitcIk5vdCBhXCIrKG4/XCIgYmFzZSBcIituOlwiXCIpK1wiIG51bWJlcjogXCIrdCk7ZS5zPW51bGx9ZS5jPWUuZT1udWxsfSxuLmFic29sdXRlVmFsdWU9bi5hYnM9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgQSh0aGlzKTtyZXR1cm4gZS5zPDAmJihlLnM9MSksZX0sbi5jb21wYXJlZFRvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIFkodGhpcyxuZXcgQShlLHQpKX0sbi5kZWNpbWFsUGxhY2VzPW4uZHA9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGk7aWYobnVsbCE9ZSlyZXR1cm4gSyhlLDAseiksbnVsbD09dD90PWI6Syh0LDAsOCksUChuZXcgQSh0aGlzKSxlK3RoaXMuZSsxLHQpO2lmKCEocj10aGlzLmMpKXJldHVybiBudWxsO2lmKG49KChpPXIubGVuZ3RoLTEpLVcodGhpcy5lL0cpKSpHLGk9cltpXSlmb3IoO2klMTA9PTA7aS89MTAsbi0tKTtyZXR1cm4gbjwwJiYobj0wKSxufSxuLmRpdmlkZWRCeT1uLmRpdj1mdW5jdGlvbihlLHQpe3JldHVybiB2KHRoaXMsbmV3IEEoZSx0KSx5LGIpfSxuLmRpdmlkZWRUb0ludGVnZXJCeT1uLmlkaXY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdih0aGlzLG5ldyBBKGUsdCksMCwxKX0sbi5leHBvbmVudGlhdGVkQnk9bi5wb3c9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksYSxvLHUsYyxzLGw9dGhpcztpZigoZT1uZXcgQShlKSkuYyYmIWUuaXNJbnRlZ2VyKCkpdGhyb3cgRXJyb3IoUitcIkV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiBcIitqKGUpKTtpZihudWxsIT10JiYodD1uZXcgQSh0KSksbz0xNDxlLmUsIWwuY3x8IWwuY1swXXx8MT09bC5jWzBdJiYhbC5lJiYxPT1sLmMubGVuZ3RofHwhZS5jfHwhZS5jWzBdKXJldHVybiBzPW5ldyBBKE1hdGgucG93KCtqKGwpLG8/Mi1KKGUpOitqKGUpKSksdD9zLm1vZCh0KTpzO2lmKHU9ZS5zPDAsdCl7aWYodC5jPyF0LmNbMF06IXQucylyZXR1cm4gbmV3IEEoTmFOKTsobj0hdSYmbC5pc0ludGVnZXIoKSYmdC5pc0ludGVnZXIoKSkmJihsPWwubW9kKHQpKX1lbHNle2lmKDk8ZS5lJiYoMDxsLmV8fGwuZTwtMXx8KDA9PWwuZT8xPGwuY1swXXx8byYmMjRlNzw9bC5jWzFdOmwuY1swXTw4ZTEzfHxvJiZsLmNbMF08PTk5OTk5NzVlNykpKXJldHVybiBhPWwuczwwJiZKKGUpPy0wOjAsLTE8bC5lJiYoYT0xL2EpLG5ldyBBKHU/MS9hOmEpO04mJihhPVQoTi9HKzIpKX1mb3IoYz1vPyhyPW5ldyBBKC41KSx1JiYoZS5zPTEpLEooZSkpOihpPU1hdGguYWJzKCtqKGUpKSklMixzPW5ldyBBKGgpOzspe2lmKGMpe2lmKCEocz1zLnRpbWVzKGwpKS5jKWJyZWFrO2E/cy5jLmxlbmd0aD5hJiYocy5jLmxlbmd0aD1hKTpuJiYocz1zLm1vZCh0KSl9aWYoaSl7aWYoMD09PShpPVUoaS8yKSkpYnJlYWs7Yz1pJTJ9ZWxzZSBpZihQKGU9ZS50aW1lcyhyKSxlLmUrMSwxKSwxNDxlLmUpYz1KKGUpO2Vsc2V7aWYoMD09KGk9K2ooZSkpKWJyZWFrO2M9aSUyfWw9bC50aW1lcyhsKSxhP2wuYyYmbC5jLmxlbmd0aD5hJiYobC5jLmxlbmd0aD1hKTpuJiYobD1sLm1vZCh0KSl9cmV0dXJuIG4/czoodSYmKHM9aC5kaXYocykpLHQ/cy5tb2QodCk6YT9QKHMsTixiLHZvaWQgMCk6cyl9LG4uaW50ZWdlclZhbHVlPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBKHRoaXMpO3JldHVybiBudWxsPT1lP2U9YjpLKGUsMCw4KSxQKHQsdC5lKzEsZSl9LG4uaXNFcXVhbFRvPW4uZXE9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PVkodGhpcyxuZXcgQShlLHQpKX0sbi5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jfSxuLmlzR3JlYXRlclRoYW49bi5ndD1mdW5jdGlvbihlLHQpe3JldHVybiAwPFkodGhpcyxuZXcgQShlLHQpKX0sbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvPW4uZ3RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDE9PT0odD1ZKHRoaXMsbmV3IEEoZSx0KSkpfHwwPT09dH0sbi5pc0ludGVnZXI9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuYyYmVyh0aGlzLmUvRyk+dGhpcy5jLmxlbmd0aC0yfSxuLmlzTGVzc1RoYW49bi5sdD1mdW5jdGlvbihlLHQpe3JldHVybiBZKHRoaXMsbmV3IEEoZSx0KSk8MH0sbi5pc0xlc3NUaGFuT3JFcXVhbFRvPW4ubHRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuLTE9PT0odD1ZKHRoaXMsbmV3IEEoZSx0KSkpfHwwPT09dH0sbi5pc05hTj1mdW5jdGlvbigpe3JldHVybiF0aGlzLnN9LG4uaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnM8MH0sbi5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIDA8dGhpcy5zfSxuLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jJiYwPT10aGlzLmNbMF19LG4ubWludXM9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksYSxvPXRoaXMsdT1vLnM7aWYodD0oZT1uZXcgQShlLHQpKS5zLCF1fHwhdClyZXR1cm4gbmV3IEEoTmFOKTtpZih1IT10KXJldHVybiBlLnM9LXQsby5wbHVzKGUpO3ZhciBjPW8uZS9HLHM9ZS5lL0csbD1vLmMsZj1lLmM7aWYoIWN8fCFzKXtpZighbHx8IWYpcmV0dXJuIGw/KGUucz0tdCxlKTpuZXcgQShmP286TmFOKTtpZighbFswXXx8IWZbMF0pcmV0dXJuIGZbMF0/KGUucz0tdCxlKTpuZXcgQShsWzBdP286Mz09Yj8tMDowKX1pZihjPVcoYykscz1XKHMpLGw9bC5zbGljZSgpLHU9Yy1zKXtmb3IoKGk9KGE9dTwwKT8odT0tdSxsKToocz1jLGYpKS5yZXZlcnNlKCksdD11O3QtLTtpLnB1c2goMCkpO2kucmV2ZXJzZSgpfWVsc2UgZm9yKG49KGE9KHU9bC5sZW5ndGgpPCh0PWYubGVuZ3RoKSk/dTp0LHU9dD0wO3Q8bjt0KyspaWYobFt0XSE9Zlt0XSl7YT1sW3RdPGZbdF07YnJlYWt9aWYoYSYmKGk9bCxsPWYsZj1pLGUucz0tZS5zKSwwPCh0PShuPWYubGVuZ3RoKS0ocj1sLmxlbmd0aCkpKWZvcig7dC0tO2xbcisrXT0wKTtmb3IodD0kLTE7dTxuOyl7aWYobFstLW5dPGZbbl0pe2ZvcihyPW47ciYmIWxbLS1yXTtsW3JdPXQpOy0tbFtyXSxsW25dKz0kfWxbbl0tPWZbbl19Zm9yKDswPT1sWzBdO2wuc3BsaWNlKDAsMSksLS1zKTtyZXR1cm4gbFswXT9MKGUsbCxzKTooZS5zPTM9PWI/LTE6MSxlLmM9W2UuZT0wXSxlKX0sbi5tb2R1bG89bi5tb2Q9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGk9dGhpcztyZXR1cm4gZT1uZXcgQShlLHQpLCFpLmN8fCFlLnN8fGUuYyYmIWUuY1swXT9uZXcgQShOYU4pOiFlLmN8fGkuYyYmIWkuY1swXT9uZXcgQShpKTooOT09YT8obj1lLnMsZS5zPTEscj12KGksZSwwLDMpLGUucz1uLHIucyo9bik6cj12KGksZSwwLGEpLChlPWkubWludXMoci50aW1lcyhlKSkpLmNbMF18fDEhPWF8fChlLnM9aS5zKSxlKX0sbi5tdWx0aXBsaWVkQnk9bi50aW1lcz1mdW5jdGlvbihlLHQpe3ZhciByLG4saSxhLG8sdSxjLHMsbCxmLHAsZyxkLGgsdixtPXRoaXMseT1tLmMsYj0oZT1uZXcgQShlLHQpKS5jO2lmKCEoeSYmYiYmeVswXSYmYlswXSkpcmV0dXJuIW0uc3x8IWUuc3x8eSYmIXlbMF0mJiFifHxiJiYhYlswXSYmIXk/ZS5jPWUuZT1lLnM9bnVsbDooZS5zKj1tLnMseSYmYj8oZS5jPVswXSxlLmU9MCk6ZS5jPWUuZT1udWxsKSxlO2ZvcihuPVcobS5lL0cpK1coZS5lL0cpLGUucyo9bS5zLChjPXkubGVuZ3RoKTwoZj1iLmxlbmd0aCkmJihkPXkseT1iLGI9ZCxpPWMsYz1mLGY9aSksaT1jK2YsZD1bXTtpLS07ZC5wdXNoKDApKTtmb3IoaD0kLHY9WixpPWY7MDw9LS1pOyl7Zm9yKHI9MCxwPWJbaV0ldixnPWJbaV0vdnwwLGE9aSsobz1jKTtpPGE7KXI9KChzPXAqKHM9eVstLW9dJXYpKyh1PWcqcysobD15W29dL3Z8MCkqcCkldip2K2RbYV0rcikvaHwwKSsodS92fDApK2cqbCxkW2EtLV09cyVoO2RbYV09cn1yZXR1cm4gcj8rK246ZC5zcGxpY2UoMCwxKSxMKGUsZCxuKX0sbi5uZWdhdGVkPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IEEodGhpcyk7cmV0dXJuIGUucz0tZS5zfHxudWxsLGV9LG4ucGx1cz1mdW5jdGlvbihlLHQpe3ZhciByLG49dGhpcyxpPW4ucztpZih0PShlPW5ldyBBKGUsdCkpLnMsIWl8fCF0KXJldHVybiBuZXcgQShOYU4pO2lmKGkhPXQpcmV0dXJuIGUucz0tdCxuLm1pbnVzKGUpO3ZhciBhPW4uZS9HLG89ZS5lL0csdT1uLmMsYz1lLmM7aWYoIWF8fCFvKXtpZighdXx8IWMpcmV0dXJuIG5ldyBBKGkvMCk7aWYoIXVbMF18fCFjWzBdKXJldHVybiBjWzBdP2U6bmV3IEEodVswXT9uOjAqaSl9aWYoYT1XKGEpLG89VyhvKSx1PXUuc2xpY2UoKSxpPWEtbyl7Zm9yKChyPTA8aT8obz1hLGMpOihpPS1pLHUpKS5yZXZlcnNlKCk7aS0tO3IucHVzaCgwKSk7ci5yZXZlcnNlKCl9Zm9yKChpPXUubGVuZ3RoKS0odD1jLmxlbmd0aCk8MCYmKHI9YyxjPXUsdT1yLHQ9aSksaT0wO3Q7KWk9KHVbLS10XT11W3RdK2NbdF0raSkvJHwwLHVbdF09JD09PXVbdF0/MDp1W3RdJSQ7cmV0dXJuIGkmJih1PVtpXS5jb25jYXQodSksKytvKSxMKGUsdSxvKX0sbi5wcmVjaXNpb249bi5zZD1mdW5jdGlvbihlLHQpe3ZhciByLG4saTtpZihudWxsIT1lJiZlIT09ISFlKXJldHVybiBLKGUsMSx6KSxudWxsPT10P3Q9YjpLKHQsMCw4KSxQKG5ldyBBKHRoaXMpLGUsdCk7aWYoIShyPXRoaXMuYykpcmV0dXJuIG51bGw7aWYobj0oaT1yLmxlbmd0aC0xKSpHKzEsaT1yW2ldKXtmb3IoO2klMTA9PTA7aS89MTAsbi0tKTtmb3IoaT1yWzBdOzEwPD1pO2kvPTEwLG4rKyk7fXJldHVybiBlJiZ0aGlzLmUrMT5uJiYobj10aGlzLmUrMSksbn0sbi5zaGlmdGVkQnk9ZnVuY3Rpb24oZSl7cmV0dXJuIEsoZSwtVixWKSx0aGlzLnRpbWVzKFwiMWVcIitlKX0sbi5zcXVhcmVSb290PW4uc3FydD1mdW5jdGlvbigpe3ZhciBlLHQscixuLGksYT10aGlzLG89YS5jLHU9YS5zLGM9YS5lLHM9eSs0LGw9bmV3IEEoXCIwLjVcIik7aWYoMSE9PXV8fCFvfHwhb1swXSlyZXR1cm4gbmV3IEEoIXV8fHU8MCYmKCFvfHxvWzBdKT9OYU46bz9hOjEvMCk7aWYoKHI9MD09KHU9TWF0aC5zcXJ0KCtqKGEpKSl8fHU9PTEvMD8oKCh0PUgobykpLmxlbmd0aCtjKSUyPT0wJiYodCs9XCIwXCIpLHU9TWF0aC5zcXJ0KCt0KSxjPVcoKGMrMSkvMiktKGM8MHx8YyUyKSxuZXcgQSh0PXU9PTEvMD9cIjVlXCIrYzoodD11LnRvRXhwb25lbnRpYWwoKSkuc2xpY2UoMCx0LmluZGV4T2YoXCJlXCIpKzEpK2MpKTpuZXcgQSh1K1wiXCIpKS5jWzBdKWZvcigodT0oYz1yLmUpK3MpPDMmJih1PTApOzspaWYoaT1yLHI9bC50aW1lcyhpLnBsdXModihhLGkscywxKSkpLEgoaS5jKS5zbGljZSgwLHUpPT09KHQ9SChyLmMpKS5zbGljZSgwLHUpKXtpZihyLmU8YyYmLS11LFwiOTk5OVwiIT0odD10LnNsaWNlKHUtMyx1KzEpKSYmKG58fFwiNDk5OVwiIT10KSl7K3QmJigrdC5zbGljZSgxKXx8XCI1XCIhPXQuY2hhckF0KDApKXx8KFAocixyLmUreSsyLDEpLGU9IXIudGltZXMocikuZXEoYSkpO2JyZWFrfWlmKCFuJiYoUChpLGkuZSt5KzIsMCksaS50aW1lcyhpKS5lcShhKSkpe3I9aTticmVha31zKz00LHUrPTQsbj0xfXJldHVybiBQKHIsci5lK3krMSxiLGUpfSxuLnRvRXhwb25lbnRpYWw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbCE9ZSYmKEsoZSwwLHopLGUrKyksaSh0aGlzLGUsdCwxKX0sbi50b0ZpeGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGwhPWUmJihLKGUsMCx6KSxlPWUrdGhpcy5lKzEpLGkodGhpcyxlLHQpfSxuLnRvRm9ybWF0PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbjtpZihudWxsPT1yKW51bGwhPWUmJnQmJlwib2JqZWN0XCI9PXR5cGVvZiB0PyhyPXQsdD1udWxsKTplJiZcIm9iamVjdFwiPT10eXBlb2YgZT8ocj1lLGU9dD1udWxsKTpyPUI7ZWxzZSBpZihcIm9iamVjdFwiIT10eXBlb2Ygcil0aHJvdyBFcnJvcihSK1wiQXJndW1lbnQgbm90IGFuIG9iamVjdDogXCIrcik7aWYobj10aGlzLnRvRml4ZWQoZSx0KSx0aGlzLmMpe3ZhciBpLGE9bi5zcGxpdChcIi5cIiksbz0rci5ncm91cFNpemUsdT0rci5zZWNvbmRhcnlHcm91cFNpemUsYz1yLmdyb3VwU2VwYXJhdG9yfHxcIlwiLHM9YVswXSxsPWFbMV0sZj10aGlzLnM8MCxwPWY/cy5zbGljZSgxKTpzLGc9cC5sZW5ndGg7aWYodSYmKGk9byxvPXUsZy09dT1pKSwwPG8mJjA8Zyl7Zm9yKGk9ZyVvfHxvLHM9cC5zdWJzdHIoMCxpKTtpPGc7aSs9bylzKz1jK3Auc3Vic3RyKGksbyk7MDx1JiYocys9YytwLnNsaWNlKGkpKSxmJiYocz1cIi1cIitzKX1uPWw/cysoci5kZWNpbWFsU2VwYXJhdG9yfHxcIlwiKSsoKHU9K3IuZnJhY3Rpb25Hcm91cFNpemUpP2wucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXGR7XCIrdStcIn1cXFxcQlwiLFwiZ1wiKSxcIiQmXCIrKHIuZnJhY3Rpb25Hcm91cFNlcGFyYXRvcnx8XCJcIikpOmwpOnN9cmV0dXJuKHIucHJlZml4fHxcIlwiKStuKyhyLnN1ZmZpeHx8XCJcIil9LG4udG9GcmFjdGlvbj1mdW5jdGlvbihlKXt2YXIgdCxyLG4saSxhLG8sdSxjLHMsbCxmLHAsZz10aGlzLGQ9Zy5jO2lmKG51bGwhPWUmJighKHU9bmV3IEEoZSkpLmlzSW50ZWdlcigpJiYodS5jfHwxIT09dS5zKXx8dS5sdChoKSkpdGhyb3cgRXJyb3IoUitcIkFyZ3VtZW50IFwiKyh1LmlzSW50ZWdlcigpP1wib3V0IG9mIHJhbmdlOiBcIjpcIm5vdCBhbiBpbnRlZ2VyOiBcIikraih1KSk7aWYoIWQpcmV0dXJuIG5ldyBBKGcpO2Zvcih0PW5ldyBBKGgpLHM9cj1uZXcgQShoKSxuPWM9bmV3IEEoaCkscD1IKGQpLGE9dC5lPXAubGVuZ3RoLWcuZS0xLHQuY1swXT1xWyhvPWElRyk8MD9HK286b10sZT0hZXx8MDx1LmNvbXBhcmVkVG8odCk/MDxhP3Q6czp1LG89eCx4PTEvMCx1PW5ldyBBKHApLGMuY1swXT0wO2w9dih1LHQsMCwxKSwxIT0oaT1yLnBsdXMobC50aW1lcyhuKSkpLmNvbXBhcmVkVG8oZSk7KXI9bixuPWkscz1jLnBsdXMobC50aW1lcyhpPXMpKSxjPWksdD11Lm1pbnVzKGwudGltZXMoaT10KSksdT1pO3JldHVybiBpPXYoZS5taW51cyhyKSxuLDAsMSksYz1jLnBsdXMoaS50aW1lcyhzKSkscj1yLnBsdXMoaS50aW1lcyhuKSksYy5zPXMucz1nLnMsZj12KHMsbixhKj0yLGIpLm1pbnVzKGcpLmFicygpLmNvbXBhcmVkVG8odihjLHIsYSxiKS5taW51cyhnKS5hYnMoKSk8MT9bcyxuXTpbYyxyXSx4PW8sZn0sbi50b051bWJlcj1mdW5jdGlvbigpe3JldHVybitqKHRoaXMpfSxuLnRvUHJlY2lzaW9uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGwhPWUmJksoZSwxLHopLGkodGhpcyxlLHQsMil9LG4udG9TdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQscj10aGlzLG49ci5zLGk9ci5lO3JldHVybiBudWxsPT09aT9uPyh0PVwiSW5maW5pdHlcIixuPDAmJih0PVwiLVwiK3QpKTp0PVwiTmFOXCI6KHQ9bnVsbD09ZT9pPD1kfHx3PD1pP1goSChyLmMpLGkpOlEoSChyLmMpLGksXCIwXCIpOjEwPT09ZT9RKEgoKHI9UChuZXcgQShyKSx5K2krMSxiKSkuYyksci5lLFwiMFwiKTooSyhlLDIsTS5sZW5ndGgsXCJCYXNlXCIpLGYoUShIKHIuYyksaSxcIjBcIiksMTAsZSxuLCEwKSksbjwwJiZyLmNbMF0mJih0PVwiLVwiK3QpKSx0fSxuLnZhbHVlT2Y9bi50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gaih0aGlzKX0sbi5faXNCaWdOdW1iZXI9ITAsbnVsbCE9dCYmQS5zZXQodCksQX0oKSkuZGVmYXVsdD10LkJpZ051bWJlcj10LHZvaWQgMCE9PXImJnIuZXhwb3J0cz9yLmV4cG9ydHM9dDooZT1lfHwoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGY/c2VsZjp3aW5kb3cpKS5CaWdOdW1iZXI9dH0odGhpcyl9LHt9XSwyOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXtsYW5ndWFnZVRhZzpcImVuLVVTXCIsZGVsaW1pdGVyczp7dGhvdXNhbmRzOlwiLFwiLGRlY2ltYWw6XCIuXCJ9LGFiYnJldmlhdGlvbnM6e3Rob3VzYW5kOlwia1wiLG1pbGxpb246XCJtXCIsYmlsbGlvbjpcImJcIix0cmlsbGlvbjpcInRcIn0sc3BhY2VTZXBhcmF0ZWQ6ITEsb3JkaW5hbDpmdW5jdGlvbihlKXt2YXIgdD1lJTEwO3JldHVybiAxPT1+fihlJTEwMC8xMCk/XCJ0aFwiOjE9PXQ/XCJzdFwiOjI9PXQ/XCJuZFwiOjM9PXQ/XCJyZFwiOlwidGhcIn0sYnl0ZXM6e2JpbmFyeVN1ZmZpeGVzOltcIkJcIixcIktpQlwiLFwiTWlCXCIsXCJHaUJcIixcIlRpQlwiLFwiUGlCXCIsXCJFaUJcIixcIlppQlwiLFwiWWlCXCJdLGRlY2ltYWxTdWZmaXhlczpbXCJCXCIsXCJLQlwiLFwiTUJcIixcIkdCXCIsXCJUQlwiLFwiUEJcIixcIkVCXCIsXCJaQlwiLFwiWUJcIl19LGN1cnJlbmN5OntzeW1ib2w6XCIkXCIscG9zaXRpb246XCJwcmVmaXhcIixjb2RlOlwiVVNEXCJ9LGN1cnJlbmN5Rm9ybWF0Ont0aG91c2FuZFNlcGFyYXRlZDohMCx0b3RhbExlbmd0aDo0LHNwYWNlU2VwYXJhdGVkOiEwLHNwYWNlU2VwYXJhdGVkQ3VycmVuY3k6ITB9LGZvcm1hdHM6e2ZvdXJEaWdpdHM6e3RvdGFsTGVuZ3RoOjQsc3BhY2VTZXBhcmF0ZWQ6ITB9LGZ1bGxXaXRoVHdvRGVjaW1hbHM6e291dHB1dDpcImN1cnJlbmN5XCIsdGhvdXNhbmRTZXBhcmF0ZWQ6ITAsbWFudGlzc2E6Mn0sZnVsbFdpdGhUd29EZWNpbWFsc05vQ3VycmVuY3k6e3Rob3VzYW5kU2VwYXJhdGVkOiEwLG1hbnRpc3NhOjJ9LGZ1bGxXaXRoTm9EZWNpbWFsczp7b3V0cHV0OlwiY3VycmVuY3lcIix0aG91c2FuZFNlcGFyYXRlZDohMCxtYW50aXNzYTowfX19fSx7fV0sMzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIEkoZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX0oZSl8fGZ1bmN0aW9uKGUsdCl7aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKSlyZXR1cm47dmFyIHI9W10sbj0hMCxpPSExLGE9dm9pZCAwO3RyeXtmb3IodmFyIG8sdT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKG49KG89dS5uZXh0KCkpLmRvbmUpJiYoci5wdXNoKG8udmFsdWUpLCF0fHxyLmxlbmd0aCE9PXQpO249ITApO31jYXRjaChlKXtpPSEwLGE9ZX1maW5hbGx5e3RyeXtufHxudWxsPT11LnJldHVybnx8dS5yZXR1cm4oKX1maW5hbGx5e2lmKGkpdGhyb3cgYX19cmV0dXJuIHJ9KGUsdCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9dmFyICQ9ZShcIi4vZ2xvYmFsU3RhdGVcIiksbz1lKFwiLi92YWxpZGF0aW5nXCIpLHU9ZShcIi4vcGFyc2luZ1wiKSxHPXt0cmlsbGlvbjpNYXRoLnBvdygxMCwxMiksYmlsbGlvbjpNYXRoLnBvdygxMCw5KSxtaWxsaW9uOk1hdGgucG93KDEwLDYpLHRob3VzYW5kOk1hdGgucG93KDEwLDMpfSxWPXt0b3RhbExlbmd0aDowLGNoYXJhY3RlcmlzdGljOjAsZm9yY2VBdmVyYWdlOiExLGF2ZXJhZ2U6ITEsbWFudGlzc2E6LTEsb3B0aW9uYWxNYW50aXNzYTohMCx0aG91c2FuZFNlcGFyYXRlZDohMSxzcGFjZVNlcGFyYXRlZDohMSxuZWdhdGl2ZTpcInNpZ25cIixmb3JjZVNpZ246ITEscm91bmRpbmdGdW5jdGlvbjpNYXRoLnJvdW5kLHNwYWNlU2VwYXJhdGVkQWJicmV2aWF0aW9uOiExfSxuPSQuY3VycmVudEJ5dGVzKCksZD1uLmJpbmFyeVN1ZmZpeGVzLGg9bi5kZWNpbWFsU3VmZml4ZXMsaT17Z2VuZXJhbDp7c2NhbGU6MTAyNCxzdWZmaXhlczpoLG1hcmtlcjpcImJkXCJ9LGJpbmFyeTp7c2NhbGU6MTAyNCxzdWZmaXhlczpkLG1hcmtlcjpcImJcIn0sZGVjaW1hbDp7c2NhbGU6MWUzLHN1ZmZpeGVzOmgsbWFya2VyOlwiZFwifX07ZnVuY3Rpb24gYShlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30scj0yPGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzJdOnZvaWQgMDtpZihcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9dS5wYXJzZUZvcm1hdCh0KSksIW8udmFsaWRhdGVGb3JtYXQodCkpcmV0dXJuXCJFUlJPUjogaW52YWxpZCBmb3JtYXRcIjt2YXIgbj10LnByZWZpeHx8XCJcIixpPXQucG9zdGZpeHx8XCJcIixhPWZ1bmN0aW9uKGUsdCxyKXtzd2l0Y2godC5vdXRwdXQpe2Nhc2VcImN1cnJlbmN5XCI6cmV0dXJuIHQ9Yyh0LCQuY3VycmVudEN1cnJlbmN5RGVmYXVsdEZvcm1hdCgpKSxmdW5jdGlvbihlLHQscil7dmFyIG49ci5jdXJyZW50Q3VycmVuY3koKSxpPU9iamVjdC5hc3NpZ24oe30sVix0KSxhPXZvaWQgMCxvPVwiXCIsdT0hIWkudG90YWxMZW5ndGh8fCEhaS5mb3JjZUF2ZXJhZ2V8fGkuYXZlcmFnZSxjPXQuY3VycmVuY3lQb3NpdGlvbnx8bi5wb3NpdGlvbixzPXQuY3VycmVuY3lTeW1ib2x8fG4uc3ltYm9sLGw9dm9pZCAwIT09aS5zcGFjZVNlcGFyYXRlZEN1cnJlbmN5P2kuc3BhY2VTZXBhcmF0ZWRDdXJyZW5jeTppLnNwYWNlU2VwYXJhdGVkO3ZvaWQgMD09PXQubG93UHJlY2lzaW9uJiYodC5sb3dQcmVjaXNpb249ITEpO2wmJihvPVwiIFwiKTtcImluZml4XCI9PT1jJiYoYT1vK3Mrbyk7dmFyIGY9bSh7aW5zdGFuY2U6ZSxwcm92aWRlZEZvcm1hdDp0LHN0YXRlOnIsZGVjaW1hbFNlcGFyYXRvcjphfSk7XCJwcmVmaXhcIj09PWMmJihmPWUuX3ZhbHVlPDAmJlwic2lnblwiPT09aS5uZWdhdGl2ZT9cIi1cIi5jb25jYXQobykuY29uY2F0KHMpLmNvbmNhdChmLnNsaWNlKDEpKTowPGUuX3ZhbHVlJiZpLmZvcmNlU2lnbj9cIitcIi5jb25jYXQobykuY29uY2F0KHMpLmNvbmNhdChmLnNsaWNlKDEpKTpzK28rZik7YyYmXCJwb3N0Zml4XCIhPT1jfHwobz0haS5zcGFjZVNlcGFyYXRlZEFiYnJldmlhdGlvbiYmdT9cIlwiOm8sZj1mK28rcyk7cmV0dXJuIGZ9KGUsdCwkKTtjYXNlXCJwZXJjZW50XCI6cmV0dXJuIHQ9Yyh0LCQuY3VycmVudFBlcmNlbnRhZ2VEZWZhdWx0Rm9ybWF0KCkpLGZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPXQucHJlZml4U3ltYm9sLGE9bSh7aW5zdGFuY2U6bigxMDAqZS5fdmFsdWUpLHByb3ZpZGVkRm9ybWF0OnQsc3RhdGU6cn0pLG89T2JqZWN0LmFzc2lnbih7fSxWLHQpO2lmKGkpcmV0dXJuXCIlXCIuY29uY2F0KG8uc3BhY2VTZXBhcmF0ZWQ/XCIgXCI6XCJcIikuY29uY2F0KGEpO3JldHVyblwiXCIuY29uY2F0KGEpLmNvbmNhdChvLnNwYWNlU2VwYXJhdGVkP1wiIFwiOlwiXCIsXCIlXCIpfShlLHQsJCxyKTtjYXNlXCJieXRlXCI6cmV0dXJuIHQ9Yyh0LCQuY3VycmVudEJ5dGVEZWZhdWx0Rm9ybWF0KCkpLGZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPXQuYmFzZXx8XCJiaW5hcnlcIixhPU9iamVjdC5hc3NpZ24oe30sVix0KSxvPXIuY3VycmVudEJ5dGVzKCksdT1vLmJpbmFyeVN1ZmZpeGVzLGM9by5kZWNpbWFsU3VmZml4ZXMscz17Z2VuZXJhbDp7c2NhbGU6MTAyNCxzdWZmaXhlczpjfHxoLG1hcmtlcjpcImJkXCJ9LGJpbmFyeTp7c2NhbGU6MTAyNCxzdWZmaXhlczp1fHxkLG1hcmtlcjpcImJcIn0sZGVjaW1hbDp7c2NhbGU6MWUzLHN1ZmZpeGVzOmN8fGgsbWFya2VyOlwiZFwifX1baV0sbD12KGUuX3ZhbHVlLHMuc3VmZml4ZXMscy5zY2FsZSksZj1sLnZhbHVlLHA9bC5zdWZmaXgsZz1tKHtpbnN0YW5jZTpuKGYpLHByb3ZpZGVkRm9ybWF0OnQsc3RhdGU6cixkZWZhdWx0czpyLmN1cnJlbnRCeXRlRGVmYXVsdEZvcm1hdCgpfSk7cmV0dXJuXCJcIi5jb25jYXQoZykuY29uY2F0KGEuc3BhY2VTZXBhcmF0ZWQ/XCIgXCI6XCJcIikuY29uY2F0KHApfShlLHQsJCxyKTtjYXNlXCJ0aW1lXCI6cmV0dXJuIHQ9Yyh0LCQuY3VycmVudFRpbWVEZWZhdWx0Rm9ybWF0KCkpLGZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguZmxvb3IoZS5fdmFsdWUvNjAvNjApLHI9TWF0aC5mbG9vcigoZS5fdmFsdWUtNjAqdCo2MCkvNjApLG49TWF0aC5yb3VuZChlLl92YWx1ZS02MCp0KjYwLTYwKnIpO3JldHVyblwiXCIuY29uY2F0KHQsXCI6XCIpLmNvbmNhdChyPDEwP1wiMFwiOlwiXCIpLmNvbmNhdChyLFwiOlwiKS5jb25jYXQobjwxMD9cIjBcIjpcIlwiKS5jb25jYXQobil9KGUpO2Nhc2VcIm9yZGluYWxcIjpyZXR1cm4gdD1jKHQsJC5jdXJyZW50T3JkaW5hbERlZmF1bHRGb3JtYXQoKSksZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIuY3VycmVudE9yZGluYWwoKSxpPU9iamVjdC5hc3NpZ24oe30sVix0KSxhPW0oe2luc3RhbmNlOmUscHJvdmlkZWRGb3JtYXQ6dCxzdGF0ZTpyfSksbz1uKGUuX3ZhbHVlKTtyZXR1cm5cIlwiLmNvbmNhdChhKS5jb25jYXQoaS5zcGFjZVNlcGFyYXRlZD9cIiBcIjpcIlwiKS5jb25jYXQobyl9KGUsdCwkKTtjYXNlXCJudW1iZXJcIjpkZWZhdWx0OnJldHVybiBtKHtpbnN0YW5jZTplLHByb3ZpZGVkRm9ybWF0OnQsbnVtYnJvOnJ9KX19KGUsdCxyKTtyZXR1cm4gYT0oYT1uK2EpK2l9ZnVuY3Rpb24gdihlLHQscil7dmFyIG49dFswXSxpPU1hdGguYWJzKGUpO2lmKHI8PWkpe2Zvcih2YXIgYT0xO2E8dC5sZW5ndGg7KythKXt2YXIgbz1NYXRoLnBvdyhyLGEpLHU9TWF0aC5wb3cocixhKzEpO2lmKG88PWkmJmk8dSl7bj10W2FdLGUvPW87YnJlYWt9fW49PT10WzBdJiYoZS89TWF0aC5wb3cocix0Lmxlbmd0aC0xKSxuPXRbdC5sZW5ndGgtMV0pfXJldHVybnt2YWx1ZTplLHN1ZmZpeDpufX1mdW5jdGlvbiBwKGUpe2Zvcih2YXIgdD1cIlwiLHI9MDtyPGU7cisrKXQrPVwiMFwiO3JldHVybiB0fWZ1bmN0aW9uIHEoZSx0LHIpe3ZhciBuPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09cj9yOk1hdGgucm91bmQ7cmV0dXJuLTEhPT1lLnRvU3RyaW5nKCkuaW5kZXhPZihcImVcIik/ZnVuY3Rpb24oZSx0KXt2YXIgcj1lLnRvU3RyaW5nKCksbj1JKHIuc3BsaXQoXCJlXCIpLDIpLGk9blswXSxhPW5bMV0sbz1JKGkuc3BsaXQoXCIuXCIpLDIpLHU9b1swXSxjPW9bMV0scz12b2lkIDA9PT1jP1wiXCI6YztpZigwPCthKXI9dStzK3AoYS1zLmxlbmd0aCk7ZWxzZXt2YXIgbD1cIi5cIjtsPSt1PDA/XCItMFwiLmNvbmNhdChsKTpcIjBcIi5jb25jYXQobCk7dmFyIGY9KHAoLWEtMSkrTWF0aC5hYnModSkrcykuc3Vic3RyKDAsdCk7Zi5sZW5ndGg8dCYmKGYrPXAodC1mLmxlbmd0aCkpLHI9bCtmfXJldHVybiAwPCthJiYwPHQmJihyKz1cIi5cIi5jb25jYXQocCh0KSkpLHJ9KGUsdCk6KG4oK1wiXCIuY29uY2F0KGUsXCJlK1wiKS5jb25jYXQodCkpL01hdGgucG93KDEwLHQpKS50b0ZpeGVkKHQpfWZ1bmN0aW9uIFooZSx0LHIsbixpKXt2YXIgYT1uLmN1cnJlbnREZWxpbWl0ZXJzKCksbz1hLnRob3VzYW5kcztpPWl8fGEuZGVjaW1hbDt2YXIgdT1hLnRob3VzYW5kc1NpemV8fDMsYz1lLnRvU3RyaW5nKCkscz1jLnNwbGl0KFwiLlwiKVswXSxsPWMuc3BsaXQoXCIuXCIpWzFdLGY9dDwwJiYwPT09cy5pbmRleE9mKFwiLVwiKTtyJiYoZiYmKHM9cy5zbGljZSgxKSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9W10sbj0wLGk9ZTswPGk7aS0tKW49PT10JiYoci51bnNoaWZ0KGkpLG49MCksbisrO3JldHVybiByfShzLmxlbmd0aCx1KS5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7cz1zLnNsaWNlKDAsZSt0KStvK3Muc2xpY2UoZSt0KX0pLGYmJihzPVwiLVwiLmNvbmNhdChzKSkpO3JldHVybiBjPWw/cytpK2w6c31mdW5jdGlvbiBtKGUpe3ZhciB0PWUuaW5zdGFuY2Uscj1lLnByb3ZpZGVkRm9ybWF0LG49ZS5zdGF0ZSxpPXZvaWQgMD09PW4/JDpuLGE9ZS5kZWNpbWFsU2VwYXJhdG9yLG89ZS5kZWZhdWx0cyx1PXZvaWQgMD09PW8/aS5jdXJyZW50RGVmYXVsdHMoKTpvLGM9dC5fdmFsdWU7aWYoMD09PWMmJmkuaGFzWmVyb0Zvcm1hdCgpKXJldHVybiBpLmdldFplcm9Gb3JtYXQoKTtpZighaXNGaW5pdGUoYykpcmV0dXJuIGMudG9TdHJpbmcoKTt2YXIgcyxsLGYscCxnLGQsaCx2LG09T2JqZWN0LmFzc2lnbih7fSxWLHUscikseT1tLnRvdGFsTGVuZ3RoLGI9eT8wOm0uY2hhcmFjdGVyaXN0aWMsdz1tLm9wdGlvbmFsQ2hhcmFjdGVyaXN0aWMsUz1tLmZvcmNlQXZlcmFnZSx4PW0ubG93UHJlY2lzaW9uLE89ISF5fHwhIVN8fG0uYXZlcmFnZSxOPXk/LTE6TyYmdm9pZCAwPT09ci5tYW50aXNzYT8wOm0ubWFudGlzc2EsQj0heSYmKHZvaWQgMD09PXIub3B0aW9uYWxNYW50aXNzYT8tMT09PU46bS5vcHRpb25hbE1hbnRpc3NhKSxNPW0udHJpbU1hbnRpc3NhLEE9bS50aG91c2FuZFNlcGFyYXRlZCxEPW0uc3BhY2VTZXBhcmF0ZWQsRT1tLm5lZ2F0aXZlLEY9bS5mb3JjZVNpZ24saz1tLmV4cG9uZW50aWFsLF89bS5yb3VuZGluZ0Z1bmN0aW9uLEw9XCJcIjtpZihPKXt2YXIgUD1mdW5jdGlvbihlKXt2YXIgdD1lLnZhbHVlLHI9ZS5mb3JjZUF2ZXJhZ2Usbj1lLmxvd1ByZWNpc2lvbixpPXZvaWQgMD09PW58fG4sYT1lLmFiYnJldmlhdGlvbnMsbz1lLnNwYWNlU2VwYXJhdGVkLHU9dm9pZCAwIT09byYmbyxjPWUudG90YWxMZW5ndGgscz12b2lkIDA9PT1jPzA6YyxsPWUucm91bmRpbmdGdW5jdGlvbixmPXZvaWQgMD09PWw/TWF0aC5yb3VuZDpsLHA9XCJcIixnPU1hdGguYWJzKHQpLGQ9LTE7aWYociYmYVtyXSYmR1tyXT8ocD1hW3JdLHQvPUdbcl0pOmc+PUcudHJpbGxpb258fGkmJjE9PT1mKGcvRy50cmlsbGlvbik/KHA9YS50cmlsbGlvbix0Lz1HLnRyaWxsaW9uKTpnPEcudHJpbGxpb24mJmc+PUcuYmlsbGlvbnx8aSYmMT09PWYoZy9HLmJpbGxpb24pPyhwPWEuYmlsbGlvbix0Lz1HLmJpbGxpb24pOmc8Ry5iaWxsaW9uJiZnPj1HLm1pbGxpb258fGkmJjE9PT1mKGcvRy5taWxsaW9uKT8ocD1hLm1pbGxpb24sdC89Ry5taWxsaW9uKTooZzxHLm1pbGxpb24mJmc+PUcudGhvdXNhbmR8fGkmJjE9PT1mKGcvRy50aG91c2FuZCkpJiYocD1hLnRob3VzYW5kLHQvPUcudGhvdXNhbmQpLHA9cCYmKHU/XCIgXCI6XCJcIikrcCxzKXt2YXIgaD10PDAsdj10LnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzBdLG09aD92Lmxlbmd0aC0xOnYubGVuZ3RoO2Q9TWF0aC5tYXgocy1tLDApfXJldHVybnt2YWx1ZTp0LGFiYnJldmlhdGlvbjpwLG1hbnRpc3NhUHJlY2lzaW9uOmR9fSh7dmFsdWU6Yyxmb3JjZUF2ZXJhZ2U6Uyxsb3dQcmVjaXNpb246eCxhYmJyZXZpYXRpb25zOmkuY3VycmVudEFiYnJldmlhdGlvbnMoKSxzcGFjZVNlcGFyYXRlZDpELHJvdW5kaW5nRnVuY3Rpb246Xyx0b3RhbExlbmd0aDp5fSk7Yz1QLnZhbHVlLEwrPVAuYWJicmV2aWF0aW9uLHkmJihOPVAubWFudGlzc2FQcmVjaXNpb24pfWlmKGspe3ZhciBqPShsPShzPXt2YWx1ZTpjLGNoYXJhY3RlcmlzdGljUHJlY2lzaW9uOmJ9KS52YWx1ZSxmPXMuY2hhcmFjdGVyaXN0aWNQcmVjaXNpb24scD12b2lkIDA9PT1mPzA6ZixnPUkobC50b0V4cG9uZW50aWFsKCkuc3BsaXQoXCJlXCIpLDIpLGQ9Z1swXSxoPWdbMV0sdj0rZCxwJiYxPHAmJih2Kj1NYXRoLnBvdygxMCxwLTEpLGg9MDw9KGgtPXAtMSk/XCIrXCIuY29uY2F0KGgpOmgpLHt2YWx1ZTp2LGFiYnJldmlhdGlvbjpcImVcIi5jb25jYXQoaCl9KTtjPWoudmFsdWUsTD1qLmFiYnJldmlhdGlvbitMfXZhciBDLFQsVSxSPWZ1bmN0aW9uKGUsdCxyLG4saSxhKXtpZigtMT09PW4pcmV0dXJuIGU7dmFyIG89cSh0LG4sYSksdT1JKG8udG9TdHJpbmcoKS5zcGxpdChcIi5cIiksMiksYz11WzBdLHM9dVsxXSxsPXZvaWQgMD09PXM/XCJcIjpzO2lmKGwubWF0Y2goL14wKyQvKSYmKHJ8fGkpKXJldHVybiBjO3ZhciBmPWwubWF0Y2goLzArJC8pO3JldHVybiBpJiZmP1wiXCIuY29uY2F0KGMsXCIuXCIpLmNvbmNhdChsLnRvU3RyaW5nKCkuc2xpY2UoMCxmLmluZGV4KSk6by50b1N0cmluZygpfShjLnRvU3RyaW5nKCksYyxCLE4sTSxfKTtyZXR1cm4gUj1aKFI9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk9ZSxhPUkoaS50b1N0cmluZygpLnNwbGl0KFwiLlwiKSwyKSxvPWFbMF0sdT1hWzFdO2lmKG8ubWF0Y2goL14tPzAkLykmJnIpcmV0dXJuIHU/XCJcIi5jb25jYXQoby5yZXBsYWNlKFwiMFwiLFwiXCIpLFwiLlwiKS5jb25jYXQodSk6by5yZXBsYWNlKFwiMFwiLFwiXCIpO3ZhciBjPXQ8MCYmMD09PW8uaW5kZXhPZihcIi1cIik7aWYoYyYmKG89by5zbGljZSgxKSxpPWkuc2xpY2UoMSkpLG8ubGVuZ3RoPG4pZm9yKHZhciBzPW4tby5sZW5ndGgsbD0wO2w8cztsKyspaT1cIjBcIi5jb25jYXQoaSk7cmV0dXJuIGMmJihpPVwiLVwiLmNvbmNhdChpKSksaS50b1N0cmluZygpfShSLGMsdyxiKSxjLEEsaSxhKSwoT3x8aykmJihSPVIrTCksKEZ8fGM8MCkmJihDPVIsVT1FLFI9MD09PShUPWMpP0M6MD09K0M/Qy5yZXBsYWNlKFwiLVwiLFwiXCIpOjA8VD9cIitcIi5jb25jYXQoQyk6XCJzaWduXCI9PT1VP0M6XCIoXCIuY29uY2F0KEMucmVwbGFjZShcIi1cIixcIlwiKSxcIilcIikpLFJ9ZnVuY3Rpb24gYyhlLHQpe2lmKCFlKXJldHVybiB0O3ZhciByPU9iamVjdC5rZXlzKGUpO3JldHVybiAxPT09ci5sZW5ndGgmJlwib3V0cHV0XCI9PT1yWzBdP3Q6ZX10LmV4cG9ydHM9ZnVuY3Rpb24obil7cmV0dXJue2Zvcm1hdDpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdO3JldHVybiBhLmFwcGx5KHZvaWQgMCx0LmNvbmNhdChbbl0pKX0sZ2V0Qnl0ZVVuaXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxyPTA7cjxlO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9aS5nZW5lcmFsO3JldHVybiB2KGUuX3ZhbHVlLHQuc3VmZml4ZXMsdC5zY2FsZSkuc3VmZml4fS5hcHBseSh2b2lkIDAsdC5jb25jYXQoW25dKSl9LGdldEJpbmFyeUJ5dGVVbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWkuYmluYXJ5O3JldHVybiB2KGUuX3ZhbHVlLHQuc3VmZml4ZXMsdC5zY2FsZSkuc3VmZml4fS5hcHBseSh2b2lkIDAsdC5jb25jYXQoW25dKSl9LGdldERlY2ltYWxCeXRlVW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdO3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1pLmRlY2ltYWw7cmV0dXJuIHYoZS5fdmFsdWUsdC5zdWZmaXhlcyx0LnNjYWxlKS5zdWZmaXh9LmFwcGx5KHZvaWQgMCx0LmNvbmNhdChbbl0pKX0sZm9ybWF0T3JEZWZhdWx0OmN9fX0se1wiLi9nbG9iYWxTdGF0ZVwiOjQsXCIuL3BhcnNpbmdcIjo4LFwiLi92YWxpZGF0aW5nXCI6MTB9XSw0OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4vZW4tVVNcIiksbj1lKFwiLi92YWxpZGF0aW5nXCIpLGE9ZShcIi4vcGFyc2luZ1wiKSxvPXt9LHU9dm9pZCAwLGM9e30scz1udWxsLGw9e307ZnVuY3Rpb24gZihlKXt1PWV9ZnVuY3Rpb24gcCgpe3JldHVybiBjW3VdfW8ubGFuZ3VhZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sYyl9LG8uY3VycmVudExhbmd1YWdlPWZ1bmN0aW9uKCl7cmV0dXJuIHV9LG8uY3VycmVudEJ5dGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHAoKS5ieXRlc3x8e319LG8uY3VycmVudEN1cnJlbmN5PWZ1bmN0aW9uKCl7cmV0dXJuIHAoKS5jdXJyZW5jeX0sby5jdXJyZW50QWJicmV2aWF0aW9ucz1mdW5jdGlvbigpe3JldHVybiBwKCkuYWJicmV2aWF0aW9uc30sby5jdXJyZW50RGVsaW1pdGVycz1mdW5jdGlvbigpe3JldHVybiBwKCkuZGVsaW1pdGVyc30sby5jdXJyZW50T3JkaW5hbD1mdW5jdGlvbigpe3JldHVybiBwKCkub3JkaW5hbH0sby5jdXJyZW50RGVmYXVsdHM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxwKCkuZGVmYXVsdHMsbCl9LG8uY3VycmVudE9yZGluYWxEZWZhdWx0Rm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sby5jdXJyZW50RGVmYXVsdHMoKSxwKCkub3JkaW5hbEZvcm1hdCl9LG8uY3VycmVudEJ5dGVEZWZhdWx0Rm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sby5jdXJyZW50RGVmYXVsdHMoKSxwKCkuYnl0ZUZvcm1hdCl9LG8uY3VycmVudFBlcmNlbnRhZ2VEZWZhdWx0Rm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sby5jdXJyZW50RGVmYXVsdHMoKSxwKCkucGVyY2VudGFnZUZvcm1hdCl9LG8uY3VycmVudEN1cnJlbmN5RGVmYXVsdEZvcm1hdD1mdW5jdGlvbigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LG8uY3VycmVudERlZmF1bHRzKCkscCgpLmN1cnJlbmN5Rm9ybWF0KX0sby5jdXJyZW50VGltZURlZmF1bHRGb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxvLmN1cnJlbnREZWZhdWx0cygpLHAoKS50aW1lRm9ybWF0KX0sby5zZXREZWZhdWx0cz1mdW5jdGlvbihlKXtlPWEucGFyc2VGb3JtYXQoZSksbi52YWxpZGF0ZUZvcm1hdChlKSYmKGw9ZSl9LG8uZ2V0WmVyb0Zvcm1hdD1mdW5jdGlvbigpe3JldHVybiBzfSxvLnNldFplcm9Gb3JtYXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHM9XCJzdHJpbmdcIj09dHlwZW9mIGU/ZTpudWxsfSxvLmhhc1plcm9Gb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXN9LG8ubGFuZ3VhZ2VEYXRhPWZ1bmN0aW9uKGUpe2lmKGUpe2lmKGNbZV0pcmV0dXJuIGNbZV07dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHRhZyBcIicuY29uY2F0KGUsJ1wiJykpfXJldHVybiBwKCl9LG8ucmVnaXN0ZXJMYW5ndWFnZT1mdW5jdGlvbihlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdO2lmKCFuLnZhbGlkYXRlTGFuZ3VhZ2UoZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsYW5ndWFnZSBkYXRhXCIpO2NbZS5sYW5ndWFnZVRhZ109ZSx0JiZmKGUubGFuZ3VhZ2VUYWcpfSxvLnNldExhbmd1YWdlPWZ1bmN0aW9uKGUpe3ZhciB0PTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTppLmxhbmd1YWdlVGFnO2lmKCFjW2VdKXt2YXIgcj1lLnNwbGl0KFwiLVwiKVswXSxuPU9iamVjdC5rZXlzKGMpLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoXCItXCIpWzBdPT09cn0pO3JldHVybiBjW25dP3ZvaWQgZihuKTp2b2lkIGYodCl9ZihlKX0sby5yZWdpc3Rlckxhbmd1YWdlKGkpLHU9aS5sYW5ndWFnZVRhZyx0LmV4cG9ydHM9b30se1wiLi9lbi1VU1wiOjIsXCIuL3BhcnNpbmdcIjo4LFwiLi92YWxpZGF0aW5nXCI6MTB9XSw1OltmdW5jdGlvbihuLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybntsb2FkTGFuZ3VhZ2VzSW5Ob2RlOmZ1bmN0aW9uKGUpe3JldHVybiByPXQsdm9pZCBlLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9dm9pZCAwO3RyeXtlPW4oXCIuLi9sYW5ndWFnZXMvXCIuY29uY2F0KHQpKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gbG9hZCBcIicuY29uY2F0KHQsJ1wiLiBObyBtYXRjaGluZyBsYW5ndWFnZSBmaWxlIGZvdW5kLicpKX1lJiZyLnJlZ2lzdGVyTGFuZ3VhZ2UoZSl9KTt2YXIgcn19fX0se31dLDY6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYz1lKFwiYmlnbnVtYmVyLmpzXCIpO2Z1bmN0aW9uIGEoZSx0LHIpe3ZhciBuPW5ldyBjKGUuX3ZhbHVlKSxpPXQ7cmV0dXJuIHIuaXNOdW1icm8odCkmJihpPXQuX3ZhbHVlKSxpPW5ldyBjKGkpLGUuX3ZhbHVlPW4ubWludXMoaSkudG9OdW1iZXIoKSxlfXQuZXhwb3J0cz1mdW5jdGlvbih1KXtyZXR1cm57YWRkOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG49dCxpPXUsYT1uZXcgYygocj1lKS5fdmFsdWUpLG89bixpLmlzTnVtYnJvKG4pJiYobz1uLl92YWx1ZSksbz1uZXcgYyhvKSxyLl92YWx1ZT1hLnBsdXMobykudG9OdW1iZXIoKSxyO3ZhciByLG4saSxhLG99LHN1YnRyYWN0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGEoZSx0LHUpfSxtdWx0aXBseTpmdW5jdGlvbihlLHQpe3JldHVybiBuPXQsaT11LGE9bmV3IGMoKHI9ZSkuX3ZhbHVlKSxvPW4saS5pc051bWJybyhuKSYmKG89bi5fdmFsdWUpLG89bmV3IGMobyksci5fdmFsdWU9YS50aW1lcyhvKS50b051bWJlcigpLHI7dmFyIHIsbixpLGEsb30sZGl2aWRlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG49dCxpPXUsYT1uZXcgYygocj1lKS5fdmFsdWUpLG89bixpLmlzTnVtYnJvKG4pJiYobz1uLl92YWx1ZSksbz1uZXcgYyhvKSxyLl92YWx1ZT1hLmRpdmlkZWRCeShvKS50b051bWJlcigpLHI7dmFyIHIsbixpLGEsb30sc2V0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHI9ZSxpPW49dCx1LmlzTnVtYnJvKG4pJiYoaT1uLl92YWx1ZSksci5fdmFsdWU9aSxyO3ZhciByLG4saX0sZGlmZmVyZW5jZTpmdW5jdGlvbihlLHQpe3JldHVybiByPXQsYShpPShuPXUpKGUuX3ZhbHVlKSxyLG4pLE1hdGguYWJzKGkuX3ZhbHVlKTt2YXIgcixuLGl9LEJpZ051bWJlcjpjfX19LHtcImJpZ251bWJlci5qc1wiOjF9XSw3OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19dmFyIGE9ZShcIi4vZ2xvYmFsU3RhdGVcIiksbj1lKFwiLi92YWxpZGF0aW5nXCIpLG89ZShcIi4vbG9hZGluZ1wiKShnKSx1PWUoXCIuL3VuZm9ybWF0dGluZ1wiKSxjPWUoXCIuL2Zvcm1hdHRpbmdcIikoZykscz1lKFwiLi9tYW5pcHVsYXRpbmdcIikoZyksbD1lKFwiLi9wYXJzaW5nXCIpLGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsdCksdGhpcy5fdmFsdWU9ZX12YXIgZSxyLG47cmV0dXJuIGU9dCwocj1be2tleTpcImNsb25lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZyh0aGlzLl92YWx1ZSl9fSx7a2V5OlwiZm9ybWF0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9MDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJuIGMuZm9ybWF0KHRoaXMsdCl9fSx7a2V5OlwiZm9ybWF0Q3VycmVuY3lcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9bC5wYXJzZUZvcm1hdChlKSksKGU9Yy5mb3JtYXRPckRlZmF1bHQoZSxhLmN1cnJlbnRDdXJyZW5jeURlZmF1bHRGb3JtYXQoKSkpLm91dHB1dD1cImN1cnJlbmN5XCIsYy5mb3JtYXQodGhpcyxlKX19LHtrZXk6XCJmb3JtYXRUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9MDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJuIHQub3V0cHV0PVwidGltZVwiLGMuZm9ybWF0KHRoaXMsdCl9fSx7a2V5OlwiYmluYXJ5Qnl0ZVVuaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXRCaW5hcnlCeXRlVW5pdCh0aGlzKX19LHtrZXk6XCJkZWNpbWFsQnl0ZVVuaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXREZWNpbWFsQnl0ZVVuaXQodGhpcyl9fSx7a2V5OlwiYnl0ZVVuaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXRCeXRlVW5pdCh0aGlzKX19LHtrZXk6XCJkaWZmZXJlbmNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuZGlmZmVyZW5jZSh0aGlzLGUpfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBzLmFkZCh0aGlzLGUpfX0se2tleTpcInN1YnRyYWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuc3VidHJhY3QodGhpcyxlKX19LHtrZXk6XCJtdWx0aXBseVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBzLm11bHRpcGx5KHRoaXMsZSl9fSx7a2V5OlwiZGl2aWRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuZGl2aWRlKHRoaXMsZSl9fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuc2V0KHRoaXMscChlKSl9fSx7a2V5OlwidmFsdWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl92YWx1ZX19LHtrZXk6XCJ2YWx1ZU9mXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFsdWV9fV0pJiZpKGUucHJvdG90eXBlLHIpLG4mJmkoZSxuKSx0fSgpO2Z1bmN0aW9uIHAoZSl7dmFyIHQ9ZTtyZXR1cm4gZy5pc051bWJybyhlKT90PWUuX3ZhbHVlOlwic3RyaW5nXCI9PXR5cGVvZiBlP3Q9Zy51bmZvcm1hdChlKTppc05hTihlKSYmKHQ9TmFOKSx0fWZ1bmN0aW9uIGcoZSl7cmV0dXJuIG5ldyBmKHAoZSkpfWcudmVyc2lvbj1cIjIuMy4yXCIsZy5pc051bWJybz1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGZ9LGcubGFuZ3VhZ2U9YS5jdXJyZW50TGFuZ3VhZ2UsZy5yZWdpc3Rlckxhbmd1YWdlPWEucmVnaXN0ZXJMYW5ndWFnZSxnLnNldExhbmd1YWdlPWEuc2V0TGFuZ3VhZ2UsZy5sYW5ndWFnZXM9YS5sYW5ndWFnZXMsZy5sYW5ndWFnZURhdGE9YS5sYW5ndWFnZURhdGEsZy56ZXJvRm9ybWF0PWEuc2V0WmVyb0Zvcm1hdCxnLmRlZmF1bHRGb3JtYXQ9YS5jdXJyZW50RGVmYXVsdHMsZy5zZXREZWZhdWx0cz1hLnNldERlZmF1bHRzLGcuZGVmYXVsdEN1cnJlbmN5Rm9ybWF0PWEuY3VycmVudEN1cnJlbmN5RGVmYXVsdEZvcm1hdCxnLnZhbGlkYXRlPW4udmFsaWRhdGUsZy5sb2FkTGFuZ3VhZ2VzSW5Ob2RlPW8ubG9hZExhbmd1YWdlc0luTm9kZSxnLnVuZm9ybWF0PXUudW5mb3JtYXQsZy5CaWdOdW1iZXI9cy5CaWdOdW1iZXIsdC5leHBvcnRzPWd9LHtcIi4vZm9ybWF0dGluZ1wiOjMsXCIuL2dsb2JhbFN0YXRlXCI6NCxcIi4vbG9hZGluZ1wiOjUsXCIuL21hbmlwdWxhdGluZ1wiOjYsXCIuL3BhcnNpbmdcIjo4LFwiLi91bmZvcm1hdHRpbmdcIjo5LFwiLi92YWxpZGF0aW5nXCI6MTB9XSw4OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXtwYXJzZUZvcm1hdDpmdW5jdGlvbihlKXt2YXIgdCxyLG4saSxhLG8sdSxjLHMsbCxmLHAsZyxkLGgsdixtLHksYix3LFMseCxPPTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgZT9lOihyPU8sZT0obj0odD1lKS5tYXRjaCgvXnsoW159XSopfS8pKT8oci5wcmVmaXg9blsxXSx0LnNsaWNlKG5bMF0ubGVuZ3RoKSk6dCxhPU8sZnVuY3Rpb24oZSx0KXtpZigtMT09PWUuaW5kZXhPZihcIiRcIikpe2lmKC0xPT09ZS5pbmRleE9mKFwiJVwiKSlyZXR1cm4tMSE9PWUuaW5kZXhPZihcImJkXCIpPyh0Lm91dHB1dD1cImJ5dGVcIix0LmJhc2U9XCJnZW5lcmFsXCIpOi0xIT09ZS5pbmRleE9mKFwiYlwiKT8odC5vdXRwdXQ9XCJieXRlXCIsdC5iYXNlPVwiYmluYXJ5XCIpOi0xIT09ZS5pbmRleE9mKFwiZFwiKT8odC5vdXRwdXQ9XCJieXRlXCIsdC5iYXNlPVwiZGVjaW1hbFwiKTotMT09PWUuaW5kZXhPZihcIjpcIik/LTEhPT1lLmluZGV4T2YoXCJvXCIpJiYodC5vdXRwdXQ9XCJvcmRpbmFsXCIpOnQub3V0cHV0PVwidGltZVwiO3Qub3V0cHV0PVwicGVyY2VudFwifWVsc2UgdC5vdXRwdXQ9XCJjdXJyZW5jeVwifShlPShvPShpPWUpLm1hdGNoKC97KFtefV0qKX0kLykpPyhhLnBvc3RmaXg9b1sxXSxpLnNsaWNlKDAsLW9bMF0ubGVuZ3RoKSk6aSxPKSx1PU8sKGM9ZS5tYXRjaCgvWzEtOV0rWzAtOV0qLykpJiYodS50b3RhbExlbmd0aD0rY1swXSkscz1PLChsPWUuc3BsaXQoXCIuXCIpWzBdLm1hdGNoKC8wKy8pKSYmKHMuY2hhcmFjdGVyaXN0aWM9bFswXS5sZW5ndGgpLGZ1bmN0aW9uKGUsdCl7aWYoLTEhPT1lLmluZGV4T2YoXCIuXCIpKXt2YXIgcj1lLnNwbGl0KFwiLlwiKVswXTt0Lm9wdGlvbmFsQ2hhcmFjdGVyaXN0aWM9LTE9PT1yLmluZGV4T2YoXCIwXCIpfX0oZSxPKSxmPU8sLTEhPT1lLmluZGV4T2YoXCJhXCIpJiYoZi5hdmVyYWdlPSEwKSxnPU8sLTEhPT0ocD1lKS5pbmRleE9mKFwiS1wiKT9nLmZvcmNlQXZlcmFnZT1cInRob3VzYW5kXCI6LTEhPT1wLmluZGV4T2YoXCJNXCIpP2cuZm9yY2VBdmVyYWdlPVwibWlsbGlvblwiOi0xIT09cC5pbmRleE9mKFwiQlwiKT9nLmZvcmNlQXZlcmFnZT1cImJpbGxpb25cIjotMSE9PXAuaW5kZXhPZihcIlRcIikmJihnLmZvcmNlQXZlcmFnZT1cInRyaWxsaW9uXCIpLGZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS5zcGxpdChcIi5cIilbMV07aWYocil7dmFyIG49ci5tYXRjaCgvMCsvKTtuJiYodC5tYW50aXNzYT1uWzBdLmxlbmd0aCl9fShlLE8pLGg9TywoZD1lKS5tYXRjaCgvXFxbXFwuXS8pP2gub3B0aW9uYWxNYW50aXNzYT0hMDpkLm1hdGNoKC9cXC4vKSYmKGgub3B0aW9uYWxNYW50aXNzYT0hMSksdj1PLChtPWUuc3BsaXQoXCIuXCIpWzFdKSYmKHYudHJpbU1hbnRpc3NhPS0xIT09bS5pbmRleE9mKFwiW1wiKSkseT1PLC0xIT09ZS5pbmRleE9mKFwiLFwiKSYmKHkudGhvdXNhbmRTZXBhcmF0ZWQ9ITApLGI9TywtMSE9PWUuaW5kZXhPZihcIiBcIikmJihiLnNwYWNlU2VwYXJhdGVkPSEwLGIuc3BhY2VTZXBhcmF0ZWRDdXJyZW5jeT0hMCwoYi5hdmVyYWdlfHxiLmZvcmNlQXZlcmFnZSkmJihiLnNwYWNlU2VwYXJhdGVkQWJicmV2aWF0aW9uPSEwKSksUz1PLCh3PWUpLm1hdGNoKC9eXFwrP1xcKFteKV0qXFwpJC8pJiYoUy5uZWdhdGl2ZT1cInBhcmVudGhlc2lzXCIpLHcubWF0Y2goL15cXCs/LS8pJiYoUy5uZWdhdGl2ZT1cInNpZ25cIikseD1PLGUubWF0Y2goL15cXCsvKSYmKHguZm9yY2VTaWduPSEwKSxPKX19fSx7fV0sOTpbZnVuY3Rpb24ocCxlLHQpe1widXNlIHN0cmljdFwiO3ZhciBNPVt7a2V5OlwiWmlCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsNyl9LHtrZXk6XCJaQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsNyl9LHtrZXk6XCJZaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCw4KX0se2tleTpcIllCXCIsZmFjdG9yOk1hdGgucG93KDFlMyw4KX0se2tleTpcIlRpQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDQpfSx7a2V5OlwiVEJcIixmYWN0b3I6TWF0aC5wb3coMWUzLDQpfSx7a2V5OlwiUGlCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsNSl9LHtrZXk6XCJQQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsNSl9LHtrZXk6XCJNaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCwyKX0se2tleTpcIk1CXCIsZmFjdG9yOk1hdGgucG93KDFlMywyKX0se2tleTpcIktpQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDEpfSx7a2V5OlwiS0JcIixmYWN0b3I6TWF0aC5wb3coMWUzLDEpfSx7a2V5OlwiR2lCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsMyl9LHtrZXk6XCJHQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsMyl9LHtrZXk6XCJFaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCw2KX0se2tleTpcIkVCXCIsZmFjdG9yOk1hdGgucG93KDFlMyw2KX0se2tleTpcIkJcIixmYWN0b3I6MX1dO2Z1bmN0aW9uIEEoZSl7cmV0dXJuIGUucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZyxcIlxcXFwkJlwiKX1mdW5jdGlvbiBnKGUsdCxyLG4saSxhLG8pe3ZhciB1PTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09cj9yOlwiXCIsYz0zPGFyZ3VtZW50cy5sZW5ndGg/bjp2b2lkIDAscz00PGFyZ3VtZW50cy5sZW5ndGg/aTp2b2lkIDAsbD01PGFyZ3VtZW50cy5sZW5ndGg/YTp2b2lkIDAsZj02PGFyZ3VtZW50cy5sZW5ndGg/bzp2b2lkIDA7aWYoXCJcIiE9PWUpcmV0dXJuIGU9PT1zPzA6ZnVuY3Rpb24gZSh0LHIsbixpLGEsbyx1KXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PW4/bjpcIlwiLHM9Mzxhcmd1bWVudHMubGVuZ3RoP2k6dm9pZCAwLGw9NDxhcmd1bWVudHMubGVuZ3RoP2E6dm9pZCAwLGY9NTxhcmd1bWVudHMubGVuZ3RoP286dm9pZCAwLHA9Njxhcmd1bWVudHMubGVuZ3RoP3U6dm9pZCAwO2lmKCFpc05hTigrdCkpcmV0dXJuK3Q7dmFyIGc9XCJcIixkPXQucmVwbGFjZSgvKF5bXihdKilcXCgoLiopXFwpKFteKV0qJCkvLFwiJDEkMiQzXCIpO2lmKGQhPT10KXJldHVybi0xKmUoZCxyLGMscyxsLGYscCk7Zm9yKHZhciBoPTA7aDxNLmxlbmd0aDtoKyspe3ZhciB2PU1baF07aWYoKGc9dC5yZXBsYWNlKFJlZ0V4cChcIihbMC05IF0pKFwiLmNvbmNhdCh2LmtleSxcIikkXCIpKSxcIiQxXCIpKSE9PXQpcmV0dXJuIGUoZyxyLGMscyxsLGYscCkqdi5mYWN0b3J9aWYoKGc9dC5yZXBsYWNlKFwiJVwiLFwiXCIpKSE9PXQpcmV0dXJuIGUoZyxyLGMscyxsLGYscCkvMTAwO3ZhciBtPXBhcnNlRmxvYXQodCk7aWYoIWlzTmFOKG0pKXt2YXIgeT1zKG0pO2lmKHkmJlwiLlwiIT09eSYmKGc9dC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoQSh5KSxcIiRcIikpLFwiXCIpKSE9PXQpcmV0dXJuIGUoZyxyLGMscyxsLGYscCk7dmFyIGI9e307T2JqZWN0LmtleXMoZikuZm9yRWFjaChmdW5jdGlvbihlKXtiW2ZbZV1dPWV9KTtmb3IodmFyIHc9T2JqZWN0LmtleXMoYikuc29ydCgpLnJldmVyc2UoKSxTPXcubGVuZ3RoLHg9MDt4PFM7eCsrKXt2YXIgTz13W3hdLE49YltPXTtpZigoZz10LnJlcGxhY2UoTyxcIlwiKSkhPT10KXt2YXIgQj12b2lkIDA7c3dpdGNoKE4pe2Nhc2VcInRob3VzYW5kXCI6Qj1NYXRoLnBvdygxMCwzKTticmVhaztjYXNlXCJtaWxsaW9uXCI6Qj1NYXRoLnBvdygxMCw2KTticmVhaztjYXNlXCJiaWxsaW9uXCI6Qj1NYXRoLnBvdygxMCw5KTticmVhaztjYXNlXCJ0cmlsbGlvblwiOkI9TWF0aC5wb3coMTAsMTIpfXJldHVybiBlKGcscixjLHMsbCxmLHApKkJ9fX19KGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PXI/cjpcIlwiLGk9ZS5yZXBsYWNlKG4sXCJcIik7cmV0dXJuIGk9KGk9aS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoWzAtOV0pXCIuY29uY2F0KEEodC50aG91c2FuZHMpLFwiKFswLTldKVwiKSxcImdcIiksXCIkMSQyXCIpKS5yZXBsYWNlKHQuZGVjaW1hbCxcIi5cIil9KGUsdCx1KSx0LHUsYyxzLGwsZil9ZS5leHBvcnRzPXt1bmZvcm1hdDpmdW5jdGlvbihlLHQpe3ZhciByLG4saSxhPXAoXCIuL2dsb2JhbFN0YXRlXCIpLG89YS5jdXJyZW50RGVsaW1pdGVycygpLHU9YS5jdXJyZW50Q3VycmVuY3koKS5zeW1ib2wsYz1hLmN1cnJlbnRPcmRpbmFsKCkscz1hLmdldFplcm9Gb3JtYXQoKSxsPWEuY3VycmVudEFiYnJldmlhdGlvbnMoKSxmPXZvaWQgMDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlmPWZ1bmN0aW9uKGUsdCl7aWYoZS5pbmRleE9mKFwiOlwiKSYmXCI6XCIhPT10LnRob3VzYW5kcyl7dmFyIHI9ZS5zcGxpdChcIjpcIik7aWYoMz09PXIubGVuZ3RoKXt2YXIgbj0rclswXSxpPStyWzFdLGE9K3JbMl07cmV0dXJuIWlzTmFOKG4pJiYhaXNOYU4oaSkmJiFpc05hTihhKX19fShlLG8pPyhyPWUuc3BsaXQoXCI6XCIpLG49K3JbMF0saT0rclsxXSwrclsyXSs2MCppKzM2MDAqbik6ZyhlLG8sdSxjLHMsbCx0KTtlbHNle2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlKXJldHVybjtmPWV9aWYodm9pZCAwIT09ZilyZXR1cm4gZn19fSx7XCIuL2dsb2JhbFN0YXRlXCI6NH1dLDEwOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PTAscj1uZXcgQXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKXJbdF09ZVt0XTtyZXR1cm4gcn19KGUpfHxmdW5jdGlvbihlKXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9ZnVuY3Rpb24gZihlKXtyZXR1cm4oZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9dmFyIGk9ZShcIi4vdW5mb3JtYXR0aW5nXCIpLGE9L15bYS16XXsyLDN9KC1bYS16QS1aXXs0fSk/KC0oW0EtWl17Mn18WzAtOV17M30pKT8kLyxwPXtvdXRwdXQ6e3R5cGU6XCJzdHJpbmdcIix2YWxpZFZhbHVlczpbXCJjdXJyZW5jeVwiLFwicGVyY2VudFwiLFwiYnl0ZVwiLFwidGltZVwiLFwib3JkaW5hbFwiLFwibnVtYmVyXCJdfSxiYXNlOnt0eXBlOlwic3RyaW5nXCIsdmFsaWRWYWx1ZXM6W1wiZGVjaW1hbFwiLFwiYmluYXJ5XCIsXCJnZW5lcmFsXCJdLHJlc3RyaWN0aW9uOmZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJieXRlXCI9PT10Lm91dHB1dH0sbWVzc2FnZTpcImBiYXNlYCBtdXN0IGJlIHByb3ZpZGVkIG9ubHkgd2hlbiB0aGUgb3V0cHV0IGlzIGBieXRlYFwiLG1hbmRhdG9yeTpmdW5jdGlvbihlKXtyZXR1cm5cImJ5dGVcIj09PWUub3V0cHV0fX0sY2hhcmFjdGVyaXN0aWM6e3R5cGU6XCJudW1iZXJcIixyZXN0cmljdGlvbjpmdW5jdGlvbihlKXtyZXR1cm4gMDw9ZX0sbWVzc2FnZTpcInZhbHVlIG11c3QgYmUgcG9zaXRpdmVcIn0scHJlZml4Olwic3RyaW5nXCIscG9zdGZpeDpcInN0cmluZ1wiLGZvcmNlQXZlcmFnZTp7dHlwZTpcInN0cmluZ1wiLHZhbGlkVmFsdWVzOltcInRyaWxsaW9uXCIsXCJiaWxsaW9uXCIsXCJtaWxsaW9uXCIsXCJ0aG91c2FuZFwiXX0sYXZlcmFnZTpcImJvb2xlYW5cIixsb3dQcmVjaXNpb246e3R5cGU6XCJib29sZWFuXCIscmVzdHJpY3Rpb246ZnVuY3Rpb24oZSx0KXtyZXR1cm4hMD09PXQuYXZlcmFnZX0sbWVzc2FnZTpcImBsb3dQcmVjaXNpb25gIG11c3QgYmUgcHJvdmlkZWQgb25seSB3aGVuIHRoZSBvcHRpb24gYGF2ZXJhZ2VgIGlzIHNldFwifSxjdXJyZW5jeVBvc2l0aW9uOnt0eXBlOlwic3RyaW5nXCIsdmFsaWRWYWx1ZXM6W1wicHJlZml4XCIsXCJpbmZpeFwiLFwicG9zdGZpeFwiXX0sY3VycmVuY3lTeW1ib2w6XCJzdHJpbmdcIix0b3RhbExlbmd0aDp7dHlwZTpcIm51bWJlclwiLHJlc3RyaWN0aW9uczpbe3Jlc3RyaWN0aW9uOmZ1bmN0aW9uKGUpe3JldHVybiAwPD1lfSxtZXNzYWdlOlwidmFsdWUgbXVzdCBiZSBwb3NpdGl2ZVwifSx7cmVzdHJpY3Rpb246ZnVuY3Rpb24oZSx0KXtyZXR1cm4hdC5leHBvbmVudGlhbH0sbWVzc2FnZTpcImB0b3RhbExlbmd0aGAgaXMgaW5jb21wYXRpYmxlIHdpdGggYGV4cG9uZW50aWFsYFwifV19LG1hbnRpc3NhOnt0eXBlOlwibnVtYmVyXCIscmVzdHJpY3Rpb246ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PWV9LG1lc3NhZ2U6XCJ2YWx1ZSBtdXN0IGJlIHBvc2l0aXZlXCJ9LG9wdGlvbmFsTWFudGlzc2E6XCJib29sZWFuXCIsdHJpbU1hbnRpc3NhOlwiYm9vbGVhblwiLHJvdW5kaW5nRnVuY3Rpb246XCJmdW5jdGlvblwiLG9wdGlvbmFsQ2hhcmFjdGVyaXN0aWM6XCJib29sZWFuXCIsdGhvdXNhbmRTZXBhcmF0ZWQ6XCJib29sZWFuXCIsc3BhY2VTZXBhcmF0ZWQ6XCJib29sZWFuXCIsc3BhY2VTZXBhcmF0ZWRDdXJyZW5jeTpcImJvb2xlYW5cIixzcGFjZVNlcGFyYXRlZEFiYnJldmlhdGlvbjpcImJvb2xlYW5cIixhYmJyZXZpYXRpb25zOnt0eXBlOlwib2JqZWN0XCIsY2hpbGRyZW46e3Rob3VzYW5kOlwic3RyaW5nXCIsbWlsbGlvbjpcInN0cmluZ1wiLGJpbGxpb246XCJzdHJpbmdcIix0cmlsbGlvbjpcInN0cmluZ1wifX0sbmVnYXRpdmU6e3R5cGU6XCJzdHJpbmdcIix2YWxpZFZhbHVlczpbXCJzaWduXCIsXCJwYXJlbnRoZXNpc1wiXX0sZm9yY2VTaWduOlwiYm9vbGVhblwiLGV4cG9uZW50aWFsOnt0eXBlOlwiYm9vbGVhblwifSxwcmVmaXhTeW1ib2w6e3R5cGU6XCJib29sZWFuXCIscmVzdHJpY3Rpb246ZnVuY3Rpb24oZSx0KXtyZXR1cm5cInBlcmNlbnRcIj09PXQub3V0cHV0fSxtZXNzYWdlOlwiYHByZWZpeFN5bWJvbGAgY2FuIGJlIHByb3ZpZGVkIG9ubHkgd2hlbiB0aGUgb3V0cHV0IGlzIGBwZXJjZW50YFwifX0sbz17bGFuZ3VhZ2VUYWc6e3R5cGU6XCJzdHJpbmdcIixtYW5kYXRvcnk6ITAscmVzdHJpY3Rpb246ZnVuY3Rpb24oZSl7cmV0dXJuIGUubWF0Y2goYSl9LG1lc3NhZ2U6XCJ0aGUgbGFuZ3VhZ2UgdGFnIG11c3QgZm9sbG93IHRoZSBCQ1AgNDcgc3BlY2lmaWNhdGlvbiAoc2VlIGh0dHBzOi8vdG9vbHMuaWVmdC5vcmcvaHRtbC9iY3A0NylcIn0sZGVsaW1pdGVyczp7dHlwZTpcIm9iamVjdFwiLGNoaWxkcmVuOnt0aG91c2FuZHM6XCJzdHJpbmdcIixkZWNpbWFsOlwic3RyaW5nXCIsdGhvdXNhbmRzU2l6ZTpcIm51bWJlclwifSxtYW5kYXRvcnk6ITB9LGFiYnJldmlhdGlvbnM6e3R5cGU6XCJvYmplY3RcIixjaGlsZHJlbjp7dGhvdXNhbmQ6e3R5cGU6XCJzdHJpbmdcIixtYW5kYXRvcnk6ITB9LG1pbGxpb246e3R5cGU6XCJzdHJpbmdcIixtYW5kYXRvcnk6ITB9LGJpbGxpb246e3R5cGU6XCJzdHJpbmdcIixtYW5kYXRvcnk6ITB9LHRyaWxsaW9uOnt0eXBlOlwic3RyaW5nXCIsbWFuZGF0b3J5OiEwfX0sbWFuZGF0b3J5OiEwfSxzcGFjZVNlcGFyYXRlZDpcImJvb2xlYW5cIixzcGFjZVNlcGFyYXRlZEN1cnJlbmN5OlwiYm9vbGVhblwiLG9yZGluYWw6e3R5cGU6XCJmdW5jdGlvblwiLG1hbmRhdG9yeTohMH0sYnl0ZXM6e3R5cGU6XCJvYmplY3RcIixjaGlsZHJlbjp7YmluYXJ5U3VmZml4ZXM6XCJvYmplY3RcIixkZWNpbWFsU3VmZml4ZXM6XCJvYmplY3RcIn19LGN1cnJlbmN5Ont0eXBlOlwib2JqZWN0XCIsY2hpbGRyZW46e3N5bWJvbDpcInN0cmluZ1wiLHBvc2l0aW9uOlwic3RyaW5nXCIsY29kZTpcInN0cmluZ1wifSxtYW5kYXRvcnk6ITB9LGRlZmF1bHRzOlwiZm9ybWF0XCIsb3JkaW5hbEZvcm1hdDpcImZvcm1hdFwiLGJ5dGVGb3JtYXQ6XCJmb3JtYXRcIixwZXJjZW50YWdlRm9ybWF0OlwiZm9ybWF0XCIsY3VycmVuY3lGb3JtYXQ6XCJmb3JtYXRcIix0aW1lRGVmYXVsdHM6XCJmb3JtYXRcIixmb3JtYXRzOnt0eXBlOlwib2JqZWN0XCIsY2hpbGRyZW46e2ZvdXJEaWdpdHM6e3R5cGU6XCJmb3JtYXRcIixtYW5kYXRvcnk6ITB9LGZ1bGxXaXRoVHdvRGVjaW1hbHM6e3R5cGU6XCJmb3JtYXRcIixtYW5kYXRvcnk6ITB9LGZ1bGxXaXRoVHdvRGVjaW1hbHNOb0N1cnJlbmN5Ont0eXBlOlwiZm9ybWF0XCIsbWFuZGF0b3J5OiEwfSxmdWxsV2l0aE5vRGVjaW1hbHM6e3R5cGU6XCJmb3JtYXRcIixtYW5kYXRvcnk6ITB9fX19O2Z1bmN0aW9uIHUoZSl7cmV0dXJuIHZvaWQgMCE9PWkudW5mb3JtYXQoZSl9ZnVuY3Rpb24gZyhjLHMsbCxlKXt2YXIgdD0zPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWUmJmUscj1PYmplY3Qua2V5cyhjKS5tYXAoZnVuY3Rpb24oZSl7aWYoIXNbZV0pcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCxcIiBJbnZhbGlkIGtleTogXCIpLmNvbmNhdChlKSksITE7dmFyIHQ9Y1tlXSxyPXNbZV07aWYoXCJzdHJpbmdcIj09dHlwZW9mIHImJihyPXt0eXBlOnJ9KSxcImZvcm1hdFwiPT09ci50eXBlKXtpZighZyh0LHAsXCJbVmFsaWRhdGUgXCIuY29uY2F0KGUsXCJdXCIpLCEwKSlyZXR1cm4hMX1lbHNlIGlmKGYodCkhPT1yLnR5cGUpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCxcIiBcIikuY29uY2F0KGUsJyB0eXBlIG1pc21hdGNoZWQ6IFwiJykuY29uY2F0KHIudHlwZSwnXCIgZXhwZWN0ZWQsIFwiJykuY29uY2F0KGYodCksJ1wiIHByb3ZpZGVkJykpLCExO2lmKHIucmVzdHJpY3Rpb25zJiZyLnJlc3RyaWN0aW9ucy5sZW5ndGgpZm9yKHZhciBuPXIucmVzdHJpY3Rpb25zLmxlbmd0aCxpPTA7aTxuO2krKyl7dmFyIGE9ci5yZXN0cmljdGlvbnNbaV0sbz1hLnJlc3RyaWN0aW9uLHU9YS5tZXNzYWdlO2lmKCFvKHQsYykpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCxcIiBcIikuY29uY2F0KGUsXCIgaW52YWxpZCB2YWx1ZTogXCIpLmNvbmNhdCh1KSksITF9aWYoci5yZXN0cmljdGlvbiYmIXIucmVzdHJpY3Rpb24odCxjKSlyZXR1cm4gY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdChsLFwiIFwiKS5jb25jYXQoZSxcIiBpbnZhbGlkIHZhbHVlOiBcIikuY29uY2F0KHIubWVzc2FnZSkpLCExO2lmKHIudmFsaWRWYWx1ZXMmJi0xPT09ci52YWxpZFZhbHVlcy5pbmRleE9mKHQpKXJldHVybiBjb25zb2xlLmVycm9yKFwiXCIuY29uY2F0KGwsXCIgXCIpLmNvbmNhdChlLFwiIGludmFsaWQgdmFsdWU6IG11c3QgYmUgYW1vbmcgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShyLnZhbGlkVmFsdWVzKSwnLCBcIicpLmNvbmNhdCh0LCdcIiBwcm92aWRlZCcpKSwhMTtpZihyLmNoaWxkcmVuJiYhZyh0LHIuY2hpbGRyZW4sXCJbVmFsaWRhdGUgXCIuY29uY2F0KGUsXCJdXCIpKSlyZXR1cm4hMTtyZXR1cm4hMH0pO3JldHVybiB0fHxyLnB1c2guYXBwbHkocixuKE9iamVjdC5rZXlzKHMpLm1hcChmdW5jdGlvbihlKXt2YXIgdD1zW2VdO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD17dHlwZTp0fSksdC5tYW5kYXRvcnkpe3ZhciByPXQubWFuZGF0b3J5O2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHImJihyPXIoYykpLHImJnZvaWQgMD09PWNbZV0pcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCwnIE1pc3NpbmcgbWFuZGF0b3J5IGtleSBcIicpLmNvbmNhdChlLCdcIicpKSwhMX1yZXR1cm4hMH0pKSksci5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSYmdH0sITApfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGcoZSxwLFwiW1ZhbGlkYXRlIGZvcm1hdF1cIil9dC5leHBvcnRzPXt2YWxpZGF0ZTpmdW5jdGlvbihlLHQpe3ZhciByPXUoZSksbj1jKHQpO3JldHVybiByJiZufSx2YWxpZGF0ZUZvcm1hdDpjLHZhbGlkYXRlSW5wdXQ6dSx2YWxpZGF0ZUxhbmd1YWdlOmZ1bmN0aW9uKGUpe3JldHVybiBnKGUsbyxcIltWYWxpZGF0ZSBsYW5ndWFnZV1cIil9fX0se1wiLi91bmZvcm1hdHRpbmdcIjo5fV19LHt9LFs3XSkoNyl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJyby5taW4uanMubWFwXG4iLCJpbXBvcnQgeyBOdW1lcmljLCBScGNFcnJvciwgSnNvblJwYywgU2VyaWFsaXplLCBLZXksIEFwaSB9IGZyb20gJ0Bwcm90b24vanMnO1xuaW1wb3J0IHsgY29uc3RhbnRzIH0gZnJvbSAnQGJsb2tzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBKc29uUnBjIGFzIEpzb25ScGMkMiB9IGZyb20gJ0Bwcm90b24vaHlwZXJpb24nO1xuaW1wb3J0IHsgSnNvblJwYyBhcyBKc29uUnBjJDEgfSBmcm9tICdAcHJvdG9uL2xpZ2h0LWFwaSc7XG5pbXBvcnQgeyB1cmxCdWlsZGVyLCBuYXRpdmVUcmFuc2Zvcm1HZXRBY3Rpb25zLCBkZnVzZVRyYW5zZm9ybUdldEFjdGlvbnMsIGh5cGVyaW9uVHJhbnNmb3JtR2V0QWN0aW9ucywgZW5jb2RlTmFtZSwgc3RyaW5nX3RvX3VpbnQxMjhfaGFzaCwgaGV4VG9VaW50OEFycmF5LCBoaXN0b3J5VHJhbnNmb3JtVHJhbnNhY3Rpb24sIGhpc3RvcnlUcmFuc2Zvcm1EZWZlcnJlZFRyYW5zYWN0aW9uLCBoeXBlcmlvblRyYW5zZm9ybVRyYW5zYWN0aW9uLCBmaW9LZXlUb0FjdG9yIH0gZnJvbSAnQGJsb2tzL3V0aWxzJztcbmltcG9ydCBmZXRjaCBmcm9tICdjcm9zcy1mZXRjaCc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgZXhjaGFuZ2VSYXRlc1BhcnNlciwgd2l0aGRyYXdhbEZlZVF1b3RlUGFyc2VyIH0gZnJvbSAnQHByb3Rvbi93cmFwLWNvbnN0YW50cyc7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB7IG11bHRpcGx5LCBkaXZpZGUsIGZvcm1hdERhdGUsIHV0Y1RpbWUsIHN0YXJ0RGF0ZSwgdGltZSB9IGZyb20gJ0BibG9rcy9udW1iZXJzJztcblxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHtcbiAgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqL1xuXG4gIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH07XG5cbiAgdmFyIGV4cG9ydHMgPSB7fSxcbiAgICAgIE9wID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LFxuICAgICAgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sXG4gICAgICBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsXG4gICAgICBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsXG4gICAgICB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMFxuICAgIH0pLCBvYmpba2V5XTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcixcbiAgICAgICAgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLFxuICAgICAgICBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuICAgIHJldHVybiBnZW5lcmF0b3IuX2ludm9rZSA9IGZ1bmN0aW9uIChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgICB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgIGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcblxuICAgICAgICBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHtcbiAgICAgICAgICBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZztcbiAgICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7Oykge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG5cbiAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZztcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuICAgICAgICAgIH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgICAgc3RhdGUgPSBcImV4ZWN1dGluZ1wiO1xuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfShpbm5lckZuLCBzZWxmLCBjb250ZXh0KSwgZ2VuZXJhdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgIGFyZzogZm4uY2FsbChvYmosIGFyZylcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRocm93XCIsXG4gICAgICAgIGFyZzogZXJyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpO1xuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuXG4gICAgICBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsdWUgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIHRoaXMuX2ludm9rZSA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG5cbiAgICBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHtcbiAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkpIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcbiAgICBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdHJ5TG9jOiBsb2NzWzBdXG4gICAgfTtcbiAgICAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICB0cnlMb2M6IFwicm9vdFwiXG4gICAgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlO1xuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcblxuICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogITBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpLCBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpO1xuICB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47XG4gIH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fYXdhaXQ6IGFyZ1xuICAgIH07XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpO1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTtcblxuICAgIHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGZvciAoOyBrZXlzLmxlbmd0aDspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDtcbiAgICB9O1xuICB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChza2lwVGVtcFJlc2V0KSB7XG4gICAgICBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZG9uZSA9ICEwO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLFxuICAgICAgICAgICAgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSxcbiAgICAgICAgICAgICAgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWJydXB0OiBmdW5jdGlvbiAodHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpO1xuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIChyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuICAgIGZpbmlzaDogZnVuY3Rpb24gKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhdGNoOiBmdW5jdGlvbiAodHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfSwgZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpdCkgbyA9IGl0O1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRBY2NvdW50KF94KSB7XG4gIHJldHVybiBfZ2V0QWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWNjb3VudCgpIHtcbiAgX2dldEFjY291bnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYWNjb3VudE5hbWUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGFjY291bnQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfYWNjb3VudChhY2NvdW50TmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBhY2NvdW50ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGFjY291bnQucGVybWlzc2lvbnMgPSBhY2NvdW50LnBlcm1pc3Npb25zLm1hcChmdW5jdGlvbiAocGVybWlzc2lvbikge1xuICAgICAgICAgICAgICBwZXJtaXNzaW9uLnJlcXVpcmVkX2F1dGgua2V5cyA9IHBlcm1pc3Npb24ucmVxdWlyZWRfYXV0aC5rZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5rZXkuaW5kZXhPZihfdGhpcy5jb25zdGFudHMuS0VZX1BSRUZJWCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBrZXkua2V5ID0gTnVtZXJpYy5jb252ZXJ0TGVnYWN5UHVibGljS2V5KGtleS5rZXksIF90aGlzLmNvbnN0YW50cy5LRVlfUFJFRklYKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBlcm1pc3Npb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYWNjb3VudCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2VhcmNoQWNjb3VudChfeDIsIF94Mykge1xuICByZXR1cm4gX3NlYXJjaEFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3NlYXJjaEFjY291bnQoKSB7XG4gIF9zZWFyY2hBY2NvdW50ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihxdWVyeSwgbGltaXQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKCFxdWVyeSB8fCAhLyheW2EtekEtWjEyMzQ1Ll0rJCkvLnRlc3QocXVlcnkpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoIShxdWVyeS5pbmRleE9mKCcuJykgPT09IDApKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gNDtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX2J5X3Njb3BlKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IHF1ZXJ5LFxuICAgICAgICAgICAgICB0YWJsZTogJ3VzZXJyZXMnLFxuICAgICAgICAgICAgICB1cHBlcl9ib3VuZDogXCJcIiArIHF1ZXJ5ICsgKHF1ZXJ5Lmxlbmd0aCA8IDEyID8gJ3onLnJlcGVhdCgxMiAtIHF1ZXJ5Lmxlbmd0aCkgOiAnJylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90LnJvd3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuc2NvcGU7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMztcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQyLnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1s0LCAxM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX3NlYXJjaEFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0R3JhdmF0YXIoX3g0KSB7XG4gIHJldHVybiBfZ2V0R3JhdmF0YXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEdyYXZhdGFyKCkge1xuICBfZ2V0R3JhdmF0YXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGFjY291bnQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh0aGlzLmNvbnN0YW50cy5DSEFJTiA9PT0gJ2VvcycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkFDQ09VTlRfSU5GTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkFDQ09VTlRfSU5GTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdhY2NvdW50cycsXG4gICAgICAgICAgICAgIHRhYmxlX2tleTogJycsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnbmFtZScsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBhY2NvdW50LFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogMSxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCByZXN1bHQucm93cy5sZW5ndGggPiAwICYmIHJlc3VsdC5yb3dzWzBdLmFjY291bnRfbmFtZSA9PT0gYWNjb3VudCA/IHJlc3VsdC5yb3dzWzBdIDogdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRHcmF2YXRhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnQoX3g1KSB7XG4gIHJldHVybiBfZ2V0UGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQYXJlbnQoKSB7XG4gIF9nZXRQYXJlbnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGFjY291bnQpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTLmluY2x1ZGVzKCdoeXBlcmlvbicpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdGFudHMuSFlQRVJJT05fVVJMKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuaHlwZXJpb24uZ2V0X2NyZWF0b3IoYWNjb3VudCkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5nZXQodXJsQnVpbGRlcih0aGlzLmNvbnN0YW50cy5BUElfVVJMLCAnaHlwZXJpb24nLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdnZXRfY3JlYXRvcicsXG4gICAgICAgICAgICAgIGFjY291bnQ6IGFjY291bnRcbiAgICAgICAgICAgIH0pKSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjY291bnRMaWdodERhdGEoX3g2KSB7XG4gIHJldHVybiBfZ2V0QWNjb3VudExpZ2h0RGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWNjb3VudExpZ2h0RGF0YSgpIHtcbiAgX2dldEFjY291bnRMaWdodERhdGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGFjY291bnROYW1lKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICh0aGlzLmxpZ2h0QXBpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDI7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saWdodEFwaS5nZXRfYWNjb3VudF9pbmZvKGFjY291bnROYW1lKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NS5zZW50KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ1LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMiwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjY291bnRMaWdodERhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uc0Zyb21OYXRpdmUoX3gsIF94MiwgX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9nZXRBY3Rpb25zRnJvbU5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWN0aW9uc0Zyb21OYXRpdmUoKSB7XG4gIF9nZXRBY3Rpb25zRnJvbU5hdGl2ZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhY2NvdW50TmFtZSwgYWN0aW9uU2tpcCwgYWN0aW9uc1BlclBhZ2UsIGhpc3RvcnlUeXBlKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoaGlzdG9yeVR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBoaXN0b3J5VHlwZSA9ICduYXRpdmUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgYWN0aW9ucyBmcm9tOicsIGhpc3RvcnlUeXBlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaCBQYXJhbXM6JywgJ2FjdGlvblNraXAnLCBhY3Rpb25Ta2lwLCAnYWN0aW9uc1BlclBhZ2UnLCBhY3Rpb25zUGVyUGFnZSk7IC8vIFJlcXVlc3RcblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zUnBjLmhpc3RvcnlfZ2V0X2FjdGlvbnMoYWNjb3VudE5hbWUsIGFjdGlvblNraXAsIGFjdGlvbnNQZXJQYWdlKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZXRyaWV2ZSBhY3Rpb25zJyk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBpZiAoIShoaXN0b3J5VHlwZSA9PT0gJ25hdGl2ZScpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlVHJhbnNmb3JtR2V0QWN0aW9ucyhyZXN1bHQsIHRoaXMuY29uc3RhbnRzKSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjdGlvbnNGcm9tTmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvbnMoX3g1LCBfeDYsIF94Nykge1xuICByZXR1cm4gX2dldEFjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjdGlvbnMoKSB7XG4gIF9nZXRBY3Rpb25zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhY2NvdW50TmFtZSwgaGlzdG9yeVR5cGUsIF90ZW1wKSB7XG4gICAgdmFyIF9yZWYsIF9yZWYkYWN0aW9uc1BlclBhZ2UsIGFjdGlvbnNQZXJQYWdlLCBfcmVmJGFjdGlvblNraXAsIGFjdGlvblNraXAsIF9yZWYkc29ydERpcmVjdGlvbiwgc29ydERpcmVjdGlvbiwgX3JlZiRkZnVzZUN1cnNvclN0YWNrLCBkZnVzZUN1cnNvclN0YWNrLCB0b2tlbkZpbHRlciwgYWN0aW9uRmlsdGVycywgY29udHJhY3RGaWx0ZXIsIGFjdGlvbkZpbHRlciwgc3RhcnQsIGVuZCwgcmVzdWx0LCBpbnB1dEN1cnNvcjtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsIF9yZWYkYWN0aW9uc1BlclBhZ2UgPSBfcmVmLmFjdGlvbnNQZXJQYWdlLCBhY3Rpb25zUGVyUGFnZSA9IF9yZWYkYWN0aW9uc1BlclBhZ2UgPT09IHZvaWQgMCA/IDEwMCA6IF9yZWYkYWN0aW9uc1BlclBhZ2UsIF9yZWYkYWN0aW9uU2tpcCA9IF9yZWYuYWN0aW9uU2tpcCwgYWN0aW9uU2tpcCA9IF9yZWYkYWN0aW9uU2tpcCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkYWN0aW9uU2tpcCwgX3JlZiRzb3J0RGlyZWN0aW9uID0gX3JlZi5zb3J0RGlyZWN0aW9uLCBzb3J0RGlyZWN0aW9uID0gX3JlZiRzb3J0RGlyZWN0aW9uID09PSB2b2lkIDAgPyAnZGVzYycgOiBfcmVmJHNvcnREaXJlY3Rpb24sIF9yZWYkZGZ1c2VDdXJzb3JTdGFjayA9IF9yZWYuZGZ1c2VDdXJzb3JTdGFjaywgZGZ1c2VDdXJzb3JTdGFjayA9IF9yZWYkZGZ1c2VDdXJzb3JTdGFjayA9PT0gdm9pZCAwID8gW10gOiBfcmVmJGRmdXNlQ3Vyc29yU3RhY2ssIHRva2VuRmlsdGVyID0gX3JlZi50b2tlbkZpbHRlciwgYWN0aW9uRmlsdGVycyA9IF9yZWYuYWN0aW9uRmlsdGVycywgY29udHJhY3RGaWx0ZXIgPSBfcmVmLmNvbnRyYWN0RmlsdGVyLCBhY3Rpb25GaWx0ZXIgPSBfcmVmLmFjdGlvbkZpbHRlciwgc3RhcnQgPSBfcmVmLnN0YXJ0LCBlbmQgPSBfcmVmLmVuZDtcblxuICAgICAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuY29uc3RhbnRzLkNIQUlOX1NUQVJUX0RBVEU7XG4gICAgICAgICAgICB9IC8vIEZhbGxiYWNrIGZvciBoaXN0b3J5IHR5cGVcblxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTKTtcblxuICAgICAgICAgICAgaWYgKCFoaXN0b3J5VHlwZSAmJiB0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTLmxlbmd0aCkge1xuICAgICAgICAgICAgICBoaXN0b3J5VHlwZSA9IHRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVNbMF07XG4gICAgICAgICAgICB9IC8vIEZpeCBmb3IgZmlyZWZveCBhbmQgSUUgYW5kIHNhZmFyaVxuXG5cbiAgICAgICAgICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydCB8fCB0aGlzLmNvbnN0YW50cy5DSEFJTl9TVEFSVF9EQVRFID8gbmV3IERhdGUoc3RhcnQgfHwgdGhpcy5jb25zdGFudHMuQ0hBSU5fU1RBUlRfREFURSkudG9JU09TdHJpbmcoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoZW5kIHx8IG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgZW5kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShoaXN0b3J5VHlwZSA9PT0gJ2RmdXNlJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlucHV0Q3Vyc29yID0gZGZ1c2VDdXJzb3JTdGFjay5sZW5ndGggPiAwID8gZGZ1c2VDdXJzb3JTdGFja1tkZnVzZUN1cnNvclN0YWNrLmxlbmd0aCAtIDFdIDogJyc7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3Rpb25zRnJvbURmdXNlKGFjY291bnROYW1lLCB7XG4gICAgICAgICAgICAgIGxpbWl0OiBhY3Rpb25zUGVyUGFnZSxcbiAgICAgICAgICAgICAgY3Vyc29yOiBpbnB1dEN1cnNvcixcbiAgICAgICAgICAgICAgZGlyZWN0aW9uOiBzb3J0RGlyZWN0aW9uLFxuICAgICAgICAgICAgICBxdWVyeTogJycsXG4gICAgICAgICAgICAgIGFmdGVyOiBzdGFydCxcbiAgICAgICAgICAgICAgYmVmb3JlOiBlbmQsXG4gICAgICAgICAgICAgIHRva2VuRmlsdGVyOiB0b2tlbkZpbHRlcixcbiAgICAgICAgICAgICAgYWN0aW9uRmlsdGVyczogYWN0aW9uRmlsdGVycyxcbiAgICAgICAgICAgICAgY29udHJhY3RGaWx0ZXI6IGNvbnRyYWN0RmlsdGVyLFxuICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXI6IGFjdGlvbkZpbHRlclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBpZiAoIShoaXN0b3J5VHlwZSA9PT0gJ2h5cGVyaW9uJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3Rpb25zRnJvbUh5cGVyaW9uKGFjY291bnROYW1lLCB7XG4gICAgICAgICAgICAgIHNraXA6IE1hdGguYWJzKGFjdGlvblNraXApIC0gMSxcbiAgICAgICAgICAgICAgbGltaXQ6IGFjdGlvbnNQZXJQYWdlLFxuICAgICAgICAgICAgICBzb3J0OiBzb3J0RGlyZWN0aW9uLFxuICAgICAgICAgICAgICBhZnRlcjogc3RhcnQsXG4gICAgICAgICAgICAgIGJlZm9yZTogZW5kLFxuICAgICAgICAgICAgICB0b2tlbkZpbHRlcjogdG9rZW5GaWx0ZXIsXG4gICAgICAgICAgICAgIGFjdGlvbkZpbHRlcnM6IGFjdGlvbkZpbHRlcnMsXG4gICAgICAgICAgICAgIGNvbnRyYWN0RmlsdGVyOiBjb250cmFjdEZpbHRlcixcbiAgICAgICAgICAgICAgYWN0aW9uRmlsdGVyOiBhY3Rpb25GaWx0ZXJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3Rpb25zRnJvbU5hdGl2ZShhY2NvdW50TmFtZSwgYWN0aW9uU2tpcCwgLWFjdGlvbnNQZXJQYWdlLCAnbmF0aXZlJyk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY3Rpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvbnNGcm9tRGZ1c2UoX3g4LCBfeDkpIHtcbiAgcmV0dXJuIF9nZXRBY3Rpb25zRnJvbURmdXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBY3Rpb25zRnJvbURmdXNlKCkge1xuICBfZ2V0QWN0aW9uc0Zyb21EZnVzZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYWNjb3VudE5hbWUsIF90ZW1wMikge1xuICAgIHZhciBfcmVmMiwgYmVmb3JlLCBhZnRlciwgX3JlZjIkbGltaXQsIGxpbWl0LCBjdXJzb3IsIHF1ZXJ5LCBfcmVmMiRkaXJlY3Rpb24sIGRpcmVjdGlvbiwgdG9rZW5GaWx0ZXIsIGFjdGlvbkZpbHRlcnMsIGNvbnRyYWN0RmlsdGVyLCBhY3Rpb25GaWx0ZXIsIF9yZWYyJHR5cGUsIHR5cGUsIHEsIF90b2tlbkZpbHRlciRzcGxpdCwgdG9rZW5Db250cmFjdCwgdG9rZW5maWx0ZXIsIGFjdGlvbkZpbHRlcnNMb2NhbCwgYWN0aW9uRmlsdGVyc1F1ZXJ5LCByZXN1bHQ7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX3JlZjIgPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyLCBiZWZvcmUgPSBfcmVmMi5iZWZvcmUsIGFmdGVyID0gX3JlZjIuYWZ0ZXIsIF9yZWYyJGxpbWl0ID0gX3JlZjIubGltaXQsIGxpbWl0ID0gX3JlZjIkbGltaXQgPT09IHZvaWQgMCA/IDI1IDogX3JlZjIkbGltaXQsIGN1cnNvciA9IF9yZWYyLmN1cnNvciwgcXVlcnkgPSBfcmVmMi5xdWVyeSwgX3JlZjIkZGlyZWN0aW9uID0gX3JlZjIuZGlyZWN0aW9uLCBkaXJlY3Rpb24gPSBfcmVmMiRkaXJlY3Rpb24gPT09IHZvaWQgMCA/ICdkZXNjJyA6IF9yZWYyJGRpcmVjdGlvbiwgdG9rZW5GaWx0ZXIgPSBfcmVmMi50b2tlbkZpbHRlciwgYWN0aW9uRmlsdGVycyA9IF9yZWYyLmFjdGlvbkZpbHRlcnMsIGNvbnRyYWN0RmlsdGVyID0gX3JlZjIuY29udHJhY3RGaWx0ZXIsIGFjdGlvbkZpbHRlciA9IF9yZWYyLmFjdGlvbkZpbHRlciwgX3JlZjIkdHlwZSA9IF9yZWYyLnR5cGUsIHR5cGUgPSBfcmVmMiR0eXBlID09PSB2b2lkIDAgPyAnc2VhcmNoX3RyYW5zYWN0aW9uc19ncmFwaHFsJyA6IF9yZWYyJHR5cGU7XG4gICAgICAgICAgICBxID0gcXVlcnkgfHwgXCIoYXV0aDpcIiArIGFjY291bnROYW1lICsgXCIgT1JcXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyOlwiICsgYWNjb3VudE5hbWUgKyBcIiBPUlxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50bzpcIiArIGFjY291bnROYW1lICsgXCIgT1JcXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZnJvbTpcIiArIGFjY291bnROYW1lICsgXCIgT1JcXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucmVjZWl2ZXI6XCIgKyBhY2NvdW50TmFtZSArIFwiKVwiO1xuXG4gICAgICAgICAgICBpZiAodG9rZW5GaWx0ZXIpIHtcbiAgICAgICAgICAgICAgX3Rva2VuRmlsdGVyJHNwbGl0ID0gdG9rZW5GaWx0ZXIuc3BsaXQoJyAnKSwgdG9rZW5Db250cmFjdCA9IF90b2tlbkZpbHRlciRzcGxpdFsxXTtcbiAgICAgICAgICAgICAgdG9rZW5maWx0ZXIgPSBcImFjY291bnQ6XCIgKyB0b2tlbkNvbnRyYWN0O1xuICAgICAgICAgICAgICBxID0gcSArIFwiIFwiICsgdG9rZW5maWx0ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhY3Rpb25GaWx0ZXJzKSB7XG4gICAgICAgICAgICAgIGFjdGlvbkZpbHRlcnNMb2NhbCA9IE9iamVjdC5lbnRyaWVzKGFjdGlvbkZpbHRlcnMpLnJlZHVjZShmdW5jdGlvbiAoZmlsdGVycywgX3JlZjQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmNFsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaXNBY3RpdmUgPyBmaWx0ZXJzLmNvbmNhdCh2YWx1ZSkgOiBmaWx0ZXJzO1xuICAgICAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGlvbkZpbHRlcnNMb2NhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXJzUXVlcnkgPSBhY3Rpb25GaWx0ZXJzTG9jYWwubWFwKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIuZGZ1c2VRdWVyeShhY2NvdW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfSkuam9pbignIE9SICcpOyAvLyBXcmFwIGFyb3VuZCB0aGUgYWN0aW9uIGZpbHRlcnNcblxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25GaWx0ZXJzUXVlcnkuc2VhcmNoKCdPUicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uRmlsdGVyc1F1ZXJ5ID0gXCIoXCIgKyBhY3Rpb25GaWx0ZXJzUXVlcnkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICB9IC8vIFNldCB0aGUgYWN0aW9uIGZpbHRlcnNcblxuXG4gICAgICAgICAgICAgICAgcSA9IHEgKyBcIiBcIiArIGFjdGlvbkZpbHRlcnNRdWVyeTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb250cmFjdEZpbHRlcikge1xuICAgICAgICAgICAgICAgIHEgPSBxICsgXCIgYWNjb3VudDpcIiArIGNvbnRyYWN0RmlsdGVyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGlvbkZpbHRlcikge1xuICAgICAgICAgICAgICAgIHEgPSBxICsgXCIgYWN0aW9uOlwiICsgYWN0aW9uRmlsdGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmxCdWlsZGVyKHRoaXMuY29uc3RhbnRzLkFQSV9VUkwsICdkZnVzZScsIHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgcTogcSxcbiAgICAgICAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgIHNvcnQ6IGRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBjdXJzb3I6IGN1cnNvcixcbiAgICAgICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICAgICAgd2l0aFJldmVyc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmUsXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyLFxuICAgICAgICAgICAgICAgIGNvZGU6IDFcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJldHJpZXZlIGFjdGlvbnMnKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIGRmdXNlVHJhbnNmb3JtR2V0QWN0aW9ucyhyZXN1bHQsIGFjY291bnROYW1lLCB0aGlzLmNvbnN0YW50cykpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjdGlvbnNGcm9tRGZ1c2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uc0Zyb21IeXBlcmlvbihfeDEwLCBfeDExKSB7XG4gIHJldHVybiBfZ2V0QWN0aW9uc0Zyb21IeXBlcmlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWN0aW9uc0Zyb21IeXBlcmlvbigpIHtcbiAgX2dldEFjdGlvbnNGcm9tSHlwZXJpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGFjY291bnQsIF90ZW1wMykge1xuICAgIHZhciBfcmVmMywgc2tpcCwgbGltaXQsIHNvcnQsIGFmdGVyLCBiZWZvcmUsIGZpbHRlciwgdG9rZW5GaWx0ZXIsIGFjdGlvbkZpbHRlcnMsIGNvbnRyYWN0RmlsdGVyLCBhY3Rpb25GaWx0ZXIsIHBhcmFtcywgcmVzdWx0LCBfdG9rZW5GaWx0ZXIkc3BsaXQyLCB0b2tlbkNvbnRyYWN0LCBhY3Rpb25GaWx0ZXJzTG9jYWwsIF9pdGVyYXRvciwgX3N0ZXAsIGVhY2hGaWx0ZXIsIHVuaXF1ZUNvbnRyYWN0cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmMyA9IF90ZW1wMyA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDMsIHNraXAgPSBfcmVmMy5za2lwLCBsaW1pdCA9IF9yZWYzLmxpbWl0LCBzb3J0ID0gX3JlZjMuc29ydCwgYWZ0ZXIgPSBfcmVmMy5hZnRlciwgYmVmb3JlID0gX3JlZjMuYmVmb3JlLCBmaWx0ZXIgPSBfcmVmMy5maWx0ZXIsIHRva2VuRmlsdGVyID0gX3JlZjMudG9rZW5GaWx0ZXIsIGFjdGlvbkZpbHRlcnMgPSBfcmVmMy5hY3Rpb25GaWx0ZXJzLCBjb250cmFjdEZpbHRlciA9IF9yZWYzLmNvbnRyYWN0RmlsdGVyLCBhY3Rpb25GaWx0ZXIgPSBfcmVmMy5hY3Rpb25GaWx0ZXI7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplXG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICBza2lwOiBza2lwLFxuICAgICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICAgIGFmdGVyOiBhZnRlcixcbiAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgYWN0aW9ucyBmcm9tIEh5cGVyaW9uJyk7XG5cbiAgICAgICAgICAgIC8vIFRva2VuIGZpbHRlciwgd2Ugd291bGQgb25seSByZWNlaXZlIHVuZGVmaW5lZCBvciAqOmFjdGlvblxuICAgICAgICAgICAgaWYgKHRva2VuRmlsdGVyKSB7XG4gICAgICAgICAgICAgIF90b2tlbkZpbHRlciRzcGxpdDIgPSB0b2tlbkZpbHRlci5zcGxpdCgnICcpLCB0b2tlbkNvbnRyYWN0ID0gX3Rva2VuRmlsdGVyJHNwbGl0MlsxXTtcblxuICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIgPSBwYXJhbXMuZmlsdGVyLnJlcGxhY2UoJyonLCB0b2tlbkNvbnRyYWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyID0gdG9rZW5Db250cmFjdCArIFwiOipcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWN0aW9uRmlsdGVycykge1xuICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXJzTG9jYWwgPSBPYmplY3QuZW50cmllcyhhY3Rpb25GaWx0ZXJzKS5yZWR1Y2UoZnVuY3Rpb24gKGZpbHRlcnMsIF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjVbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmlzQWN0aXZlID8gZmlsdGVycy5jb25jYXQodmFsdWUpIDogZmlsdGVycztcbiAgICAgICAgICAgICAgfSwgW10pO1xuXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25GaWx0ZXJzTG9jYWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjdGlvbkZpbHRlcnNMb2NhbCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgIGVhY2hGaWx0ZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGVhY2hGaWx0ZXIuaHlwZXJpb25RdWVyeShhY2NvdW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBhcmFtcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gQWN0aW9ucyBjb250cmFjdCBmaWx0ZXJzXG5cblxuICAgICAgICAgICAgaWYgKGNvbnRyYWN0RmlsdGVyKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZpbHRlciA9IHBhcmFtcy5maWx0ZXIuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0RmlsdGVyICsgXCI6XCIgKyBmaWx0ZXIuc3BsaXQoJzonKVsxXTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcsJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZpbHRlciA9IGNvbnRyYWN0RmlsdGVyICsgXCI6KlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhY3Rpb25GaWx0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB1bmlxdWVDb250cmFjdHMgPSBBcnJheS5mcm9tKG5ldyBTZXQocGFyYW1zLmZpbHRlci5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyLnNwbGl0KCc6JylbMF07XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyID0gdW5pcXVlQ29udHJhY3RzLm1hcChmdW5jdGlvbiAoY29udHJhY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdCArIFwiOlwiICsgYWN0aW9uRmlsdGVyO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyID0gXCIqOlwiICsgYWN0aW9uRmlsdGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIElmIGh5cGVyaW9uIFVSTCBwcm92aWRlZCwgZG8gaXQgY2xpZW50IHNpZGVcblxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLkhZUEVSSU9OX1VSTCkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uLmdldF9hY3Rpb25zKGFjY291bnQsIE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcykpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsQnVpbGRlcih0aGlzLmNvbnN0YW50cy5BUElfVVJMLCAnaHlwZXJpb24nLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdnZXRfYWN0aW9ucycsXG4gICAgICAgICAgICAgIGFjY291bnQ6IGFjY291bnQsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcylcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDQuc2VudDtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZXRyaWV2ZSBhY3Rpb25zJyk7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgaHlwZXJpb25UcmFuc2Zvcm1HZXRBY3Rpb25zKHJlc3VsdCkpO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFjdGlvbnNGcm9tSHlwZXJpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGFwcFN0YXRzKCkge1xuICByZXR1cm4gX2dldERhcHBTdGF0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RGFwcFN0YXRzKCkge1xuICBfZ2V0RGFwcFN0YXRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdkYXBwc2VydmljZXMnLFxuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgc2NvcGU6ICcuLi4uLi4ya2UxLm80JyxcbiAgICAgICAgICAgICAgdGFibGU6ICdzdGF0ZXh0J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoISghcmVzdWx0IHx8ICFyZXN1bHQucm93cyB8fCAhcmVzdWx0LnJvd3MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge30pO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXN1bHQucm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTE7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHt9KTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgMTFdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREYXBwU3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RHNwUGFja2FnZXMoKSB7XG4gIHJldHVybiBfZ2V0RHNwUGFja2FnZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERzcFBhY2thZ2VzKCkge1xuICBfZ2V0RHNwUGFja2FnZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdkYXBwc2VydmljZXMnLFxuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogNTAwLFxuICAgICAgICAgICAgICBzY29wZTogJ2RhcHBzZXJ2aWNlcycsXG4gICAgICAgICAgICAgIHRhYmxlOiAncGFja2FnZSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXN1bHQgJiYgcmVzdWx0LnJvd3MgJiYgcmVzdWx0LnJvd3MubGVuZ3RoID8gcmVzdWx0LnJvd3MgOiBbXSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDc7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbMCwgN11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERzcFBhY2thZ2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERhcHBob2RsQmFsYW5jZShfeCkge1xuICByZXR1cm4gX2dldERhcHBob2RsQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RGFwcGhvZGxCYWxhbmNlKCkge1xuICBfZ2V0RGFwcGhvZGxCYWxhbmNlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhY2NvdW50KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2RhcHBhaXJob2RsMScsXG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICBzY29wZTogYWNjb3VudCxcbiAgICAgICAgICAgICAgdGFibGU6ICdhY2NvdW50cydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCByZXN1bHQgJiYgcmVzdWx0LnJvd3MgJiYgcmVzdWx0LnJvd3MubGVuZ3RoID8gcmVzdWx0LnJvd3NbMF0gOiB7fSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDc7XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHt9KTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCA3XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RGFwcGhvZGxCYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERhcHBCYWxhbmNlKF94Mikge1xuICByZXR1cm4gX2dldERhcHBCYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREYXBwQmFsYW5jZSgpIHtcbiAgX2dldERhcHBCYWxhbmNlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhY2NvdW50KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2RhcHBzZXJ2aWNlcycsXG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICBzY29wZTogYWNjb3VudCxcbiAgICAgICAgICAgICAgdGFibGU6ICdhY2NvdW50cydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByZXN1bHQgJiYgcmVzdWx0LnJvd3MgJiYgcmVzdWx0LnJvd3MubGVuZ3RoID8gcmVzdWx0LnJvd3NbMF0gOiB7fSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDc7XG4gICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHt9KTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1swLCA3XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RGFwcEJhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGFwcFN0YWtlcyhfeDMpIHtcbiAgcmV0dXJuIF9nZXREYXBwU3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREYXBwU3Rha2VzKCkge1xuICBfZ2V0RGFwcFN0YWtlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoYWNjb3VudCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdkYXBwc2VydmljZXMnLFxuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICAgICAgICBzY29wZTogYWNjb3VudCxcbiAgICAgICAgICAgICAgdGFibGU6ICdzdGFraW5nJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCAmJiByZXN1bHQucm93cyAmJiByZXN1bHQucm93cy5sZW5ndGggPyByZXN1bHQucm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByb3cuc2NvcGUgPSBhY2NvdW50O1xuICAgICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICAgICAgfSkgOiBbXSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDc7XG4gICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1swLCA3XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RGFwcFN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREYXBwaG9kbFN0YWtlcyhfeDQsIF94NSkge1xuICByZXR1cm4gX2dldERhcHBob2RsU3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREYXBwaG9kbFN0YWtlcygpIHtcbiAgX2dldERhcHBob2RsU3Rha2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihhY2NvdW50LCBsb3dlcl9ib3VuZCkge1xuICAgIHZhciByZXN1bHQsIHJvd3M7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChsb3dlcl9ib3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdkYXBwc2VydmljZXMnLFxuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwMCxcbiAgICAgICAgICAgICAgc2NvcGU6ICdkYXBwYWlyaG9kbDEnLFxuICAgICAgICAgICAgICB0YWJsZTogJ3N0YWtpbmcnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogbG93ZXJfYm91bmRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ2LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcm93cyA9IHJlc3VsdC5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5tb3JlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSByb3dzO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhcHBob2RsU3Rha2VzKGFjY291bnQsICtyb3dzW3Jvd3MubGVuZ3RoIC0gMV0uaWQgKyAxKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDYudDEgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfY29udGV4dDYudDAuY29uY2F0LmNhbGwoX2NvbnRleHQ2LnQwLCBfY29udGV4dDYudDEpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5hY2NvdW50ID09PSBhY2NvdW50O1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcm93LnNjb3BlID0gJ2RhcHBhaXJob2RsMSc7XG4gICAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxNztcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MiA9IF9jb250ZXh0NltcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzEsIDE3XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RGFwcGhvZGxTdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGFwcFVuc3Rha2VzKF94Nikge1xuICByZXR1cm4gX2dldERhcHBVbnN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RGFwcFVuc3Rha2VzKCkge1xuICBfZ2V0RGFwcFVuc3Rha2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhhY2NvdW50KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2RhcHBzZXJ2aWNlcycsXG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDAsXG4gICAgICAgICAgICAgIHNjb3BlOiBhY2NvdW50LFxuICAgICAgICAgICAgICB0YWJsZTogJ3JlZnVuZHMnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0ICYmIHJlc3VsdC5yb3dzICYmIHJlc3VsdC5yb3dzLmxlbmd0aCA/IHJlc3VsdC5yb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJvdy5zY29wZSA9IGFjY291bnQ7XG4gICAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgICAgICB9KSA6IFtdKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gNztcbiAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU3LCB0aGlzLCBbWzAsIDddXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREYXBwVW5zdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGFwcGhvZGxVbnN0YWtlcyhfeDcpIHtcbiAgcmV0dXJuIF9nZXREYXBwaG9kbFVuc3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXREYXBwaG9kbFVuc3Rha2VzKCkge1xuICBfZ2V0RGFwcGhvZGxVbnN0YWtlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgoYWNjb3VudCkge1xuICAgIHZhciByZXN1bHQsIHJvd3M7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdkYXBwc2VydmljZXMnLFxuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwMCxcbiAgICAgICAgICAgICAgc2NvcGU6ICdkYXBwYWlyaG9kbDEnLFxuICAgICAgICAgICAgICB0YWJsZTogJ3JlZnVuZHMnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0OC5zZW50O1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJvd3MgPSByZXN1bHQucm93cztcblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQubW9yZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDEzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ4LnQwID0gcm93cztcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXBwaG9kbFVuc3Rha2VzKGFjY291bnQpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0OC50MSA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF9jb250ZXh0OC50MC5jb25jYXQuY2FsbChfY29udGV4dDgudDAsIF9jb250ZXh0OC50MSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gcm93LmFjY291bnQgPT09IGFjY291bnQ7XG4gICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByb3cuc2NvcGUgPSAnZGFwcGFpcmhvZGwxJztcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDE2O1xuICAgICAgICAgICAgX2NvbnRleHQ4LnQyID0gX2NvbnRleHQ4W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTgsIHRoaXMsIFtbMCwgMTZdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXREYXBwaG9kbFVuc3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBodHRwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYyID0gLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShfcmVmKSB7XG4gICAgdmFyIHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycywgZGF0YSwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcGF0aCA9IF9yZWYucGF0aCwgbWV0aG9kID0gX3JlZi5tZXRob2QsIGJvZHkgPSBfcmVmLmJvZHksIGhlYWRlcnMgPSBfcmVmLmhlYWRlcnM7XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHBhdGgsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMgfHwge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMDtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IFJwY0Vycm9yKGRhdGEgfHwgJ0Vycm9yJyk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMTBdXSk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gaHR0cChfeCkge1xuICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xudmFyIGdldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmMyA9IC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHBhdGgsIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGh0dHAoe1xuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBnZXQoX3gyLCBfeDMpIHtcbiAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcbnZhciBwb3N0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWY0ID0gLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMocGF0aCwgYm9keSkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gaHR0cCh7XG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDMuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcG9zdChfeDQsIF94NSkge1xuICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBnZXRGSU9Wb3RlcihfeCkge1xuICByZXR1cm4gX2dldEZJT1ZvdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRGSU9Wb3RlcigpIHtcbiAgX2dldEZJT1ZvdGVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB0YWJsZTogJ3ZvdGVycycsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDMsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90LnJvd3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MubGVuZ3RoID8gcm93c1swXSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEZJT1ZvdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEZJT0FkZHJlc3NCeU5hbWUoX3gyKSB7XG4gIHJldHVybiBfZ2V0RklPQWRkcmVzc0J5TmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RklPQWRkcmVzc0J5TmFtZSgpIHtcbiAgX2dldEZJT0FkZHJlc3NCeU5hbWUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKG5hbWUpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Miwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSB0aGlzLnJwYztcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdfdG9fdWludDEyOF9oYXNoKG5hbWUpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX2NvbnRleHQyLnQxID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDIudDIgPSAnMHgnICsgX2NvbnRleHQyLnQxO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQzID0ge1xuICAgICAgICAgICAgICBjb2RlOiAnZmlvLmFkZHJlc3MnLFxuICAgICAgICAgICAgICBzY29wZTogJ2Zpby5hZGRyZXNzJyxcbiAgICAgICAgICAgICAgdGFibGU6ICdmaW9uYW1lcycsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBfY29udGV4dDIudDIsXG4gICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2kxMjgnLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogNVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIudDAuZ2V0X3RhYmxlX3Jvd3MuY2FsbChfY29udGV4dDIudDAsIF9jb250ZXh0Mi50Myk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QyID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Mi5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoICYmIHJvd3NbMF0ubmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTg7XG4gICAgICAgICAgICBfY29udGV4dDIudDQgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Mi50NCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDE4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RklPQWRkcmVzc0J5TmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRORlRzQnlGaW9BZGRyZXNzKF94Mykge1xuICByZXR1cm4gX2dldE5GVHNCeUZpb0FkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldE5GVHNCeUZpb0FkZHJlc3MoKSB7XG4gIF9nZXRORlRzQnlGaW9BZGRyZXNzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhuYW1lKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfbiwgbmZ0cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X25mdHNfZmlvX2FkZHJlc3MobmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X24gPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIG5mdHMgPSBfeWllbGQkdGhpcyRycGMkZ2V0X24ubmZ0cztcblxuICAgICAgICAgICAgaWYgKCEobmZ0cyAmJiBuZnRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgbmZ0cyk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTI7XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0My50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMCwgMTJdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRORlRzQnlGaW9BZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEZJT0RvbWFpbkJ5TmFtZShfeDQpIHtcbiAgcmV0dXJuIF9nZXRGSU9Eb21haW5CeU5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEZJT0RvbWFpbkJ5TmFtZSgpIHtcbiAgX2dldEZJT0RvbWFpbkJ5TmFtZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQobmFtZSkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QzLCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IHRoaXMucnBjO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ190b191aW50MTI4X2hhc2gobmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfY29udGV4dDQudDEgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0NC50MiA9ICcweCcgKyBfY29udGV4dDQudDE7XG4gICAgICAgICAgICBfY29udGV4dDQudDMgPSB7XG4gICAgICAgICAgICAgIGNvZGU6ICdmaW8uYWRkcmVzcycsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZmlvLmFkZHJlc3MnLFxuICAgICAgICAgICAgICB0YWJsZTogJ2RvbWFpbnMnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogX2NvbnRleHQ0LnQyLFxuICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpMTI4JyxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnQwLmdldF90YWJsZV9yb3dzLmNhbGwoX2NvbnRleHQ0LnQwLCBfY29udGV4dDQudDMpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90MyA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDMucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCAmJiByb3dzWzBdLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDE4O1xuICAgICAgICAgICAgX2NvbnRleHQ0LnQ0ID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDQudDQpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1swLCAxOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEZJT0RvbWFpbkJ5TmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREb21haW5zKF94NSwgX3g2KSB7XG4gIHJldHVybiBfZ2V0RG9tYWlucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0RG9tYWlucygpIHtcbiAgX2dldERvbWFpbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGxpbWl0LCB1cHBlcl9ib3VuZCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q0LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGxpbWl0ID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6ICdmaW8uYWRkcmVzcycsXG4gICAgICAgICAgICAgIHNjb3BlOiAnZmlvLmFkZHJlc3MnLFxuICAgICAgICAgICAgICB0YWJsZTogJ2RvbWFpbnMnLFxuICAgICAgICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICAgICAgICB1cHBlcl9ib3VuZDogdXBwZXJfYm91bmQsXG4gICAgICAgICAgICAgIGxpbWl0OiBsaW1pdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q0ID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90NC5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDEzO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDUudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzEsIDEzXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RG9tYWlucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBZGRyZXNzZXMoX3g3LCBfeDgpIHtcbiAgcmV0dXJuIF9nZXRBZGRyZXNzZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFkZHJlc3NlcygpIHtcbiAgX2dldEFkZHJlc3NlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYobGltaXQsIHVwcGVyX2JvdW5kKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDUsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbGltaXQgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2Zpby5hZGRyZXNzJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdmaW8uYWRkcmVzcycsXG4gICAgICAgICAgICAgIHRhYmxlOiAnZmlvbmFtZXMnLFxuICAgICAgICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICAgICAgICB1cHBlcl9ib3VuZDogdXBwZXJfYm91bmQsXG4gICAgICAgICAgICAgIGxpbWl0OiBsaW1pdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1ID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90NS5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDEzO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gX2NvbnRleHQ2W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDYudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzEsIDEzXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QWRkcmVzc2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEZJT1Byb2R1Y2VycyhfeDkpIHtcbiAgcmV0dXJuIF9nZXRGSU9Qcm9kdWNlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEZJT1Byb2R1Y2VycygpIHtcbiAgX2dldEZJT1Byb2R1Y2VycyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcobGltaXQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Niwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ3Byb2R1Y2VycycsXG4gICAgICAgICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgICAgICAgIGxpbWl0OiBsaW1pdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q2ID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Ni5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxMjtcbiAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ3LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgdGhpcywgW1swLCAxMl1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEZJT1Byb2R1Y2Vycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRGSU9CYWxhbmNlKF94MTApIHtcbiAgcmV0dXJuIF9nZXRGSU9CYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRGSU9CYWxhbmNlKCkge1xuICBfZ2V0RklPQmFsYW5jZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgoZmlvX3B1YmxpY19rZXkpIHtcbiAgICB2YXIgYmFsYW5jZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmZldGNoKCcvdjEvY2hhaW4vZ2V0X2Zpb19iYWxhbmNlJywge1xuICAgICAgICAgICAgICBmaW9fcHVibGljX2tleTogZmlvX3B1YmxpY19rZXlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgYmFsYW5jZSA9IF9jb250ZXh0OC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIWJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgYmFsYW5jZSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDExO1xuICAgICAgICAgICAgX2NvbnRleHQ4LnQwID0gX2NvbnRleHQ4W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDgudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTgsIHRoaXMsIFtbMCwgMTFdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRGSU9CYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEZJT1N1cHBseUJyZWFrZG93bigpIHtcbiAgcmV0dXJuIF9nZXRGSU9TdXBwbHlCcmVha2Rvd24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEZJT1N1cHBseUJyZWFrZG93bigpIHtcbiAgX2dldEZJT1N1cHBseUJyZWFrZG93biA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoKSB7XG4gICAgdmFyIHRva2VuUmVzLCBzdXBwbHksIGJwUmV3YXJkUmVzLCBicFJld2FyZHMsIGJwQnVja2V0UmVzLCBicEJ1Y2tldCwgdG90YWxCcCwgY2lyY3VsYXRpbmcsIHRvdGFsTG9ja2VkO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiBcImZpby50b2tlblwiLFxuICAgICAgICAgICAgICBzY29wZTogXCJGSU9cIixcbiAgICAgICAgICAgICAgdGFibGU6IFwic3RhdFwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRva2VuUmVzID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICBzdXBwbHkgPSArdG9rZW5SZXMucm93c1swXS5zdXBwbHkuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IFwiZmlvLnRyZWFzdXJ5XCIsXG4gICAgICAgICAgICAgIHNjb3BlOiBcImZpby50cmVhc3VyeVwiLFxuICAgICAgICAgICAgICB0YWJsZTogXCJicHJld2FyZHNcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBicFJld2FyZFJlcyA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgYnBSZXdhcmRzID0gYnBSZXdhcmRSZXMucm93c1swXS5yZXdhcmRzIC8gTWF0aC5wb3coMTAsIHRoaXMuY29uc3RhbnRzLkNPUkVfUFJFQ0lTSU9OKTtcbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiBcImZpby50cmVhc3VyeVwiLFxuICAgICAgICAgICAgICBzY29wZTogXCJmaW8udHJlYXN1cnlcIixcbiAgICAgICAgICAgICAgdGFibGU6IFwiYnBidWNrZXRwb29sXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGJwQnVja2V0UmVzID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICBicEJ1Y2tldCA9IGJwQnVja2V0UmVzLnJvd3NbMF0ucmV3YXJkcyAvIE1hdGgucG93KDEwLCB0aGlzLmNvbnN0YW50cy5DT1JFX1BSRUNJU0lPTik7XG4gICAgICAgICAgICB0b3RhbEJwID0gYnBSZXdhcmRzICsgYnBCdWNrZXQ7IC8vIGNvbnN0IHRvdGFsTG9ja2VkID0gYmFzZUxvY2tlZCArIHRvdGFsQnBcbiAgICAgICAgICAgIC8vIGNvbnN0IGNpcmN1bGF0aW5nID0gc3VwcGx5IC0gdG90YWxMb2NrZWRcblxuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgnaHR0cHM6Ly9maW9wcm90b2NvbC5pby9jaXJjdWxhdGluZycpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNpcmN1bGF0aW5nID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICB0b3RhbExvY2tlZCA9IHN1cHBseSAtICtjaXJjdWxhdGluZztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgc3VwcGx5OiBzdXBwbHksXG4gICAgICAgICAgICAgIHRvdGFsTG9ja2VkOiB0b3RhbExvY2tlZCxcbiAgICAgICAgICAgICAgYnBSZXdhcmRzOiBicFJld2FyZHMsXG4gICAgICAgICAgICAgIGJwQnVja2V0OiBicEJ1Y2tldCxcbiAgICAgICAgICAgICAgdG90YWxCcDogdG90YWxCcCxcbiAgICAgICAgICAgICAgY2lyY3VsYXRpbmc6IGNpcmN1bGF0aW5nXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRGSU9TdXBwbHlCcmVha2Rvd24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RklPRmVlcygpIHtcbiAgcmV0dXJuIF9nZXRGSU9GZWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRGSU9GZWVzKCkge1xuICBfZ2V0RklPRmVlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ2Zpby5mZWUnLFxuICAgICAgICAgICAgICBzY29wZTogJ2Zpby5mZWUnLFxuICAgICAgICAgICAgICB0YWJsZTogJ2Zpb2ZlZXMnLFxuICAgICAgICAgICAgICBsaW1pdDogLTFcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJvd3M7XG4gICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMTAsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RklPRmVlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBhZGRGSU9GZWVUb0FjdGlvbnMoX3gxMSwgX3gxMikge1xuICByZXR1cm4gX2FkZEZJT0ZlZVRvQWN0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfYWRkRklPRmVlVG9BY3Rpb25zKCkge1xuICBfYWRkRklPRmVlVG9BY3Rpb25zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEoYWN0aW9ucywgYWN0b3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGZpb0ZlZXNNYXAsIGZlZXMsIG1vZGlmaWVkQWN0aW9ucywgX2xvb3AsIF9pdGVyYXRvciwgX3N0ZXA7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDEyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGZpb0ZlZXNNYXAgPSB7XG4gICAgICAgICAgICAgICdlb3Npbzo6ZGVsZXRlYXV0aCc6ICdhdXRoX2RlbGV0ZScsXG4gICAgICAgICAgICAgICdlb3Npbzo6bGlua2F1dGgnOiAnYXV0aF9saW5rJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvOjpyZWdwcm9kdWNlcic6ICdyZWdpc3Rlcl9wcm9kdWNlcicsXG4gICAgICAgICAgICAgICdlb3Npbzo6cmVncHJveHknOiAncmVnaXN0ZXJfcHJveHknLFxuICAgICAgICAgICAgICAnZW9zaW86OnVucmVncHJvZCc6ICd1bnJlZ2lzdGVyX3Byb2R1Y2VyJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvOjp1bnJlZ3Byb3h5JzogJ3VucmVnaXN0ZXJfcHJveHknLFxuICAgICAgICAgICAgICAnZW9zaW86OnVwZGF0ZWF1dGgnOiAnYXV0aF91cGRhdGUnLFxuICAgICAgICAgICAgICAnZW9zaW86OnZvdGVwcm9kdWNlcic6ICd2b3RlX3Byb2R1Y2VyJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvOjp2b3RlcHJveHknOiAncHJveHlfdm90ZScsXG4gICAgICAgICAgICAgICdmaW8udG9rZW46OnRybnNmaW9wdWJreSc6ICd0cmFuc2Zlcl90b2tlbnNfcHViX2tleScsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6YWRkYWRkcmVzcyc6ICdhZGRfcHViX2FkZHJlc3MnLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OnJlZ2FkZHJlc3MnOiAncmVnaXN0ZXJfZmlvX2FkZHJlc3MnLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OnJlZ2RvbWFpbic6ICdyZWdpc3Rlcl9maW9fZG9tYWluJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjpyZW5ld2FkZHJlc3MnOiAncmVuZXdfZmlvX2FkZHJlc3MnLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OnJlbmV3ZG9tYWluJzogJ3JlbmV3X2Zpb19kb21haW4nLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OnNldGRvbWFpbnB1Yic6ICdzZXRfZmlvX2RvbWFpbl9wdWJsaWMnLFxuICAgICAgICAgICAgICAnZW9zaW8ubXNpZzo6YXBwcm92ZSc6ICdtc2lnX2FwcHJvdmUnLFxuICAgICAgICAgICAgICAnZW9zaW8ubXNpZzo6Y2FuY2VsJzogJ21zaWdfY2FuY2VsJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvLm1zaWc6OmV4ZWMnOiAnbXNpZ19leGVjJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvLm1zaWc6OmludmFsaWRhdGUnOiAnbXNpZ19pbnZhbGlkYXRlJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvLm1zaWc6OnByb3Bvc2UnOiAnbXNpZ19wcm9wb3NlJyxcbiAgICAgICAgICAgICAgJ2Vvc2lvLm1zaWc6OnVuYXBwcm92ZSc6ICdtc2lnX2FwcHJvdmUnLFxuICAgICAgICAgICAgICAnZmlvLnJlcW9idDo6bmV3ZnVuZHNyZXEnOiAnbmV3X2Z1bmRzX3JlcXVlc3QnLFxuICAgICAgICAgICAgICAnZmlvLnJlcW9idDo6cmVqZWN0Zm5kcmVxJzogJ3JlamVjdF9mdW5kc19yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgJ2Zpby5yZXFvYnQ6OmNhbmNlbGZuZHJlcSc6ICdjYW5jZWxmbmRyZXEnLFxuICAgICAgICAgICAgICAnZmlvLnJlcW9idDo6cmVjb3Jkb2J0JzogJ3JlY29yZF9vYnRfZGF0YScsXG4gICAgICAgICAgICAgICdmaW8ucmVxb2J0OjpuZXdwdWJhZGRyZXEnOiAnbmV3X3B1Yl9hZGRyZXNzX3JlcXVlc3QnLFxuICAgICAgICAgICAgICAnZmlvLnJlcW9idDo6cmVscHViYWRkJzogJ3JlbGVhc2VfcHViX2FkZHJlc3MnLFxuICAgICAgICAgICAgICAnZmlvLnJlcW9idDo6cmVqZWN0YWRkcmVxJzogJ3JlamVjdF9wdWJfYWRkcmVzc19yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgJ2Zpby5yZXFvYnQ6OmNhbmNlbGFkZHJlcSc6ICdjYW5jZWxfcHViX2FkZHJlc3NfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICdmaW8ubG9jazo6dHJuc2xvY3Rva3MnOiAndHJhbnNmZXJfbG9ja2VkX3Rva2VucycsXG4gICAgICAgICAgICAgICdmaW8ubG9jazo6bG9ja3Rva2Vucyc6ICdsb2NrX3Rva2VucycsXG4gICAgICAgICAgICAgICdmaW8uYWRkcmVzczo6cmVtYWRkcmVzcyc6ICdyZW1vdmVfcHViX2FkZHJlc3MnLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OnJlbWFsbGFkZHInOiAncmVtb3ZlX2FsbF9wdWJfYWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjpidXJuYWRkcmVzcyc6ICdidXJuX2Zpb19hZGRyZXNzJyxcbiAgICAgICAgICAgICAgJ2Zpby5hZGRyZXNzOjp4ZmVyZG9tYWluJzogJ3RyYW5zZmVyX2Zpb19kb21haW4nLFxuICAgICAgICAgICAgICAnZmlvLmFkZHJlc3M6OnhmZXJhZGRyZXNzJzogJ3RyYW5zZmVyX2Zpb19hZGRyZXNzJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGSU9GZWVzKCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBmZWVzID0gX2NvbnRleHQxMi5zZW50O1xuICAgICAgICAgICAgbW9kaWZpZWRBY3Rpb25zID0gW107XG4gICAgICAgICAgICBfbG9vcCA9IC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGlvbiwgX3lpZWxkJF90aGlzJGFwaSRnZXRDLCBfeWllbGQkX3RoaXMkYXBpJGdldEMyLCBhYmlBY3Rpb25zLCBhYmlTdHJ1Y3RzLCByZWxldmFudEFjdGlvbiwgcmVsZXZhbnRTdHJ1Y3QsIG1heEZlZUZpZWxkLCBlbmRwb2ludCwgcmVsZXZhbnRGZWUsIGFjdG9yRmllbGQsIHRwaWRGaWVsZCwgYWRkcmVzc0ZpZWxkLCBhZGRyZXNzZXM7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9sb29wJChfY29udGV4dDExKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcGkuZ2V0Q2FjaGVkQWJpKGFjdGlvbi5hY2NvdW50KTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgX3lpZWxkJF90aGlzJGFwaSRnZXRDID0gX2NvbnRleHQxMS5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgIF95aWVsZCRfdGhpcyRhcGkkZ2V0QzIgPSBfeWllbGQkX3RoaXMkYXBpJGdldEMuYWJpO1xuICAgICAgICAgICAgICAgICAgICAgIGFiaUFjdGlvbnMgPSBfeWllbGQkX3RoaXMkYXBpJGdldEMyLmFjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgYWJpU3RydWN0cyA9IF95aWVsZCRfdGhpcyRhcGkkZ2V0QzIuc3RydWN0cztcbiAgICAgICAgICAgICAgICAgICAgICByZWxldmFudEFjdGlvbiA9IGFiaUFjdGlvbnMuZmluZChmdW5jdGlvbiAoYWJpQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWJpQWN0aW9uLm5hbWUgPT09IGFjdGlvbi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxldmFudEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICByZWxldmFudFN0cnVjdCA9IGFiaVN0cnVjdHMuZmluZChmdW5jdGlvbiAoYWJpU3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWJpU3RydWN0Lm5hbWUgPT09IHJlbGV2YW50QWN0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbGV2YW50U3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIG1heEZlZUZpZWxkID0gcmVsZXZhbnRTdHJ1Y3QuZmllbGRzLmZpbmQoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQubmFtZSA9PT0gXCJtYXhfZmVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4RmVlRmllbGQgJiYgYWN0aW9uLmRhdGEubWF4X2ZlZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludCA9IGZpb0ZlZXNNYXBbYWN0aW9uLmFjY291bnQgKyBcIjo6XCIgKyBhY3Rpb24ubmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZWxldmFudEZlZSA9IGZlZXMuZmluZChmdW5jdGlvbiAoZmVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlZS5lbmRfcG9pbnQgPT09IGVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsZXZhbnRGZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24uZGF0YS5tYXhfZmVlID0gcmVsZXZhbnRGZWUuc3VmX2Ftb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24uZGF0YS5tYXhfZmVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGFjdG9yRmllbGQgPSByZWxldmFudFN0cnVjdC5maWVsZHMuZmluZChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC5uYW1lID09PSBcImFjdG9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3JGaWVsZCAmJiBhY3Rpb24uZGF0YS5hY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24uZGF0YS5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHRwaWRGaWVsZCA9IHJlbGV2YW50U3RydWN0LmZpZWxkcy5maW5kKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm5hbWUgPT09IFwidHBpZFwiO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRwaWRGaWVsZCAmJiBhY3Rpb24uZGF0YS50cGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5kYXRhLnRwaWQgPSBfdGhpcy5jb25zdGFudHMuRklPX0ZFRVNfQUNDT1VOVDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzRmllbGQgPSByZWxldmFudFN0cnVjdC5maWVsZHMuZmluZChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC5uYW1lID09PSBcImZpb19hZGRyZXNzXCI7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhZGRyZXNzRmllbGQgJiYgYWN0aW9uLmRhdGEuZmlvX2FkZHJlc3MgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldEZJT0FkZHJlc3NlcyhhY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMgPSBfY29udGV4dDExLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmRhdGEuZmlvX2FkZHJlc3MgPSBhZGRyZXNzZXNbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEFjdGlvbnMucHVzaChhY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBfbG9vcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWN0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZiAoKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5kZWxlZ2F0ZVlpZWxkKF9sb29wKCksIFwidDBcIiwgOSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIG1vZGlmaWVkQWN0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9hZGRGSU9GZWVUb0FjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RklPQWRkcmVzc2VzKGFjY291bnQpIHtcbiAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICBjb2RlOiAnZmlvLmFkZHJlc3MnLFxuICAgIHNjb3BlOiAnZmlvLmFkZHJlc3MnLFxuICAgIHRhYmxlOiAnZmlvbmFtZXMnLFxuICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICBsaW1pdDogLTEsXG4gICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgIHVwcGVyX2JvdW5kOiBuZXcgQmlnTnVtYmVyKGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpKS5wbHVzKDEpLnRvU3RyaW5nKCksXG4gICAgaW5kZXhfcG9zaXRpb246IDRcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5yb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiByZXN1bHQucm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gcm93Lm93bmVyX2FjY291bnQgPT09IGFjY291bnQ7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoXykge1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRGSU9Eb21haW5zKGFjY291bnQpIHtcbiAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICBjb2RlOiAnZmlvLmFkZHJlc3MnLFxuICAgIHNjb3BlOiAnZmlvLmFkZHJlc3MnLFxuICAgIHRhYmxlOiAnZG9tYWlucycsXG4gICAga2V5X3R5cGU6ICdpNjQnLFxuICAgIGxpbWl0OiAtMSxcbiAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgdXBwZXJfYm91bmQ6IG5ldyBCaWdOdW1iZXIoZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSkpLnBsdXMoMSkudG9TdHJpbmcoKSxcbiAgICBpbmRleF9wb3NpdGlvbjogMlxuICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LnJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5yb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiByb3cuYWNjb3VudCA9PT0gYWNjb3VudDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZJT0FkZHJlc3Nlc0FuZERvbWFpbnMoZmlvX3B1YmxpY19rZXkpIHtcbiAgcmV0dXJuIHBvc3QodGhpcy5jb25zdGFudHMuREVGQVVMVF9FTkRQT0lOVFNbMF0gKyBcIi92MS9nZXRfZmlvX25hbWVzXCIsIHtcbiAgICBmaW9fcHVibGljX2tleTogZmlvX3B1YmxpY19rZXlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEFsbE1zaWdzKCkge1xuICByZXR1cm4gX2dldEFsbE1zaWdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBbGxNc2lncygpIHtcbiAgX2dldEFsbE1zaWdzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRnZXQsIHRhYmxlcywgcm93cywgbG93ZXJfYm91bmQsIHJlc3VsdDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFUy5pbmNsdWRlcygnZGZ1c2UnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybEJ1aWxkZXIodGhpcy5jb25zdGFudHMuQVBJX1VSTCwgJ2RmdXNlJywge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RhdGVfc2NvcGVfcGlwZWxpbmUnLFxuICAgICAgICAgICAgICBhY2NvdW50OiB0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHLFxuICAgICAgICAgICAgICB0YWJsZTogdGhpcy5jb25zdGFudHMuRU9TSU9fTVNJR19QUk9QT1NBTFNfVEFCTEUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRnZXQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgdGFibGVzID0gX3lpZWxkJHRoaXMkZ2V0LnRhYmxlcztcbiAgICAgICAgICAgIHRhYmxlcyA9IHRhYmxlcy5tYXAoZnVuY3Rpb24gKHRhYmxlKSB7XG4gICAgICAgICAgICAgIHRhYmxlLnJvd3MgPSB0YWJsZS5yb3dzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5ibG9jayAtIGEuYmxvY2s7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0YWJsZS5oaWdoZXN0QmxvY2sgPSB0YWJsZS5yb3dzWzBdLmJsb2NrO1xuICAgICAgICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiLmhpZ2hlc3RCbG9jayAtIGEuaGlnaGVzdEJsb2NrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRhYmxlcyk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByb3dzID0gW107XG4gICAgICAgICAgICBsb3dlcl9ib3VuZCA9ICcnO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfYnlfc2NvcGUoe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiAnZW9zaW8ubXNpZycsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDAsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBsb3dlcl9ib3VuZCxcbiAgICAgICAgICAgICAgdGFibGU6ICdwcm9wb3NhbCcsXG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiAnJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGxvd2VyX2JvdW5kID0gcmVzdWx0Lm1vcmU7XG4gICAgICAgICAgICByb3dzID0gcm93cy5jb25jYXQocmVzdWx0LnJvd3MpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGlmIChsb3dlcl9ib3VuZCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjb3BlOiByb3cuc2NvcGUsXG4gICAgICAgICAgICAgICAgcm93czogQXJyYXkocm93LmNvdW50KS5maWxsKHtcbiAgICAgICAgICAgICAgICAgIGtleTogJydcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBbGxNc2lncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRNc2lnUHJvcG9zYWwoX3gsIF94Mikge1xuICByZXR1cm4gX2dldE1zaWdQcm9wb3NhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0TXNpZ1Byb3Bvc2FsKCkge1xuICBfZ2V0TXNpZ1Byb3Bvc2FsID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhY2NvdW50TmFtZSwgcHJvcG9zYWxOYW1lKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiAnZW9zaW8ubXNpZycsXG4gICAgICAgICAgICAgIHNjb3BlOiBhY2NvdW50TmFtZSxcbiAgICAgICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBwcm9wb3NhbE5hbWUsXG4gICAgICAgICAgICAgIHRhYmxlOiAncHJvcG9zYWwnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoICYmIHJvd3NbMF0ucHJvcG9zYWxfbmFtZSA9PT0gcHJvcG9zYWxOYW1lKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRNc2lnUHJvcG9zYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYWNrZWRNc2lnQWN0aW9ucyhfeDMpIHtcbiAgcmV0dXJuIF9wYXJzZVBhY2tlZE1zaWdBY3Rpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXJzZVBhY2tlZE1zaWdBY3Rpb25zKCkge1xuICBfcGFyc2VQYWNrZWRNc2lnQWN0aW9ucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMocGFja2VkQWN0aW9ucykge1xuICAgIHZhciBhY3Rpb25zLCBfaXRlcmF0b3IsIF9zdGVwLCBhY3Rpb247XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgYWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShwYWNrZWRBY3Rpb25zKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICgoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWN0aW9uID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICghKGFjdGlvbi5hY2NvdW50ID09PSB0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHICYmIGFjdGlvbi5uYW1lID09PSAncHJvcG9zZScpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaS5kZXNlcmlhbGl6ZUFjdGlvbnNTeW5jKGFjdGlvbi5kYXRhLnRyeC5hY3Rpb25zKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGFjdGlvbi5kYXRhLnRyeC5hY3Rpb25zID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBpZiAoIShhY3Rpb24uYWNjb3VudCA9PT0gdGhpcy5jb25zdGFudHMuRU9TSU8gJiYgYWN0aW9uLm5hbWUgPT09ICdzZXRhYmknKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaS5yYXdBYmlUb0pzb24oaGV4VG9VaW50OEFycmF5KGFjdGlvbi5kYXRhLmFiaSkpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGFjdGlvbi5kYXRhLmFiaSA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLm1hcChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uX3RyYWNlOiB7XG4gICAgICAgICAgICAgICAgICBhY3Q6IGFjdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgYWN0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfcGFyc2VQYWNrZWRNc2lnQWN0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhY2tlZE1zaWcoX3g0KSB7XG4gIHJldHVybiBfcGFyc2VQYWNrZWRNc2lnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXJzZVBhY2tlZE1zaWcoKSB7XG4gIF9wYXJzZVBhY2tlZE1zaWcgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KHBhY2tlZF90cmFuc2FjdGlvbikge1xuICAgIHZhciB0eDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmRlc2VyaWFsaXplVHJhbnNhY3Rpb25XaXRoQWN0aW9ucyhwYWNrZWRfdHJhbnNhY3Rpb24pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdHggPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFja2VkTXNpZ0FjdGlvbnModHguYWN0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB0eC5hY3Rpb25zID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0eCk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAxMDtcbiAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IF9jb250ZXh0NFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIHBhcnNpbmcgcGFja2VkIG1zaWcnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0NC50MCk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMsIFtbMCwgMTBdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9wYXJzZVBhY2tlZE1zaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RnVsbE1zaWdQcm9wb3NhbChfeDUsIF94Nikge1xuICByZXR1cm4gX2dldEZ1bGxNc2lnUHJvcG9zYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEZ1bGxNc2lnUHJvcG9zYWwoKSB7XG4gIF9nZXRGdWxsTXNpZ1Byb3Bvc2FsID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNShhY2NvdW50X25hbWUsIHByb3Bvc2FsX25hbWUpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHLFxuICAgICAgICAgICAgICBzY29wZTogZW5jb2RlTmFtZShhY2NvdW50X25hbWUsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdGFibGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUdfUFJPUE9TQUxTX1RBQkxFLFxuICAgICAgICAgICAgICB0YWJsZV9rZXk6ICcnLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ25hbWUnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogcHJvcG9zYWxfbmFtZSxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDEsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIShyZXN1bHQgJiYgcmVzdWx0LnJvd3MgJiYgcmVzdWx0LnJvd3MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBhY2tlZE1zaWcocmVzdWx0LnJvd3NbMF0ucGFja2VkX3RyYW5zYWN0aW9uKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NS5zZW50KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDEwO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDUudDApO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzAsIDEwXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0RnVsbE1zaWdQcm9wb3NhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRNc2lnQXBwcm92YWxzKF94NywgX3g4KSB7XG4gIHJldHVybiBfZ2V0TXNpZ0FwcHJvdmFscy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0TXNpZ0FwcHJvdmFscygpIHtcbiAgX2dldE1zaWdBcHByb3ZhbHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGFjY291bnQsIHRhYmxlKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU9fTVNJRyxcbiAgICAgICAgICAgICAgc2NvcGU6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICAgIGxpbWl0OiAtMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QyID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Mi5yb3dzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Ni50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYsIHRoaXMsIFtbMCwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldE1zaWdBcHByb3ZhbHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWNjb3VudHNNc2lnUHJvcG9zYWxzKF94OSkge1xuICByZXR1cm4gX2dldEFjY291bnRzTXNpZ1Byb3Bvc2Fscy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWNjb3VudHNNc2lnUHJvcG9zYWxzKCkge1xuICBfZ2V0QWNjb3VudHNNc2lnUHJvcG9zYWxzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhhY2NvdW50KSB7XG4gICAgdmFyIHByb21pc2VzLCBfeWllbGQkUHJvbWlzZSRhbGwsIHJvd3MyLCByb3dzMTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDA7XG4gICAgICAgICAgICBwcm9taXNlcyA9IFt0aGlzLmdldE1zaWdBcHByb3ZhbHMoYWNjb3VudCwgdGhpcy5jb25zdGFudHMuRU9TSU9fTVNJR19BUFBST1ZBTFNfVEFCTEUpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3RhbnRzLkVPU0lPX01TSUdfQVBQUk9WQUxTX1RBQkxFID09PSAnYXBwcm92YWxzMicpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmdldE1zaWdBcHByb3ZhbHMoYWNjb3VudCwgJ2FwcHJvdmFscycpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF95aWVsZCRQcm9taXNlJGFsbCA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgcm93czIgPSBfeWllbGQkUHJvbWlzZSRhbGxbMF07XG4gICAgICAgICAgICByb3dzMSA9IF95aWVsZCRQcm9taXNlJGFsbFsxXTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MyLmNvbmNhdChyb3dzMSkpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTE7XG4gICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Ny50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTcsIHRoaXMsIFtbMCwgMTFdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY2NvdW50c01zaWdQcm9wb3NhbHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gaHlwZXJpb25HZXRNc2lnKF94MTApIHtcbiAgcmV0dXJuIF9oeXBlcmlvbkdldE1zaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2h5cGVyaW9uR2V0TXNpZygpIHtcbiAgX2h5cGVyaW9uR2V0TXNpZyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgobXNpZ0ZpbHRlcnMpIHtcbiAgICB2YXIgcmVzLCBleGVjdXRpb25UcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24sIHByb3Bvc2FsLCBfeWllbGQkUHJvbWlzZSRhbGwyLCBhY3Rpb25zUmVzLCBhY3Rpb25zUmVzMiwgcmVsZXZhbnRBY3Rpb24sIHR4O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICh0aGlzLmh5cGVyaW9uKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbi5nZXRfcHJvcG9zYWxzKG1zaWdGaWx0ZXJzKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0OC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIShyZXMgJiYgcmVzLnByb3Bvc2FscyAmJiByZXMucHJvcG9zYWxzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3Bvc2FsID0gcmVzLnByb3Bvc2Fsc1swXTtcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpcy5oeXBlcmlvbi5nZXRfYWN0aW9ucyh0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHLCB7XG4gICAgICAgICAgICAgIGJsb2NrX251bTogcHJvcG9zYWwuYmxvY2tfbnVtLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSksIHRoaXMuaHlwZXJpb24uZ2V0X2RlbHRhcyh0aGlzLmNvbnN0YW50cy5FT1NJT19NU0lHLCBtc2lnRmlsdGVycy5wcm9wb3NlciwgJ3Byb3Bvc2FsJywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgIGJsb2NrX251bTogcHJvcG9zYWwuYmxvY2tfbnVtXG4gICAgICAgICAgICB9KV0pO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX3lpZWxkJFByb21pc2UkYWxsMiA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgYWN0aW9uc1JlcyA9IF95aWVsZCRQcm9taXNlJGFsbDJbMF07XG4gICAgICAgICAgICBhY3Rpb25zUmVzMiA9IF95aWVsZCRQcm9taXNlJGFsbDJbMV07XG5cbiAgICAgICAgICAgIGlmIChhY3Rpb25zUmVzICYmIGFjdGlvbnNSZXMuYWN0aW9ucyAmJiBhY3Rpb25zUmVzLmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlbGV2YW50QWN0aW9uID0gYWN0aW9uc1Jlcy5hY3Rpb25zLmZpbmQoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uYWN0LmRhdGEucHJvcG9zYWxfbmFtZSA9PT0gbXNpZ0ZpbHRlcnMucHJvcG9zYWw7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChyZWxldmFudEFjdGlvbikge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgcGF5ZXI6IHJlbGV2YW50QWN0aW9uLmFjdC5kYXRhLmV4ZWN1dGVyIHx8IHJlbGV2YW50QWN0aW9uLmFjdC5kYXRhLmNhbmNlbGVyLFxuICAgICAgICAgICAgICAgICAgdHJ4X2lkOiByZWxldmFudEFjdGlvbi50cnhfaWQsXG4gICAgICAgICAgICAgICAgICBwdWJsaXNoZWRfYXQ6IHJlbGV2YW50QWN0aW9uLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogcmVsZXZhbnRBY3Rpb24uYWN0Lm5hbWUgPT09ICdjYW5jZWwnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShhY3Rpb25zUmVzMiAmJiBhY3Rpb25zUmVzMi5kZWx0YXMgJiYgYWN0aW9uc1JlczIuZGVsdGFzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHR4ID0gYWN0aW9uc1JlczIuZGVsdGFzWzBdLmRhdGEudHJhbnNhY3Rpb247XG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE3O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYWNrZWRNc2lnQWN0aW9ucyh0eC5hY3Rpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICB0eC5hY3Rpb25zID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHR4O1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgYXBwcm92YWxzOiBwcm9wb3NhbCxcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICBleGVjdXRpb25UcmFuc2FjdGlvbjogZXhlY3V0aW9uVHJhbnNhY3Rpb25cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfaHlwZXJpb25HZXRNc2lnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFZvdGVyKF94KSB7XG4gIHJldHVybiBfZ2V0Vm90ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFZvdGVyKCkge1xuICBfZ2V0Vm90ZXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB1cHBlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHRhYmxlOiAndm90ZXJzJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Qucm93cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cy5sZW5ndGggPyByb3dzWzBdIDogdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0Vm90ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJveGllcygpIHtcbiAgcmV0dXJuIF9nZXRQcm94aWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm94aWVzKCkge1xuICBfZ2V0UHJveGllcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfeWllbGQkdGhpcyRnZXQsIHByb3hpZXMsIF95aWVsZCR0aGlzJGh5cGVyaW9uJCwgdm90ZXJzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHRoaXMuY29uc3RhbnRzLkFMT0hBX1BST1hZX1VSTCAhPT0gJycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmNvbnN0YW50cy5BTE9IQV9QUk9YWV9VUkwgKyBcIj9vdXRwdXQ9anNvblwiKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcHJveGllcyA9IF95aWVsZCR0aGlzJGdldC5wcm94aWVzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcHJveGllcyk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb24uZ2V0X3ZvdGVycyh7XG4gICAgICAgICAgICAgIHByb3h5OiB0cnVlLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkaHlwZXJpb24kID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICB2b3RlcnMgPSBfeWllbGQkdGhpcyRoeXBlcmlvbiQudm90ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdm90ZXJzLm1hcChmdW5jdGlvbiAodm90ZXIsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdm90ZXIsIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IHZvdGVyLndlaWdodCAvIE1hdGgucG93KDEwLCBfdGhpcy5jb25zdGFudHMuQ09SRV9QUkVDSVNJT04pLFxuICAgICAgICAgICAgICAgIHJhbms6IGluZGV4ICsgMVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQcm94aWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFZvdGVycyhfeDIpIHtcbiAgcmV0dXJuIF9nZXRWb3RlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFZvdGVycygpIHtcbiAgX2dldFZvdGVycyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMocHJvZHVjZXIpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfeWllbGQkdGhpcyRoeXBlcmlvbiQyLCB2b3RlcnMsIHZvdGVXZWlnaHQ7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmh5cGVyaW9uKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uLmdldF92b3RlcnMoe1xuICAgICAgICAgICAgICBwcm9kdWNlcjogcHJvZHVjZXIsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkaHlwZXJpb24kMiA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgdm90ZXJzID0gX3lpZWxkJHRoaXMkaHlwZXJpb24kMi52b3RlcnM7XG4gICAgICAgICAgICB2b3RlV2VpZ2h0ID0gdGhpcy5jYWxjdWxhdGVWb3RlV2VpZ2h0KCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB2b3RlcnMubWFwKGZ1bmN0aW9uICh2b3Rlcikge1xuICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHZvdGVyLCB7XG4gICAgICAgICAgICAgICAgdm90ZTogX3RoaXMyLndlaWdodGVkVm90ZVRvTnVtYmVyKHZvdGVyLndlaWdodCwgdm90ZVdlaWdodClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFZvdGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVWb3RlV2VpZ2h0KCkge1xuICB2YXIgZGVjYXlXZWVrcyA9IHRoaXMuY29uc3RhbnRzLkNIQUlOID09PSAnd2F4JyA/IDEzIDogNTI7XG4gIHZhciB0aW1lc3RhbXBfZXBvY2ggPSA5NDY2ODQ4MDAwMDA7XG4gIHZhciBkYXRlcyA9IERhdGUubm93KCkgLyAxMDAwIC0gdGltZXN0YW1wX2Vwb2NoIC8gMTAwMDtcbiAgdmFyIHdlaWdodCA9IE1hdGguZmxvb3IoZGF0ZXMgLyAoODY0MDAgKiA3KSkgLyBkZWNheVdlZWtzO1xuICByZXR1cm4gTWF0aC5wb3coMiwgd2VpZ2h0KTtcbn1cbmZ1bmN0aW9uIHdlaWdodGVkVm90ZVRvTnVtYmVyKHdlaWdodGVkVm90ZSwgdm90ZVdlaWdodCkge1xuICBpZiAoIXZvdGVXZWlnaHQpIHtcbiAgICB2b3RlV2VpZ2h0ID0gdGhpcy5jYWxjdWxhdGVWb3RlV2VpZ2h0KCk7XG4gIH1cblxuICByZXR1cm4gK3dlaWdodGVkVm90ZSAvIHZvdGVXZWlnaHQgLyBNYXRoLnBvdygxMCwgdGhpcy5jb25zdGFudHMuQ09SRV9QUkVDSVNJT04pO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlEYXRhKF94Mykge1xuICByZXR1cm4gX2dldFByb3h5RGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJveHlEYXRhKCkge1xuICBfZ2V0UHJveHlEYXRhID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhY2NvdW50TmFtZSkge1xuICAgIHZhciBfeWllbGQkdGhpcyRnZXQyLCBwcm94eTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh0aGlzLmNvbnN0YW50cy5BTE9IQV9QUk9YWV9VUkwgIT09ICcnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5jb25zdGFudHMuQUxPSEFfUFJPWFlfVVJMICsgXCIvXCIgKyBhY2NvdW50TmFtZSArIFwiP291dHB1dD1qc29uXCIpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0MiA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcHJveHkgPSBfeWllbGQkdGhpcyRnZXQyLnByb3h5O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgcHJveHkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb3h5RGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9kdWNlcnNMb2NhbCgpIHtcbiAgcmV0dXJuIF9nZXRQcm9kdWNlcnNMb2NhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvZHVjZXJzTG9jYWwoKSB7XG4gIF9nZXRQcm9kdWNlcnNMb2NhbCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoKSB7XG4gICAgdmFyIG1vcmUsIHJvd3MsIHJlc3VsdCwgbG93ZXJfYm91bmQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG1vcmUgPSB0cnVlO1xuICAgICAgICAgICAgcm93cyA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxvd2VyX2JvdW5kID0gbnVsbDtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAncHJvZHVjZXJzJyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGxvd2VyX2JvdW5kLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogMSxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpNjQnLFxuICAgICAgICAgICAgICBsaW1pdDogMTAwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgbW9yZSA9IHJlc3VsdC5tb3JlO1xuICAgICAgICAgICAgcm93cyA9IHJvd3MuY29uY2F0KHJlc3VsdC5yb3dzKTtcbiAgICAgICAgICAgIGxvd2VyX2JvdW5kID0gbmV3IEJpZ051bWJlcihlbmNvZGVOYW1lKHJvd3Nbcm93cy5sZW5ndGggLSAxXS5vd25lciwgZmFsc2UpKS5wbHVzKDEpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgaWYgKG1vcmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQcm9kdWNlcnNMb2NhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9kdWNlcnMoX3g0LCBfeDUsIF94Nikge1xuICByZXR1cm4gX2dldFByb2R1Y2Vycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvZHVjZXJzKCkge1xuICBfZ2V0UHJvZHVjZXJzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihwYWdlTnVtLCBwZXJQYWdlLCBsb2NhbCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAocGFnZU51bSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHBhZ2VOdW0gPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGVyUGFnZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHBlclBhZ2UgPSA1MDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvY2FsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbG9jYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEodGhpcy5jb25zdGFudHMuQVBJX1VSTCAhPT0gJycgJiYgIWxvY2FsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsQnVpbGRlcih0aGlzLmNvbnN0YW50cy5BUElfVVJMLCAncHJvZHVjZXJzJywge1xuICAgICAgICAgICAgICBwYWdlTnVtOiBwYWdlTnVtLFxuICAgICAgICAgICAgICBwZXJQYWdlOiBwZXJQYWdlXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDYuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB0aGlzLmdldFByb2R1Y2Vyc0xvY2FsKCkpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb2R1Y2Vycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFpblRhYmxlKCkge1xuICByZXR1cm4gX2dldENoYWluVGFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldENoYWluVGFibGUoKSB7XG4gIF9nZXRDaGFpblRhYmxlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNygpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Miwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ2dsb2JhbCcsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLnJvd3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU3LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldENoYWluVGFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIEt5Y1N0YXR1cztcblxuKGZ1bmN0aW9uIChLeWNTdGF0dXMpIHtcbiAgS3ljU3RhdHVzW1wiRkFJTEVEXCJdID0gXCJGQUlMRURcIjtcbiAgS3ljU3RhdHVzW1wiVU5TVUJNSVRURURcIl0gPSBcIlVOU1VCTUlUVEVEXCI7XG4gIEt5Y1N0YXR1c1tcIlBFTkRJTkdcIl0gPSBcIlBFTkRJTkdcIjtcbiAgS3ljU3RhdHVzW1wiUEFTU0VEXCJdID0gXCJQQVNTRURcIjtcbn0pKEt5Y1N0YXR1cyB8fCAoS3ljU3RhdHVzID0ge30pKTtcblxudmFyIGNvdW50cnlPcHRpb25zID0gW3tcbiAga2V5OiAnQUYnLFxuICB2YWx1ZTogJ0FGJyxcbiAgZmxhZzogJ2FmJyxcbiAgdGV4dDogJ0FmZ2hhbmlzdGFuJ1xufSwge1xuICBrZXk6ICdBWCcsXG4gIHZhbHVlOiAnQVgnLFxuICBmbGFnOiAnYXgnLFxuICB0ZXh0OiAnQWxhbmQgSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnQUwnLFxuICB2YWx1ZTogJ0FMJyxcbiAgZmxhZzogJ2FsJyxcbiAgdGV4dDogJ0FsYmFuaWEnXG59LCB7XG4gIGtleTogJ0RaJyxcbiAgdmFsdWU6ICdEWicsXG4gIGZsYWc6ICdkeicsXG4gIHRleHQ6ICdBbGdlcmlhJ1xufSwge1xuICBrZXk6ICdBUycsXG4gIHZhbHVlOiAnQVMnLFxuICBmbGFnOiAnYXMnLFxuICB0ZXh0OiAnQW1lcmljYW4gU2Ftb2EnXG59LCB7XG4gIGtleTogJ0FEJyxcbiAgdmFsdWU6ICdBRCcsXG4gIGZsYWc6ICdhZCcsXG4gIHRleHQ6ICdBbmRvcnJhJ1xufSwge1xuICBrZXk6ICdBTycsXG4gIHZhbHVlOiAnQU8nLFxuICBmbGFnOiAnYW8nLFxuICB0ZXh0OiAnQW5nb2xhJ1xufSwge1xuICBrZXk6ICdBSScsXG4gIHZhbHVlOiAnQUknLFxuICBmbGFnOiAnYWknLFxuICB0ZXh0OiAnQW5ndWlsbGEnXG59LCB7XG4gIGtleTogJ0FHJyxcbiAgdmFsdWU6ICdBRycsXG4gIGZsYWc6ICdhZycsXG4gIHRleHQ6ICdBbnRpZ3VhJ1xufSwge1xuICBrZXk6ICdBUicsXG4gIHZhbHVlOiAnQVInLFxuICBmbGFnOiAnYXInLFxuICB0ZXh0OiAnQXJnZW50aW5hJ1xufSwge1xuICBrZXk6ICdBTScsXG4gIHZhbHVlOiAnQU0nLFxuICBmbGFnOiAnYW0nLFxuICB0ZXh0OiAnQXJtZW5pYSdcbn0sIHtcbiAga2V5OiAnQVcnLFxuICB2YWx1ZTogJ0FXJyxcbiAgZmxhZzogJ2F3JyxcbiAgdGV4dDogJ0FydWJhJ1xufSwge1xuICBrZXk6ICdBVScsXG4gIHZhbHVlOiAnQVUnLFxuICBmbGFnOiAnYXUnLFxuICB0ZXh0OiAnQXVzdHJhbGlhJ1xufSwge1xuICBrZXk6ICdBVCcsXG4gIHZhbHVlOiAnQVQnLFxuICBmbGFnOiAnYXQnLFxuICB0ZXh0OiAnQXVzdHJpYSdcbn0sIHtcbiAga2V5OiAnQVonLFxuICB2YWx1ZTogJ0FaJyxcbiAgZmxhZzogJ2F6JyxcbiAgdGV4dDogJ0F6ZXJiYWlqYW4nXG59LCB7XG4gIGtleTogJ0JTJyxcbiAgdmFsdWU6ICdCUycsXG4gIGZsYWc6ICdicycsXG4gIHRleHQ6ICdCYWhhbWFzJ1xufSwge1xuICBrZXk6ICdCSCcsXG4gIHZhbHVlOiAnQkgnLFxuICBmbGFnOiAnYmgnLFxuICB0ZXh0OiAnQmFocmFpbidcbn0sIHtcbiAga2V5OiAnQkQnLFxuICB2YWx1ZTogJ0JEJyxcbiAgZmxhZzogJ2JkJyxcbiAgdGV4dDogJ0JhbmdsYWRlc2gnXG59LCB7XG4gIGtleTogJ0JCJyxcbiAgdmFsdWU6ICdCQicsXG4gIGZsYWc6ICdiYicsXG4gIHRleHQ6ICdCYXJiYWRvcydcbn0sIHtcbiAga2V5OiAnQlknLFxuICB2YWx1ZTogJ0JZJyxcbiAgZmxhZzogJ2J5JyxcbiAgdGV4dDogJ0JlbGFydXMnXG59LCB7XG4gIGtleTogJ0JFJyxcbiAgdmFsdWU6ICdCRScsXG4gIGZsYWc6ICdiZScsXG4gIHRleHQ6ICdCZWxnaXVtJ1xufSwge1xuICBrZXk6ICdCWicsXG4gIHZhbHVlOiAnQlonLFxuICBmbGFnOiAnYnonLFxuICB0ZXh0OiAnQmVsaXplJ1xufSwge1xuICBrZXk6ICdCSicsXG4gIHZhbHVlOiAnQkonLFxuICBmbGFnOiAnYmonLFxuICB0ZXh0OiAnQmVuaW4nXG59LCB7XG4gIGtleTogJ0JNJyxcbiAgdmFsdWU6ICdCTScsXG4gIGZsYWc6ICdibScsXG4gIHRleHQ6ICdCZXJtdWRhJ1xufSwge1xuICBrZXk6ICdCVCcsXG4gIHZhbHVlOiAnQlQnLFxuICBmbGFnOiAnYnQnLFxuICB0ZXh0OiAnQmh1dGFuJ1xufSwge1xuICBrZXk6ICdCTycsXG4gIHZhbHVlOiAnQk8nLFxuICBmbGFnOiAnYm8nLFxuICB0ZXh0OiAnQm9saXZpYSdcbn0sIHtcbiAga2V5OiAnQkEnLFxuICB2YWx1ZTogJ0JBJyxcbiAgZmxhZzogJ2JhJyxcbiAgdGV4dDogJ0Jvc25pYSdcbn0sIHtcbiAga2V5OiAnQlcnLFxuICB2YWx1ZTogJ0JXJyxcbiAgZmxhZzogJ2J3JyxcbiAgdGV4dDogJ0JvdHN3YW5hJ1xufSwge1xuICBrZXk6ICdCVicsXG4gIHZhbHVlOiAnQlYnLFxuICBmbGFnOiAnYnYnLFxuICB0ZXh0OiAnQm91dmV0IElzbGFuZCdcbn0sIHtcbiAga2V5OiAnQlInLFxuICB2YWx1ZTogJ0JSJyxcbiAgZmxhZzogJ2JyJyxcbiAgdGV4dDogJ0JyYXppbCdcbn0sIHtcbiAga2V5OiAnVkcnLFxuICB2YWx1ZTogJ1ZHJyxcbiAgZmxhZzogJ3ZnJyxcbiAgdGV4dDogJ0JyaXRpc2ggVmlyZ2luIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ0JOJyxcbiAgdmFsdWU6ICdCTicsXG4gIGZsYWc6ICdibicsXG4gIHRleHQ6ICdCcnVuZWknXG59LCB7XG4gIGtleTogJ0JHJyxcbiAgdmFsdWU6ICdCRycsXG4gIGZsYWc6ICdiZycsXG4gIHRleHQ6ICdCdWxnYXJpYSdcbn0sIHtcbiAga2V5OiAnQkYnLFxuICB2YWx1ZTogJ0JGJyxcbiAgZmxhZzogJ2JmJyxcbiAgdGV4dDogJ0J1cmtpbmEgRmFzbydcbn0sIHtcbiAga2V5OiAnQkknLFxuICB2YWx1ZTogJ0JJJyxcbiAgZmxhZzogJ2JpJyxcbiAgdGV4dDogJ0J1cnVuZGknXG59LCB7XG4gIGtleTogJ1RDJyxcbiAgdmFsdWU6ICdUQycsXG4gIGZsYWc6ICd0YycsXG4gIHRleHQ6ICdDYWljb3MgSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnS0gnLFxuICB2YWx1ZTogJ0tIJyxcbiAgZmxhZzogJ2toJyxcbiAgdGV4dDogJ0NhbWJvZGlhJ1xufSwge1xuICBrZXk6ICdDTScsXG4gIHZhbHVlOiAnQ00nLFxuICBmbGFnOiAnY20nLFxuICB0ZXh0OiAnQ2FtZXJvb24nXG59LCB7XG4gIGtleTogJ0NBJyxcbiAgdmFsdWU6ICdDQScsXG4gIGZsYWc6ICdjYScsXG4gIHRleHQ6ICdDYW5hZGEnXG59LCB7XG4gIGtleTogJ0NWJyxcbiAgdmFsdWU6ICdDVicsXG4gIGZsYWc6ICdjdicsXG4gIHRleHQ6ICdDYXBlIFZlcmRlJ1xufSwge1xuICBrZXk6ICdLWScsXG4gIHZhbHVlOiAnS1knLFxuICBmbGFnOiAna3knLFxuICB0ZXh0OiAnQ2F5bWFuIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ0NGJyxcbiAgdmFsdWU6ICdDRicsXG4gIGZsYWc6ICdjZicsXG4gIHRleHQ6ICdDZW50cmFsIEFmcmljYW4gUmVwdWJsaWMnXG59LCB7XG4gIGtleTogJ1REJyxcbiAgdmFsdWU6ICdURCcsXG4gIGZsYWc6ICd0ZCcsXG4gIHRleHQ6ICdDaGFkJ1xufSwge1xuICBrZXk6ICdDTCcsXG4gIHZhbHVlOiAnQ0wnLFxuICBmbGFnOiAnY2wnLFxuICB0ZXh0OiAnQ2hpbGUnXG59LCB7XG4gIGtleTogJ0NOJyxcbiAgdmFsdWU6ICdDTicsXG4gIGZsYWc6ICdjbicsXG4gIHRleHQ6ICdDaGluYSdcbn0sIHtcbiAga2V5OiAnQ1gnLFxuICB2YWx1ZTogJ0NYJyxcbiAgZmxhZzogJ2N4JyxcbiAgdGV4dDogJ0NocmlzdG1hcyBJc2xhbmQnXG59LCB7XG4gIGtleTogJ0NDJyxcbiAgdmFsdWU6ICdDQycsXG4gIGZsYWc6ICdjYycsXG4gIHRleHQ6ICdDb2NvcyBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdDTycsXG4gIHZhbHVlOiAnQ08nLFxuICBmbGFnOiAnY28nLFxuICB0ZXh0OiAnQ29sb21iaWEnXG59LCB7XG4gIGtleTogJ0tNJyxcbiAgdmFsdWU6ICdLTScsXG4gIGZsYWc6ICdrbScsXG4gIHRleHQ6ICdDb21vcm9zJ1xufSwge1xuICBrZXk6ICdDRycsXG4gIHZhbHVlOiAnQ0cnLFxuICBmbGFnOiAnY2cnLFxuICB0ZXh0OiAnQ29uZ28gQnJhenphdmlsbGUnXG59LCB7XG4gIGtleTogJ0NEJyxcbiAgdmFsdWU6ICdDRCcsXG4gIGZsYWc6ICdjZCcsXG4gIHRleHQ6ICdDb25nbydcbn0sIHtcbiAga2V5OiAnQ0snLFxuICB2YWx1ZTogJ0NLJyxcbiAgZmxhZzogJ2NrJyxcbiAgdGV4dDogJ0Nvb2sgSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnQ1InLFxuICB2YWx1ZTogJ0NSJyxcbiAgZmxhZzogJ2NyJyxcbiAgdGV4dDogJ0Nvc3RhIFJpY2EnXG59LCB7XG4gIGtleTogJ0NJJyxcbiAgdmFsdWU6ICdDSScsXG4gIGZsYWc6ICdjaScsXG4gIHRleHQ6ICdDb3RlIERpdm9pcmUnXG59LCB7XG4gIGtleTogJ0hSJyxcbiAgdmFsdWU6ICdIUicsXG4gIGZsYWc6ICdocicsXG4gIHRleHQ6ICdDcm9hdGlhJ1xufSwge1xuICBrZXk6ICdDVScsXG4gIHZhbHVlOiAnQ1UnLFxuICBmbGFnOiAnY3UnLFxuICB0ZXh0OiAnQ3ViYSdcbn0sIHtcbiAga2V5OiAnQ1knLFxuICB2YWx1ZTogJ0NZJyxcbiAgZmxhZzogJ2N5JyxcbiAgdGV4dDogJ0N5cHJ1cydcbn0sIHtcbiAga2V5OiAnQ1onLFxuICB2YWx1ZTogJ0NaJyxcbiAgZmxhZzogJ2N6JyxcbiAgdGV4dDogJ0N6ZWNoIFJlcHVibGljJ1xufSwge1xuICBrZXk6ICdESycsXG4gIHZhbHVlOiAnREsnLFxuICBmbGFnOiAnZGsnLFxuICB0ZXh0OiAnRGVubWFyaydcbn0sIHtcbiAga2V5OiAnREonLFxuICB2YWx1ZTogJ0RKJyxcbiAgZmxhZzogJ2RqJyxcbiAgdGV4dDogJ0RqaWJvdXRpJ1xufSwge1xuICBrZXk6ICdETScsXG4gIHZhbHVlOiAnRE0nLFxuICBmbGFnOiAnZG0nLFxuICB0ZXh0OiAnRG9taW5pY2EnXG59LCB7XG4gIGtleTogJ0RPJyxcbiAgdmFsdWU6ICdETycsXG4gIGZsYWc6ICdkbycsXG4gIHRleHQ6ICdEb21pbmljYW4gUmVwdWJsaWMnXG59LCB7XG4gIGtleTogJ0VDJyxcbiAgdmFsdWU6ICdFQycsXG4gIGZsYWc6ICdlYycsXG4gIHRleHQ6ICdFY3VhZG9yJ1xufSwge1xuICBrZXk6ICdFRycsXG4gIHZhbHVlOiAnRUcnLFxuICBmbGFnOiAnZWcnLFxuICB0ZXh0OiAnRWd5cHQnXG59LCB7XG4gIGtleTogJ1NWJyxcbiAgdmFsdWU6ICdTVicsXG4gIGZsYWc6ICdzdicsXG4gIHRleHQ6ICdFbCBTYWx2YWRvcidcbn0sIHtcbiAga2V5OiAnR0InLFxuICB2YWx1ZTogJ0dCJyxcbiAgZmxhZzogJ2diJyxcbiAgdGV4dDogJ0VuZ2xhbmQnXG59LCB7XG4gIGtleTogJ0dRJyxcbiAgdmFsdWU6ICdHUScsXG4gIGZsYWc6ICdncScsXG4gIHRleHQ6ICdFcXVhdG9yaWFsIEd1aW5lYSdcbn0sIHtcbiAga2V5OiAnRVInLFxuICB2YWx1ZTogJ0VSJyxcbiAgZmxhZzogJ2VyJyxcbiAgdGV4dDogJ0VyaXRyZWEnXG59LCB7XG4gIGtleTogJ0VFJyxcbiAgdmFsdWU6ICdFRScsXG4gIGZsYWc6ICdlZScsXG4gIHRleHQ6ICdFc3RvbmlhJ1xufSwge1xuICBrZXk6ICdFVCcsXG4gIHZhbHVlOiAnRVQnLFxuICBmbGFnOiAnZXQnLFxuICB0ZXh0OiAnRXRoaW9waWEnXG59LCB7XG4gIGtleTogJ0VVJyxcbiAgdmFsdWU6ICdFVScsXG4gIGZsYWc6ICdldScsXG4gIHRleHQ6ICdFdXJvcGVhbiBVbmlvbidcbn0sIHtcbiAga2V5OiAnRksnLFxuICB2YWx1ZTogJ0ZLJyxcbiAgZmxhZzogJ2ZrJyxcbiAgdGV4dDogJ0ZhbGtsYW5kIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ0ZPJyxcbiAgdmFsdWU6ICdGTycsXG4gIGZsYWc6ICdmbycsXG4gIHRleHQ6ICdGYXJvZSBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdGSicsXG4gIHZhbHVlOiAnRkonLFxuICBmbGFnOiAnZmonLFxuICB0ZXh0OiAnRmlqaSdcbn0sIHtcbiAga2V5OiAnRkknLFxuICB2YWx1ZTogJ0ZJJyxcbiAgZmxhZzogJ2ZpJyxcbiAgdGV4dDogJ0ZpbmxhbmQnXG59LCB7XG4gIGtleTogJ0ZSJyxcbiAgdmFsdWU6ICdGUicsXG4gIGZsYWc6ICdmcicsXG4gIHRleHQ6ICdGcmFuY2UnXG59LCB7XG4gIGtleTogJ0dGJyxcbiAgdmFsdWU6ICdHRicsXG4gIGZsYWc6ICdnZicsXG4gIHRleHQ6ICdGcmVuY2ggR3VpYW5hJ1xufSwge1xuICBrZXk6ICdQRicsXG4gIHZhbHVlOiAnUEYnLFxuICBmbGFnOiAncGYnLFxuICB0ZXh0OiAnRnJlbmNoIFBvbHluZXNpYSdcbn0sIHtcbiAga2V5OiAnVEYnLFxuICB2YWx1ZTogJ1RGJyxcbiAgZmxhZzogJ3RmJyxcbiAgdGV4dDogJ0ZyZW5jaCBUZXJyaXRvcmllcydcbn0sIHtcbiAga2V5OiAnR0EnLFxuICB2YWx1ZTogJ0dBJyxcbiAgZmxhZzogJ2dhJyxcbiAgdGV4dDogJ0dhYm9uJ1xufSwge1xuICBrZXk6ICdHTScsXG4gIHZhbHVlOiAnR00nLFxuICBmbGFnOiAnZ20nLFxuICB0ZXh0OiAnR2FtYmlhJ1xufSwge1xuICBrZXk6ICdHRScsXG4gIHZhbHVlOiAnR0UnLFxuICBmbGFnOiAnZ2UnLFxuICB0ZXh0OiAnR2VvcmdpYSdcbn0sIHtcbiAga2V5OiAnREUnLFxuICB2YWx1ZTogJ0RFJyxcbiAgZmxhZzogJ2RlJyxcbiAgdGV4dDogJ0dlcm1hbnknXG59LCB7XG4gIGtleTogJ0dIJyxcbiAgdmFsdWU6ICdHSCcsXG4gIGZsYWc6ICdnaCcsXG4gIHRleHQ6ICdHaGFuYSdcbn0sIHtcbiAga2V5OiAnR0knLFxuICB2YWx1ZTogJ0dJJyxcbiAgZmxhZzogJ2dpJyxcbiAgdGV4dDogJ0dpYnJhbHRhcidcbn0sIHtcbiAga2V5OiAnR1InLFxuICB2YWx1ZTogJ0dSJyxcbiAgZmxhZzogJ2dyJyxcbiAgdGV4dDogJ0dyZWVjZSdcbn0sIHtcbiAga2V5OiAnR0wnLFxuICB2YWx1ZTogJ0dMJyxcbiAgZmxhZzogJ2dsJyxcbiAgdGV4dDogJ0dyZWVubGFuZCdcbn0sIHtcbiAga2V5OiAnR0QnLFxuICB2YWx1ZTogJ0dEJyxcbiAgZmxhZzogJ2dkJyxcbiAgdGV4dDogJ0dyZW5hZGEnXG59LCB7XG4gIGtleTogJ0dQJyxcbiAgdmFsdWU6ICdHUCcsXG4gIGZsYWc6ICdncCcsXG4gIHRleHQ6ICdHdWFkZWxvdXBlJ1xufSwge1xuICBrZXk6ICdHVScsXG4gIHZhbHVlOiAnR1UnLFxuICBmbGFnOiAnZ3UnLFxuICB0ZXh0OiAnR3VhbSdcbn0sIHtcbiAga2V5OiAnR1QnLFxuICB2YWx1ZTogJ0dUJyxcbiAgZmxhZzogJ2d0JyxcbiAgdGV4dDogJ0d1YXRlbWFsYSdcbn0sIHtcbiAga2V5OiAnR1cnLFxuICB2YWx1ZTogJ0dXJyxcbiAgZmxhZzogJ2d3JyxcbiAgdGV4dDogJ0d1aW5lYS1CaXNzYXUnXG59LCB7XG4gIGtleTogJ0dOJyxcbiAgdmFsdWU6ICdHTicsXG4gIGZsYWc6ICdnbicsXG4gIHRleHQ6ICdHdWluZWEnXG59LCB7XG4gIGtleTogJ0dZJyxcbiAgdmFsdWU6ICdHWScsXG4gIGZsYWc6ICdneScsXG4gIHRleHQ6ICdHdXlhbmEnXG59LCB7XG4gIGtleTogJ0hUJyxcbiAgdmFsdWU6ICdIVCcsXG4gIGZsYWc6ICdodCcsXG4gIHRleHQ6ICdIYWl0aSdcbn0sIHtcbiAga2V5OiAnSE0nLFxuICB2YWx1ZTogJ0hNJyxcbiAgZmxhZzogJ2htJyxcbiAgdGV4dDogJ0hlYXJkIElzbGFuZCdcbn0sIHtcbiAga2V5OiAnSE4nLFxuICB2YWx1ZTogJ0hOJyxcbiAgZmxhZzogJ2huJyxcbiAgdGV4dDogJ0hvbmR1cmFzJ1xufSwge1xuICBrZXk6ICdISycsXG4gIHZhbHVlOiAnSEsnLFxuICBmbGFnOiAnaGsnLFxuICB0ZXh0OiAnSG9uZyBLb25nJ1xufSwge1xuICBrZXk6ICdIVScsXG4gIHZhbHVlOiAnSFUnLFxuICBmbGFnOiAnaHUnLFxuICB0ZXh0OiAnSHVuZ2FyeSdcbn0sIHtcbiAga2V5OiAnSVMnLFxuICB2YWx1ZTogJ0lTJyxcbiAgZmxhZzogJ2lzJyxcbiAgdGV4dDogJ0ljZWxhbmQnXG59LCB7XG4gIGtleTogJ0lOJyxcbiAgdmFsdWU6ICdJTicsXG4gIGZsYWc6ICdpbicsXG4gIHRleHQ6ICdJbmRpYSdcbn0sIHtcbiAga2V5OiAnSU8nLFxuICB2YWx1ZTogJ0lPJyxcbiAgZmxhZzogJ2lvJyxcbiAgdGV4dDogJ0luZGlhbiBPY2VhbiBUZXJyaXRvcnknXG59LCB7XG4gIGtleTogJ0lEJyxcbiAgdmFsdWU6ICdJRCcsXG4gIGZsYWc6ICdpZCcsXG4gIHRleHQ6ICdJbmRvbmVzaWEnXG59LCB7XG4gIGtleTogJ0lSJyxcbiAgdmFsdWU6ICdJUicsXG4gIGZsYWc6ICdpcicsXG4gIHRleHQ6ICdJcmFuJ1xufSwge1xuICBrZXk6ICdJUScsXG4gIHZhbHVlOiAnSVEnLFxuICBmbGFnOiAnaXEnLFxuICB0ZXh0OiAnSXJhcSdcbn0sIHtcbiAga2V5OiAnSUUnLFxuICB2YWx1ZTogJ0lFJyxcbiAgZmxhZzogJ2llJyxcbiAgdGV4dDogJ0lyZWxhbmQnXG59LCB7XG4gIGtleTogJ0lMJyxcbiAgdmFsdWU6ICdJTCcsXG4gIGZsYWc6ICdpbCcsXG4gIHRleHQ6ICdJc3JhZWwnXG59LCB7XG4gIGtleTogJ0lUJyxcbiAgdmFsdWU6ICdJVCcsXG4gIGZsYWc6ICdpdCcsXG4gIHRleHQ6ICdJdGFseSdcbn0sIHtcbiAga2V5OiAnSk0nLFxuICB2YWx1ZTogJ0pNJyxcbiAgZmxhZzogJ2ptJyxcbiAgdGV4dDogJ0phbWFpY2EnXG59LCB7XG4gIGtleTogJ0pQJyxcbiAgdmFsdWU6ICdKUCcsXG4gIGZsYWc6ICdqcCcsXG4gIHRleHQ6ICdKYXBhbidcbn0sIHtcbiAga2V5OiAnSk8nLFxuICB2YWx1ZTogJ0pPJyxcbiAgZmxhZzogJ2pvJyxcbiAgdGV4dDogJ0pvcmRhbidcbn0sIHtcbiAga2V5OiAnS1onLFxuICB2YWx1ZTogJ0taJyxcbiAgZmxhZzogJ2t6JyxcbiAgdGV4dDogJ0themFraHN0YW4nXG59LCB7XG4gIGtleTogJ0tFJyxcbiAgdmFsdWU6ICdLRScsXG4gIGZsYWc6ICdrZScsXG4gIHRleHQ6ICdLZW55YSdcbn0sIHtcbiAga2V5OiAnS0knLFxuICB2YWx1ZTogJ0tJJyxcbiAgZmxhZzogJ2tpJyxcbiAgdGV4dDogJ0tpcmliYXRpJ1xufSwge1xuICBrZXk6ICdLVycsXG4gIHZhbHVlOiAnS1cnLFxuICBmbGFnOiAna3cnLFxuICB0ZXh0OiAnS3V3YWl0J1xufSwge1xuICBrZXk6ICdLRycsXG4gIHZhbHVlOiAnS0cnLFxuICBmbGFnOiAna2cnLFxuICB0ZXh0OiAnS3lyZ3l6c3Rhbidcbn0sIHtcbiAga2V5OiAnTEEnLFxuICB2YWx1ZTogJ0xBJyxcbiAgZmxhZzogJ2xhJyxcbiAgdGV4dDogJ0xhb3MnXG59LCB7XG4gIGtleTogJ0xWJyxcbiAgdmFsdWU6ICdMVicsXG4gIGZsYWc6ICdsdicsXG4gIHRleHQ6ICdMYXR2aWEnXG59LCB7XG4gIGtleTogJ0xCJyxcbiAgdmFsdWU6ICdMQicsXG4gIGZsYWc6ICdsYicsXG4gIHRleHQ6ICdMZWJhbm9uJ1xufSwge1xuICBrZXk6ICdMUycsXG4gIHZhbHVlOiAnTFMnLFxuICBmbGFnOiAnbHMnLFxuICB0ZXh0OiAnTGVzb3Robydcbn0sIHtcbiAga2V5OiAnTFInLFxuICB2YWx1ZTogJ0xSJyxcbiAgZmxhZzogJ2xyJyxcbiAgdGV4dDogJ0xpYmVyaWEnXG59LCB7XG4gIGtleTogJ0xZJyxcbiAgdmFsdWU6ICdMWScsXG4gIGZsYWc6ICdseScsXG4gIHRleHQ6ICdMaWJ5YSdcbn0sIHtcbiAga2V5OiAnTEknLFxuICB2YWx1ZTogJ0xJJyxcbiAgZmxhZzogJ2xpJyxcbiAgdGV4dDogJ0xpZWNodGVuc3RlaW4nXG59LCB7XG4gIGtleTogJ0xUJyxcbiAgdmFsdWU6ICdMVCcsXG4gIGZsYWc6ICdsdCcsXG4gIHRleHQ6ICdMaXRodWFuaWEnXG59LCB7XG4gIGtleTogJ0xVJyxcbiAgdmFsdWU6ICdMVScsXG4gIGZsYWc6ICdsdScsXG4gIHRleHQ6ICdMdXhlbWJvdXJnJ1xufSwge1xuICBrZXk6ICdNTycsXG4gIHZhbHVlOiAnTU8nLFxuICBmbGFnOiAnbW8nLFxuICB0ZXh0OiAnTWFjYXUnXG59LCB7XG4gIGtleTogJ01LJyxcbiAgdmFsdWU6ICdNSycsXG4gIGZsYWc6ICdtaycsXG4gIHRleHQ6ICdNYWNlZG9uaWEnXG59LCB7XG4gIGtleTogJ01HJyxcbiAgdmFsdWU6ICdNRycsXG4gIGZsYWc6ICdtZycsXG4gIHRleHQ6ICdNYWRhZ2FzY2FyJ1xufSwge1xuICBrZXk6ICdNVycsXG4gIHZhbHVlOiAnTVcnLFxuICBmbGFnOiAnbXcnLFxuICB0ZXh0OiAnTWFsYXdpJ1xufSwge1xuICBrZXk6ICdNWScsXG4gIHZhbHVlOiAnTVknLFxuICBmbGFnOiAnbXknLFxuICB0ZXh0OiAnTWFsYXlzaWEnXG59LCB7XG4gIGtleTogJ01WJyxcbiAgdmFsdWU6ICdNVicsXG4gIGZsYWc6ICdtdicsXG4gIHRleHQ6ICdNYWxkaXZlcydcbn0sIHtcbiAga2V5OiAnTUwnLFxuICB2YWx1ZTogJ01MJyxcbiAgZmxhZzogJ21sJyxcbiAgdGV4dDogJ01hbGknXG59LCB7XG4gIGtleTogJ01UJyxcbiAgdmFsdWU6ICdNVCcsXG4gIGZsYWc6ICdtdCcsXG4gIHRleHQ6ICdNYWx0YSdcbn0sIHtcbiAga2V5OiAnTUgnLFxuICB2YWx1ZTogJ01IJyxcbiAgZmxhZzogJ21oJyxcbiAgdGV4dDogJ01hcnNoYWxsIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ01RJyxcbiAgdmFsdWU6ICdNUScsXG4gIGZsYWc6ICdtcScsXG4gIHRleHQ6ICdNYXJ0aW5pcXVlJ1xufSwge1xuICBrZXk6ICdNUicsXG4gIHZhbHVlOiAnTVInLFxuICBmbGFnOiAnbXInLFxuICB0ZXh0OiAnTWF1cml0YW5pYSdcbn0sIHtcbiAga2V5OiAnTVUnLFxuICB2YWx1ZTogJ01VJyxcbiAgZmxhZzogJ211JyxcbiAgdGV4dDogJ01hdXJpdGl1cydcbn0sIHtcbiAga2V5OiAnWVQnLFxuICB2YWx1ZTogJ1lUJyxcbiAgZmxhZzogJ3l0JyxcbiAgdGV4dDogJ01heW90dGUnXG59LCB7XG4gIGtleTogJ01YJyxcbiAgdmFsdWU6ICdNWCcsXG4gIGZsYWc6ICdteCcsXG4gIHRleHQ6ICdNZXhpY28nXG59LCB7XG4gIGtleTogJ0ZNJyxcbiAgdmFsdWU6ICdGTScsXG4gIGZsYWc6ICdmbScsXG4gIHRleHQ6ICdNaWNyb25lc2lhJ1xufSwge1xuICBrZXk6ICdNRCcsXG4gIHZhbHVlOiAnTUQnLFxuICBmbGFnOiAnbWQnLFxuICB0ZXh0OiAnTW9sZG92YSdcbn0sIHtcbiAga2V5OiAnTUMnLFxuICB2YWx1ZTogJ01DJyxcbiAgZmxhZzogJ21jJyxcbiAgdGV4dDogJ01vbmFjbydcbn0sIHtcbiAga2V5OiAnTU4nLFxuICB2YWx1ZTogJ01OJyxcbiAgZmxhZzogJ21uJyxcbiAgdGV4dDogJ01vbmdvbGlhJ1xufSwge1xuICBrZXk6ICdNRScsXG4gIHZhbHVlOiAnTUUnLFxuICBmbGFnOiAnbWUnLFxuICB0ZXh0OiAnTW9udGVuZWdybydcbn0sIHtcbiAga2V5OiAnTVMnLFxuICB2YWx1ZTogJ01TJyxcbiAgZmxhZzogJ21zJyxcbiAgdGV4dDogJ01vbnRzZXJyYXQnXG59LCB7XG4gIGtleTogJ01BJyxcbiAgdmFsdWU6ICdNQScsXG4gIGZsYWc6ICdtYScsXG4gIHRleHQ6ICdNb3JvY2NvJ1xufSwge1xuICBrZXk6ICdNWicsXG4gIHZhbHVlOiAnTVonLFxuICBmbGFnOiAnbXonLFxuICB0ZXh0OiAnTW96YW1iaXF1ZSdcbn0sIHtcbiAga2V5OiAnTkEnLFxuICB2YWx1ZTogJ05BJyxcbiAgZmxhZzogJ25hJyxcbiAgdGV4dDogJ05hbWliaWEnXG59LCB7XG4gIGtleTogJ05SJyxcbiAgdmFsdWU6ICdOUicsXG4gIGZsYWc6ICducicsXG4gIHRleHQ6ICdOYXVydSdcbn0sIHtcbiAga2V5OiAnTlAnLFxuICB2YWx1ZTogJ05QJyxcbiAgZmxhZzogJ25wJyxcbiAgdGV4dDogJ05lcGFsJ1xufSwge1xuICBrZXk6ICdBTicsXG4gIHZhbHVlOiAnQU4nLFxuICBmbGFnOiAnYW4nLFxuICB0ZXh0OiAnTmV0aGVybGFuZHMgQW50aWxsZXMnXG59LCB7XG4gIGtleTogJ05MJyxcbiAgdmFsdWU6ICdOTCcsXG4gIGZsYWc6ICdubCcsXG4gIHRleHQ6ICdOZXRoZXJsYW5kcydcbn0sIHtcbiAga2V5OiAnTkMnLFxuICB2YWx1ZTogJ05DJyxcbiAgZmxhZzogJ25jJyxcbiAgdGV4dDogJ05ldyBDYWxlZG9uaWEnXG59LCB7XG4gIGtleTogJ1BHJyxcbiAgdmFsdWU6ICdQRycsXG4gIGZsYWc6ICdwZycsXG4gIHRleHQ6ICdOZXcgR3VpbmVhJ1xufSwge1xuICBrZXk6ICdOWicsXG4gIHZhbHVlOiAnTlonLFxuICBmbGFnOiAnbnonLFxuICB0ZXh0OiAnTmV3IFplYWxhbmQnXG59LCB7XG4gIGtleTogJ05JJyxcbiAgdmFsdWU6ICdOSScsXG4gIGZsYWc6ICduaScsXG4gIHRleHQ6ICdOaWNhcmFndWEnXG59LCB7XG4gIGtleTogJ05FJyxcbiAgdmFsdWU6ICdORScsXG4gIGZsYWc6ICduZScsXG4gIHRleHQ6ICdOaWdlcidcbn0sIHtcbiAga2V5OiAnTkcnLFxuICB2YWx1ZTogJ05HJyxcbiAgZmxhZzogJ25nJyxcbiAgdGV4dDogJ05pZ2VyaWEnXG59LCB7XG4gIGtleTogJ05VJyxcbiAgdmFsdWU6ICdOVScsXG4gIGZsYWc6ICdudScsXG4gIHRleHQ6ICdOaXVlJ1xufSwge1xuICBrZXk6ICdORicsXG4gIHZhbHVlOiAnTkYnLFxuICBmbGFnOiAnbmYnLFxuICB0ZXh0OiAnTm9yZm9sayBJc2xhbmQnXG59LCB7XG4gIGtleTogJ0tQJyxcbiAgdmFsdWU6ICdLUCcsXG4gIGZsYWc6ICdrcCcsXG4gIHRleHQ6ICdOb3J0aCBLb3JlYSdcbn0sIHtcbiAga2V5OiAnTVAnLFxuICB2YWx1ZTogJ01QJyxcbiAgZmxhZzogJ21wJyxcbiAgdGV4dDogJ05vcnRoZXJuIE1hcmlhbmEgSXNsYW5kcydcbn0sIHtcbiAga2V5OiAnTk8nLFxuICB2YWx1ZTogJ05PJyxcbiAgZmxhZzogJ25vJyxcbiAgdGV4dDogJ05vcndheSdcbn0sIHtcbiAga2V5OiAnT00nLFxuICB2YWx1ZTogJ09NJyxcbiAgZmxhZzogJ29tJyxcbiAgdGV4dDogJ09tYW4nXG59LCB7XG4gIGtleTogJ1BLJyxcbiAgdmFsdWU6ICdQSycsXG4gIGZsYWc6ICdwaycsXG4gIHRleHQ6ICdQYWtpc3Rhbidcbn0sIHtcbiAga2V5OiAnUFcnLFxuICB2YWx1ZTogJ1BXJyxcbiAgZmxhZzogJ3B3JyxcbiAgdGV4dDogJ1BhbGF1J1xufSwge1xuICBrZXk6ICdQUycsXG4gIHZhbHVlOiAnUFMnLFxuICBmbGFnOiAncHMnLFxuICB0ZXh0OiAnUGFsZXN0aW5lJ1xufSwge1xuICBrZXk6ICdQQScsXG4gIHZhbHVlOiAnUEEnLFxuICBmbGFnOiAncGEnLFxuICB0ZXh0OiAnUGFuYW1hJ1xufSwge1xuICBrZXk6ICdQWScsXG4gIHZhbHVlOiAnUFknLFxuICBmbGFnOiAncHknLFxuICB0ZXh0OiAnUGFyYWd1YXknXG59LCB7XG4gIGtleTogJ1BFJyxcbiAgdmFsdWU6ICdQRScsXG4gIGZsYWc6ICdwZScsXG4gIHRleHQ6ICdQZXJ1J1xufSwge1xuICBrZXk6ICdQSCcsXG4gIHZhbHVlOiAnUEgnLFxuICBmbGFnOiAncGgnLFxuICB0ZXh0OiAnUGhpbGlwcGluZXMnXG59LCB7XG4gIGtleTogJ1BOJyxcbiAgdmFsdWU6ICdQTicsXG4gIGZsYWc6ICdwbicsXG4gIHRleHQ6ICdQaXRjYWlybiBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdQTCcsXG4gIHZhbHVlOiAnUEwnLFxuICBmbGFnOiAncGwnLFxuICB0ZXh0OiAnUG9sYW5kJ1xufSwge1xuICBrZXk6ICdQVCcsXG4gIHZhbHVlOiAnUFQnLFxuICBmbGFnOiAncHQnLFxuICB0ZXh0OiAnUG9ydHVnYWwnXG59LCB7XG4gIGtleTogJ1BSJyxcbiAgdmFsdWU6ICdQUicsXG4gIGZsYWc6ICdwcicsXG4gIHRleHQ6ICdQdWVydG8gUmljbydcbn0sIHtcbiAga2V5OiAnUUEnLFxuICB2YWx1ZTogJ1FBJyxcbiAgZmxhZzogJ3FhJyxcbiAgdGV4dDogJ1FhdGFyJ1xufSwge1xuICBrZXk6ICdSRScsXG4gIHZhbHVlOiAnUkUnLFxuICBmbGFnOiAncmUnLFxuICB0ZXh0OiAnUmV1bmlvbidcbn0sIHtcbiAga2V5OiAnUk8nLFxuICB2YWx1ZTogJ1JPJyxcbiAgZmxhZzogJ3JvJyxcbiAgdGV4dDogJ1JvbWFuaWEnXG59LCB7XG4gIGtleTogJ1JVJyxcbiAgdmFsdWU6ICdSVScsXG4gIGZsYWc6ICdydScsXG4gIHRleHQ6ICdSdXNzaWEnXG59LCB7XG4gIGtleTogJ1JXJyxcbiAgdmFsdWU6ICdSVycsXG4gIGZsYWc6ICdydycsXG4gIHRleHQ6ICdSd2FuZGEnXG59LCB7XG4gIGtleTogJ1NIJyxcbiAgdmFsdWU6ICdTSCcsXG4gIGZsYWc6ICdzaCcsXG4gIHRleHQ6ICdTYWludCBIZWxlbmEnXG59LCB7XG4gIGtleTogJ0tOJyxcbiAgdmFsdWU6ICdLTicsXG4gIGZsYWc6ICdrbicsXG4gIHRleHQ6ICdTYWludCBLaXR0cyBhbmQgTmV2aXMnXG59LCB7XG4gIGtleTogJ0xDJyxcbiAgdmFsdWU6ICdMQycsXG4gIGZsYWc6ICdsYycsXG4gIHRleHQ6ICdTYWludCBMdWNpYSdcbn0sIHtcbiAga2V5OiAnUE0nLFxuICB2YWx1ZTogJ1BNJyxcbiAgZmxhZzogJ3BtJyxcbiAgdGV4dDogJ1NhaW50IFBpZXJyZSdcbn0sIHtcbiAga2V5OiAnVkMnLFxuICB2YWx1ZTogJ1ZDJyxcbiAgZmxhZzogJ3ZjJyxcbiAgdGV4dDogJ1NhaW50IFZpbmNlbnQnXG59LCB7XG4gIGtleTogJ1dTJyxcbiAgdmFsdWU6ICdXUycsXG4gIGZsYWc6ICd3cycsXG4gIHRleHQ6ICdTYW1vYSdcbn0sIHtcbiAga2V5OiAnU00nLFxuICB2YWx1ZTogJ1NNJyxcbiAgZmxhZzogJ3NtJyxcbiAgdGV4dDogJ1NhbiBNYXJpbm8nXG59LCB7XG4gIGtleTogJ0dTJyxcbiAgdmFsdWU6ICdHUycsXG4gIGZsYWc6ICdncycsXG4gIHRleHQ6ICdTYW5kd2ljaCBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdTVCcsXG4gIHZhbHVlOiAnU1QnLFxuICBmbGFnOiAnc3QnLFxuICB0ZXh0OiAnU2FvIFRvbWUnXG59LCB7XG4gIGtleTogJ1NBJyxcbiAgdmFsdWU6ICdTQScsXG4gIGZsYWc6ICdzYScsXG4gIHRleHQ6ICdTYXVkaSBBcmFiaWEnXG59LCB7XG4gIGtleTogJ1NOJyxcbiAgdmFsdWU6ICdTTicsXG4gIGZsYWc6ICdzbicsXG4gIHRleHQ6ICdTZW5lZ2FsJ1xufSwge1xuICBrZXk6ICdDUycsXG4gIHZhbHVlOiAnQ1MnLFxuICBmbGFnOiAnY3MnLFxuICB0ZXh0OiAnU2VyYmlhJ1xufSwge1xuICBrZXk6ICdSUycsXG4gIHZhbHVlOiAnUlMnLFxuICBmbGFnOiAncnMnLFxuICB0ZXh0OiAnU2VyYmlhJ1xufSwge1xuICBrZXk6ICdTQycsXG4gIHZhbHVlOiAnU0MnLFxuICBmbGFnOiAnc2MnLFxuICB0ZXh0OiAnU2V5Y2hlbGxlcydcbn0sIHtcbiAga2V5OiAnU0wnLFxuICB2YWx1ZTogJ1NMJyxcbiAgZmxhZzogJ3NsJyxcbiAgdGV4dDogJ1NpZXJyYSBMZW9uZSdcbn0sIHtcbiAga2V5OiAnU0cnLFxuICB2YWx1ZTogJ1NHJyxcbiAgZmxhZzogJ3NnJyxcbiAgdGV4dDogJ1NpbmdhcG9yZSdcbn0sIHtcbiAga2V5OiAnU0snLFxuICB2YWx1ZTogJ1NLJyxcbiAgZmxhZzogJ3NrJyxcbiAgdGV4dDogJ1Nsb3Zha2lhJ1xufSwge1xuICBrZXk6ICdTSScsXG4gIHZhbHVlOiAnU0knLFxuICBmbGFnOiAnc2knLFxuICB0ZXh0OiAnU2xvdmVuaWEnXG59LCB7XG4gIGtleTogJ1NCJyxcbiAgdmFsdWU6ICdTQicsXG4gIGZsYWc6ICdzYicsXG4gIHRleHQ6ICdTb2xvbW9uIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ1NPJyxcbiAgdmFsdWU6ICdTTycsXG4gIGZsYWc6ICdzbycsXG4gIHRleHQ6ICdTb21hbGlhJ1xufSwge1xuICBrZXk6ICdaQScsXG4gIHZhbHVlOiAnWkEnLFxuICBmbGFnOiAnemEnLFxuICB0ZXh0OiAnU291dGggQWZyaWNhJ1xufSwge1xuICBrZXk6ICdLUicsXG4gIHZhbHVlOiAnS1InLFxuICBmbGFnOiAna3InLFxuICB0ZXh0OiAnU291dGggS29yZWEnXG59LCB7XG4gIGtleTogJ0VTJyxcbiAgdmFsdWU6ICdFUycsXG4gIGZsYWc6ICdlcycsXG4gIHRleHQ6ICdTcGFpbidcbn0sIHtcbiAga2V5OiAnTEsnLFxuICB2YWx1ZTogJ0xLJyxcbiAgZmxhZzogJ2xrJyxcbiAgdGV4dDogJ1NyaSBMYW5rYSdcbn0sIHtcbiAga2V5OiAnU0QnLFxuICB2YWx1ZTogJ1NEJyxcbiAgZmxhZzogJ3NkJyxcbiAgdGV4dDogJ1N1ZGFuJ1xufSwge1xuICBrZXk6ICdTUicsXG4gIHZhbHVlOiAnU1InLFxuICBmbGFnOiAnc3InLFxuICB0ZXh0OiAnU3VyaW5hbWUnXG59LCB7XG4gIGtleTogJ1NKJyxcbiAgdmFsdWU6ICdTSicsXG4gIGZsYWc6ICdzaicsXG4gIHRleHQ6ICdTdmFsYmFyZCdcbn0sIHtcbiAga2V5OiAnU1onLFxuICB2YWx1ZTogJ1NaJyxcbiAgZmxhZzogJ3N6JyxcbiAgdGV4dDogJ1N3YXppbGFuZCdcbn0sIHtcbiAga2V5OiAnU0UnLFxuICB2YWx1ZTogJ1NFJyxcbiAgZmxhZzogJ3NlJyxcbiAgdGV4dDogJ1N3ZWRlbidcbn0sIHtcbiAga2V5OiAnQ0gnLFxuICB2YWx1ZTogJ0NIJyxcbiAgZmxhZzogJ2NoJyxcbiAgdGV4dDogJ1N3aXR6ZXJsYW5kJ1xufSwge1xuICBrZXk6ICdTWScsXG4gIHZhbHVlOiAnU1knLFxuICBmbGFnOiAnc3knLFxuICB0ZXh0OiAnU3lyaWEnXG59LCB7XG4gIGtleTogJ1RXJyxcbiAgdmFsdWU6ICdUVycsXG4gIGZsYWc6ICd0dycsXG4gIHRleHQ6ICdUYWl3YW4nXG59LCB7XG4gIGtleTogJ1RKJyxcbiAgdmFsdWU6ICdUSicsXG4gIGZsYWc6ICd0aicsXG4gIHRleHQ6ICdUYWppa2lzdGFuJ1xufSwge1xuICBrZXk6ICdUWicsXG4gIHZhbHVlOiAnVFonLFxuICBmbGFnOiAndHonLFxuICB0ZXh0OiAnVGFuemFuaWEnXG59LCB7XG4gIGtleTogJ1RIJyxcbiAgdmFsdWU6ICdUSCcsXG4gIGZsYWc6ICd0aCcsXG4gIHRleHQ6ICdUaGFpbGFuZCdcbn0sIHtcbiAga2V5OiAnVEwnLFxuICB2YWx1ZTogJ1RMJyxcbiAgZmxhZzogJ3RsJyxcbiAgdGV4dDogJ1RpbW9ybGVzdGUnXG59LCB7XG4gIGtleTogJ1RHJyxcbiAgdmFsdWU6ICdURycsXG4gIGZsYWc6ICd0ZycsXG4gIHRleHQ6ICdUb2dvJ1xufSwge1xuICBrZXk6ICdUSycsXG4gIHZhbHVlOiAnVEsnLFxuICBmbGFnOiAndGsnLFxuICB0ZXh0OiAnVG9rZWxhdSdcbn0sIHtcbiAga2V5OiAnVE8nLFxuICB2YWx1ZTogJ1RPJyxcbiAgZmxhZzogJ3RvJyxcbiAgdGV4dDogJ1RvbmdhJ1xufSwge1xuICBrZXk6ICdUVCcsXG4gIHZhbHVlOiAnVFQnLFxuICBmbGFnOiAndHQnLFxuICB0ZXh0OiAnVHJpbmlkYWQnXG59LCB7XG4gIGtleTogJ1ROJyxcbiAgdmFsdWU6ICdUTicsXG4gIGZsYWc6ICd0bicsXG4gIHRleHQ6ICdUdW5pc2lhJ1xufSwge1xuICBrZXk6ICdUUicsXG4gIHZhbHVlOiAnVFInLFxuICBmbGFnOiAndHInLFxuICB0ZXh0OiAnVHVya2V5J1xufSwge1xuICBrZXk6ICdUTScsXG4gIHZhbHVlOiAnVE0nLFxuICBmbGFnOiAndG0nLFxuICB0ZXh0OiAnVHVya21lbmlzdGFuJ1xufSwge1xuICBrZXk6ICdUVicsXG4gIHZhbHVlOiAnVFYnLFxuICBmbGFnOiAndHYnLFxuICB0ZXh0OiAnVHV2YWx1J1xufSwge1xuICBrZXk6ICdVRycsXG4gIHZhbHVlOiAnVUcnLFxuICBmbGFnOiAndWcnLFxuICB0ZXh0OiAnVWdhbmRhJ1xufSwge1xuICBrZXk6ICdVQScsXG4gIHZhbHVlOiAnVUEnLFxuICBmbGFnOiAndWEnLFxuICB0ZXh0OiAnVWtyYWluZSdcbn0sIHtcbiAga2V5OiAnQUUnLFxuICB2YWx1ZTogJ0FFJyxcbiAgZmxhZzogJ2FlJyxcbiAgdGV4dDogJ1VuaXRlZCBBcmFiIEVtaXJhdGVzJ1xufSwge1xuICBrZXk6ICdVUycsXG4gIHZhbHVlOiAnVVMnLFxuICBmbGFnOiAndXMnLFxuICB0ZXh0OiAnVW5pdGVkIFN0YXRlcydcbn0sIHtcbiAga2V5OiAnVVknLFxuICB2YWx1ZTogJ1VZJyxcbiAgZmxhZzogJ3V5JyxcbiAgdGV4dDogJ1VydWd1YXknXG59LCB7XG4gIGtleTogJ1VNJyxcbiAgdmFsdWU6ICdVTScsXG4gIGZsYWc6ICd1bScsXG4gIHRleHQ6ICdVcyBNaW5vciBJc2xhbmRzJ1xufSwge1xuICBrZXk6ICdWSScsXG4gIHZhbHVlOiAnVkknLFxuICBmbGFnOiAndmknLFxuICB0ZXh0OiAnVXMgVmlyZ2luIElzbGFuZHMnXG59LCB7XG4gIGtleTogJ1VaJyxcbiAgdmFsdWU6ICdVWicsXG4gIGZsYWc6ICd1eicsXG4gIHRleHQ6ICdVemJla2lzdGFuJ1xufSwge1xuICBrZXk6ICdWVScsXG4gIHZhbHVlOiAnVlUnLFxuICBmbGFnOiAndnUnLFxuICB0ZXh0OiAnVmFudWF0dSdcbn0sIHtcbiAga2V5OiAnVkEnLFxuICB2YWx1ZTogJ1ZBJyxcbiAgZmxhZzogJ3ZhJyxcbiAgdGV4dDogJ1ZhdGljYW4gQ2l0eSdcbn0sIHtcbiAga2V5OiAnVkUnLFxuICB2YWx1ZTogJ1ZFJyxcbiAgZmxhZzogJ3ZlJyxcbiAgdGV4dDogJ1ZlbmV6dWVsYSdcbn0sIHtcbiAga2V5OiAnVk4nLFxuICB2YWx1ZTogJ1ZOJyxcbiAgZmxhZzogJ3ZuJyxcbiAgdGV4dDogJ1ZpZXRuYW0nXG59LCB7XG4gIGtleTogJ1dGJyxcbiAgdmFsdWU6ICdXRicsXG4gIGZsYWc6ICd3ZicsXG4gIHRleHQ6ICdXYWxsaXMgYW5kIEZ1dHVuYSdcbn0sIHtcbiAga2V5OiAnRUgnLFxuICB2YWx1ZTogJ0VIJyxcbiAgZmxhZzogJ2VoJyxcbiAgdGV4dDogJ1dlc3Rlcm4gU2FoYXJhJ1xufSwge1xuICBrZXk6ICdZRScsXG4gIHZhbHVlOiAnWUUnLFxuICBmbGFnOiAneWUnLFxuICB0ZXh0OiAnWWVtZW4nXG59LCB7XG4gIGtleTogJ1pNJyxcbiAgdmFsdWU6ICdaTScsXG4gIGZsYWc6ICd6bScsXG4gIHRleHQ6ICdaYW1iaWEnXG59LCB7XG4gIGtleTogJ1pXJyxcbiAgdmFsdWU6ICdaVycsXG4gIGZsYWc6ICd6dycsXG4gIHRleHQ6ICdaaW1iYWJ3ZSdcbn1dO1xuXG5mdW5jdGlvbiBmZXRjaEt5Y0NvdW50cmllcyhfeCkge1xuICByZXR1cm4gX2ZldGNoS3ljQ291bnRyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcclxuICogRkFJTEVEXHJcbiAqIFVOU1VCTUlUVEVEXHJcbiAqIFBFTkRJTkdcclxuICogUEFTU0VEXHJcbiAqL1xuXG5mdW5jdGlvbiBfZmV0Y2hLeWNDb3VudHJpZXMoKSB7XG4gIF9mZXRjaEt5Y0NvdW50cmllcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShfcmVmKSB7XG4gICAgdmFyIGNoYWluLCB1cmwsIF95aWVsZCR0aGlzJGdldCwgY291bnRyaWVzLCBjb3VudHJpZXNCeUlkO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2hhaW4gPSBfcmVmLmNoYWluO1xuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuQkxPS1NfQVBJICsgXCIvXCIgKyBjaGFpbiArIFwiL2t5Yz90eXBlPWNvdW50cmllcyZjaGFpbj1cIiArIGNoYWluO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBjb3VudHJpZXMgPSBfeWllbGQkdGhpcyRnZXQuY29udGVudDtcbiAgICAgICAgICAgIGNvdW50cmllc0J5SWQgPSBjb3VudHJpZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvdW50cnkpIHtcbiAgICAgICAgICAgICAgYWNjW2NvdW50cnkuaWRdID0gY291bnRyeTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY291bnRyeU9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChjb3VudHJ5T3B0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb3VudHJpZXNCeUlkW2NvdW50cnlPcHRpb24ua2V5XTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9mZXRjaEt5Y0NvdW50cmllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjaGVja1VzZXJLeWNTdGF0dXMoX3gyKSB7XG4gIHJldHVybiBfY2hlY2tVc2VyS3ljU3RhdHVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jaGVja1VzZXJLeWNTdGF0dXMoKSB7XG4gIF9jaGVja1VzZXJLeWNTdGF0dXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KF9yZWYyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBjaGFpbiwgYWN0b3IsIGV4cGVjdGVkVGllcjtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2hhaW4gPSBfcmVmMi5jaGFpbiwgYWN0b3IgPSBfcmVmMi5hY3RvciwgZXhwZWN0ZWRUaWVyID0gX3JlZjIuZXhwZWN0ZWRUaWVyO1xuXG4gICAgICAgICAgICBpZiAoISghY2hhaW4gfHwgIWFjdG9yIHx8ICFleHBlY3RlZFRpZXIpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXJzJyk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBuZXcgUHJvbWlzZSggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0U3RhdHVzO1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYWxsIEtZQyByZWNvcmRzIGZvciB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfeWllbGQkX3RoaXMkcnBjJGlzTGksIHVzZXJJbmZvLCB1cmwsIGt5YywgbWF0Y2hlZFRpZXIsIHN0YXR1cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucnBjLmlzTGlnaHRLWUNWZXJpZmllZChhY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfeWllbGQkX3RoaXMkcnBjJGlzTGkgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJbmZvID0gX3lpZWxkJF90aGlzJHJwYyRpc0xpWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh1c2VySW5mbyAmJiB1c2VySW5mby5pc0xpZ2h0S1lDVmVyaWZpZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc29sdmUoS3ljU3RhdHVzLlBBU1NFRCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gX3RoaXMuY29uc3RhbnRzLkJMT0tTX0FQSSArIFwiL1wiICsgY2hhaW4gKyBcIi9reWM/dHlwZT1zdGF0dXMmY2hhaW49XCIgKyBjaGFpbiArIFwiJmFjdG9yPVwiICsgYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0KHVybCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBreWMgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoIWt5YyB8fCAha3ljLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlamVjdChuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmZXRjaCBLWUMgcmVjb3JkJykpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHJlbGV2YW50IEtZQyByZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRUaWVyID0ga3ljLmZpbmQoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aWVyID0gX3JlZjUudGllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpZXIgPT09IFN0cmluZyhleHBlY3RlZFRpZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkVGllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVqZWN0KG5ldyBFcnJvcignTm8ga3ljIGRhdGEgbWF0Y2hpbmcgdGllciBmb3VuZCcpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW53cmFwIGt5YyBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBtYXRjaGVkVGllci5zdGF0dXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkVGllci5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlamVjdChuZXcgRXJyb3IoJ0tZQyBTdGF0dXMgbm90IGZvdW5kJykpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGF0dXMgPT09IEt5Y1N0YXR1cy5QRU5ESU5HKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDAgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXNvbHZlKHN0YXR1cykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFN0YXR1cygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTMpO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDQsIF94NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpKSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCk7XG4gIH0pKTtcbiAgcmV0dXJuIF9jaGVja1VzZXJLeWNTdGF0dXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlGb3JLeWMoX3gzKSB7XG4gIHJldHVybiBfYXBwbHlGb3JLeWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2FwcGx5Rm9yS3ljKCkge1xuICBfYXBwbHlGb3JLeWMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHBhcmFtcykge1xuICAgIHZhciB1cmwsIGRhdGE7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLkJMT0tTX0FQSSArIFwiL1wiICsgcGFyYW1zLmNoYWluICsgXCIva3ljXCI7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0KHVybCwgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICB0eXBlOiAnYXBwbHknXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgYXBwbHkgZm9yIEtZQycpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfYXBwbHlGb3JLeWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIGNoYWluSW5mb1BhcnNlciA9IC8qI19fUFVSRV9fKi96Lm9iamVjdCh7XG4gIGNoYWluSWQ6IC8qI19fUFVSRV9fKi96LnN0cmluZygpLFxuICBleHBsb3JlclVybDogLyojX19QVVJFX18qL3ouc3RyaW5nKCksXG4gIGV4cGxvcmVyTmFtZTogLyojX19QVVJFX18qL3ouc3RyaW5nKCksXG4gIHJlc291cmNlVG9rZW5TeW1ib2w6IC8qI19fUFVSRV9fKi96LnN0cmluZygpLFxuICByZXNvdXJjZVRva2VuQ29udHJhY3Q6IC8qI19fUFVSRV9fKi96LnN0cmluZygpLFxuICBzeXN0ZW1Ub2tlblN5bWJvbDogLyojX19QVVJFX18qL3ouc3RyaW5nKCksXG4gIHN5c3RlbVRva2VuQ29udHJhY3Q6IC8qI19fUFVSRV9fKi96LnN0cmluZygpLFxuICBycGNFbmRwb2ludHM6IC8qI19fUFVSRV9fKi96LmFycmF5KCAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSksXG4gIGFjdGlvbnNScGNFbmRwb2ludHM6IC8qI19fUFVSRV9fKi96LmFycmF5KCAvKiNfX1BVUkVfXyovei5zdHJpbmcoKSksXG4gIGh5cGVyaW9uRW5kcG9pbnRzOiAvKiNfX1BVUkVfXyovei5hcnJheSggLyojX19QVVJFX18qL3ouc3RyaW5nKCkpLFxuICBsaWdodEVuZHBvaW50czogLyojX19QVVJFX18qL3ouYXJyYXkoIC8qI19fUFVSRV9fKi96LnN0cmluZygpKVxufSk7XG5cbmZ1bmN0aW9uIGdldENoYWluSW5mbygpIHtcbiAgcmV0dXJuIF9nZXRDaGFpbkluZm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldENoYWluSW5mbygpIHtcbiAgX2dldENoYWluSW5mbyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICB2YXIgdXJsLCBkYXRhO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLkNIQUlOID09PSAncHJvdG9uLXRlc3QnID8gJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9Qcm90b25Qcm90b2NvbC9jaGFpbi1pbmZvL21haW4vdGVzdG5ldC5qc29uJyA6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vUHJvdG9uUHJvdG9jb2wvY2hhaW4taW5mby9tYWluL21haW5uZXQuanNvbic7XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCwge30pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNoYWluSW5mb1BhcnNlci5wYXJzZShkYXRhKSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMSwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldENoYWluSW5mby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRUb2tlblByaWNlcygpIHtcbiAgcmV0dXJuIF9nZXRUb2tlblByaWNlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0VG9rZW5QcmljZXMoKSB7XG4gIF9nZXRUb2tlblByaWNlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgdmFyIHVybCwgZGF0YTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuTUVUQUxfUFJPVE9OX0VORFBPSU5UICsgXCIvdjEvY2hhaW4vZXhjaGFuZ2UtcmF0ZXMvaW5mb1wiO1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBleGNoYW5nZVJhdGVzUGFyc2VyLnBhcnNlKGRhdGEpKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZldGNoIGV4Y2hhbmdlIHJhdGVzXCIpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzEsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRUb2tlblByaWNlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRXaXRoZHJhd2FsRmVlKF94KSB7XG4gIHJldHVybiBfZ2V0V2l0aGRyYXdhbEZlZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0V2l0aGRyYXdhbEZlZSgpIHtcbiAgX2dldFdpdGhkcmF3YWxGZWUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKF9yZWYpIHtcbiAgICB2YXIgY3VycmVuY3ksIG5ldHdvcmssIHVybCwgZGF0YTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY3VycmVuY3kgPSBfcmVmLmN1cnJlbmN5LCBuZXR3b3JrID0gX3JlZi5uZXR3b3JrO1xuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuTUVUQUxfUFJPVE9OX0VORFBPSU5UICsgXCIvdjEvc3dhcHMvY2FsY3VsYXRlLWVzdGltYXRlZC1mZWVcIjtcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QodXJsLCB7XG4gICAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB3aXRoZHJhd2FsRmVlUXVvdGVQYXJzZXIucGFyc2UoZGF0YSkpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSA5O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDMudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcywgW1syLCA5XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0V2l0aGRyYXdhbEZlZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjdXJyZW50TG9jYXRpb24oKSB7XG4gIHJldHVybiBfY3VycmVudExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jdXJyZW50TG9jYXRpb24oKSB7XG4gIF9jdXJyZW50TG9jYXRpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLk1FVEFMX1BST1RPTl9FTkRQT0lOVCArIFwiL3YxL2t5Yy9pcC1pbmZvXCI7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2N1cnJlbnRMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBdmFpbGFibGVGZWF0dXJlcyhfeDIpIHtcbiAgcmV0dXJuIF9nZXRBdmFpbGFibGVGZWF0dXJlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QXZhaWxhYmxlRmVhdHVyZXMoKSB7XG4gIF9nZXRBdmFpbGFibGVGZWF0dXJlcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoYWNjb3VudCkge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLk1FVEFMX1BST1RPTl9FTkRQT0lOVCArIChcIi92Mi9reWMvYnktY2hhaW4tYWNjb3VudC9cIiArIGFjY291bnQgKyBcIi9hdmFpbGFibGUtZmVhdHVyZXNcIik7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NS5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEF2YWlsYWJsZUZlYXR1cmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjY291bnQoX3gzKSB7XG4gIHJldHVybiBfY3JlYXRlQWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlQWNjb3VudCgpIHtcbiAgX2NyZWF0ZUFjY291bnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHBhcmFtcykge1xuICAgIHZhciB1cmwsIGRhdGE7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLk1FVEFMX1BST1RPTl9FTkRQT0lOVCArIFwiL3YyL3VzZXJzL2NyZWF0ZVwiO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdCh1cmwsIHBhcmFtcyk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2NyZWF0ZUFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbG9naW5BY2NvdW50KF94NCkge1xuICByZXR1cm4gX2xvZ2luQWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbG9naW5BY2NvdW50KCkge1xuICBfbG9naW5BY2NvdW50ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhwYXJhbXMpIHtcbiAgICB2YXIgdXJsLCBkYXRhO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5NRVRBTF9QUk9UT05fRU5EUE9JTlQgKyBcIi92Mi91c2Vycy9sb2dpblwiO1xuICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdCh1cmwsIHBhcmFtcyk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU3LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2xvZ2luQWNjb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBvdGNRdW90ZShfeCkge1xuICByZXR1cm4gX290Y1F1b3RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vdGNRdW90ZSgpIHtcbiAgX290Y1F1b3RlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGJvZHkpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLlNXQVBfVVJMICsgKFwiL3YxL3F1b3RlL1wiICsgYm9keS5iYXNlU3ltYm9sICsgXCIvXCIgKyBib2R5LmJhc2VBbW91bnQgKyBcIi9cIiArIGJvZHkucXVvdGVTeW1ib2wpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfb3RjUXVvdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gb3RjT3JkZXIoX3gyKSB7XG4gIHJldHVybiBfb3RjT3JkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX290Y09yZGVyKCkge1xuICBfb3RjT3JkZXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGlkKSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuU1dBUF9VUkwgKyAoXCIvdjEvb3JkZXIvXCIgKyBpZCk7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX290Y09yZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQWRkcmVzcyhfeCkge1xuICByZXR1cm4gX2dlbmVyYXRlQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVBZGRyZXNzKCkge1xuICBfZ2VuZXJhdGVBZGRyZXNzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGJvZHkpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLldSQVBfU0VSVkVSX1VSTCArICcvYWRkcmVzcy9nZW5lcmF0ZSc7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QodXJsLCBib2R5KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2VuZXJhdGVBZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZUFkZHJlc3MoX3gyKSB7XG4gIHJldHVybiBfZGVsZXRlQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZGVsZXRlQWRkcmVzcygpIHtcbiAgX2RlbGV0ZUFkZHJlc3MgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGJvZHkpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmNvbnN0YW50cy5XUkFQX1NFUlZFUl9VUkwgKyAnL2FkZHJlc3MvZGVsZXRlJztcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QodXJsLCBib2R5KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2RlbGV0ZUFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gd2l0aGRyYXdNZXRhbChfeDMpIHtcbiAgcmV0dXJuIF93aXRoZHJhd01ldGFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93aXRoZHJhd01ldGFsKCkge1xuICBfd2l0aGRyYXdNZXRhbCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYm9keSkge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHVybCA9IHRoaXMuY29uc3RhbnRzLldSQVBfU0VSVkVSX1VSTCArICcvd2l0aGRyYXcnO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdCh1cmwsIGJvZHkpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQzLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfd2l0aGRyYXdNZXRhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB3aXRoZHJhd2FsSGlzdG9yeU1ldGFsKF94NCkge1xuICByZXR1cm4gX3dpdGhkcmF3YWxIaXN0b3J5TWV0YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3dpdGhkcmF3YWxIaXN0b3J5TWV0YWwoKSB7XG4gIF93aXRoZHJhd2FsSGlzdG9yeU1ldGFsID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhY2NvdW50KSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXJsID0gdGhpcy5jb25zdGFudHMuV1JBUF9TRVJWRVJfVVJMICsgKFwiL3dpdGhkcmF3YWxzL1wiICsgYWNjb3VudCk7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX3dpdGhkcmF3YWxIaXN0b3J5TWV0YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0WHByVG90YWxTdGFrZWRBbmRBcHIoKSB7XG4gIHJldHVybiBfZ2V0WHByVG90YWxTdGFrZWRBbmRBcHIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFhwclRvdGFsU3Rha2VkQW5kQXByKCkge1xuICBfZ2V0WHByVG90YWxTdGFrZWRBbmRBcHIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIF95aWVsZCRQcm9taXNlJGFsbCwgc3VwcGx5LCB0b3RhbFN0YWtlZFVucGFyc2VkLCBfeWllbGQkUHJvbWlzZSRhbGwkLCBjb250aW51b3VzX3JhdGUsIGluZmxhdGlvbl9wYXlfZmFjdG9yLCB2b3RlcGF5X2ZhY3RvciwgYWRkaXRpb25hbEluZmxhdGlvbiwgbmV3X3Rva2VucywgdG9feWllbGRmYXJtcywgYnBhbmRzYXZpbmdzLCB0b19wcm9kdWNlcnMsIHRvX3Byb2R1Y2Vyc19ibG9jaywgdG9fcHJvZHVjZXJzX3ZvdGUsIHNhdmluZ3MsIHRvX3NhdmluZ3MsIHRvX2NvbnNvcnRpdW0sIHRvdGFsU3Rha2VkLCBhcHI7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLmdldFRva2VuU3VwcGx5KHRoaXMuY29uc3RhbnRzLkVPU0lPX1RPS0VOLCB0aGlzLmNvbnN0YW50cy5DT1JFX1NZTUJPTCksIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdnbG9iYWxzZCcsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yb3dzWzBdO1xuICAgICAgICAgICAgfSksIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdnbG9iYWw0JyxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzLnJvd3NbMF07XG4gICAgICAgICAgICB9KV0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJFByb21pc2UkYWxsID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHN1cHBseSA9IF95aWVsZCRQcm9taXNlJGFsbFswXS5zdXBwbHk7XG4gICAgICAgICAgICB0b3RhbFN0YWtlZFVucGFyc2VkID0gX3lpZWxkJFByb21pc2UkYWxsWzFdLnRvdGFscnN0YWtlZDtcbiAgICAgICAgICAgIF95aWVsZCRQcm9taXNlJGFsbCQgPSBfeWllbGQkUHJvbWlzZSRhbGxbMl07XG4gICAgICAgICAgICBjb250aW51b3VzX3JhdGUgPSBfeWllbGQkUHJvbWlzZSRhbGwkLmNvbnRpbnVvdXNfcmF0ZTtcbiAgICAgICAgICAgIGluZmxhdGlvbl9wYXlfZmFjdG9yID0gX3lpZWxkJFByb21pc2UkYWxsJC5pbmZsYXRpb25fcGF5X2ZhY3RvcjtcbiAgICAgICAgICAgIHZvdGVwYXlfZmFjdG9yID0gX3lpZWxkJFByb21pc2UkYWxsJC52b3RlcGF5X2ZhY3RvcjtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxJbmZsYXRpb24gPSArY29udGludW91c19yYXRlICogc3VwcGx5O1xuICAgICAgICAgICAgbmV3X3Rva2VucyA9IGFkZGl0aW9uYWxJbmZsYXRpb247XG4gICAgICAgICAgICB0b195aWVsZGZhcm1zID0gbmV3X3Rva2VucyAvIDQ7XG4gICAgICAgICAgICBicGFuZHNhdmluZ3MgPSBuZXdfdG9rZW5zIC0gdG9feWllbGRmYXJtcztcbiAgICAgICAgICAgIHRvX3Byb2R1Y2VycyA9IGJwYW5kc2F2aW5ncyAqICgxMDAwMCAvIGluZmxhdGlvbl9wYXlfZmFjdG9yKTtcbiAgICAgICAgICAgIHRvX3Byb2R1Y2Vyc19ibG9jayA9IHRvX3Byb2R1Y2VycyAqICgxMDAwMCAvIHZvdGVwYXlfZmFjdG9yKTtcbiAgICAgICAgICAgIHRvX3Byb2R1Y2Vyc192b3RlID0gdG9fcHJvZHVjZXJzIC0gdG9fcHJvZHVjZXJzX2Jsb2NrO1xuICAgICAgICAgICAgc2F2aW5ncyA9IGJwYW5kc2F2aW5ncyAtIHRvX3Byb2R1Y2VycztcbiAgICAgICAgICAgIHRvX3NhdmluZ3MgPSAyICogc2F2aW5ncyAvIDM7XG4gICAgICAgICAgICB0b19jb25zb3J0aXVtID0gc2F2aW5ncyAtIHRvX3NhdmluZ3M7XG4gICAgICAgICAgICB0b3RhbFN0YWtlZCA9ICt0b3RhbFN0YWtlZFVucGFyc2VkIC8gTWF0aC5wb3coMTAsIHRoaXMuY29uc3RhbnRzLkNPUkVfUFJFQ0lTSU9OKTtcbiAgICAgICAgICAgIGFwciA9IHRvX3NhdmluZ3MgLyB0b3RhbFN0YWtlZCAqIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBzdXBwbHk6IHN1cHBseSxcbiAgICAgICAgICAgICAgeWllbGRGYXJtaW5nOiB0b195aWVsZGZhcm1zLFxuICAgICAgICAgICAgICBwcm9kdWNlcnM6IHRvX3Byb2R1Y2VycyxcbiAgICAgICAgICAgICAgcHJvZHVjZXJzQmxvY2s6IHRvX3Byb2R1Y2Vyc19ibG9jayxcbiAgICAgICAgICAgICAgcHJvZHVjZXJzVm90ZTogdG9fcHJvZHVjZXJzX3ZvdGUsXG4gICAgICAgICAgICAgIGNvbnNvcnRpdW06IHRvX2NvbnNvcnRpdW0sXG4gICAgICAgICAgICAgIHN0YWtpbmc6IHRvX3NhdmluZ3MsXG4gICAgICAgICAgICAgIHRvdGFsU3Rha2VkOiB0b3RhbFN0YWtlZCxcbiAgICAgICAgICAgICAgYXByOiBhcHJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNTtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgMCk7XG5cbiAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDI1XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0WHByVG90YWxTdGFrZWRBbmRBcHIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0WHByVm90ZXIoX3gpIHtcbiAgcmV0dXJuIF9nZXRYcHJWb3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0WHByVm90ZXIoKSB7XG4gIF9nZXRYcHJWb3RlciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB0YWJsZTogJ3ZvdGVyc3hwcicsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoICYmIHJvd3NbMF0ub3duZXIgPT09IGFjY291bnQpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMjtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQyLnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbMCwgMTJdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRYcHJWb3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRYcHJBY2NvdW50U3Rha2VzKF94Mikge1xuICByZXR1cm4gX2dldFhwckFjY291bnRTdGFrZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFhwckFjY291bnRTdGFrZXMoKSB7XG4gIF9nZXRYcHJBY2NvdW50U3Rha2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhY2NvdW50KSB7XG4gICAgdmFyIHN0YWtlcywgX3lpZWxkJHRoaXMkcnBjJGdldF90Miwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBzdGFrZXMgPSBbXTtcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHRhYmxlOiAnZGVseHByJyxcbiAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLnJvd3M7XG5cbiAgICAgICAgICAgIGlmIChyb3dzICYmIHJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN0YWtlcyA9IHJvd3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gOTtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBzdGFrZXMpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzEsIDldXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRYcHJBY2NvdW50U3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFhwckFjY291bnRSZWZ1bmQoX3gzKSB7XG4gIHJldHVybiBfZ2V0WHByQWNjb3VudFJlZnVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0WHByQWNjb3VudFJlZnVuZCgpIHtcbiAgX2dldFhwckFjY291bnRSZWZ1bmQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGFjY291bnQpIHtcbiAgICB2YXIgcmVmdW5kLCBfeWllbGQkdGhpcyRycGMkZ2V0X3QzLCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIHRhYmxlOiAncmVmdW5kc3hwcicsXG4gICAgICAgICAgICAgIGxpbWl0OiAtMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QzID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90My5yb3dzO1xuXG4gICAgICAgICAgICBpZiAocm93cyAmJiByb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZWZ1bmQgPSByb3dzWzBdO1xuICAgICAgICAgICAgICByZWZ1bmQucXVhbnRpdHkgPSArcmVmdW5kLnF1YW50aXR5LnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IF9jb250ZXh0NFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ0LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByZWZ1bmQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzAsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRYcHJBY2NvdW50UmVmdW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFhwck9yYWNsZURhdGEoX3g0KSB7XG4gIHJldHVybiBfZ2V0WHByT3JhY2xlRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0WHByT3JhY2xlRGF0YSgpIHtcbiAgX2dldFhwck9yYWNsZURhdGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KG9yYWNsZUluZGV4KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDQsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ29yYWNsZXMnLFxuICAgICAgICAgICAgICBzY29wZTogJ29yYWNsZXMnLFxuICAgICAgICAgICAgICB0YWJsZTogJ2RhdGEnLFxuICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IG9yYWNsZUluZGV4LFxuICAgICAgICAgICAgICB1cHBlcl9ib3VuZDogb3JhY2xlSW5kZXhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NCA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDQucm93cztcblxuICAgICAgICAgICAgaWYgKCEocm93cyAmJiByb3dzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDEyO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDUudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1swLCAxMl1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFhwck9yYWNsZURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxsT3JhY2xlRmVlZHMoX3g1KSB7XG4gIHJldHVybiBfZ2V0QWxsT3JhY2xlRmVlZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFsbE9yYWNsZUZlZWRzKCkge1xuICBfZ2V0QWxsT3JhY2xlRmVlZHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGxvd2VyX2JvdW5kKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDUsIHJvd3MsIG1vcmUsIG5leHRfa2V5LCByZXN0T2ZSb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChsb3dlcl9ib3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnb3JhY2xlcycsXG4gICAgICAgICAgICAgIHNjb3BlOiAnb3JhY2xlcycsXG4gICAgICAgICAgICAgIHRhYmxlOiAnZmVlZHMnLFxuICAgICAgICAgICAgICBsaW1pdDogLTEsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBsb3dlcl9ib3VuZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1ID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90NS5yb3dzO1xuICAgICAgICAgICAgbW9yZSA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDUubW9yZTtcbiAgICAgICAgICAgIG5leHRfa2V5ID0gX3lpZWxkJHRoaXMkcnBjJGdldF90NS5uZXh0X2tleTtcblxuICAgICAgICAgICAgaWYgKCFtb3JlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsT3JhY2xlRmVlZHMobmV4dF9rZXkpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJlc3RPZlJvd3MgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MuY29uY2F0KHJlc3RPZlJvd3MpKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDIyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxODtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NltcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ2LnQwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNiwgdGhpcywgW1sxLCAxOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFsbE9yYWNsZUZlZWRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFNwZWNpZmljT3JhY2xlRGF0YShfeDYpIHtcbiAgcmV0dXJuIF9nZXRTcGVjaWZpY09yYWNsZURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0gLy8gcHViXG5cbmZ1bmN0aW9uIF9nZXRTcGVjaWZpY09yYWNsZURhdGEoKSB7XG4gIF9nZXRTcGVjaWZpY09yYWNsZURhdGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KGZlZWRfaW5kZXgpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Niwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiAnb3JhY2xlcycsXG4gICAgICAgICAgICAgIHNjb3BlOiAnb3JhY2xlcycsXG4gICAgICAgICAgICAgIHRhYmxlOiAnZGF0YScsXG4gICAgICAgICAgICAgIGxpbWl0OiAtMSxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGZlZWRfaW5kZXgsXG4gICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiBmZWVkX2luZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDYgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q2LnJvd3M7XG5cbiAgICAgICAgICAgIGlmICghKHJvd3MgJiYgcm93cy5sZW5ndGggJiYgcm93c1swXS5mZWVkX2luZGV4ID09PSBmZWVkX2luZGV4KSkge1xuICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gOTtcbiAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ3LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU3LCB0aGlzLCBbWzAsIDldXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRTcGVjaWZpY09yYWNsZURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxsT3JhY2xlRGF0YShfeDcpIHtcbiAgcmV0dXJuIF9nZXRBbGxPcmFjbGVEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBbGxPcmFjbGVEYXRhKCkge1xuICBfZ2V0QWxsT3JhY2xlRGF0YSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgobG93ZXJfYm91bmQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Nywgcm93cywgbW9yZSwgbmV4dF9rZXk7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogJ29yYWNsZXMnLFxuICAgICAgICAgICAgICBzY29wZTogJ29yYWNsZXMnLFxuICAgICAgICAgICAgICB0YWJsZTogJ2RhdGEnLFxuICAgICAgICAgICAgICBsaW1pdDogLTEsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBsb3dlcl9ib3VuZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q3ID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Ny5yb3dzO1xuICAgICAgICAgICAgbW9yZSA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDcubW9yZTtcbiAgICAgICAgICAgIG5leHRfa2V5ID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Ny5uZXh0X2tleTtcblxuICAgICAgICAgICAgaWYgKCFtb3JlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDgudDAgPSByb3dzO1xuICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbE9yYWNsZURhdGEobmV4dF9rZXkpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0OC50MSA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF9jb250ZXh0OC50MC5jb25jYXQuY2FsbChfY29udGV4dDgudDAsIF9jb250ZXh0OC50MSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAxNjtcbiAgICAgICAgICAgIF9jb250ZXh0OC50MiA9IF9jb250ZXh0OFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ4LnQyKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlOCwgdGhpcywgW1swLCAxNl1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFsbE9yYWNsZURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdG9uQXZhdGFycyhfeDgsIF94OSkge1xuICByZXR1cm4gX2dldFByb3RvbkF2YXRhcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvbkF2YXRhcnMoKSB7XG4gIF9nZXRQcm90b25BdmF0YXJzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOShhY2NvdW50LCBsaW1pdCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGxpbWl0ID0gMTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKHRoaXMuY29uc3RhbnRzLkNIQUlOLmluZGV4T2YoJ3Byb3RvbicpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0OS5wcmV2ID0gMjtcbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6ICdlb3Npby5wcm90b24nLFxuICAgICAgICAgICAgICBzY29wZTogJ2Vvc2lvLnByb3RvbicsXG4gICAgICAgICAgICAgIHRhYmxlOiAndXNlcnNpbmZvJyxcbiAgICAgICAgICAgICAgdGFibGVfa2V5OiAnJyxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpNjQnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogZW5jb2RlTmFtZShhY2NvdW50LCBmYWxzZSksXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAxLFxuICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCByZXN1bHQucm93cyk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dDkucHJldiA9IDk7XG4gICAgICAgICAgICBfY29udGV4dDkudDAgPSBfY29udGV4dDlbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXRQcm90b25BdmF0YXIgZXJyb3InLCBfY29udGV4dDkudDApO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlOSwgdGhpcywgW1syLCA5XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UHJvdG9uQXZhdGFycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm90b25BdmF0YXIoX3gxMCkge1xuICByZXR1cm4gX2dldFByb3RvbkF2YXRhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG9uQXZhdGFyKCkge1xuICBfZ2V0UHJvdG9uQXZhdGFyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoYWNjb3VudCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh0aGlzLmNvbnN0YW50cy5DSEFJTi5pbmRleE9mKCdwcm90b24nKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gMTtcbiAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiAnZW9zaW8ucHJvdG9uJyxcbiAgICAgICAgICAgICAgc2NvcGU6ICdlb3Npby5wcm90b24nLFxuICAgICAgICAgICAgICB0YWJsZTogJ3VzZXJzaW5mbycsXG4gICAgICAgICAgICAgIHRhYmxlX2tleTogJycsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogMSxcbiAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQxMC5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdC5yb3dzLmxlbmd0aCA+IDAgJiYgcmVzdWx0LnJvd3NbMF0uYWNjID09PSBhY2NvdW50ID8gcmVzdWx0LnJvd3NbMF0gOiB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0MTAudDAgPSBfY29udGV4dDEwW1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ2V0UHJvdG9uQXZhdGFyIGVycm9yJywgX2NvbnRleHQxMC50MCk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUxMCwgdGhpcywgW1sxLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UHJvdG9uQXZhdGFyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbnRid1N0YXRlKCkge1xuICByZXR1cm4gX2dldFJlbnRid1N0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZW50YndTdGF0ZSgpIHtcbiAgX2dldFJlbnRid1N0YXRlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogMCxcbiAgICAgICAgICAgICAgdGFibGU6ICdwb3d1cC5zdGF0ZScsXG4gICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90LnJvd3M7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJvd3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJlbnRid1N0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGRlbGVnYXRlZEJhbmR3aWR0aChfeCwgX3gyKSB7XG4gIHJldHVybiBfZGVsZWdhdGVkQmFuZHdpZHRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9kZWxlZ2F0ZWRCYW5kd2lkdGgoKSB7XG4gIF9kZWxlZ2F0ZWRCYW5kd2lkdGggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGFjY291bnQsIGxvd2VyX2JvdW5kKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgdGFibGU6ICdkZWxiYW5kJyxcbiAgICAgICAgICAgICAgdGFibGVfa2V5OiAnJyxcbiAgICAgICAgICAgICAgbGltaXQ6IC0xLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogbG93ZXJfYm91bmQsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDFcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2RlbGVnYXRlZEJhbmR3aWR0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBY2NvdW50RGVsZWdhdGVkQmFuZHdpZHRoKF94Mykge1xuICByZXR1cm4gX2dldEFjY291bnREZWxlZ2F0ZWRCYW5kd2lkdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjY291bnREZWxlZ2F0ZWRCYW5kd2lkdGgoKSB7XG4gIF9nZXRBY2NvdW50RGVsZWdhdGVkQmFuZHdpZHRoID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhY2NvdW50KSB7XG4gICAgdmFyIG1vcmUsIHJvd3MsIHJlc3VsdCwgbG93ZXJfYm91bmQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG1vcmUgPSB0cnVlO1xuICAgICAgICAgICAgcm93cyA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxvd2VyX2JvdW5kID0gJyc7XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDQ7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZWRCYW5kd2lkdGgoYWNjb3VudCwgbG93ZXJfYm91bmQpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBtb3JlID0gcmVzdWx0Lm1vcmU7XG4gICAgICAgICAgICByb3dzID0gcm93cy5jb25jYXQocmVzdWx0LnJvd3MpO1xuXG4gICAgICAgICAgICBpZiAobW9yZSkge1xuICAgICAgICAgICAgICBsb3dlcl9ib3VuZCA9IG5ldyBCaWdOdW1iZXIoZW5jb2RlTmFtZShyb3dzW3Jvd3MubGVuZ3RoIC0gMV0udG8sIGZhbHNlKSkucGx1cygxKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGlmIChtb3JlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTQ7XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbNCwgMTRdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY2NvdW50RGVsZWdhdGVkQmFuZHdpZHRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjY291bnRSZXNvdXJjZXMoX3g0KSB7XG4gIHJldHVybiBfZ2V0QWNjb3VudFJlc291cmNlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QWNjb3VudFJlc291cmNlcygpIHtcbiAgX2dldEFjY291bnRSZXNvdXJjZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90Miwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICB0YWJsZTogJ3VzZXJyZXMnLFxuICAgICAgICAgICAgICB0YWJsZV9rZXk6ICcnLFxuICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QyID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Mi5yb3dzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93c1swXSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY2NvdW50UmVzb3VyY2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJhbVByaWNlSW5Fb3MoKSB7XG4gIHJldHVybiBfZ2V0UmFtUHJpY2VJbkVvcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmFtUHJpY2VJbkVvcygpIHtcbiAgX2dldFJhbVByaWNlSW5Fb3MgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgIHZhciByYW0sIGJhc2VTdHJpbmcsIGJhc2UsIHF1b3RlU3RyaW5nLCBxdW90ZSwgcHJpY2UsIHJhbVByaWNlRW9zO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ3JhbW1hcmtldCcsXG4gICAgICAgICAgICAgIHRhYmxlX2tleTogJycsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByYW0gPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIC8vIEFtb3VudCBvZiBSQU0gYnl0ZXMgaW4gdXNlXG4gICAgICAgICAgICBiYXNlU3RyaW5nID0gcmFtLnJvd3NbMF0uYmFzZS5iYWxhbmNlO1xuICAgICAgICAgICAgYmFzZSA9ICtiYXNlU3RyaW5nLnN1YnN0cigwLCBiYXNlU3RyaW5nLmluZGV4T2YoJyAnKSk7IC8vIEFtb3VudCBvZiBFT1MgaW4gdGhlIFJBTSBjb2xsZWN0b3JcblxuICAgICAgICAgICAgcXVvdGVTdHJpbmcgPSByYW0ucm93c1swXS5xdW90ZS5iYWxhbmNlO1xuICAgICAgICAgICAgcXVvdGUgPSBxdW90ZVN0cmluZy5zdWJzdHIoMCwgcXVvdGVTdHJpbmcuaW5kZXhPZignICcpKTsgLy8gUHJpY2UgaW4ga2JcblxuICAgICAgICAgICAgcHJpY2UgPSBxdW90ZSAvIGJhc2U7XG4gICAgICAgICAgICByYW1QcmljZUVvcyA9IE51bWJlcihwcmljZS50b0ZpeGVkKDgpKSAqIDEwMjQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByYW1QcmljZUVvcyk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxMztcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQ1LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCAwKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1swLCAxM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJhbVByaWNlSW5Fb3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW9zVG9wU3Rha2VzKF94KSB7XG4gIHJldHVybiBfZ2V0RW9zVG9wU3Rha2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRFb3NUb3BTdGFrZXMoKSB7XG4gIF9nZXRFb3NUb3BTdGFrZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobGltaXQpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBsaW1pdCA9IDUwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0aGlzLmxpZ2h0QXBpLmdldF90b3BzdGFrZShsaW1pdCkpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEVvc1RvcFN0YWtlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRFb3NUb3BSYW1zKF94Mikge1xuICByZXR1cm4gX2dldEVvc1RvcFJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEVvc1RvcFJhbXMoKSB7XG4gIF9nZXRFb3NUb3BSYW1zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihsaW1pdCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBsaW1pdCA9IDUwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5saWdodEFwaS5nZXRfdG9wcmFtKGxpbWl0KSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRFb3NUb3BSYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnROYW1lQmlkcyhfeDMsIF94NCkge1xuICByZXR1cm4gX2dldEN1cnJlbnROYW1lQmlkcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q3VycmVudE5hbWVCaWRzKCkge1xuICBfZ2V0Q3VycmVudE5hbWVCaWRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkcnBjJGdldF90LCByb3dzLCBtb3JlLCBuZXh0X2tleTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAobG93ZXJfYm91bmQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBsb3dlcl9ib3VuZCA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXBwZXJfYm91bmQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB1cHBlcl9ib3VuZCA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ25hbWViaWRzJyxcbiAgICAgICAgICAgICAga2V5X3R5cGU6ICdpNjQnLFxuICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogbG93ZXJfYm91bmQgJiYgbG93ZXJfYm91bmQubGVuZ3RoIDw9IDEyID8gZW5jb2RlTmFtZShsb3dlcl9ib3VuZCwgdHJ1ZSkgOiBsb3dlcl9ib3VuZCxcbiAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6IHVwcGVyX2JvdW5kICYmIHVwcGVyX2JvdW5kLmxlbmd0aCA8PSAxMiA/IGVuY29kZU5hbWUodXBwZXJfYm91bmQsIHRydWUpIDogdXBwZXJfYm91bmQsXG4gICAgICAgICAgICAgIGluZGV4X3Bvc2l0aW9uOiAxLFxuICAgICAgICAgICAgICBsaW1pdDogLTFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90ID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90LnJvd3M7XG4gICAgICAgICAgICBtb3JlID0gX3lpZWxkJHRoaXMkcnBjJGdldF90Lm1vcmU7XG4gICAgICAgICAgICBuZXh0X2tleSA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5uZXh0X2tleTtcblxuICAgICAgICAgICAgaWYgKCFtb3JlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSByb3dzO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnROYW1lQmlkcyhuZXh0X2tleSwgdXBwZXJfYm91bmQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0My50MSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF9jb250ZXh0My50MC5jb25jYXQuY2FsbChfY29udGV4dDMudDAsIF9jb250ZXh0My50MSk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0Q3VycmVudE5hbWVCaWRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBjaGFpblRvUmV4TWFwID0ge1xuICBqdW5nbGU6ICdqdW5nbGUnLFxuICBib3M6ICdib3MnLFxuICBlb3M6ICdtYWlubmV0JyxcbiAgdGVsb3M6ICd0ZWxvcydcbn07XG5mdW5jdGlvbiBnZXRSZXhRdWV1ZWQoX3gpIHtcbiAgcmV0dXJuIF9nZXRSZXhRdWV1ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJleFF1ZXVlZCgpIHtcbiAgX2dldFJleFF1ZXVlZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdCwgcm93cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ3JleHF1ZXVlJyxcbiAgICAgICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdC5yb3dzO1xuXG4gICAgICAgICAgICBpZiAoIShyb3dzICYmIHJvd3MubGVuZ3RoICYmIHJvd3NbMF0ub3duZXIgPT09IGFjY291bnQpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByb3dzWzBdKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDk7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCA5XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmV4UXVldWVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJleFBvb2woKSB7XG4gIHJldHVybiBfZ2V0UmV4UG9vbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmV4UG9vbCgpIHtcbiAgX2dldFJleFBvb2wgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLCByb3dzLCBwb29sLCBhc3NldFRvTnVtYmVyLCB0b3RhbF9sZW50LCB0b3RhbF9sZW5kYWJsZSwgdG90YWxfdW5sZW50LCB0b3RhbF9yZXgsIHRvdGFsX3JlbnQsIGxlbnRfcGVyY2VudCwgcmV4X3ByaWNlLCByZXNvdXJjZV9wcmljZTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ3JleHBvb2wnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3QyLnJvd3M7XG4gICAgICAgICAgICBwb29sID0gcm93c1swXTtcblxuICAgICAgICAgICAgYXNzZXRUb051bWJlciA9IGZ1bmN0aW9uIGFzc2V0VG9OdW1iZXIoYXNzZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihhc3NldC5zcGxpdCgnICcpWzBdKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRvdGFsX2xlbnQgPSBhc3NldFRvTnVtYmVyKHBvb2wudG90YWxfbGVudCk7XG4gICAgICAgICAgICB0b3RhbF9sZW5kYWJsZSA9IGFzc2V0VG9OdW1iZXIocG9vbC50b3RhbF9sZW5kYWJsZSk7XG4gICAgICAgICAgICB0b3RhbF91bmxlbnQgPSBhc3NldFRvTnVtYmVyKHBvb2wudG90YWxfdW5sZW50KTtcbiAgICAgICAgICAgIHRvdGFsX3JleCA9IGFzc2V0VG9OdW1iZXIocG9vbC50b3RhbF9yZXgpO1xuICAgICAgICAgICAgdG90YWxfcmVudCA9IGFzc2V0VG9OdW1iZXIocG9vbC50b3RhbF9yZW50KTtcbiAgICAgICAgICAgIGxlbnRfcGVyY2VudCA9IG11bHRpcGx5KGRpdmlkZSh0b3RhbF9sZW50LCB0b3RhbF9sZW5kYWJsZSksIDEwMCk7XG4gICAgICAgICAgICByZXhfcHJpY2UgPSArZGl2aWRlKHRvdGFsX2xlbmRhYmxlLCB0b3RhbF9yZXgpO1xuICAgICAgICAgICAgcmVzb3VyY2VfcHJpY2UgPSArZGl2aWRlKHRvdGFsX3VubGVudCwgdG90YWxfcmVudCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICB2ZXJzaW9uOiBwb29sLnZlcnNpb24sXG4gICAgICAgICAgICAgIG5hbWViaWRfcHJvY2VlZHM6IGFzc2V0VG9OdW1iZXIocG9vbC5uYW1lYmlkX3Byb2NlZWRzKSxcbiAgICAgICAgICAgICAgbG9hbl9udW06IHBvb2wubG9hbl9udW0sXG4gICAgICAgICAgICAgIHRvdGFsX2xlbnQ6IHRvdGFsX2xlbnQsXG4gICAgICAgICAgICAgIHRvdGFsX3VubGVudDogdG90YWxfdW5sZW50LFxuICAgICAgICAgICAgICB0b3RhbF9yZW50OiB0b3RhbF9yZW50LFxuICAgICAgICAgICAgICB0b3RhbF9sZW5kYWJsZTogdG90YWxfbGVuZGFibGUsXG4gICAgICAgICAgICAgIHRvdGFsX3JleDogdG90YWxfcmV4LFxuICAgICAgICAgICAgICBsZW50X3BlcmNlbnQ6IGxlbnRfcGVyY2VudCxcbiAgICAgICAgICAgICAgcmV4X3ByaWNlOiByZXhfcHJpY2UsXG4gICAgICAgICAgICAgIHJlc291cmNlX3ByaWNlOiByZXNvdXJjZV9wcmljZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmV4UG9vbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXhCYWxhbmNlKF94Mikge1xuICByZXR1cm4gX2dldFJleEJhbGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJleEJhbGFuY2UoKSB7XG4gIF9nZXRSZXhCYWxhbmNlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDMsIHJvd3MsIGJhbDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0X3RhYmxlX3Jvd3Moe1xuICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICB0YWJsZTogJ3JleGJhbCcsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3QzID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90My5yb3dzO1xuICAgICAgICAgICAgYmFsID0gcm93c1swXTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIGJhbC5vd25lciA9PT0gYWNjb3VudCA/IGJhbCA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZXhCYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJleENwdUxvYW5zKF94Mykge1xuICByZXR1cm4gX2dldFJleENwdUxvYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXhDcHVMb2FucygpIHtcbiAgX2dldFJleENwdUxvYW5zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfdDQsIHJvd3M7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdjcHVsb2FuJyxcbiAgICAgICAgICAgICAgdGFibGVfa2V5OiAnYnlvd25lcicsXG4gICAgICAgICAgICAgIGtleV90eXBlOiAnaTY0JyxcbiAgICAgICAgICAgICAgbGltaXQ6IDEwMCxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpLFxuICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogM1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfeWllbGQkdGhpcyRycGMkZ2V0X3Q0ID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByb3dzID0gX3lpZWxkJHRoaXMkcnBjJGdldF90NC5yb3dzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gcm93LmZyb20gPT09IGFjY291bnQ7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZXhDcHVMb2Fucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXhOZXRMb2FucyhfeDQpIHtcbiAgcmV0dXJuIF9nZXRSZXhOZXRMb2Fucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmV4TmV0TG9hbnMoKSB7XG4gIF9nZXRSZXhOZXRMb2FucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q1LCByb3dzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29uc3RhbnRzLkVPU0lPLFxuICAgICAgICAgICAgICBzY29wZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHRhYmxlOiAnbmV0bG9hbicsXG4gICAgICAgICAgICAgIHRhYmxlX2tleTogJ2J5b3duZXInLFxuICAgICAgICAgICAgICBrZXlfdHlwZTogJ2k2NCcsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMDAsXG4gICAgICAgICAgICAgIGxvd2VyX2JvdW5kOiBlbmNvZGVOYW1lKGFjY291bnQsIGZhbHNlKSxcbiAgICAgICAgICAgICAgaW5kZXhfcG9zaXRpb246IDNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF90NSA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgcm93cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfdDUucm93cztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5mcm9tID09PSBhY2NvdW50O1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmV4TmV0TG9hbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW9zRGVwb3NpdGVkSW50b1JleChfeDUpIHtcbiAgcmV0dXJuIF9nZXRFb3NEZXBvc2l0ZWRJbnRvUmV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRFb3NEZXBvc2l0ZWRJbnRvUmV4KCkge1xuICBfZ2V0RW9zRGVwb3NpdGVkSW50b1JleCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoYWNjb3VudCkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X3Q2LCByb3dzLCByb3c7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgICAgICAgY29kZTogdGhpcy5jb25zdGFudHMuRU9TSU8sXG4gICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbnN0YW50cy5FT1NJTyxcbiAgICAgICAgICAgICAgdGFibGU6ICdyZXhmdW5kJyxcbiAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGVuY29kZU5hbWUoYWNjb3VudCwgZmFsc2UpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfdDYgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIHJvd3MgPSBfeWllbGQkdGhpcyRycGMkZ2V0X3Q2LnJvd3M7XG4gICAgICAgICAgICByb3cgPSByb3dzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93Lm93bmVyID09PSBhY2NvdW50ID8gTnVtYmVyKHJvdy5iYWxhbmNlLnNwbGl0KCcgJylbMF0pIDogMCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRFb3NEZXBvc2l0ZWRJbnRvUmV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJleFJldHVyblJhdGUoX3g2KSB7XG4gIHJldHVybiBfZ2V0UmV4UmV0dXJuUmF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmV4UmV0dXJuUmF0ZSgpIHtcbiAgX2dldFJleFJldHVyblJhdGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHR5cGUpIHtcbiAgICB2YXIgY2hhaW4sIF95aWVsZCR0aGlzJHBvc3QsIGRhdGE7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0eXBlID0gJ21wcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYWluID0gY2hhaW5Ub1JleE1hcFt0aGlzLmNvbnN0YW50cy5DSEFJTl07XG5cbiAgICAgICAgICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QoJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9ncmFwaHFsL3YxYWxwaGExL2dyYXBocWwnLCB7XG4gICAgICAgICAgICAgIHF1ZXJ5OiBcInF1ZXJ5IHtcXG4gICAgICAgIFwiICsgY2hhaW4gKyBcIl9cIiArIHR5cGUgKyBcIiB7XFxuICAgICAgICAgIFwiICsgdHlwZSArIFwiXFxuICAgICAgICB9XFxuICAgICAgfVwiLFxuICAgICAgICAgICAgICB2YXJpYWJsZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcG9zdCA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgZGF0YSA9IF95aWVsZCR0aGlzJHBvc3QuZGF0YTtcblxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBNYXRoLmFicyhkYXRhW2NoYWluICsgXCJfXCIgKyB0eXBlXVswXVt0eXBlXSkpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIDApO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCAwKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZXhSZXR1cm5SYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJleFByaWNlQ2hhcnQoKSB7XG4gIHJldHVybiBfZ2V0UmV4UHJpY2VDaGFydC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmV4UHJpY2VDaGFydCgpIHtcbiAgX2dldFJleFByaWNlQ2hhcnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KCkge1xuICAgIHZhciBjaGFpbiwgY3VycmVudF90aW1lLCBzZXZlbl9kYXlzX2FnbywgX3lpZWxkJHRoaXMkcG9zdDIsIGRhdGE7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2hhaW4gPSBjaGFpblRvUmV4TWFwW3RoaXMuY29uc3RhbnRzLkNIQUlOXTtcblxuICAgICAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudF90aW1lID0gZm9ybWF0RGF0ZSh1dGNUaW1lKCkpO1xuICAgICAgICAgICAgc2V2ZW5fZGF5c19hZ28gPSBmb3JtYXREYXRlKHV0Y1RpbWUoc3RhcnREYXRlKHRpbWUoKSwgNykpKTtcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3QoJ2h0dHBzOi8vd3d3LmFwaS5ibG9rcy5pby9ncmFwaHFsL3YxYWxwaGExL2dyYXBocWwnLCB7XG4gICAgICAgICAgICAgIHF1ZXJ5OiBcInF1ZXJ5IHtcXG4gICAgICAgIFwiICsgY2hhaW4gKyBcIl9wcmljZWNoYXJ0KGFyZ3M6IHtcXG4gICAgICAgICAgZnJvbV90aW1lOiBcXFwiXCIgKyBzZXZlbl9kYXlzX2FnbyArIFwiXFxcIixcXG4gICAgICAgICAgdG9fdGltZTogXFxcIlwiICsgY3VycmVudF90aW1lICsgXCJcXFwiXFxuICAgICAgICB9KSB7XFxuICAgICAgICAgIHRcXG4gICAgICAgICAgb1xcbiAgICAgICAgICBoXFxuICAgICAgICAgIGxcXG4gICAgICAgICAgY1xcbiAgICAgICAgfVxcbiAgICAgIH1cIixcbiAgICAgICAgICAgICAgdmFyaWFibGVzOiBudWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHBvc3QyID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICBkYXRhID0gX3lpZWxkJHRoaXMkcG9zdDIuZGF0YTtcblxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBkYXRhW2NoYWluICsgXCJfcHJpY2VjaGFydFwiXSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZXhQcmljZUNoYXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEVvc0JhbGFuY2UoX3gpIHtcbiAgcmV0dXJuIF9nZXRFb3NCYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRFb3NCYWxhbmNlKCkge1xuICBfZ2V0RW9zQmFsYW5jZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhY2NvdW50TmFtZSkge1xuICAgIHZhciBfeWllbGQkdGhpcyRycGMkZ2V0X2MsIGJhbGFuY2U7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfY3VycmVuY3lfYmFsYW5jZSh0aGlzLmNvbnN0YW50cy5FT1NJT19UT0tFTiwgYWNjb3VudE5hbWUsIHRoaXMuY29uc3RhbnRzLkNPUkVfU1lNQk9MKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfYyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBiYWxhbmNlID0gX3lpZWxkJHRoaXMkcnBjJGdldF9jWzBdO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBiYWxhbmNlKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRFb3NCYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFRva2VuQmFsYW5jZShfeDIsIF94MywgX3g0KSB7XG4gIHJldHVybiBfZ2V0VG9rZW5CYWxhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59IC8vIEdldCBBY2NvdW50IFRva2Vuc1xuXG5mdW5jdGlvbiBfZ2V0VG9rZW5CYWxhbmNlKCkge1xuICBfZ2V0VG9rZW5CYWxhbmNlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihjb250cmFjdCwgYWNjb3VudE5hbWUsIHN5bWJvbCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfY3VycmVuY3lfYmFsYW5jZShjb250cmFjdCwgYWNjb3VudE5hbWUsIHN5bWJvbClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKCEocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdFswXSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFRva2VuQmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBY2NvdW50VG9rZW5zKF94NSkge1xuICByZXR1cm4gX2dldEFjY291bnRUb2tlbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFjY291bnRUb2tlbnMoKSB7XG4gIF9nZXRBY2NvdW50VG9rZW5zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhY2NvdW50TmFtZSkge1xuICAgIHZhciBhY2NvdW50QmFsYW5jZXM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChhY2NvdW50QmFsYW5jZXMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlnaHRHZXRUb2tlbnMoYWNjb3VudE5hbWUpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgYWNjb3VudEJhbGFuY2VzID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAoYWNjb3VudEJhbGFuY2VzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uR2V0VG9rZW5zRm9yQWNjb3VudChhY2NvdW50TmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBhY2NvdW50QmFsYW5jZXMgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIGFjY291bnRCYWxhbmNlcyB8fCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBY2NvdW50VG9rZW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGxpZ2h0R2V0VG9rZW5zKF94Nikge1xuICByZXR1cm4gX2xpZ2h0R2V0VG9rZW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9saWdodEdldFRva2VucygpIHtcbiAgX2xpZ2h0R2V0VG9rZW5zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhY2NvdW50KSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJGxpZ2h0QXBpJCwgYmFsYW5jZXM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlnaHRBcGkuZ2V0X2JhbGFuY2VzKGFjY291bnQpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkbGlnaHRBcGkkID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICBiYWxhbmNlcyA9IF95aWVsZCR0aGlzJGxpZ2h0QXBpJC5iYWxhbmNlcztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIGJhbGFuY2VzLm1hcChmdW5jdGlvbiAoYmFsYW5jZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBiYWxhbmNlLmN1cnJlbmN5LFxuICAgICAgICAgICAgICAgIGFtb3VudDogTnVtYmVyKGJhbGFuY2UuYW1vdW50KSxcbiAgICAgICAgICAgICAgICBjb250cmFjdDogYmFsYW5jZS5jb250cmFjdCxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogTnVtYmVyKGJhbGFuY2UuZGVjaW1hbHMpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdsaWdodEdldFRva2VucyBlcnJvcicsIF9jb250ZXh0NC50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzAsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9saWdodEdldFRva2Vucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBoeXBlcmlvbkdldFRva2Vuc0ZvckFjY291bnQoX3g3KSB7XG4gIHJldHVybiBfaHlwZXJpb25HZXRUb2tlbnNGb3JBY2NvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9oeXBlcmlvbkdldFRva2Vuc0ZvckFjY291bnQoKSB7XG4gIF9oeXBlcmlvbkdldFRva2Vuc0ZvckFjY291bnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGFjY291bnQpIHtcbiAgICB2YXIgX3lpZWxkJHRoaXMkaHlwZXJpb24kLCB0b2tlbnM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb24uZ2V0X3Rva2VucyhhY2NvdW50KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGh5cGVyaW9uJCA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgdG9rZW5zID0gX3lpZWxkJHRoaXMkaHlwZXJpb24kLnRva2VucztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3k6IHRva2VuLnN5bWJvbCxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IE51bWJlcih0b2tlbi5hbW91bnQpLFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0OiB0b2tlbi5jb250cmFjdCxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogTnVtYmVyKHRva2VuLnByZWNpc2lvbilcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2h5cGVyaW9uR2V0VG9rZW5zRm9yQWNjb3VudCBlcnJvcicsIF9jb250ZXh0NS50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzAsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9oeXBlcmlvbkdldFRva2Vuc0ZvckFjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW5TdXBwbHkoX3g4LCBfeDkpIHtcbiAgcmV0dXJuIF9nZXRUb2tlblN1cHBseS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0VG9rZW5TdXBwbHkoKSB7XG4gIF9nZXRUb2tlblN1cHBseSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoY29udHJhY3QsIHN5bWJvbCkge1xuICAgIHZhciBzdGF0cywgX3N0YXRzJHN5bWJvbCwgc3VwcGx5LCBtYXhfc3VwcGx5O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfY3VycmVuY3lfc3RhdHMoY29udHJhY3QsIHN5bWJvbCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdGF0cyA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgX3N0YXRzJHN5bWJvbCA9IHN0YXRzW3N5bWJvbF0sIHN1cHBseSA9IF9zdGF0cyRzeW1ib2wuc3VwcGx5LCBtYXhfc3VwcGx5ID0gX3N0YXRzJHN5bWJvbC5tYXhfc3VwcGx5O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBzdXBwbHk6IHN1cHBseSA/ICtzdXBwbHkuc3BsaXQoJyAnKVswXSA6IDAsXG4gICAgICAgICAgICAgIG1heF9zdXBwbHk6IG1heF9zdXBwbHkgPyArbWF4X3N1cHBseS5zcGxpdCgnICcpWzBdIDogMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0Ni50MCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIHN1cHBseTogMCxcbiAgICAgICAgICAgICAgbWF4X3N1cHBseTogMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYsIHRoaXMsIFtbMCwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFRva2VuU3VwcGx5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEhpc3RvcnlUcmFuc2FjdGlvbihfeCwgX3gyKSB7XG4gIHJldHVybiBfZ2V0SGlzdG9yeVRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRIaXN0b3J5VHJhbnNhY3Rpb24oKSB7XG4gIF9nZXRIaXN0b3J5VHJhbnNhY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodHhJZCwgYmxvY2tIaW50KSB7XG4gICAgdmFyIGVvc1RyYW5zYWN0aW9ucywgdHg7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGJsb2NrSGludCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGJsb2NrSGludCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVvc1RyYW5zYWN0aW9ucyA9IG5ldyBKc29uUnBjKHRoaXMuY29uc3RhbnRzLlRSQU5TQUNUSU9OU19FTkRQT0lOVFMpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gZW9zVHJhbnNhY3Rpb25zLmhpc3RvcnlfZ2V0X3RyYW5zYWN0aW9uKHR4SWQsIGJsb2NrSGludCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0eCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVFggbm90IGZvdW5kJyk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGhpc3RvcnlUcmFuc2Zvcm1UcmFuc2FjdGlvbih0eCkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEhpc3RvcnlUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREZWZlcnJlZFRyYW5zYWN0aW9uKF94Mykge1xuICByZXR1cm4gX2dldERlZmVycmVkVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldERlZmVycmVkVHJhbnNhY3Rpb24oKSB7XG4gIF9nZXREZWZlcnJlZFRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMih0eElkKSB7XG4gICAgdmFyIF95aWVsZCR0aGlzJHJwYyRnZXRfcywgdHJhbnNhY3Rpb25zO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfc2NoZWR1bGVkX3RyYW5zYWN0aW9ucyh0cnVlLCB0eElkLCAxKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJHJwYyRnZXRfcyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zID0gX3lpZWxkJHRoaXMkcnBjJGdldF9zLnRyYW5zYWN0aW9ucztcblxuICAgICAgICAgICAgaWYgKCEodHJhbnNhY3Rpb25zLmxlbmd0aCA+IDAgJiYgdHJhbnNhY3Rpb25zWzBdLnRyeF9pZC5zdWJzdHJpbmcoMCwgNikgPT09IHR4SWQuc3Vic3RyaW5nKDAsIDYpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBoaXN0b3J5VHJhbnNmb3JtRGVmZXJyZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbnNbMF0pKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHt9KTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldERlZmVycmVkVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SHlwZXJpb25UcmFuc2FjdGlvbihfeDQpIHtcbiAgcmV0dXJuIF9nZXRIeXBlcmlvblRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRIeXBlcmlvblRyYW5zYWN0aW9uKCkge1xuICBfZ2V0SHlwZXJpb25UcmFuc2FjdGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoaWQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLkhZUEVSSU9OX1VSTCkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oeXBlcmlvbi5nZXRfdHJhbnNhY3Rpb24oaWQpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gODtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh1cmxCdWlsZGVyKHRoaXMuY29uc3RhbnRzLkFQSV9VUkwsICdoeXBlcmlvbicsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2dldF90cmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgb3B0aW9uczoge31cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgaWYgKCEoIXJlc3VsdCB8fCAhcmVzdWx0LmFjdGlvbnMgfHwgIXJlc3VsdC5hY3Rpb25zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVFggbm90IGZvdW5kJyk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgaHlwZXJpb25UcmFuc2Zvcm1UcmFuc2FjdGlvbihyZXN1bHQpKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRIeXBlcmlvblRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVHJhbnNhY3Rpb25TZXR0aW5ncyhfeDUsIF94NiwgX3g3KSB7XG4gIHJldHVybiBfZ2VuZXJhdGVUcmFuc2FjdGlvblNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZW5lcmF0ZVRyYW5zYWN0aW9uU2V0dGluZ3MoKSB7XG4gIF9nZW5lcmF0ZVRyYW5zYWN0aW9uU2V0dGluZ3MgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGV4cGlyZVNlY29uZHMsIGJsb2Nrc0JlaGluZCwgZGVsYXlTZWMpIHtcbiAgICB2YXIgaW5mbywgcmVmQmxvY2ssIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGV4cGlyZVNlY29uZHMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBleHBpcmVTZWNvbmRzID0gMzAwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJsb2Nrc0JlaGluZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGJsb2Nrc0JlaGluZCA9IDEyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVsYXlTZWMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBkZWxheVNlYyA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfaW5mbygpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgaW5mbyA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRfYmxvY2soaW5mby5oZWFkX2Jsb2NrX251bSAtIGJsb2Nrc0JlaGluZCk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmVmQmxvY2sgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IFNlcmlhbGl6ZS50cmFuc2FjdGlvbkhlYWRlcihyZWZCbG9jaywgZXhwaXJlU2Vjb25kcyk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICBtYXhfbmV0X3VzYWdlX3dvcmRzOiAwLFxuICAgICAgICAgICAgICBtYXhfY3B1X3VzYWdlX21zOiAwLFxuICAgICAgICAgICAgICBkZWxheV9zZWM6IGRlbGF5U2VjLFxuICAgICAgICAgICAgICBjb250ZXh0X2ZyZWVfYWN0aW9uczogW10sXG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtdLFxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbl9leHRlbnNpb25zOiBbXVxuICAgICAgICAgICAgfSwgcmVzdWx0KSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2VuZXJhdGVUcmFuc2FjdGlvblNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRyb2xsZWRBY2NvdW50cyhhY2NvdW50TmFtZSkge1xuICBpZiAodGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFUy5pbmNsdWRlcygnbmF0aXZlJykpIHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zUnBjLmhpc3RvcnlfZ2V0X2NvbnRyb2xsZWRfYWNjb3VudHMoYWNjb3VudE5hbWUpO1xuICB9IGVsc2UgaWYgKHRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVMuaW5jbHVkZXMoJ2h5cGVyaW9uJykpIHtcbiAgICB2YXIgYWN0aW9uc1JwYyA9IG5ldyBKc29uUnBjKFt0aGlzLmNvbnN0YW50cy5IWVBFUklPTl9VUkxdKTtcbiAgICByZXR1cm4gYWN0aW9uc1JwYy5oaXN0b3J5X2dldF9jb250cm9sbGVkX2FjY291bnRzKGFjY291bnROYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBlcm1pc3Npb25MaW5rcyhfeCkge1xuICByZXR1cm4gX2dldFBlcm1pc3Npb25MaW5rcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UGVybWlzc2lvbkxpbmtzKCkge1xuICBfZ2V0UGVybWlzc2lvbkxpbmtzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFjY291bnQpIHtcbiAgICB2YXIgbGlnaHRBY2NvdW50LCBfeWllbGQkdGhpcyRnZXQsIGxpbmtlZF9wZXJtaXNzaW9ucywgX3lpZWxkJHRoaXMkaHlwZXJpb24kLCBsaW5rcztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdGFudHMuTElHSFRfQVBJKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2NvdW50TGlnaHREYXRhKGFjY291bnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgbGlnaHRBY2NvdW50ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKCFsaWdodEFjY291bnQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGxpZ2h0QWNjb3VudC5saW5rYXV0aC5tYXAoZnVuY3Rpb24gKGF1dGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGF1dGgudHlwZSxcbiAgICAgICAgICAgICAgICBjb250cmFjdDogYXV0aC5jb2RlLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25fbmFtZTogYXV0aC5yZXF1aXJlbWVudFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVMuaW5jbHVkZXMoJ2RmdXNlJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDEzO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuY29uc3RhbnRzLkFQSV9VUkwgKyBcIi9kZnVzZT90eXBlPXN0YXRlX3Blcm1pc3Npb25fbGlua3MmYWNjb3VudD1cIiArIGFjY291bnQpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBsaW5rZWRfcGVybWlzc2lvbnMgPSBfeWllbGQkdGhpcyRnZXQubGlua2VkX3Blcm1pc3Npb25zO1xuXG4gICAgICAgICAgICBpZiAoIWxpbmtlZF9wZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGxpbmtlZF9wZXJtaXNzaW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDIyO1xuICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDEzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQxKTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLkhJU1RPUllfVFlQRVMuaW5jbHVkZXMoJ2h5cGVyaW9uJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI2O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb24uZ2V0X2xpbmtzKGFjY291bnQpO1xuXG4gICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGh5cGVyaW9uJCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBsaW5rcyA9IF95aWVsZCR0aGlzJGh5cGVyaW9uJC5saW5rcztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbGlua3MubWFwKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBsaW5rLmFjdGlvbixcbiAgICAgICAgICAgICAgICBjb250cmFjdDogbGluay5jb2RlLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25fbmFtZTogbGluay5wZXJtaXNzaW9uXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM0O1xuICAgICAgICAgICAgX2NvbnRleHQudDIgPSBfY29udGV4dFtcImNhdGNoXCJdKDI2KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKF9jb250ZXh0LnQyKTtcblxuICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUGVybWlzc2lvbiBsaW5rcyBub3QgYXZhaWxhYmxlIG9uIGNoYWluJyk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMSwgOV0sIFsxMywgMjJdLCBbMjYsIDM0XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UGVybWlzc2lvbkxpbmtzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGRmdXNlR2V0S2V5QWNjb3VudHMoX3gyKSB7XG4gIHJldHVybiBfZGZ1c2VHZXRLZXlBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZGZ1c2VHZXRLZXlBY2NvdW50cygpIHtcbiAgX2RmdXNlR2V0S2V5QWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGtleSkge1xuICAgIHZhciBfeWllbGQkdGhpcyRnZXQyLCBhY2NvdW50X25hbWVzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmNvbnN0YW50cy5BUElfVVJMICsgXCIvZGZ1c2U/dHlwZT1zdGF0ZV9rZXlfYWNjb3VudHMmcHVibGljS2V5PVwiICsga2V5KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldDIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIGFjY291bnRfbmFtZXMgPSBfeWllbGQkdGhpcyRnZXQyLmFjY291bnRfbmFtZXM7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBhY2NvdW50X25hbWVzICYmIGFjY291bnRfbmFtZXMubGVuZ3RoID8gYWNjb3VudF9uYW1lcyA6IFtdKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQyLnQwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBkZnVzZSBhY2NvdW50cyBmb3VuZCBhc3NvY2lhdGVkIHdpdGgga2V5OicsIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbMCwgOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2RmdXNlR2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbmF0aXZlR2V0S2V5QWNjb3VudHMoX3gzKSB7XG4gIHJldHVybiBfbmF0aXZlR2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX25hdGl2ZUdldEtleUFjY291bnRzKCkge1xuICBfbmF0aXZlR2V0S2V5QWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGtleSkge1xuICAgIHZhciBrZXlBY2NvdW50cywgZmlvQWNjb3VudCwgX3lpZWxkJHRoaXMkcnBjJGdldF9hLCBhY2NvdW50cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7XG4gICAgICAgICAgICBrZXlBY2NvdW50cyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIVsnZmlvJywgJ2Zpby10ZXN0J10uaW5jbHVkZXModGhpcy5jb25zdGFudHMuQ0hBSU4pKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpb0FjY291bnQgPSBmaW9LZXlUb0FjdG9yKGtleS5yZXBsYWNlKCdFT1MnLCAnRklPJyksIE51bWVyaWMuc3RyaW5nVG9QdWJsaWNLZXkpO1xuXG4gICAgICAgICAgICBpZiAoa2V5QWNjb3VudHMuaW5kZXhPZihmaW9BY2NvdW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAga2V5QWNjb3VudHMucHVzaChmaW9BY2NvdW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldF9hY2NvdW50c19ieV9hdXRob3JpemVycyhbXSwgW2tleV0pO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkcnBjJGdldF9hID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBhY2NvdW50cyA9IF95aWVsZCR0aGlzJHJwYyRnZXRfYS5hY2NvdW50cztcbiAgICAgICAgICAgIGtleUFjY291bnRzID0gQXJyYXkuZnJvbShuZXcgU2V0KGFjY291bnRzLm1hcChmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWNjb3VudC5hY2NvdW50X25hbWU7XG4gICAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIGtleUFjY291bnRzKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE1O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDMudDApO1xuICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzLnQwO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzAsIDE1XV0pO1xuICB9KSk7XG4gIHJldHVybiBfbmF0aXZlR2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gaHlwZXJpb25HZXRLZXlBY2NvdW50cyhfeDQpIHtcbiAgcmV0dXJuIF9oeXBlcmlvbkdldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9oeXBlcmlvbkdldEtleUFjY291bnRzKCkge1xuICBfaHlwZXJpb25HZXRLZXlBY2NvdW50cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoa2V5KSB7XG4gICAgdmFyIGxlZ2FjeVB1YmxpY0tleSwgX3lpZWxkJHRoaXMkaHlwZXJpb24kMiwgYWNjb3VudF9uYW1lcztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAodGhpcy5oeXBlcmlvbikge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0h5cGVyaW9uIEFQSSBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsZWdhY3lQdWJsaWNLZXkgPSBLZXkuUHVibGljS2V5LmZyb21TdHJpbmcoa2V5KS50b0xlZ2FjeVN0cmluZygpO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlwZXJpb24uZ2V0X2tleV9hY2NvdW50cyhsZWdhY3lQdWJsaWNLZXkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX3lpZWxkJHRoaXMkaHlwZXJpb24kMiA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgYWNjb3VudF9uYW1lcyA9IF95aWVsZCR0aGlzJGh5cGVyaW9uJDIuYWNjb3VudF9uYW1lcztcblxuICAgICAgICAgICAgaWYgKCEoYWNjb3VudF9uYW1lcyAmJiBhY2NvdW50X25hbWVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIGFjY291bnRfbmFtZXMpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8ga2V5cyBmb3VuZCcpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2h5cGVyaW9uR2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbGlnaHRHZXRLZXlBY2NvdW50cyhfeDUpIHtcbiAgcmV0dXJuIF9saWdodEdldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9saWdodEdldEtleUFjY291bnRzKCkge1xuICBfbGlnaHRHZXRLZXlBY2NvdW50cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoa2V5KSB7XG4gICAgdmFyIGxpZ2h0Q2hhaW4sIGFjY291bnRzQnlDaGFpbiwgYWNjb3VudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICh0aGlzLmxpZ2h0QXBpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGlnaHQgQVBJIG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxpZ2h0Q2hhaW4gPSB0aGlzLmNvbnN0YW50cy5DSEFJTi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saWdodEFwaS5nZXRfa2V5X2FjY291bnRzKGtleSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBhY2NvdW50c0J5Q2hhaW4gPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIGFjY291bnRzID0gYWNjb3VudHNCeUNoYWluW2xpZ2h0Q2hhaW5dLmFjY291bnRzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgQXJyYXkuZnJvbShuZXcgU2V0KE9iamVjdC5rZXlzKGFjY291bnRzKSkpKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2xpZ2h0R2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5QWNjb3VudHNCeVR5cGUoX3g2LCBfeDcpIHtcbiAgcmV0dXJuIF9nZXRLZXlBY2NvdW50c0J5VHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLyoqXHJcbiAqIFRyaWVzIGFsbCBoaXN0b3JpZXMgdG8gZ2V0IGtleXMuXHJcbiAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0S2V5QWNjb3VudHNCeVR5cGUoKSB7XG4gIF9nZXRLZXlBY2NvdW50c0J5VHlwZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoa2V5LCB0eXBlKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IHR5cGU7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IF9jb250ZXh0Ni50MCA9PT0gJ2RmdXNlJyA/IDMgOiBfY29udGV4dDYudDAgPT09ICduYXRpdmUnID8gNiA6IF9jb250ZXh0Ni50MCA9PT0gJ2h5cGVyaW9uJyA/IDkgOiBfY29udGV4dDYudDAgPT09ICdsaWdodCcgPyAxMiA6IDEyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZnVzZUdldEtleUFjY291bnRzKGtleSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDYuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVHZXRLZXlBY2NvdW50cyhrZXkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ2LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh5cGVyaW9uR2V0S2V5QWNjb3VudHMoa2V5KTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDYuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpZ2h0R2V0S2V5QWNjb3VudHMoa2V5KTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDYuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0S2V5QWNjb3VudHNCeVR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5QWNjb3VudHMoX3g4KSB7XG4gIHJldHVybiBfZ2V0S2V5QWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEtleUFjY291bnRzKCkge1xuICBfZ2V0S2V5QWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KGtleSkge1xuICAgIHZhciBfaSwgX2FyciwgaGlzdG9yeVR5cGUsIHJlcztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ0ZJTycpKSB7XG4gICAgICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKCdGSU8nLCAnRU9TJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pID0gMCwgX2FyciA9IFt0aGlzLmNvbnN0YW50cy5ISVNUT1JZX1RZUEVTWzBdLCAnbGlnaHQnXS5jb25jYXQodGhpcy5jb25zdGFudHMuSElTVE9SWV9UWVBFUy5zbGljZSgxKSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoIShfaSA8IF9hcnIubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGlzdG9yeVR5cGUgPSBfYXJyW19pXTtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gNDtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleUFjY291bnRzQnlUeXBlKGtleSwgaGlzdG9yeVR5cGUpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ3LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCByZXMpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDEyO1xuICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDcudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJjb250aW51ZVwiLCAxNik7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgdGhpcywgW1s0LCAxMl1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEtleUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEtleUFjY291bnRzRm9yQWxsQ2hhaW5zKF94OSkge1xuICByZXR1cm4gX2dldEtleUFjY291bnRzRm9yQWxsQ2hhaW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcclxuICogUmVjdXJzaXZlbHkgcmVzb2x2ZXMgYWxsIHJlcXVpcmVkIHBlcm1pc3Npb25zXHJcbiAqIEBwYXJhbSBhY2NvdW50TmFtZVxyXG4gKiBAcGFyYW0gcGVybWlzc2lvblxyXG4gKi9cblxuZnVuY3Rpb24gX2dldEtleUFjY291bnRzRm9yQWxsQ2hhaW5zKCkge1xuICBfZ2V0S2V5QWNjb3VudHNGb3JBbGxDaGFpbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KGtleSkge1xuICAgIHZhciBrZXlBY2NvdW50cywgY29tYmluZWQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICh0aGlzLmxpZ2h0QXBpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGlnaHQgQVBJIG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMjtcbiAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpZ2h0QXBpLmdldF9hbGxfa2V5X2FjY291bnRzKGtleSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBrZXlBY2NvdW50cyA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgY29tYmluZWQgPSBrZXlBY2NvdW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgb2JqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCBvYmopO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgT2JqZWN0LmVudHJpZXMoY29tYmluZWQpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfcmVmKSB7XG4gICAgICAgICAgICAgIHZhciBjaGFpbiA9IF9yZWZbMF0sXG4gICAgICAgICAgICAgICAgICBhY2NvdW50c0J5TmFtZSA9IF9yZWZbMV0uYWNjb3VudHM7XG4gICAgICAgICAgICAgIHZhciBhY2NvdW50cyA9IE9iamVjdC5rZXlzKGFjY291bnRzQnlOYW1lKTtcblxuICAgICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICAgICAgYWNjb3VudHM6IGFjY291bnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgW10pKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDEwO1xuICAgICAgICAgICAgX2NvbnRleHQ4LnQwID0gX2NvbnRleHQ4W1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDgudDApO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU4LCB0aGlzLCBbWzIsIDEwXV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0S2V5QWNjb3VudHNGb3JBbGxDaGFpbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWlyZWRBY2NvdW50cyhfeDEwLCBfeDExLCBfeDEyLCBfeDEzLCBfeDE0KSB7XG4gIHJldHVybiBfZ2V0UmVxdWlyZWRBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZWRBY2NvdW50cygpIHtcbiAgX2dldFJlcXVpcmVkQWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KGFjY291bnROYW1lLCBwZXJtaXNzaW9uTmFtZSwgYWxsUGVybWlzc2lvbnMsIGN1cnJlbnRMZXZlbCwgbWF4TGV2ZWwpIHtcbiAgICB2YXIgYWNjb3VudEluZm8sIF9pdGVyYXRvciwgX3N0ZXAsIHBlcm1pc3Npb24sIGFjY291bnRzLCBwcm9kdWNlcnMsIF9pdGVyYXRvcjIsIF9zdGVwMiwgYWNjb3VudDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoYWxsUGVybWlzc2lvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBhbGxQZXJtaXNzaW9ucyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudExldmVsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1heExldmVsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbWF4TGV2ZWwgPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2NvdW50KGFjY291bnROYW1lKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGFjY291bnRJbmZvID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFjY291bnRJbmZvLnBlcm1pc3Npb25zKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlmICgoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDMxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVybWlzc2lvbiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIShwZXJtaXNzaW9uLnBlcm1fbmFtZSA9PT0gcGVybWlzc2lvbk5hbWUpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgYWxsIGFjY291bnQgKGUuZy4gZ3l5LCBoYXJ0b25vLCB0aG9tcHNvbilcbiAgICAgICAgICAgIGFjY291bnRzID0gW107XG5cbiAgICAgICAgICAgIGlmICghKGFjY291bnROYW1lID09PSAnZW9zaW8nICYmIFsnb3duZXInLCAnYWN0aXZlJ10uaW5jbHVkZXMocGVybWlzc2lvbi5wZXJtX25hbWUpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDE2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxNDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2R1Y2Vyc0xvY2FsKCk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcHJvZHVjZXJzID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICBhY2NvdW50cyA9IHByb2R1Y2Vycy5tYXAoZnVuY3Rpb24gKHByb2R1Y2VyKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0b3I6IHByb2R1Y2VyLm93bmVyLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb246ICdhY3RpdmUnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBhY2NvdW50cyA9IHBlcm1pc3Npb24ucmVxdWlyZWRfYXV0aC5hY2NvdW50cy5tYXAoZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjb3VudC5wZXJtaXNzaW9uO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYWxsUGVybWlzc2lvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgYWN0b3I6IGFjY291bnROYW1lLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb246IHBlcm1pc3Npb25OYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAvLyBGb3IgZWFjaCBhY2NvdW50IChlLmcuIGhhcnRvbm8pXG5cblxuICAgICAgICAgICAgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoYWNjb3VudHMpO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIGlmICgoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhY2NvdW50ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIShjdXJyZW50TGV2ZWwgPCBtYXhMZXZlbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXF1aXJlZEFjY291bnRzKGFjY291bnQuYWN0b3IsIGFjY291bnQucGVybWlzc2lvbiwgYWxsUGVybWlzc2lvbnMsICsrY3VycmVudExldmVsLCBtYXhMZXZlbCk7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgIGFsbFBlcm1pc3Npb25zLnB1c2goe1xuICAgICAgICAgICAgICBhY3RvcjogYWNjb3VudC5hY3RvcixcbiAgICAgICAgICAgICAgcGVybWlzc2lvbjogYWNjb3VudC5wZXJtaXNzaW9uXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDE5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgYWxsUGVybWlzc2lvbnMpO1xuXG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU5LCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJlcXVpcmVkQWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0VXNlcnNGcm9tS2V5cyhfeDE1KSB7XG4gIHJldHVybiBfZ2V0VXNlcnNGcm9tS2V5cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0VXNlcnNGcm9tS2V5cygpIHtcbiAgX2dldFVzZXJzRnJvbUtleXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMihrZXlzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB1c2VycywgcHJvbWlzZXM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB1c2VycyA9IFtdO1xuICAgICAgICAgICAgcHJvbWlzZXMgPSBrZXlzLm1hcCggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjY291bnRfbmFtZXMsIHByb21pc2VzMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0S2V5QWNjb3VudHMoa2V5KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRfbmFtZXMgPSBfY29udGV4dDExLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlczIgPSBhY2NvdW50X25hbWVzLm1hcCggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoYWNjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY2NvdW50SW5mbywgX2l0ZXJhdG9yMywgX3N0ZXAzLCBwZXJtaXNzaW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldEFjY291bnQoYWNjb3VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50SW5mbyA9IF9jb250ZXh0MTAuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV2ZXJ5IHBlcm1pc3Npb24sIGFkZCB0byBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhY2NvdW50SW5mby5wZXJtaXNzaW9ucyk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGtleSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcm1pc3Npb24ucmVxdWlyZWRfYXV0aC5rZXlzLmZpbmQoZnVuY3Rpb24gKHBlcm1LZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVybUtleS5rZXkgPT09IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2Vycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yOiBhY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbjogcGVybWlzc2lvbi5wZXJtX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gxNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMyKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMTEpO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwgdXNlcnMpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUxMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRVc2Vyc0Zyb21LZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBBcGlDbGFzcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFwaUNsYXNzKGNoYWluKSB7XG4gICAgdGhpcy5ycGMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hY3Rpb25zUnBjID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXBpID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaHlwZXJpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saWdodEFwaSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnN0YW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmh0dHAgPSBodHRwO1xuICAgIHRoaXMuZ2V0ID0gZ2V0O1xuICAgIHRoaXMucG9zdCA9IHBvc3Q7XG4gICAgdGhpcy5nZXRBY2NvdW50ID0gZ2V0QWNjb3VudDtcbiAgICB0aGlzLmdldEdyYXZhdGFyID0gZ2V0R3JhdmF0YXI7XG4gICAgdGhpcy5zZWFyY2hBY2NvdW50ID0gc2VhcmNoQWNjb3VudDtcbiAgICB0aGlzLmdldFBhcmVudCA9IGdldFBhcmVudDtcbiAgICB0aGlzLmdldEFjY291bnRMaWdodERhdGEgPSBnZXRBY2NvdW50TGlnaHREYXRhO1xuICAgIHRoaXMuZ2V0QWN0aW9uc0Zyb21OYXRpdmUgPSBnZXRBY3Rpb25zRnJvbU5hdGl2ZTtcbiAgICB0aGlzLmdldEFjdGlvbnMgPSBnZXRBY3Rpb25zO1xuICAgIHRoaXMuZ2V0QWN0aW9uc0Zyb21EZnVzZSA9IGdldEFjdGlvbnNGcm9tRGZ1c2U7XG4gICAgdGhpcy5nZXRBY3Rpb25zRnJvbUh5cGVyaW9uID0gZ2V0QWN0aW9uc0Zyb21IeXBlcmlvbjtcbiAgICB0aGlzLmdldERhcHBTdGF0cyA9IGdldERhcHBTdGF0cztcbiAgICB0aGlzLmdldERzcFBhY2thZ2VzID0gZ2V0RHNwUGFja2FnZXM7XG4gICAgdGhpcy5nZXREYXBwaG9kbEJhbGFuY2UgPSBnZXREYXBwaG9kbEJhbGFuY2U7XG4gICAgdGhpcy5nZXREYXBwQmFsYW5jZSA9IGdldERhcHBCYWxhbmNlO1xuICAgIHRoaXMuZ2V0RGFwcFN0YWtlcyA9IGdldERhcHBTdGFrZXM7XG4gICAgdGhpcy5nZXREYXBwaG9kbFN0YWtlcyA9IGdldERhcHBob2RsU3Rha2VzO1xuICAgIHRoaXMuZ2V0RGFwcFVuc3Rha2VzID0gZ2V0RGFwcFVuc3Rha2VzO1xuICAgIHRoaXMuZ2V0RGFwcGhvZGxVbnN0YWtlcyA9IGdldERhcHBob2RsVW5zdGFrZXM7XG4gICAgdGhpcy5nZXRGSU9Wb3RlciA9IGdldEZJT1ZvdGVyO1xuICAgIHRoaXMuZ2V0RklPQWRkcmVzc0J5TmFtZSA9IGdldEZJT0FkZHJlc3NCeU5hbWU7XG4gICAgdGhpcy5nZXRGSU9Eb21haW5CeU5hbWUgPSBnZXRGSU9Eb21haW5CeU5hbWU7XG4gICAgdGhpcy5nZXRORlRzQnlGaW9BZGRyZXNzID0gZ2V0TkZUc0J5RmlvQWRkcmVzcztcbiAgICB0aGlzLmdldERvbWFpbnMgPSBnZXREb21haW5zO1xuICAgIHRoaXMuZ2V0QWRkcmVzc2VzID0gZ2V0QWRkcmVzc2VzO1xuICAgIHRoaXMuZ2V0RklPUHJvZHVjZXJzID0gZ2V0RklPUHJvZHVjZXJzO1xuICAgIHRoaXMuZ2V0RklPU3VwcGx5QnJlYWtkb3duID0gZ2V0RklPU3VwcGx5QnJlYWtkb3duO1xuICAgIHRoaXMuZ2V0RklPRmVlcyA9IGdldEZJT0ZlZXM7XG4gICAgdGhpcy5hZGRGSU9GZWVUb0FjdGlvbnMgPSBhZGRGSU9GZWVUb0FjdGlvbnM7XG4gICAgdGhpcy5nZXRGSU9BZGRyZXNzZXMgPSBnZXRGSU9BZGRyZXNzZXM7XG4gICAgdGhpcy5nZXRGSU9Eb21haW5zID0gZ2V0RklPRG9tYWlucztcbiAgICB0aGlzLmdldEZJT0FkZHJlc3Nlc0FuZERvbWFpbnMgPSBnZXRGSU9BZGRyZXNzZXNBbmREb21haW5zO1xuICAgIHRoaXMuZ2V0RklPQmFsYW5jZSA9IGdldEZJT0JhbGFuY2U7XG4gICAgdGhpcy5nZXRDb250cm9sbGVkQWNjb3VudHMgPSBnZXRDb250cm9sbGVkQWNjb3VudHM7XG4gICAgdGhpcy5nZXRQZXJtaXNzaW9uTGlua3MgPSBnZXRQZXJtaXNzaW9uTGlua3M7XG4gICAgdGhpcy5kZnVzZUdldEtleUFjY291bnRzID0gZGZ1c2VHZXRLZXlBY2NvdW50cztcbiAgICB0aGlzLm5hdGl2ZUdldEtleUFjY291bnRzID0gbmF0aXZlR2V0S2V5QWNjb3VudHM7XG4gICAgdGhpcy5oeXBlcmlvbkdldEtleUFjY291bnRzID0gaHlwZXJpb25HZXRLZXlBY2NvdW50cztcbiAgICB0aGlzLmxpZ2h0R2V0S2V5QWNjb3VudHMgPSBsaWdodEdldEtleUFjY291bnRzO1xuICAgIHRoaXMuZ2V0S2V5QWNjb3VudHNCeVR5cGUgPSBnZXRLZXlBY2NvdW50c0J5VHlwZTtcbiAgICB0aGlzLmdldEtleUFjY291bnRzID0gZ2V0S2V5QWNjb3VudHM7XG4gICAgdGhpcy5nZXRLZXlBY2NvdW50c0ZvckFsbENoYWlucyA9IGdldEtleUFjY291bnRzRm9yQWxsQ2hhaW5zO1xuICAgIHRoaXMuZ2V0UmVxdWlyZWRBY2NvdW50cyA9IGdldFJlcXVpcmVkQWNjb3VudHM7XG4gICAgdGhpcy5nZXRVc2Vyc0Zyb21LZXlzID0gZ2V0VXNlcnNGcm9tS2V5cztcbiAgICB0aGlzLmdldEFsbE1zaWdzID0gZ2V0QWxsTXNpZ3M7XG4gICAgdGhpcy5wYXJzZVBhY2tlZE1zaWdBY3Rpb25zID0gcGFyc2VQYWNrZWRNc2lnQWN0aW9ucztcbiAgICB0aGlzLnBhcnNlUGFja2VkTXNpZyA9IHBhcnNlUGFja2VkTXNpZztcbiAgICB0aGlzLmdldEZ1bGxNc2lnUHJvcG9zYWwgPSBnZXRGdWxsTXNpZ1Byb3Bvc2FsO1xuICAgIHRoaXMuZ2V0TXNpZ0FwcHJvdmFscyA9IGdldE1zaWdBcHByb3ZhbHM7XG4gICAgdGhpcy5nZXRBY2NvdW50c01zaWdQcm9wb3NhbHMgPSBnZXRBY2NvdW50c01zaWdQcm9wb3NhbHM7XG4gICAgdGhpcy5oeXBlcmlvbkdldE1zaWcgPSBoeXBlcmlvbkdldE1zaWc7XG4gICAgdGhpcy5nZXRNc2lnUHJvcG9zYWwgPSBnZXRNc2lnUHJvcG9zYWw7XG4gICAgdGhpcy5nZXRSZW50YndTdGF0ZSA9IGdldFJlbnRid1N0YXRlO1xuICAgIHRoaXMuZGVsZWdhdGVkQmFuZHdpZHRoID0gZGVsZWdhdGVkQmFuZHdpZHRoO1xuICAgIHRoaXMuZ2V0QWNjb3VudERlbGVnYXRlZEJhbmR3aWR0aCA9IGdldEFjY291bnREZWxlZ2F0ZWRCYW5kd2lkdGg7XG4gICAgdGhpcy5nZXRBY2NvdW50UmVzb3VyY2VzID0gZ2V0QWNjb3VudFJlc291cmNlcztcbiAgICB0aGlzLmdldFJhbVByaWNlSW5Fb3MgPSBnZXRSYW1QcmljZUluRW9zO1xuICAgIHRoaXMuZ2V0UmV4UXVldWVkID0gZ2V0UmV4UXVldWVkO1xuICAgIHRoaXMuZ2V0UmV4UG9vbCA9IGdldFJleFBvb2w7XG4gICAgdGhpcy5nZXRSZXhCYWxhbmNlID0gZ2V0UmV4QmFsYW5jZTtcbiAgICB0aGlzLmdldFJleENwdUxvYW5zID0gZ2V0UmV4Q3B1TG9hbnM7XG4gICAgdGhpcy5nZXRSZXhOZXRMb2FucyA9IGdldFJleE5ldExvYW5zO1xuICAgIHRoaXMuZ2V0RW9zRGVwb3NpdGVkSW50b1JleCA9IGdldEVvc0RlcG9zaXRlZEludG9SZXg7XG4gICAgdGhpcy5nZXRSZXhSZXR1cm5SYXRlID0gZ2V0UmV4UmV0dXJuUmF0ZTtcbiAgICB0aGlzLmdldFJleFByaWNlQ2hhcnQgPSBnZXRSZXhQcmljZUNoYXJ0O1xuICAgIHRoaXMuZ2V0RW9zVG9wU3Rha2VzID0gZ2V0RW9zVG9wU3Rha2VzO1xuICAgIHRoaXMuZ2V0RW9zVG9wUmFtcyA9IGdldEVvc1RvcFJhbXM7XG4gICAgdGhpcy5nZXRDdXJyZW50TmFtZUJpZHMgPSBnZXRDdXJyZW50TmFtZUJpZHM7XG4gICAgdGhpcy5nZXRFb3NCYWxhbmNlID0gZ2V0RW9zQmFsYW5jZTtcbiAgICB0aGlzLmdldFRva2VuQmFsYW5jZSA9IGdldFRva2VuQmFsYW5jZTtcbiAgICB0aGlzLmh5cGVyaW9uR2V0VG9rZW5zRm9yQWNjb3VudCA9IGh5cGVyaW9uR2V0VG9rZW5zRm9yQWNjb3VudDtcbiAgICB0aGlzLmdldFRva2VuU3VwcGx5ID0gZ2V0VG9rZW5TdXBwbHk7XG4gICAgdGhpcy5saWdodEdldFRva2VucyA9IGxpZ2h0R2V0VG9rZW5zO1xuICAgIHRoaXMuZ2V0QWNjb3VudFRva2VucyA9IGdldEFjY291bnRUb2tlbnM7XG4gICAgdGhpcy5nZXRIaXN0b3J5VHJhbnNhY3Rpb24gPSBnZXRIaXN0b3J5VHJhbnNhY3Rpb247XG4gICAgdGhpcy5nZXREZWZlcnJlZFRyYW5zYWN0aW9uID0gZ2V0RGVmZXJyZWRUcmFuc2FjdGlvbjtcbiAgICB0aGlzLmdldEh5cGVyaW9uVHJhbnNhY3Rpb24gPSBnZXRIeXBlcmlvblRyYW5zYWN0aW9uO1xuICAgIHRoaXMuZ2VuZXJhdGVUcmFuc2FjdGlvblNldHRpbmdzID0gZ2VuZXJhdGVUcmFuc2FjdGlvblNldHRpbmdzO1xuICAgIHRoaXMuZ2V0UHJveGllcyA9IGdldFByb3hpZXM7XG4gICAgdGhpcy5nZXRWb3RlcnMgPSBnZXRWb3RlcnM7XG4gICAgdGhpcy5jYWxjdWxhdGVWb3RlV2VpZ2h0ID0gY2FsY3VsYXRlVm90ZVdlaWdodDtcbiAgICB0aGlzLndlaWdodGVkVm90ZVRvTnVtYmVyID0gd2VpZ2h0ZWRWb3RlVG9OdW1iZXI7XG4gICAgdGhpcy5nZXRQcm94eURhdGEgPSBnZXRQcm94eURhdGE7XG4gICAgdGhpcy5nZXRWb3RlciA9IGdldFZvdGVyO1xuICAgIHRoaXMuZ2V0UHJvZHVjZXJzID0gZ2V0UHJvZHVjZXJzO1xuICAgIHRoaXMuZ2V0UHJvZHVjZXJzTG9jYWwgPSBnZXRQcm9kdWNlcnNMb2NhbDtcbiAgICB0aGlzLmdldENoYWluVGFibGUgPSBnZXRDaGFpblRhYmxlO1xuICAgIHRoaXMuZmV0Y2hLeWNDb3VudHJpZXMgPSBmZXRjaEt5Y0NvdW50cmllcztcbiAgICB0aGlzLmNoZWNrVXNlckt5Y1N0YXR1cyA9IGNoZWNrVXNlckt5Y1N0YXR1cztcbiAgICB0aGlzLmFwcGx5Rm9yS3ljID0gYXBwbHlGb3JLeWM7XG4gICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG4gICAgdGhpcy5nZXRBdmFpbGFibGVGZWF0dXJlcyA9IGdldEF2YWlsYWJsZUZlYXR1cmVzO1xuICAgIHRoaXMub3RjUXVvdGUgPSBvdGNRdW90ZTtcbiAgICB0aGlzLm90Y09yZGVyID0gb3RjT3JkZXI7XG4gICAgdGhpcy5nZW5lcmF0ZUFkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3M7XG4gICAgdGhpcy5kZWxldGVBZGRyZXNzID0gZGVsZXRlQWRkcmVzcztcbiAgICB0aGlzLndpdGhkcmF3TWV0YWwgPSB3aXRoZHJhd01ldGFsO1xuICAgIHRoaXMud2l0aGRyYXdhbEhpc3RvcnlNZXRhbCA9IHdpdGhkcmF3YWxIaXN0b3J5TWV0YWw7XG4gICAgdGhpcy5nZXRUb2tlblByaWNlcyA9IGdldFRva2VuUHJpY2VzO1xuICAgIHRoaXMuZ2V0V2l0aGRyYXdhbEZlZSA9IGdldFdpdGhkcmF3YWxGZWU7XG4gICAgdGhpcy5nZXRDaGFpbkluZm8gPSBnZXRDaGFpbkluZm87XG4gICAgdGhpcy5jcmVhdGVBY2NvdW50ID0gY3JlYXRlQWNjb3VudDtcbiAgICB0aGlzLmxvZ2luQWNjb3VudCA9IGxvZ2luQWNjb3VudDtcbiAgICB0aGlzLmdldFhwclRvdGFsU3Rha2VkQW5kQXByID0gZ2V0WHByVG90YWxTdGFrZWRBbmRBcHI7XG4gICAgdGhpcy5nZXRYcHJWb3RlciA9IGdldFhwclZvdGVyO1xuICAgIHRoaXMuZ2V0WHByQWNjb3VudFN0YWtlcyA9IGdldFhwckFjY291bnRTdGFrZXM7XG4gICAgdGhpcy5nZXRYcHJBY2NvdW50UmVmdW5kID0gZ2V0WHByQWNjb3VudFJlZnVuZDtcbiAgICB0aGlzLmdldFhwck9yYWNsZURhdGEgPSBnZXRYcHJPcmFjbGVEYXRhO1xuICAgIHRoaXMuZ2V0QWxsT3JhY2xlRmVlZHMgPSBnZXRBbGxPcmFjbGVGZWVkcztcbiAgICB0aGlzLmdldEFsbE9yYWNsZURhdGEgPSBnZXRBbGxPcmFjbGVEYXRhO1xuICAgIHRoaXMuZ2V0U3BlY2lmaWNPcmFjbGVEYXRhID0gZ2V0U3BlY2lmaWNPcmFjbGVEYXRhO1xuICAgIHRoaXMuZ2V0UHJvdG9uQXZhdGFyID0gZ2V0UHJvdG9uQXZhdGFyO1xuICAgIHRoaXMuZ2V0UHJvdG9uQXZhdGFycyA9IGdldFByb3RvbkF2YXRhcnM7XG5cbiAgICBpZiAoY2hhaW4pIHtcbiAgICAgIGNvbnN0YW50cy5pbml0aWFsaXplKGNoYWluKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShjb25zdGFudHMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBcGlDbGFzcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplKGNvbnN0YW50cywgX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBycGNFbmRwb2ludHMgPSBfcmVmLnJwY0VuZHBvaW50cyxcbiAgICAgICAgYWN0aW9uc1JwY0VuZHBvaW50cyA9IF9yZWYuYWN0aW9uc1JwY0VuZHBvaW50cyxcbiAgICAgICAgbGlnaHRFbmRwb2ludCA9IF9yZWYubGlnaHRFbmRwb2ludCxcbiAgICAgICAgaHlwZXJpb25FbmRwb2ludCA9IF9yZWYuaHlwZXJpb25FbmRwb2ludDtcblxuICAgIHRoaXMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuICAgIHRoaXMucnBjID0gbmV3IEpzb25ScGMocnBjRW5kcG9pbnRzIHx8IHRoaXMuY29uc3RhbnRzLkRFRkFVTFRfRU5EUE9JTlRTKTtcbiAgICB0aGlzLmFjdGlvbnNScGMgPSBuZXcgSnNvblJwYyhhY3Rpb25zUnBjRW5kcG9pbnRzIHx8IHRoaXMuY29uc3RhbnRzLkFDVElPTlNfRU5EUE9JTlRTKTtcbiAgICB0aGlzLmFwaSA9IG5ldyBBcGkoe1xuICAgICAgcnBjOiB0aGlzLnJwY1xuICAgIH0pO1xuICAgIHZhciBsaWdodFVybCA9IGxpZ2h0RW5kcG9pbnQgfHwgdGhpcy5jb25zdGFudHMuTElHSFRfQVBJO1xuXG4gICAgaWYgKGxpZ2h0VXJsKSB7XG4gICAgICB0aGlzLmxpZ2h0QXBpID0gbmV3IEpzb25ScGMkMSh0aGlzLmNvbnN0YW50cy5DSEFJTi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJy0nLCAnJyksIHtcbiAgICAgICAgZW5kcG9pbnQ6IGxpZ2h0VXJsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaHlwZXJpb25VcmwgPSBoeXBlcmlvbkVuZHBvaW50IHx8IHRoaXMuY29uc3RhbnRzLkhZUEVSSU9OX1VSTDtcblxuICAgIGlmIChoeXBlcmlvblVybCkge1xuICAgICAgdGhpcy5oeXBlcmlvbiA9IG5ldyBKc29uUnBjJDIoaHlwZXJpb25VcmwpO1xuICAgIH1cblxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIEFwaUNsYXNzO1xufSgpO1xuXG5leHBvcnQgeyBBcGlDbGFzcywgS3ljU3RhdHVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuZXNtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFR5cGVTY3JpcHQgRGVmaW5pdGlvbnNcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvdHlwZXMvYWN0aW9uX3RyYWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvdHlwZXMvYXBpXCIpLCBleHBvcnRzKTtcbi8vIEh5cGVyaW9uIEFQSVxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9qc29ucnBjXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvZW5kcG9pbnRzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvcnBjZXJyb3JcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlYyX0dFVF9UUkFOU0ZFUlMgPSBleHBvcnRzLlYyX0dFVF9UUkFOU0FDVElPTiA9IGV4cG9ydHMuVjJfR0VUX1RSQU5TQUNURURfQUNDT1VOVFMgPSBleHBvcnRzLlYyX0dFVF9ERUxUQVMgPSBleHBvcnRzLlYyX0dFVF9DUkVBVE9SID0gZXhwb3J0cy5WMl9HRVRfQ1JFQVRFRF9BQ0NPVU5UUyA9IGV4cG9ydHMuVjJfR0VUX0FDVElPTlMgPSBleHBvcnRzLlYyX0dFVF9BQklfU05BUFNIT1QgPSBleHBvcnRzLlYyX0dFVF9QUk9QT1NBTFMgPSBleHBvcnRzLlYyX0dFVF9MSU5LUyA9IGV4cG9ydHMuVjJfR0VUX1ZPVEVSUyA9IGV4cG9ydHMuVjJfR0VUX1RPS0VOUyA9IGV4cG9ydHMuVjJfR0VUX0tFWV9BQ0NPVU5UUyA9IGV4cG9ydHMuVjJfQUxJVkUgPSB2b2lkIDA7XG4vLyBTdGF0ZVxuZXhwb3J0cy5WMl9BTElWRSA9IFwiL3YyL3N0YXRlL2FsaXZlXCI7XG5leHBvcnRzLlYyX0dFVF9LRVlfQUNDT1VOVFMgPSBcIi92Mi9zdGF0ZS9nZXRfa2V5X2FjY291bnRzXCI7XG5leHBvcnRzLlYyX0dFVF9UT0tFTlMgPSBcIi92Mi9zdGF0ZS9nZXRfdG9rZW5zXCI7XG5leHBvcnRzLlYyX0dFVF9WT1RFUlMgPSBcIi92Mi9zdGF0ZS9nZXRfdm90ZXJzXCI7XG5leHBvcnRzLlYyX0dFVF9MSU5LUyA9IFwiL3YyL3N0YXRlL2dldF9saW5rc1wiO1xuZXhwb3J0cy5WMl9HRVRfUFJPUE9TQUxTID0gXCIvdjIvc3RhdGUvZ2V0X3Byb3Bvc2Fsc1wiO1xuLy8gSGlzdG9yeVxuZXhwb3J0cy5WMl9HRVRfQUJJX1NOQVBTSE9UID0gXCIvdjIvaGlzdG9yeS9nZXRfYWJpX3NuYXBzaG90XCI7XG5leHBvcnRzLlYyX0dFVF9BQ1RJT05TID0gXCIvdjIvaGlzdG9yeS9nZXRfYWN0aW9uc1wiO1xuZXhwb3J0cy5WMl9HRVRfQ1JFQVRFRF9BQ0NPVU5UUyA9IFwiL3YyL2hpc3RvcnkvZ2V0X2NyZWF0ZWRfYWNjb3VudHNcIjtcbmV4cG9ydHMuVjJfR0VUX0NSRUFUT1IgPSBcIi92Mi9oaXN0b3J5L2dldF9jcmVhdG9yXCI7XG5leHBvcnRzLlYyX0dFVF9ERUxUQVMgPSBcIi92Mi9oaXN0b3J5L2dldF9kZWx0YXNcIjtcbmV4cG9ydHMuVjJfR0VUX1RSQU5TQUNURURfQUNDT1VOVFMgPSBcIi92Mi9oaXN0b3J5L2dldF90cmFuc2FjdGVkX2FjY291bnRzXCI7XG5leHBvcnRzLlYyX0dFVF9UUkFOU0FDVElPTiA9IFwiL3YyL2hpc3RvcnkvZ2V0X3RyYW5zYWN0aW9uXCI7XG5leHBvcnRzLlYyX0dFVF9UUkFOU0ZFUlMgPSBcIi92Mi9oaXN0b3J5L2dldF90cmFuc2ZlcnNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuZHBvaW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Kc29uUnBjID0gdm9pZCAwO1xudmFyIGVuZHBvaW50c18xID0gcmVxdWlyZShcIi4vZW5kcG9pbnRzXCIpO1xudmFyIHJwY2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ycGNlcnJvclwiKTtcbnZhciBjcm9zc19mZXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcm9zcy1mZXRjaFwiKSk7XG5mdW5jdGlvbiBxdWVyeVBhcmFtcyhwYXJhbXMpIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwYXJhbXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVudHJpZXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXMuam9pbihcIiZcIik7XG59XG5mdW5jdGlvbiBmZXRjaFdpdGhUaW1lb3V0KHJlc291cmNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZW91dCwgY29udHJvbGxlciwgaWQsIHJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbGxlci5hYm9ydCgpOyB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGNyb3NzX2ZldGNoXzEuZGVmYXVsdCkocmVzb3VyY2UsIF9fYXNzaWduKF9fYXNzaWduKHt9LCAob3B0aW9ucyB8fCB7fSkpLCB7IHNpZ25hbDogY29udHJvbGxlci5zaWduYWwgfSkpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogSnNvblJwY1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCBoeXBlcmlvbiBlbmRwb2ludFxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBlbmRwb2ludCA9IFwiaHR0cHM6Ly9ici5lb3NyaW8uaW9cIlxuICogY29uc3QgcnBjID0gbmV3IEpzb25ScGMoZW5kcG9pbnQsIHsgZmV0Y2ggfSlcbiAqL1xudmFyIEpzb25ScGMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSnNvblJwYyhlbmRwb2ludCwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSB7fTsgfVxuICAgICAgICB0aGlzLnRpbWVvdXQgPSA4MDAwO1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgIGlmIChhcmdzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IGFyZ3MudGltZW91dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBwb3N0XG4gICAgICpcbiAgICAgKiBQT1NUIGBib2R5YCB0byBgZW5kcG9pbnQgKyBwYXRoYC5cbiAgICAgKiBUaHJvd3MgZGV0YWlsZWQgZXJyb3IgaW5mb3JtYXRpb24gaW4gYFJwY0Vycm9yYCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChwYXRoLCBib2R5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwganNvbiwgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoV2l0aFRpbWVvdXQodGhpcy5lbmRwb2ludCArIHBhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS5qc29uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24ucHJvY2Vzc2VkICYmIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBycGNlcnJvcl8xLlJwY0Vycm9yKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMS5pc0ZldGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJwY2Vycm9yXzEuUnBjRXJyb3IoanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywganNvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0XG4gICAgICpcbiAgICAgKiBHRVQgYHBhcmFtc2AgdG8gYGVuZHBvaW50ICsgcGF0aGAuXG4gICAgICogVGhyb3dzIGRldGFpbGVkIGVycm9yIGluZm9ybWF0aW9uIGluIGBScGNFcnJvcmAgd2hlbiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXRoLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlLCBqc29uLCB1cmwsIGVfMjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuZW5kcG9pbnQgKyBwYXRoICsgXCI/XCIgKyBxdWVyeVBhcmFtcyhwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDQsICwgNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hXaXRoVGltZW91dCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJwY2Vycm9yXzEuUnBjU3RhdHVzRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UuanNvbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLnByb2Nlc3NlZCAmJiBqc29uLnByb2Nlc3NlZC5leGNlcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcnBjZXJyb3JfMS5ScGNFcnJvcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIuaXNGZXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBycGNlcnJvcl8xLlJwY0Vycm9yKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGpzb25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL3N0YXRlL2FsaXZlXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9zdGF0ZS9nZXRfdjJfc3RhdGVfYWxpdmUpXG4gICAgICpcbiAgICAgKiBzaW1wbGUgc2VydmVyIGhlYWx0aGNoZWNrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBbGl2ZT59IGFsaXZlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmFsaXZlKCk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIC8vID0+IHtcInN0YXR1c1wiOiBcIk9LXCJ9XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuYWxpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9BTElWRSwge30pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvaGlzdG9yeS9nZXRfYWJpX3NuYXBzaG90XShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9oaXN0b3J5L2dldF92Ml9oaXN0b3J5X2dldF9hYmlfc25hcHNob3QpXG4gICAgICpcbiAgICAgKiBmZXRjaCBjb250cmFjdCBhYmkgYXQgc3BlY2lmaWMgYmxvY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdCBjb250cmFjdCBhY2NvdW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciB0YXJnZXQgYmxvY2tcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRBYmlTbmFwc2hvdD59IGFiaSBzbmFwc2hvdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfYWJpX3NuYXBzaG90KFwiZW9zaW9cIiwgMjAwKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS52ZXJzaW9uKTtcbiAgICAgKiAvLyA9PiBcImVvc2lvOjphYmkvMS4wXCJcbiAgICAgKlxuICAgICAqIGZvciAoY29uc3QgdGFibGUgb2YgcmVzcG9uc2UudGFibGVzKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHRhYmxlKTtcbiAgICAgKiAgICAgLy8gPT4geyBuYW1lOiAncHJvZHVjZXJzJywgaW5kZXhfdHlwZTogJ2k2NCcsIGtleV9uYW1lczogWyAnb3duZXInIF0sIGtleV90eXBlczogWyAndWludDY0JyBdLCB0eXBlOiAncHJvZHVjZXJfaW5mbycgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfYWJpX3NuYXBzaG90ID0gZnVuY3Rpb24gKGNvbnRyYWN0LCBibG9jaykge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgY29udHJhY3Q6IGNvbnRyYWN0LFxuICAgICAgICAgICAgYmxvY2s6IGJsb2NrLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX0FCSV9TTkFQU0hPVCwgcGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL3N0YXRlL2dldF92b3RlcnNdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL3N0YXRlL2dldF92Ml9zdGF0ZV9nZXRfdm90ZXJzKVxuICAgICAqXG4gICAgICogZ2V0IHZvdGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb2R1Y2VyXSBmaWx0ZXIgYnkgdm90ZWQgcHJvZHVjZXIgKGNvbW1hIHNlcGFyYXRlZClcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByb3h5XSB0cnVlIG9yIGZhbHNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNraXBdIHNraXAgW25dIGFjdGlvbnMgKHBhZ2luYXRpb24pXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbWl0XSBsaW1pdCBvZiBbbl0gYWN0aW9ucyBwZXIgcGFnZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldFZvdGVycz59IHZvdGVyc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfdm90ZXJzKHsgcHJvZHVjZXI6IFwiZW9zY2FmZWJsb2NrXCIsIGxpbWl0OiAxMDAgfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2Uudm90ZXJzKTtcbiAgICAgKiAvLyA9PiBcIlt7XG4gICAgICogLy8gICBcImFjY291bnRcIjogXCJndXpka21ydGdhZ2VcIixcbiAgICAgKiAvLyAgIFwid2VpZ2h0XCI6IDc4NDM0Njk1MjM2NTA1MjgwLFxuICAgICAqIC8vICAgXCJsYXN0X3ZvdGVcIjogNjQ4MDQ3NjhcbiAgICAgKiAvLyB9XVwiXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3ZvdGVycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfVk9URVJTLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL3YyL3N0YXRlL2dldF9saW5rc10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvc3RhdGUvZ2V0X3YyX3N0YXRlX2xpbmtzKVxuICAgICAqXG4gICAgICogZ2V0IHZvdGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFthY2NvdW50XSBhY2NvdW50IHRvIGdldCBsaW5rcyBmb3JcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRMaW5rcz59IGxpbmtzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF9saW5rcyhcImVvc2NhZmVibG9ja1wiKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5saW5rcyk7XG4gICAgICogLy8gPT4gXCJbe1xuICAgICAqIFwiYmxvY2tfbnVtXCI6MjYwODgwNzIsXG4gICAgICogXCJ0aW1lc3RhbXBcIjpcIjIwMTktMTEtMjJUMjM6MTc6NDIuMDAwXCIsXG4gICAgICogXCJhY2NvdW50XCI6XCJlb3NyaW9icmF6aWxcIixcbiAgICAgKiBcInBlcm1pc3Npb25cIjpcImNsYWltMlwiLFxuICAgICAqIFwiY29kZVwiOlwiZW9zaW9cIixcbiAgICAgKiBcImFjdGlvblwiOlwidm90ZXByb2R1Y2VyXCJcbiAgICAgKiB9XVwiXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2xpbmtzID0gZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9MSU5LUywgeyBhY2NvdW50OiBhY2NvdW50IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvc3RhdGUvZ2V0X3Byb3Bvc2Fsc10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvc3RhdGUvZ2V0X3YyX3N0YXRlX2dldF9wcm9wb3NhbHMpXG4gICAgICpcbiAgICAgKiBnZXQgcHJvcG9zYWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjY291bnRdIGFjY291bnQgdG8gZ2V0IHByb3Bvc2FscyBmb3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvcG9zZXJdIGZpbHRlciBieSBwcm9wb3NlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcm9wb3NhbF0gZmlsdGVyIGJ5IHByb3Bvc2FsIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWNjb3VudF0gZmlsdGVyIGJ5IGVpdGhlciByZXF1ZXN0ZWQgb3IgcHJvdmlkZWQgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZXF1ZXN0ZWRdIGZpbHRlciBieSByZXF1ZXN0ZWQgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcm92aWRlZF0gZmlsdGVyIGJ5IHByb3ZpZGVkIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhY2tdIHRvdGFsIHJlc3VsdHMgdG8gdHJhY2sgKGNvdW50KSBbbnVtYmVyIG9yIHRydWVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNraXBdIHNraXAgW25dIGFjdGlvbnMgKHBhZ2luYXRpb24pXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbWl0XSBsaW1pdCBvZiBbbl0gYWN0aW9ucyBwZXIgcGFnZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldFByb3Bvc2Fscz59IHByb3Bvc2Fsc1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9wcm9wb3NhbHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX1BST1BPU0FMUywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9oaXN0b3J5L2dldF9hY3Rpb25zXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9oaXN0b3J5L2dldF92Ml9oaXN0b3J5X2dldF9hY3Rpb25zKVxuICAgICAqXG4gICAgICogZ2V0IGFjdGlvbnMgYmFzZWQgb24gbm90aWZpZWQgYWNjb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnQgbm90aWZpZWQgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5maWx0ZXJdIGNvZGU6Om5hbWUgZmlsdGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNraXBdIHNraXAgW25dIGFjdGlvbnMgKHBhZ2luYXRpb24pXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbWl0XSBsaW1pdCBvZiBbbl0gYWN0aW9ucyBwZXIgcGFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3J0XSBzb3J0IGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hZnRlcl0gZmlsdGVyIGFmdGVyIHNwZWNpZmllZCBkYXRlIChJU084NjAxKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5iZWZvcmVdIGZpbHRlciBiZWZvcmUgc3BlY2lmaWVkIGRhdGUgKElTTzg2MDEpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYW5zZmVyX3RvXSB0cmFuc2ZlciBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhbnNmZXJfZnJvbV0gIHRyYW5zZmVyIGZpbHRlciBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYW5zZmVyX3N5bWJvbF0gIHRyYW5zZmVyIGZpbHRlciBzeW1ib2xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWN0X25hbWVdICBhY3QgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hY3RfYWNjb3VudF0gIGFjdCBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0QWN0aW9ucz59IGdldCBhY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF9hY3Rpb25zKFwiZW9zY2FmZWJsb2NrXCIsIHtcbiAgICAgKiAgICAgZmlsdGVyOiBcImVvc2lvLnRva2VuOipcIixcbiAgICAgKiAgICAgc2tpcDogMTAwLFxuICAgICAqICAgICBsaW1pdDogMTAwLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZm9yIChjb25zdCBhY3Rpb24gb2YgcmVzcG9uc2UuYWN0aW9ucykge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhhY3Rpb24pO1xuICAgICAqICAgICAvLyA9PiB7IGFjdDogeyBhY2NvdW50OiAnZW9zaW8udG9rZW4nLCBuYW1lOiAndHJhbnNmZXInLCAuLi4gfSB9XG4gICAgICogfVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9hY3Rpb25zID0gZnVuY3Rpb24gKGFjY291bnQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHsgYWNjb3VudDogYWNjb3VudCB9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9BQ1RJT05TLCBwYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvaGlzdG9yeS9nZXRfY3JlYXRlZF9hY2NvdW50c10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvaGlzdG9yeS9nZXRfdjJfaGlzdG9yeV9nZXRfY3JlYXRlZF9hY2NvdW50cylcbiAgICAgKlxuICAgICAqIGdldCBjcmVhdGVkIGFjY291bnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudCBjcmVhdGVkIGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRDcmVhdGVkQWNjb3VudHM+fSBnZXQgY3JlYXRvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfY3JlYXRlZF9hY2NvdW50cyhcImVvc25hdGlvbmZ0d1wiKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogLy8gPT4ge1wiYWNjb3VudHNcIjogW3tcIm5hbWVcIjpcImVvc25hdGlvbmRzcFwiLFwidHJ4X2lkXCI6XCI3MjhkNGE0ZGEzNmE5OGQ5MDQ4MDgwNDYxZGFjYWY5NzVhZDA4M2U4MTU4ZWY4NGVkZWE2MGNjNzU1YWIyYzFhXCIsXCJ0aW1lc3RhbXBcIjpcIjIwMTktMDItMjhUMjI6MzY6NDUuMDAwXCJ9LCAuLi4gXX1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfY3JlYXRlZF9hY2NvdW50cyA9IGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX0NSRUFURURfQUNDT1VOVFMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9oaXN0b3J5L2dldF9jcmVhdG9yXShodHRwczovL2Vvcy5oeXBlcmlvbi5lb3NyaW8uaW8vdjIvZG9jcy9pbmRleC5odG1sIy9oaXN0b3J5L2dldF92Ml9oaXN0b3J5X2dldF9jcmVhdG9yKVxuICAgICAqXG4gICAgICogZ2V0IGNyZWF0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50IGNyZWF0ZWQgYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldENyZWF0b3I+fSBnZXQgY3JlYXRvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfY3JlYXRvcihcImVvc25hdGlvbmZ0d1wiKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogLy8gPT4geyBhY2NvdW50OiAnZW9zbmF0aW9uZnR3JywgY3JlYXRvcjogJ2d5enRjbXJ2Z3FnZScsIHRpbWVzdGFtcDogJzIwMTgtMDYtMTBUMTM6MDY6NDMuNTAwJywgLi4uIH1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfY3JlYXRvciA9IGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX0NSRUFUT1IsIHBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9oaXN0b3J5L2dldF9kZWx0YXNdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL2hpc3RvcnkvZ2V0X3YyX2hpc3RvcnlfZ2V0X2RlbHRhcylcbiAgICAgKlxuICAgICAqIGdldCBkZWx0YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIGNvbnRyYWN0IGFjY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGUgdGFibGUgc2NvcGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGUgdGFibGUgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXllciBwYXllciBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0RGVsdGFzPn0gZ2V0IGRlbHRhc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfZGVsdGFzKFwiZW9zaW8udG9rZW5cIiwgXCJlb3NuYXRpb25mdHdcIiwgXCJhY2NvdW50c1wiLCBcImVvc25hdGlvbmZ0d1wiKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogLy8gPT4geyBcInF1ZXJ5X3RpbWVcIjogMTksIFwidG90YWxcIjogeyBcInZhbHVlXCI6IDQ4NiwgXCJyZWxhdGlvblwiOiBcImVxXCIgfSwgXCJkZWx0YXNcIjogWyAuLi4gXSB9XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2RlbHRhcyA9IGZ1bmN0aW9uIChjb2RlLCBzY29wZSwgdGFibGUsIHBheWVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgcGF5ZXI6IHBheWVyLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLlYyX0dFVF9ERUxUQVMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUL3YyL3N0YXRlL2dldF9rZXlfYWNjb3VudHNdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL3N0YXRlL2dldF92Ml9zdGF0ZV9nZXRfa2V5X2FjY291bnRzKVxuICAgICAqXG4gICAgICogZ2V0IGFjY291bnQgYnkgcHVibGljIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY19rZXkgQ29udHJhY3QgYWNjb3VudCB0YXJnZXRlZCBieSB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldEtleUFjY291bnRzPn0ga2V5IGFjY291bnRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF9rZXlfYWNjb3VudHMoXCJFT1M1TXRvM0ttNkJDVnhvd2I2TGtrRmFUOW9hVXdMVmdzd2djeHZZNFFnYzRyaEhyeTRUdlwiKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5hY2NvdW50X25hbWVzKTtcbiAgICAgKiAvLyA9PiBbICdlb3NjYWZlYmxvY2snIF1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfa2V5X2FjY291bnRzID0gZnVuY3Rpb24gKHB1YmxpY19rZXkpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHB1YmxpY19rZXk6IHB1YmxpY19rZXksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfS0VZX0FDQ09VTlRTLCBwYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvc3RhdGUvZ2V0X3Rva2Vuc10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvc3RhdGUvZ2V0X3YyX3N0YXRlX2dldF90b2tlbnMpXG4gICAgICpcbiAgICAgKiBnZXQgdG9rZW5zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudCBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0VG9rZW5zPn0gZ2V0IHRva2Vuc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfdG9rZW5zKFwiZW9zbmF0aW9uZnR3XCIpO1xuICAgICAqIGZvciAoY29uc3QgdG9rZW4gb2YgcmVzcG9uc2UudG9rZW5zKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHRva2VuKTtcbiAgICAgKiAgICAgLy8gPT4geyBzeW1ib2w6ICdaT1MnLCBwcmVjaXNpb246IDQsIGFtb3VudDogMTQwLCBjb250cmFjdDogJ3pvc2Rpc2NvdW50cycgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdG9rZW5zID0gZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGFjY291bnQ6IGFjY291bnQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfVE9LRU5TLCBwYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvdjIvaGlzdG9yeS9nZXRfdHJhbnNhY3RlZF9hY2NvdW50c10oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvaGlzdG9yeS9nZXRfdjJfaGlzdG9yeV9nZXRfdHJhbnNhY3RlZF9hY2NvdW50cylcbiAgICAgKlxuICAgICAqIGdldCBhbGwgYWNjb3VudCB0aGF0IGludGVyYWN0ZWQgd2l0aCB0aGUgc291cmNlIGFjY291bnQgcHJvdmlkZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50IHNvdXJjZSBhY2NvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBzZWFyY2ggZGlyZWN0aW9uIChpbiwgb3V0IG9yIGJvdGgpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0VHJhbnNhY3RlZEFjY291bnRzPn0gdHJhbnNhY3RlZCBhY2NvdW50c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfdHJhbnNhY3RlZF9hY2NvdW50cyhcImVvc2NhZmVibG9ja1wiLCBcImluXCIpO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiAvLyA9PiB7IHF1ZXJ5X3RpbWU6IDI2OCwgYWNjb3VudDogJ2Vvc2NhZmVibG9jaycsIHRvdGFsX2luOiAxMDkyMzY5LjE4MjcsIGlucHV0czogWyAuLi4gXSB9XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3RyYW5zYWN0ZWRfYWNjb3VudHMgPSBmdW5jdGlvbiAoYWNjb3VudCwgZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB7IGFjY291bnQ6IGFjY291bnQsIGRpcmVjdGlvbjogZGlyZWN0aW9uIH0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZW5kcG9pbnRzXzEuVjJfR0VUX1RSQU5TQUNURURfQUNDT1VOVFMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9oaXN0b3J5L2dldF90cmFuc2FjdGlvbl0oaHR0cHM6Ly9lb3MuaHlwZXJpb24uZW9zcmlvLmlvL3YyL2RvY3MvaW5kZXguaHRtbCMvaGlzdG9yeS9nZXRfdjJfaGlzdG9yeV9nZXRfdHJhbnNhY3Rpb24pXG4gICAgICpcbiAgICAgKiBnZXQgYWxsIGFjdGlvbnMgYmVsb25naW5nIHRvIHRoZSBzYW1lIHRyYW5zYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdHJhbnNhY3Rpb24gaWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRUcmFuc2FjdGlvbj59IHRyYW5zYWN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldF90cmFuc2FjdGlvbihcIjQyZGFjZDU3MjIwMDFiNzM0YmU0NmEyMTQwOTE3ZTA2Y2QyMWQ0MjQyNWY5MjdmNTA2YzA3YjQzODhiMDdmNjJcIik7XG4gICAgICogZm9yIChjb25zdCBhY3Rpb24gb2YgcmVzcG9uc2UuYWN0aW9ucykge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhhY3Rpb24pO1xuICAgICAqICAgICAvLyA9PiB7IGFjdDogeyBhY2NvdW50OiAnZW9zaW8nLCBuYW1lOiAnYnV5cmFtYnl0ZXMnLCAuLi4gfX1cbiAgICAgKiB9XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfVFJBTlNBQ1RJT04sIHBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC92Mi9oaXN0b3J5L2dldF90cmFuc2ZlcnNdKGh0dHBzOi8vZW9zLmh5cGVyaW9uLmVvc3Jpby5pby92Mi9kb2NzL2luZGV4Lmh0bWwjL2hpc3RvcnkvZ2V0X3YyX2hpc3RvcnlfZ2V0X3RyYW5zZmVycylcbiAgICAgKlxuICAgICAqIGdldCB0b2tlbiB0cmFuc2ZlcnMgdXRpbGl6aW5nIHRoZSBlb3Npby50b2tlbiBzdGFuZGFyZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZyb21dIHNvdXJjZSBhY2NvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRvXSBkZXN0aW5hdGlvbiBhY2NvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN5bWJvbF0gdG9rZW4gc3ltYm9sXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvbnRyYWN0XSB0b2tlbiBjb250cmFjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5za2lwXSBza2lwIFtuXSBhY3Rpb25zIChwYWdpbmF0aW9uKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW1pdF0gbGltaXQgb2YgW25dIGFjdGlvbnMgcGVyIHBhZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWZ0ZXJdIGZpbHRlciBhZnRlciBzcGVjaWZpZWQgZGF0ZSAoSVNPODYwMSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmVmb3JlXSBmaWx0ZXIgYmVmb3JlIHNwZWNpZmllZCBkYXRlIChJU084NjAxKVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldFRyYW5zZmVycz59IHRyYW5zZmVyc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRfdHJhbnNmZXJzKHt0bzogXCJlb3NuZXd5b3JraW9cIn0pO1xuICAgICAqIGZvciAoY29uc3QgYWN0aW9uIG9mIHJlc3BvbnNlLmFjdGlvbnMpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYWN0aW9uLmFjdC5kYXRhKTtcbiAgICAgKiAgICAgLy8gPT4geyBmcm9tOiAnZW9zaW8uYnBheScsIHRvOiAnZW9zbmV3eW9ya2lvJywgYW1vdW50OiAzMjYuNTI0LCBzeW1ib2w6ICdFT1MnLCBtZW1vOiAncHJvZHVjZXIgYmxvY2sgcGF5JyB9XG4gICAgICogfVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90cmFuc2ZlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChlbmRwb2ludHNfMS5WMl9HRVRfVFJBTlNGRVJTLCBwYXJhbXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEpzb25ScGM7XG59KCkpO1xuZXhwb3J0cy5Kc29uUnBjID0gSnNvblJwYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb25ycGMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ScGNTdGF0dXNFcnJvciA9IGV4cG9ydHMuUnBjRXJyb3IgPSB2b2lkIDA7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAbW9kdWxlIFJQQy1FcnJvclxuICpcbiAqIGNvcHlyaWdodCBkZWZpbmVkIGluIGVvc2pzL0xJQ0VOU0UudHh0XG4gKi9cbnZhciBScGNFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUnBjRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUnBjRXJyb3IoanNvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoanNvbi5lcnJvciAmJiBqc29uLmVycm9yLmRldGFpbHMgJiYganNvbi5lcnJvci5kZXRhaWxzLmxlbmd0aCAmJiBqc29uLmVycm9yLmRldGFpbHNbMF0ubWVzc2FnZSkge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBqc29uLmVycm9yLmRldGFpbHNbMF0ubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc29uLnByb2Nlc3NlZCAmJiBqc29uLnByb2Nlc3NlZC5leGNlcHQgJiYganNvbi5wcm9jZXNzZWQuZXhjZXB0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywganNvbi5wcm9jZXNzZWQuZXhjZXB0Lm1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGpzb24ubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJwY0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIF90aGlzLmpzb24gPSBqc29uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBScGNFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUnBjRXJyb3IgPSBScGNFcnJvcjtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIFJwY1N0YXR1c0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhScGNTdGF0dXNFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBScGNTdGF0dXNFcnJvcihyZXNwb25zZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDUpIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVzcG9uc2Uuc3RhdHVzVGV4dCkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJwY1N0YXR1c0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJwY1N0YXR1c0Vycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5ScGNTdGF0dXNFcnJvciA9IFJwY1N0YXR1c0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnBjZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpb25fdHJhY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFR5cGVTY3JpcHQgRGVmaW5pdGlvbnNcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvdHlwZXMvYXBpXCIpLCBleHBvcnRzKTtcbi8vIExpZ2h0IEFQSVxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9qc29ucnBjXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvZW5kcG9pbnRzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvcnBjZXJyb3JcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdFVF9BQ0NPVU5UU19GUk9NX0tFWVMgPSBleHBvcnRzLkdFVF9UT0tFTl9IT0xERVJTID0gZXhwb3J0cy5HRVRfVE9LRU5fSE9MREVSX0NPVU5UID0gZXhwb3J0cy5HRVRfQ09ERUhBU0ggPSBleHBvcnRzLkdFVF9UT1BTVEFLRSA9IGV4cG9ydHMuR0VUX1RPUFJBTSA9IGV4cG9ydHMuR0VUX1VTRVJDT1VOVCA9IGV4cG9ydHMuR0VUX1RPUEhPTERFUlMgPSBleHBvcnRzLkdFVF9UT0tFTl9CQUxBTkNFID0gZXhwb3J0cy5HRVRfU1lOQ19JTkZPID0gZXhwb3J0cy5HRVRfTkVUV09SS1MgPSBleHBvcnRzLkdFVF9LRVlfQUNDT1VOVFMgPSBleHBvcnRzLkdFVF9CQUxBTkNFUyA9IGV4cG9ydHMuR0VUX0FDQ09VTlRfSU5GTyA9IGV4cG9ydHMuR0VUX0FDQ09VTlQgPSB2b2lkIDA7XG5leHBvcnRzLkdFVF9BQ0NPVU5UID0gXCIvYXBpL2FjY291bnRcIjtcbmV4cG9ydHMuR0VUX0FDQ09VTlRfSU5GTyA9IFwiL2FwaS9hY2NpbmZvXCI7XG5leHBvcnRzLkdFVF9CQUxBTkNFUyA9IFwiL2FwaS9iYWxhbmNlc1wiO1xuZXhwb3J0cy5HRVRfS0VZX0FDQ09VTlRTID0gXCIvYXBpL2tleVwiO1xuZXhwb3J0cy5HRVRfTkVUV09SS1MgPSBcIi9hcGkvbmV0d29ya3NcIjtcbmV4cG9ydHMuR0VUX1NZTkNfSU5GTyA9IFwiL2FwaS9zeW5jXCI7XG5leHBvcnRzLkdFVF9UT0tFTl9CQUxBTkNFID0gXCIvYXBpL3Rva2VuYmFsYW5jZVwiO1xuZXhwb3J0cy5HRVRfVE9QSE9MREVSUyA9IFwiL2FwaS90b3Bob2xkZXJzXCI7XG5leHBvcnRzLkdFVF9VU0VSQ09VTlQgPSBcIi9hcGkvdXNlcmNvdW50XCI7XG5leHBvcnRzLkdFVF9UT1BSQU0gPSBcIi9hcGkvdG9wcmFtXCI7XG5leHBvcnRzLkdFVF9UT1BTVEFLRSA9IFwiL2FwaS90b3BzdGFrZVwiO1xuZXhwb3J0cy5HRVRfQ09ERUhBU0ggPSBcIi9hcGkvY29kZWhhc2hcIjtcbmV4cG9ydHMuR0VUX1RPS0VOX0hPTERFUl9DT1VOVCA9IFwiL2FwaS9ob2xkZXJjb3VudFwiO1xuZXhwb3J0cy5HRVRfVE9LRU5fSE9MREVSUyA9IFwiZ2V0X3Rva2VuX2hvbGRlcnNcIjtcbmV4cG9ydHMuR0VUX0FDQ09VTlRTX0ZST01fS0VZUyA9IFwiZ2V0X2FjY291bnRzX2Zyb21fa2V5c1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5kcG9pbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25ScGMgPSB2b2lkIDA7XG52YXIgZW5kcG9pbnRzXzEgPSByZXF1aXJlKFwiLi9lbmRwb2ludHNcIik7XG52YXIgcnBjZXJyb3JfMSA9IHJlcXVpcmUoXCIuL3JwY2Vycm9yXCIpO1xudmFyIGNyb3NzX2ZldGNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNyb3NzLWZldGNoXCIpKTtcbnZhciBqc29ucnBjMl93c18xID0gcmVxdWlyZShcImpzb25ycGMyLXdzXCIpO1xudmFyIGNoYWluVG9FbmRwb2ludCA9IHtcbiAgICBlb3M6IFwiaHR0cHM6Ly9hcGkubGlnaHQueGVvcy5tZVwiLFxuICAgIHRlbG9zOiBcImh0dHBzOi8vYXBpLmxpZ2h0Lnhlb3MubWVcIixcbiAgICBqdW5nbGU6IFwiaHR0cHM6Ly9saWdodGFwaS5lb3NnZW5ldmEuaW9cIixcbiAgICBib3M6IFwiaHR0cHM6Ly9saWdodGFwaS5lb3NhbXN0ZXJkYW0ubmV0XCIsXG4gICAgaW5zdGFyOiBcImh0dHBzOi8vbGlnaHRhcGkuZW9zYW1zdGVyZGFtLm5ldFwiLFxuICAgIHByb3RvbjogXCJodHRwczovL3Byb3Rvbi5saWdodC1hcGkubmV0XCIsXG4gICAgd2F4OiBcImh0dHBzOi8vbGlnaHRhcGkuZW9zYW1zdGVyZGFtLm5ldFwiLFxuICAgIHdvcmJsaTogXCJodHRwczovL2xpZ2h0YXBpLmVvc2Ftc3RlcmRhbS5uZXRcIixcbiAgICB4ZWM6IFwiaHR0cHM6Ly9saWdodGFwaS5lb3NhbXN0ZXJkYW0ubmV0XCIsXG4gICAgcHJvdG9udGVzdDogXCJodHRwczovL3Rlc3RuZXQtbGlnaHRhcGkuZW9zYW1zLnhlb3MubWVcIixcbiAgICB0ZWxvc3Rlc3Q6IFwiaHR0cHM6Ly90ZXN0bmV0LWxpZ2h0YXBpLmVvc2Ftcy54ZW9zLm1lXCIsXG4gICAgd2F4dGVzdDogXCJodHRwczovL3Rlc3RuZXQtbGlnaHRhcGkuZW9zYW1zLnhlb3MubWVcIixcbiAgICBjb2ZmZTogXCJodHRwczovL2h5cGVyaW9uLmNvZmZlLmlvXCIsXG59O1xuZnVuY3Rpb24gZmV0Y2hXaXRoVGltZW91dChyZXNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWVvdXQsIGNvbnRyb2xsZXIsIGlkLCByZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xsZXIuYWJvcnQoKTsgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBjcm9zc19mZXRjaF8xLmRlZmF1bHQpKHJlc291cmNlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEpzb25ScGNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgTElHSFQgQVBJIGVuZHBvaW50XG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IHJwYyA9IG5ldyBKc29uUnBjKFwicHJvdG9uXCIpXG4gKi9cbnZhciBKc29uUnBjID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb25ScGMoY2hhaW4sIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0ge307IH1cbiAgICAgICAgdGhpcy50aW1lb3V0ID0gNTAwMDtcbiAgICAgICAgdGhpcy53c1JlcXVlc3RJZCA9IDEwMDtcbiAgICAgICAgdGhpcy5jaGFpbiA9IGNoYWluO1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gYXJncy5lbmRwb2ludCB8fCBjaGFpblRvRW5kcG9pbnRbY2hhaW5dO1xuICAgICAgICB0aGlzLndzQ2xpZW50ID0gbmV3IGpzb25ycGMyX3dzXzEuQ2xpZW50KHRoaXMuZW5kcG9pbnQucmVwbGFjZSgnaHR0cHM6JywgJ3dzczonKSArICcvd3NhcGknKTtcbiAgICAgICAgaWYgKCF0aGlzLmVuZHBvaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFpbiBcIi5jb25jYXQoY2hhaW4sIFwiIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IGVuZHBvaW50LCBwcm92aWRlIG9uZSBpbiBhcmdzXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBhcmdzLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0XG4gICAgICpcbiAgICAgKiBHRVQgYHBhcmFtc2AgdG8gYGVuZHBvaW50ICsgcGF0aGAuXG4gICAgICogVGhyb3dzIGRldGFpbGVkIGVycm9yIGluZm9ybWF0aW9uIGluIGBScGNFcnJvcmAgd2hlbiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXRoLCBlbmRwb2ludCkge1xuICAgICAgICBpZiAoZW5kcG9pbnQgPT09IHZvaWQgMCkgeyBlbmRwb2ludCA9IHRoaXMuZW5kcG9pbnQ7IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlLCBqc29uLCB1cmwsIHRleHQsIGVfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IGVuZHBvaW50ICsgcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoV2l0aFRpbWVvdXQodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcnBjZXJyb3JfMS5ScGNTdGF0dXNFcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS50ZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5wcm9jZXNzZWQgJiYganNvbi5wcm9jZXNzZWQuZXhjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBycGNlcnJvcl8xLlJwY0Vycm9yKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMS5pc0ZldGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJwY2Vycm9yXzEuUnBjRXJyb3IoanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywganNvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL2FjY291bnRdXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBhbGwgdG9rZW4gYmFsYW5jZXMsIHJlc291cmNlcyBhbmQgYXV0aG9yaXphdGlvbiBpbmZvcm1hdGlvbiBmb3IgYW4gYWNjb3VudDpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50TmFtZSBuYW1lIG9mIGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRBY2NvdW50Pn0gYWNjb3VudFxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9hY2NvdW50ID0gZnVuY3Rpb24gKGFjY291bnROYW1lKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfQUNDT1VOVCwgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluLCBcIi9cIikuY29uY2F0KGFjY291bnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvYWNjaW5mb11cbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGFsbCByZXNvdXJjZXMgYW5kIGF1dGhvcml6YXRpb24gaW5mb3JtYXRpb24gZm9yIGFuIGFjY291bnQ6XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudE5hbWUgbmFtZSBvZiBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0QWNjb3VudEluZm8+fSBhY2NvdW50XG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2FjY291bnRfaW5mbyA9IGZ1bmN0aW9uIChhY2NvdW50TmFtZSkge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX0FDQ09VTlRfSU5GTywgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluLCBcIi9cIikuY29uY2F0KGFjY291bnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvYmFsYW5jZXNdXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBvbmx5IHRva2VuIGJhbGFuY2VzIGZvciBhbiBhY2NvdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudE5hbWUgbmFtZSBvZiBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0QmFsYW5jZXM+fSBiYWxhbmNlc1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9iYWxhbmNlcyA9IGZ1bmN0aW9uIChhY2NvdW50TmFtZSkge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX0JBTEFOQ0VTLCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4sIFwiL1wiKS5jb25jYXQoYWNjb3VudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS9rZXldXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBhbGwgYWNjb3VudHMgaW4gYWxsIGtub3duIEVPUyBuZXR3b3JrcyBkZXBlbmRlbnQgb24gYSBwdWJsaWMga2V5OlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBwdWJsaWMga2V5XG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0S2V5QWNjb3VudHNbXT59IGFjY291bnRzIHBlciBuZXR3b3JrXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2FsbF9rZXlfYWNjb3VudHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChuZXcgU2V0KE9iamVjdC52YWx1ZXMoY2hhaW5Ub0VuZHBvaW50KSkpLCBmYWxzZSkubWFwKGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfS0VZX0FDQ09VTlRTLCBcIi9cIikuY29uY2F0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldCh1cmwsIGVuZHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwocHJvbWlzZXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkva2V5XVxuICAgICAqXG4gICAgICogUmV0cmlldmUgYWxsIGFjY291bnRzIGluIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgcHVibGljIGtleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldEtleUFjY291bnRzPn0gYWNjb3VudHNcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfa2V5X2FjY291bnRzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXJsO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9LRVlfQUNDT1VOVFMsIFwiL1wiKS5jb25jYXQoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5nZXQodXJsKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvbmV0d29ya3NdXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBhbGwgYWNjb3VudHMgaW4gYWxsIGtub3duIEVPUyBuZXR3b3JrcyBkZXBlbmRlbnQgb24gYSBwdWJsaWMga2V5OlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0TmV0d29ya3M+fSBhY2NvdW50c1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9uZXR3b3JrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGVuZHBvaW50c18xLkdFVF9ORVRXT1JLUyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvc3luY11cbiAgICAgKlxuICAgICAqIHJldHVybnMgYSBwbGFpbiB0ZXh0IHdpdGggZGVsYXkgaW4gc2Vjb25kcyB0aGF0IHRoaXMgc2VydmVyJ3MgYmxvY2tjaGFpbiBkYXRhYmFzZSBpcyBiZWhpbmQgdGhlIHJlYWwgdGltZSwgYW5kIGEgc3RhdHVzOiBPSyBpZiB0aGUgZGVsYXkgaXMgd2l0aGluIDE4MCBzZWNvbmRzLCBvciAnT1VUX09GX1NZTkMnIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IGdldCBzeW5jXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3N5bmNfaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9TWU5DX0lORk8sIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0dFVCAvYXBpL3Rva2VuYmFsYW5jZV1cbiAgICAgKlxuICAgICAqICByZXR1cm5zIGEgcGxhaW4gdGV4dCB3aXRoIG51bWVyaWMgb3V0cHV0IGluZGljYXRpbmcgdGhlIHRva2VuIGJhbGFuY2UuIFplcm8gaXMgcmV0dXJuZWQgaWYgdGhlIHRva2VuIGlzIG5vdCBwcmVzZW50IG9yIGRvZXMgbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnQgb3duZXIgb2YgdG9rZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3QgdG9rZW4gY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gdG9rZW4gc3ltYm9sXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gdG9rZW4gYmFsYW5jZVxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90b2tlbl9iYWxhbmNlID0gZnVuY3Rpb24gKGFjY291bnQsIGNvbnRyYWN0LCB0b2tlbikge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX1RPS0VOX0JBTEFOQ0UsIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbiwgXCIvXCIpLmNvbmNhdChhY2NvdW50LCBcIi9cIikuY29uY2F0KGNvbnRyYWN0LCBcIi9cIikuY29uY2F0KHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvdG9waG9sZGVyc11cbiAgICAgKlxuICAgICAqIHJldHVybnMgdG9wIE5VTSBob2xkZXJzIG9mIGEgc3BlY2lmaWVkIHRva2VuIGluIGEgSlNPTiBhcnJheSBjb250YWluaW5nIGFycmF5cyBvZiAoYWNjb3VudCwgYW1vdW50KSBwYWlycy4gTlVNIG11c3Qgbm90IGJlIGxlc3MgdGhhbiAxMCBvciBtb3JlIHRoYW4gMTAwMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdCB0b2tlbiBjb250cmFjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiB0b2tlbiBzeW1ib2xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtIG51bWJlciBvZiB0b3AgaG9sZGVycyAobWluIDEwLCBtYXggMTAwMClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IHRva2VuIGJhbGFuY2VcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdG9waG9sZGVycyA9IGZ1bmN0aW9uIChjb250cmFjdCwgdG9rZW4sIG51bSkge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX1RPUEhPTERFUlMsIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbiwgXCIvXCIpLmNvbmNhdChjb250cmFjdCwgXCIvXCIpLmNvbmNhdCh0b2tlbiwgXCIvXCIpLmNvbmNhdChudW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtHRVQgL2FwaS91c2VyY291bnRdXG4gICAgICpcbiAgICAgKiByZXR1cm5zIGEgcGxhaW4gdGV4dCB3aXRoIHRvdGFsIG51bWJlciBvZiBhY2NvdW50cyBpbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IHRva2VuIGJhbGFuY2VcbiAgICAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfdXNlcmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX1VTRVJDT1VOVCwgXCIvXCIpLmNvbmNhdCh0aGlzLmNoYWluKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvdG9wcmFtXVxuICAgICAqXG4gICAgICogcmV0dXJucyB0b3AgTlVNIFJBTSBidXllcnMgaW4gYSBKU09OIGFycmF5IGNvbnRhaW5pbmcgYXJyYXlzIG9mIChhY2NvdW50LCBieXRlcykgcGFpcnMuIE5VTSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gMTAgb3IgbW9yZSB0aGFuIDEwMDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtIG51bWJlciBvZiB0b3AgaG9sZGVycyAobWluIDEwLCBtYXggMTAwMClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdldFRvcFJhbT59IHRvcCByYW0gaG9sZGVyc1xuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90b3ByYW0gPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChlbmRwb2ludHNfMS5HRVRfVE9QUkFNLCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4sIFwiL1wiKS5jb25jYXQobnVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvdG9wc3Rha2VdXG4gICAgICpcbiAgICAgKiByZXR1cm5zIHRvcCBOVU0gUkFNIGJ1eWVycyBpbiBhIEpTT04gYXJyYXkgY29udGFpbmluZyBhcnJheXMgb2YgKGFjY291bnQsIGJ5dGVzKSBwYWlycy4gTlVNIG11c3Qgbm90IGJlIGxlc3MgdGhhbiAxMCBvciBtb3JlIHRoYW4gMTAwMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW0gcmV0dXJucyB0b3AgTlVNIHN0YWtlIGhvbGRlcnMgYnkgc3VtIG9mIENQVSBhbmQgTmV0IHN0YWtlcywgaW4gYSBKU09OIGFycmF5IGNvbnRhaW5pbmcgYXJyYXlzIG9mIChhY2NvdW50LCBjcHVfd2VpZ2h0LCBuZXRfd2VpZ2h0KSB0dXBsZXMuIE5VTSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gMTAgb3IgbW9yZSB0aGFuIDEwMDAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRUb3BTdGFrZT59IHRvcCBzdGFrZSBob2xkZXJzXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3RvcHN0YWtlID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoZW5kcG9pbnRzXzEuR0VUX1RPUFNUQUtFLCBcIi9cIikuY29uY2F0KHRoaXMuY2hhaW4sIFwiL1wiKS5jb25jYXQobnVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvY29kZWhhc2hdXG4gICAgICpcbiAgICAgKiByZXRyaWV2ZXMgYWxsIGFjY291bnRzIGluIGFsbCBrbm93biBFT1MgbmV0d29ya3MgYnkgY29udHJhY3QgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW0gcmV0dXJucyB0b3AgTlVNIHN0YWtlIGhvbGRlcnMgYnkgc3VtIG9mIENQVSBhbmQgTmV0IHN0YWtlcywgaW4gYSBKU09OIGFycmF5IGNvbnRhaW5pbmcgYXJyYXlzIG9mIChhY2NvdW50LCBjcHVfd2VpZ2h0LCBuZXRfd2VpZ2h0KSB0dXBsZXMuIE5VTSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gMTAgb3IgbW9yZSB0aGFuIDEwMDAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXRDb2RlaGFzaD59IGFjY291bnRzXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2NvZGVoYXNoID0gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9DT0RFSEFTSCwgXCIvXCIpLmNvbmNhdChoYXNoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbR0VUIC9hcGkvaG9sZGVyY291bnRdXG4gICAgICpcbiAgICAgKiByZXR1cm5zIGEgcGxhaW50ZXh0IGludGVnZXIgaW5kaWNhdGluZyB0aGUgbnVtYmVyIG9mIGFjY291bnRzIHdpdGggcG9zaXRpdmUgYmFsYW5jZSBmb3IgYSBzcGVjaWZpZWQgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3QgdG9rZW4gY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gdG9rZW4gc3ltYm9sXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBjb3VudFxuICAgICAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90b2tlbmhvbGRlcl9jb3VudCA9IGZ1bmN0aW9uIChjb250cmFjdCwgdG9rZW4pIHtcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGVuZHBvaW50c18xLkdFVF9UT0tFTl9IT0xERVJfQ09VTlQsIFwiL1wiKS5jb25jYXQodGhpcy5jaGFpbiwgXCIvXCIpLmNvbmNhdChjb250cmFjdCwgXCIvXCIpLmNvbmNhdCh0b2tlbik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW1dTIGdldF90b2tlbl9ob2xkZXJzXVxuICAgICAqXG4gICAgICogR2V0IGFsbCB0b2tlbiBob2xkZXJzIG9mIGEgY29udHJhY3QgYW5kIHN5bWJvbFxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0IHRva2VuIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHRva2VuIHRva2VuIHN5bWJvbFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X3Rva2VuX2hvbGRlcnMgPSBmdW5jdGlvbiAoY29udHJhY3QsIHRva2VuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXFJZCA9ICsrdGhpcy53c1JlcXVlc3RJZDtcbiAgICAgICAgdmFyIGJhbGFuY2VzID0gW107XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy53c0NsaWVudC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfSk7XG4gICAgICAgICAgICBfdGhpcy53c0NsaWVudC5tZXRob2RzLnNldCgncmVxZGF0YScsIGZ1bmN0aW9uIChfLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJhbGFuY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmFsYW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IHBhcmFtcy5kYXRhLmFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogK3BhcmFtcy5kYXRhLmFtb3VudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy53c0NsaWVudC5jYWxsKGVuZHBvaW50c18xLkdFVF9UT0tFTl9IT0xERVJTLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcWlkOiByZXFJZCxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogX3RoaXMuY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBjb250cmFjdCxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IHRva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbV1MgZ2V0X2FjY291bnRzX2Zyb21fa2V5c11cbiAgICAgKlxuICAgICAqIEdldCBhbGwgdG9rZW4gaG9sZGVycyBvZiBhIGNvbnRyYWN0IGFuZCBzeW1ib2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlzW10gYXJyYXkgb2Yga2V5c1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2FjY291bnRzX2Zyb21fa2V5cyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXFJZCA9ICsrdGhpcy53c1JlcXVlc3RJZDtcbiAgICAgICAgdmFyIGFjY291bnRzID0gW107XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy53c0NsaWVudC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfSk7XG4gICAgICAgICAgICBfdGhpcy53c0NsaWVudC5tZXRob2RzLnNldCgncmVxZGF0YScsIGZ1bmN0aW9uIChfLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFjY291bnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjb3VudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRfbmFtZTogcGFyYW1zLmRhdGEuYWNjb3VudF9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBwZXJtOiBwYXJhbXMuZGF0YS5wZXJtLFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6ICtwYXJhbXMuZGF0YS53ZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHB1YmtleTogcGFyYW1zLmRhdGEucHVia2V5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF90aGlzLndzQ2xpZW50LmNhbGwoZW5kcG9pbnRzXzEuR0VUX0FDQ09VTlRTX0ZST01fS0VZUywge1xuICAgICAgICAgICAgICAgICAgICByZXFpZDogcmVxSWQsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcms6IF90aGlzLmNoYWluLFxuICAgICAgICAgICAgICAgICAgICBrZXlzOiBrZXlzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSnNvblJwYztcbn0oKSk7XG5leHBvcnRzLkpzb25ScGMgPSBKc29uUnBjO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbnJwYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJwY1N0YXR1c0Vycm9yID0gZXhwb3J0cy5ScGNFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogQHByaXZhdGVcbiAqIEBtb2R1bGUgUlBDLUVycm9yXG4gKlxuICogY29weXJpZ2h0IGRlZmluZWQgaW4gZW9zanMvTElDRU5TRS50eHRcbiAqL1xudmFyIFJwY0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhScGNFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBScGNFcnJvcihqc29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChqc29uLmVycm9yICYmIGpzb24uZXJyb3IuZGV0YWlscyAmJiBqc29uLmVycm9yLmRldGFpbHMubGVuZ3RoICYmIGpzb24uZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlKSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGpzb24uZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24ucHJvY2Vzc2VkICYmIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdCAmJiBqc29uLnByb2Nlc3NlZC5leGNlcHQubWVzc2FnZSkge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBqc29uLnByb2Nlc3NlZC5leGNlcHQubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywganNvbi5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUnBjRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgX3RoaXMuanNvbiA9IGpzb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJwY0Vycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5ScGNFcnJvciA9IFJwY0Vycm9yO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgUnBjU3RhdHVzRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJwY1N0YXR1c0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJwY1N0YXR1c0Vycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNSkge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZXNwb25zZS5zdGF0dXNUZXh0KSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUnBjU3RhdHVzRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgX3RoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUnBjU3RhdHVzRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlJwY1N0YXR1c0Vycm9yID0gUnBjU3RhdHVzRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ycGNlcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCJpbXBvcnQgeyBzdHJpbmcsIG9iamVjdCwgYXJyYXksIGxpdGVyYWwsIG51bWJlciwgYW55LCBuYXRpdmVFbnVtLCBib29sZWFuIH0gZnJvbSAnem9kJztcblxudmFyIF9zaW1pbGFyQ2hhaW5zLCBfZXhwbG9yZXJMaW5rQnlDaGFpbjtcblxudmFyIENoYWlucztcblxuKGZ1bmN0aW9uIChDaGFpbnMpIHtcbiAgQ2hhaW5zW1wiQml0Y29pbk1haW5uZXRcIl0gPSBcIkJpdGNvaW5cIjtcbiAgQ2hhaW5zW1wiQml0Y29pblRlc3RuZXRcIl0gPSBcIkJpdGNvaW4gKFRlc3RuZXQpXCI7XG4gIENoYWluc1tcIkV0aGVyZXVtTWFpbm5ldFwiXSA9IFwiRXRoZXJldW1cIjtcbiAgQ2hhaW5zW1wiRXRoZXJldW1Sb3BzdGVuXCJdID0gXCJFdGhlcmV1bSAoUm9wc3RlbilcIjtcbiAgQ2hhaW5zW1wiTGl0ZWNvaW5NYWlubmV0XCJdID0gXCJMaXRlY29pblwiO1xuICBDaGFpbnNbXCJMaXRlY29pblRlc3RuZXRcIl0gPSBcIkxpdGVjb2luIChUZXN0bmV0KVwiO1xuICBDaGFpbnNbXCJCaXRjb2luQ2FzaE1haW5uZXRcIl0gPSBcIkJpdGNvaW4gQ2FzaFwiO1xuICBDaGFpbnNbXCJCaXRjb2luQ2FzaFRlc3RuZXRcIl0gPSBcIkJpdGNvaW4gQ2FzaCAoVGVzdG5ldClcIjtcbiAgQ2hhaW5zW1wiU3RlbGxhck1haW5uZXRcIl0gPSBcIlN0ZWxsYXJcIjtcbiAgQ2hhaW5zW1wiU3RlbGxhclRlc3RuZXRcIl0gPSBcIlN0ZWxsYXIgKFRlc3RuZXQpXCI7XG4gIENoYWluc1tcIlByb3Rvbk1haW5uZXRcIl0gPSBcIlByb3RvblwiO1xuICBDaGFpbnNbXCJQcm90b25UZXN0bmV0XCJdID0gXCJQcm90b24gKFRlc3RuZXQpXCI7XG4gIENoYWluc1tcIlBvbGthZG90TWFpbm5ldFwiXSA9IFwiUG9sa2Fkb3RcIjtcbiAgQ2hhaW5zW1wiQmluYW5jZUJFUDJcIl0gPSBcIkJpbmFuY2UgKEJFUDIpXCI7XG4gIENoYWluc1tcIkJpbmFuY2VCRVAyMFwiXSA9IFwiQmluYW5jZSAoQkVQMjApXCI7XG4gIENoYWluc1tcIkVvc01haW5uZXRcIl0gPSBcIkVPU1wiO1xuICBDaGFpbnNbXCJFb3NUZXN0bmV0XCJdID0gXCJFT1MgKEp1bmdsZSBUZXN0bmV0KVwiO1xuICBDaGFpbnNbXCJIZWRlcmFNYWlubmV0XCJdID0gXCJIZWRlcmEgKE1haW5uZXQpXCI7XG4gIENoYWluc1tcIkhlZGVyYVRlc3RuZXRcIl0gPSBcIkhlZGVyYSAoVGVzdG5ldClcIjtcbiAgQ2hhaW5zW1wiRG9nZU1haW5uZXRcIl0gPSBcIkRvZ2Vjb2luXCI7XG4gIENoYWluc1tcIkNhcmRhbm9NYWlubmV0XCJdID0gXCJDYXJkYW5vXCI7XG4gIENoYWluc1tcIkF2YWxhbmNoZVhDaGFpblwiXSA9IFwiQXZhbGFuY2hlIFgtQ2hhaW5cIjtcbiAgQ2hhaW5zW1wiQXZhbGFuY2hlQ0NoYWluXCJdID0gXCJBdmFsYW5jaGUgQy1DaGFpblwiO1xuICBDaGFpbnNbXCJQb2x5Z29uTWFpbm5ldFwiXSA9IFwiUG9seWdvblwiO1xuICBDaGFpbnNbXCJUZXJyYU1haW5uZXRcIl0gPSBcIlRlcnJhXCI7XG59KShDaGFpbnMgfHwgKENoYWlucyA9IHt9KSk7XG5cbnZhciBOZXR3b3JrcztcblxuKGZ1bmN0aW9uIChOZXR3b3Jrcykge1xuICBOZXR3b3Jrc1tcIk1haW5uZXRcIl0gPSBcIm1haW5uZXRcIjtcbiAgTmV0d29ya3NbXCJUZXN0bmV0XCJdID0gXCJ0ZXN0bmV0XCI7XG4gIE5ldHdvcmtzW1wiUm9wc3RlblwiXSA9IFwicm9wc3RlblwiO1xuICBOZXR3b3Jrc1tcIkVSQzIwXCJdID0gXCJlcmMyMFwiO1xuICBOZXR3b3Jrc1tcIkJFUDIwXCJdID0gXCJiZXAyMFwiO1xuICBOZXR3b3Jrc1tcIlhMTVwiXSA9IFwieGxtXCI7XG59KShOZXR3b3JrcyB8fCAoTmV0d29ya3MgPSB7fSkpO1xuXG52YXIgc2ltaWxhckNoYWlucyA9IChfc2ltaWxhckNoYWlucyA9IHt9LCBfc2ltaWxhckNoYWluc1tDaGFpbnMuRXRoZXJldW1NYWlubmV0XSA9IFtDaGFpbnMuQmluYW5jZUJFUDIwXSwgX3NpbWlsYXJDaGFpbnNbQ2hhaW5zLkJpbmFuY2VCRVAyMF0gPSBbQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldF0sIF9zaW1pbGFyQ2hhaW5zKTtcbnZhciBleHBsb3JlckxpbmtCeUNoYWluID0gKF9leHBsb3JlckxpbmtCeUNoYWluID0ge30sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5CaXRjb2luTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2Jsb2NrY2hhaW4uY29tL2J0Yy90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuQml0Y29pblRlc3RuZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ibG9ja3N0cmVhbS5pbmZvL3Rlc3RuZXQvdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2V0aGVyc2Nhbi5pby90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuRXRoZXJldW1Sb3BzdGVuXSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vcm9wc3Rlbi5ldGhlcnNjYW4uaW8vdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkxpdGVjb2luTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2Jsb2NrY2hhaXIuY29tL2xpdGVjb2luL3RyYW5zYWN0aW9uL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5MaXRlY29pblRlc3RuZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ibG9ja2V4cGxvcmVyLm9uZS9saXRlY29pbi90ZXN0bmV0L2Jsb2NrSGFzaC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuQml0Y29pbkNhc2hNYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmxvY2tjaGFpci5jb20vYml0Y29pbi1jYXNoL3RyYW5zYWN0aW9uL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5CaXRjb2luQ2FzaFRlc3RuZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9ibG9ja2V4cGxvcmVyLm9uZS9iaXRjb2luLWNhc2gvdGVzdG5ldC9ibG9ja0hhc2gvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLlN0ZWxsYXJNYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmxvY2tjaGFpci5jb20vc3RlbGxhci90cmFuc2FjdGlvbi9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuU3RlbGxhclRlc3RuZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly90ZXN0bmV0LnN0ZWV4cC5jb20vdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLlByb3Rvbk1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9wcm90b24uYmxva3MuaW8vdHJhbnNhY3Rpb24vXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLlByb3RvblRlc3RuZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9wcm90b24tdGVzdC5ibG9rcy5pby90cmFuc2FjdGlvbi9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuUG9sa2Fkb3RNYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vcG9sa2Fkb3Quc3Vic2Nhbi5pby9leHRyaW5zaWMvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkJpbmFuY2VCRVAyXSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmluYW5jZS5taW50c2Nhbi5pby90eHMvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkJpbmFuY2VCRVAyMF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2JzY3NjYW4uY29tL3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5Fb3NNYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmxva3MuaW8vdHJhbnNhY3Rpb24vXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkVvc1Rlc3RuZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9qdW5nbGUuYmxva3MuaW8vdHJhbnNhY3Rpb24vXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkhlZGVyYU1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9hcHAuZHJhZ29uZ2xhc3MubWUvdHJhbnNhY3Rpb25zL1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluW0NoYWlucy5IZWRlcmFUZXN0bmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vdGVzdG5ldC5kcmFnb25nbGFzcy5tZS90cmFuc2FjdGlvbnMvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkRvZ2VNYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYmxvY2tjaGFpci5jb20vZG9nZWNvaW4vdHJhbnNhY3Rpb24vXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkNhcmRhbm9NYWlubmV0XSA9IGZ1bmN0aW9uICh0eGlkKSB7XG4gIHJldHVybiBcImh0dHBzOi8vZXhwbG9yZXIuY2FyZGFuby5vcmcvZW4vdHJhbnNhY3Rpb24/aWQ9XCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkF2YWxhbmNoZVhDaGFpbl0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL2F2YXNjYW4uaW5mby9ibG9ja2NoYWluL3gvdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLkF2YWxhbmNoZUNDaGFpbl0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL3Nub3d0cmFjZS5pby90eC9cIiArIHR4aWQ7XG59LCBfZXhwbG9yZXJMaW5rQnlDaGFpbltDaGFpbnMuUG9seWdvbk1haW5uZXRdID0gZnVuY3Rpb24gKHR4aWQpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9wb2x5Z29uc2Nhbi5jb20vdHgvXCIgKyB0eGlkO1xufSwgX2V4cGxvcmVyTGlua0J5Q2hhaW5bQ2hhaW5zLlRlcnJhTWFpbm5ldF0gPSBmdW5jdGlvbiAodHhpZCkge1xuICByZXR1cm4gXCJodHRwczovL3RlcnJhLnN0YWtlLmlkLz8jL3R4L1wiICsgdHhpZDtcbn0sIF9leHBsb3JlckxpbmtCeUNoYWluKTtcbnZhciBpbml0aWFsaXplQ29pbnMgPSBmdW5jdGlvbiBpbml0aWFsaXplQ29pbnMocHJvdG9uQ2hhaW4pIHtcbiAgdmFyIElTX01BSU5ORVQgPSBwcm90b25DaGFpbiA9PT0gJ3Byb3Rvbic7XG4gIHZhciBJU19URVNUTkVUID0gcHJvdG9uQ2hhaW4gPT09ICdwcm90b24tdGVzdCc7XG4gIHZhciBjb2lucyA9IFt7XG4gICAgYWxsb3dTd2FwOiB0cnVlLFxuICAgIGFsbG93QnJpZGdlOiBJU19NQUlOTkVULFxuICAgIGFsbG93TGVuZDogdHJ1ZSxcbiAgICBhbGxvd0JvcnJvdzogdHJ1ZSxcbiAgICBuYW1lOiAnUHJvdG9uJyxcbiAgICBjb2luOiAnWFBSJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYUFInLFxuICAgIHh0b2tlblByZWNpc2lvbjogNCxcbiAgICB4dG9rZW5Db250cmFjdDogJ2Vvc2lvLnRva2VuJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdYUFItRVJDMjAnLFxuICAgICAgc3ltYm9sOiAnWFBSJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDQsXG4gICAgICBjb250cmFjdDogJzB4RDdFRkIwMEQxMkMyQzEzMTMxRkQzMTkzMzZGREY5NTI1MjVEQTJBRicsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfSwge1xuICAgICAgd2FsbGV0OiAnWFBSLUJFUDIwJyxcbiAgICAgIHN5bWJvbDogJ1hQUicsXG4gICAgICBjaGFpbjogQ2hhaW5zLkJpbmFuY2VCRVAyMCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkJFUDIwLFxuICAgICAgcHJlY2lzaW9uOiA0LFxuICAgICAgY29udHJhY3Q6ICcweDVERTM5MzlCMkY4MTFBNjFEODMwRTZGNTJEMTNCMDY2ODgxNDEyQUInLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMvZW9zaW8tdG9rZW5YUFIucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3Byb3RvbidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogdHJ1ZSxcbiAgICBhbGxvd0JyaWRnZTogdHJ1ZSxcbiAgICBhbGxvd0xlbmQ6IHRydWUsXG4gICAgYWxsb3dCb3Jyb3c6IHRydWUsXG4gICAgbmFtZTogJ1VTRCBDb2luJyxcbiAgICBjb2luOiAnVVNEQycsXG4gICAgeHRva2VuU3ltYm9sOiAnWFVTREMnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1VTREMnLFxuICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiA2LFxuICAgICAgY29udHJhY3Q6ICcweEEwQjg2OTkxQzYyMThCMzZDMUQxOUQ0QTJFOUVCMENFMzYwNkVCNDgnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHdhbGxldDogJ1VTREMtQkVQMjAnLFxuICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkJpbmFuY2VCRVAyMCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkJFUDIwLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHg4QUM3NkE1MUNDOTUwRDk4MjJENjhCODNGRTFBRDk3QjMyQ0Q1ODBEJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9LCB7XG4gICAgICB3YWxsZXQ6ICdVU0RDLVhMTScsXG4gICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuU3RlbGxhck1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5YTE0sXG4gICAgICBwcmVjaXNpb246IDcsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiB0cnVlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdVU0RDJyxcbiAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bVJvcHN0ZW4sXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5Sb3BzdGVuLFxuICAgICAgcHJlY2lzaW9uOiA2LFxuICAgICAgY29udHJhY3Q6ICcweEEwQjg2OTkxQzYyMThCMzZDMUQxOUQ0QTJFOUVCMENFMzYwNkVCNDgnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hVU0RDLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICd1c2QtY29pbidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogdHJ1ZSxcbiAgICBhbGxvd0JyaWRnZTogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0xlbmQ6IHRydWUsXG4gICAgYWxsb3dCb3Jyb3c6IHRydWUsXG4gICAgbmFtZTogJ01ldGFsJyxcbiAgICBjb2luOiAnTVRMJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYTVQnLFxuICAgIHh0b2tlblByZWNpc2lvbjogOCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ01UTCcsXG4gICAgICBzeW1ib2w6ICdNVEwnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogOCxcbiAgICAgIGNvbnRyYWN0OiAnMHhGNDMzMDg5MzY2ODk5RDgzQTlGMjZBNzczRDU5RUM3RUNGMzAzNTVFJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYTVQucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ21ldGFsJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiB0cnVlLFxuICAgIGFsbG93QnJpZGdlOiB0cnVlLFxuICAgIGFsbG93TGVuZDogdHJ1ZSxcbiAgICBhbGxvd0JvcnJvdzogdHJ1ZSxcbiAgICBuYW1lOiAnQml0Y29pbicsXG4gICAgY29pbjogJ0JUQycsXG4gICAgeHRva2VuU3ltYm9sOiAnWEJUQycsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA4LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnQlRDJyxcbiAgICAgIHN5bWJvbDogJ0JUQycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkJpdGNvaW5NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogOCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdCVEMnLFxuICAgICAgc3ltYm9sOiAnQlRDJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQml0Y29pblRlc3RuZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5UZXN0bmV0LFxuICAgICAgcHJlY2lzaW9uOiA4LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYQlRDLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdiaXRjb2luJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiB0cnVlLFxuICAgIGFsbG93QnJpZGdlOiB0cnVlLFxuICAgIGFsbG93TGVuZDogdHJ1ZSxcbiAgICBhbGxvd0JvcnJvdzogdHJ1ZSxcbiAgICBuYW1lOiAnRXRoZXJldW0nLFxuICAgIGNvaW46ICdFVEgnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hFVEgnLFxuICAgIHh0b2tlblByZWNpc2lvbjogOCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0VUSCcsXG4gICAgICBzeW1ib2w6ICdFVEgnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdLCBJU19URVNUTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0VUSCcsXG4gICAgICBzeW1ib2w6ICdFVEgnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bVJvcHN0ZW4sXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5Sb3BzdGVuLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYRVRILnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdldGhlcmV1bSdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogdHJ1ZSxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0xvYW4nLFxuICAgIGNvaW46ICdMT0FOJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdMT0FOJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDQsXG4gICAgeHRva2VuQ29udHJhY3Q6ICdsb2FuLnRva2VuJyxcbiAgICB3YWxsZXRzOiBbXSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL2xvYW4udG9rZW5MT0FOLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdwcm90b24tbG9hbidcbiAgfSwge1xuICAgIGFsbG93U3dhcDogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0JyaWRnZTogdHJ1ZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnVGV0aGVyJyxcbiAgICBjb2luOiAnVVNEVCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWFVTRFQnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1VTRFQnLFxuICAgICAgc3ltYm9sOiAnVVNEVCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkVSQzIwLFxuICAgICAgcHJlY2lzaW9uOiA2LFxuICAgICAgY29udHJhY3Q6ICcweERBQzE3Rjk1OEQyRUU1MjNBMjIwNjIwNjk5NDU5N0MxM0Q4MzFFQzcnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnVVNEVCcsXG4gICAgICBzeW1ib2w6ICdVU0RUJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1Sb3BzdGVuLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuUm9wc3RlbixcbiAgICAgIHByZWNpc2lvbjogNixcbiAgICAgIGNvbnRyYWN0OiAnMHhEQUMxN0Y5NThEMkVFNTIzQTIyMDYyMDY5OTQ1OTdDMTNEODMxRUM3JyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYVVNEVC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAndGV0aGVyJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnVHJ1ZVVTRCcsXG4gICAgY29pbjogJ1RVU0QnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hUVVNEJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdUVVNEJyxcbiAgICAgIHN5bWJvbDogJ1RVU0QnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4MDAwMDAwMDAwMDA4NUQ0NzgwQjczMTE5QjY0NEFFNUVDRDIyQjM3NicsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWFRVU0QucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3RydWUtdXNkJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnUGF4b3MgU3RhbmRhcmQnLFxuICAgIGNvaW46ICdQQVgnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hQQVgnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ1BBWCcsXG4gICAgICBzeW1ib2w6ICdQQVgnLFxuICAgICAgY2hhaW46IENoYWlucy5FdGhlcmV1bU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5FUkMyMCxcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4OEU4NzBENjdGNjYwRDk1RDVCRTUzMDM4MEQwRUMwQkQzODgyODlFMScsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWFBBWC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAndXNkcCdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IHRydWUsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1BheG9zIEdvbGQnLFxuICAgIGNvaW46ICdQQVhHJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYUEFYRycsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA4LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnUEFYRycsXG4gICAgICBzeW1ib2w6ICdQQVhHJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDQ1ODA0ODgwREUyMjkxM0RBRkUwOUY0OTgwODQ4RUNFNkVDQkFGNzgnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnUEFYRycsXG4gICAgICBzeW1ib2w6ICdQQVhHJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1Sb3BzdGVuLFxuICAgICAgbmV0d29yazogTmV0d29ya3MuUm9wc3RlbixcbiAgICAgIHByZWNpc2lvbjogMTgsXG4gICAgICBjb250cmFjdDogJzB4NDU4MDQ4ODBERTIyOTEzREFGRTA5RjQ5ODA4NDhFQ0U2RUNCQUY3OCcsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWFBBWEcucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3BheC1nb2xkJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBJU19NQUlOTkVULFxuICAgIGFsbG93QnJpZGdlOiB0cnVlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdVbmlzd2FwJyxcbiAgICBjb2luOiAnVU5JJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYVU5JJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdVTkknLFxuICAgICAgc3ltYm9sOiAnVU5JJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDFGOTg0MEE4NUQ1QUY1QkYxRDE3NjJGOTI1QkRBRERDNDIwMUY5ODQnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnVU5JJyxcbiAgICAgIHN5bWJvbDogJ1VOSScsXG4gICAgICBjaGFpbjogQ2hhaW5zLkV0aGVyZXVtUm9wc3RlbixcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlJvcHN0ZW4sXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDFGOTg0MEE4NUQ1QUY1QkYxRDE3NjJGOTI1QkRBRERDNDIwMUY5ODQnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hVTkkucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ3VuaXN3YXAnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnMUlOQ0gnLFxuICAgIGNvaW46ICcxSU5DSCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWElOQ0gnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJzFJTkNIJyxcbiAgICAgIHN5bWJvbDogJzFJTkNIJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDExMTExMTExMTExN0RDMEFBNzhCNzcwRkE2QTczODAzNDEyMEMzMDInLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hJTkNILnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICcxaW5jaCdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdDaGFpbmxpbmsnLFxuICAgIGNvaW46ICdMSU5LJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYTElOSycsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnTElOSycsXG4gICAgICBzeW1ib2w6ICdMSU5LJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuRXRoZXJldW1NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuRVJDMjAsXG4gICAgICBwcmVjaXNpb246IDE4LFxuICAgICAgY29udHJhY3Q6ICcweDUxNDkxMDc3MUFGOUNBNjU2QUY4NDBERkY4M0U4MjY0RUNGOTg2Q0EnLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hMSU5LLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdjaGFpbmxpbmsnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IElTX01BSU5ORVQsXG4gICAgYWxsb3dCcmlkZ2U6IHRydWUsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0xpdGVjb2luJyxcbiAgICBjb2luOiAnTFRDJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYTFRDJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDgsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdMVEMnLFxuICAgICAgc3ltYm9sOiAnTFRDJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuTGl0ZWNvaW5NYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogOCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSwgSVNfVEVTVE5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdMVEMnLFxuICAgICAgc3ltYm9sOiAnTFRDJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuTGl0ZWNvaW5UZXN0bmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuVGVzdG5ldCxcbiAgICAgIHByZWNpc2lvbjogOCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWExUQy5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnbGl0ZWNvaW4nXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IElTX01BSU5ORVQsXG4gICAgYWxsb3dCcmlkZ2U6IHRydWUsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0JpdGNvaW4gQ2FzaCcsXG4gICAgY29pbjogJ0JDSCcsXG4gICAgeHRva2VuU3ltYm9sOiAnWEJDSCcsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA4LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnQkNIJyxcbiAgICAgIHN5bWJvbDogJ0JDSCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkJpdGNvaW5DYXNoTWFpbm5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLk1haW5uZXQsXG4gICAgICBwcmVjaXNpb246IDgsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnQkNIJyxcbiAgICAgIHN5bWJvbDogJ0JDSCcsXG4gICAgICBjaGFpbjogQ2hhaW5zLkJpdGNvaW5DYXNoVGVzdG5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlRlc3RuZXQsXG4gICAgICBwcmVjaXNpb246IDgsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiBmYWxzZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hCQ0gucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2JpdGNvaW4tY2FzaCdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IGZhbHNlLFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdTdGVsbGFyJyxcbiAgICBjb2luOiAnWExNJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYWExNJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdYTE0nLFxuICAgICAgc3ltYm9sOiAnWExNJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuU3RlbGxhck1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA3LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogdHJ1ZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnWExNJyxcbiAgICAgIHN5bWJvbDogJ1hMTScsXG4gICAgICBjaGFpbjogQ2hhaW5zLlN0ZWxsYXJUZXN0bmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuVGVzdG5ldCxcbiAgICAgIHByZWNpc2lvbjogNyxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IHRydWVcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYWExNLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdzdGVsbGFyJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBJU19NQUlOTkVULFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnU2Vuc2UnLFxuICAgIGNvaW46ICdTRU5TRScsXG4gICAgeHRva2VuU3ltYm9sOiAnWFNFTlNFJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDQsXG4gICAgeHRva2VuQ29udHJhY3Q6ICdzZW5zZScsXG4gICAgd2FsbGV0czogW10sXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy9zZW5zZVhTRU5TRS5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnc2Vuc2UnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnUG9sa2Fkb3QnLFxuICAgIGNvaW46ICdET1QnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hET1QnLFxuICAgIHh0b2tlblByZWNpc2lvbjogOCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0RPVCcsXG4gICAgICBzeW1ib2w6ICdET1QnLFxuICAgICAgY2hhaW46IENoYWlucy5Qb2xrYWRvdE1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiAxMCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWERPVC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAncG9sa2Fkb3QnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IHRydWUsXG4gICAgYWxsb3dCcmlkZ2U6IElTX01BSU5ORVQsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0JpbmFuY2UgQ29pbicsXG4gICAgY29pbjogJ0JOQicsXG4gICAgeHRva2VuU3ltYm9sOiAnWEJOQicsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA4LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnQk5CJyxcbiAgICAgIHN5bWJvbDogJ0JOQicsXG4gICAgICBjaGFpbjogQ2hhaW5zLkJpbmFuY2VCRVAyMCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLkJFUDIwLFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWEJOQi5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnYmluYW5jZWNvaW4nXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IHRydWUsXG4gICAgYWxsb3dCcmlkZ2U6IHRydWUsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0VPUycsXG4gICAgY29pbjogJ0VPUycsXG4gICAgeHRva2VuU3ltYm9sOiAnWEVPUycsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA0LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX01BSU5ORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnRU9TJyxcbiAgICAgIHN5bWJvbDogJ0VPUycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkVvc01haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA0LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogdHJ1ZVxuICAgIH1dIDogW10sIElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnRU9TJyxcbiAgICAgIHN5bWJvbDogJ0VPUycsXG4gICAgICBjaGFpbjogQ2hhaW5zLkVvc1Rlc3RuZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5UZXN0bmV0LFxuICAgICAgcHJlY2lzaW9uOiA0LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogdHJ1ZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hFT1MucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2VvcydcbiAgfSwge1xuICAgIGFsbG93U3dhcDogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0JyaWRnZTogSVNfTUFJTk5FVCxcbiAgICBhbGxvd0xlbmQ6IHRydWUsXG4gICAgYWxsb3dCb3Jyb3c6IHRydWUsXG4gICAgbmFtZTogJ0RvZ2Vjb2luJyxcbiAgICBjb2luOiAnRE9HRScsXG4gICAgeHRva2VuU3ltYm9sOiAnWERPR0UnLFxuICAgIHh0b2tlblByZWNpc2lvbjogNixcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ0RPR0UnLFxuICAgICAgc3ltYm9sOiAnRE9HRScsXG4gICAgICBjaGFpbjogQ2hhaW5zLkRvZ2VNYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogOCxcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IGZhbHNlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWERPR0UucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2RvZ2Vjb2luJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBJU19NQUlOTkVULFxuICAgIGFsbG93QnJpZGdlOiBJU19NQUlOTkVULFxuICAgIGFsbG93TGVuZDogZmFsc2UsXG4gICAgYWxsb3dCb3Jyb3c6IGZhbHNlLFxuICAgIG5hbWU6ICdDYXJkYW5vJyxcbiAgICBjb2luOiAnQURBJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYQURBJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdBREEnLFxuICAgICAgc3ltYm9sOiAnQURBJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuQ2FyZGFub01haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA2LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYQURBLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICdjYXJkYW5vJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0F2YWxhbmNoZScsXG4gICAgY29pbjogJ0FWQVgnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hBVkFYJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDksXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdBVkFYJyxcbiAgICAgIHN5bWJvbDogJ0FWQVgnLFxuICAgICAgY2hhaW46IENoYWlucy5BdmFsYW5jaGVYQ2hhaW4sXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA5LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9LCB7XG4gICAgICB3YWxsZXQ6ICdBVkFYJyxcbiAgICAgIHN5bWJvbDogJ0FWQVgnLFxuICAgICAgY2hhaW46IENoYWlucy5BdmFsYW5jaGVDQ2hhaW4sXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA5LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYQVZBWC5wbmcnLFxuICAgIGNvaW5nZWNrb0lkOiAnYXZhbGFuY2hlLTInXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnUG9seWdvbicsXG4gICAgY29pbjogJ01BVElDJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYTUFUSUMnLFxuICAgIHh0b2tlblByZWNpc2lvbjogOCxcbiAgICB4dG9rZW5Db250cmFjdDogJ3h0b2tlbnMnLFxuICAgIHdhbGxldHM6IFtdLmNvbmNhdChJU19NQUlOTkVUID8gW3tcbiAgICAgIHdhbGxldDogJ01BVElDJyxcbiAgICAgIHN5bWJvbDogJ01BVElDJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuUG9seWdvbk1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiAxOCxcbiAgICAgIGNvbnRyYWN0OiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogZmFsc2VcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYTUFUSUMucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ21hdGljLW5ldHdvcmsnXG4gIH0sIHtcbiAgICBhbGxvd1N3YXA6IGZhbHNlLFxuICAgIGFsbG93QnJpZGdlOiBmYWxzZSxcbiAgICBhbGxvd0xlbmQ6IGZhbHNlLFxuICAgIGFsbG93Qm9ycm93OiBmYWxzZSxcbiAgICBuYW1lOiAnTHVuYScsXG4gICAgY29pbjogJ0xVTkEnLFxuICAgIHh0b2tlblN5bWJvbDogJ1hMVU5BJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdMVU5BJyxcbiAgICAgIHN5bWJvbDogJ0xVTkEnLFxuICAgICAgY2hhaW46IENoYWlucy5UZXJyYU1haW5uZXQsXG4gICAgICBuZXR3b3JrOiBOZXR3b3Jrcy5NYWlubmV0LFxuICAgICAgcHJlY2lzaW9uOiA2LFxuICAgICAgY29udHJhY3Q6IHVuZGVmaW5lZCxcbiAgICAgIGhhc1dpdGhkcmF3TWVtbzogdHJ1ZVxuICAgIH1dIDogW10pLFxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cucHJvdG9uY2hhaW4uY29tL2ltYWdlcy90b2tlbnMveHRva2Vuc1hMVU5BLnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICd0ZXJyYS1sdW5hJ1xuICB9LCB7XG4gICAgYWxsb3dTd2FwOiBmYWxzZSxcbiAgICBhbGxvd0JyaWRnZTogZmFsc2UsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ1RlcnJhVVNEJyxcbiAgICBjb2luOiAnVVNUJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYVVNUJyxcbiAgICB4dG9rZW5QcmVjaXNpb246IDYsXG4gICAgeHRva2VuQ29udHJhY3Q6ICd4dG9rZW5zJyxcbiAgICB3YWxsZXRzOiBbXS5jb25jYXQoSVNfTUFJTk5FVCA/IFt7XG4gICAgICB3YWxsZXQ6ICdVU1QnLFxuICAgICAgc3ltYm9sOiAnVVNUJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuVGVycmFNYWlubmV0LFxuICAgICAgbmV0d29yazogTmV0d29ya3MuTWFpbm5ldCxcbiAgICAgIHByZWNpc2lvbjogNixcbiAgICAgIGNvbnRyYWN0OiB1bmRlZmluZWQsXG4gICAgICBoYXNXaXRoZHJhd01lbW86IHRydWVcbiAgICB9XSA6IFtdKSxcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LnByb3RvbmNoYWluLmNvbS9pbWFnZXMvdG9rZW5zL3h0b2tlbnNYVVNULnBuZycsXG4gICAgY29pbmdlY2tvSWQ6ICd0ZXJyYXVzZCdcbiAgfSwge1xuICAgIGFsbG93U3dhcDogZmFsc2UsXG4gICAgYWxsb3dCcmlkZ2U6IElTX1RFU1RORVQsXG4gICAgYWxsb3dMZW5kOiBmYWxzZSxcbiAgICBhbGxvd0JvcnJvdzogZmFsc2UsXG4gICAgbmFtZTogJ0hCQVInLFxuICAgIGNvaW46ICdIQkFSJyxcbiAgICB4dG9rZW5TeW1ib2w6ICdYSEJBUicsXG4gICAgeHRva2VuUHJlY2lzaW9uOiA2LFxuICAgIHh0b2tlbkNvbnRyYWN0OiAneHRva2VucycsXG4gICAgd2FsbGV0czogW10uY29uY2F0KElTX1RFU1RORVQgPyBbe1xuICAgICAgd2FsbGV0OiAnSEJBUicsXG4gICAgICBzeW1ib2w6ICdIQkFSJyxcbiAgICAgIGNoYWluOiBDaGFpbnMuSGVkZXJhVGVzdG5ldCxcbiAgICAgIG5ldHdvcms6IE5ldHdvcmtzLlRlc3RuZXQsXG4gICAgICBwcmVjaXNpb246IDgsXG4gICAgICBjb250cmFjdDogdW5kZWZpbmVkLFxuICAgICAgaGFzV2l0aGRyYXdNZW1vOiB0cnVlXG4gICAgfV0gOiBbXSksXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5wcm90b25jaGFpbi5jb20vaW1hZ2VzL3Rva2Vucy94dG9rZW5zWEhCQVIucG5nJyxcbiAgICBjb2luZ2Vja29JZDogJ2hlZGVyYS1oYXNoZ3JhcGgnXG4gIH1dOyAvLyBWYWxpZGF0aW9uXG5cbiAgdmFyIHdhbGxldFdpdGhEdXBsaWNhdGVDaGFpbnMgPSBjb2lucy5maW5kKGZ1bmN0aW9uIChjb2luKSB7XG4gICAgdmFyIGNoYWlucyA9IGNvaW4ud2FsbGV0cy5tYXAoZnVuY3Rpb24gKHdhbGxldCkge1xuICAgICAgcmV0dXJuIHdhbGxldC5jaGFpbjtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFNldChjaGFpbnMpLnNpemUgIT09IGNoYWlucy5sZW5ndGg7XG4gIH0pO1xuXG4gIGlmICh3YWxsZXRXaXRoRHVwbGljYXRlQ2hhaW5zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29pbiBcIiArIHdhbGxldFdpdGhEdXBsaWNhdGVDaGFpbnMuY29pbiArIFwiIGhhcyBkdXBsaWNhdGUgY2hhaW5zIGluIHdhbGxldFwiKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWxsQ29pbnM6IGNvaW5zLFxuICAgIHN3YXBDb2luczogY29pbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2luKSB7XG4gICAgICByZXR1cm4gY29pbi5hbGxvd1N3YXA7XG4gICAgfSksXG4gICAgYnJpZGdlQ29pbnM6IGNvaW5zLmZpbHRlcihmdW5jdGlvbiAoY29pbikge1xuICAgICAgcmV0dXJuIGNvaW4uYWxsb3dCcmlkZ2U7XG4gICAgfSksXG4gICAgbGVuZENvaW5zOiBjb2lucy5maWx0ZXIoZnVuY3Rpb24gKGNvaW4pIHtcbiAgICAgIHJldHVybiBjb2luLmFsbG93TGVuZDtcbiAgICB9KSxcbiAgICBib3Jyb3dDb2luczogY29pbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2luKSB7XG4gICAgICByZXR1cm4gY29pbi5hbGxvd0JvcnJvdztcbiAgICB9KSxcbiAgICBsb2FuQ29pbnM6IGNvaW5zLmZpbHRlcihmdW5jdGlvbiAoY29pbikge1xuICAgICAgcmV0dXJuIGNvaW4uYWxsb3dMZW5kIHx8IGNvaW4uYWxsb3dCb3Jyb3c7XG4gICAgfSksXG4gICAgYWxsRW5hYmxlZENvaW5zOiBjb2lucy5maWx0ZXIoZnVuY3Rpb24gKGNvaW4pIHtcbiAgICAgIHJldHVybiBjb2luLmFsbG93U3dhcCB8fCBjb2luLmFsbG93QnJpZGdlO1xuICAgIH0pXG4gIH07XG59O1xuXG52YXIgYWNjb3VudFBhcnNlciA9IC8qI19fUFVSRV9fKi9zdHJpbmcoKS5yZWdleCgvXlsuMS01YS16XXswLDEyfVsuMS01YS1qXT8kLyk7XG52YXIgYXV0aG9yaXphdGlvblBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBhY3RvcjogYWNjb3VudFBhcnNlcixcbiAgcGVybWlzc2lvbjogLyojX19QVVJFX18qL3N0cmluZygpXG59KTtcbnZhciBhdXRob3JpemF0aW9uc1BhcnNlciA9IC8qI19fUFVSRV9fKi9hcnJheShhdXRob3JpemF0aW9uUGFyc2VyKS5taW4oMSk7XG52YXIgRXh0ZW5kZWRBc3NldFBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBxdWFudGl0eTogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjb250cmFjdDogYWNjb3VudFBhcnNlclxufSk7XG5cbnZhciByYXdUcmFuc2FjdGlvblBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBleHBpcmF0aW9uOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHJlZl9ibG9ja19udW06IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgcmVmX2Jsb2NrX3ByZWZpeDogLyojX19QVVJFX18qL251bWJlcigpLFxuICBtYXhfbmV0X3VzYWdlX3dvcmRzOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIG1heF9jcHVfdXNhZ2VfbXM6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgZGVsYXlfc2VjOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIGNvbnRleHRfZnJlZV9hY3Rpb25zOiAvKiNfX1BVUkVfXyovYXJyYXkoIC8qI19fUFVSRV9fKi9hbnkoKSksXG4gIHRyYW5zYWN0aW9uX2V4dGVuc2lvbnM6IC8qI19fUFVSRV9fKi9hcnJheSggLyojX19QVVJFX18qL2FueSgpKVxufSk7XG52YXIgYmFzZUFjdGlvblBhcnNlciA9IGZ1bmN0aW9uIGJhc2VBY3Rpb25QYXJzZXIoY29udHJhY3QsIGFjdGlvbiwgZGF0YSkge1xuICByZXR1cm4gb2JqZWN0KHtcbiAgICBhY2NvdW50OiBjb250cmFjdCA9PT0gJyonID8gYWNjb3VudFBhcnNlciA6IGxpdGVyYWwoY29udHJhY3QpLFxuICAgIG5hbWU6IGxpdGVyYWwoYWN0aW9uKSxcbiAgICBkYXRhOiBvYmplY3QoZGF0YSksXG4gICAgYXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbnNQYXJzZXJcbiAgfSk7XG59O1xudmFyIGJhc2VBY3Rpb25TZXJpYWxpemVkUGFyc2VyID0gZnVuY3Rpb24gYmFzZUFjdGlvblNlcmlhbGl6ZWRQYXJzZXIoY29udHJhY3QsIGFjdGlvbiwgZGF0YSkge1xuICByZXR1cm4gb2JqZWN0KHtcbiAgICBhY2NvdW50OiBjb250cmFjdCA9PT0gJyonID8gYWNjb3VudFBhcnNlciA6IGxpdGVyYWwoY29udHJhY3QpLFxuICAgIG5hbWU6IGxpdGVyYWwoYWN0aW9uKSxcbiAgICBkYXRhOiBzdHJpbmcoKS5vcihvYmplY3QoZGF0YSkpLFxuICAgIGF1dGhvcml6YXRpb246IGF1dGhvcml6YXRpb25zUGFyc2VyXG4gIH0pO1xufTtcbnZhciB3ZWJhdXRoQWN0aW9uUGFyc2VyID0gZnVuY3Rpb24gd2ViYXV0aEFjdGlvblBhcnNlcihjb250cmFjdCwgYWN0aW9uLCBkYXRhKSB7XG4gIHJldHVybiBvYmplY3Qoe1xuICAgIGFjY291bnQ6IGxpdGVyYWwoJ3dlYmF1dGhuJyksXG4gICAgbmFtZTogbGl0ZXJhbCgnZXhlYycpLFxuICAgIGRhdGE6IG9iamVjdCh7XG4gICAgICBhY2NvdW50OiBhY2NvdW50UGFyc2VyLFxuICAgICAga2V5OiBvYmplY3Qoe1xuICAgICAgICBrZXk6IGFycmF5KHN0cmluZygpLm9yKG9iamVjdCh7XG4gICAgICAgICAgbW9kdWx1czogc3RyaW5nKCksXG4gICAgICAgICAgZXhwb25lbnQ6IHN0cmluZygpXG4gICAgICAgIH0pKSksXG4gICAgICAgIHVzZXJfcHJlc2VuY2U6IG51bWJlcigpLFxuICAgICAgICBycGlkOiBzdHJpbmcoKVxuICAgICAgfSksXG4gICAgICBub25jZTogbnVtYmVyKCksXG4gICAgICBwZXJtaXNzaW9uczogYXV0aG9yaXphdGlvbnNQYXJzZXIsXG4gICAgICBzaWduYXR1cmU6IG9iamVjdCh7XG4gICAgICAgIGF1dGhfZGF0YTogc3RyaW5nKCksXG4gICAgICAgIGNsaWVudF9qc29uOiBzdHJpbmcoKSxcbiAgICAgICAgc2lnbmF0dXJlOiBzdHJpbmcoKVxuICAgICAgfSksXG4gICAgICB0cng6IHJhd1RyYW5zYWN0aW9uUGFyc2VyLm1lcmdlKG9iamVjdCh7XG4gICAgICAgIGFjdGlvbnM6IGFycmF5KGJhc2VBY3Rpb25TZXJpYWxpemVkUGFyc2VyKGNvbnRyYWN0LCBhY3Rpb24sIGRhdGEpKS5sZW5ndGgoMSlcbiAgICAgIH0pKVxuICAgIH0pLFxuICAgIGF1dGhvcml6YXRpb246IGF1dGhvcml6YXRpb25zUGFyc2VyXG4gIH0pO1xufTtcbnZhciBzaW5nbGVBY3Rpb25UcmFuc2FjdGlvblBhcnNlciA9IGZ1bmN0aW9uIHNpbmdsZUFjdGlvblRyYW5zYWN0aW9uUGFyc2VyKGNvbnRyYWN0LCBhY3Rpb24sIGRhdGEpIHtcbiAgdmFyIGJhc2VBY3Rpb24gPSBiYXNlQWN0aW9uUGFyc2VyKGNvbnRyYWN0LCBhY3Rpb24sIGRhdGEpO1xuICB2YXIgd2ViYXV0aEFjdGlvbiA9IHdlYmF1dGhBY3Rpb25QYXJzZXIoY29udHJhY3QsIGFjdGlvbiwgZGF0YSk7XG4gIHJldHVybiByYXdUcmFuc2FjdGlvblBhcnNlci5tZXJnZShvYmplY3Qoe1xuICAgIGFjdGlvbnM6IGFycmF5KGJhc2VBY3Rpb24ub3Iod2ViYXV0aEFjdGlvbikpLmxlbmd0aCgxKVxuICB9KSk7XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgV1JBUF9DT05UUkFDVCA9ICdwcm90b24ud3JhcCc7XG52YXIgV1JBUF9BVVRIX0FDVElPTiA9ICdnZW5lcmF0ZWF1dGgnO1xudmFyIGluaXRpYWxpemVDb25zdGFudHMgPSBmdW5jdGlvbiBpbml0aWFsaXplQ29uc3RhbnRzKGNoYWluKSB7XG4gIHZhciBfaW5pdGlhbGl6ZUNvaW5zID0gaW5pdGlhbGl6ZUNvaW5zKGNoYWluKSxcbiAgICAgIHN3YXBDb2lucyA9IF9pbml0aWFsaXplQ29pbnMuc3dhcENvaW5zLFxuICAgICAgYnJpZGdlQ29pbnMgPSBfaW5pdGlhbGl6ZUNvaW5zLmJyaWRnZUNvaW5zLFxuICAgICAgYWxsRW5hYmxlZENvaW5zID0gX2luaXRpYWxpemVDb2lucy5hbGxFbmFibGVkQ29pbnMsXG4gICAgICBhbGxDb2lucyA9IF9pbml0aWFsaXplQ29pbnMuYWxsQ29pbnMsXG4gICAgICBsZW5kQ29pbnMgPSBfaW5pdGlhbGl6ZUNvaW5zLmxlbmRDb2lucyxcbiAgICAgIGJvcnJvd0NvaW5zID0gX2luaXRpYWxpemVDb2lucy5ib3Jyb3dDb2lucyxcbiAgICAgIGxvYW5Db2lucyA9IF9pbml0aWFsaXplQ29pbnMubG9hbkNvaW5zO1xuXG4gIHZhciBjb25zdGFudHMgPSB7XG4gICAgU1dBUF9DT05UUkFDVDogJ3Byb3Rvbi5zd2FwcycsXG4gICAgRkVFX0ZBQ1RPUjogMTAwMDAsXG4gICAgR09PR0xFX01BUFNfS0VZOiAnQUl6YVN5RGIyX0NySzAzMmtTSXFCWGJrZHdtYUxLV0VMbDBTeFZzJyxcbiAgICBTV0FQX1VSTDogY2hhaW4gPT09ICdwcm90b24nID8gJ2h0dHBzOi8vb3RjLnByb3RvbnN3YXAuY29tJyA6ICdodHRwczovL290Yy10ZXN0LnByb3RvbnN3YXAuY29tJyxcbiAgICBXUkFQX1NFUlZFUl9VUkw6IGNoYWluID09PSAncHJvdG9uJyA/ICdodHRwczovL3d3dy5hcGkuYmxva3MuaW8vcHJvdG9uLXdyYXAtcHVibGljMicgOiAnaHR0cHM6Ly93d3cuYXBpLmJsb2tzLmlvL3Byb3Rvbi13cmFwLXRlc3RuZXQtcHVibGljMicsXG4gICAgV1JBUF9DT05UUkFDVDogV1JBUF9DT05UUkFDVCxcbiAgICBXUkFQX0FDVElPTlM6IHtcbiAgICAgIFNBVkVfQUREUkVTUzogJ3NhdmVhZGRyZXNzMicsXG4gICAgICBERUxFVEVfQUREUkVTUzogJ2RlbGFkZHJlc3MyJyxcbiAgICAgIFdSQVBfU1RBUlQ6ICd3cmFwc3RhcnQyJyxcbiAgICAgIFdSQVBfRklOSVNIOiAnd3JhcGZpbmlzaDInLFxuICAgICAgV1JBUF9QUk9DRVNTOiAnd3JhcHByb2Nlc3MyJyxcbiAgICAgIFdSQVBfU0VUX0NPTkY6ICd3cmFwc2V0Y29uZjInXG4gICAgfSxcbiAgICBXUkFQX1RBQkxFUzoge1xuICAgICAgQUREUkVTU0VTOiAnYWRkcmVzc2VzMicsXG4gICAgICBXUkFQUzogJ3dyYXBzMidcbiAgICB9LFxuICAgIEFERFJFU1NFU19JTkRFWEVTOiB7XG4gICAgICBCWV9BQ0NPVU5UOiAyLFxuICAgICAgQllfQUREUl9IQVNIOiAzXG4gICAgfSxcbiAgICBXUkFQU19JTkRFWEVTOiB7XG4gICAgICBCWV9BQ0NPVU5UOiAyLFxuICAgICAgQllfU1RBVFVTOiAzLFxuICAgICAgQllfV1JBUF9IQVNIOiA0XG4gICAgfSxcbiAgICBXUkFQX1BST0NFU1NfVElNRVI6IDUwMDAsXG4gICAgRkFSTV9DT05UUkFDVDogJ3lpZWxkLmZhcm1zJyxcbiAgICBXRUJIT09LX1BFUk1JU1NJT046ICd3ZWJob29rJyxcbiAgICBQVUJMSUNfUEVSTUlTU0lPTjogJ3B1YmxpYycsXG4gICAgTElHSFRfUEVSTUlTU0lPTjogJ2xpZ2h0JyxcbiAgICBXUkFQX0FVVEhfQUNUSU9OOiBXUkFQX0FVVEhfQUNUSU9OLFxuICAgIE1FVEFMX0VORFBPSU5UOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyAnaHR0cHM6Ly9jaXJydXMubWV0YWxwYXkuY29tJyA6ICdodHRwczovL2NpcnJ1cy1kZXYubWV0YWxwYXkuY29tJyxcbiAgICBNRVRBTF9QUk9UT05fRU5EUE9JTlQ6IGNoYWluID09PSAncHJvdG9uJyA/ICdodHRwczovL2FwaS5wcm90b25jaGFpbi5jb20nIDogJ2h0dHBzOi8vYXBpLWRldi5wcm90b25jaGFpbi5jb20nLFxuICAgIFBST1RPTl9FTkRQT0lOVFM6IGNoYWluID09PSAncHJvdG9uJyA/IFsnaHR0cHM6Ly9wcm90b24uZ3JleW1hc3MuY29tJywgJ2h0dHBzOi8vcHJvdG9uLmVvc2NhZmVibG9jay5jb20nLCAnaHR0cHM6Ly9wcm90b24uY3J5cHRvbGlvbnMuaW8nLCAnaHR0cHM6Ly9wcm90b24uZW9zdXNhLm5ld3MnXSA6IFsnaHR0cHM6Ly90ZXN0bmV0LnByb3RvbmNoYWluLmNvbSddLFxuICAgIENIQUlOX0lEOiBjaGFpbiA9PT0gJ3Byb3RvbicgPyAnMzg0ZGE4ODgxMTIwMjdmMDMyMTg1MGExNjlmNzM3YzMzZTUzYjM4OGFhZDQ4YjVhZGFjZTRiYWI5N2Y0MzdlMCcgOiAnNzFlZTgzYmNmNTIxNDJkNjEwMTlkOTVmOWNjNTQyN2JhNmEwZDdmZjhhY2NkOWUyMDg4YWUyYWJlYWYzZDNkZCcsXG4gICAgQ0hBSU46IGNoYWluLFxuICAgIFNXQVBfQ09JTlM6IHN3YXBDb2lucyxcbiAgICBCUklER0VfQ09JTlM6IGJyaWRnZUNvaW5zLFxuICAgIEFMTF9FTkFCTEVEX0NPSU5TOiBhbGxFbmFibGVkQ29pbnMsXG4gICAgTEVORF9DT0lOUzogbGVuZENvaW5zLFxuICAgIEJPUlJPV19DT0lOUzogYm9ycm93Q29pbnMsXG4gICAgTE9BTl9DT0lOUzogbG9hbkNvaW5zLFxuICAgIEFMTF9DT0lOUzogYWxsQ29pbnMsXG4gICAgZmluZEJyaWRnZUNvaW5XYWxsZXRCeVh0b2tlbkFuZENoYWluOiBmdW5jdGlvbiBmaW5kQnJpZGdlQ29pbldhbGxldEJ5WHRva2VuQW5kQ2hhaW4oeHRva2VuU3ltYm9sLCBjaGFpbikge1xuICAgICAgdmFyIGJyaWRnZUNvaW4gPSBjb25zdGFudHMuQlJJREdFX0NPSU5TLmZpbmQoZnVuY3Rpb24gKGJyaWRnZUNvaW4pIHtcbiAgICAgICAgcmV0dXJuIGJyaWRnZUNvaW4ueHRva2VuU3ltYm9sID09PSB4dG9rZW5TeW1ib2w7XG4gICAgICB9KTtcbiAgICAgIGlmICghYnJpZGdlQ29pbikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBicmlkZ2VXYWxsZXQgPSBicmlkZ2VDb2luLndhbGxldHMuZmluZChmdW5jdGlvbiAoYnJpZGdlV2FsbGV0KSB7XG4gICAgICAgIHJldHVybiBicmlkZ2VXYWxsZXQuY2hhaW4gPT09IGNoYWluO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWJyaWRnZVdhbGxldCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYnJpZGdlQ29pbiwgYnJpZGdlV2FsbGV0KTtcbiAgICB9LFxuICAgIGZpbmRCcmlkZ2VDb2luV2FsbGV0OiBmdW5jdGlvbiBmaW5kQnJpZGdlQ29pbldhbGxldChjb2luLCB3YWxsZXQpIHtcbiAgICAgIHZhciBicmlkZ2VDb2luID0gY29uc3RhbnRzLkJSSURHRV9DT0lOUy5maW5kKGZ1bmN0aW9uIChicmlkZ2VDb2luKSB7XG4gICAgICAgIHJldHVybiBicmlkZ2VDb2luLmNvaW4gPT09IGNvaW47XG4gICAgICB9KTtcbiAgICAgIGlmICghYnJpZGdlQ29pbikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBicmlkZ2VXYWxsZXQgPSBicmlkZ2VDb2luLndhbGxldHMuZmluZChmdW5jdGlvbiAoYnJpZGdlV2FsbGV0KSB7XG4gICAgICAgIHJldHVybiBicmlkZ2VXYWxsZXQud2FsbGV0ID09PSB3YWxsZXQ7XG4gICAgICB9KTtcbiAgICAgIGlmICghYnJpZGdlV2FsbGV0KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBicmlkZ2VDb2luLCBicmlkZ2VXYWxsZXQpO1xuICAgIH0sXG4gICAgZmluZEJyaWRnZUNvaW5OZXR3b3JrOiBmdW5jdGlvbiBmaW5kQnJpZGdlQ29pbk5ldHdvcmsoY29pbiwgbmV0d29yaykge1xuICAgICAgdmFyIGJyaWRnZUNvaW4gPSBjb25zdGFudHMuQlJJREdFX0NPSU5TLmZpbmQoZnVuY3Rpb24gKGJyaWRnZUNvaW4pIHtcbiAgICAgICAgcmV0dXJuIGJyaWRnZUNvaW4uY29pbiA9PT0gY29pbjtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFicmlkZ2VDb2luKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIGJyaWRnZVdhbGxldCA9IGJyaWRnZUNvaW4ud2FsbGV0cy5maW5kKGZ1bmN0aW9uIChicmlkZ2VXYWxsZXQpIHtcbiAgICAgICAgcmV0dXJuIGJyaWRnZVdhbGxldC5uZXR3b3JrID09PSBuZXR3b3JrO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWJyaWRnZVdhbGxldCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYnJpZGdlQ29pbiwgYnJpZGdlV2FsbGV0KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBjb25zdGFudHM7XG59O1xuXG52YXIgY3JlYXRlQWJzdHJhY3RBdXRoUGFyc2VyID0gZnVuY3Rpb24gY3JlYXRlQWJzdHJhY3RBdXRoUGFyc2VyKGNvbnRyYWN0LCBhY3Rpb24sIGRhdGEpIHtcbiAgcmV0dXJuIG9iamVjdCh7XG4gICAgc2lnbmVyOiBhdXRob3JpemF0aW9uUGFyc2VyLFxuICAgIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKS5sZW5ndGgoMSksXG4gICAgdHJhbnNhY3Rpb246IHNpbmdsZUFjdGlvblRyYW5zYWN0aW9uUGFyc2VyKGNvbnRyYWN0LCBhY3Rpb24sIGRhdGEpXG4gIH0pO1xufTtcbnZhciBnZW5lcmF0ZUF1dGhEYXRhID0ge1xuICB0aW1lOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHByb3RvbkFjY291bnQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKVxufTtcbnZhciBnZW5lcmF0ZUF1dGhQYXJzZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQWJzdHJhY3RBdXRoUGFyc2VyKFdSQVBfQ09OVFJBQ1QsIFdSQVBfQVVUSF9BQ1RJT04sIGdlbmVyYXRlQXV0aERhdGEpO1xuXG52YXIgYWRkcmVzc1BhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBpbmRleDogLyojX19QVVJFX18qL251bWJlcigpLFxuICBhY2NvdW50OiBhY2NvdW50UGFyc2VyLFxuICBjaGFpbjogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBhZGRyZXNzOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGFkZHJlc3NfaGFzaDogLyojX19QVVJFX18qL3N0cmluZygpXG59KTtcbnZhciBnZW5lcmF0ZUFkZHJlc3NCb2R5UGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGNvaW46IHN0cmluZygpLFxuICB3YWxsZXQ6IHN0cmluZygpXG59KS5tZXJnZShnZW5lcmF0ZUF1dGhQYXJzZXIpO1xudmFyIGdlbmVyYXRlQWRkcmVzc1Jlc3BvbnNlID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGFkZHJlc3M6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY29pbjogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB3YWxsZXQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgbWVtbzogLyojX19QVVJFX18qL3N0cmluZygpLm9wdGlvbmFsKClcbn0pO1xuXG52YXIgcmF0ZVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBjb3VudGVyQ3VycmVuY3k6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgcHJpY2U6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgcHJpY2VDaGFuZ2VQZXJjZW50OiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIG1hcmtldENhcDogLyojX19QVVJFX18qL251bWJlcigpLFxuICB2b2x1bWU6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgdGltZXN0YW1wOiAvKiNfX1BVUkVfXyovbnVtYmVyKClcbn0pO1xudmFyIGV4Y2hhbmdlUmF0ZVBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBjb250cmFjdDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBzeW1ib2w6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgcmFuazogLyojX19QVVJFX18qL251bWJlcigpLFxuICByYXRlczogLyojX19QVVJFX18qL2FycmF5KHJhdGVQYXJzZXIpXG59KTtcbnZhciBleGNoYW5nZVJhdGVzUGFyc2VyID0gLyojX19QVVJFX18qL2FycmF5KGV4Y2hhbmdlUmF0ZVBhcnNlcik7XG5cbnZhciBUeXBlO1xuXG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgVHlwZVtcIlJFQ0VJVkVcIl0gPSBcInJlY2VpdmVcIjtcbiAgVHlwZVtcIlNFTkRcIl0gPSBcInNlbmRcIjtcbn0pKFR5cGUgfHwgKFR5cGUgPSB7fSkpO1xuXG52YXIgZGVwb3NpdEJvZHlQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgaWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgdHlwZTogLyojX19QVVJFX18qL25hdGl2ZUVudW0oVHlwZSksXG4gIGhhc2g6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY29pbjogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB3YWxsZXQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKVxufSk7XG52YXIgdHJhbnNhY3Rpb25QYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgaWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgd2FsbGV0OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHZhbHVlOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHZhbHVlU3RyaW5nOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGFkZHJlc3M6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgdHlwZTogLyojX19QVVJFX18qL25hdGl2ZUVudW0oVHlwZSksXG4gIHN0YXRlOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNvbmZpcm1hdGlvbnM6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgaGFzaDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBibG9ja0hhc2g6IC8qI19fUFVSRV9fKi9zdHJpbmcoKS5vcHRpb25hbCgpLm51bGxhYmxlKCksXG4gIGJsb2NrSGVpZ2h0OiAvKiNfX1BVUkVfXyovbnVtYmVyKCkub3B0aW9uYWwoKS5udWxsYWJsZSgpXG59KTtcblxudmFyIG90Y09yZGVyUmVzcG9uc2VQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgc3VjY2VzczogLyojX19QVVJFX18qL2Jvb2xlYW4oKSxcbiAgdHJhbnNhY3Rpb25faWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgZXJyb3Jtc2c6IC8qI19fUFVSRV9fKi9zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcbnZhciBvdGNRdW90ZUJvZHlQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgYmFzZUFtb3VudDogLyojX19QVVJFX18qL251bWJlcigpLFxuICBiYXNlU3ltYm9sOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHF1b3RlU3ltYm9sOiAvKiNfX1BVUkVfXyovc3RyaW5nKClcbn0pO1xudmFyIG90Y1F1b3RlUmVzcG9uc2VQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgc3VjY2VzczogLyojX19QVVJFX18qL2Jvb2xlYW4oKSxcbiAgdG9rZW46IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgcXR5OiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIGVycm9ybXNnOiAvKiNfX1BVUkVfXyovc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5cbnZhciB3aXRoZHJhd0RhdGEgPSB7XG4gIGZyb206IC8qI19fUFVSRV9fKi9zdHJpbmcoKS5yZWZpbmUoZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgIT09IFdSQVBfQ09OVFJBQ1Q7XG4gIH0sIHtcbiAgICBtZXNzYWdlOiBXUkFQX0NPTlRSQUNUICsgXCIgbXVzdCBiZSByZWNlaXZlclwiXG4gIH0pLFxuICB0bzogLyojX19QVVJFX18qL2xpdGVyYWwoV1JBUF9DT05UUkFDVCksXG4gIHF1YW50aXR5OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIG1lbW86IC8qI19fUFVSRV9fKi9zdHJpbmcoKVxufTtcbnZhciB3aXRoZHJhd0JvZHlQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgc2lnbmVyOiBhdXRob3JpemF0aW9uUGFyc2VyLFxuICBzaWduYXR1cmVzOiAvKiNfX1BVUkVfXyovYXJyYXkoc3RyaW5nKCkpLmxlbmd0aCgxKSxcbiAgdHJhbnNhY3Rpb246IC8qI19fUFVSRV9fKi9zaW5nbGVBY3Rpb25UcmFuc2FjdGlvblBhcnNlcignKicsICd0cmFuc2ZlcicsIHdpdGhkcmF3RGF0YSksXG4gIHF1b3RlSWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgcHJvdmlkZXI6IC8qI19fUFVSRV9fKi9zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcbnZhciB3aXRoZHJhd01ldGFsUmVzcG9uc2VQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgc3VjY2VzczogLyojX19QVVJFX18qL2Jvb2xlYW4oKSxcbiAgaWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKVxufSk7XG52YXIgd2l0aGRyYXdhbEZlZVF1b3RlUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIHF1b3RlSWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgZXN0aW1hdGVkRmVlOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGN1cnJlbmN5OiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIG5ldHdvcms6IC8qI19fUFVSRV9fKi9zdHJpbmcoKVxufSk7XG5cbnZhciB3aXRoZHJhd0hpc3RvcnlNZXRhbFN3YXBQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgaWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgc3RhdHVzOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGFtb3VudDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjdXJyZW5jeTogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBuZXR3b3JrOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNyZWF0ZWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgd2l0aGRyYXdhbEFkZHJlc3M6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgd2l0aGRyYXdhbEhhc2g6IC8qI19fUFVSRV9fKi9zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcbnZhciB3aXRoZHJhd0hpc3RvcnlNZXRhbFJlc3BvbnNlUGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIHN3YXBzOiAvKiNfX1BVUkVfXyovYXJyYXkod2l0aGRyYXdIaXN0b3J5TWV0YWxTd2FwUGFyc2VyKSxcbiAgcGFnZTogLyojX19QVVJFX18qL251bWJlcigpLFxuICBwYWdlU2l6ZTogLyojX19QVVJFX18qL251bWJlcigpLFxuICBudW1iZXJPZkVsZW1lbnRzOiAvKiNfX1BVUkVfXyovbnVtYmVyKCksXG4gIHRvdGFsUGFnZXM6IC8qI19fUFVSRV9fKi9udW1iZXIoKSxcbiAgdG90YWxFbGVtZW50czogLyojX19QVVJFX18qL251bWJlcigpXG59KTtcblxudmFyIFN0YXR1cztcblxuKGZ1bmN0aW9uIChTdGF0dXMpIHtcbiAgU3RhdHVzW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICBTdGF0dXNbXCJTVUNDRVNTXCJdID0gXCJzdWNjZXNzXCI7XG4gIFN0YXR1c1tcIkZBSUxcIl0gPSBcImZhaWxcIjtcbiAgU3RhdHVzW1wiUFJPQ0VTU0lOR1wiXSA9IFwicHJvY2Vzc2luZ1wiO1xufSkoU3RhdHVzIHx8IChTdGF0dXMgPSB7fSkpO1xuXG52YXIgd3JhcFN0YXJ0UGFyc2VyID0gLyojX19QVVJFX18qL29iamVjdCh7XG4gIGJhbGFuY2U6IEV4dGVuZGVkQXNzZXRQYXJzZXIsXG4gIGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHR4aWQ6IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgY2hhaW46IC8qI19fUFVSRV9fKi9zdHJpbmcoKSxcbiAgZGVwb3NpdF9hZGRyZXNzOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNvbmZpcm1hdGlvbnM6IC8qI19fUFVSRV9fKi9udW1iZXIoKVxufSk7XG52YXIgd3JhcFNldENvbmZQYXJzZXIgPSAvKiNfX1BVUkVfXyovb2JqZWN0KHtcbiAgd3JhcF9oYXNoOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNvbmZpcm1hdGlvbnM6IC8qI19fUFVSRV9fKi9udW1iZXIoKVxufSk7XG52YXIgd3JhcFBhcnNlciA9IC8qI19fUFVSRV9fKi9vYmplY3Qoe1xuICBpbmRleDogLyojX19QVVJFX18qL251bWJlcigpLFxuICBwcm90b25fYWNjb3VudDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBiYWxhbmNlOiBFeHRlbmRlZEFzc2V0UGFyc2VyLFxuICBpZDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICB0eGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGNoYWluOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIGRlcG9zaXRfYWRkcmVzczogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBzdGF0dXM6IC8qI19fUFVSRV9fKi9uYXRpdmVFbnVtKFN0YXR1cyksXG4gIGZpbmlzaF90eGlkOiAvKiNfX1BVUkVfXyovc3RyaW5nKCksXG4gIHdyYXBfaGFzaDogLyojX19QVVJFX18qL3N0cmluZygpLFxuICBjb25maXJtYXRpb25zOiAvKiNfX1BVUkVfXyovbnVtYmVyKClcbn0pO1xuXG52YXIgaXNTYW1lVG9rZW4gPSBmdW5jdGlvbiBpc1NhbWVUb2tlbih0b2tlbjEsIHRva2VuMikge1xuICByZXR1cm4gdG9rZW4xLnh0b2tlblN5bWJvbCA9PT0gdG9rZW4yLnh0b2tlblN5bWJvbCAmJiB0b2tlbjEueHRva2VuUHJlY2lzaW9uID09PSB0b2tlbjIueHRva2VuUHJlY2lzaW9uICYmIHRva2VuMS54dG9rZW5Db250cmFjdCA9PT0gdG9rZW4yLnh0b2tlbkNvbnRyYWN0O1xufTtcblxuZXhwb3J0IHsgQ2hhaW5zLCBFeHRlbmRlZEFzc2V0UGFyc2VyLCBOZXR3b3JrcywgU3RhdHVzLCBUeXBlLCBXUkFQX0FVVEhfQUNUSU9OLCBXUkFQX0NPTlRSQUNULCBhY2NvdW50UGFyc2VyLCBhZGRyZXNzUGFyc2VyLCBhdXRob3JpemF0aW9uUGFyc2VyLCBhdXRob3JpemF0aW9uc1BhcnNlciwgYmFzZUFjdGlvblBhcnNlciwgYmFzZUFjdGlvblNlcmlhbGl6ZWRQYXJzZXIsIGNyZWF0ZUFic3RyYWN0QXV0aFBhcnNlciwgZGVwb3NpdEJvZHlQYXJzZXIsIGV4Y2hhbmdlUmF0ZVBhcnNlciwgZXhjaGFuZ2VSYXRlc1BhcnNlciwgZXhwbG9yZXJMaW5rQnlDaGFpbiwgZ2VuZXJhdGVBZGRyZXNzQm9keVBhcnNlciwgZ2VuZXJhdGVBZGRyZXNzUmVzcG9uc2UsIGdlbmVyYXRlQXV0aFBhcnNlciwgaW5pdGlhbGl6ZUNvaW5zLCBpbml0aWFsaXplQ29uc3RhbnRzLCBpc1NhbWVUb2tlbiwgb3RjT3JkZXJSZXNwb25zZVBhcnNlciwgb3RjUXVvdGVCb2R5UGFyc2VyLCBvdGNRdW90ZVJlc3BvbnNlUGFyc2VyLCByYXRlUGFyc2VyLCBzaW1pbGFyQ2hhaW5zLCBzaW5nbGVBY3Rpb25UcmFuc2FjdGlvblBhcnNlciwgdHJhbnNhY3Rpb25QYXJzZXIsIHdlYmF1dGhBY3Rpb25QYXJzZXIsIHdpdGhkcmF3Qm9keVBhcnNlciwgd2l0aGRyYXdIaXN0b3J5TWV0YWxSZXNwb25zZVBhcnNlciwgd2l0aGRyYXdIaXN0b3J5TWV0YWxTd2FwUGFyc2VyLCB3aXRoZHJhd01ldGFsUmVzcG9uc2VQYXJzZXIsIHdpdGhkcmF3YWxGZWVRdW90ZVBhcnNlciwgd3JhcFBhcnNlciwgd3JhcFNldENvbmZQYXJzZXIsIHdyYXBTdGFydFBhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcC1jb25zdGFudHMuZXNtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxcIik7XG5leHBvcnRzLlpvZEVycm9yQ29kZSA9IHV0aWxfMS51dGlsLmFycmF5VG9FbnVtKFtcbiAgICAnaW52YWxpZF90eXBlJyxcbiAgICAnbm9uZW1wdHlfYXJyYXlfaXNfZW1wdHknLFxuICAgICdjdXN0b21fZXJyb3InLFxuICAgICdpbnZhbGlkX3VuaW9uJyxcbiAgICAnaW52YWxpZF9saXRlcmFsX3ZhbHVlJyxcbiAgICAnaW52YWxpZF9lbnVtX3ZhbHVlJyxcbiAgICAndW5yZWNvZ25pemVkX2tleXMnLFxuICAgICdpbnZhbGlkX2FyZ3VtZW50cycsXG4gICAgJ2ludmFsaWRfcmV0dXJuX3R5cGUnLFxuICAgICdpbnZhbGlkX2RhdGUnLFxuICAgICdpbnZhbGlkX3N0cmluZycsXG4gICAgJ3Rvb19zbWFsbCcsXG4gICAgJ3Rvb19iaWcnLFxuXSk7XG5leHBvcnRzLnF1b3RlbGVzc0pzb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpOyAvLyB7XCJuYW1lXCI6XCJKb2huIFNtaXRoXCJ9XG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXCIoW15cIl0rKVwiOi9nLCAnJDE6Jyk7XG59O1xudmFyIFpvZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RFcnJvcihlcnJvcnMpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgX3RoaXMuYWRkRXJyb3IgPSBmdW5jdGlvbiAoc3ViKSB7XG4gICAgICAgICAgICBfdGhpcy5lcnJvcnMgPSBfdGhpcy5lcnJvcnMuY29uY2F0KFtzdWJdKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkRXJyb3JzID0gZnVuY3Rpb24gKHN1YnMpIHtcbiAgICAgICAgICAgIGlmIChzdWJzID09PSB2b2lkIDApIHsgc3VicyA9IFtdOyB9XG4gICAgICAgICAgICBfdGhpcy5lcnJvcnMgPSBfdGhpcy5lcnJvcnMuY29uY2F0KHN1YnMpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5mbGF0dGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkRXJyb3JzID0ge307XG4gICAgICAgICAgICB2YXIgZm9ybUVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IF90aGlzLmVycm9yczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSA9IGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dLnB1c2goc3ViLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKHN1Yi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzOiBmb3JtRXJyb3JzLCBmaWVsZEVycm9yczogZmllbGRFcnJvcnMgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW5cbiAgICAgICAgdmFyIGFjdHVhbFByb3RvID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgYWN0dWFsUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RFcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuZXJyb3JzLCBudWxsLCAyKTtcbiAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMubGVuZ3RoICsgXCIgdmFsaWRhdGlvbiBpc3N1ZShzKVwiLFxuICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVycm9yczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBwYXRoU3RyaW5nID0gZXJyLnBhdGguam9pbignLicpIHx8ICdbW3Jvb3RdXSc7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlLnB1c2goXCIgIElzc3VlICNcIiArIHRoaXMuZXJyb3JzLmluZGV4T2YoZXJyKSArIFwiOiBcIiArIGVyci5jb2RlICsgXCIgYXQgXCIgKyBwYXRoU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UucHVzaChcIiAgXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlLnB1c2goJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIC8vIHJldHVybiBxdW90ZWxlc3NKc29uKHRoaXMpO1xuICAgICAgICAgICAgLy8gLm1hcCgoeyBwYXRoLCBtZXNzYWdlIH0pID0+IHtcbiAgICAgICAgICAgIC8vICAgcmV0dXJuIHBhdGgubGVuZ3RoID8gYCR7cGF0aC5qb2luKCcuL2luZGV4Jyl9OiAke21lc3NhZ2V9YCA6IGAke21lc3NhZ2V9YDtcbiAgICAgICAgICAgIC8vIH0pXG4gICAgICAgICAgICAvLyAuam9pbignXFxuJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RFcnJvci5wcm90b3R5cGUsIFwiaXNFbXB0eVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZEVycm9yLnByb3RvdHlwZSwgXCJmb3JtRXJyb3JzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFpvZEVycm9yLmNyZWF0ZSA9IGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IFpvZEVycm9yKGVycm9ycyk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9O1xuICAgIHJldHVybiBab2RFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuWm9kRXJyb3IgPSBab2RFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVpvZEVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW5kZXhcIikpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbFwiKTtcbnZhciBpc09wdGlvbmFsID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgIHZhciBkZWYgPSBzY2hlbWEuX2RlZjtcbiAgICBpZiAoZGVmLnQgPT09IHouWm9kVHlwZXMudW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIGlmIChkZWYudCA9PT0gei5ab2RUeXBlcy5pbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGlzT3B0aW9uYWwoZGVmLnJpZ2h0KSAmJiBpc09wdGlvbmFsKGRlZi5sZWZ0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLnQgPT09IHouWm9kVHlwZXMudW5pb24pIHtcbiAgICAgICAgcmV0dXJuIGRlZi5vcHRpb25zLm1hcChpc09wdGlvbmFsKS5zb21lKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ID09PSB0cnVlOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBab2RDb2RlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpvZENvZGVHZW5lcmF0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2VlbiA9IFtdO1xuICAgICAgICB0aGlzLnNlcmlhbCA9IDA7XG4gICAgICAgIHRoaXMucmFuZG9tSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJWm9kXCIgKyBfdGhpcy5zZXJpYWwrKztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maW5kQnlTY2hlbWEgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2Vlbi5maW5kKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnNjaGVtYSA9PT0gc2NoZW1hOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maW5kQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gX3RoaXMuc2Vlbi5maW5kKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmlkID09PSBpZDsgfSk7XG4gICAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZm91bmQgSUQ6IFwiICsgaWQpO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXG50eXBlIElkZW50aXR5PFQ+ID0gVDtcXG5cXG5cIiArIF90aGlzLnNlZW5cbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBcInR5cGUgXCIgKyBpdGVtLmlkICsgXCIgPSBJZGVudGl0eTxcIiArIGl0ZW0udHlwZSArIFwiPjtcIjsgfSlcbiAgICAgICAgICAgICAgICAuam9pbignXFxuXFxuJykgKyBcIlxcblwiO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFR5cGUgPSBmdW5jdGlvbiAoaWQsIHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IF90aGlzLmZpbmRCeUlkKGlkKTtcbiAgICAgICAgICAgIGZvdW5kLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdlbmVyYXRlID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gX3RoaXMuZmluZEJ5U2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgdmFyIGRlZiA9IHNjaGVtYS5fZGVmO1xuICAgICAgICAgICAgdmFyIGlkID0gX3RoaXMucmFuZG9tSWQoKTtcbiAgICAgICAgICAgIHZhciB0eSA9IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJfX0lOQ09NUExFVEVfX1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLnNlZW4ucHVzaCh0eSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGRlZi50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnN0cmluZzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5udW1iZXI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcIm51bWJlclwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMuYmlnaW50OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJiaWdpbnRcIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmJvb2xlYW46XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcImJvb2xlYW5cIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmRhdGU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcIkRhdGVcIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwidW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5udWxsOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJudWxsXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5hbnk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcImFueVwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMudW5rbm93bjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwidW5rbm93blwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMudm9pZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwidm9pZFwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMubGl0ZXJhbDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGRlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpdGVyYWxUeXBlID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBcIlxcXCJcIiArIHZhbCArIFwiXFxcIlwiIDogXCJcIiArIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIGxpdGVyYWxUeXBlKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMuZW51bTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIGRlZi52YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIlxcXCJcIiArIHYgKyBcIlxcXCJcIjsgfSkuam9pbignIHwgJykpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5vYmplY3Q6XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBkZWYuc2hhcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRTY2hlbWEgPSBzaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkVHlwZSA9IF90aGlzLmdlbmVyYXRlKGNoaWxkU2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBPUFRLRVkgPSBpc09wdGlvbmFsKGNoaWxkU2NoZW1hKSA/ICc/JyA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TGluZXMucHVzaChcIlwiICsga2V5ICsgT1BUS0VZICsgXCI6IFwiICsgY2hpbGRUeXBlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVN0cnVjdCA9IFwie1xcblwiICsgb2JqZWN0TGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUpIHsgcmV0dXJuIFwiICBcIiArIGxpbmUgKyBcIjtcIjsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSArIFwiXFxufVwiO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRUeXBlKGlkLCBcIlwiICsgYmFzZVN0cnVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy50dXBsZTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR1cGxlTGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRlZi5pdGVtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbFNjaGVtYSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbFR5cGUgPSBfdGhpcy5nZW5lcmF0ZShlbFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZUxpbmVzLnB1c2goZWxUeXBlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVR1cGxlID0gXCJbXFxuXCIgKyB0dXBsZUxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBcIiAgXCIgKyBsaW5lICsgXCIsXCI7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJykgKyBcIlxcbl1cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIFwiXCIgKyBiYXNlVHVwbGUpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5hcnJheTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIF90aGlzLmdlbmVyYXRlKGRlZi50eXBlKS5pZCArIFwiW11cIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IF90aGlzLmdlbmVyYXRlKGRlZi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybnMgPSBfdGhpcy5nZW5lcmF0ZShkZWYucmV0dXJucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcIiguLi5hcmdzOiBcIiArIGFyZ3MuaWQgKyBcIik9PlwiICsgcmV0dXJucy5pZCk7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnByb21pc2U6XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9tVmFsdWUgPSBfdGhpcy5nZW5lcmF0ZShkZWYudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcIlByb21pc2U8XCIgKyBwcm9tVmFsdWUuaWQgKyBcIj5cIik7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnVuaW9uOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pb25MaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZGVmLm9wdGlvbnM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxTY2hlbWEgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxUeXBlID0gX3RoaXMuZ2VuZXJhdGUoZWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pb25MaW5lcy5wdXNoKGVsVHlwZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIHVuaW9uTGluZXMuam9pbihcIiB8IFwiKSk7XG4gICAgICAgICAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmludGVyc2VjdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFR5cGUoaWQsIF90aGlzLmdlbmVyYXRlKGRlZi5sZWZ0KS5pZCArIFwiICYgXCIgKyBfdGhpcy5nZW5lcmF0ZShkZWYucmlnaHQpLmlkKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMucmVjb3JkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgXCJ7W2s6c3RyaW5nXTogXCIgKyBfdGhpcy5nZW5lcmF0ZShkZWYudmFsdWVUeXBlKS5pZCArIFwifVwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMubGF6eTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhenlUeXBlID0gZGVmLmdldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0VHlwZShpZCwgX3RoaXMuZ2VuZXJhdGUobGF6eVR5cGUpLmlkKTtcbiAgICAgICAgICAgICAgICBjYXNlIHouWm9kVHlwZXMubmF0aXZlRW51bTpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgbGF6eVR5cGUgPSBkZWYuZ2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCAnYXNkZicpO1xuICAgICAgICAgICAgICAgIGNhc2Ugei5ab2RUeXBlcy5rZXlvZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgbGF6eVR5cGUgPSBkZWYuZ2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRUeXBlKGlkLCBcImtleW9mIFtcIiArIGRlZi52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gXCJcXFwiXCIgKyB2YWwgKyBcIlxcXCJcIiA6IHZhbCk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEudXRpbC5hc3NlcnROZXZlcihkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbmRCeUlkKGlkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgWm9kQ29kZUdlbmVyYXRvci5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgWm9kQ29kZUdlbmVyYXRvcigpOyB9O1xuICAgIHJldHVybiBab2RDb2RlR2VuZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuWm9kQ29kZUdlbmVyYXRvciA9IFpvZENvZGVHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlZ2VuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFpvZEVycm9yXzEgPSByZXF1aXJlKFwiLi9ab2RFcnJvclwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxcIik7XG5leHBvcnRzLmRlZmF1bHRFcnJvck1hcCA9IGZ1bmN0aW9uIChlcnJvciwgX2N0eCkge1xuICAgIHZhciBtZXNzYWdlO1xuICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZTpcbiAgICAgICAgICAgIGlmIChlcnJvci5yZWNlaXZlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ1JlcXVpcmVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkV4cGVjdGVkIFwiICsgZXJyb3IuZXhwZWN0ZWQgKyBcIiwgcmVjZWl2ZWQgXCIgKyBlcnJvci5yZWNlaXZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLm5vbmVtcHR5X2FycmF5X2lzX2VtcHR5OlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiTGlzdCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGl0ZW1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6IFwiICsgZXJyb3Iua2V5cy5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFwiJ1wiICsgayArIFwiJ1wiOyB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBjYXNlIFpvZEVycm9yQ29kZS5pbnZhbGlkX3R1cGxlX2xlbmd0aDpcbiAgICAgICAgLy8gICBtZXNzYWdlID0gYEV4cGVjdGVkIGxpc3Qgb2YgJHtlcnJvci5leHBlY3RlZH0gaXRlbXMsIHJlY2VpdmVkICR7ZXJyb3IucmVjZWl2ZWR9IGl0ZW1zYDtcbiAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2xpdGVyYWxfdmFsdWU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJJbnB1dCBtdXN0IGJlIFxcXCJcIiArIGVycm9yLmV4cGVjdGVkICsgXCJcXFwiXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJJbnB1dCBtdXN0IGJlIG9uZSBvZiB0aGVzZSB2YWx1ZXM6IFwiICsgZXJyb3Iub3B0aW9ucy5qb2luKCcsICcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgZGF0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGNhc2UgWm9kRXJyb3JDb2RlLnRvb19zbWFsbDpcbiAgICAgICAgLy8gICBjb25zdCB0b29TaG9ydE5vdW4gPSBfY3R4LmRhdGEgPT09ICdzdHJpbmcnID8gJ2NoYXJhY3RlcnMnIDogJ2l0ZW1zJztcbiAgICAgICAgLy8gICBtZXNzYWdlID0gYFRvbyBzaG9ydCwgc2hvdWxkIGJlIGF0IGxlYXN0ICR7ZXJyb3IubWluaW11bX0gJHt0b29TaG9ydE5vdW59YDtcbiAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgLy8gY2FzZSBab2RFcnJvckNvZGUudG9vX2JpZzpcbiAgICAgICAgLy8gICBjb25zdCB0b29Mb25nTm91biA9IF9jdHguZGF0YSA9PT0gJ3N0cmluZycgPyAnY2hhcmFjdGVycycgOiAnaXRlbXMnO1xuICAgICAgICAvLyAgIG1lc3NhZ2UgPSBgVG9vIHNob3J0LCBzaG91bGQgYmUgYXQgbW9zdCAke2Vycm9yLm1heGltdW19ICR7dG9vTG9uZ05vdW59YDtcbiAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgICAgICAgIGlmIChlcnJvci52YWxpZGF0aW9uICE9PSAncmVnZXgnKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgXCIgKyBlcnJvci52YWxpZGF0aW9uO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnSW52YWxpZCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gY2FzZSBab2RFcnJvckNvZGUuaW52YWxpZF91cmw6XG4gICAgICAgIC8vICAgbWVzc2FnZSA9ICdJbnZhbGlkIFVSTC4nO1xuICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAvLyBjYXNlIFpvZEVycm9yQ29kZS5pbnZhbGlkX3V1aWQ6XG4gICAgICAgIC8vICAgbWVzc2FnZSA9ICdJbnZhbGlkIFVVSUQuJztcbiAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gJ2FycmF5JylcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJTaG91bGQgaGF2ZSBcIiArIChlcnJvci5pbmNsdXNpdmUgPyBcImF0IGxlYXN0XCIgOiBcIm1vcmUgdGhhblwiKSArIFwiIFwiICsgZXJyb3IubWluaW11bSArIFwiIGl0ZW1zXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvci50eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJTaG91bGQgYmUgXCIgKyAoZXJyb3IuaW5jbHVzaXZlID8gXCJhdCBsZWFzdFwiIDogXCJvdmVyXCIpICsgXCIgXCIgKyBlcnJvci5taW5pbXVtICsgXCIgY2hhcmFjdGVyc1wiO1xuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiVmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBcIiArIChlcnJvci5pbmNsdXNpdmUgPyBcIm9yIGVxdWFsIHRvIFwiIDogXCJcIikgKyBlcnJvci5taW5pbXVtO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnSW52YWxpZCBpbnB1dCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fYmlnOlxuICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICdhcnJheScpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiU2hvdWxkIGhhdmUgXCIgKyAoZXJyb3IuaW5jbHVzaXZlID8gXCJhdCBtb3N0XCIgOiBcImxlc3MgdGhhblwiKSArIFwiIFwiICsgZXJyb3IubWF4aW11bSArIFwiIGl0ZW1zXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvci50eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJTaG91bGQgYmUgXCIgKyAoZXJyb3IuaW5jbHVzaXZlID8gXCJhdCBtb3N0XCIgOiBcInVuZGVyXCIpICsgXCIgXCIgKyBlcnJvci5tYXhpbXVtICsgXCIgY2hhcmFjdGVycyBsb25nXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvci50eXBlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJWYWx1ZSBzaG91bGQgYmUgbGVzcyB0aGFuIFwiICsgKGVycm9yLmluY2x1c2l2ZSA/IFwib3IgZXF1YWwgdG8gXCIgOiBcIlwiKSArIGVycm9yLm1heGltdW07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9ICdJbnZhbGlkIGlucHV0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmN1c3RvbV9lcnJvcjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXQuXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXQuXCI7XG4gICAgICAgICAgICB1dGlsXzEudXRpbC5hc3NlcnROZXZlcihlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgICAvLyByZXR1cm4gYEludmFsaWQgaW5wdXQuYDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0RXJyb3JNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXJyb3JVdGlsO1xuKGZ1bmN0aW9uIChlcnJvclV0aWwpIHtcbiAgICBlcnJvclV0aWwuZXJyVG9PYmogPSBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IHsgbWVzc2FnZTogbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fSk7IH07XG59KShlcnJvclV0aWwgPSBleHBvcnRzLmVycm9yVXRpbCB8fCAoZXhwb3J0cy5lcnJvclV0aWwgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JVdGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiYXNlXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMvYmFzZVwiKTtcbnZhciBpbnRlcnNlY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi90eXBlcy9pbnRlcnNlY3Rpb25cIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vdHlwZXMvb2JqZWN0XCIpO1xudmFyIG9iamVjdFV0aWw7XG4oZnVuY3Rpb24gKG9iamVjdFV0aWwpIHtcbiAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdmFyIGZpcnN0S2V5cyA9IE9iamVjdC5rZXlzKGZpcnN0KTtcbiAgICAgICAgdmFyIHNlY29uZEtleXMgPSBPYmplY3Qua2V5cyhzZWNvbmQpO1xuICAgICAgICB2YXIgc2hhcmVkS2V5cyA9IGZpcnN0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHNlY29uZEtleXMuaW5kZXhPZihrKSAhPT0gLTE7IH0pO1xuICAgICAgICB2YXIgc2hhcmVkU2hhcGUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzaGFyZWRLZXlzXzEgPSBzaGFyZWRLZXlzOyBfaSA8IHNoYXJlZEtleXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBrID0gc2hhcmVkS2V5c18xW19pXTtcbiAgICAgICAgICAgIHNoYXJlZFNoYXBlW2tdID0gaW50ZXJzZWN0aW9uXzEuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZShmaXJzdFtrXSwgc2Vjb25kW2tdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIGZpcnN0LCBzZWNvbmQsIHNoYXJlZFNoYXBlKTtcbiAgICB9O1xuICAgIG9iamVjdFV0aWwubWVyZ2VPYmplY3RzID0gZnVuY3Rpb24gKGZpcnN0KSB7IHJldHVybiBmdW5jdGlvbiAoc2Vjb25kKSB7XG4gICAgICAgIHZhciBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoZmlyc3QuX2RlZi5zaGFwZSgpLCBzZWNvbmQuX2RlZi5zaGFwZSgpKTtcbiAgICAgICAgdmFyIG1lcmdlZCA9IG5ldyBvYmplY3RfMS5ab2RPYmplY3Qoe1xuICAgICAgICAgICAgdDogYmFzZV8xLlpvZFR5cGVzLm9iamVjdCxcbiAgICAgICAgICAgIGNoZWNrczogKGZpcnN0Ll9kZWYuY2hlY2tzIHx8IFtdKS5jb25jYXQoKHNlY29uZC5fZGVmLmNoZWNrcyB8fCBbXSkpLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgc3RyaWN0OiBmaXJzdC5wYXJhbXMuc3RyaWN0ICYmIHNlY29uZC5wYXJhbXMuc3RyaWN0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNoYXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXJnZWRTaGFwZTsgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfTsgfTtcbn0pKG9iamVjdFV0aWwgPSBleHBvcnRzLm9iamVjdFV0aWwgfHwgKGV4cG9ydHMub2JqZWN0VXRpbCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3RVdGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWw7XG4oZnVuY3Rpb24gKHV0aWwpIHtcbiAgICBmdW5jdGlvbiBhc3NlcnROZXZlcihfeCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xuICAgIHV0aWwuYXJyYXlUb0VudW0gPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGl0ZW1zXzEgPSBpdGVtczsgX2kgPCBpdGVtc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc18xW19pXTtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgdmFsaWRLZXlzID0gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gJ251bWJlcic7IH0pO1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB2YWxpZEtleXNfMSA9IHZhbGlkS2V5czsgX2kgPCB2YWxpZEtleXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBrID0gdmFsaWRLZXlzXzFbX2ldO1xuICAgICAgICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWwuZ2V0VmFsdWVzKGZpbHRlcmVkKTtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RWYWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pKHV0aWwgPSBleHBvcnRzLnV0aWwgfHwgKGV4cG9ydHMudXRpbCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogWk9EICovXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN0cmluZ18xID0gcmVxdWlyZShcIi4vdHlwZXMvc3RyaW5nXCIpO1xuZXhwb3J0cy5ab2RTdHJpbmcgPSBzdHJpbmdfMS5ab2RTdHJpbmc7XG52YXIgbnVtYmVyXzEgPSByZXF1aXJlKFwiLi90eXBlcy9udW1iZXJcIik7XG5leHBvcnRzLlpvZE51bWJlciA9IG51bWJlcl8xLlpvZE51bWJlcjtcbnZhciBiaWdpbnRfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2JpZ2ludFwiKTtcbmV4cG9ydHMuWm9kQmlnSW50ID0gYmlnaW50XzEuWm9kQmlnSW50O1xudmFyIGJvb2xlYW5fMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2Jvb2xlYW5cIik7XG5leHBvcnRzLlpvZEJvb2xlYW4gPSBib29sZWFuXzEuWm9kQm9vbGVhbjtcbnZhciBkYXRlXzEgPSByZXF1aXJlKFwiLi90eXBlcy9kYXRlXCIpO1xuZXhwb3J0cy5ab2REYXRlID0gZGF0ZV8xLlpvZERhdGU7XG52YXIgdW5kZWZpbmVkXzEgPSByZXF1aXJlKFwiLi90eXBlcy91bmRlZmluZWRcIik7XG5leHBvcnRzLlpvZFVuZGVmaW5lZCA9IHVuZGVmaW5lZF8xLlpvZFVuZGVmaW5lZDtcbnZhciBudWxsXzEgPSByZXF1aXJlKFwiLi90eXBlcy9udWxsXCIpO1xuZXhwb3J0cy5ab2ROdWxsID0gbnVsbF8xLlpvZE51bGw7XG52YXIgYW55XzEgPSByZXF1aXJlKFwiLi90eXBlcy9hbnlcIik7XG5leHBvcnRzLlpvZEFueSA9IGFueV8xLlpvZEFueTtcbnZhciB1bmtub3duXzEgPSByZXF1aXJlKFwiLi90eXBlcy91bmtub3duXCIpO1xuZXhwb3J0cy5ab2RVbmtub3duID0gdW5rbm93bl8xLlpvZFVua25vd247XG52YXIgdm9pZF8xID0gcmVxdWlyZShcIi4vdHlwZXMvdm9pZFwiKTtcbmV4cG9ydHMuWm9kVm9pZCA9IHZvaWRfMS5ab2RWb2lkO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi90eXBlcy9hcnJheVwiKTtcbmV4cG9ydHMuWm9kQXJyYXkgPSBhcnJheV8xLlpvZEFycmF5O1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcIi4vdHlwZXMvb2JqZWN0XCIpO1xuZXhwb3J0cy5ab2RPYmplY3QgPSBvYmplY3RfMS5ab2RPYmplY3Q7XG52YXIgdW5pb25fMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3VuaW9uXCIpO1xuZXhwb3J0cy5ab2RVbmlvbiA9IHVuaW9uXzEuWm9kVW5pb247XG52YXIgaW50ZXJzZWN0aW9uXzEgPSByZXF1aXJlKFwiLi90eXBlcy9pbnRlcnNlY3Rpb25cIik7XG5leHBvcnRzLlpvZEludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbl8xLlpvZEludGVyc2VjdGlvbjtcbnZhciB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHlwZXMvdHVwbGVcIik7XG5leHBvcnRzLlpvZFR1cGxlID0gdHVwbGVfMS5ab2RUdXBsZTtcbnZhciByZWNvcmRfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3JlY29yZFwiKTtcbmV4cG9ydHMuWm9kUmVjb3JkID0gcmVjb3JkXzEuWm9kUmVjb3JkO1xudmFyIGZ1bmN0aW9uXzEgPSByZXF1aXJlKFwiLi90eXBlcy9mdW5jdGlvblwiKTtcbmV4cG9ydHMuWm9kRnVuY3Rpb24gPSBmdW5jdGlvbl8xLlpvZEZ1bmN0aW9uO1xudmFyIGxhenlfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2xhenlcIik7XG5leHBvcnRzLlpvZExhenkgPSBsYXp5XzEuWm9kTGF6eTtcbnZhciBsaXRlcmFsXzEgPSByZXF1aXJlKFwiLi90eXBlcy9saXRlcmFsXCIpO1xuZXhwb3J0cy5ab2RMaXRlcmFsID0gbGl0ZXJhbF8xLlpvZExpdGVyYWw7XG52YXIgZW51bV8xID0gcmVxdWlyZShcIi4vdHlwZXMvZW51bVwiKTtcbmV4cG9ydHMuWm9kRW51bSA9IGVudW1fMS5ab2RFbnVtO1xudmFyIG5hdGl2ZUVudW1fMSA9IHJlcXVpcmUoXCIuL3R5cGVzL25hdGl2ZUVudW1cIik7XG5leHBvcnRzLlpvZE5hdGl2ZUVudW0gPSBuYXRpdmVFbnVtXzEuWm9kTmF0aXZlRW51bTtcbnZhciBrZXlvZl8xID0gcmVxdWlyZShcIi4vdHlwZXMva2V5b2ZcIik7XG52YXIgcHJvbWlzZV8xID0gcmVxdWlyZShcIi4vdHlwZXMvcHJvbWlzZVwiKTtcbmV4cG9ydHMuWm9kUHJvbWlzZSA9IHByb21pc2VfMS5ab2RQcm9taXNlO1xudmFyIGJhc2VfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2Jhc2VcIik7XG5leHBvcnRzLlpvZFR5cGUgPSBiYXNlXzEuWm9kVHlwZTtcbmV4cG9ydHMuU2NoZW1hID0gYmFzZV8xLlpvZFR5cGU7XG5leHBvcnRzLlpvZFNjaGVtYSA9IGJhc2VfMS5ab2RUeXBlO1xuZXhwb3J0cy5ab2RUeXBlcyA9IGJhc2VfMS5ab2RUeXBlcztcbi8vIGltcG9ydCB7IFpvZEVycm9yLCBab2RFcnJvckNvZGUsIFpvZEludmFsaWRUeXBlRXJyb3IsXG4vLyBab2ROb25FbXB0eUFycmF5SXNFbXB0eUVycm9yLFxuLy8gWm9kVW5yZWNvZ25pemVkS2V5c0Vycm9yLFxuLy8gWm9kSW52YWxpZFVuaW9uRXJyb3IsXG4vLyBab2RJbnZhbGlkTGl0ZXJhbFZhbHVlRXJyb3IsXG4vLyBab2RJbnZhbGlkRW51bVZhbHVlRXJyb3IsXG4vLyBab2RJbnZhbGlkQXJndW1lbnRzRXJyb3IsXG4vLyBab2RJbnZhbGlkUmV0dXJuVHlwZUVycm9yLFxuLy8gWm9kSW52YWxpZERhdGVFcnJvcixcbi8vIFpvZEludmFsaWRTdHJpbmdFcnJvcixcbi8vIFpvZFRvb1NtYWxsRXJyb3IsXG4vLyBab2RUb29CaWdFcnJvcixcbi8vIFpvZEN1c3RvbUVycm9yIH0gZnJvbSAnLi9ab2RFcnJvcic7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XG5leHBvcnRzLlpvZFBhcnNlZFR5cGUgPSBwYXJzZXJfMS5ab2RQYXJzZWRUeXBlO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5leHBvcnRzLlpvZENvZGVHZW5lcmF0b3IgPSBjb2RlZ2VuXzEuWm9kQ29kZUdlbmVyYXRvcjtcbnZhciBzdHJpbmdUeXBlID0gc3RyaW5nXzEuWm9kU3RyaW5nLmNyZWF0ZTtcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nVHlwZTtcbnZhciBudW1iZXJUeXBlID0gbnVtYmVyXzEuWm9kTnVtYmVyLmNyZWF0ZTtcbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyVHlwZTtcbnZhciBiaWdJbnRUeXBlID0gYmlnaW50XzEuWm9kQmlnSW50LmNyZWF0ZTtcbmV4cG9ydHMuYmlnaW50ID0gYmlnSW50VHlwZTtcbnZhciBib29sZWFuVHlwZSA9IGJvb2xlYW5fMS5ab2RCb29sZWFuLmNyZWF0ZTtcbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW5UeXBlO1xudmFyIGRhdGVUeXBlID0gZGF0ZV8xLlpvZERhdGUuY3JlYXRlO1xuZXhwb3J0cy5kYXRlID0gZGF0ZVR5cGU7XG52YXIgdW5kZWZpbmVkVHlwZSA9IHVuZGVmaW5lZF8xLlpvZFVuZGVmaW5lZC5jcmVhdGU7XG5leHBvcnRzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZFR5cGU7XG52YXIgbnVsbFR5cGUgPSBudWxsXzEuWm9kTnVsbC5jcmVhdGU7XG5leHBvcnRzLm51bGwgPSBudWxsVHlwZTtcbnZhciBhbnlUeXBlID0gYW55XzEuWm9kQW55LmNyZWF0ZTtcbmV4cG9ydHMuYW55ID0gYW55VHlwZTtcbnZhciB1bmtub3duVHlwZSA9IHVua25vd25fMS5ab2RVbmtub3duLmNyZWF0ZTtcbmV4cG9ydHMudW5rbm93biA9IHVua25vd25UeXBlO1xudmFyIHZvaWRUeXBlID0gdm9pZF8xLlpvZFZvaWQuY3JlYXRlO1xuZXhwb3J0cy52b2lkID0gdm9pZFR5cGU7XG52YXIgYXJyYXlUeXBlID0gYXJyYXlfMS5ab2RBcnJheS5jcmVhdGU7XG5leHBvcnRzLmFycmF5ID0gYXJyYXlUeXBlO1xudmFyIG9iamVjdFR5cGUgPSBvYmplY3RfMS5ab2RPYmplY3QuY3JlYXRlO1xuZXhwb3J0cy5vYmplY3QgPSBvYmplY3RUeXBlO1xudmFyIHVuaW9uVHlwZSA9IHVuaW9uXzEuWm9kVW5pb24uY3JlYXRlO1xuZXhwb3J0cy51bmlvbiA9IHVuaW9uVHlwZTtcbnZhciBpbnRlcnNlY3Rpb25UeXBlID0gaW50ZXJzZWN0aW9uXzEuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmV4cG9ydHMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uVHlwZTtcbnZhciB0dXBsZVR5cGUgPSB0dXBsZV8xLlpvZFR1cGxlLmNyZWF0ZTtcbmV4cG9ydHMudHVwbGUgPSB0dXBsZVR5cGU7XG52YXIgcmVjb3JkVHlwZSA9IHJlY29yZF8xLlpvZFJlY29yZC5jcmVhdGU7XG5leHBvcnRzLnJlY29yZCA9IHJlY29yZFR5cGU7XG52YXIgZnVuY3Rpb25UeXBlID0gZnVuY3Rpb25fMS5ab2RGdW5jdGlvbi5jcmVhdGU7XG5leHBvcnRzLmZ1bmN0aW9uID0gZnVuY3Rpb25UeXBlO1xudmFyIGxhenlUeXBlID0gbGF6eV8xLlpvZExhenkuY3JlYXRlO1xuZXhwb3J0cy5sYXp5ID0gbGF6eVR5cGU7XG52YXIgbGl0ZXJhbFR5cGUgPSBsaXRlcmFsXzEuWm9kTGl0ZXJhbC5jcmVhdGU7XG5leHBvcnRzLmxpdGVyYWwgPSBsaXRlcmFsVHlwZTtcbnZhciBlbnVtVHlwZSA9IGVudW1fMS5ab2RFbnVtLmNyZWF0ZTtcbmV4cG9ydHMuZW51bSA9IGVudW1UeXBlO1xudmFyIG5hdGl2ZUVudW1UeXBlID0gbmF0aXZlRW51bV8xLlpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuZXhwb3J0cy5uYXRpdmVFbnVtID0gbmF0aXZlRW51bVR5cGU7XG52YXIgcHJvbWlzZVR5cGUgPSBwcm9taXNlXzEuWm9kUHJvbWlzZS5jcmVhdGU7XG5leHBvcnRzLnByb21pc2UgPSBwcm9taXNlVHlwZTtcbnZhciBrZXlvZlR5cGUgPSBrZXlvZl8xLlpvZEtleW9mLmNyZWF0ZTtcbmV4cG9ydHMua2V5b2YgPSBrZXlvZlR5cGU7XG52YXIgb3N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ1R5cGUoKS5vcHRpb25hbCgpOyB9O1xuZXhwb3J0cy5vc3RyaW5nID0gb3N0cmluZztcbnZhciBvbnVtYmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7IH07XG5leHBvcnRzLm9udW1iZXIgPSBvbnVtYmVyO1xudmFyIG9ib29sZWFuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpOyB9O1xuZXhwb3J0cy5vYm9vbGVhbiA9IG9ib29sZWFuO1xudmFyIGNvZGVnZW4gPSBjb2RlZ2VuXzEuWm9kQ29kZUdlbmVyYXRvci5jcmVhdGU7XG5leHBvcnRzLmNvZGVnZW4gPSBjb2RlZ2VuO1xuZXhwb3J0cy5jdXN0b20gPSBmdW5jdGlvbiAoY2hlY2ssIHBhcmFtcykgeyByZXR1cm4gYW55VHlwZSgpLnJlZmluZShjaGVjaywgcGFyYW1zKTsgfTtcbnZhciBpbnN0YW5jZU9mVHlwZSA9IGZ1bmN0aW9uIChjbHMsIHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7XG4gICAgICAgIG1lc3NhZ2U6IFwiSW5wdXQgbm90IGluc3RhbmNlIG9mIFwiICsgY2xzLm5hbWUsXG4gICAgfTsgfVxuICAgIHJldHVybiBleHBvcnRzLmN1c3RvbShmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIGNsczsgfSwgcGFyYW1zKTtcbn07XG5leHBvcnRzLmluc3RhbmNlb2YgPSBpbnN0YW5jZU9mVHlwZTtcbmV4cG9ydHMubGF0ZSA9IHtcbiAgICBvYmplY3Q6IG9iamVjdF8xLlpvZE9iamVjdC5sYXp5Y3JlYXRlLFxufTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1pvZEVycm9yXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW5kZXhcIikpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbFwiKTtcbmV4cG9ydHMuaXNTY2FsYXIgPSBmdW5jdGlvbiAoc2NoZW1hLCBwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0geyByb290OiB0cnVlIH07IH1cbiAgICB2YXIgZGVmID0gc2NoZW1hLl9kZWY7XG4gICAgdmFyIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgc3dpdGNoIChkZWYudCkge1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuc3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5udW1iZXI6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmJpZ2ludDpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuYm9vbGVhbjpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudW5kZWZpbmVkOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5udWxsOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5hbnk6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy51bmtub3duOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudm9pZDpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmFycmF5OlxuICAgICAgICAgICAgaWYgKHBhcmFtcy5yb290ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGV4cG9ydHMuaXNTY2FsYXIoZGVmLnR5cGUsIHsgcm9vdDogZmFsc2UgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm9iamVjdDpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnVuaW9uOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBkZWYub3B0aW9ucy5ldmVyeShmdW5jdGlvbiAoeCkgeyByZXR1cm4gZXhwb3J0cy5pc1NjYWxhcih4KTsgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmludGVyc2VjdGlvbjpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZXhwb3J0cy5pc1NjYWxhcihkZWYubGVmdCkgJiYgZXhwb3J0cy5pc1NjYWxhcihkZWYucmlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy50dXBsZTpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmxhenk6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGV4cG9ydHMuaXNTY2FsYXIoZGVmLmdldHRlcigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubGl0ZXJhbDpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuZW51bTpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubmF0aXZlRW51bTpcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuZnVuY3Rpb246XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5yZWNvcmQ6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5kYXRlOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5wcm9taXNlOlxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMua2V5b2Y6XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHV0aWxfMS51dGlsLmFzc2VydE5ldmVyKGRlZik7XG4gICAgICAgIC8vIHJldHVyblZhbHVlID0gZmFsc2U7IGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTY2FsYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfdGhpcyA9IHRoaXM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9iYXNlXCIpKTtcbnZhciBab2RFcnJvcl8xID0gcmVxdWlyZShcIi4vWm9kRXJyb3JcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsXCIpO1xudmFyIGRlZmF1bHRFcnJvck1hcF8xID0gcmVxdWlyZShcIi4vZGVmYXVsdEVycm9yTWFwXCIpO1xuZXhwb3J0cy5nZXRQYXJzZWRUeXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGRhdGEpKVxuICAgICAgICAgICAgcmV0dXJuICduYW4nO1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJldHVybiAnYmlnaW50JztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzeW1ib2wnKVxuICAgICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuICdmdW5jdGlvbic7XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgIGlmICghZGF0YSlcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIGlmIChkYXRhLnRoZW4gJiZcbiAgICAgICAgICAgIHR5cGVvZiBkYXRhLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIGRhdGEuY2F0Y2ggJiZcbiAgICAgICAgICAgIHR5cGVvZiBkYXRhLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Byb21pc2UnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgcmV0dXJuICd1bmtub3duJztcbn07XG5leHBvcnRzLlpvZFBhcnNlZFR5cGUgPSB1dGlsXzEudXRpbC5hcnJheVRvRW51bShbXG4gICAgJ3N0cmluZycsXG4gICAgJ25hbicsXG4gICAgJ251bWJlcicsXG4gICAgJ2ludGVnZXInLFxuICAgICdib29sZWFuJyxcbiAgICAnZGF0ZScsXG4gICAgJ2JpZ2ludCcsXG4gICAgJ3N5bWJvbCcsXG4gICAgJ2Z1bmN0aW9uJyxcbiAgICAndW5kZWZpbmVkJyxcbiAgICAnbnVsbCcsXG4gICAgJ2FycmF5JyxcbiAgICAnb2JqZWN0JyxcbiAgICAndW5rbm93bicsXG4gICAgJ3Byb21pc2UnLFxuICAgICd2b2lkJyxcbl0pO1xuZXhwb3J0cy5maW5kID0gZnVuY3Rpb24gKGFyciwgY2hlY2tlcikge1xuICAgIGZvciAodmFyIF9pID0gMCwgYXJyXzEgPSBhcnI7IF9pIDwgYXJyXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJyXzFbX2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbnZhciBtYWtlRXJyb3IgPSBmdW5jdGlvbiAocGFyYW1zLCBvYmosIGVycm9yRGF0YSkge1xuICAgIHZhciBlcnJvckFyZyA9IF9fYXNzaWduKHt9LCBlcnJvckRhdGEsIHsgcGF0aDogcGFyYW1zLnBhdGguY29uY2F0KChlcnJvckRhdGEucGF0aCB8fCBbXSkpIH0pO1xuICAgIHZhciBjdHhBcmcgPSB7IGRhdGE6IG9iaiB9O1xuICAgIHZhciBkZWZhdWx0RXJyb3IgPSBkZWZhdWx0RXJyb3JNYXBfMS5kZWZhdWx0RXJyb3JNYXAgPT09IHBhcmFtcy5lcnJvck1hcFxuICAgICAgICA/IHsgbWVzc2FnZTogXCJJbnZhbGlkIHZhbHVlLlwiIH1cbiAgICAgICAgOiBkZWZhdWx0RXJyb3JNYXBfMS5kZWZhdWx0RXJyb3JNYXAoZXJyb3JBcmcsIF9fYXNzaWduKHt9LCBjdHhBcmcsIHsgZGVmYXVsdEVycm9yOiBcIkludmFsaWQgdmFsdWUuXCIgfSkpO1xuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgZXJyb3JEYXRhLCB7IHBhdGg6IHBhcmFtcy5wYXRoLmNvbmNhdCgoZXJyb3JEYXRhLnBhdGggfHwgW10pKSwgbWVzc2FnZTogZXJyb3JEYXRhLm1lc3NhZ2UgfHxcbiAgICAgICAgICAgIHBhcmFtcy5lcnJvck1hcChlcnJvckFyZywgX19hc3NpZ24oe30sIGN0eEFyZywgeyBkZWZhdWx0RXJyb3I6IGRlZmF1bHRFcnJvci5tZXNzYWdlIH0pKS5tZXNzYWdlIH0pO1xufTtcbmV4cG9ydHMuWm9kUGFyc2VyID0gZnVuY3Rpb24gKHNjaGVtYURlZikgeyByZXR1cm4gZnVuY3Rpb24gKG9iaiwgYmFzZVBhcmFtcykge1xuICAgIGlmIChiYXNlUGFyYW1zID09PSB2b2lkIDApIHsgYmFzZVBhcmFtcyA9IHsgc2VlbjogW10sIGVycm9yTWFwOiBkZWZhdWx0RXJyb3JNYXBfMS5kZWZhdWx0RXJyb3JNYXAsIHBhdGg6IFtdIH07IH1cbiAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBzZWVuOiBiYXNlUGFyYW1zLnNlZW4gfHwgW10sXG4gICAgICAgIHBhdGg6IGJhc2VQYXJhbXMucGF0aCB8fCBbXSxcbiAgICAgICAgZXJyb3JNYXA6IGJhc2VQYXJhbXMuZXJyb3JNYXAgfHwgZGVmYXVsdEVycm9yTWFwXzEuZGVmYXVsdEVycm9yTWFwLFxuICAgIH07XG4gICAgdmFyIGRlZiA9IHNjaGVtYURlZjtcbiAgICB2YXIgcGFyc2VkVHlwZSA9IGV4cG9ydHMuZ2V0UGFyc2VkVHlwZShvYmopO1xuICAgIHZhciBzY2hlbWFTZWVuID0gZXhwb3J0cy5maW5kKHBhcmFtcy5zZWVuLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zY2hlbWEgPT09IHNjaGVtYURlZjsgfSk7XG4gICAgdmFyIGlzTm9ucHJpbWl0aXZlID0gWydhcnJheScsICdvYmplY3QnXS5pbmRleE9mKHBhcnNlZFR5cGUpICE9PSAtMTtcbiAgICBpZiAoaXNOb25wcmltaXRpdmUpIHtcbiAgICAgICAgaWYgKHNjaGVtYVNlZW4pIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGV4cG9ydHMuZmluZChzY2hlbWFTZWVuLm9iamVjdHMsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmRhdGEgPT09IG9iajsgfSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZm91bmQuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvdW5kLnRpbWVzID0gZm91bmQudGltZXMgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZC50aW1lcyA+IDUgJiYgaXNOb25wcmltaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbCgncmVjdXJzaW9uIGRlcHRoIGV4Y2VlZGVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3VuZC50aW1lcyA+IDIpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHNjaGVtYVNlZW4ub2JqZWN0cy5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMuc2Vlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYURlZixcbiAgICAgICAgICAgICAgICBvYmplY3RzOiBbeyBkYXRhOiBvYmosIGVycm9yOiB1bmRlZmluZWQsIHRpbWVzOiAxIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc3Qgc2V0RXJyb3IgPSAoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgLy8gICBjb25zdCBzY2hlbWFTZWVuID0gcGFyYW1zLnNlZW4uZmluZCh4ID0+IHguc2NoZW1hID09PSBzY2hlbWFEZWYpO1xuICAgIC8vICAgaWYgKHNjaGVtYVNlZW4pIHtcbiAgICAvLyAgICAgY29uc3QgZm91bmQgPSBzY2hlbWFTZWVuLm9iamVjdHMuZmluZCh4ID0+IHguZGF0YSA9PT0gb2JqKTtcbiAgICAvLyAgICAgaWYgKGZvdW5kKSB7XG4gICAgLy8gICAgICAgZm91bmQuZXJyb3IgPSBlcnJvcjtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuICAgIC8vIH07XG4gICAgdmFyIGVycm9yID0gbmV3IFpvZEVycm9yXzEuWm9kRXJyb3IoW10pO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IG9iajtcbiAgICBzd2l0Y2ggKGRlZi50KSB7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5zdHJpbmc6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnN0cmluZykge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5udW1iZXI6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihvYmopKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmJpZ2ludDpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUuYmlnaW50KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmJvb2xlYW46XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLnVuZGVmaW5lZDpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS51bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLm51bGw6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmFueTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudW5rbm93bjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudm9pZDpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnZvaWQsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmFycmF5OlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBwYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG9iajtcbiAgICAgICAgICAgIGlmIChkZWYubm9uZW1wdHkgPT09IHRydWUgJiYgb2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5ub25lbXB0eV9hcnJheV9pc19lbXB0eSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkSXRlbSA9IGRlZi50eXBlLnBhcnNlKGl0ZW0sIF9fYXNzaWduKHt9LCBwYXJhbXMsIHsgcGF0aDogcGFyYW1zLnBhdGguY29uY2F0KFtpXSkgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkSXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgemVyciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3JzKHplcnIuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZXJyb3IuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMub2JqZWN0OlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGRlZi5zaGFwZSgpO1xuICAgICAgICAgICAgaWYgKGRlZi5wYXJhbXMuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlS2V5c18xID0gT2JqZWN0LmtleXMoc2hhcGUpO1xuICAgICAgICAgICAgICAgIHZhciBvYmpLZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFLZXlzID0gb2JqS2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHNoYXBlS2V5c18xLmluZGV4T2YoaykgPT09IC0xOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2hhcGUoKVtrZXldLnBhcnNlKG9ialtrZXldLCBfX2Fzc2lnbih7fSwgcGFyYW1zLCB7IHBhdGg6IHBhcmFtcy5wYXRoLmNvbmNhdChba2V5XSkgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6ZXJyID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcnMoemVyci5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudW5pb246XG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHVuaW9uRXJyb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGVmLm9wdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24ucGFyc2Uob2JqLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB1bmlvbkVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkRXJyb3JzID0gdW5pb25FcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyci5lcnJvcnNbMF0uY29kZSAhPT0gJ2ludmFsaWRfdHlwZSc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkRXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcnMoZmlsdGVyZWRFcnJvcnNbMF0uZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzOiB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMuaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWYubGVmdC5wYXJzZShvYmosIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3JzKGVyci5lcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWYucmlnaHQucGFyc2Uob2JqLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9ycyhlcnIuZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMudHVwbGU6XG4gICAgICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoID4gZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2JqLmxlbmd0aCA8IGRlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcnNlZFR1cGxlID0gW107XG4gICAgICAgICAgICB2YXIgdHVwbGVEYXRhID0gb2JqO1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gdHVwbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0dXBsZURhdGFbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBpdGVtUGFyc2VyID0gZGVmLml0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRUdXBsZS5wdXNoKGl0ZW1QYXJzZXIucGFyc2UoaXRlbSwgX19hc3NpZ24oe30sIHBhcmFtcywgeyBwYXRoOiBwYXJhbXMucGF0aC5jb25jYXQoW2luZGV4XSkgfSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcnMoZXJyLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5sYXp5OlxuICAgICAgICAgICAgdmFyIGxhenlTY2hlbWEgPSBkZWYuZ2V0dGVyKCk7XG4gICAgICAgICAgICBsYXp5U2NoZW1hLnBhcnNlKG9iaiwgcGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMubGl0ZXJhbDpcbiAgICAgICAgICAgIGlmIChvYmogIT09IGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2xpdGVyYWxfdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBkZWYudmFsdWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5lbnVtOlxuICAgICAgICAgICAgaWYgKGRlZi52YWx1ZXMuaW5kZXhPZihvYmopID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGRlZi52YWx1ZXMsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5uYXRpdmVFbnVtOlxuICAgICAgICAgICAgaWYgKHV0aWxfMS51dGlsLmdldFZhbGlkRW51bVZhbHVlcyhkZWYudmFsdWVzKS5pbmRleE9mKG9iaikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdXRpbF8xLnV0aWwuZ2V0VmFsdWVzKGRlZi52YWx1ZXMpLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMua2V5b2Y6XG4gICAgICAgICAgICBpZiAodXRpbF8xLnV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKGRlZi52YWx1ZXMpLmluZGV4T2Yob2JqKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB1dGlsXzEudXRpbC5nZXRWYWx1ZXMoZGVmLnZhbHVlcyksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugei5ab2RUeXBlcy5mdW5jdGlvbjpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogcGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbGlkYXRlZEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZi5hcmdzLnBhcnNlKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBab2RFcnJvcl8xLlpvZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnc0Vycm9yID0gbmV3IFpvZEVycm9yXzEuWm9kRXJyb3IoW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc0Vycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0Vycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBhcmdzRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZi5yZXR1cm5zLnBhcnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFpvZEVycm9yXzEuWm9kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5zRXJyb3IgPSBuZXcgWm9kRXJyb3JfMS5ab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5zRXJyb3IuYWRkRXJyb3IobWFrZUVycm9yKHBhcmFtcywgb2JqLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJldHVybnNFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMucmVjb3JkOlxuICAgICAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5hZGRFcnJvcihtYWtlRXJyb3IocGFyYW1zLCBvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWVUeXBlLnBhcnNlKG9ialtrZXldLCBfX2Fzc2lnbih7fSwgcGFyYW1zLCB7IHBhdGg6IHBhcmFtcy5wYXRoLmNvbmNhdChba2V5XSkgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9ycyhlcnIuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB6LlpvZFR5cGVzLmRhdGU6XG4gICAgICAgICAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihvYmouZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX2RhdGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHouWm9kVHlwZXMucHJvbWlzZTpcbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBleHBvcnRzLlpvZFBhcnNlZFR5cGUucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBvcnRzLlpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqVmFsdWUsIHBhcnNlZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgb2JqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpWYWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBkZWYudHlwZS5wYXJzZShvYmpWYWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdXRpbF8xLnV0aWwuYXNzZXJ0TmV2ZXIoZGVmKTtcbiAgICB9XG4gICAgdmFyIGN1c3RvbUNoZWNrcyA9IGRlZi5jaGVja3MgfHwgW107XG4gICAgZm9yICh2YXIgX2IgPSAwLCBjdXN0b21DaGVja3NfMSA9IGN1c3RvbUNoZWNrczsgX2IgPCBjdXN0b21DaGVja3NfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgdmFyIGNoZWNrID0gY3VzdG9tQ2hlY2tzXzFbX2JdO1xuICAgICAgICBpZiAoIWNoZWNrLmNoZWNrKHJldHVyblZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGNoZWNrTWV0aG9kID0gY2hlY2suY2hlY2ssIG5vTWV0aG9kQ2hlY2sgPSBfX3Jlc3QoY2hlY2ssIFtcImNoZWNrXCJdKTtcbiAgICAgICAgICAgIGVycm9yLmFkZEVycm9yKG1ha2VFcnJvcihwYXJhbXMsIG9iaiwgbm9NZXRob2RDaGVjaykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZXJyb3IuaXNFbXB0eSkge1xuICAgICAgICAvLyBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59OyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RBbnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZEFueSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RBbnkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RBbnkuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmFueSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kQW55O1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kQW55ID0gWm9kQW55O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG4vLyBpbXBvcnQgeyBab2RVbmRlZmluZWQgfSBmcm9tICcuL3VuZGVmaW5lZCc7XG4vLyBpbXBvcnQgeyBab2ROdWxsIH0gZnJvbSAnLi9udWxsJztcbi8vIGltcG9ydCB7IFpvZFVuaW9uIH0gZnJvbSAnLi91bmlvbic7XG52YXIgWm9kRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9ab2RFcnJvclwiKTtcbnZhciBab2RBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kQXJyYXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kQXJyYXkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHQ6IF90aGlzLl9kZWYudCxcbiAgICAgICAgICAgICAgICBub25lbXB0eTogX3RoaXMuX2RlZi5ub25lbXB0eSxcbiAgICAgICAgICAgICAgICB0eXBlOiBfdGhpcy5fZGVmLnR5cGUudG9KU09OKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMubWluID0gZnVuY3Rpb24gKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhLmxlbmd0aCA+PSBtaW5MZW5ndGg7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19zbWFsbCwgdHlwZTogJ2FycmF5JywgaW5jbHVzaXZlOiB0cnVlLCBtaW5pbXVtOiBtaW5MZW5ndGggfSwgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IHsgbWVzc2FnZTogbWVzc2FnZSB9IDogbWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWF4ID0gZnVuY3Rpb24gKG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhLmxlbmd0aCA8PSBtYXhMZW5ndGg7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19iaWcsIHR5cGU6ICdhcnJheScsIGluY2x1c2l2ZTogdHJ1ZSwgbWF4aW11bTogbWF4TGVuZ3RoIH0sICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSA6IG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmxlbmd0aCA9IGZ1bmN0aW9uIChsZW4sIG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLm1pbihsZW4sIHsgbWVzc2FnZTogbWVzc2FnZSB9KS5tYXgobGVuLCB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7IH07XG4gICAgICAgIF90aGlzLm5vbmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2ROb25FbXB0eUFycmF5KF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IG5vbmVtcHR5OiB0cnVlIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kQXJyYXkucHJvdG90eXBlLCBcImVsZW1lbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgWm9kQXJyYXkuY3JlYXRlID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMuYXJyYXksXG4gICAgICAgICAgICB0eXBlOiBzY2hlbWEsXG4gICAgICAgICAgICBub25lbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZEFycmF5O1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kQXJyYXkgPSBab2RBcnJheTtcbnZhciBab2ROb25FbXB0eUFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2ROb25FbXB0eUFycmF5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZE5vbkVtcHR5QXJyYXkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHQ6IF90aGlzLl9kZWYudCxcbiAgICAgICAgICAgICAgICB0eXBlOiBfdGhpcy5fZGVmLnR5cGUudG9KU09OKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMubWluID0gZnVuY3Rpb24gKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhLmxlbmd0aCA+PSBtaW5MZW5ndGg7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19zbWFsbCwgbWluaW11bTogbWluTGVuZ3RoLCB0eXBlOiAnYXJyYXknLCBpbmNsdXNpdmU6IHRydWUgfSwgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IHsgbWVzc2FnZTogbWVzc2FnZSB9IDogbWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWF4ID0gZnVuY3Rpb24gKG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhLmxlbmd0aCA8PSBtYXhMZW5ndGg7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19iaWcsIG1heGltdW06IG1heExlbmd0aCwgdHlwZTogJ2FycmF5JywgaW5jbHVzaXZlOiB0cnVlIH0sICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSA6IG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmxlbmd0aCA9IGZ1bmN0aW9uIChsZW4sIG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLm1pbihsZW4sIHsgbWVzc2FnZTogbWVzc2FnZSB9KS5tYXgobGVuLCB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFpvZE5vbkVtcHR5QXJyYXk7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2ROb25FbXB0eUFycmF5ID0gWm9kTm9uRW1wdHlBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJcIik7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcbnZhciBab2RUeXBlcztcbihmdW5jdGlvbiAoWm9kVHlwZXMpIHtcbiAgICBab2RUeXBlc1tcInN0cmluZ1wiXSA9IFwic3RyaW5nXCI7XG4gICAgWm9kVHlwZXNbXCJudW1iZXJcIl0gPSBcIm51bWJlclwiO1xuICAgIFpvZFR5cGVzW1wiYmlnaW50XCJdID0gXCJiaWdpbnRcIjtcbiAgICBab2RUeXBlc1tcImJvb2xlYW5cIl0gPSBcImJvb2xlYW5cIjtcbiAgICBab2RUeXBlc1tcImRhdGVcIl0gPSBcImRhdGVcIjtcbiAgICBab2RUeXBlc1tcInVuZGVmaW5lZFwiXSA9IFwidW5kZWZpbmVkXCI7XG4gICAgWm9kVHlwZXNbXCJudWxsXCJdID0gXCJudWxsXCI7XG4gICAgWm9kVHlwZXNbXCJhcnJheVwiXSA9IFwiYXJyYXlcIjtcbiAgICBab2RUeXBlc1tcIm9iamVjdFwiXSA9IFwib2JqZWN0XCI7XG4gICAgWm9kVHlwZXNbXCJ1bmlvblwiXSA9IFwidW5pb25cIjtcbiAgICBab2RUeXBlc1tcImludGVyc2VjdGlvblwiXSA9IFwiaW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kVHlwZXNbXCJ0dXBsZVwiXSA9IFwidHVwbGVcIjtcbiAgICBab2RUeXBlc1tcInJlY29yZFwiXSA9IFwicmVjb3JkXCI7XG4gICAgWm9kVHlwZXNbXCJmdW5jdGlvblwiXSA9IFwiZnVuY3Rpb25cIjtcbiAgICBab2RUeXBlc1tcImxhenlcIl0gPSBcImxhenlcIjtcbiAgICBab2RUeXBlc1tcImxpdGVyYWxcIl0gPSBcImxpdGVyYWxcIjtcbiAgICBab2RUeXBlc1tcImVudW1cIl0gPSBcImVudW1cIjtcbiAgICBab2RUeXBlc1tcIm5hdGl2ZUVudW1cIl0gPSBcIm5hdGl2ZUVudW1cIjtcbiAgICBab2RUeXBlc1tcInByb21pc2VcIl0gPSBcInByb21pc2VcIjtcbiAgICBab2RUeXBlc1tcImFueVwiXSA9IFwiYW55XCI7XG4gICAgWm9kVHlwZXNbXCJ1bmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gICAgWm9kVHlwZXNbXCJ2b2lkXCJdID0gXCJ2b2lkXCI7XG4gICAgWm9kVHlwZXNbXCJrZXlvZlwiXSA9IFwia2V5b2ZcIjtcbn0pKFpvZFR5cGVzID0gZXhwb3J0cy5ab2RUeXBlcyB8fCAoZXhwb3J0cy5ab2RUeXBlcyA9IHt9KSk7XG52YXIgWm9kVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBab2RUeXBlKGRlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZSA9IGZ1bmN0aW9uIChkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IF90aGlzLnBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFyc2VkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGluZGV4XzEuWm9kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhcnNlQXN5bmMgPSBmdW5jdGlvbiAodmFsdWUsIHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBfdGhpcy5wYXJzZSh2YWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcyhwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWooZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSBmdW5jdGlvbiAoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9ICdJbnZhbGlkIHZhbHVlLic7IH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVmaW5lbWVudCh7IGNoZWNrOiBjaGVjaywgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGNoZWNrIH0sIG1lc3NhZ2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gZnVuY3Rpb24gKHJlZmluZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNvZGU6IGluZGV4XzEuWm9kRXJyb3JDb2RlLmN1c3RvbV9lcnJvciB9LCByZWZpbmVtZW50KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3JlZmluZW1lbnQgPSBmdW5jdGlvbiAocmVmaW5lbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfdGhpcy5jb25zdHJ1Y3RvcihfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyBjaGVja3M6IChfdGhpcy5fZGVmLmNoZWNrcyB8fCBbXSkuY29uY2F0KFtyZWZpbmVtZW50XSkgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyAgYWJzdHJhY3QgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBhbnk7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhfMS5ab2RVbmlvbi5jcmVhdGUoW190aGlzLCBpbmRleF8xLlpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm51bGxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4XzEuWm9kVW5pb24uY3JlYXRlKFtfdGhpcywgaW5kZXhfMS5ab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXJyYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF8xLlpvZEFycmF5LmNyZWF0ZShfdGhpcyk7IH07XG4gICAgICAgIHRoaXMub3IgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhfMS5ab2RVbmlvbi5jcmVhdGUoW190aGlzLCBhcmddKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2VyXzEuWm9kUGFyc2VyKGRlZik7XG4gICAgfVxuICAgIFpvZFR5cGUucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucGFyc2UodSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFpvZFR5cGUucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucGFyc2UodSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBab2RUeXBlO1xufSgpKTtcbmV4cG9ydHMuWm9kVHlwZSA9IFpvZFR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RCaWdJbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZEJpZ0ludCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RCaWdJbnQoKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RCaWdJbnQuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmJpZ2ludCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kQmlnSW50O1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kQmlnSW50ID0gWm9kQmlnSW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnaW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RCb29sZWFuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RCb29sZWFuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZEJvb2xlYW4oKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RCb29sZWFuLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMuYm9vbGVhbixcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kQm9vbGVhbjtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZEJvb2xlYW4gPSBab2RCb29sZWFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kRGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kRGF0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2REYXRlKCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kRGF0ZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmRhdGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZERhdGU7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2REYXRlID0gWm9kRGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZEVudW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZEVudW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kRW51bSgpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RFbnVtLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZEVudW0ucHJvdG90eXBlLCBcImVudW1cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbnVtVmFsdWVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fZGVmLnZhbHVlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kRW51bS5wcm90b3R5cGUsIFwiVmFsdWVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2RlZi52YWx1ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvZEVudW0ucHJvdG90eXBlLCBcIkVudW1cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbnVtVmFsdWVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fZGVmLnZhbHVlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBab2RFbnVtLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMuZW51bSxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RFbnVtO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kRW51bSA9IFpvZEVudW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL3R1cGxlXCIpO1xudmFyIHVua25vd25fMSA9IHJlcXVpcmUoXCIuL3Vua25vd25cIik7XG52YXIgWm9kRnVuY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZEZ1bmN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZEZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbihfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyBhcmdzOiB0dXBsZV8xLlpvZFR1cGxlLmNyZWF0ZShpdGVtcykgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZXR1cm5zID0gZnVuY3Rpb24gKHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgcmV0dXJuczogcmV0dXJuVHlwZSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmltcGxlbWVudCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGVkRnVuYyA9IF90aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnZhbGlkYXRlID0gX3RoaXMuaW1wbGVtZW50O1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0OiBfdGhpcy5fZGVmLnQsXG4gICAgICAgICAgICAgICAgYXJnczogX3RoaXMuX2RlZi5hcmdzLnRvSlNPTigpLFxuICAgICAgICAgICAgICAgIHJldHVybnM6IF90aGlzLl9kZWYucmV0dXJucy50b0pTT04oKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kRnVuY3Rpb24uY3JlYXRlID0gZnVuY3Rpb24gKGFyZ3MsIHJldHVybnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmZ1bmN0aW9uLFxuICAgICAgICAgICAgYXJnczogYXJncyB8fCB0dXBsZV8xLlpvZFR1cGxlLmNyZWF0ZShbXSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IHVua25vd25fMS5ab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RGdW5jdGlvbjtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZEZ1bmN0aW9uID0gWm9kRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kSW50ZXJzZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RJbnRlcnNlY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kSW50ZXJzZWN0aW9uKCkge1xuICAgICAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICB0OiBfdGhpcy5fZGVmLnQsXG4gICAgICAgICAgICBsZWZ0OiBfdGhpcy5fZGVmLmxlZnQudG9KU09OKCksXG4gICAgICAgICAgICByaWdodDogX3RoaXMuX2RlZi5yaWdodC50b0pTT04oKSxcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLmludGVyc2VjdGlvbixcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbjtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZEludGVyc2VjdGlvbiA9IFpvZEludGVyc2VjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyc2VjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kS2V5b2YgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZEtleW9mLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZEtleW9mKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHQ6IF90aGlzLl9kZWYudCxcbiAgICAgICAgICAgIHZhbHVlczogX3RoaXMuX2RlZi52YWx1ZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH0pLFxuICAgICAgICB9KTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RLZXlvZi5jcmVhdGUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kS2V5b2Yoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5rZXlvZixcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGNhc3QgaXMgbm90IGNvcnJlY3QgaW4gdGhlIGdlbmVyYWwgY2FzZVxuICAgICAgICAgICAgLy8gU2VlIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMjg3MFxuICAgICAgICAgICAgdmFsdWVzOiBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RLZXlvZjtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZEtleW9mID0gWm9kS2V5b2Y7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlvZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kTGF6eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kTGF6eSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RMYXp5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IEpTT05pZnkgcmVjdXJzaXZlIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9kTGF6eS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBab2RMYXp5LmNyZWF0ZSA9IGZ1bmN0aW9uIChnZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMubGF6eSxcbiAgICAgICAgICAgIGdldHRlcjogZ2V0dGVyLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RMYXp5O1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kTGF6eSA9IFpvZExhenk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXp5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RMaXRlcmFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RMaXRlcmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZExpdGVyYWwoKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RMaXRlcmFsLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZExpdGVyYWwoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5saXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RMaXRlcmFsO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kTGl0ZXJhbCA9IFpvZExpdGVyYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXRlcmFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2ROYXRpdmVFbnVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2ROYXRpdmVFbnVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZE5hdGl2ZUVudW0oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZE5hdGl2ZUVudW0uY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE5hdGl2ZUVudW0oe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5uYXRpdmVFbnVtLFxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZE5hdGl2ZUVudW07XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2ROYXRpdmVFbnVtID0gWm9kTmF0aXZlRW51bTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdGl2ZUVudW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZE51bGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZE51bGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kTnVsbCgpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZE51bGwuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bGwoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5udWxsLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2ROdWxsO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kTnVsbCA9IFpvZE51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG4vLyBpbXBvcnQgeyBab2RVbmRlZmluZWQgfSBmcm9tICcuL3VuZGVmaW5lZCc7XG4vLyBpbXBvcnQgeyBab2ROdWxsIH0gZnJvbSAnLi9udWxsJztcbi8vIGltcG9ydCB7IFpvZFVuaW9uIH0gZnJvbSAnLi91bmlvbic7XG52YXIgWm9kRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9ab2RFcnJvclwiKTtcbnZhciBlcnJvclV0aWxfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Vycm9yVXRpbFwiKTtcbnZhciBab2ROdW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZE51bWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2ROdW1iZXIoKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgX3RoaXMubWluID0gZnVuY3Rpb24gKG1pbmltdW0sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSA+PSBtaW5pbXVtOyB9LCBjb2RlOiBab2RFcnJvcl8xLlpvZEVycm9yQ29kZS50b29fc21hbGwsIG1pbmltdW06IG1pbmltdW0sIHR5cGU6ICdudW1iZXInLCBpbmNsdXNpdmU6IHRydWUgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm1heCA9IGZ1bmN0aW9uIChtYXhpbXVtLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgPD0gbWF4aW11bTsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX2JpZywgbWF4aW11bTogbWF4aW11bSwgdHlwZTogJ251bWJlcicsIGluY2x1c2l2ZTogdHJ1ZSB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaW50ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihkYXRhKTsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUuaW52YWxpZF90eXBlLCBleHBlY3RlZDogJ2ludGVnZXInLCByZWNlaXZlZDogJ251bWJlcicgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnBvc2l0aXZlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSA+IDA7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19zbWFsbCwgbWluaW11bTogMCwgdHlwZTogJ251bWJlcicsIGluY2x1c2l2ZTogZmFsc2UgfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm5lZ2F0aXZlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IGNoZWNrOiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSA8IDA7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19iaWcsIG1heGltdW06IDAsIHR5cGU6ICdudW1iZXInLCBpbmNsdXNpdmU6IGZhbHNlIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5ub25wb3NpdGl2ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgPD0gMDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX2JpZywgbWF4aW11bTogMCwgdHlwZTogJ251bWJlcicsIGluY2x1c2l2ZTogdHJ1ZSB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubm9ubmVnYXRpdmUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhID49IDA7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19zbWFsbCwgbWluaW11bTogMCwgdHlwZTogJ251bWJlcicsIGluY2x1c2l2ZTogdHJ1ZSB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2ROdW1iZXIuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLm51bWJlcixcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kTnVtYmVyO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kTnVtYmVyID0gWm9kTnVtYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgb2JqZWN0VXRpbF8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvb2JqZWN0VXRpbFwiKTtcbnZhciBpc1NjYWxhcl8xID0gcmVxdWlyZShcIi4uL2lzU2NhbGFyXCIpO1xudmFyIEF1Z21lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gZnVuY3Rpb24gKGF1Z21lbnRhdGlvbikge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KF9fYXNzaWduKHt9LCBkZWYsIHsgc2hhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfX2Fzc2lnbih7fSwgZGVmLnNoYXBlKCksIGF1Z21lbnRhdGlvbikpOyB9IH0pKTtcbn07IH07XG52YXIgb2JqZWN0RGVmVG9Kc29uID0gZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gKHtcbiAgICB0OiBkZWYudCxcbiAgICBzaGFwZTogT2JqZWN0LmFzc2lnbih7fSwgT2JqZWN0LmtleXMoZGVmLnNoYXBlKCkpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW2tdID0gZGVmLnNoYXBlKClba10udG9KU09OKCksXG4gICAgICAgICAgICBfYSk7XG4gICAgfSkpLFxufSk7IH07XG52YXIgWm9kT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RPYmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kT2JqZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqZWN0RGVmVG9Kc29uKF90aGlzLl9kZWYpOyB9O1xuICAgICAgICBfdGhpcy5ub25zdHJpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IF90aGlzLl9kZWYuc2hhcGUsXG4gICAgICAgICAgICAgICAgdDogei5ab2RUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBfX2Fzc2lnbih7fSwgX3RoaXMuX3BhcmFtcywgeyBzdHJpY3Q6IGZhbHNlIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgLy8gbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMuYXVnbWVudCA9IEF1Z21lbnRGYWN0b3J5KF90aGlzLl9kZWYpO1xuICAgICAgICBfdGhpcy5leHRlbmQgPSBBdWdtZW50RmFjdG9yeShfdGhpcy5fZGVmKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgICAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICAgICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5tZXJnZSA9IG9iamVjdFV0aWxfMS5vYmplY3RVdGlsLm1lcmdlT2JqZWN0cyhfdGhpcyk7XG4gICAgICAgIF90aGlzLnBpY2sgPSBmdW5jdGlvbiAobWFzaykge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtYXNrKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSBfdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdChfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyBzaGFwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcGU7IH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbWl0ID0gZnVuY3Rpb24gKG1hc2spIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3RoaXMuc2hhcGUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1hc2spLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IF90aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdChfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyBzaGFwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcGU7IH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5wYXJ0aWFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX3RoaXMuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gX3RoaXMuc2hhcGVba2V5XS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3QoX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgc2hhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ld1NoYXBlOyB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucHJpbWl0aXZlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIF90aGlzLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2NhbGFyXzEuaXNTY2FsYXIoX3RoaXMuc2hhcGVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IF90aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3QoX19hc3NpZ24oe30sIF90aGlzLl9kZWYsIHsgc2hhcGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ld1NoYXBlOyB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubm9ucHJpbWl0aXZlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIF90aGlzLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1NjYWxhcl8xLmlzU2NhbGFyKF90aGlzLnNoYXBlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBfdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KF9fYXNzaWduKHt9LCBfdGhpcy5fZGVmLCB7IHNoYXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXdTaGFwZTsgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmRlZXBQYXJ0aWFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX3RoaXMuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRTY2hlbWEgPSBfdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZFNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEuZGVlcFBhcnRpYWwoKS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IF90aGlzLnNoYXBlW2tleV0ub3B0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdChfX2Fzc2lnbih7fSwgX3RoaXMuX2RlZiwgeyBzaGFwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3U2hhcGU7IH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RPYmplY3QucHJvdG90eXBlLCBcInNoYXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab2RPYmplY3QucHJvdG90eXBlLCBcInBhcmFtc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5wYXJhbXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFpvZE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy5vYmplY3QsXG4gICAgICAgICAgICBzaGFwZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcGU7IH0sXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFpvZE9iamVjdC5sYXp5Y3JlYXRlID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMub2JqZWN0LFxuICAgICAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9kT2JqZWN0O1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kT2JqZWN0ID0gWm9kT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbnZhciBab2RQcm9taXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RQcm9taXNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZFByb21pc2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHQ6IF90aGlzLl9kZWYudCxcbiAgICAgICAgICAgICAgICB0eXBlOiBfdGhpcy5fZGVmLnR5cGUudG9KU09OKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgWm9kUHJvbWlzZS5jcmVhdGUgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLnByb21pc2UsXG4gICAgICAgICAgICB0eXBlOiBzY2hlbWEsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZFByb21pc2U7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RQcm9taXNlID0gWm9kUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZFJlY29yZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kUmVjb3JkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvZFJlY29yZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICB0OiBfdGhpcy5fZGVmLnQsXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IF90aGlzLl9kZWYudmFsdWVUeXBlLnRvSlNPTigpLFxuICAgICAgICB9KTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgIFpvZFJlY29yZC5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWVUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMucmVjb3JkLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiB2YWx1ZVR5cGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZFJlY29yZDtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZFJlY29yZCA9IFpvZFJlY29yZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY29yZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xuLy8gaW1wb3J0IHsgWm9kVW5kZWZpbmVkIH0gZnJvbSAnLi91bmRlZmluZWQnO1xuLy8gaW1wb3J0IHsgWm9kTnVsbCB9IGZyb20gJy4vbnVsbCc7XG4vLyBpbXBvcnQgeyBab2RVbmlvbiB9IGZyb20gJy4vdW5pb24nO1xudmFyIFpvZEVycm9yXzEgPSByZXF1aXJlKFwiLi4vWm9kRXJyb3JcIik7XG52YXIgZXJyb3JVdGlsXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lcnJvclV0aWxcIik7XG52YXIgZW1haWxSZWdleCA9IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaTtcbnZhciB1dWlkUmVnZXggPSAvXlthLWYwLTldezh9LVthLWYwLTldezR9LTRbYS1mMC05XXszfS1bODlhQWJCXVthLWYwLTldezN9LVthLWYwLTldezEyfSQvaTtcbnZhciBab2RTdHJpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZFN0cmluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RTdHJpbmcoKSB7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG51bGwgbnVsbGFibGU6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2ROdWxsXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZE51bGwuY3JlYXRlKCldKTtcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgX3RoaXMubWluID0gZnVuY3Rpb24gKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWZpbmVtZW50KF9fYXNzaWduKHsgY2hlY2s6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhLmxlbmd0aCA+PSBtaW5MZW5ndGg7IH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLnRvb19zbWFsbCwgbWluaW11bTogbWluTGVuZ3RoLCB0eXBlOiAnc3RyaW5nJywgaW5jbHVzaXZlOiB0cnVlIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tYXggPSBmdW5jdGlvbiAobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEubGVuZ3RoIDw9IG1heExlbmd0aDsgfSwgY29kZTogWm9kRXJyb3JfMS5ab2RFcnJvckNvZGUudG9vX2JpZywgbWF4aW11bTogbWF4TGVuZ3RoLCB0eXBlOiAnc3RyaW5nJywgaW5jbHVzaXZlOiB0cnVlIH0sIGVycm9yVXRpbF8xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fcmVnZXggPSBmdW5jdGlvbiAocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVmaW5lbWVudChfX2Fzc2lnbih7IHZhbGlkYXRpb246IHZhbGlkYXRpb24sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfc3RyaW5nLCBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIHJlZ2V4LnRlc3QoZGF0YSk7IH0gfSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmVtYWlsID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVnZXgoZW1haWxSZWdleCwgJ2VtYWlsJywgbWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnVybCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmluZW1lbnQoX19hc3NpZ24oeyBjaGVjazogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNvZGU6IFpvZEVycm9yXzEuWm9kRXJyb3JDb2RlLmludmFsaWRfc3RyaW5nLCB2YWxpZGF0aW9uOiAndXJsJyB9LCBlcnJvclV0aWxfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdXJsID0gKG1lc3NhZ2U/OiBlcnJvclV0aWwuRXJyTWVzc2FnZSkgPT4gdGhpcy5fcmVnZXgodXJsUmVnZXgsICd1cmwnLCBtZXNzYWdlKTtcbiAgICAgICAgX3RoaXMudXVpZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZ2V4KHV1aWRSZWdleCwgJ3V1aWQnLCBtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVnZXggPSBmdW5jdGlvbiAocmVnZXhwLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlZ2V4KHJlZ2V4cCwgJ3JlZ2V4JywgbWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm5vbmVtcHR5ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5taW4oMSwgZXJyb3JVdGlsXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBab2RTdHJpbmcucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKGxlbiwgbWVzc2FnZSkubWF4KGxlbiwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBab2RTdHJpbmcuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IHt9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RTdHJpbmc7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RTdHJpbmcgPSBab2RTdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZFR1cGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RUdXBsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RUdXBsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICB0OiBfdGhpcy5fZGVmLnQsXG4gICAgICAgICAgICBpdGVtczogX3RoaXMuX2RlZi5pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0udG9KU09OKCk7IH0pLFxuICAgICAgICB9KTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgIFpvZFR1cGxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzY2hlbWFzKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy50dXBsZSxcbiAgICAgICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RUdXBsZTtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZFR1cGxlID0gWm9kVHVwbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kVW5kZWZpbmVkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RVbmRlZmluZWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kVW5kZWZpbmVkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlZjsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBvcHQgb3B0aW9uYWw6ICgpID0+IFpvZFVuaW9uPFt0aGlzLCBab2RVbmRlZmluZWRdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kVW5kZWZpbmVkLmNyZWF0ZSgpXSk7XG4gICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgIFpvZFVuZGVmaW5lZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgICAgIHQ6IHouWm9kVHlwZXMudW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RVbmRlZmluZWQ7XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RVbmRlZmluZWQgPSBab2RVbmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmRlZmluZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZFVuaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab2RVbmlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RVbmlvbigpIHtcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgdDogX3RoaXMuX2RlZi50LFxuICAgICAgICAgICAgb3B0aW9uczogX3RoaXMuX2RlZi5vcHRpb25zLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b0pTT04oKTsgfSksXG4gICAgICAgIH0pOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIGRpc3RyaWJ1dGUgPSA8RiBleHRlbmRzIChhcmc6IFRbbnVtYmVyXSkgPT4gei5ab2RUeXBlQW55PihmOiBGKTogWm9kVW5pb248eyBbayBpbiBrZXlvZiBUXTogUmV0dXJuVHlwZTxGPiB9PiA9PiB7XG4gICAgLy8gICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKHRoaXMuX2RlZi5vcHRpb25zLm1hcChmKSBhcyBhbnkpO1xuICAgIC8vIH07XG4gICAgWm9kVW5pb24uY3JlYXRlID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy51bmlvbixcbiAgICAgICAgICAgIG9wdGlvbnM6IHR5cGVzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RVbmlvbjtcbn0oei5ab2RUeXBlKSk7XG5leHBvcnRzLlpvZFVuaW9uID0gWm9kVW5pb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSk7XG52YXIgWm9kVW5rbm93biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9kVW5rbm93biwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab2RVbmtub3duKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLy8gb3B0IG9wdGlvbmFsOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kVW5kZWZpbmVkXT4gPSAoKSA9PiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIFpvZFVuZGVmaW5lZC5jcmVhdGUoKV0pO1xuICAgICAgICAvLyBudWxsIG51bGxhYmxlOiAoKSA9PiBab2RVbmlvbjxbdGhpcywgWm9kTnVsbF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2ROdWxsLmNyZWF0ZSgpXSk7XG4gICAgICAgIF90aGlzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWY7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWm9kVW5rbm93bi5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgICAgICAgICB0OiB6LlpvZFR5cGVzLnVua25vd24sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFpvZFVua25vd247XG59KHouWm9kVHlwZSkpO1xuZXhwb3J0cy5ab2RVbmtub3duID0gWm9kVW5rbm93bjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVua25vd24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB6ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VcIikpO1xudmFyIFpvZFZvaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFpvZFZvaWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9kVm9pZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIG9wdCBvcHRpb25hbDogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZFVuZGVmaW5lZF0+ID0gKCkgPT4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBab2RVbmRlZmluZWQuY3JlYXRlKCldKTtcbiAgICAgICAgLy8gbnVsbCBudWxsYWJsZTogKCkgPT4gWm9kVW5pb248W3RoaXMsIFpvZE51bGxdPiA9ICgpID0+IFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgWm9kTnVsbC5jcmVhdGUoKV0pO1xuICAgICAgICBfdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFpvZFZvaWQuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICAgICAgdDogei5ab2RUeXBlcy52b2lkLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBab2RWb2lkO1xufSh6LlpvZFR5cGUpKTtcbmV4cG9ydHMuWm9kVm9pZCA9IFpvZFZvaWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12b2lkLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8ICByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGNvbmZpZy50cmFuc2l0aW9uYWwgJiYgY29uZmlnLnRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gJ0VUSU1FRE9VVCcgOiAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy92YWxpZGF0b3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJyksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJylcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQsXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQsIGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2NvcmUvZW5oYW5jZUVycm9yJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5U2FmZWx5KHJhd1ZhbHVlLCBwYXJzZXIsIGVuY29kZXIpIHtcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiB1dGlscy50cmltKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlbmNvZGVyIHx8IEpTT04uc3RyaW5naWZ5KShyYXdWYWx1ZSk7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHtcbiAgICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxuICB9LFxuXG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkgfHwgKGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPT09ICdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbDtcbiAgICB2YXIgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgdmFyIHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGVuaGFuY2VFcnJvcihlLCB0aGlzLCAnRV9KU09OX1BBUlNFJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JykgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBrZyA9IHJlcXVpcmUoJy4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaChmdW5jdGlvbih0eXBlLCBpKSB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG52YXIgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG52YXIgY3VycmVudFZlckFyciA9IHBrZy52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cbi8qKlxuICogQ29tcGFyZSBwYWNrYWdlIHZlcnNpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSB0aGFuVmVyc2lvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2xkZXJWZXJzaW9uKHZlcnNpb24sIHRoYW5WZXJzaW9uKSB7XG4gIHZhciBwa2dWZXJzaW9uQXJyID0gdGhhblZlcnNpb24gPyB0aGFuVmVyc2lvbi5zcGxpdCgnLicpIDogY3VycmVudFZlckFycjtcbiAgdmFyIGRlc3RWZXIgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPiBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPCBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICB2YXIgaXNEZXByZWNhdGVkID0gdmVyc2lvbiAmJiBpc09sZGVyVmVyc2lvbih2ZXJzaW9uKTtcblxuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgcGtnLnZlcnNpb24gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvcHQsIG9wdHMpIHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQgaW4gJyArIHZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZXByZWNhdGVkICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICB2YXIgb3B0ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09sZGVyVmVyc2lvbjogaXNPbGRlclZlcnNpb24sXG4gIGFzc2VydE9wdGlvbnM6IGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iLCJpbXBvcnQgeyBGcmFnbWVudCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUGFyYW1zIH0gZnJvbSBcInJlYWN0LXJvdXRlci1kb21cIjtcbmltcG9ydCBBdXRoQ29udGV4dCBmcm9tIFwiLi4vLi4vc3RvcmUvYXV0aC1jb250ZXh0XCI7XG5pbXBvcnQgV2FsbGV0Q29udGV4dCBmcm9tIFwiLi4vLi4vc3RvcmUvd2FsbGV0LWNvbnRleHRcIjtcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vdWkvTW9kYWxcIjtcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uL3VpL0J1dHRvblwiO1xuaW1wb3J0IHtcbiAgICBmZXRjaEVzY3Jvd3MsXG4gICAgZmlsbEVzY3JvdyxcbiAgICBjYW5jZWxFc2Nyb3csXG59IGZyb20gXCIuLi8uLi9zZGsvZWFzeWVzY3Jvd1NES1wiO1xuXG5jb25zdCBFeGNoYW5nZUFjdGlvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgZXNjcm93SWQsIHVzZXIxQWNjIH0gPSB1c2VQYXJhbXMoKTtcbiAgICBjb25zdCBjdHggPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcbiAgICBjb25zdCB3YWxsZXRDdHggPSB1c2VDb250ZXh0KFdhbGxldENvbnRleHQpO1xuICAgIGNvbnN0IFtjb25maXJtYXRpb25Qb3B1cCwgc2V0Q29uZmlybWF0aW9uUG9wdXBdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtyZXNwb25zZVR5cGUsIHNldFJlc3BvbnNlVHlwZV0gPSB1c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbbXlFc2Nyb3dzLCBzZXRNeUVzY3Jvd3NdID0gdXNlU3RhdGUoW10pO1xuXG4gICAgdXNlRWZmZWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5pc0xvZ2dlZEluKSB7XG4gICAgICAgICAgICBjb25zdCBlc2Nyb3dzID0gYXdhaXQgZmV0Y2hFc2Nyb3dzKHVzZXIxQWNjKTtcbiAgICAgICAgICAgIGNvbnN0IG15RXNjcm93c3MgPSBlc2Nyb3dzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAoZXNjcm93KSA9PlxuICAgICAgICAgICAgICAgICAgICBlc2Nyb3cuaWQudG9TdHJpbmcoKSA9PSBlc2Nyb3dJZCAmJlxuICAgICAgICAgICAgICAgICAgICBlc2Nyb3cudG8udG9TdHJpbmcoKSA9PSBjdHgud2FsbGV0TmFtZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKG15RXNjcm93c3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNldE15RXNjcm93cyhbLi4ubXlFc2Nyb3dzc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW215RXNjcm93cy5sZW5ndGgsIGN0eC5pc0xvZ2dlZEluXSk7XG4gICAgY29uc3QgaGFuZGxlQWNjZXB0ID0gKHJlc3BvbnNlX3R5cGUpID0+IHtcbiAgICAgICAgc2V0Q29uZmlybWF0aW9uUG9wdXAodHJ1ZSk7XG4gICAgICAgIHNldFJlc3BvbnNlVHlwZShyZXNwb25zZV90eXBlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlRXhjaGFuZ2VBY3Rpb24gPSBhc3luYyAocmVzcG9uc2VfdHlwZSkgPT4ge1xuICAgICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFjdG9yOiBjdHguYXV0aC5hY3RvcixcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uOiBjdHguYXV0aC5wZXJtaXNzaW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgdHlwZUlkID0gMTtcbiAgICAgICAgaWYgKHJlc3BvbnNlX3R5cGUgPT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICAgICAgYXdhaXQgZmlsbEVzY3JvdyhcbiAgICAgICAgICAgICAgICBteUVzY3Jvd3NbMF0uaWQsXG4gICAgICAgICAgICAgICAgdHlwZUlkLFxuICAgICAgICAgICAgICAgIGN0eC53YWxsZXROYW1lLFxuICAgICAgICAgICAgICAgIG15RXNjcm93c1swXS50b1Rva2Vuc1swXSxcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICAgIHdhbGxldEN0eC5zZXNzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2V0TXlFc2Nyb3dzKFtdKTtcbiAgICAgICAgICAgIC8vc3VjY2VzcyB0b2FzdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgY2FuY2VsRXNjcm93KFxuICAgICAgICAgICAgICAgIG15RXNjcm93c1swXS5pZCxcbiAgICAgICAgICAgICAgICBjdHgud2FsbGV0TmFtZSxcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICAgIHdhbGxldEN0eC5zZXNzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2V0TXlFc2Nyb3dzKFtdKTtcbiAgICAgICAgICAgIC8vY2FuY2VsIHRvYXN0XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q29uZmlybWF0aW9uUG9wdXAoZmFsc2UpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgLy8gZmV0Y2goYCR7cHJvY2Vzcy5lbnYuTUlYX0FQSV9VUkx9L3VzZXIvZXNjcm93X3Jlc3BvbnNlYCwge1xuICAgICAgICAvLyAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgLy8gICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgLy8gICAgICAgICB0eXBlX2lkOiBwcm9wcy50eXBlX2lkLFxuICAgICAgICAvLyAgICAgICAgIGVzY3Jvd19pZDogcHJvcHMuZXNjcm93X2lkLFxuICAgICAgICAvLyAgICAgICAgIHN0YXR1czogcmVzcG9uc2VfdHlwZSxcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyAgICAgICAgIEF1dGhvcml6YXRpb246IFwiQmVhcmVyIFwiICsgY3R4LnRva2VuLFxuICAgICAgICAvLyAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gfSlcbiAgICAgICAgLy8gICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAvLyAgICAgICAgIGlmIChyZXNwb25zZS5vaykgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgLy8gICAgICAgICB0aHJvdyByZXNwb25zZS5zdGF0dXMgKyBcIjogXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgLy8gICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgLy8gICAgICAgICBpZiAoZGF0YS52YWxpZCkge1xuICAgICAgICAvLyAgICAgICAgICAgICBwcm9wcy5yZWxvYWRUcmFuc2FjdGlvbnMocHJvcHMuZXNjcm93X2lkKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgc2V0Q29uZmlybWF0aW9uUG9wdXAoZmFsc2UpO1xuICAgICAgICAvLyAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEubWVzc2FnZSk7XG4gICAgICAgIC8vICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIC8vICAgICB9KVxuICAgICAgICAvLyAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgLy8gICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8bWFpbj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIGJhbm5lci1pbm5lclwiPlxuICAgICAgICAgICAgICAgIDxoMj5UcmFuc2FjdGlvbiBEZXRhaWxzPC9oMj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgYmxvY2tcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRyYW5zYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgICB7Y3R4LmlzTG9nZ2VkSW4gJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPEZyYWdtZW50PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtteUVzY3Jvd3MubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0cmFuc2FjdGlvbi1kZXRhaWxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bXlFc2Nyb3dzWzBdLmZyb219IHdhbnRzIHRvIGV4Y2hhbmdle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtteUVzY3Jvd3NbMF0uZnJvbVRva2Vuc1swXS5xdWFudGl0eX17XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB7bXlFc2Nyb3dzWzBdLnRvVG9rZW5zWzBdLnF1YW50aXR5fXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHlvdShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y3R4LndhbGxldE5hbWV9KSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidHJhbnNhY3Rpb24tYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkFjY2VwdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4tYWNjZXB0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQWNjZXB0KFwiY29tcGxldGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkNhbmNlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gYnRuLWNhbmNlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUFjY2VwdChcImNhbmNlbGxlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29uZmlybWF0aW9uUG9wdXAgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNb2RhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlUG9wdXA9eygpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb25maXJtYXRpb25Qb3B1cChmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3J5cHRvIEV4Y2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZXNwb25zZVR5cGUgPT09IFwiY29tcGxldGVkXCIgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgeW91IGFncmVlIHRvIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNoYW5nZSwgcGxlYXNlIEFDQ0VQVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVzcG9uc2VUeXBlID09PSBcImNhbmNlbGxlZFwiICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHlvdSBkbyBOT1QgYWdyZWUsIGhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgYnV0dG9uIHRvIENBTkNFTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGU6IFRoaXMgYWN0aW9uIGNhbiBub3QgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1yb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZXNwb25zZVR5cGUgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21wbGV0ZWRcIiAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1cIkFjY2VwdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0bi1hY2NlcHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXhjaGFuZ2VBY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21wbGV0ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc9e2xvYWRpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVzcG9uc2VUeXBlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FuY2VsbGVkXCIgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9XCJDYW5jZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4tY2FuY2VsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUV4Y2hhbmdlQWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FuY2VsbGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L01vZGFsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bXlFc2Nyb3dzLmxlbmd0aCA9PSAwICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0cmFuc2FjdGlvbi1lbXB0eVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlcmUgaXMgbm8gZXNjcm93IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIHshY3R4LmlzTG9nZ2VkSW4gJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0cmFuc2FjdGlvbi1lbXB0eVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBZb3UgbXVzdCBsb2dpbiB0byBjb250aW51ZS4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vd3d3LnByb3Rvbi5vcmcvd2FsbGV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERvd25sb2FkIFByb3RvbiBXYWxsZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvKiA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiTG9naW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4tYWNjZXB0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17YXN5bmMgKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhbGxldEN0eC5wcm90b25Db25uZWN0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+ICovfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9tYWluPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFeGNoYW5nZUFjdGlvbjtcbiIsIi8vVXNlIEFQSSB0byBzYXZlIHRyYW5zYWN0aW9uIGRldGFpbHNcbmltcG9ydCB7IEFwaUNsYXNzIH0gZnJvbSBcIkBwcm90b24vYXBpXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgeyBjdXJyZW50X25ldHdvcmsgfSBmcm9tIFwiLi4vY29uc3RhbnRzL25ldHdvcmtzLmpzXCI7XG5pbXBvcnQgeyB0cmFuc2FjdCB9IGZyb20gXCIuL3Byb3RvbkFQSS5qc1wiO1xuXG5jb25zdCBhcGkgPSBuZXcgQXBpQ2xhc3MoY3VycmVudF9uZXR3b3JrLmNoYWluKTtcbmNvbnN0IGNvbnRyYWN0ID0gXCJlYXN5ZXNjcm93MlwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hFc2Nyb3dBbGwoKSB7XG4gICAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBhcGkucnBjLmdldF90YWJsZV9yb3dzKHtcbiAgICAgICAgY29kZTogY29udHJhY3QsXG4gICAgICAgIHNjb3BlOiBjb250cmFjdCxcbiAgICAgICAgdGFibGU6IFwiZXNjcm93c1wiLFxuICAgICAgICBpbmRleF9wb3NpdGlvbjogMixcbiAgICAgICAga2V5X3R5cGU6IFwiaTY0XCIsXG4gICAgICAgIGxpbWl0OiAtMSxcbiAgICB9KTtcbiAgICByZXR1cm4gcm93cztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoRXNjcm93cyhhY2NvdW50TmFtZSkge1xuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgYXBpLnJwYy5nZXRfdGFibGVfcm93cyh7XG4gICAgICAgIGNvZGU6IGNvbnRyYWN0LFxuICAgICAgICBzY29wZTogY29udHJhY3QsXG4gICAgICAgIHRhYmxlOiBcImVzY3Jvd3NcIixcbiAgICAgICAgaW5kZXhfcG9zaXRpb246IDIsXG4gICAgICAgIGtleV90eXBlOiBcImk2NFwiLFxuICAgICAgICBsb3dlcl9ib3VuZDogYWNjb3VudE5hbWUsXG4gICAgICAgIHVwcGVyX2JvdW5kOiBhY2NvdW50TmFtZSxcbiAgICAgICAgbGltaXQ6IC0xLFxuICAgIH0pO1xuICAgIHJldHVybiByb3dzO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0RXNjcm93KFxuICAgIHR5cGVJZCxcbiAgICBmcm9tLFxuICAgIHRvLFxuICAgIGZyb21Ub2tlbixcbiAgICB0b1Rva2VuLFxuICAgIGZyb21BbW91bnQsXG4gICAgdG9BbW91bnQsXG4gICAgZGVsaXZlclR5cGUsXG4gICAgZXhwaXJ5LFxuICAgIGF1dGhvcml6YXRpb24sXG4gICAgc2Vzc2lvblxuKSB7XG4gICAgY29uc3QgYW1vdW50SW4gPSBwYXJzZUZsb2F0KGZyb21BbW91bnQpXG4gICAgICAgIC50b0ZpeGVkKE51bWJlcihmcm9tVG9rZW4uZGVjaW1hbHMpKVxuICAgICAgICAudG9TdHJpbmcoKTtcbiAgICBjb25zdCBmcm9tUXVhbnRpdHkgPSBhbW91bnRJbiArIFwiIFwiICsgZnJvbVRva2VuLmN1cnJlbmN5O1xuICAgIGxldCBhY3Rpb25zID0gW107XG4gICAgaWYgKHR5cGVJZCA9PSAxKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudE91dCA9IHBhcnNlRmxvYXQodG9BbW91bnQpXG4gICAgICAgICAgICAudG9GaXhlZChOdW1iZXIodG9Ub2tlbi5kZWNpbWFscykpXG4gICAgICAgICAgICAudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgdG9RdWFudGl0eSA9IGFtb3VudE91dCArIFwiIFwiICsgdG9Ub2tlbi5jdXJyZW5jeTtcbiAgICAgICAgYWN0aW9ucyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBmcm9tVG9rZW4uY29udHJhY3QsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0cmFuc2ZlclwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG86IGNvbnRyYWN0LFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZnJvbVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICBtZW1vOiBcIlVzZXIxIGRlcG9zaXQgZm9yIGVzY3Jvd1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogY29udHJhY3QsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydGVzY3Jvd1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUlkOiB0eXBlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbVRva2VuczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBmcm9tVG9rZW4uY29udHJhY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGZyb21RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGZyb21OZnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdG9Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdDogdG9Ub2tlbi5jb250cmFjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogdG9RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIHRvTmZ0czogW10sXG4gICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJUeXBlOiBkZWxpdmVyVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJ5OiBleHBpcnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVJZCA9PSAyKSB7XG4gICAgICAgIGFjdGlvbnMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogZnJvbVRva2VuLmNvbnRyYWN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiBjb250cmFjdCxcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGZyb21RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgbWVtbzogXCJVc2VyMSBkZXBvc2l0IGZvciBhIGdpZnRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFjY291bnQ6IGNvbnRyYWN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRlc2Nyb3dcIixcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZDogdHlwZUlkLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICAgICAgICAgIGZyb21Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdDogZnJvbVRva2VuLmNvbnRyYWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBmcm9tUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBmcm9tTmZ0czogW10sXG4gICAgICAgICAgICAgICAgICAgIHRvVG9rZW5zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdG9OZnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZGVsaXZlclR5cGU6IGRlbGl2ZXJUeXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBpcnk6IE1hdGguZmxvb3IoZXhwaXJ5IC8gMTAwMCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVJZCA9PSAzIHx8IHR5cGVJZCA9PSA0KSB7XG4gICAgICAgIGxldCBtZW1vID0gXCJVc2VyMSBkZXBvc2l0ZWQgZm9yIFB1cmNoYXNlIEl0ZW0hXCI7XG4gICAgICAgIGlmICh0eXBlSWQgPT0gNCkge1xuICAgICAgICAgICAgbWVtbyA9IFwiVXNlcjEgZGVwb3NpdGVkIGZvciBQdXJjaGFzZSBTZXJ2aWNlIVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vaW4gdGhpcyBjYXNlIG9ubHkgc3RvcmUgdG8gcHJvdG9uIGRiLiBub3Qgc2VuZCBjb2luXG4gICAgICAgIGFjdGlvbnMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogY29udHJhY3QsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydGVzY3Jvd1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUlkOiB0eXBlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbVRva2VuczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0OiBmcm9tVG9rZW4uY29udHJhY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGZyb21RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGZyb21OZnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdG9Ub2tlbnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB0b05mdHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBkZWxpdmVyVHlwZTogZGVsaXZlclR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyeTogZXhwaXJ5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXdhaXQgc2Vzc2lvbi50cmFuc2FjdCh7XG4gICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmlsbEVzY3JvdyhcbiAgICBlc2Nyb3dJZCxcbiAgICB0eXBlSWQsXG4gICAgYWN0b3IsXG4gICAgdG9Ub2tlbixcbiAgICBhdXRob3JpemF0aW9uLFxuICAgIHNlc3Npb25cbikge1xuICAgIGxldCBhY3Rpb25zID0gW107XG4gICAgaWYgKHR5cGVJZCA9PSAxKSB7XG4gICAgICAgIGFjdGlvbnMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogdG9Ub2tlbi5jb250cmFjdCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRyYW5zZmVyXCIsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgdG86IGNvbnRyYWN0LFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogdG9Ub2tlbi5xdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgbWVtbzogXCJVc2VyMiBkZXBvc2l0IGZvciBlc2Nyb3dcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFjY291bnQ6IGNvbnRyYWN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZmlsbGVzY3Jvd1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0b3I6IGFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBpZDogZXNjcm93SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAodHlwZUlkID09IDIpIHtcbiAgICAgICAgY29uc3QgY29udHJhY3RhdXRoID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFjdG9yOiBjb250cmFjdCxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uOiBcImFjdGl2ZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgYWN0aW9ucyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBjb250cmFjdCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcImZpbGxlc2Nyb3dcIixcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdG9yOiBhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGVzY3Jvd0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBjb250cmFjdGF1dGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHJhbnNhY3QoYWN0aW9ucyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlc3VsdFwiLCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBoZXJlPz9cIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlSWQgPT0gMyB8fCB0eXBlSWQgPT0gNCkge1xuICAgICAgICBhY3Rpb25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFjY291bnQ6IGNvbnRyYWN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZmlsbGVzY3Jvd1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0b3I6IGFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBpZDogZXNjcm93SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBpZiAodHlwZUlkICE9IDIpIHtcbiAgICAgICAgYXdhaXQgc2Vzc2lvbi50cmFuc2FjdCh7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FuY2VsRXNjcm93KGVzY3Jvd0lkLCBhY3RvciwgYXV0aG9yaXphdGlvbiwgc2Vzc2lvbikge1xuICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnQ6IGNvbnRyYWN0LFxuICAgICAgICAgICAgbmFtZTogXCJjYW5jZWxlc2Nyb3dcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBhY3RvcjogYWN0b3IsXG4gICAgICAgICAgICAgICAgaWQ6IGVzY3Jvd0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcbiAgICAgICAgfSxcbiAgICBdO1xuICAgIGF3YWl0IHNlc3Npb24udHJhbnNhY3Qoe1xuICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UHVyY2hhc2UoZnJvbSwgdG9rZW4sIGF1dGhvcml6YXRpb24sIHNlc3Npb24pIHtcbiAgICBjb25zdCBhY3Rpb25zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBhY2NvdW50OiB0b2tlbi5jb250cmFjdCxcbiAgICAgICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBjb250cmFjdCxcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogdG9rZW4ucXVhbnRpdHksXG4gICAgICAgICAgICAgICAgbWVtbzogXCJVc2VyMiBkZXBvc2l0IGZvciBlc2Nyb3dcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uLFxuICAgICAgICB9LFxuICAgIF07XG4gICAgYXdhaXQgc2Vzc2lvbi50cmFuc2FjdCh7XG4gICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmVnb1B1cmNoYXNlKFxuICAgIGVzY3Jvd0lkLFxuICAgIHR5cGVJZCxcbiAgICBmcm9tLFxuICAgIHRvLFxuICAgIGZyb21Ub2tlbixcbiAgICB0b1Rva2VuLFxuICAgIGZyb21BbW91bnQsXG4gICAgdG9BbW91bnQsXG4gICAgZGVsaXZlclR5cGUsXG4gICAgZXhwaXJ5LFxuICAgIGF1dGhvcml6YXRpb24sXG4gICAgc2Vzc2lvblxuKSB7XG4gICAgY29uc3QgYW1vdW50SW4gPSBwYXJzZUZsb2F0KGZyb21BbW91bnQpXG4gICAgICAgIC50b0ZpeGVkKE51bWJlcihmcm9tVG9rZW4uZGVjaW1hbHMpKVxuICAgICAgICAudG9TdHJpbmcoKTtcbiAgICBjb25zdCBmcm9tUXVhbnRpdHkgPSBhbW91bnRJbiArIFwiIFwiICsgZnJvbVRva2VuLmN1cnJlbmN5O1xuICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnQ6IGNvbnRyYWN0LFxuICAgICAgICAgICAgbmFtZTogXCJuZWdvcHVyY2hhc2VcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2Nyb3dJZDogZXNjcm93SWQsXG4gICAgICAgICAgICAgICAgdHlwZUlkOiB0eXBlSWQsXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICAgICAgZnJvbVRva2VuczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdDogZnJvbVRva2VuLmNvbnRyYWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGZyb21RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGZyb21OZnRzOiBbXSxcbiAgICAgICAgICAgICAgICB0b1Rva2VuczogW10sXG4gICAgICAgICAgICAgICAgdG9OZnRzOiBbXSxcbiAgICAgICAgICAgICAgICBkZWxpdmVyVHlwZTogZGVsaXZlclR5cGUsXG4gICAgICAgICAgICAgICAgZXhwaXJ5OiBleHBpcnksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbixcbiAgICAgICAgfSxcbiAgICBdO1xuICAgIGF3YWl0IHNlc3Npb24udHJhbnNhY3Qoe1xuICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuY29uc3QgdGFibGVyb3dzID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHByb3RvbnJvd3MgPSBhd2FpdCBmZXRjaEVzY3Jvd0FsbCgpO1xuICAgIGNvbnNvbGUubG9nKHByb3RvbnJvd3MpO1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm90b25yb3dzKS5sZW5ndGggIT0gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBwcm90b25yb3dzKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdkYXRldGVubWludXRlcyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gbmV3ZGF0ZXRlbm1pbnV0ZXMuZ2V0TWludXRlcygpIC0gMTA7XG4gICAgICAgICAgICBuZXdkYXRldGVubWludXRlcy5zZXRNaW51dGVzKGRpZmZlcmVuY2UpO1xuXG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBvYmouZXhwaXJ5ICogMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xuXG4gICAgICAgICAgICBpZiAoZGF0ZSA+IG5ld2RhdGV0ZW5taW51dGVzICYmIGRhdGUgPD0gbmV3IERhdGUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY3VycmVudCBkYXRlXCIsIG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FsbGluZyBmaWxsIGdpZnQgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJydW5uaW5nIGVzY3Jvd1wiLCBvYmouaWQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicnVubmluZyBlc2Nyb3cgZGF0ZVwiLCBkYXRlKTtcblxuICAgICAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdpZnRyZXNwb25zZWNhbGwoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdpZnRyZXNwb25zZSA9IGF3YWl0IGZpbGxFc2Nyb3coXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdpZnRyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2Nyb3dfaWQ6IG9iai5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlX2lkOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhcyA9IEpTT04uc3RyaW5naWZ5KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlvcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cHM6Ly9lYXN5ZXNjcm93LmlvL2FwaS91c2VyL2dpZnQtdXBkYXRlLXN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLmRhdGEucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhnaWZ0cmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdpZnRyZXNwb25zZWNhbGwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJza2lwIGVzY3Jvd1wiLCBvYmouaWQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2tpcCBlc2Nyb3cgZGF0ZVwiLCBkYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImN1cnJlbnQgZGF0ZVwiLCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibm8gcm93cyBmb3VuZFwiKTtcbiAgICB9XG59O1xudGFibGVyb3dzKCk7XG5cbi8vIGNvbnN0IGhpc3RvcnkgPSBhd2FpdCBhcGkuZ2V0QWN0aW9uc0Zyb21IeXBlcmlvbihjdHguYXV0aC5hY3Rvciwge1xuLy8gICAgIGxpbWl0OiAxMCxcbi8vICAgICBza2lwOiAwLFxuLy8gICAgIHNvcnQ6IFwiZGVzY1wiLFxuLy8gICAgIGZpbHRlcjogY29udHJhY3QqXCIsXG4vLyB9KTtcblxuLy8gY29uc29sZS5sb2coXCJIaXN0b3J5XCIsIGhpc3RvcnkpO1xuIiwiaW1wb3J0IHsgSnNvblJwYywgQXBpLCBKc1NpZ25hdHVyZVByb3ZpZGVyIH0gZnJvbSBcIkBwcm90b24vanNcIjtcbmltcG9ydCBmZXRjaCBmcm9tIFwibm9kZS1mZXRjaFwiO1xuaW1wb3J0IHsgY3VycmVudF9uZXR3b3JrIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9uZXR3b3Jrc1wiO1xuXG5leHBvcnQgY29uc3QgcnBjID0gbmV3IEpzb25ScGMoW2N1cnJlbnRfbmV0d29yay5lbmRwb2ludF0sIHsgZmV0Y2g6IGZldGNoIH0pO1xuZXhwb3J0IGNvbnN0IGFwaSA9IG5ldyBBcGkoe1xuICAgIHJwYyxcbiAgICBzaWduYXR1cmVQcm92aWRlcjogbmV3IEpzU2lnbmF0dXJlUHJvdmlkZXIoW1xuICAgICAgICBcIlBWVF9LMV8yU2czamRiZ0FmYzhmSmN0Mk1WSHBValJXSnZ0RGhpdHhENXA1OXdhclhTUXJYWFdBM1wiLFxuICAgIF0pLFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2FjdChhY3Rpb25zKSB7XG4gICAgY29uc29sZS5sb2coXCJjb21lIGhlcmUsIHRoZW4gd2h5P1wiKTtcbiAgICBhcGkudHJhbnNhY3QoXG4gICAgICAgIHsgYWN0aW9ucyB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBibG9ja3NCZWhpbmQ6IDMwMCxcbiAgICAgICAgICAgIGV4cGlyZVNlY29uZHM6IDMwMDAsXG4gICAgICAgIH1cbiAgICApO1xufVxuIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG4iLCI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4wLjJcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMSBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IDIgLSBpc09kZChuKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgICBpZiAobSkge1xyXG5cclxuICAgICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAgICovXHJcbiAgICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoeExUeSkgdCA9IHhjLCB4YyA9IHljLCB5YyA9IHQsIHkucyA9IC15LnM7XHJcblxyXG4gICAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgeGNbal0gKz0gQkFTRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgICAvLyBmb3IgZmluaXRlIHggYW5kIHkuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgIG4gJSAwID0gIE5cclxuICAgICAqICAgbiAlIE4gPSAgTlxyXG4gICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgKiAgIDAgJSBuID0gIDBcclxuICAgICAqICAtMCAlIG4gPSAtMFxyXG4gICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgKiAgIDAgJSBOID0gIE5cclxuICAgICAqICAgMCAlIEkgPSAgMFxyXG4gICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgKiAgIE4gJSAwID0gIE5cclxuICAgICAqICAgTiAlIE4gPSAgTlxyXG4gICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgKiAgIEkgJSBuID0gIE5cclxuICAgICAqICAgSSAlIDAgPSAgTlxyXG4gICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgKiAgIEkgJSBJID0gIE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgcSwgcyxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICAgIHMgPSB5LnM7XHJcbiAgICAgICAgeS5zID0gMTtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgcS5zICo9IHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICAgIGlmICgheS5jWzBdICYmIE1PRFVMT19NT0RFID09IDEpIHkucyA9IHgucztcclxuXHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICogMCA9IDBcclxuICAgICAqICBuICogTiA9IE5cclxuICAgICAqICBuICogSSA9IElcclxuICAgICAqICAwICogbiA9IDBcclxuICAgICAqICAwICogMCA9IDBcclxuICAgICAqICAwICogTiA9IE5cclxuICAgICAqICAwICogSSA9IE5cclxuICAgICAqICBOICogbiA9IE5cclxuICAgICAqICBOICogMCA9IE5cclxuICAgICAqICBOICogTiA9IE5cclxuICAgICAqICBOICogSSA9IE5cclxuICAgICAqICBJICogbiA9IElcclxuICAgICAqICBJICogMCA9IE5cclxuICAgICAqICBJICogTiA9IE5cclxuICAgICAqICBJICogSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgaWYgKCF4YyB8fCAheWMgfHwgIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICB5LnMgKj0geC5zO1xyXG4gICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgaWYgKHhjTCA8IHljTCkgemMgPSB4YywgeGMgPSB5YywgeWMgPSB6YywgaSA9IHhjTCwgeGNMID0geWNMLCB5Y0wgPSBpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgZm9yICg7IDspICB7XHJcbiAgICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgICBuID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICogbmVnYXRpdmUgemVyby5cclxuICAgICAqL1xyXG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICAgIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4gIC8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbiAgLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gICAgdmFyIGkgPSBuIHwgMDtcclxuICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG4gIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgdmFyIHMsIHosXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBqID0gYS5sZW5ndGgsXHJcbiAgICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gICAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICAgIHIgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gICAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gICAgdmFyIGEsIGIsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYyxcclxuICAgICAgaSA9IHgucyxcclxuICAgICAgaiA9IHkucyxcclxuICAgICAgayA9IHguZSxcclxuICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gICAgYSA9IGkgPCAwO1xyXG4gICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICAgIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICAgIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICAgIHZhciBsZW4sIHpzO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgICAgc3RyICs9IHpzO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0pO1xyXG5cclxuICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsT2JqZWN0KSB7XHJcbiAgICAgIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbE9iamVjdC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqcz1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9MWUzLGU9NmU0LG49MzZlNSxyPVwibWlsbGlzZWNvbmRcIixpPVwic2Vjb25kXCIscz1cIm1pbnV0ZVwiLHU9XCJob3VyXCIsYT1cImRheVwiLG89XCJ3ZWVrXCIsZj1cIm1vbnRoXCIsaD1cInF1YXJ0ZXJcIixjPVwieWVhclwiLGQ9XCJkYXRlXCIsJD1cIkludmFsaWQgRGF0ZVwiLGw9L14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbVHRcXHNdKihcXGR7MSwyfSk/Oj8oXFxkezEsMn0pPzo/KFxcZHsxLDJ9KT9bLjpdPyhcXGQrKT8kLyx5PS9cXFsoW15cXF1dKyldfFl7MSw0fXxNezEsNH18RHsxLDJ9fGR7MSw0fXxIezEsMn18aHsxLDJ9fGF8QXxtezEsMn18c3sxLDJ9fFp7MSwyfXxTU1MvZyxNPXtuYW1lOlwiZW5cIix3ZWVrZGF5czpcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLG1vbnRoczpcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIil9LG09ZnVuY3Rpb24odCxlLG4pe3ZhciByPVN0cmluZyh0KTtyZXR1cm4hcnx8ci5sZW5ndGg+PWU/dDpcIlwiK0FycmF5KGUrMS1yLmxlbmd0aCkuam9pbihuKSt0fSxnPXtzOm0sejpmdW5jdGlvbih0KXt2YXIgZT0tdC51dGNPZmZzZXQoKSxuPU1hdGguYWJzKGUpLHI9TWF0aC5mbG9vcihuLzYwKSxpPW4lNjA7cmV0dXJuKGU8PTA/XCIrXCI6XCItXCIpK20ociwyLFwiMFwiKStcIjpcIittKGksMixcIjBcIil9LG06ZnVuY3Rpb24gdChlLG4pe2lmKGUuZGF0ZSgpPG4uZGF0ZSgpKXJldHVybi10KG4sZSk7dmFyIHI9MTIqKG4ueWVhcigpLWUueWVhcigpKSsobi5tb250aCgpLWUubW9udGgoKSksaT1lLmNsb25lKCkuYWRkKHIsZikscz1uLWk8MCx1PWUuY2xvbmUoKS5hZGQocisocz8tMToxKSxmKTtyZXR1cm4rKC0ocisobi1pKS8ocz9pLXU6dS1pKSl8fDApfSxhOmZ1bmN0aW9uKHQpe3JldHVybiB0PDA/TWF0aC5jZWlsKHQpfHwwOk1hdGguZmxvb3IodCl9LHA6ZnVuY3Rpb24odCl7cmV0dXJue006Zix5OmMsdzpvLGQ6YSxEOmQsaDp1LG06cyxzOmksbXM6cixROmh9W3RdfHxTdHJpbmcodHx8XCJcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9zJC8sXCJcIil9LHU6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR9fSx2PVwiZW5cIixEPXt9O0Rbdl09TTt2YXIgcD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIF99LFM9ZnVuY3Rpb24gdChlLG4scil7dmFyIGk7aWYoIWUpcmV0dXJuIHY7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBzPWUudG9Mb3dlckNhc2UoKTtEW3NdJiYoaT1zKSxuJiYoRFtzXT1uLGk9cyk7dmFyIHU9ZS5zcGxpdChcIi1cIik7aWYoIWkmJnUubGVuZ3RoPjEpcmV0dXJuIHQodVswXSl9ZWxzZXt2YXIgYT1lLm5hbWU7RFthXT1lLGk9YX1yZXR1cm4hciYmaSYmKHY9aSksaXx8IXImJnZ9LHc9ZnVuY3Rpb24odCxlKXtpZihwKHQpKXJldHVybiB0LmNsb25lKCk7dmFyIG49XCJvYmplY3RcIj09dHlwZW9mIGU/ZTp7fTtyZXR1cm4gbi5kYXRlPXQsbi5hcmdzPWFyZ3VtZW50cyxuZXcgXyhuKX0sTz1nO08ubD1TLE8uaT1wLE8udz1mdW5jdGlvbih0LGUpe3JldHVybiB3KHQse2xvY2FsZTplLiRMLHV0YzplLiR1LHg6ZS4keCwkb2Zmc2V0OmUuJG9mZnNldH0pfTt2YXIgXz1mdW5jdGlvbigpe2Z1bmN0aW9uIE0odCl7dGhpcy4kTD1TKHQubG9jYWxlLG51bGwsITApLHRoaXMucGFyc2UodCl9dmFyIG09TS5wcm90b3R5cGU7cmV0dXJuIG0ucGFyc2U9ZnVuY3Rpb24odCl7dGhpcy4kZD1mdW5jdGlvbih0KXt2YXIgZT10LmRhdGUsbj10LnV0YztpZihudWxsPT09ZSlyZXR1cm4gbmV3IERhdGUoTmFOKTtpZihPLnUoZSkpcmV0dXJuIG5ldyBEYXRlO2lmKGUgaW5zdGFuY2VvZiBEYXRlKXJldHVybiBuZXcgRGF0ZShlKTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmIS9aJC9pLnRlc3QoZSkpe3ZhciByPWUubWF0Y2gobCk7aWYocil7dmFyIGk9clsyXS0xfHwwLHM9KHJbN118fFwiMFwiKS5zdWJzdHJpbmcoMCwzKTtyZXR1cm4gbj9uZXcgRGF0ZShEYXRlLlVUQyhyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKSk6bmV3IERhdGUoclsxXSxpLHJbM118fDEscls0XXx8MCxyWzVdfHwwLHJbNl18fDAscyl9fXJldHVybiBuZXcgRGF0ZShlKX0odCksdGhpcy4keD10Lnh8fHt9LHRoaXMuaW5pdCgpfSxtLmluaXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLiRkO3RoaXMuJHk9dC5nZXRGdWxsWWVhcigpLHRoaXMuJE09dC5nZXRNb250aCgpLHRoaXMuJEQ9dC5nZXREYXRlKCksdGhpcy4kVz10LmdldERheSgpLHRoaXMuJEg9dC5nZXRIb3VycygpLHRoaXMuJG09dC5nZXRNaW51dGVzKCksdGhpcy4kcz10LmdldFNlY29uZHMoKSx0aGlzLiRtcz10LmdldE1pbGxpc2Vjb25kcygpfSxtLiR1dGlscz1mdW5jdGlvbigpe3JldHVybiBPfSxtLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4hKHRoaXMuJGQudG9TdHJpbmcoKT09PSQpfSxtLmlzU2FtZT1mdW5jdGlvbih0LGUpe3ZhciBuPXcodCk7cmV0dXJuIHRoaXMuc3RhcnRPZihlKTw9biYmbjw9dGhpcy5lbmRPZihlKX0sbS5pc0FmdGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCk8dGhpcy5zdGFydE9mKGUpfSxtLmlzQmVmb3JlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5kT2YoZSk8dyh0KX0sbS4kZz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE8udSh0KT90aGlzW2VdOnRoaXMuc2V0KG4sdCl9LG0udW5peD1mdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpLzFlMyl9LG0udmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLmdldFRpbWUoKX0sbS5zdGFydE9mPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcyxyPSEhTy51KGUpfHxlLGg9Ty5wKHQpLCQ9ZnVuY3Rpb24odCxlKXt2YXIgaT1PLncobi4kdT9EYXRlLlVUQyhuLiR5LGUsdCk6bmV3IERhdGUobi4keSxlLHQpLG4pO3JldHVybiByP2k6aS5lbmRPZihhKX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiBPLncobi50b0RhdGUoKVt0XS5hcHBseShuLnRvRGF0ZShcInNcIiksKHI/WzAsMCwwLDBdOlsyMyw1OSw1OSw5OTldKS5zbGljZShlKSksbil9LHk9dGhpcy4kVyxNPXRoaXMuJE0sbT10aGlzLiRELGc9XCJzZXRcIisodGhpcy4kdT9cIlVUQ1wiOlwiXCIpO3N3aXRjaChoKXtjYXNlIGM6cmV0dXJuIHI/JCgxLDApOiQoMzEsMTEpO2Nhc2UgZjpyZXR1cm4gcj8kKDEsTSk6JCgwLE0rMSk7Y2FzZSBvOnZhciB2PXRoaXMuJGxvY2FsZSgpLndlZWtTdGFydHx8MCxEPSh5PHY/eSs3OnkpLXY7cmV0dXJuICQocj9tLUQ6bSsoNi1EKSxNKTtjYXNlIGE6Y2FzZSBkOnJldHVybiBsKGcrXCJIb3Vyc1wiLDApO2Nhc2UgdTpyZXR1cm4gbChnK1wiTWludXRlc1wiLDEpO2Nhc2UgczpyZXR1cm4gbChnK1wiU2Vjb25kc1wiLDIpO2Nhc2UgaTpyZXR1cm4gbChnK1wiTWlsbGlzZWNvbmRzXCIsMyk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5jbG9uZSgpfX0sbS5lbmRPZj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGFydE9mKHQsITEpfSxtLiRzZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbixvPU8ucCh0KSxoPVwic2V0XCIrKHRoaXMuJHU/XCJVVENcIjpcIlwiKSwkPShuPXt9LG5bYV09aCtcIkRhdGVcIixuW2RdPWgrXCJEYXRlXCIsbltmXT1oK1wiTW9udGhcIixuW2NdPWgrXCJGdWxsWWVhclwiLG5bdV09aCtcIkhvdXJzXCIsbltzXT1oK1wiTWludXRlc1wiLG5baV09aCtcIlNlY29uZHNcIixuW3JdPWgrXCJNaWxsaXNlY29uZHNcIixuKVtvXSxsPW89PT1hP3RoaXMuJEQrKGUtdGhpcy4kVyk6ZTtpZihvPT09Znx8bz09PWMpe3ZhciB5PXRoaXMuY2xvbmUoKS5zZXQoZCwxKTt5LiRkWyRdKGwpLHkuaW5pdCgpLHRoaXMuJGQ9eS5zZXQoZCxNYXRoLm1pbih0aGlzLiRELHkuZGF5c0luTW9udGgoKSkpLiRkfWVsc2UgJCYmdGhpcy4kZFskXShsKTtyZXR1cm4gdGhpcy5pbml0KCksdGhpc30sbS5zZXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jbG9uZSgpLiRzZXQodCxlKX0sbS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXNbTy5wKHQpXSgpfSxtLmFkZD1mdW5jdGlvbihyLGgpe3ZhciBkLCQ9dGhpcztyPU51bWJlcihyKTt2YXIgbD1PLnAoaCkseT1mdW5jdGlvbih0KXt2YXIgZT13KCQpO3JldHVybiBPLncoZS5kYXRlKGUuZGF0ZSgpK01hdGgucm91bmQodCpyKSksJCl9O2lmKGw9PT1mKXJldHVybiB0aGlzLnNldChmLHRoaXMuJE0rcik7aWYobD09PWMpcmV0dXJuIHRoaXMuc2V0KGMsdGhpcy4keStyKTtpZihsPT09YSlyZXR1cm4geSgxKTtpZihsPT09bylyZXR1cm4geSg3KTt2YXIgTT0oZD17fSxkW3NdPWUsZFt1XT1uLGRbaV09dCxkKVtsXXx8MSxtPXRoaXMuJGQuZ2V0VGltZSgpK3IqTTtyZXR1cm4gTy53KG0sdGhpcyl9LG0uc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hZGQoLTEqdCxlKX0sbS5mb3JtYXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXRoaXMuJGxvY2FsZSgpO2lmKCF0aGlzLmlzVmFsaWQoKSlyZXR1cm4gbi5pbnZhbGlkRGF0ZXx8JDt2YXIgcj10fHxcIllZWVktTU0tRERUSEg6bW06c3NaXCIsaT1PLnoodGhpcykscz10aGlzLiRILHU9dGhpcy4kbSxhPXRoaXMuJE0sbz1uLndlZWtkYXlzLGY9bi5tb250aHMsaD1mdW5jdGlvbih0LG4saSxzKXtyZXR1cm4gdCYmKHRbbl18fHQoZSxyKSl8fGlbbl0uc2xpY2UoMCxzKX0sYz1mdW5jdGlvbih0KXtyZXR1cm4gTy5zKHMlMTJ8fDEyLHQsXCIwXCIpfSxkPW4ubWVyaWRpZW18fGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10PDEyP1wiQU1cIjpcIlBNXCI7cmV0dXJuIG4/ci50b0xvd2VyQ2FzZSgpOnJ9LGw9e1lZOlN0cmluZyh0aGlzLiR5KS5zbGljZSgtMiksWVlZWTp0aGlzLiR5LE06YSsxLE1NOk8ucyhhKzEsMixcIjBcIiksTU1NOmgobi5tb250aHNTaG9ydCxhLGYsMyksTU1NTTpoKGYsYSksRDp0aGlzLiRELEREOk8ucyh0aGlzLiRELDIsXCIwXCIpLGQ6U3RyaW5nKHRoaXMuJFcpLGRkOmgobi53ZWVrZGF5c01pbix0aGlzLiRXLG8sMiksZGRkOmgobi53ZWVrZGF5c1Nob3J0LHRoaXMuJFcsbywzKSxkZGRkOm9bdGhpcy4kV10sSDpTdHJpbmcocyksSEg6Ty5zKHMsMixcIjBcIiksaDpjKDEpLGhoOmMoMiksYTpkKHMsdSwhMCksQTpkKHMsdSwhMSksbTpTdHJpbmcodSksbW06Ty5zKHUsMixcIjBcIiksczpTdHJpbmcodGhpcy4kcyksc3M6Ty5zKHRoaXMuJHMsMixcIjBcIiksU1NTOk8ucyh0aGlzLiRtcywzLFwiMFwiKSxaOml9O3JldHVybiByLnJlcGxhY2UoeSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8bFt0XXx8aS5yZXBsYWNlKFwiOlwiLFwiXCIpfSkpfSxtLnV0Y09mZnNldD1mdW5jdGlvbigpe3JldHVybiAxNSotTWF0aC5yb3VuZCh0aGlzLiRkLmdldFRpbWV6b25lT2Zmc2V0KCkvMTUpfSxtLmRpZmY9ZnVuY3Rpb24ocixkLCQpe3ZhciBsLHk9Ty5wKGQpLE09dyhyKSxtPShNLnV0Y09mZnNldCgpLXRoaXMudXRjT2Zmc2V0KCkpKmUsZz10aGlzLU0sdj1PLm0odGhpcyxNKTtyZXR1cm4gdj0obD17fSxsW2NdPXYvMTIsbFtmXT12LGxbaF09di8zLGxbb109KGctbSkvNjA0OGU1LGxbYV09KGctbSkvODY0ZTUsbFt1XT1nL24sbFtzXT1nL2UsbFtpXT1nL3QsbClbeV18fGcsJD92Ok8uYSh2KX0sbS5kYXlzSW5Nb250aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZE9mKGYpLiREfSxtLiRsb2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gRFt0aGlzLiRMXX0sbS5sb2NhbGU9ZnVuY3Rpb24odCxlKXtpZighdClyZXR1cm4gdGhpcy4kTDt2YXIgbj10aGlzLmNsb25lKCkscj1TKHQsZSwhMCk7cmV0dXJuIHImJihuLiRMPXIpLG59LG0uY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gTy53KHRoaXMuJGQsdGhpcyl9LG0udG9EYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKX0sbS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1ZhbGlkKCk/dGhpcy50b0lTT1N0cmluZygpOm51bGx9LG0udG9JU09TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b0lTT1N0cmluZygpfSxtLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9VVENTdHJpbmcoKX0sTX0oKSxUPV8ucHJvdG90eXBlO3JldHVybiB3LnByb3RvdHlwZT1ULFtbXCIkbXNcIixyXSxbXCIkc1wiLGldLFtcIiRtXCIsc10sW1wiJEhcIix1XSxbXCIkV1wiLGFdLFtcIiRNXCIsZl0sW1wiJHlcIixjXSxbXCIkRFwiLGRdXS5mb3JFYWNoKChmdW5jdGlvbih0KXtUW3RbMV1dPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLiRnKGUsdFswXSx0WzFdKX19KSksdy5leHRlbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC4kaXx8KHQoZSxfLHcpLHQuJGk9ITApLHd9LHcubG9jYWxlPVMsdy5pc0RheWpzPXAsdy51bml4PWZ1bmN0aW9uKHQpe3JldHVybiB3KDFlMyp0KX0sdy5lbj1EW3ZdLHcuTHM9RCx3LnA9e30sd30pKTsiLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KTooZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOmV8fHNlbGYpLmRheWpzX3BsdWdpbl9hZHZhbmNlZEZvcm1hdD10KCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10LnByb3RvdHlwZSxzPW4uZm9ybWF0O3IuZW4ub3JkaW5hbD1mdW5jdGlvbihlKXt2YXIgdD1bXCJ0aFwiLFwic3RcIixcIm5kXCIsXCJyZFwiXSxyPWUlMTAwO3JldHVyblwiW1wiK2UrKHRbKHItMjApJTEwXXx8dFtyXXx8dFswXSkrXCJdXCJ9LG4uZm9ybWF0PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj10aGlzLiRsb2NhbGUoKTtpZighdGhpcy5pc1ZhbGlkKCkpcmV0dXJuIHMuYmluZCh0aGlzKShlKTt2YXIgbj10aGlzLiR1dGlscygpLGE9KGV8fFwiWVlZWS1NTS1ERFRISDptbTpzc1pcIikucmVwbGFjZSgvXFxbKFteXFxdXSspXXxRfHdvfHd3fHd8V1d8V3x6enp8enxnZ2dnfEdHR0d8RG98WHx4fGt7MSwyfXxTL2csKGZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlXCJRXCI6cmV0dXJuIE1hdGguY2VpbCgodC4kTSsxKS8zKTtjYXNlXCJEb1wiOnJldHVybiByLm9yZGluYWwodC4kRCk7Y2FzZVwiZ2dnZ1wiOnJldHVybiB0LndlZWtZZWFyKCk7Y2FzZVwiR0dHR1wiOnJldHVybiB0Lmlzb1dlZWtZZWFyKCk7Y2FzZVwid29cIjpyZXR1cm4gci5vcmRpbmFsKHQud2VlaygpLFwiV1wiKTtjYXNlXCJ3XCI6Y2FzZVwid3dcIjpyZXR1cm4gbi5zKHQud2VlaygpLFwid1wiPT09ZT8xOjIsXCIwXCIpO2Nhc2VcIldcIjpjYXNlXCJXV1wiOnJldHVybiBuLnModC5pc29XZWVrKCksXCJXXCI9PT1lPzE6MixcIjBcIik7Y2FzZVwia1wiOmNhc2VcImtrXCI6cmV0dXJuIG4ucyhTdHJpbmcoMD09PXQuJEg/MjQ6dC4kSCksXCJrXCI9PT1lPzE6MixcIjBcIik7Y2FzZVwiWFwiOnJldHVybiBNYXRoLmZsb29yKHQuJGQuZ2V0VGltZSgpLzFlMyk7Y2FzZVwieFwiOnJldHVybiB0LiRkLmdldFRpbWUoKTtjYXNlXCJ6XCI6cmV0dXJuXCJbXCIrdC5vZmZzZXROYW1lKCkrXCJdXCI7Y2FzZVwienp6XCI6cmV0dXJuXCJbXCIrdC5vZmZzZXROYW1lKFwibG9uZ1wiKStcIl1cIjtkZWZhdWx0OnJldHVybiBlfX0pKTtyZXR1cm4gcy5iaW5kKHRoaXMpKGEpfX19KSk7IiwiIWZ1bmN0aW9uKHIsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpyfHxzZWxmKS5kYXlqc19wbHVnaW5fcmVsYXRpdmVUaW1lPWUoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gZnVuY3Rpb24ocixlLHQpe3I9cnx8e307dmFyIG49ZS5wcm90b3R5cGUsbz17ZnV0dXJlOlwiaW4gJXNcIixwYXN0OlwiJXMgYWdvXCIsczpcImEgZmV3IHNlY29uZHNcIixtOlwiYSBtaW51dGVcIixtbTpcIiVkIG1pbnV0ZXNcIixoOlwiYW4gaG91clwiLGhoOlwiJWQgaG91cnNcIixkOlwiYSBkYXlcIixkZDpcIiVkIGRheXNcIixNOlwiYSBtb250aFwiLE1NOlwiJWQgbW9udGhzXCIseTpcImEgeWVhclwiLHl5OlwiJWQgeWVhcnNcIn07ZnVuY3Rpb24gaShyLGUsdCxvKXtyZXR1cm4gbi5mcm9tVG9CYXNlKHIsZSx0LG8pfXQuZW4ucmVsYXRpdmVUaW1lPW8sbi5mcm9tVG9CYXNlPWZ1bmN0aW9uKGUsbixpLGQsdSl7Zm9yKHZhciBmLGEscyxsPWkuJGxvY2FsZSgpLnJlbGF0aXZlVGltZXx8byxoPXIudGhyZXNob2xkc3x8W3tsOlwic1wiLHI6NDQsZDpcInNlY29uZFwifSx7bDpcIm1cIixyOjg5fSx7bDpcIm1tXCIscjo0NCxkOlwibWludXRlXCJ9LHtsOlwiaFwiLHI6ODl9LHtsOlwiaGhcIixyOjIxLGQ6XCJob3VyXCJ9LHtsOlwiZFwiLHI6MzV9LHtsOlwiZGRcIixyOjI1LGQ6XCJkYXlcIn0se2w6XCJNXCIscjo0NX0se2w6XCJNTVwiLHI6MTAsZDpcIm1vbnRoXCJ9LHtsOlwieVwiLHI6MTd9LHtsOlwieXlcIixkOlwieWVhclwifV0sbT1oLmxlbmd0aCxjPTA7YzxtO2MrPTEpe3ZhciB5PWhbY107eS5kJiYoZj1kP3QoZSkuZGlmZihpLHkuZCwhMCk6aS5kaWZmKGUseS5kLCEwKSk7dmFyIHA9KHIucm91bmRpbmd8fE1hdGgucm91bmQpKE1hdGguYWJzKGYpKTtpZihzPWY+MCxwPD15LnJ8fCF5LnIpe3A8PTEmJmM+MCYmKHk9aFtjLTFdKTt2YXIgdj1sW3kubF07dSYmKHA9dShcIlwiK3ApKSxhPVwic3RyaW5nXCI9PXR5cGVvZiB2P3YucmVwbGFjZShcIiVkXCIscCk6dihwLG4seS5sLHMpO2JyZWFrfX1pZihuKXJldHVybiBhO3ZhciBNPXM/bC5mdXR1cmU6bC5wYXN0O3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIE0/TShhKTpNLnJlcGxhY2UoXCIlc1wiLGEpfSxuLnRvPWZ1bmN0aW9uKHIsZSl7cmV0dXJuIGkocixlLHRoaXMsITApfSxuLmZyb209ZnVuY3Rpb24ocixlKXtyZXR1cm4gaShyLGUsdGhpcyl9O3ZhciBkPWZ1bmN0aW9uKHIpe3JldHVybiByLiR1P3QudXRjKCk6dCgpfTtuLnRvTm93PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRvKGQodGhpcykscil9LG4uZnJvbU5vdz1mdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5mcm9tKGQodGhpcykscil9fX0pKTsiLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKToodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmRheWpzX3BsdWdpbl90aW1lem9uZT1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9e3llYXI6MCxtb250aDoxLGRheToyLGhvdXI6MyxtaW51dGU6NCxzZWNvbmQ6NX0sZT17fTtyZXR1cm4gZnVuY3Rpb24obixpLG8pe3ZhciByLGE9ZnVuY3Rpb24odCxuLGkpe3ZvaWQgMD09PWkmJihpPXt9KTt2YXIgbz1uZXcgRGF0ZSh0KSxyPWZ1bmN0aW9uKHQsbil7dm9pZCAwPT09biYmKG49e30pO3ZhciBpPW4udGltZVpvbmVOYW1lfHxcInNob3J0XCIsbz10K1wifFwiK2kscj1lW29dO3JldHVybiByfHwocj1uZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIse2hvdXIxMjohMSx0aW1lWm9uZTp0LHllYXI6XCJudW1lcmljXCIsbW9udGg6XCIyLWRpZ2l0XCIsZGF5OlwiMi1kaWdpdFwiLGhvdXI6XCIyLWRpZ2l0XCIsbWludXRlOlwiMi1kaWdpdFwiLHNlY29uZDpcIjItZGlnaXRcIix0aW1lWm9uZU5hbWU6aX0pLGVbb109cikscn0obixpKTtyZXR1cm4gci5mb3JtYXRUb1BhcnRzKG8pfSx1PWZ1bmN0aW9uKGUsbil7Zm9yKHZhciBpPWEoZSxuKSxyPVtdLHU9MDt1PGkubGVuZ3RoO3UrPTEpe3ZhciBmPWlbdV0scz1mLnR5cGUsbT1mLnZhbHVlLGM9dFtzXTtjPj0wJiYocltjXT1wYXJzZUludChtLDEwKSl9dmFyIGQ9clszXSxsPTI0PT09ZD8wOmQsdj1yWzBdK1wiLVwiK3JbMV0rXCItXCIrclsyXStcIiBcIitsK1wiOlwiK3JbNF0rXCI6XCIrcls1XStcIjowMDBcIixoPStlO3JldHVybihvLnV0Yyh2KS52YWx1ZU9mKCktKGgtPWglMWUzKSkvNmU0fSxmPWkucHJvdG90eXBlO2YudHo9ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT10JiYodD1yKTt2YXIgbj10aGlzLnV0Y09mZnNldCgpLGk9dGhpcy50b0RhdGUoKSxhPWkudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLHt0aW1lWm9uZTp0fSksdT1NYXRoLnJvdW5kKChpLW5ldyBEYXRlKGEpKS8xZTMvNjApLGY9byhhKS4kc2V0KFwibWlsbGlzZWNvbmRcIix0aGlzLiRtcykudXRjT2Zmc2V0KDE1Ki1NYXRoLnJvdW5kKGkuZ2V0VGltZXpvbmVPZmZzZXQoKS8xNSktdSwhMCk7aWYoZSl7dmFyIHM9Zi51dGNPZmZzZXQoKTtmPWYuYWRkKG4tcyxcIm1pbnV0ZVwiKX1yZXR1cm4gZi4keC4kdGltZXpvbmU9dCxmfSxmLm9mZnNldE5hbWU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy4keC4kdGltZXpvbmV8fG8udHouZ3Vlc3MoKSxuPWEodGhpcy52YWx1ZU9mKCksZSx7dGltZVpvbmVOYW1lOnR9KS5maW5kKChmdW5jdGlvbih0KXtyZXR1cm5cInRpbWV6b25lbmFtZVwiPT09dC50eXBlLnRvTG93ZXJDYXNlKCl9KSk7cmV0dXJuIG4mJm4udmFsdWV9O3ZhciBzPWYuc3RhcnRPZjtmLnN0YXJ0T2Y9ZnVuY3Rpb24odCxlKXtpZighdGhpcy4keHx8IXRoaXMuJHguJHRpbWV6b25lKXJldHVybiBzLmNhbGwodGhpcyx0LGUpO3ZhciBuPW8odGhpcy5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzOlNTU1wiKSk7cmV0dXJuIHMuY2FsbChuLHQsZSkudHoodGhpcy4keC4kdGltZXpvbmUsITApfSxvLnR6PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uJiZlLGE9bnx8ZXx8cixmPXUoK28oKSxhKTtpZihcInN0cmluZ1wiIT10eXBlb2YgdClyZXR1cm4gbyh0KS50eihhKTt2YXIgcz1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC02MCplKjFlMyxvPXUoaSxuKTtpZihlPT09bylyZXR1cm5baSxlXTt2YXIgcj11KGktPTYwKihvLWUpKjFlMyxuKTtyZXR1cm4gbz09PXI/W2ksb106W3QtNjAqTWF0aC5taW4obyxyKSoxZTMsTWF0aC5tYXgobyxyKV19KG8udXRjKHQsaSkudmFsdWVPZigpLGYsYSksbT1zWzBdLGM9c1sxXSxkPW8obSkudXRjT2Zmc2V0KGMpO3JldHVybiBkLiR4LiR0aW1lem9uZT1hLGR9LG8udHouZ3Vlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lfSxvLnR6LnNldERlZmF1bHQ9ZnVuY3Rpb24odCl7cj10fX19KSk7IiwiIWZ1bmN0aW9uKHQsaSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9aSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoaSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqc19wbHVnaW5fdXRjPWkoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD1cIm1pbnV0ZVwiLGk9L1srLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2csZT0vKFsrLV18XFxkXFxkKS9nO3JldHVybiBmdW5jdGlvbihzLGYsbil7dmFyIHU9Zi5wcm90b3R5cGU7bi51dGM9ZnVuY3Rpb24odCl7dmFyIGk9e2RhdGU6dCx1dGM6ITAsYXJnczphcmd1bWVudHN9O3JldHVybiBuZXcgZihpKX0sdS51dGM9ZnVuY3Rpb24oaSl7dmFyIGU9bih0aGlzLnRvRGF0ZSgpLHtsb2NhbGU6dGhpcy4kTCx1dGM6ITB9KTtyZXR1cm4gaT9lLmFkZCh0aGlzLnV0Y09mZnNldCgpLHQpOmV9LHUubG9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLnRvRGF0ZSgpLHtsb2NhbGU6dGhpcy4kTCx1dGM6ITF9KX07dmFyIG89dS5wYXJzZTt1LnBhcnNlPWZ1bmN0aW9uKHQpe3QudXRjJiYodGhpcy4kdT0hMCksdGhpcy4kdXRpbHMoKS51KHQuJG9mZnNldCl8fCh0aGlzLiRvZmZzZXQ9dC4kb2Zmc2V0KSxvLmNhbGwodGhpcyx0KX07dmFyIHI9dS5pbml0O3UuaW5pdD1mdW5jdGlvbigpe2lmKHRoaXMuJHUpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldFVUQ0Z1bGxZZWFyKCksdGhpcy4kTT10LmdldFVUQ01vbnRoKCksdGhpcy4kRD10LmdldFVUQ0RhdGUoKSx0aGlzLiRXPXQuZ2V0VVRDRGF5KCksdGhpcy4kSD10LmdldFVUQ0hvdXJzKCksdGhpcy4kbT10LmdldFVUQ01pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0VVRDU2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0VVRDTWlsbGlzZWNvbmRzKCl9ZWxzZSByLmNhbGwodGhpcyl9O3ZhciBhPXUudXRjT2Zmc2V0O3UudXRjT2Zmc2V0PWZ1bmN0aW9uKHMsZil7dmFyIG49dGhpcy4kdXRpbHMoKS51O2lmKG4ocykpcmV0dXJuIHRoaXMuJHU/MDpuKHRoaXMuJG9mZnNldCk/YS5jYWxsKHRoaXMpOnRoaXMuJG9mZnNldDtpZihcInN0cmluZ1wiPT10eXBlb2YgcyYmKHM9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9XCJcIik7dmFyIHM9dC5tYXRjaChpKTtpZighcylyZXR1cm4gbnVsbDt2YXIgZj0oXCJcIitzWzBdKS5tYXRjaChlKXx8W1wiLVwiLDAsMF0sbj1mWzBdLHU9NjAqK2ZbMV0rICtmWzJdO3JldHVybiAwPT09dT8wOlwiK1wiPT09bj91Oi11fShzKSxudWxsPT09cykpcmV0dXJuIHRoaXM7dmFyIHU9TWF0aC5hYnMocyk8PTE2PzYwKnM6cyxvPXRoaXM7aWYoZilyZXR1cm4gby4kb2Zmc2V0PXUsby4kdT0wPT09cyxvO2lmKDAhPT1zKXt2YXIgcj10aGlzLiR1P3RoaXMudG9EYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTotMSp0aGlzLnV0Y09mZnNldCgpOyhvPXRoaXMubG9jYWwoKS5hZGQodStyLHQpKS4kb2Zmc2V0PXUsby4keC4kbG9jYWxPZmZzZXQ9cn1lbHNlIG89dGhpcy51dGMoKTtyZXR1cm4gb307dmFyIGg9dS5mb3JtYXQ7dS5mb3JtYXQ9ZnVuY3Rpb24odCl7dmFyIGk9dHx8KHRoaXMuJHU/XCJZWVlZLU1NLUREVEhIOm1tOnNzW1pdXCI6XCJcIik7cmV0dXJuIGguY2FsbCh0aGlzLGkpfSx1LnZhbHVlT2Y9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLiR1dGlscygpLnUodGhpcy4kb2Zmc2V0KT8wOnRoaXMuJG9mZnNldCsodGhpcy4keC4kbG9jYWxPZmZzZXR8fHRoaXMuJGQuZ2V0VGltZXpvbmVPZmZzZXQoKSk7cmV0dXJuIHRoaXMuJGQudmFsdWVPZigpLTZlNCp0fSx1LmlzVVRDPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLiR1fSx1LnRvSVNPU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKX0sdS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvRGF0ZSgpLnRvVVRDU3RyaW5nKCl9O3ZhciBsPXUudG9EYXRlO3UudG9EYXRlPWZ1bmN0aW9uKHQpe3JldHVyblwic1wiPT09dCYmdGhpcy4kb2Zmc2V0P24odGhpcy5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzOlNTU1wiKSkudG9EYXRlKCk6bC5jYWxsKHRoaXMpfTt2YXIgYz11LmRpZmY7dS5kaWZmPWZ1bmN0aW9uKHQsaSxlKXtpZih0JiZ0aGlzLiR1PT09dC4kdSlyZXR1cm4gYy5jYWxsKHRoaXMsdCxpLGUpO3ZhciBzPXRoaXMubG9jYWwoKSxmPW4odCkubG9jYWwoKTtyZXR1cm4gYy5jYWxsKHMsZixpLGUpfX19KSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xudmFyICRleGVjID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC9nLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIE1hcExpa2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKS5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tYXBba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMuX21hcFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwW2tleV07XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9tYXApO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tYXBba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLl9tYXBba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNYXBMaWtlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwTGlrZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5jbGFzcyBNZXNzYWdlSGFuZGxlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLm1ldGhvZHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZU1lc3NhZ2Uoc29ja2V0LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBsZXQgaXNCaW5hcnkgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgaXNCaW5hcnkgPSB0cnVlO1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgaXNCaW5hcnkgPSB0cnVlO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBpc0JpbmFyeSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhID0gXCJbXCIgKyBkYXRhLm1hcChidWYgPT4gYnVmLnRvU3RyaW5nKCkpLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjb21tb25fMS5jcmVhdGVFcnJvcigtMzI2MDAgLyogSW52YWxpZFJlcXVlc3QgKi8sIG51bGwsIFwiRW1wdHkgQXJyYXlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShyZXMpLCBpc0JpbmFyeSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbHMucHVzaCguLi5vYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbHMucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogY29tbW9uXzEuY3JlYXRlRXJyb3IoLTMyNzAwIC8qIFBhcnNlRXJyb3IgKi8sIG51bGwsIFwiSW52YWxpZCBKU09OXCIpLFxuICAgICAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkocmVzKSwgaXNCaW5hcnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBjYWxscykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fcHJvY2Vzc0NhbGwoc29ja2V0LCBjYWxsKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZXMucHVzaChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoaXNBcnJheSA/IHJlc3BvbnNlcyA6IHJlc3BvbnNlc1swXSksIGlzQmluYXJ5KTtcbiAgICB9XG4gICAgYXN5bmMgX3Byb2Nlc3NDYWxsKHNvY2tldCwgY2FsbCkge1xuICAgICAgICBjb25zdCByZXFJZCA9IGNhbGwuaWQ7XG4gICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBpZDogcmVxSWQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiByZXFJZFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGNhbGwgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsLmpzb25ycGMgIT09IFwiMi4wXCIgJiYgKHRoaXMub3B0aW9ucy5qc29ucnBjVmVyc2lvbkNoZWNrID09PSAwIC8qIFNUUklDVCAqLyB8fFxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5qc29ucnBjVmVyc2lvbkNoZWNrID09PSAxIC8qIExPT1NFICovICYmIGNhbGwuanNvbnJwYyAhPT0gdW5kZWZpbmVkKSkpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLywgbnVsbCwgXCJJbnZhbGlkIEpTT04tUlBDIFZlcnNpb25cIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tb25fMS5pc1Jlc3BvbnNlKGNhbGwpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZXNwb25zZVwiLCBzb2NrZXQsIGNhbGwpO1xuICAgICAgICAgICAgaWYgKGNhbGwuaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJtZXRob2RfcmVzcG9uc2VcIiwgc29ja2V0LCBjYWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbGwuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuZXJyb3IgPSBjb21tb25fMS5jcmVhdGVFcnJvcigtMzI2MDAgLyogSW52YWxpZFJlcXVlc3QgKi8pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvcl9yZXNwb25zZVwiLCBzb2NrZXQsIGNhbGwpO1xuICAgICAgICAgICAgaWYgKGNhbGwuZXJyb3IuY29kZSA9PT0gLTMyNzAwIC8qIFBhcnNlRXJyb3IgKi8gfHwgY2FsbC5lcnJvci5jb2RlID09PSAtMzI2MDAgLyogSW52YWxpZFJlcXVlc3QgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJub3RpZmljYXRpb25fZXJyb3JcIiwgc29ja2V0LCBjYWxsLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbGwubWV0aG9kKSB7XG4gICAgICAgICAgICByZXMuZXJyb3IgPSBjb21tb25fMS5jcmVhdGVFcnJvcigtMzI2MDEgLyogTWV0aG9kTm90Rm91bmQgKi8sIG51bGwsIFwiTWV0aG9kIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbC5tZXRob2QgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLywgbnVsbCwgXCJJbnZhbGlkIHR5cGUgb2YgbWV0aG9kIG5hbWVcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInBhcmFtc1wiIGluIGNhbGwgJiYgKHR5cGVvZiBjYWxsLnBhcmFtcyAhPT0gXCJvYmplY3RcIiB8fCBjYWxsLnBhcmFtcyA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMCAvKiBJbnZhbGlkUmVxdWVzdCAqLyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZHMuaGFzKGNhbGwubWV0aG9kKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNvbW1vbl8xLmNyZWF0ZUVycm9yKC0zMjYwMSAvKiBNZXRob2ROb3RGb3VuZCAqLyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgdGhpcy5tZXRob2RzLmdldChjYWxsLm1ldGhvZCkoc29ja2V0LCBjYWxsLnBhcmFtcykgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXFJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHJlcUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVycm9yID0gY29tbW9uXzEuY3JlYXRlRXJyb3IoLTMyMDAwIC8qIFNlcnZlckVycm9yICovLCBlLm5hbWUsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1lc3NhZ2VIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzc2FnZUhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbmZpZ0RlZmF1bHRzID0gdm9pZCAwO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZShcImlzb21vcnBoaWMtd3NcIik7XG5jb25zdCBCYWNrb2ZmID0gcmVxdWlyZShcImJhY2tvMlwiKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudGVtaXR0ZXIzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5jb25zdCBNZXNzYWdlSGFuZGxlcl8xID0gcmVxdWlyZShcIi4vTWVzc2FnZUhhbmRsZXJcIik7XG5leHBvcnRzLkNvbmZpZ0RlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgcmVjb25uZWN0aW9uOiB0cnVlLFxuICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiBJbmZpbml0eSxcbiAgICByZWNvbm5lY3Rpb25EZWxheTogMTAwMCxcbiAgICByZWNvbm5lY3Rpb25EZWxheU1heDogNTAwMCxcbiAgICByZWNvbm5lY3Rpb25KaXR0ZXI6IDAuNSxcbiAgICBtZXRob2RDYWxsVGltZW91dDogMjAwMDAsXG4gICAgYXV0b0Nvbm5lY3Q6IHRydWUsXG4gICAgYnVmZmVyU2VuZGluZ01lc3NhZ2VzOiB0cnVlLFxuICAgIHF1ZXJ5OiB7fSxcbiAgICBwcm90b2NvbHM6IFwiXCJcbn0pO1xuLyoqXG4gKiBKU09OLVJQQyAyLjAgQ2xpZW50XG4gKi9cbmNsYXNzIENsaWVudCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHVyaSBUaGUgVVJJIHRvIGNvbm5lY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudXJpID0gdXJpO1xuICAgICAgICB0aGlzLnNlbmRpbmdNZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9za2lwUmVjb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0SWQgPSAwO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmV4cG9ydHMuQ29uZmlnRGVmYXVsdHMsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2JhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgICAgICAgICBtaW46IHRoaXMuY29uZmlnLnJlY29ubmVjdGlvbkRlbGF5LFxuICAgICAgICAgICAgbWF4OiB0aGlzLmNvbmZpZy5yZWNvbm5lY3Rpb25EZWxheU1heCxcbiAgICAgICAgICAgIGppdHRlcjogdGhpcy5jb25maWcucmVjb25uZWN0aW9uSml0dGVyXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcl8xLmRlZmF1bHQodGhpcy5jb25maWcpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcIm1ldGhvZF9yZXNwb25zZVwiLCAoc29ja2V0LCByZXNwb25zZSkgPT4gdGhpcy5faGFuZGxlTWV0aG9kUmVzcG9uc2UocmVzcG9uc2UpKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIub24oXCJlcnJvcl9yZXNwb25zZVwiLCAoc29ja2V0LCByZXNwb25zZSkgPT4gdGhpcy5lbWl0KFwiZXJyb3JfcmVzcG9uc2VcIiwgcmVzcG9uc2UpKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIub24oXCJub3RpZmljYXRpb25fZXJyb3JcIiwgKHNvY2tldCwgZXJyb3IpID0+IHRoaXMuZW1pdChcIm5vdGlmaWNhdGlvbl9lcnJvclwiLCBlcnJvcikpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYXV0b0Nvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKCgpID0+IHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG1ldGhvZHMoKSB7IHJldHVybiB0aGlzLl9tZXNzYWdlSGFuZGxlci5tZXRob2RzOyB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGluZ1wiKTtcbiAgICAgICAgY29uc3Qgd3MgPSB0aGlzLl93cyA9IG5ldyBXZWJTb2NrZXQodGhpcy51cmksIHRoaXMuY29uZmlnLnByb3RvY29scywgdGhpcy5jb25maWcpO1xuICAgICAgICBpZiAod3MuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9yID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKHsgY29kZSwgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3MgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoeyBkYXRhIH0pID0+IHRoaXMuX21lc3NhZ2VIYW5kbGVyLmhhbmRsZU1lc3NhZ2UodGhpcywgZGF0YSkuY2F0Y2goZSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3Mub24oXCJlcnJvclwiLCBlcnJvciA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpO1xuICAgICAgICAgICAgd3Mub24oXCJjbG9zZVwiLCAoY29kZSwgcmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBjb2RlLCByZWFzb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dzID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd3Mub24oXCJtZXNzYWdlXCIsIGRhdGEgPT4gdGhpcy5fbWVzc2FnZUhhbmRsZXIuaGFuZGxlTWVzc2FnZSh0aGlzLCBkYXRhKS5jYXRjaChlID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJlY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc2tpcFJlY29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHdzLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKCkgPT4gdGhpcy5yZWNvbm5lY3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cy5vbihcImNsb3NlXCIsICgpID0+IHRoaXMucmVjb25uZWN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh3cy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3cy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cy5vbmNlKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdzLm9mZihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3cy5vbmNlKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NlbmRCdWZmZXJlZE1lc3NhZ2VzKCk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCB0aGUgY29ubmVjdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLl9za2lwUmVjb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgLy8gY2xlYXIgbWV0aG9kIGNhbGwgdGltZW91dC5cbiAgICAgICAgZm9yIChjb25zdCBbdGltZXJdIG9mIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5jbGVhcigpO1xuICAgICAgICAvLyBjbGVhciByZWNvbm5lY3Rpb24gdGltZXIuXG4gICAgICAgIGlmICh0aGlzLl9yZWNvbm5lY3Rpb25TbGVlcFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVjb25uZWN0aW9uU2xlZXBUaW1lcik7XG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb25TbGVlcFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cyA9IHRoaXMuX3dzO1xuICAgICAgICBpZiAoIXdzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTiB8fCB3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh3cy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoKSA9PiByZXNvbHZlKCksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdzLm9uY2UoXCJjbG9zZVwiLCAoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IG51bGw7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgIGlmICh3cy5yZW1vdmVBbGxMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIC8vIGZvciBub2RlXG4gICAgICAgICAgICB3cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvciBicm93c2VyXG4gICAgICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGF0IHRoaXMgdGltZS5cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kKGRhdGEsIGJpbmFyeSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChiaW5hcnkgJiYgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNlbmRpbmdNZXNzYWdlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dzLnNlbmQoZGF0YSwgZSA9PiBlID8gdGhpcy5fYnVmZmVyU2VuZGluZ01lc3NhZ2UoZGF0YSkgOiBudWxsKTtcbiAgICB9XG4gICAgY2xlYXJTZW5kaW5nTWVzc2FnZUJ1ZmZlcigpIHtcbiAgICAgICAgdGhpcy5zZW5kaW5nTWVzc2FnZUJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBub3RpZnkobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICB9XG4gICAgY2FsbChtZXRob2QsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fY3VycmVudFJlcXVlc3RJZCsrO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGlkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJKU09OLVJQQzogbWV0aG9kIGNhbGwgdGltZW91dFwiKSk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5tZXRob2RDYWxsVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnNldChpZCwgW3RpbWVvdXQsIHJlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyAhPT0gbnVsbCAmJiB0aGlzLl93cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTjtcbiAgICB9XG4gICAgYXN5bmMgcmVjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVjb25uZWN0aW5nIHx8IHRoaXMuX3NraXBSZWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYWNrb2ZmID0gdGhpcy5fYmFja29mZjtcbiAgICAgICAgaWYgKGJhY2tvZmYuYXR0ZW1wdHMgPiB0aGlzLmNvbmZpZy5yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVjb25uZWN0X2ZhaWxlZFwiKTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gYmFja29mZi5kdXJhdGlvbigpO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHRoaXMuX3JlY29ubmVjdGlvblNsZWVwVGltZXIgPSBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvblNsZWVwVGltZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fc2tpcFJlY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInJlY29ubmVjdGluZ1wiLCBiYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuX3NraXBSZWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVjb25uZWN0X2Vycm9yXCIsIGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0ZW1wdHMgPSBiYWNrb2ZmLmF0dGVtcHRzO1xuICAgICAgICBiYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWNvbm5lY3RlZFwiLCBhdHRlbXB0cyk7XG4gICAgfVxuICAgIF9oYW5kbGVNZXRob2RSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmlkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1bmtvd25fcmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmdldChyZXNwb25zZS5pZCk7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidW5rb3duX3Jlc3BvbnNlXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmRlbGV0ZShyZXNwb25zZS5pZCk7XG4gICAgICAgIGNvbnN0IFt0aW1lciwgcmVzb2x2ZSwgcmVqZWN0XSA9IGhhbmRsZXI7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGlmIChjb21tb25fMS5pc1N1Y2Nlc3NSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2J1ZmZlclNlbmRpbmdNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJ1ZmZlclNlbmRpbmdNZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5zZW5kaW5nTWVzc2FnZUJ1ZmZlci5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZSBpcyByZWplY3RlZDogIFRoZSBzb2NrZXQgaXMgY2xvc2Ugd2l0aG91dCBtZXNzYWdlIGJ1ZmZlcmluZy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3NlbmRCdWZmZXJlZE1lc3NhZ2VzKCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLnNlbmRpbmdNZXNzYWdlQnVmZmVyO1xuICAgICAgICBjb25zdCB3cyA9IHRoaXMuX3dzO1xuICAgICAgICBmb3IgKGxldCBkYXRhID0gYnVmZmVyLnNoaWZ0KCk7IGRhdGE7IGRhdGEgPSBidWZmZXIuc2hpZnQoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB3cy5zZW5kKGRhdGEsIGUgPT4gZSA/IHJlamVjdChlKSA6IHJlc29sdmUoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIudW5zaGlmdChkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJidWZmZXJfc2VuZGluZ19lcnJvclwiLCBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRXJyb3IgPSBleHBvcnRzLmVycm9yQ29kZU1hcCA9IGV4cG9ydHMuaXNTdWNjZXNzUmVzcG9uc2UgPSBleHBvcnRzLmlzUmVzcG9uc2UgPSB2b2lkIDA7XG4vKipcbiAqIENoZWNrIHR5cGUgb2YgY2FsbCBpcyBhbiBSZXBvbnNlIG9yIG5vdFxuICogQHBhcmFtIGNhbGwgYW4gQ2FsbCBvYmplY3Qgd2hpY2ggd2lsbCBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKGNhbGwpIHtcbiAgICByZXR1cm4gXCJpZFwiIGluIGNhbGwgJiYgKFwicmVzdWx0XCIgaW4gY2FsbCB8fCBcImVycm9yXCIgaW4gY2FsbCk7XG59XG5leHBvcnRzLmlzUmVzcG9uc2UgPSBpc1Jlc3BvbnNlO1xuLyoqXG4gKiBDaGVjayB0eXBlIG9mIHJlc3BvbnNlIGlzIFN1Y2Nlc3NSZXNwb25zZSBvciBub3RcbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgYW4gUmVzcG9uc2Ugb2JqZWN0IHdoaWNoIHdpbGwgYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdWNjZXNzUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gXCJyZXN1bHRcIiBpbiByZXNwb25zZSAmJiByZXNwb25zZS5pZCAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNTdWNjZXNzUmVzcG9uc2UgPSBpc1N1Y2Nlc3NSZXNwb25zZTtcbi8qKlxuICogSlNPTi1SUEMgMi4wIEVycm9yIENvZGVzXG4gKi9cbmV4cG9ydHMuZXJyb3JDb2RlTWFwID0gbmV3IE1hcChbXG4gICAgWy0zMjcwMCwgXCJQYXJzZSBlcnJvclwiXSxcbiAgICBbLTMyNjAwLCBcIkludmFsaWQgUmVxdWVzdFwiXSxcbiAgICBbLTMyNjAxLCBcIk1ldGhvZCBub3QgZm91bmRcIl0sXG4gICAgWy0zMjYwMiwgXCJJbnZhbGlkIHBhcmFtc1wiXSxcbiAgICBbLTMyNjAzLCBcIkludGVybmFsIGVycm9yXCJdLFxuICAgIFstMzIwMDAsIFwiU2VydmVyIGVycm9yXCJdXG5dKTtcbi8qKlxuICogQ3JlYXRlcyBhIEpTT04tUlBDIDIuMCBjb21wbGlhbnQgRXJyb3IgT2JqZWN0XG4gKiBAcGFyYW0gY29kZSBBIE51bWJlciB0aGF0IGluZGljYXRlcyB0aGUgZXJyb3IgdHlwZSB0aGF0IG9jY3VycmVkLiAoSW50ZWdlcilcbiAqIEBwYXJhbSBkYXRhIEEgUHJpbWl0aXZlIG9yIFN0cnVjdHVyZWQgdmFsdWUgdGhhdCBjb250YWlucyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIGNvbnN0IGVycm9yID0ge1xuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IGV4cG9ydHMuZXJyb3JDb2RlTWFwLmdldChjb2RlKSB8fCBcIlNlcnZlciBlcnJvclwiXG4gICAgfTtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnRzLmNyZWF0ZUVycm9yID0gY3JlYXRlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudCA9IGV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xudmFyIHNlcnZlcl8xID0gcmVxdWlyZShcIi4vc2VydmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfMS5kZWZhdWx0OyB9IH0pO1xudmFyIGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfMS5kZWZhdWx0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudGVtaXR0ZXIzXCIpO1xuY29uc3Qgd3NfMSA9IHJlcXVpcmUoXCJ3c1wiKTtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgTWVzc2FnZUhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL01lc3NhZ2VIYW5kbGVyXCIpO1xuY29uc3QgTWFwTGlrZV8xID0gcmVxdWlyZShcIi4vTWFwTGlrZVwiKTtcbi8qKlxuICogSlNPTi1SUEMgMi4wIFdlYlNvY2tldCBTZXJ2ZXJcbiAqL1xuY2xhc3MgU2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayBjYWxsYmFjayBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnQgKHdzKS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNvY2tldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2xhc3RQaW5nQXQgPSAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHBpbmdUaW1lb3V0OiA1MDAwLFxuICAgICAgICAgICAgcGluZ0ludGVydmFsOiAyNTAwMCxcbiAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICBqc29ucnBjVmVyc2lvbkNoZWNrOiAwIC8qIFNUUklDVCAqLyxcbiAgICAgICAgICAgIHV3czogZmFsc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyXzEuZGVmYXVsdCh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcImVycm9yX3Jlc3BvbnNlXCIsIChzb2NrZXQsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvcl9yZXNwb25zZVwiLCBzb2NrZXQsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KFwiZXJyb3JfcmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIub24oXCJub3RpZmljYXRpb25fZXJyb3JcIiwgKHNvY2tldCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm5vdGlmaWNhdGlvbl9lcnJvclwiLCBzb2NrZXQsIGVycm9yKTtcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KFwibm90aWZpY2F0aW9uX2Vycm9yXCIsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbWV0aG9kcygpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm1ldGhvZHM7IH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgY2FsbGJhY2sgQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50ICh3cykuXG4gICAgICovXG4gICAgb3BlbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMud3NzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgd3NgIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndzRW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLndzcyA9IG5ldyB0aGlzLm9wdGlvbnMud3NFbmdpbmUodGhpcy5vcHRpb25zLndzcywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53c3MgPSBuZXcgd3NfMS5TZXJ2ZXIodGhpcy5vcHRpb25zLndzcywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3NzLm9uY2UoXCJsaXN0ZW5pbmdcIiwgZnVuY3Rpb24gX29uTGlzdGVuaW5nV1NTKCkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KFwibGlzdGVuaW5nXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53c3Mub24oXCJjb25uZWN0aW9uXCIsIGZ1bmN0aW9uIF9vbkNvbm5lY3Rpb25XU1Mod3MsIHJlcSkge1xuICAgICAgICAgICAgbGV0IHNvY2tldCA9IG5ldyBTb2NrZXQod3MpO1xuICAgICAgICAgICAgc2VsZi5zb2NrZXRzLnNldChzb2NrZXQuaWQsIHNvY2tldCk7XG4gICAgICAgICAgICB3cy5vbmNlKFwiY2xvc2VcIiwgZnVuY3Rpb24gX29uQ2xvc2VXUygpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LndzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzb2NrZXQucm9vbXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuZGF0YS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNvY2tldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgd3MucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgd3MgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3cy5vbihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gX29uTWVzc2FnZVdTKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tZXNzYWdlSGFuZGxlci5oYW5kbGVNZXNzYWdlKHNvY2tldCwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIF9vbkVycm9ySGFuZGxlTWVzc2FnZShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3cy5vbihcInBvbmdcIiwgZnVuY3Rpb24gX29uUG9uZ1dTKCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5fcG9uZ0F0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5lbWl0KFwiY29ubmVjdGlvblwiLCBzb2NrZXQsIHJlcSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndzcy5vbihcImVycm9yXCIsIGZ1bmN0aW9uIF9vbkVycm9yV1NTKGUpIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcGluZ1RpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fcGluZy5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbnMucGluZ0ludGVydmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgc2VydmVyIGFuZCB0ZXJtaW5hdGVzIGFsbCBzb2NrZXRzLlxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BpbmdUaW1lcik7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0LnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMud3NzLmNsb3NlKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3NzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICBkZWxldGUgdGhpcy53c3M7XG4gICAgICAgIHRoaXMuc29ja2V0cy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGEgbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiZSBpbnZva2VkLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgb2YgdGhlIG1ldGhvZC5cbiAgICAgKi9cbiAgICBicm9hZGNhc3QobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChqc29uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGEgbm90aWZpY2F0aW9uIHRvIHRoZSByb29tLlxuICAgICAqIEBwYXJhbSByb29tIFRoZSBuYW1lIG9mIHRoZSByb29tLlxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiZSBpbnZva2VkLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgb2YgdGhlIG1ldGhvZC5cbiAgICAgKi9cbiAgICBub3RpZnlUbyhyb29tLCBtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQucm9vbXMuaGFzKHJvb20pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyBhIChyYXcpIG1lc3NhZ2UgdG8gdGhlIHJvb20uXG4gICAgICogQHBhcmFtIHJvb20gVGhlIG5hbWUgb2YgdGhlIHJvb20uXG4gICAgICogQHBhcmFtIGRhdGEgKHJhdykgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBzZW5kVG8ocm9vbSwgZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQucm9vbXMuaGFzKHJvb20pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBzb2NrZXRzIGluIHRoZSByb29tLlxuICAgICAqIEBwYXJhbSByb29tIFRoZSBuYW1lIG9mIHRoZSByb29tLlxuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgY29uc3Qgc29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoc29ja2V0LnJvb21zLmhhcyhyb29tKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNvY2tldHMuc2V0KHNvY2tldC5pZCwgc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ja2V0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VydmVyIGlzIG9wZW4gb3Igbm90XG4gICAgICovXG4gICAgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53c3MgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGluZyB0byBhbGwgc29ja2V0cy5cbiAgICAgKi9cbiAgICBfcGluZygpIHtcbiAgICAgICAgY29uc3QgZGVhZGxpbmUgPSB0aGlzLl9sYXN0UGluZ0F0ICsgdGhpcy5vcHRpb25zLnBpbmdUaW1lb3V0O1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQuX3BvbmdBdCA9PT0gLTEgfHwgc29ja2V0Ll9wb25nQXQgPiBkZWFkbGluZSkge1xuICAgICAgICAgICAgICAgIHNvY2tldC50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvY2tldC5fcG9uZ0F0ID0gLTE7XG4gICAgICAgICAgICBpZiAoc29ja2V0LmlzT3BlbigpKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LndzLnBpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0UGluZ0F0ID0gRGF0ZS5ub3coKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTZXJ2ZXI7XG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud3MgPSB3cztcbiAgICAgICAgdGhpcy5pZCA9IHV1aWRfMS52NCgpO1xuICAgICAgICB0aGlzLnJvb21zID0gbmV3IFNldCgpO1xuICAgICAgICAvKiogY3VzdG9tIGRhdGEgc3RvcmUgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcExpa2VfMS5kZWZhdWx0KCk7XG4gICAgICAgIC8qKiAoaW50ZXJuYWwgdXNpbmcgZm9yIGhlYXJ0YmVhdCkgKi9cbiAgICAgICAgdGhpcy5fcG9uZ0F0ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBub3RpZmljYXRpb24gdG8gdGhlIHNvY2tldC5cbiAgICAgKiBAcGFyYW0gbWV0aG9kIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gYmUgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBtZXRob2QuXG4gICAgICovXG4gICAgbm90aWZ5KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIChyYXcpIG1lc3NhZ2UgdG8gdGhlIHNvY2tldC5cbiAgICAgKiBAcGFyYW0gZGF0YSAocmF3KSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBiaW5hcnkgYmluYXJ5IGZsYWcuXG4gICAgICovXG4gICAgc2VuZChkYXRhLCBiaW5hcnkgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEsIHsgYmluYXJ5IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW5zIGEgcm9vbS4gWW91IGNhbiBqb2luIG11bHRpcGxlIHJvb21zLlxuICAgICAqIEBwYXJhbSByb29tIFRoZSBuYW1lIG9mIHRoZSByb29tIHRoYXQgd2Ugd2FudCB0byBqb2luLlxuICAgICAqL1xuICAgIGpvaW5Ubyhyb29tKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb21zLmhhcyhyb29tKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucm9vbXMuYWRkKHJvb20pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgYSByb29tLlxuICAgICAqIEBwYXJhbSByb29tIFRoZSBuYW1lIG9mIHRoZSByb29tIHRvIGxlYXZlLlxuICAgICAqL1xuICAgIGxlYXZlRnJvbShyb29tKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb21zLmhhcyhyb29tKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5yb29tcy5kZWxldGUocm9vbSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyBhbGwgdGhlIHJvb21zIHRoYXQgd2UndmUgam9pbmVkLlxuICAgICAqL1xuICAgIGxlYXZlRnJvbUFsbCgpIHtcbiAgICAgICAgdGhpcy5yb29tcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgICAqIEBwYXJhbSBjb2RlIEEgbnVtZXJpYyB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBiZWluZyBjbG9zZWQuXG4gICAgICogQHBhcmFtIHJlYXNvbiBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nLlxuICAgICAqL1xuICAgIGNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLndzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdGhpcy53cy50ZXJtaW5hdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb25uZWN0aW9uIGlzIG9wZW4gb3Igbm90XG4gICAgICovXG4gICAgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cyAhPT0gdW5kZWZpbmVkICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gd3NfMS5PUEVOO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gTG9uZztcclxuXHJcbi8qKlxyXG4gKiB3YXNtIG9wdGltaXphdGlvbnMsIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxyXG4gKi9cclxudmFyIHdhc20gPSBudWxsO1xyXG5cclxudHJ5IHtcclxuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFcclxuICBdKSksIHt9KS5leHBvcnRzO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgLy8gbm8gd2FzbSBzdXBwb3J0IDooXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICogQGV4cG9ydHMgTG9uZ1xyXG4gKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG59XHJcblxyXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4vLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4vLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuLy9cclxuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4vLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbi8vXHJcbi8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuLyoqXHJcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tSW50ID0gZnJvbUludDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xyXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgIH1cclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuXHJcbiAgICB2YXIgcDtcclxuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XHJcbiAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XHJcbiAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xyXG5cclxuLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4vLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlpFUk8gPSBaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE9ORSA9IGZyb21JbnQoMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVU9ORSA9IFVPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHg3RkZGRkZGRnwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuICcwJztcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxyXG4gICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXHJcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxyXG4gICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmhpZ2gpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuXHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgIHJlcyA9IFpFUk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cclxuICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBVT05FO1xyXG4gICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgIHJlbSA9IHRoaXM7XHJcbiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xyXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XHJcbiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMjRcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgaGkgPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmXHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbMF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1syXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbM10gPDwgMjQsXHJcbiAgICAgICAgYnl0ZXNbNF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbN10gPDwgMjQsXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1s0XSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s3XSxcclxuICAgICAgICBieXRlc1swXSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1szXSxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gKCkge1xuXHQvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcblx0Ly8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG5cdC8vIEhvd2V2ZXIsIHRoaXMgY2F1c2VzIENTUCB2aW9sYXRpb25zIGluIENocm9tZSBhcHBzLlxuXHRpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gd2luZG93OyB9XG5cdGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZ2xvYmFsOyB9XG5cdHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG5cbnZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZ2xvYmFsLmZldGNoO1xuXG4vLyBOZWVkZWQgZm9yIFR5cGVTY3JpcHQgYW5kIFdlYnBhY2suXG5pZiAoZ2xvYmFsLmZldGNoKSB7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGdsb2JhbC5mZXRjaC5iaW5kKGdsb2JhbCk7XG59XG5cbmV4cG9ydHMuSGVhZGVycyA9IGdsb2JhbC5IZWFkZXJzO1xuZXhwb3J0cy5SZXF1ZXN0ID0gZ2xvYmFsLlJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gZ2xvYmFsLlJlc3BvbnNlOyIsInZhciBoYXNNYXAgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIE1hcC5wcm90b3R5cGU7XG52YXIgbWFwU2l6ZURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmIGhhc01hcCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTWFwLnByb3RvdHlwZSwgJ3NpemUnKSA6IG51bGw7XG52YXIgbWFwU2l6ZSA9IGhhc01hcCAmJiBtYXBTaXplRGVzY3JpcHRvciAmJiB0eXBlb2YgbWFwU2l6ZURlc2NyaXB0b3IuZ2V0ID09PSAnZnVuY3Rpb24nID8gbWFwU2l6ZURlc2NyaXB0b3IuZ2V0IDogbnVsbDtcbnZhciBtYXBGb3JFYWNoID0gaGFzTWFwICYmIE1hcC5wcm90b3R5cGUuZm9yRWFjaDtcbnZhciBoYXNTZXQgPSB0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIFNldC5wcm90b3R5cGU7XG52YXIgc2V0U2l6ZURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmIGhhc1NldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoU2V0LnByb3RvdHlwZSwgJ3NpemUnKSA6IG51bGw7XG52YXIgc2V0U2l6ZSA9IGhhc1NldCAmJiBzZXRTaXplRGVzY3JpcHRvciAmJiB0eXBlb2Ygc2V0U2l6ZURlc2NyaXB0b3IuZ2V0ID09PSAnZnVuY3Rpb24nID8gc2V0U2l6ZURlc2NyaXB0b3IuZ2V0IDogbnVsbDtcbnZhciBzZXRGb3JFYWNoID0gaGFzU2V0ICYmIFNldC5wcm90b3R5cGUuZm9yRWFjaDtcbnZhciBoYXNXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgV2Vha01hcC5wcm90b3R5cGU7XG52YXIgd2Vha01hcEhhcyA9IGhhc1dlYWtNYXAgPyBXZWFrTWFwLnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyIGhhc1dlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrU2V0LnByb3RvdHlwZTtcbnZhciB3ZWFrU2V0SGFzID0gaGFzV2Vha1NldCA/IFdlYWtTZXQucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgaGFzV2Vha1JlZiA9IHR5cGVvZiBXZWFrUmVmID09PSAnZnVuY3Rpb24nICYmIFdlYWtSZWYucHJvdG90eXBlO1xudmFyIHdlYWtSZWZEZXJlZiA9IGhhc1dlYWtSZWYgPyBXZWFrUmVmLnByb3RvdHlwZS5kZXJlZiA6IG51bGw7XG52YXIgYm9vbGVhblZhbHVlT2YgPSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mO1xudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyICRtYXRjaCA9IFN0cmluZy5wcm90b3R5cGUubWF0Y2g7XG52YXIgJHNsaWNlID0gU3RyaW5nLnByb3RvdHlwZS5zbGljZTtcbnZhciAkcmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcbnZhciAkdG9VcHBlckNhc2UgPSBTdHJpbmcucHJvdG90eXBlLnRvVXBwZXJDYXNlO1xudmFyICR0b0xvd2VyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2U7XG52YXIgJHRlc3QgPSBSZWdFeHAucHJvdG90eXBlLnRlc3Q7XG52YXIgJGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgJGpvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbjtcbnZhciAkYXJyU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgJGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBiaWdJbnRWYWx1ZU9mID0gdHlwZW9mIEJpZ0ludCA9PT0gJ2Z1bmN0aW9uJyA/IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZiA6IG51bGw7XG52YXIgZ09QUyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgc3ltVG9TdHJpbmcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnID8gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyA6IG51bGw7XG52YXIgaGFzU2hhbW1lZFN5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdvYmplY3QnO1xuLy8gaWUsIGBoYXMtdG9zdHJpbmd0YWcvc2hhbXNcbnZhciB0b1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSBoYXNTaGFtbWVkU3ltYm9scyA/ICdvYmplY3QnIDogJ3N5bWJvbCcpXG4gICAgPyBTeW1ib2wudG9TdHJpbmdUYWdcbiAgICA6IG51bGw7XG52YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIGdQTyA9ICh0eXBlb2YgUmVmbGVjdCA9PT0gJ2Z1bmN0aW9uJyA/IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YgOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHx8IChcbiAgICBbXS5fX3Byb3RvX18gPT09IEFycmF5LnByb3RvdHlwZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG4gICAgICAgID8gZnVuY3Rpb24gKE8pIHtcbiAgICAgICAgICAgIHJldHVybiBPLl9fcHJvdG9fXzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuICAgICAgICB9XG4gICAgICAgIDogbnVsbFxuKTtcblxuZnVuY3Rpb24gYWRkTnVtZXJpY1NlcGFyYXRvcihudW0sIHN0cikge1xuICAgIGlmIChcbiAgICAgICAgbnVtID09PSBJbmZpbml0eVxuICAgICAgICB8fCBudW0gPT09IC1JbmZpbml0eVxuICAgICAgICB8fCBudW0gIT09IG51bVxuICAgICAgICB8fCAobnVtICYmIG51bSA+IC0xMDAwICYmIG51bSA8IDEwMDApXG4gICAgICAgIHx8ICR0ZXN0LmNhbGwoL2UvLCBzdHIpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHZhciBzZXBSZWdleCA9IC9bMC05XSg/PSg/OlswLTldezN9KSsoPyFbMC05XSkpL2c7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBpbnQgPSBudW0gPCAwID8gLSRmbG9vcigtbnVtKSA6ICRmbG9vcihudW0pOyAvLyB0cnVuYyhudW0pXG4gICAgICAgIGlmIChpbnQgIT09IG51bSkge1xuICAgICAgICAgICAgdmFyIGludFN0ciA9IFN0cmluZyhpbnQpO1xuICAgICAgICAgICAgdmFyIGRlYyA9ICRzbGljZS5jYWxsKHN0ciwgaW50U3RyLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuICRyZXBsYWNlLmNhbGwoaW50U3RyLCBzZXBSZWdleCwgJyQmXycpICsgJy4nICsgJHJlcGxhY2UuY2FsbCgkcmVwbGFjZS5jYWxsKGRlYywgLyhbMC05XXszfSkvZywgJyQmXycpLCAvXyQvLCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwoc3RyLCBzZXBSZWdleCwgJyQmXycpO1xufVxuXG52YXIgdXRpbEluc3BlY3QgPSByZXF1aXJlKCcuL3V0aWwuaW5zcGVjdCcpO1xudmFyIGluc3BlY3RDdXN0b20gPSB1dGlsSW5zcGVjdC5jdXN0b207XG52YXIgaW5zcGVjdFN5bWJvbCA9IGlzU3ltYm9sKGluc3BlY3RDdXN0b20pID8gaW5zcGVjdEN1c3RvbSA6IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5zcGVjdF8ob2JqLCBvcHRpb25zLCBkZXB0aCwgc2Vlbikge1xuICAgIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChoYXMob3B0cywgJ3F1b3RlU3R5bGUnKSAmJiAob3B0cy5xdW90ZVN0eWxlICE9PSAnc2luZ2xlJyAmJiBvcHRzLnF1b3RlU3R5bGUgIT09ICdkb3VibGUnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJxdW90ZVN0eWxlXCIgbXVzdCBiZSBcInNpbmdsZVwiIG9yIFwiZG91YmxlXCInKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ21heFN0cmluZ0xlbmd0aCcpICYmICh0eXBlb2Ygb3B0cy5tYXhTdHJpbmdMZW5ndGggPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IG9wdHMubWF4U3RyaW5nTGVuZ3RoIDwgMCAmJiBvcHRzLm1heFN0cmluZ0xlbmd0aCAhPT0gSW5maW5pdHlcbiAgICAgICAgICAgIDogb3B0cy5tYXhTdHJpbmdMZW5ndGggIT09IG51bGxcbiAgICAgICAgKVxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJtYXhTdHJpbmdMZW5ndGhcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBJbmZpbml0eSwgb3IgYG51bGxgJyk7XG4gICAgfVxuICAgIHZhciBjdXN0b21JbnNwZWN0ID0gaGFzKG9wdHMsICdjdXN0b21JbnNwZWN0JykgPyBvcHRzLmN1c3RvbUluc3BlY3QgOiB0cnVlO1xuICAgIGlmICh0eXBlb2YgY3VzdG9tSW5zcGVjdCAhPT0gJ2Jvb2xlYW4nICYmIGN1c3RvbUluc3BlY3QgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcImN1c3RvbUluc3BlY3RcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYHRydWVgLCBgZmFsc2VgLCBvciBgXFwnc3ltYm9sXFwnYCcpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICAgaGFzKG9wdHMsICdpbmRlbnQnKVxuICAgICAgICAmJiBvcHRzLmluZGVudCAhPT0gbnVsbFxuICAgICAgICAmJiBvcHRzLmluZGVudCAhPT0gJ1xcdCdcbiAgICAgICAgJiYgIShwYXJzZUludChvcHRzLmluZGVudCwgMTApID09PSBvcHRzLmluZGVudCAmJiBvcHRzLmluZGVudCA+IDApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcImluZGVudFwiIG11c3QgYmUgXCJcXFxcdFwiLCBhbiBpbnRlZ2VyID4gMCwgb3IgYG51bGxgJyk7XG4gICAgfVxuICAgIGlmIChoYXMob3B0cywgJ251bWVyaWNTZXBhcmF0b3InKSAmJiB0eXBlb2Ygb3B0cy5udW1lcmljU2VwYXJhdG9yICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwibnVtZXJpY1NlcGFyYXRvclwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBgdHJ1ZWAgb3IgYGZhbHNlYCcpO1xuICAgIH1cbiAgICB2YXIgbnVtZXJpY1NlcGFyYXRvciA9IG9wdHMubnVtZXJpY1NlcGFyYXRvcjtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gb2JqID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGluc3BlY3RTdHJpbmcob2JqLCBvcHRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChvYmogPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eSAvIG9iaiA+IDAgPyAnMCcgOiAnLTAnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHIgPSBTdHJpbmcob2JqKTtcbiAgICAgICAgcmV0dXJuIG51bWVyaWNTZXBhcmF0b3IgPyBhZGROdW1lcmljU2VwYXJhdG9yKG9iaiwgc3RyKSA6IHN0cjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHZhciBiaWdJbnRTdHIgPSBTdHJpbmcob2JqKSArICduJztcbiAgICAgICAgcmV0dXJuIG51bWVyaWNTZXBhcmF0b3IgPyBhZGROdW1lcmljU2VwYXJhdG9yKG9iaiwgYmlnSW50U3RyKSA6IGJpZ0ludFN0cjtcbiAgICB9XG5cbiAgICB2YXIgbWF4RGVwdGggPSB0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyA1IDogb3B0cy5kZXB0aDtcbiAgICBpZiAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJykgeyBkZXB0aCA9IDA7IH1cbiAgICBpZiAoZGVwdGggPj0gbWF4RGVwdGggJiYgbWF4RGVwdGggPiAwICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KG9iaikgPyAnW0FycmF5XScgOiAnW09iamVjdF0nO1xuICAgIH1cblxuICAgIHZhciBpbmRlbnQgPSBnZXRJbmRlbnQob3B0cywgZGVwdGgpO1xuXG4gICAgaWYgKHR5cGVvZiBzZWVuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWVuID0gW107XG4gICAgfSBlbHNlIGlmIChpbmRleE9mKHNlZW4sIG9iaikgPj0gMCkge1xuICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3BlY3QodmFsdWUsIGZyb20sIG5vSW5kZW50KSB7XG4gICAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgICAgICBzZWVuID0gJGFyclNsaWNlLmNhbGwoc2Vlbik7XG4gICAgICAgICAgICBzZWVuLnB1c2goZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vSW5kZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV3T3B0cyA9IHtcbiAgICAgICAgICAgICAgICBkZXB0aDogb3B0cy5kZXB0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoYXMob3B0cywgJ3F1b3RlU3R5bGUnKSkge1xuICAgICAgICAgICAgICAgIG5ld09wdHMucXVvdGVTdHlsZSA9IG9wdHMucXVvdGVTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgbmV3T3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zcGVjdF8odmFsdWUsIG9wdHMsIGRlcHRoICsgMSwgc2Vlbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgJiYgIWlzUmVnRXhwKG9iaikpIHsgLy8gaW4gb2xkZXIgZW5naW5lcywgcmVnZXhlcyBhcmUgY2FsbGFibGVcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lT2Yob2JqKTtcbiAgICAgICAgdmFyIGtleXMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIHJldHVybiAnW0Z1bmN0aW9uJyArIChuYW1lID8gJzogJyArIG5hbWUgOiAnIChhbm9ueW1vdXMpJykgKyAnXScgKyAoa2V5cy5sZW5ndGggPiAwID8gJyB7ICcgKyAkam9pbi5jYWxsKGtleXMsICcsICcpICsgJyB9JyA6ICcnKTtcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKG9iaikpIHtcbiAgICAgICAgdmFyIHN5bVN0cmluZyA9IGhhc1NoYW1tZWRTeW1ib2xzID8gJHJlcGxhY2UuY2FsbChTdHJpbmcob2JqKSwgL14oU3ltYm9sXFwoLipcXCkpX1teKV0qJC8sICckMScpIDogc3ltVG9TdHJpbmcuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWhhc1NoYW1tZWRTeW1ib2xzID8gbWFya0JveGVkKHN5bVN0cmluZykgOiBzeW1TdHJpbmc7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQob2JqKSkge1xuICAgICAgICB2YXIgcyA9ICc8JyArICR0b0xvd2VyQ2FzZS5jYWxsKFN0cmluZyhvYmoubm9kZU5hbWUpKTtcbiAgICAgICAgdmFyIGF0dHJzID0gb2JqLmF0dHJpYnV0ZXMgfHwgW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHMgKz0gJyAnICsgYXR0cnNbaV0ubmFtZSArICc9JyArIHdyYXBRdW90ZXMocXVvdGUoYXR0cnNbaV0udmFsdWUpLCAnZG91YmxlJywgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSAnPic7XG4gICAgICAgIGlmIChvYmouY2hpbGROb2RlcyAmJiBvYmouY2hpbGROb2Rlcy5sZW5ndGgpIHsgcyArPSAnLi4uJzsgfVxuICAgICAgICBzICs9ICc8LycgKyAkdG9Mb3dlckNhc2UuY2FsbChTdHJpbmcob2JqLm5vZGVOYW1lKSkgKyAnPic7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAwKSB7IHJldHVybiAnW10nOyB9XG4gICAgICAgIHZhciB4cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgaWYgKGluZGVudCAmJiAhc2luZ2xlTGluZVZhbHVlcyh4cykpIHtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBpbmRlbnRlZEpvaW4oeHMsIGluZGVudCkgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdbICcgKyAkam9pbi5jYWxsKHhzLCAnLCAnKSArICcgXSc7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKG9iaikpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICBpZiAoISgnY2F1c2UnIGluIEVycm9yLnByb3RvdHlwZSkgJiYgJ2NhdXNlJyBpbiBvYmogJiYgIWlzRW51bWVyYWJsZS5jYWxsKG9iaiwgJ2NhdXNlJykpIHtcbiAgICAgICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArICRqb2luLmNhbGwoJGNvbmNhdC5jYWxsKCdbY2F1c2VdOiAnICsgaW5zcGVjdChvYmouY2F1c2UpLCBwYXJ0cyksICcsICcpICsgJyB9JztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnWycgKyBTdHJpbmcob2JqKSArICddJzsgfVxuICAgICAgICByZXR1cm4gJ3sgWycgKyBTdHJpbmcob2JqKSArICddICcgKyAkam9pbi5jYWxsKHBhcnRzLCAnLCAnKSArICcgfSc7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBjdXN0b21JbnNwZWN0KSB7XG4gICAgICAgIGlmIChpbnNwZWN0U3ltYm9sICYmIHR5cGVvZiBvYmpbaW5zcGVjdFN5bWJvbF0gPT09ICdmdW5jdGlvbicgJiYgdXRpbEluc3BlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsSW5zcGVjdChvYmosIHsgZGVwdGg6IG1heERlcHRoIC0gZGVwdGggfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcgJiYgdHlwZW9mIG9iai5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmluc3BlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNNYXAob2JqKSkge1xuICAgICAgICB2YXIgbWFwUGFydHMgPSBbXTtcbiAgICAgICAgbWFwRm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIG1hcFBhcnRzLnB1c2goaW5zcGVjdChrZXksIG9iaiwgdHJ1ZSkgKyAnID0+ICcgKyBpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ01hcCcsIG1hcFNpemUuY2FsbChvYmopLCBtYXBQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzU2V0KG9iaikpIHtcbiAgICAgICAgdmFyIHNldFBhcnRzID0gW107XG4gICAgICAgIHNldEZvckVhY2guY2FsbChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0UGFydHMucHVzaChpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ1NldCcsIHNldFNpemUuY2FsbChvYmopLCBzZXRQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha01hcChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrTWFwJyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtTZXQob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1NldCcpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrUmVmKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtSZWYnKTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KE51bWJlcihvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0JpZ0ludChvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoaXNCb29sZWFuKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChib29sZWFuVmFsdWVPZi5jYWxsKG9iaikpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoU3RyaW5nKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKCFpc0RhdGUob2JqKSAmJiAhaXNSZWdFeHAob2JqKSkge1xuICAgICAgICB2YXIgeXMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIHZhciBpc1BsYWluT2JqZWN0ID0gZ1BPID8gZ1BPKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGUgOiBvYmogaW5zdGFuY2VvZiBPYmplY3QgfHwgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgICAgIHZhciBwcm90b1RhZyA9IG9iaiBpbnN0YW5jZW9mIE9iamVjdCA/ICcnIDogJ251bGwgcHJvdG90eXBlJztcbiAgICAgICAgdmFyIHN0cmluZ1RhZyA9ICFpc1BsYWluT2JqZWN0ICYmIHRvU3RyaW5nVGFnICYmIE9iamVjdChvYmopID09PSBvYmogJiYgdG9TdHJpbmdUYWcgaW4gb2JqID8gJHNsaWNlLmNhbGwodG9TdHIob2JqKSwgOCwgLTEpIDogcHJvdG9UYWcgPyAnT2JqZWN0JyA6ICcnO1xuICAgICAgICB2YXIgY29uc3RydWN0b3JUYWcgPSBpc1BsYWluT2JqZWN0IHx8IHR5cGVvZiBvYmouY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgPyAnJyA6IG9iai5jb25zdHJ1Y3Rvci5uYW1lID8gb2JqLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgOiAnJztcbiAgICAgICAgdmFyIHRhZyA9IGNvbnN0cnVjdG9yVGFnICsgKHN0cmluZ1RhZyB8fCBwcm90b1RhZyA/ICdbJyArICRqb2luLmNhbGwoJGNvbmNhdC5jYWxsKFtdLCBzdHJpbmdUYWcgfHwgW10sIHByb3RvVGFnIHx8IFtdKSwgJzogJykgKyAnXSAnIDogJycpO1xuICAgICAgICBpZiAoeXMubGVuZ3RoID09PSAwKSB7IHJldHVybiB0YWcgKyAne30nOyB9XG4gICAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcgKyAneycgKyBpbmRlbnRlZEpvaW4oeXMsIGluZGVudCkgKyAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZyArICd7ICcgKyAkam9pbi5jYWxsKHlzLCAnLCAnKSArICcgfSc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcob2JqKTtcbn07XG5cbmZ1bmN0aW9uIHdyYXBRdW90ZXMocywgZGVmYXVsdFN0eWxlLCBvcHRzKSB7XG4gICAgdmFyIHF1b3RlQ2hhciA9IChvcHRzLnF1b3RlU3R5bGUgfHwgZGVmYXVsdFN0eWxlKSA9PT0gJ2RvdWJsZScgPyAnXCInIDogXCInXCI7XG4gICAgcmV0dXJuIHF1b3RlQ2hhciArIHMgKyBxdW90ZUNoYXI7XG59XG5cbmZ1bmN0aW9uIHF1b3RlKHMpIHtcbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChTdHJpbmcocyksIC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBBcnJheV0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNEYXRlKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBSZWdFeHBdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBFcnJvcl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBTdHJpbmddJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBCb29sZWFuXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5cbi8vIFN5bWJvbCBhbmQgQmlnSW50IGRvIGhhdmUgU3ltYm9sLnRvU3RyaW5nVGFnIGJ5IHNwZWMsIHNvIHRoYXQgY2FuJ3QgYmUgdXNlZCB0byBlbGltaW5hdGUgZmFsc2UgcG9zaXRpdmVzXG5mdW5jdGlvbiBpc1N5bWJvbChvYmopIHtcbiAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMpIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogaW5zdGFuY2VvZiBTeW1ib2w7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgIXN5bVRvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc3ltVG9TdHJpbmcuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCaWdJbnQob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgIWJpZ0ludFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSBpbiB0aGlzOyB9O1xuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn1cblxuZnVuY3Rpb24gdG9TdHIob2JqKSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gbmFtZU9mKGYpIHtcbiAgICBpZiAoZi5uYW1lKSB7IHJldHVybiBmLm5hbWU7IH1cbiAgICB2YXIgbSA9ICRtYXRjaC5jYWxsKGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChmKSwgL15mdW5jdGlvblxccyooW1xcdyRdKykvKTtcbiAgICBpZiAobSkgeyByZXR1cm4gbVsxXTsgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHsgcmV0dXJuIHhzLmluZGV4T2YoeCk7IH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHsgcmV0dXJuIGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBpc01hcCh4KSB7XG4gICAgaWYgKCFtYXBTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtNYXAoeCkge1xuICAgIGlmICghd2Vha01hcEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha01hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha1JlZih4KSB7XG4gICAgaWYgKCF3ZWFrUmVmRGVyZWYgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha1JlZkRlcmVmLmNhbGwoeCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1NldCh4KSB7XG4gICAgaWYgKCFzZXRTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtTZXQoeCkge1xuICAgIGlmICghd2Vha1NldEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha1NldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCh4KSB7XG4gICAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHguZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0U3RyaW5nKHN0ciwgb3B0cykge1xuICAgIGlmIChzdHIubGVuZ3RoID4gb3B0cy5tYXhTdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHN0ci5sZW5ndGggLSBvcHRzLm1heFN0cmluZ0xlbmd0aDtcbiAgICAgICAgdmFyIHRyYWlsZXIgPSAnLi4uICcgKyByZW1haW5pbmcgKyAnIG1vcmUgY2hhcmFjdGVyJyArIChyZW1haW5pbmcgPiAxID8gJ3MnIDogJycpO1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZygkc2xpY2UuY2FsbChzdHIsIDAsIG9wdHMubWF4U3RyaW5nTGVuZ3RoKSwgb3B0cykgKyB0cmFpbGVyO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIHZhciBzID0gJHJlcGxhY2UuY2FsbCgkcmVwbGFjZS5jYWxsKHN0ciwgLyhbJ1xcXFxdKS9nLCAnXFxcXCQxJyksIC9bXFx4MDAtXFx4MWZdL2csIGxvd2J5dGUpO1xuICAgIHJldHVybiB3cmFwUXVvdGVzKHMsICdzaW5nbGUnLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gbG93Ynl0ZShjKSB7XG4gICAgdmFyIG4gPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHggPSB7XG4gICAgICAgIDg6ICdiJyxcbiAgICAgICAgOTogJ3QnLFxuICAgICAgICAxMDogJ24nLFxuICAgICAgICAxMjogJ2YnLFxuICAgICAgICAxMzogJ3InXG4gICAgfVtuXTtcbiAgICBpZiAoeCkgeyByZXR1cm4gJ1xcXFwnICsgeDsgfVxuICAgIHJldHVybiAnXFxcXHgnICsgKG4gPCAweDEwID8gJzAnIDogJycpICsgJHRvVXBwZXJDYXNlLmNhbGwobi50b1N0cmluZygxNikpO1xufVxuXG5mdW5jdGlvbiBtYXJrQm94ZWQoc3RyKSB7XG4gICAgcmV0dXJuICdPYmplY3QoJyArIHN0ciArICcpJztcbn1cblxuZnVuY3Rpb24gd2Vha0NvbGxlY3Rpb25PZih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgKyAnIHsgPyB9Jztcbn1cblxuZnVuY3Rpb24gY29sbGVjdGlvbk9mKHR5cGUsIHNpemUsIGVudHJpZXMsIGluZGVudCkge1xuICAgIHZhciBqb2luZWRFbnRyaWVzID0gaW5kZW50ID8gaW5kZW50ZWRKb2luKGVudHJpZXMsIGluZGVudCkgOiAkam9pbi5jYWxsKGVudHJpZXMsICcsICcpO1xuICAgIHJldHVybiB0eXBlICsgJyAoJyArIHNpemUgKyAnKSB7JyArIGpvaW5lZEVudHJpZXMgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZUxpbmVWYWx1ZXMoeHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhzW2ldLCAnXFxuJykgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRlbnQob3B0cywgZGVwdGgpIHtcbiAgICB2YXIgYmFzZUluZGVudDtcbiAgICBpZiAob3B0cy5pbmRlbnQgPT09ICdcXHQnKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAnXFx0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmluZGVudCA9PT0gJ251bWJlcicgJiYgb3B0cy5pbmRlbnQgPiAwKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAkam9pbi5jYWxsKEFycmF5KG9wdHMuaW5kZW50ICsgMSksICcgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IGJhc2VJbmRlbnQsXG4gICAgICAgIHByZXY6ICRqb2luLmNhbGwoQXJyYXkoZGVwdGggKyAxKSwgYmFzZUluZGVudClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbmRlbnRlZEpvaW4oeHMsIGluZGVudCkge1xuICAgIGlmICh4cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnOyB9XG4gICAgdmFyIGxpbmVKb2luZXIgPSAnXFxuJyArIGluZGVudC5wcmV2ICsgaW5kZW50LmJhc2U7XG4gICAgcmV0dXJuIGxpbmVKb2luZXIgKyAkam9pbi5jYWxsKHhzLCAnLCcgKyBsaW5lSm9pbmVyKSArICdcXG4nICsgaW5kZW50LnByZXY7XG59XG5cbmZ1bmN0aW9uIGFyck9iaktleXMob2JqLCBpbnNwZWN0KSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmopO1xuICAgIHZhciB4cyA9IFtdO1xuICAgIGlmIChpc0Fycikge1xuICAgICAgICB4cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHNbaV0gPSBoYXMob2JqLCBpKSA/IGluc3BlY3Qob2JqW2ldLCBvYmopIDogJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN5bXMgPSB0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJyA/IGdPUFMob2JqKSA6IFtdO1xuICAgIHZhciBzeW1NYXA7XG4gICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzKSB7XG4gICAgICAgIHN5bU1hcCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHN5bXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHN5bU1hcFsnJCcgKyBzeW1zW2tdXSA9IHN5bXNba107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgaWYgKCFoYXMob2JqLCBrZXkpKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIGlmIChpc0FyciAmJiBTdHJpbmcoTnVtYmVyKGtleSkpID09PSBrZXkgJiYga2V5IDwgb2JqLmxlbmd0aCkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMgJiYgc3ltTWFwWyckJyArIGtleV0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcHJldmVudCBzaGFtbWVkIFN5bWJvbHMsIHdoaWNoIGFyZSBzdG9yZWQgYXMgc3RyaW5ncywgZnJvbSBiZWluZyBpbmNsdWRlZCBpbiB0aGUgc3RyaW5nIGtleSBzZWN0aW9uXG4gICAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmICgkdGVzdC5jYWxsKC9bXlxcdyRdLywga2V5KSkge1xuICAgICAgICAgICAgeHMucHVzaChpbnNwZWN0KGtleSwgb2JqKSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhzLnB1c2goa2V5ICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN5bXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpc0VudW1lcmFibGUuY2FsbChvYmosIHN5bXNbal0pKSB7XG4gICAgICAgICAgICAgICAgeHMucHVzaCgnWycgKyBpbnNwZWN0KHN5bXNbal0pICsgJ106ICcgKyBpbnNwZWN0KG9ialtzeW1zW2pdXSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcbnZhciBwZXJjZW50VHdlbnRpZXMgPSAvJTIwL2c7XG5cbnZhciBGb3JtYXQgPSB7XG4gICAgUkZDMTczODogJ1JGQzE3MzgnLFxuICAgIFJGQzM5ODY6ICdSRkMzOTg2J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2RlZmF1bHQnOiBGb3JtYXQuUkZDMzk4NixcbiAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgIFJGQzE3Mzg6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UuY2FsbCh2YWx1ZSwgcGVyY2VudFR3ZW50aWVzLCAnKycpO1xuICAgICAgICB9LFxuICAgICAgICBSRkMzOTg2OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBSRkMxNzM4OiBGb3JtYXQuUkZDMTczOCxcbiAgICBSRkMzOTg2OiBGb3JtYXQuUkZDMzk4NlxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmb3JtYXRzOiBmb3JtYXRzLFxuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGRlZmF1bHRzID0ge1xuICAgIGFsbG93RG90czogZmFsc2UsXG4gICAgYWxsb3dQcm90b3R5cGVzOiBmYWxzZSxcbiAgICBhbGxvd1NwYXJzZTogZmFsc2UsXG4gICAgYXJyYXlMaW1pdDogMjAsXG4gICAgY2hhcnNldDogJ3V0Zi04JyxcbiAgICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuICAgIGNvbW1hOiBmYWxzZSxcbiAgICBkZWNvZGVyOiB1dGlscy5kZWNvZGUsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgaWdub3JlUXVlcnlQcmVmaXg6IGZhbHNlLFxuICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogZmFsc2UsXG4gICAgcGFyYW1ldGVyTGltaXQ6IDEwMDAsXG4gICAgcGFyc2VBcnJheXM6IHRydWUsXG4gICAgcGxhaW5PYmplY3RzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiMoXFxkKyk7L2csIGZ1bmN0aW9uICgkMCwgbnVtYmVyU3RyKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG51bWJlclN0ciwgMTApKTtcbiAgICB9KTtcbn07XG5cbnZhciBwYXJzZUFycmF5VmFsdWUgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmNvbW1hICYmIHZhbC5pbmRleE9mKCcsJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdmFsLnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIFRoaXMgaXMgd2hhdCBicm93c2VycyB3aWxsIHN1Ym1pdCB3aGVuIHRoZSDinJMgY2hhcmFjdGVyIG9jY3VycyBpbiBhblxuLy8gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIGJvZHkgYW5kIHRoZSBlbmNvZGluZyBvZiB0aGUgcGFnZSBjb250YWluaW5nXG4vLyB0aGUgZm9ybSBpcyBpc28tODg1OS0xLCBvciB3aGVuIHRoZSBzdWJtaXR0ZWQgZm9ybSBoYXMgYW4gYWNjZXB0LWNoYXJzZXRcbi8vIGF0dHJpYnV0ZSBvZiBpc28tODg1OS0xLiBQcmVzdW1hYmx5IGFsc28gd2l0aCBvdGhlciBjaGFyc2V0cyB0aGF0IGRvIG5vdCBjb250YWluXG4vLyB0aGUg4pyTIGNoYXJhY3Rlciwgc3VjaCBhcyB1cy1hc2NpaS5cbnZhciBpc29TZW50aW5lbCA9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpXG5cbi8vIFRoZXNlIGFyZSB0aGUgcGVyY2VudC1lbmNvZGVkIHV0Zi04IG9jdGV0cyByZXByZXNlbnRpbmcgYSBjaGVja21hcmssIGluZGljYXRpbmcgdGhhdCB0aGUgcmVxdWVzdCBhY3R1YWxseSBpcyB1dGYtOCBlbmNvZGVkLlxudmFyIGNoYXJzZXRTZW50aW5lbCA9ICd1dGY4PSVFMiU5QyU5Myc7IC8vIGVuY29kZVVSSUNvbXBvbmVudCgn4pyTJylcblxudmFyIHBhcnNlVmFsdWVzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ1ZhbHVlcyhzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIGNsZWFuU3RyID0gb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA/IHN0ci5yZXBsYWNlKC9eXFw/LywgJycpIDogc3RyO1xuICAgIHZhciBsaW1pdCA9IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdDtcbiAgICB2YXIgcGFydHMgPSBjbGVhblN0ci5zcGxpdChvcHRpb25zLmRlbGltaXRlciwgbGltaXQpO1xuICAgIHZhciBza2lwSW5kZXggPSAtMTsgLy8gS2VlcCB0cmFjayBvZiB3aGVyZSB0aGUgdXRmOCBzZW50aW5lbCB3YXMgZm91bmRcbiAgICB2YXIgaTtcblxuICAgIHZhciBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0O1xuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1tpXS5pbmRleE9mKCd1dGY4PScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzW2ldID09PSBjaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9ICd1dGYtOCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXSA9PT0gaXNvU2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9ICdpc28tODg1OS0xJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpID0gcGFydHMubGVuZ3RoOyAvLyBUaGUgZXNsaW50IHNldHRpbmdzIGRvIG5vdCBhbGxvdyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaSA9PT0gc2tpcEluZGV4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgIHZhciBicmFja2V0RXF1YWxzUG9zID0gcGFydC5pbmRleE9mKCddPScpO1xuICAgICAgICB2YXIgcG9zID0gYnJhY2tldEVxdWFsc1BvcyA9PT0gLTEgPyBwYXJ0LmluZGV4T2YoJz0nKSA6IGJyYWNrZXRFcXVhbHNQb3MgKyAxO1xuXG4gICAgICAgIHZhciBrZXksIHZhbDtcbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA/IG51bGwgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKDAsIHBvcyksIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHZhbCA9IHV0aWxzLm1heWJlTWFwKFxuICAgICAgICAgICAgICAgIHBhcnNlQXJyYXlWYWx1ZShwYXJ0LnNsaWNlKHBvcyArIDEpLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZW5jb2RlZFZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kZWNvZGVyKGVuY29kZWRWYWwsIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICd2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsICYmIG9wdGlvbnMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzICYmIGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAgICAgdmFsID0gaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzKHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydC5pbmRleE9mKCdbXT0nKSA+IC0xKSB7XG4gICAgICAgICAgICB2YWwgPSBpc0FycmF5KHZhbCkgPyBbdmFsXSA6IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdXRpbHMuY29tYmluZShvYmpba2V5XSwgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcbiAgICB2YXIgbGVhZiA9IHZhbHVlc1BhcnNlZCA/IHZhbCA6IHBhcnNlQXJyYXlWYWx1ZSh2YWwsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgaSA9IGNoYWluLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBvYmo7XG4gICAgICAgIHZhciByb290ID0gY2hhaW5baV07XG5cbiAgICAgICAgaWYgKHJvb3QgPT09ICdbXScgJiYgb3B0aW9ucy5wYXJzZUFycmF5cykge1xuICAgICAgICAgICAgb2JqID0gW10uY29uY2F0KGxlYWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wYXJzZUFycmF5cyAmJiBjbGVhblJvb3QgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgb2JqID0geyAwOiBsZWFmIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICFpc05hTihpbmRleClcbiAgICAgICAgICAgICAgICAmJiByb290ICE9PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBTdHJpbmcoaW5kZXgpID09PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBpbmRleCA+PSAwXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsZWFuUm9vdCAhPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgICAgICBvYmpbY2xlYW5Sb290XSA9IGxlYWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZWFmID0gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiBsZWFmO1xufTtcblxudmFyIHBhcnNlS2V5cyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdLZXlzKGdpdmVuS2V5LCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIGlmICghZ2l2ZW5LZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRyYW5zZm9ybSBkb3Qgbm90YXRpb24gdG8gYnJhY2tldCBub3RhdGlvblxuICAgIHZhciBrZXkgPSBvcHRpb25zLmFsbG93RG90cyA/IGdpdmVuS2V5LnJlcGxhY2UoL1xcLihbXi5bXSspL2csICdbJDFdJykgOiBnaXZlbktleTtcblxuICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuICAgIHZhciBicmFja2V0cyA9IC8oXFxbW15bXFxdXSpdKS87XG4gICAgdmFyIGNoaWxkID0gLyhcXFtbXltcXF1dKl0pL2c7XG5cbiAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG4gICAgdmFyIHNlZ21lbnQgPSBvcHRpb25zLmRlcHRoID4gMCAmJiBicmFja2V0cy5leGVjKGtleSk7XG4gICAgdmFyIHBhcmVudCA9IHNlZ21lbnQgPyBrZXkuc2xpY2UoMCwgc2VnbWVudC5pbmRleCkgOiBrZXk7XG5cbiAgICAvLyBTdGFzaCB0aGUgcGFyZW50IGlmIGl0IGV4aXN0c1xuXG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBwbGFpbiBvYmplY3RzLCBvcHRpb25hbGx5IHByZWZpeCBrZXlzIHRoYXQgd291bGQgb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLnB1c2gocGFyZW50KTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAob3B0aW9ucy5kZXB0aCA+IDAgJiYgKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzZWdtZW50WzFdLnNsaWNlKDEsIC0xKSkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSByZW1haW5kZXIsIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCk7XG59O1xuXG52YXIgbm9ybWFsaXplUGFyc2VPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplUGFyc2VPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmRlY29kZXIgIT09IG51bGwgJiYgb3B0cy5kZWNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgdmFyIGNoYXJzZXQgPSB0eXBlb2Ygb3B0cy5jaGFyc2V0ID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmNoYXJzZXQgOiBvcHRzLmNoYXJzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd0RvdHM6IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzLFxuICAgICAgICBhbGxvd1Byb3RvdHlwZXM6IHR5cGVvZiBvcHRzLmFsbG93UHJvdG90eXBlcyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hbGxvd1Byb3RvdHlwZXMgOiBkZWZhdWx0cy5hbGxvd1Byb3RvdHlwZXMsXG4gICAgICAgIGFsbG93U3BhcnNlOiB0eXBlb2Ygb3B0cy5hbGxvd1NwYXJzZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hbGxvd1NwYXJzZSA6IGRlZmF1bHRzLmFsbG93U3BhcnNlLFxuICAgICAgICBhcnJheUxpbWl0OiB0eXBlb2Ygb3B0cy5hcnJheUxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMuYXJyYXlMaW1pdCA6IGRlZmF1bHRzLmFycmF5TGltaXQsXG4gICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcbiAgICAgICAgY29tbWE6IHR5cGVvZiBvcHRzLmNvbW1hID09PSAnYm9vbGVhbicgPyBvcHRzLmNvbW1hIDogZGVmYXVsdHMuY29tbWEsXG4gICAgICAgIGRlY29kZXI6IHR5cGVvZiBvcHRzLmRlY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmRlY29kZXIgOiBkZWZhdWx0cy5kZWNvZGVyLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgdXRpbHMuaXNSZWdFeHAob3B0cy5kZWxpbWl0ZXIpID8gb3B0cy5kZWxpbWl0ZXIgOiBkZWZhdWx0cy5kZWxpbWl0ZXIsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvbiwgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgIGRlcHRoOiAodHlwZW9mIG9wdHMuZGVwdGggPT09ICdudW1iZXInIHx8IG9wdHMuZGVwdGggPT09IGZhbHNlKSA/ICtvcHRzLmRlcHRoIDogZGVmYXVsdHMuZGVwdGgsXG4gICAgICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBvcHRzLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlLFxuICAgICAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IHR5cGVvZiBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgOiBkZWZhdWx0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMsXG4gICAgICAgIHBhcmFtZXRlckxpbWl0OiB0eXBlb2Ygb3B0cy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLnBhcmFtZXRlckxpbWl0IDogZGVmYXVsdHMucGFyYW1ldGVyTGltaXQsXG4gICAgICAgIHBhcnNlQXJyYXlzOiBvcHRzLnBhcnNlQXJyYXlzICE9PSBmYWxzZSxcbiAgICAgICAgcGxhaW5PYmplY3RzOiB0eXBlb2Ygb3B0cy5wbGFpbk9iamVjdHMgPT09ICdib29sZWFuJyA/IG9wdHMucGxhaW5PYmplY3RzIDogZGVmYXVsdHMucGxhaW5PYmplY3RzLFxuICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmdcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cyk7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zLCB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XG4gICAgICAgIG9iaiA9IHV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd1NwYXJzZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0U2lkZUNoYW5uZWwgPSByZXF1aXJlKCdzaWRlLWNoYW5uZWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGFycmF5UHJlZml4R2VuZXJhdG9ycyA9IHtcbiAgICBicmFja2V0czogZnVuY3Rpb24gYnJhY2tldHMocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnW10nO1xuICAgIH0sXG4gICAgY29tbWE6ICdjb21tYScsXG4gICAgaW5kaWNlczogZnVuY3Rpb24gaW5kaWNlcyhwcmVmaXgsIGtleSkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1snICsga2V5ICsgJ10nO1xuICAgIH0sXG4gICAgcmVwZWF0OiBmdW5jdGlvbiByZXBlYXQocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfVxufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIHNwbGl0ID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdDtcbnZhciBwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG52YXIgcHVzaFRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB2YWx1ZU9yQXJyYXkpIHtcbiAgICBwdXNoLmFwcGx5KGFyciwgaXNBcnJheSh2YWx1ZU9yQXJyYXkpID8gdmFsdWVPckFycmF5IDogW3ZhbHVlT3JBcnJheV0pO1xufTtcblxudmFyIHRvSVNPID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBkZWZhdWx0Rm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xudmFyIGRlZmF1bHRzID0ge1xuICAgIGFkZFF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBlbmNvZGU6IHRydWUsXG4gICAgZW5jb2RlcjogdXRpbHMuZW5jb2RlLFxuICAgIGVuY29kZVZhbHVlc09ubHk6IGZhbHNlLFxuICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcbiAgICBmb3JtYXR0ZXI6IGZvcm1hdHMuZm9ybWF0dGVyc1tkZWZhdWx0Rm9ybWF0XSxcbiAgICAvLyBkZXByZWNhdGVkXG4gICAgaW5kaWNlczogZmFsc2UsXG4gICAgc2VyaWFsaXplRGF0ZTogZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKGRhdGUpO1xuICAgIH0sXG4gICAgc2tpcE51bGxzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgaXNOb25OdWxsaXNoUHJpbWl0aXZlID0gZnVuY3Rpb24gaXNOb25OdWxsaXNoUHJpbWl0aXZlKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnc3ltYm9sJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCc7XG59O1xuXG52YXIgc2VudGluZWwgPSB7fTtcblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShcbiAgICBvYmplY3QsXG4gICAgcHJlZml4LFxuICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgY29tbWFSb3VuZFRyaXAsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgIHNraXBOdWxscyxcbiAgICBlbmNvZGVyLFxuICAgIGZpbHRlcixcbiAgICBzb3J0LFxuICAgIGFsbG93RG90cyxcbiAgICBzZXJpYWxpemVEYXRlLFxuICAgIGZvcm1hdCxcbiAgICBmb3JtYXR0ZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICBjaGFyc2V0LFxuICAgIHNpZGVDaGFubmVsXG4pIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuXG4gICAgdmFyIHRtcFNjID0gc2lkZUNoYW5uZWw7XG4gICAgdmFyIHN0ZXAgPSAwO1xuICAgIHZhciBmaW5kRmxhZyA9IGZhbHNlO1xuICAgIHdoaWxlICgodG1wU2MgPSB0bXBTYy5nZXQoc2VudGluZWwpKSAhPT0gdm9pZCB1bmRlZmluZWQgJiYgIWZpbmRGbGFnKSB7XG4gICAgICAgIC8vIFdoZXJlIG9iamVjdCBsYXN0IGFwcGVhcmVkIGluIHRoZSByZWYgdHJlZVxuICAgICAgICB2YXIgcG9zID0gdG1wU2MuZ2V0KG9iamVjdCk7XG4gICAgICAgIHN0ZXAgKz0gMTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAocG9zID09PSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0N5Y2xpYyBvYmplY3QgdmFsdWUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluZEZsYWcgPSB0cnVlOyAvLyBCcmVhayB3aGlsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG1wU2MuZ2V0KHNlbnRpbmVsKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN0ZXAgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqID0gdXRpbHMubWF5YmVNYXAob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCkgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAoaXNOb25OdWxsaXNoUHJpbWl0aXZlKG9iaikgfHwgdXRpbHMuaXNCdWZmZXIob2JqKSkge1xuICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gZW5jb2RlVmFsdWVzT25seSA/IHByZWZpeCA6IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGVuY29kZVZhbHVlc09ubHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzQXJyYXkgPSBzcGxpdC5jYWxsKFN0cmluZyhvYmopLCAnLCcpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXNKb2luZWQgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc0pvaW5lZCArPSAoaSA9PT0gMCA/ICcnIDogJywnKSArIGZvcm1hdHRlcihlbmNvZGVyKHZhbHVlc0FycmF5W2ldLCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAndmFsdWUnLCBmb3JtYXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIoa2V5VmFsdWUpICsgKGNvbW1hUm91bmRUcmlwICYmIGlzQXJyYXkob2JqKSAmJiB2YWx1ZXNBcnJheS5sZW5ndGggPT09IDEgPyAnW10nIDogJycpICsgJz0nICsgdmFsdWVzSm9pbmVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKGtleVZhbHVlKSArICc9JyArIGZvcm1hdHRlcihlbmNvZGVyKG9iaiwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJywgZm9ybWF0KSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZm9ybWF0dGVyKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXIoU3RyaW5nKG9iaikpXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBqb2luIGVsZW1lbnRzIGluXG4gICAgICAgIG9iaktleXMgPSBbeyB2YWx1ZTogb2JqLmxlbmd0aCA+IDAgPyBvYmouam9pbignLCcpIHx8IG51bGwgOiB2b2lkIHVuZGVmaW5lZCB9XTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZmlsdGVyKSkge1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgb2JqS2V5cyA9IHNvcnQgPyBrZXlzLnNvcnQoc29ydCkgOiBrZXlzO1xuICAgIH1cblxuICAgIHZhciBhZGp1c3RlZFByZWZpeCA9IGNvbW1hUm91bmRUcmlwICYmIGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAxID8gcHJlZml4ICsgJ1tdJyA6IHByZWZpeDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqS2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tqXTtcbiAgICAgICAgdmFyIHZhbHVlID0gdHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyBrZXkudmFsdWUgOiBvYmpba2V5XTtcblxuICAgICAgICBpZiAoc2tpcE51bGxzICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlQcmVmaXggPSBpc0FycmF5KG9iailcbiAgICAgICAgICAgID8gdHlwZW9mIGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdmdW5jdGlvbicgPyBnZW5lcmF0ZUFycmF5UHJlZml4KGFkanVzdGVkUHJlZml4LCBrZXkpIDogYWRqdXN0ZWRQcmVmaXhcbiAgICAgICAgICAgIDogYWRqdXN0ZWRQcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsga2V5IDogJ1snICsga2V5ICsgJ10nKTtcblxuICAgICAgICBzaWRlQ2hhbm5lbC5zZXQob2JqZWN0LCBzdGVwKTtcbiAgICAgICAgdmFyIHZhbHVlU2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgICAgICB2YWx1ZVNpZGVDaGFubmVsLnNldChzZW50aW5lbCwgc2lkZUNoYW5uZWwpO1xuICAgICAgICBwdXNoVG9BcnJheSh2YWx1ZXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAga2V5UHJlZml4LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICBzZXJpYWxpemVEYXRlLFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgICAgIGNoYXJzZXQsXG4gICAgICAgICAgICB2YWx1ZVNpZGVDaGFubmVsXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG52YXIgbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZW5jb2RlciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRzLmNoYXJzZXQgfHwgZGVmYXVsdHMuY2hhcnNldDtcbiAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjaGFyc2V0IG9wdGlvbiBtdXN0IGJlIGVpdGhlciB1dGYtOCwgaXNvLTg4NTktMSwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcbiAgICBpZiAodHlwZW9mIG9wdHMuZm9ybWF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIWhhcy5jYWxsKGZvcm1hdHMuZm9ybWF0dGVycywgb3B0cy5mb3JtYXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gb3B0cy5mb3JtYXQ7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgIHZhciBmaWx0ZXIgPSBkZWZhdWx0cy5maWx0ZXI7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0FycmF5KG9wdHMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRzLmZpbHRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRRdWVyeVByZWZpeDogdHlwZW9mIG9wdHMuYWRkUXVlcnlQcmVmaXggPT09ICdib29sZWFuJyA/IG9wdHMuYWRkUXVlcnlQcmVmaXggOiBkZWZhdWx0cy5hZGRRdWVyeVByZWZpeCxcbiAgICAgICAgYWxsb3dEb3RzOiB0eXBlb2Ygb3B0cy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuYWxsb3dEb3RzIDogISFvcHRzLmFsbG93RG90cyxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRzLmRlbGltaXRlcixcbiAgICAgICAgZW5jb2RlOiB0eXBlb2Ygb3B0cy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlLFxuICAgICAgICBlbmNvZGVyOiB0eXBlb2Ygb3B0cy5lbmNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0cy5lbmNvZGVyIDogZGVmYXVsdHMuZW5jb2RlcixcbiAgICAgICAgZW5jb2RlVmFsdWVzT25seTogdHlwZW9mIG9wdHMuZW5jb2RlVmFsdWVzT25seSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGVWYWx1ZXNPbmx5IDogZGVmYXVsdHMuZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICAgICAgc2VyaWFsaXplRGF0ZTogdHlwZW9mIG9wdHMuc2VyaWFsaXplRGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc2VyaWFsaXplRGF0ZSA6IGRlZmF1bHRzLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgIHNraXBOdWxsczogdHlwZW9mIG9wdHMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRzLnNraXBOdWxscyA6IGRlZmF1bHRzLnNraXBOdWxscyxcbiAgICAgICAgc29ydDogdHlwZW9mIG9wdHMuc29ydCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc29ydCA6IG51bGwsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdHMpIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuICAgIHZhciBvcHRpb25zID0gbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyhvcHRzKTtcblxuICAgIHZhciBvYmpLZXlzO1xuICAgIHZhciBmaWx0ZXI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmogPSBmaWx0ZXIoJycsIG9iaik7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIGFycmF5Rm9ybWF0O1xuICAgIGlmIChvcHRzICYmIG9wdHMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5hcnJheUZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgJ2luZGljZXMnIGluIG9wdHMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmluZGljZXMgPyAnaW5kaWNlcycgOiAncmVwZWF0JztcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheUZvcm1hdCA9ICdpbmRpY2VzJztcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5UHJlZml4R2VuZXJhdG9yc1thcnJheUZvcm1hdF07XG4gICAgaWYgKG9wdHMgJiYgJ2NvbW1hUm91bmRUcmlwJyBpbiBvcHRzICYmIHR5cGVvZiBvcHRzLmNvbW1hUm91bmRUcmlwICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGNvbW1hUm91bmRUcmlwYCBtdXN0IGJlIGEgYm9vbGVhbiwgb3IgYWJzZW50Jyk7XG4gICAgfVxuICAgIHZhciBjb21tYVJvdW5kVHJpcCA9IGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgb3B0cyAmJiBvcHRzLmNvbW1hUm91bmRUcmlwO1xuXG4gICAgaWYgKCFvYmpLZXlzKSB7XG4gICAgICAgIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICAgICAgb2JqS2V5cy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gICAgfVxuXG4gICAgdmFyIHNpZGVDaGFubmVsID0gZ2V0U2lkZUNoYW5uZWwoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoVG9BcnJheShrZXlzLCBzdHJpbmdpZnkoXG4gICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICBjb21tYVJvdW5kVHJpcCxcbiAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgb3B0aW9ucy5za2lwTnVsbHMsXG4gICAgICAgICAgICBvcHRpb25zLmVuY29kZSA/IG9wdGlvbnMuZW5jb2RlciA6IG51bGwsXG4gICAgICAgICAgICBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgICAgIG9wdGlvbnMuc29ydCxcbiAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dEb3RzLFxuICAgICAgICAgICAgb3B0aW9ucy5zZXJpYWxpemVEYXRlLFxuICAgICAgICAgICAgb3B0aW9ucy5mb3JtYXQsXG4gICAgICAgICAgICBvcHRpb25zLmZvcm1hdHRlcixcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgICAgIG9wdGlvbnMuY2hhcnNldCxcbiAgICAgICAgICAgIHNpZGVDaGFubmVsXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBrZXlzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XG5cbiAgICBpZiAob3B0aW9ucy5jaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JyksIHRoZSBcIm51bWVyaWMgZW50aXR5XCIgcmVwcmVzZW50YXRpb24gb2YgYSBjaGVja21hcmtcbiAgICAgICAgICAgIHByZWZpeCArPSAndXRmOD0lMjYlMjMxMDAwMyUzQiYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSVFMiU5QyU5MyYnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGpvaW5lZC5sZW5ndGggPiAwID8gcHJlZml4ICsgam9pbmVkIDogJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGhleFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufSgpKTtcblxudmFyIGNvbXBhY3RRdWV1ZSA9IGZ1bmN0aW9uIGNvbXBhY3RRdWV1ZShxdWV1ZSkge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0ub2JqW2l0ZW0ucHJvcF0gPSBjb21wYWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgYXJyYXlUb09iamVjdCA9IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Qoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAvKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IDAgKi9cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKChvcHRpb25zICYmIChvcHRpb25zLnBsYWluT2JqZWN0cyB8fCBvcHRpb25zLmFsbG93UHJvdG90eXBlcykpIHx8ICFoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0YXJnZXQsIHNvdXJjZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiAhaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIG1lcmdlVGFyZ2V0ID0gYXJyYXlUb09iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwodGFyZ2V0LCBpKSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJdGVtID0gdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtICYmIHR5cGVvZiB0YXJnZXRJdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBtZXJnZSh0YXJnZXRJdGVtLCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBtZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG1lcmdlVGFyZ2V0KTtcbn07XG5cbnZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ25TaW5nbGVTb3VyY2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gc291cmNlW2tleV07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdGFyZ2V0KTtcbn07XG5cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiAoc3RyLCBkZWNvZGVyLCBjaGFyc2V0KSB7XG4gICAgdmFyIHN0cldpdGhvdXRQbHVzID0gc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgLy8gdW5lc2NhcGUgbmV2ZXIgdGhyb3dzLCBubyB0cnkuLi5jYXRjaCBuZWVkZWQ6XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cy5yZXBsYWNlKC8lWzAtOWEtZl17Mn0vZ2ksIHVuZXNjYXBlKTtcbiAgICB9XG4gICAgLy8gdXRmLThcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cldpdGhvdXRQbHVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cztcbiAgICB9XG59O1xuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHN0ciwgZGVmYXVsdEVuY29kZXIsIGNoYXJzZXQsIGtpbmQsIGZvcm1hdCkge1xuICAgIC8vIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEJyaWFuIFdoaXRlIChtc2NkZXgpIGZvciB0aGUgaW8uanMgY29yZSBxdWVyeXN0cmluZyBsaWJyYXJ5LlxuICAgIC8vIEl0IGhhcyBiZWVuIGFkYXB0ZWQgaGVyZSBmb3Igc3RyaWN0ZXIgYWRoZXJlbmNlIHRvIFJGQyAzOTg2XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gc3RyO1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3ltYm9sJykge1xuICAgICAgICBzdHJpbmcgPSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0cmluZyA9IFN0cmluZyhzdHIpO1xuICAgIH1cblxuICAgIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZShzdHJpbmcpLnJlcGxhY2UoLyV1WzAtOWEtZl17NH0vZ2ksIGZ1bmN0aW9uICgkMCkge1xuICAgICAgICAgICAgcmV0dXJuICclMjYlMjMnICsgcGFyc2VJbnQoJDAuc2xpY2UoMiksIDE2KSArICclM0InO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjID09PSAweDJEIC8vIC1cbiAgICAgICAgICAgIHx8IGMgPT09IDB4MkUgLy8gLlxuICAgICAgICAgICAgfHwgYyA9PT0gMHg1RiAvLyBfXG4gICAgICAgICAgICB8fCBjID09PSAweDdFIC8vIH5cbiAgICAgICAgICAgIHx8IChjID49IDB4MzAgJiYgYyA8PSAweDM5KSAvLyAwLTlcbiAgICAgICAgICAgIHx8IChjID49IDB4NDEgJiYgYyA8PSAweDVBKSAvLyBhLXpcbiAgICAgICAgICAgIHx8IChjID49IDB4NjEgJiYgYyA8PSAweDdBKSAvLyBBLVpcbiAgICAgICAgICAgIHx8IChmb3JtYXQgPT09IGZvcm1hdHMuUkZDMTczOCAmJiAoYyA9PT0gMHgyOCB8fCBjID09PSAweDI5KSkgLy8gKCApXG4gICAgICAgICkge1xuICAgICAgICAgICAgb3V0ICs9IHN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgaGV4VGFibGVbY107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEMwIHwgKGMgPj4gNildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+PSAweEUwMDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEUwIHwgKGMgPj4gMTIpXSArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgJiAweDNGRikpO1xuICAgICAgICAvKiBlc2xpbnQgb3BlcmF0b3ItbGluZWJyZWFrOiBbMiwgXCJiZWZvcmVcIl0gKi9cbiAgICAgICAgb3V0ICs9IGhleFRhYmxlWzB4RjAgfCAoYyA+PiAxOCldXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzRildXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG52YXIgY29tcGFjdCA9IGZ1bmN0aW9uIGNvbXBhY3QodmFsdWUpIHtcbiAgICB2YXIgcXVldWUgPSBbeyBvYmo6IHsgbzogdmFsdWUgfSwgcHJvcDogJ28nIH1dO1xuICAgIHZhciByZWZzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWVbaV07XG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgcmVmcy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh7IG9iajogb2JqLCBwcm9wOiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wYWN0UXVldWUocXVldWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGlzUmVnRXhwID0gZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn07XG5cbnZhciBpc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG59O1xuXG52YXIgY29tYmluZSA9IGZ1bmN0aW9uIGNvbWJpbmUoYSwgYikge1xuICAgIHJldHVybiBbXS5jb25jYXQoYSwgYik7XG59O1xuXG52YXIgbWF5YmVNYXAgPSBmdW5jdGlvbiBtYXliZU1hcCh2YWwsIGZuKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YXIgbWFwcGVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBtYXBwZWQucHVzaChmbih2YWxbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH1cbiAgICByZXR1cm4gZm4odmFsKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFycmF5VG9PYmplY3Q6IGFycmF5VG9PYmplY3QsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgY29tYmluZTogY29tYmluZSxcbiAgICBjb21wYWN0OiBjb21wYWN0LFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gICAgbWF5YmVNYXA6IG1heWJlTWFwLFxuICAgIG1lcmdlOiBtZXJnZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICRXZWFrTWFwID0gR2V0SW50cmluc2ljKCclV2Vha01hcCUnLCB0cnVlKTtcbnZhciAkTWFwID0gR2V0SW50cmluc2ljKCclTWFwJScsIHRydWUpO1xuXG52YXIgJHdlYWtNYXBHZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xudmFyICR3ZWFrTWFwU2V0ID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5zZXQnLCB0cnVlKTtcbnZhciAkd2Vha01hcEhhcyA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG52YXIgJG1hcEdldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbnZhciAkbWFwU2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xudmFyICRtYXBIYXMgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aGUgbGlzdCByZXR1cm5pbmcgdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byB0aGVcbiAqIGdpdmVuIGtleS5cbiAqXG4gKiBUaGF0IG5vZGUgaXMgYWxzbyBtb3ZlZCB0byB0aGUgaGVhZCBvZiB0aGUgbGlzdCwgc28gdGhhdCBpZiBpdCdzIGFjY2Vzc2VkXG4gKiBhZ2FpbiB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSB3aG9sZSBsaXN0LiBCeSBkb2luZyBzbywgYWxsIHRoZSByZWNlbnRseVxuICogdXNlZCBub2RlcyBjYW4gYmUgYWNjZXNzZWQgcmVsYXRpdmVseSBxdWlja2x5LlxuICovXG52YXIgbGlzdEdldE5vZGUgPSBmdW5jdGlvbiAobGlzdCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0Zm9yICh2YXIgcHJldiA9IGxpc3QsIGN1cnI7IChjdXJyID0gcHJldi5uZXh0KSAhPT0gbnVsbDsgcHJldiA9IGN1cnIpIHtcblx0XHRpZiAoY3Vyci5rZXkgPT09IGtleSkge1xuXHRcdFx0cHJldi5uZXh0ID0gY3Vyci5uZXh0O1xuXHRcdFx0Y3Vyci5uZXh0ID0gbGlzdC5uZXh0O1xuXHRcdFx0bGlzdC5uZXh0ID0gY3VycjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdFx0cmV0dXJuIGN1cnI7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgbGlzdEdldCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlO1xufTtcbnZhciBsaXN0U2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSwgdmFsdWUpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRpZiAobm9kZSkge1xuXHRcdG5vZGUudmFsdWUgPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHQvLyBQcmVwZW5kIHRoZSBuZXcgbm9kZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cdFx0b2JqZWN0cy5uZXh0ID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0XHRrZXk6IGtleSxcblx0XHRcdG5leHQ6IG9iamVjdHMubmV4dCxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cbn07XG52YXIgbGlzdEhhcyA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0cmV0dXJuICEhbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2lkZUNoYW5uZWwoKSB7XG5cdHZhciAkd207XG5cdHZhciAkbTtcblx0dmFyICRvO1xuXHR2YXIgY2hhbm5lbCA9IHtcblx0XHRhc3NlcnQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmICghY2hhbm5lbC5oYXMoa2V5KSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignU2lkZSBjaGFubmVsIGRvZXMgbm90IGNvbnRhaW4gJyArIGluc3BlY3Qoa2V5KSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXQ6IGZ1bmN0aW9uIChrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCR3bSkge1xuXHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEdldCgkd20sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEdldCgkbSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCRvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmXG5cdFx0XHRcdFx0cmV0dXJuIGxpc3RHZXQoJG8sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhczogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCR3bSkge1xuXHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEhhcygkd20sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEhhcygkbSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCRvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmXG5cdFx0XHRcdFx0cmV0dXJuIGxpc3RIYXMoJG8sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdGlmICghJHdtKSB7XG5cdFx0XHRcdFx0JHdtID0gbmV3ICRXZWFrTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JHdlYWtNYXBTZXQoJHdtLCBrZXksIHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoISRtKSB7XG5cdFx0XHRcdFx0JG0gPSBuZXcgJE1hcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCRtYXBTZXQoJG0sIGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCEkbykge1xuXHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0ICogSW5pdGlhbGl6ZSB0aGUgbGlua2VkIGxpc3QgYXMgYW4gZW1wdHkgbm9kZSwgc28gdGhhdCB3ZSBkb24ndCBoYXZlXG5cdFx0XHRcdFx0ICogdG8gc3BlY2lhbC1jYXNlIGhhbmRsaW5nIG9mIHRoZSBmaXJzdCBub2RlOiB3ZSBjYW4gYWx3YXlzIHJlZmVyIHRvXG5cdFx0XHRcdFx0ICogaXQgYXMgKHByZXZpb3VzIG5vZGUpLm5leHQsIGluc3RlYWQgb2Ygc29tZXRoaW5nIGxpa2UgKGxpc3QpLmhlYWRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHQkbyA9IHsga2V5OiB7fSwgbmV4dDogbnVsbCB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3RTZXQoJG8sIGtleSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGNoYW5uZWw7XG59O1xuIiwiZXhwb3J0IHsgZGVmYXVsdCBhcyB2MSB9IGZyb20gJy4vdjEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MyB9IGZyb20gJy4vdjMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NCB9IGZyb20gJy4vdjQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NSB9IGZyb20gJy4vdjUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOSUwgfSBmcm9tICcuL25pbC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2YWxpZGF0ZSB9IGZyb20gJy4vdmFsaWRhdGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlIH0gZnJvbSAnLi9wYXJzZS5qcyc7IiwiLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtc2cubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlc1tpXSA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZDVUb0hleEVuY29kZWRBcnJheSh3b3Jkc1RvTWQ1KGJ5dGVzVG9Xb3JkcyhieXRlcyksIGJ5dGVzLmxlbmd0aCAqIDgpKTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYW4gYXJyYXkgb2YgYnl0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNVRvSGV4RW5jb2RlZEFycmF5KGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgdmFyIGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIHZhciBoZXhUYWIgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgzMjsgaSArPSA4KSB7XG4gICAgdmFyIHggPSBpbnB1dFtpID4+IDVdID4+PiBpICUgMzIgJiAweGZmO1xuICAgIHZhciBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIHZhciBhID0gMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2ldLCA3LCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgNF0sIDcsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNywgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTVdLCAyMiwgMTIzNjUzNTMyOSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA1LCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNSwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgOSwgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgOV0sIDUsIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDE0XSwgOSwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA4XSwgMjAsIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMl0sIDksIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNCwgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2ldLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2ldLCA2LCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgN10sIDEwLCAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNiwgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgNF0sIDYsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcbiAgICBhID0gc2FmZUFkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZUFkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZUFkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZUFkZChkLCBvbGRkKTtcbiAgfVxuXG4gIHJldHVybiBbYSwgYiwgYywgZF07XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBieXRlcyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyhpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGxlbmd0aDggPSBpbnB1dC5sZW5ndGggKiA4O1xuICB2YXIgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIHZhciBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIG1zdyA8PCAxNiB8IGxzdyAmIDB4ZmZmZjtcbn1cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cblxuXG5mdW5jdGlvbiBiaXRSb3RhdGVMZWZ0KG51bSwgY250KSB7XG4gIHJldHVybiBudW0gPDwgY250IHwgbnVtID4+PiAzMiAtIGNudDtcbn1cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5cblxuZnVuY3Rpb24gbWQ1Y21uKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIHNhZmVBZGQoYml0Um90YXRlTGVmdChzYWZlQWRkKHNhZmVBZGQoYSwgcSksIHNhZmVBZGQoeCwgdCkpLCBzKSwgYik7XG59XG5cbmZ1bmN0aW9uIG1kNWZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgYyB8IH5iICYgZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgZCB8IGMgJiB+ZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWhoKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWQ1OyIsImV4cG9ydCBkZWZhdWx0ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gcGFyc2UodXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHZhciB2O1xuICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyIsIi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgdmFyIEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICB2YXIgbCA9IGJ5dGVzLmxlbmd0aCAvIDQgKyAyO1xuICB2YXIgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICB2YXIgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTjsgKytfaSkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICBhcnJbal0gPSBieXRlc1tfaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuXG4gICAgTVtfaV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47ICsrX2kyKSB7XG4gICAgdmFyIFcgPSBuZXcgVWludDMyQXJyYXkoODApO1xuXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCAxNjsgKyt0KSB7XG4gICAgICBXW3RdID0gTVtfaTJdW3RdO1xuICAgIH1cblxuICAgIGZvciAodmFyIF90ID0gMTY7IF90IDwgODA7ICsrX3QpIHtcbiAgICAgIFdbX3RdID0gUk9UTChXW190IC0gM10gXiBXW190IC0gOF0gXiBXW190IC0gMTRdIF4gV1tfdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBIWzBdO1xuICAgIHZhciBiID0gSFsxXTtcbiAgICB2YXIgYyA9IEhbMl07XG4gICAgdmFyIGQgPSBIWzNdO1xuICAgIHZhciBlID0gSFs0XTtcblxuICAgIGZvciAodmFyIF90MiA9IDA7IF90MiA8IDgwOyArK190Mikge1xuICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKF90MiAvIDIwKTtcbiAgICAgIHZhciBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbX3QyXSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaGExOyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7IC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG5cbnZhciBfY2xvY2tzZXE7IC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuXG5cbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDsgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcblxuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDsgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH0gLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuXG5cbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH0gLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXG5cbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7IC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwOyAvLyBgdGltZV9sb3dgXG5cbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIHZhciB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IHN0cmluZ2lmeShiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjE7IiwiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgbWQ1IGZyb20gJy4vbWQ1LmpzJztcbnZhciB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7IiwiaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgdmFyIEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IHZhciBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbnZhciB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnd3MgZG9lcyBub3Qgd29yayBpbiB0aGUgYnJvd3Nlci4gQnJvd3NlciBjbGllbnRzIG11c3QgdXNlIHRoZSBuYXRpdmUgJyArXG4gICAgICAnV2ViU29ja2V0IG9iamVjdCdcbiAgKTtcbn07XG4iLCIvKiAoaWdub3JlZCkgKi8iLCJ2YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG4gICAgdXRpbC5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBvYmpbaXRlbV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcbiAgICB1dGlsLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICAgICAgICAubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cbiAgICB1dGlsLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG5jb25zdCBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm5hblwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJpbnRlZ2VyXCIsXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgXCJ1bmRlZmluZWRcIixcbiAgICBcIm51bGxcIixcbiAgICBcImFycmF5XCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcInVua25vd25cIixcbiAgICBcInByb21pc2VcIixcbiAgICBcInZvaWRcIixcbiAgICBcIm5ldmVyXCIsXG4gICAgXCJtYXBcIixcbiAgICBcInNldFwiLFxuXSk7XG5jb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIGRhdGEuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gICAgfVxufTtcblxuY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbl0pO1xuY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbmNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIHN1Yl07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgICB9XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBmb3JtYXQoX21hcHBlcikge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoaXNzdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGVycm9yQXJyYXk6IGFueSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZXJyb3JBcnJheS5fZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgICAgIHJldHVybiBmaWVsZEVycm9ycztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIG51bGwsIDIpO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZmxhdHRlbihtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7fTtcbiAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xuICAgIH1cbiAgICBnZXQgZm9ybUVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICAgIH1cbn1cblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5jb25zdCBkZWZhdWx0RXJyb3JNYXAgPSAoaXNzdWUsIF9jdHgpID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX3NtYWxsOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAke2lzc3VlLmluY2x1c2l2ZSA/IGBvciBlcXVhbCB0byBgIDogYGB9JHtpc3N1ZS5taW5pbXVtfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBsZXNzIHRoYW4gJHtpc3N1ZS5pbmNsdXNpdmUgPyBgb3IgZXF1YWwgdG8gYCA6IGBgfSR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlIH07XG59O1xubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBkZWZhdWx0RXJyb3JNYXA7XG5jb25zdCBzZXRFcnJvck1hcCA9IChtYXApID0+IHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufTtcblxuY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICEhbSlcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UgfHwgZXJyb3JNZXNzYWdlLFxuICAgIH07XG59O1xuY29uc3QgRU1QVFlfUEFUSCA9IFtdO1xuZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICAgICAgICBvdmVycmlkZUVycm9yTWFwLFxuICAgICAgICAgICAgZGVmYXVsdEVycm9yTWFwLFxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICB9KTtcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcbn1cbmNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgICB9XG4gICAgZGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJkaXJ0eVwiO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGF3YWl0IHBhaXIua2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBwYWlyLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICAgIH1cbn1cbmNvbnN0IElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5jb25zdCBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xuY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcbmNvbnN0IGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG5jb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XG5jb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XG5jb25zdCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSB1bmRlZmluZWQgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XG5cbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLm1lc3NhZ2U7XG59KShlcnJvclV0aWwgfHwgKGVycm9yVXRpbCA9IHt9KSk7XG5cbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoLmNvbmNhdCh0aGlzLl9rZXkpO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3IgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgZXJyb3JNYXAsIGludmFsaWRfdHlwZV9lcnJvciwgcmVxdWlyZWRfZXJyb3IsIGRlc2NyaXB0aW9uIH0gPSBwYXJhbXM7XG4gICAgaWYgKGVycm9yTWFwICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZFwiIG9yIFwicmVxdWlyZWRcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gICAgfVxuICAgIGlmIChlcnJvck1hcClcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwLCBkZXNjcmlwdGlvbiB9O1xuICAgIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIgJiYgcmVxdWlyZWRfZXJyb3IpXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiByZXF1aXJlZF9lcnJvciB9O1xuICAgICAgICBpZiAocGFyYW1zLmludmFsaWRfdHlwZV9lcnJvcilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHBhcmFtcy5pbnZhbGlkX3R5cGVfZXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGN1c3RvbU1hcCwgZGVzY3JpcHRpb24gfTtcbn1cbmNsYXNzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGRlZikge1xuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5fcmVmaW5lbWVudDtcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIF9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSB7XG4gICAgICAgIHJldHVybiAoY3R4IHx8IHtcbiAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9wYXJzZVN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmFzeW5jKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChpc0FzeW5jKG1heWJlQXN5bmNSZXN1bHQpXG4gICAgICAgICAgICA/IG1heWJlQXN5bmNSZXN1bHRcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJlZmluZShjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XG4gICAgICAgICAgICBjb25zdCBzZXRFcnJvciA9ICgpID0+IGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAuLi5nZXRJc3N1ZVByb3BlcnRpZXModmFsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZmluZW1lbnQoY2hlY2ssIHJlZmluZW1lbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjaGVjayh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHR5cGVvZiByZWZpbmVtZW50RGF0YSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVmaW5lbWVudERhdGEodmFsLCBjdHgpXG4gICAgICAgICAgICAgICAgICAgIDogcmVmaW5lbWVudERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3JlZmluZW1lbnQocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgbnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIG51bGxpc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsKCkubnVsbGFibGUoKTtcbiAgICB9XG4gICAgYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBab2RQcm9taXNlLmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgb3Iob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIG9wdGlvbl0pO1xuICAgIH1cbiAgICBhbmQoaW5jb21pbmcpIHtcbiAgICAgICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbi5jcmVhdGUodGhpcywgaW5jb21pbmcpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0KGRlZikge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzT3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGlzTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIH1cbn1cbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgdXVpZFJlZ2V4ID0gL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbi8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MTgxLzE1NTAxNTVcbi8vIG9sZCB2ZXJzaW9uOiB0b28gc2xvdywgZGlkbid0IHN1cHBvcnQgdW5pY29kZVxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuY29uc3QgZW1haWxSZWdleCA9IC9eKChbXjw+KClbXFxdXFwuLDs6XFxzQFxcXCJdKyhcXC5bXjw+KClbXFxdXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoW148PigpW1xcXVxcLiw7Olxcc0BcXFwiXStcXC4pK1tePD4oKVtcXF1cXC4sOzpcXHNAXFxcIl17Mix9KSQvaTtcbmNsYXNzIFpvZFN0cmluZyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9yZWdleCA9IChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkgPT4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSB6LnN0cmluZygpLm1pbigxKSBpbnN0ZWFkLlxuICAgICAgICAgKiBAc2VlIHtAbGluayBab2RTdHJpbmcubWlufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25lbXB0eSA9IChtZXNzYWdlKSA9PiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICAgICAgICB0aGlzLnRyaW0gPSAoKSA9PiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidHJpbVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbWFpbChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1cmwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVybFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHV1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihsZW4sIG1lc3NhZ2UpLm1heChsZW4sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gICAgfVxuICAgIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgICAgIGxldCBtaW4gPSAtSW5maW5pdHk7XG4gICAgICAgIHRoaXMuX2RlZi5jaGVja3MubWFwKChjaCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWYuY2hlY2tzLm1hcCgoY2gpID0+IHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5NjY0ODQvd2h5LWRvZXMtbW9kdWx1cy1vcGVyYXRvci1yZXR1cm4tZnJhY3Rpb25hbC1udW1iZXItaW4tamF2YXNjcmlwdC8zMTcxMTAzNCMzMTcxMTAzNFxuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICAgIGNvbnN0IHZhbERlY0NvdW50ID0gKHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgICBjb25zdCB2YWxJbnQgPSBwYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIGNvbnN0IHN0ZXBJbnQgPSBwYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICByZXR1cm4gKHZhbEludCAlIHN0ZXBJbnQpIC8gTWF0aC5wb3coMTAsIGRlY0NvdW50KTtcbn1cbmNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgaXNJbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIpO1xuICAgIH1cbn1cblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEJpZ0ludCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5iaWdpbnQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKGlucHV0LmRhdGEuZ2V0VGltZSgpKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE51bGwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxufVxuWm9kTmV2ZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY3R4LmRhdGEubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGN0eC5kYXRhLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4obGVuLCBtZXNzYWdlKS5tYXgobGVuLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgWm9kT2JqZWN0ICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xudmFyIG9iamVjdFV0aWw7XG4oZnVuY3Rpb24gKG9iamVjdFV0aWwpIHtcbiAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZpcnN0LFxuICAgICAgICAgICAgLi4uc2Vjb25kLFxuICAgICAgICB9O1xuICAgIH07XG59KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcbmNvbnN0IEF1Z21lbnRGYWN0b3J5ID0gKGRlZikgPT4gKGF1Z21lbnRhdGlvbikgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgLi4uZGVmLFxuICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICB9KSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5jbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIHVua25vd24gcHJvcGVydGllcyBhcmUgbm93IHNpbGVudGx5IHN0cmlwcGVkLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSBBdWdtZW50RmFjdG9yeSh0aGlzLl9kZWYpO1xuICAgICAgICB0aGlzLmV4dGVuZCA9IEF1Z21lbnRGYWN0b3J5KHRoaXMuX2RlZik7XG4gICAgfVxuICAgIF9nZXRDYWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH0pO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBwYWlyLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzeW5jUGFpcnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICB9XG4gICAgc3RyaWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgZXJyb3JVdGlsLmVyclRvT2JqO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXA6IChpc3N1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0cmlwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFzc3Rocm91Z2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInBhc3N0aHJvdWdoXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxuICAgICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgICAqL1xuICAgIG1lcmdlKG1lcmdpbmcpIHtcbiAgICAgICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxuICAgICAgICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgICAgIC8vICk7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICBjYXRjaGFsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaWNrKG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKG1hc2spLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAvLyBvbmx5IGFkZCB0byBzaGFwZSBpZiBrZXkgY29ycmVzcG9uZHMgdG8gYW4gZWxlbWVudCBvZiB0aGUgY3VycmVudCBzaGFwZVxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhcGVba2V5XSlcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb21pdChtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHV0aWwub2JqZWN0S2V5cyhtYXNrKS5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZXBQYXJ0aWFsKCkge1xuICAgICAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XG4gICAgfVxuICAgIHBhcnRpYWwobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwub2JqZWN0S2V5cyhtYXNrKS5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5zaGFwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVpcmVkKCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnNoYXBlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZpcnN0IGlzc3VlLWZyZWUgdmFsaWRhdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGlzc3VlcyBmcm9tIGRpcnR5IG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBpbnZhbGlkXG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IG5ldyBab2RFcnJvcihyZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKS50aGVuKGhhbmRsZVJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5ID0geyByZXN1bHQsIGN0eDogY2hpbGRDdHggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4uZGlydHkuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlcykgPT4gbmV3IFpvZEVycm9yKGlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxufVxuWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgb3B0aW9uczogdHlwZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gY3R4LmRhdGFbZGlzY3JpbWluYXRvcl07XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9ucy5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy52YWxpZERpc2NyaW1pbmF0b3JWYWx1ZXMsXG4gICAgICAgICAgICAgICAgcGF0aDogW2Rpc2NyaW1pbmF0b3JdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGlzY3JpbWluYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kaXNjcmltaW5hdG9yO1xuICAgIH1cbiAgICBnZXQgdmFsaWREaXNjcmltaW5hdG9yVmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnMua2V5cygpKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAgICogaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIHVuaW9uLlxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgdHlwZXMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHlwZXMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IHR5cGUuc2hhcGVbZGlzY3JpbWluYXRvcl0udmFsdWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZXQoZGlzY3JpbWluYXRvclZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGlzY3JpbWluYXRvciB2YWx1ZSBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gYWxsIHRoZSBwcm92aWRlZCBzY2hlbWFzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzc2VydCB0aGF0IGFsbCB0aGUgZGlzY3JpbWluYXRvciB2YWx1ZXMgYXJlIHVuaXF1ZVxuICAgICAgICBpZiAob3B0aW9ucy5zaXplICE9PSB0eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgdmFsdWVzIGFyZSBub3QgdW5pcXVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsXG4gICAgICAgICAgICAub2JqZWN0S2V5cyhhKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN0ID0gdGhpcy5fZGVmLnJlc3Q7XG4gICAgICAgIGlmICghcmVzdCAmJiBjdHguZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gY3R4LmRhdGFcbiAgICAgICAgICAgIC5tYXAoKGl0ZW0sIGl0ZW1JbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiAhIXgpOyAvLyBmaWx0ZXIgbnVsbHNcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pdGVtcztcbiAgICB9XG4gICAgcmVzdChyZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuWm9kVHVwbGUuY3JlYXRlID0gKHNjaGVtYXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm1hcCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwgW2luZGV4LCBcImtleVwiXSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFNldCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5TaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhTaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA+IGRlZi5tYXhTaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4U2l6ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEVycm9yTWFwLFxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0Vycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZVJldHVybnNJc3N1ZShyZXR1cm5zLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEVycm9yTWFwLFxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAgfTtcbiAgICAgICAgY29uc3QgZm4gPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgWm9kUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhd2FpdCB0aGlzLl9kZWYuYXJnc1xuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlQXJnc0lzc3VlKGFyZ3MsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oLi4ucGFyc2VkQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IHRoaXMuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gT0soKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gdGhpcy5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRBcmdzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlQXJnc0lzc3VlKGFyZ3MsIHBhcnNlZEFyZ3MuZXJyb3IpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKC4uLnBhcnNlZEFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IHRoaXMuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXR1cm5zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnMuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcbiAgICB9XG4gICAgcmV0dXJuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICAgIH1cbiAgICBhcmdzKC4uLml0ZW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RyaWN0SW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbn1cblpvZEZ1bmN0aW9uLmNyZWF0ZSA9IChhcmdzLCByZXR1cm5zLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgYXJnczogKGFyZ3NcbiAgICAgICAgICAgID8gYXJncy5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpXG4gICAgICAgICAgICA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgIHJldHVybnM6IHJldHVybnMgfHwgWm9kVW5rbm93bi5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RGdW5jdGlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZExhenkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGxhenlTY2hlbWEgPSB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgfVxufVxuWm9kTGF6eS5jcmVhdGUgPSAoZ2V0dGVyLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgICAgICBnZXR0ZXI6IGdldHRlcixcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMYXp5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTGl0ZXJhbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YSAhPT0gdGhpcy5fZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gICAgfVxufVxuWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi52YWx1ZXMuaW5kZXhPZihpbnB1dC5kYXRhKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbn1cblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbmNsYXNzIFpvZE5hdGl2ZUVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRW51bVZhbHVlcyA9IHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiZcbiAgICAgICAgICAgIGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF0aXZlRW51bVZhbHVlcy5pbmRleE9mKGlucHV0LmRhdGEpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG59XG5ab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSAmJlxuICAgICAgICAgICAgY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2lmaWVkID0gY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZVxuICAgICAgICAgICAgPyBjdHguZGF0YVxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoY3R4LmRhdGEpO1xuICAgICAgICByZXR1cm4gT0socHJvbWlzaWZpZWQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMoZGF0YSwge1xuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFByb21pc2Uoe1xuICAgICAgICB0eXBlOiBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUHJvbWlzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEVmZmVjdHMgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBpbm5lclR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhKTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja0N0eCA9IHtcbiAgICAgICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjXG4gICAgICAgICAgICAvLyBlZmZlY3Q6IFJlZmluZW1lbnRFZmZlY3Q8YW55PlxuICAgICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaW5uZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGJhc2Uuc3RhdHVzID09PSBcImFib3J0ZWRcIikgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGJhc2Uuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAvLyAgIHJldHVybiB7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZTogYmFzZS52YWx1ZSB9O1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChiYXNlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoYmFzZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyAgIHJldHVybiB7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZTogYmFzZS52YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPcHRpb25hbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE5hTiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG59XG5ab2ROYU4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmFOKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYU4sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jb25zdCBjdXN0b20gPSAoY2hlY2ssIHBhcmFtcyA9IHt9LCBmYXRhbCkgPT4ge1xuICAgIGlmIChjaGVjaylcbiAgICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhkYXRhKSA6IHBhcmFtcztcbiAgICAgICAgICAgICAgICBjb25zdCBwMiA9IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBwIH0gOiBwO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnAyLCBmYXRhbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn07XG5jb25zdCBsYXRlID0ge1xuICAgIG9iamVjdDogWm9kT2JqZWN0LmxhenljcmVhdGUsXG59O1xudmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuZGVmaW5lZFwiXSA9IFwiWm9kVW5kZWZpbmVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFueVwiXSA9IFwiWm9kQW55XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5rbm93blwiXSA9IFwiWm9kVW5rbm93blwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFZvaWRcIl0gPSBcIlpvZFZvaWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBcnJheVwiXSA9IFwiWm9kQXJyYXlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuaW9uXCJdID0gXCJab2RVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiXSA9IFwiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RUdXBsZVwiXSA9IFwiWm9kVHVwbGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWNvcmRcIl0gPSBcIlpvZFJlY29yZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU2V0XCJdID0gXCJab2RTZXRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RGdW5jdGlvblwiXSA9IFwiWm9kRnVuY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGl0ZXJhbFwiXSA9IFwiWm9kTGl0ZXJhbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVudW1cIl0gPSBcIlpvZEVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmF0aXZlRW51bVwiXSA9IFwiWm9kTmF0aXZlRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9wdGlvbmFsXCJdID0gXCJab2RPcHRpb25hbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERlZmF1bHRcIl0gPSBcIlpvZERlZmF1bHRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChjbHMsIHBhcmFtcyA9IHtcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zLCB0cnVlKTtcbmNvbnN0IHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcbmNvbnN0IGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbmNvbnN0IG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGU7XG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG5jb25zdCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xuY29uc3Qgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlO1xuY29uc3QgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG5jb25zdCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG5jb25zdCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbmNvbnN0IGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGU7XG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbmNvbnN0IGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGU7XG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG5jb25zdCBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3M7XG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcblxudmFyIG1vZCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0UGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZSxcbiAgICBab2RQYXJzZWRUeXBlOiBab2RQYXJzZWRUeXBlLFxuICAgIG1ha2VJc3N1ZTogbWFrZUlzc3VlLFxuICAgIEVNUFRZX1BBVEg6IEVNUFRZX1BBVEgsXG4gICAgYWRkSXNzdWVUb0NvbnRleHQ6IGFkZElzc3VlVG9Db250ZXh0LFxuICAgIFBhcnNlU3RhdHVzOiBQYXJzZVN0YXR1cyxcbiAgICBJTlZBTElEOiBJTlZBTElELFxuICAgIERJUlRZOiBESVJUWSxcbiAgICBPSzogT0ssXG4gICAgaXNBYm9ydGVkOiBpc0Fib3J0ZWQsXG4gICAgaXNEaXJ0eTogaXNEaXJ0eSxcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgIGlzQXN5bmM6IGlzQXN5bmMsXG4gICAgWm9kVHlwZTogWm9kVHlwZSxcbiAgICBab2RTdHJpbmc6IFpvZFN0cmluZyxcbiAgICBab2ROdW1iZXI6IFpvZE51bWJlcixcbiAgICBab2RCaWdJbnQ6IFpvZEJpZ0ludCxcbiAgICBab2RCb29sZWFuOiBab2RCb29sZWFuLFxuICAgIFpvZERhdGU6IFpvZERhdGUsXG4gICAgWm9kVW5kZWZpbmVkOiBab2RVbmRlZmluZWQsXG4gICAgWm9kTnVsbDogWm9kTnVsbCxcbiAgICBab2RBbnk6IFpvZEFueSxcbiAgICBab2RVbmtub3duOiBab2RVbmtub3duLFxuICAgIFpvZE5ldmVyOiBab2ROZXZlcixcbiAgICBab2RWb2lkOiBab2RWb2lkLFxuICAgIFpvZEFycmF5OiBab2RBcnJheSxcbiAgICBnZXQgb2JqZWN0VXRpbCAoKSB7IHJldHVybiBvYmplY3RVdGlsOyB9LFxuICAgIFpvZE9iamVjdDogWm9kT2JqZWN0LFxuICAgIFpvZFVuaW9uOiBab2RVbmlvbixcbiAgICBab2REaXNjcmltaW5hdGVkVW5pb246IFpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICBab2RJbnRlcnNlY3Rpb246IFpvZEludGVyc2VjdGlvbixcbiAgICBab2RUdXBsZTogWm9kVHVwbGUsXG4gICAgWm9kUmVjb3JkOiBab2RSZWNvcmQsXG4gICAgWm9kTWFwOiBab2RNYXAsXG4gICAgWm9kU2V0OiBab2RTZXQsXG4gICAgWm9kRnVuY3Rpb246IFpvZEZ1bmN0aW9uLFxuICAgIFpvZExhenk6IFpvZExhenksXG4gICAgWm9kTGl0ZXJhbDogWm9kTGl0ZXJhbCxcbiAgICBab2RFbnVtOiBab2RFbnVtLFxuICAgIFpvZE5hdGl2ZUVudW06IFpvZE5hdGl2ZUVudW0sXG4gICAgWm9kUHJvbWlzZTogWm9kUHJvbWlzZSxcbiAgICBab2RFZmZlY3RzOiBab2RFZmZlY3RzLFxuICAgIFpvZFRyYW5zZm9ybWVyOiBab2RFZmZlY3RzLFxuICAgIFpvZE9wdGlvbmFsOiBab2RPcHRpb25hbCxcbiAgICBab2ROdWxsYWJsZTogWm9kTnVsbGFibGUsXG4gICAgWm9kRGVmYXVsdDogWm9kRGVmYXVsdCxcbiAgICBab2ROYU46IFpvZE5hTixcbiAgICBjdXN0b206IGN1c3RvbSxcbiAgICBTY2hlbWE6IFpvZFR5cGUsXG4gICAgWm9kU2NoZW1hOiBab2RUeXBlLFxuICAgIGxhdGU6IGxhdGUsXG4gICAgZ2V0IFpvZEZpcnN0UGFydHlUeXBlS2luZCAoKSB7IHJldHVybiBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7IH0sXG4gICAgYW55OiBhbnlUeXBlLFxuICAgIGFycmF5OiBhcnJheVR5cGUsXG4gICAgYmlnaW50OiBiaWdJbnRUeXBlLFxuICAgIGJvb2xlYW46IGJvb2xlYW5UeXBlLFxuICAgIGRhdGU6IGRhdGVUeXBlLFxuICAgIGRpc2NyaW1pbmF0ZWRVbmlvbjogZGlzY3JpbWluYXRlZFVuaW9uVHlwZSxcbiAgICBlZmZlY3Q6IGVmZmVjdHNUeXBlLFxuICAgICdlbnVtJzogZW51bVR5cGUsXG4gICAgJ2Z1bmN0aW9uJzogZnVuY3Rpb25UeXBlLFxuICAgICdpbnN0YW5jZW9mJzogaW5zdGFuY2VPZlR5cGUsXG4gICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb25UeXBlLFxuICAgIGxhenk6IGxhenlUeXBlLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxUeXBlLFxuICAgIG1hcDogbWFwVHlwZSxcbiAgICBuYW46IG5hblR5cGUsXG4gICAgbmF0aXZlRW51bTogbmF0aXZlRW51bVR5cGUsXG4gICAgbmV2ZXI6IG5ldmVyVHlwZSxcbiAgICAnbnVsbCc6IG51bGxUeXBlLFxuICAgIG51bGxhYmxlOiBudWxsYWJsZVR5cGUsXG4gICAgbnVtYmVyOiBudW1iZXJUeXBlLFxuICAgIG9iamVjdDogb2JqZWN0VHlwZSxcbiAgICBvYm9vbGVhbjogb2Jvb2xlYW4sXG4gICAgb251bWJlcjogb251bWJlcixcbiAgICBvcHRpb25hbDogb3B0aW9uYWxUeXBlLFxuICAgIG9zdHJpbmc6IG9zdHJpbmcsXG4gICAgcHJlcHJvY2VzczogcHJlcHJvY2Vzc1R5cGUsXG4gICAgcHJvbWlzZTogcHJvbWlzZVR5cGUsXG4gICAgcmVjb3JkOiByZWNvcmRUeXBlLFxuICAgIHNldDogc2V0VHlwZSxcbiAgICBzdHJpY3RPYmplY3Q6IHN0cmljdE9iamVjdFR5cGUsXG4gICAgc3RyaW5nOiBzdHJpbmdUeXBlLFxuICAgIHRyYW5zZm9ybWVyOiBlZmZlY3RzVHlwZSxcbiAgICB0dXBsZTogdHVwbGVUeXBlLFxuICAgICd1bmRlZmluZWQnOiB1bmRlZmluZWRUeXBlLFxuICAgIHVuaW9uOiB1bmlvblR5cGUsXG4gICAgdW5rbm93bjogdW5rbm93blR5cGUsXG4gICAgJ3ZvaWQnOiB2b2lkVHlwZSxcbiAgICBab2RJc3N1ZUNvZGU6IFpvZElzc3VlQ29kZSxcbiAgICBxdW90ZWxlc3NKc29uOiBxdW90ZWxlc3NKc29uLFxuICAgIFpvZEVycm9yOiBab2RFcnJvcixcbiAgICBkZWZhdWx0RXJyb3JNYXA6IGRlZmF1bHRFcnJvck1hcCxcbiAgICBnZXQgb3ZlcnJpZGVFcnJvck1hcCAoKSB7IHJldHVybiBvdmVycmlkZUVycm9yTWFwOyB9LFxuICAgIHNldEVycm9yTWFwOiBzZXRFcnJvck1hcFxufSk7XG5cbmV4cG9ydCB7IERJUlRZLCBFTVBUWV9QQVRILCBJTlZBTElELCBPSywgUGFyc2VTdGF0dXMsIFpvZFR5cGUgYXMgU2NoZW1hLCBab2RBbnksIFpvZEFycmF5LCBab2RCaWdJbnQsIFpvZEJvb2xlYW4sIFpvZERhdGUsIFpvZERlZmF1bHQsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgWm9kRWZmZWN0cywgWm9kRW51bSwgWm9kRXJyb3IsIFpvZEZpcnN0UGFydHlUeXBlS2luZCwgWm9kRnVuY3Rpb24sIFpvZEludGVyc2VjdGlvbiwgWm9kSXNzdWVDb2RlLCBab2RMYXp5LCBab2RMaXRlcmFsLCBab2RNYXAsIFpvZE5hTiwgWm9kTmF0aXZlRW51bSwgWm9kTmV2ZXIsIFpvZE51bGwsIFpvZE51bGxhYmxlLCBab2ROdW1iZXIsIFpvZE9iamVjdCwgWm9kT3B0aW9uYWwsIFpvZFBhcnNlZFR5cGUsIFpvZFByb21pc2UsIFpvZFJlY29yZCwgWm9kVHlwZSBhcyBab2RTY2hlbWEsIFpvZFNldCwgWm9kU3RyaW5nLCBab2RFZmZlY3RzIGFzIFpvZFRyYW5zZm9ybWVyLCBab2RUdXBsZSwgWm9kVHlwZSwgWm9kVW5kZWZpbmVkLCBab2RVbmlvbiwgWm9kVW5rbm93biwgWm9kVm9pZCwgYWRkSXNzdWVUb0NvbnRleHQsIGFueVR5cGUgYXMgYW55LCBhcnJheVR5cGUgYXMgYXJyYXksIGJpZ0ludFR5cGUgYXMgYmlnaW50LCBib29sZWFuVHlwZSBhcyBib29sZWFuLCBjdXN0b20sIGRhdGVUeXBlIGFzIGRhdGUsIG1vZCBhcyBkZWZhdWx0LCBkZWZhdWx0RXJyb3JNYXAsIGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgYXMgZGlzY3JpbWluYXRlZFVuaW9uLCBlZmZlY3RzVHlwZSBhcyBlZmZlY3QsIGVudW1UeXBlIGFzIGVudW0sIGZ1bmN0aW9uVHlwZSBhcyBmdW5jdGlvbiwgZ2V0UGFyc2VkVHlwZSwgaW5zdGFuY2VPZlR5cGUgYXMgaW5zdGFuY2VvZiwgaW50ZXJzZWN0aW9uVHlwZSBhcyBpbnRlcnNlY3Rpb24sIGlzQWJvcnRlZCwgaXNBc3luYywgaXNEaXJ0eSwgaXNWYWxpZCwgbGF0ZSwgbGF6eVR5cGUgYXMgbGF6eSwgbGl0ZXJhbFR5cGUgYXMgbGl0ZXJhbCwgbWFrZUlzc3VlLCBtYXBUeXBlIGFzIG1hcCwgbmFuVHlwZSBhcyBuYW4sIG5hdGl2ZUVudW1UeXBlIGFzIG5hdGl2ZUVudW0sIG5ldmVyVHlwZSBhcyBuZXZlciwgbnVsbFR5cGUgYXMgbnVsbCwgbnVsbGFibGVUeXBlIGFzIG51bGxhYmxlLCBudW1iZXJUeXBlIGFzIG51bWJlciwgb2JqZWN0VHlwZSBhcyBvYmplY3QsIG9iamVjdFV0aWwsIG9ib29sZWFuLCBvbnVtYmVyLCBvcHRpb25hbFR5cGUgYXMgb3B0aW9uYWwsIG9zdHJpbmcsIG92ZXJyaWRlRXJyb3JNYXAsIHByZXByb2Nlc3NUeXBlIGFzIHByZXByb2Nlc3MsIHByb21pc2VUeXBlIGFzIHByb21pc2UsIHF1b3RlbGVzc0pzb24sIHJlY29yZFR5cGUgYXMgcmVjb3JkLCBzZXRUeXBlIGFzIHNldCwgc2V0RXJyb3JNYXAsIHN0cmljdE9iamVjdFR5cGUgYXMgc3RyaWN0T2JqZWN0LCBzdHJpbmdUeXBlIGFzIHN0cmluZywgZWZmZWN0c1R5cGUgYXMgdHJhbnNmb3JtZXIsIHR1cGxlVHlwZSBhcyB0dXBsZSwgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQsIHVuaW9uVHlwZSBhcyB1bmlvbiwgdW5rbm93blR5cGUgYXMgdW5rbm93biwgdm9pZFR5cGUgYXMgdm9pZCwgbW9kIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJGcmFnbWVudCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVBhcmFtcyIsIkF1dGhDb250ZXh0IiwiV2FsbGV0Q29udGV4dCIsIk1vZGFsIiwiQnV0dG9uIiwiZmV0Y2hFc2Nyb3dzIiwiZmlsbEVzY3JvdyIsImNhbmNlbEVzY3JvdyIsIkV4Y2hhbmdlQWN0aW9uIiwicHJvcHMiLCJlc2Nyb3dJZCIsInVzZXIxQWNjIiwiY3R4Iiwid2FsbGV0Q3R4IiwiY29uZmlybWF0aW9uUG9wdXAiLCJzZXRDb25maXJtYXRpb25Qb3B1cCIsInJlc3BvbnNlVHlwZSIsInNldFJlc3BvbnNlVHlwZSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwibXlFc2Nyb3dzIiwic2V0TXlFc2Nyb3dzIiwiaXNMb2dnZWRJbiIsImVzY3Jvd3MiLCJteUVzY3Jvd3NzIiwiZmlsdGVyIiwiZXNjcm93IiwiaWQiLCJ0b1N0cmluZyIsInRvIiwid2FsbGV0TmFtZSIsImxlbmd0aCIsImhhbmRsZUFjY2VwdCIsInJlc3BvbnNlX3R5cGUiLCJoYW5kbGVFeGNoYW5nZUFjdGlvbiIsImF1dGhvcml6YXRpb24iLCJhY3RvciIsImF1dGgiLCJwZXJtaXNzaW9uIiwidHlwZUlkIiwidG9Ub2tlbnMiLCJzZXNzaW9uIiwiZnJvbSIsImZyb21Ub2tlbnMiLCJxdWFudGl0eSIsIkFwaUNsYXNzIiwiYXhpb3MiLCJjdXJyZW50X25ldHdvcmsiLCJ0cmFuc2FjdCIsImFwaSIsImNoYWluIiwiY29udHJhY3QiLCJmZXRjaEVzY3Jvd0FsbCIsInJwYyIsImdldF90YWJsZV9yb3dzIiwiY29kZSIsInNjb3BlIiwidGFibGUiLCJpbmRleF9wb3NpdGlvbiIsImtleV90eXBlIiwibGltaXQiLCJyb3dzIiwiYWNjb3VudE5hbWUiLCJsb3dlcl9ib3VuZCIsInVwcGVyX2JvdW5kIiwic3RhcnRFc2Nyb3ciLCJmcm9tVG9rZW4iLCJ0b1Rva2VuIiwiZnJvbUFtb3VudCIsInRvQW1vdW50IiwiZGVsaXZlclR5cGUiLCJleHBpcnkiLCJhbW91bnRJbiIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwiTnVtYmVyIiwiZGVjaW1hbHMiLCJmcm9tUXVhbnRpdHkiLCJjdXJyZW5jeSIsImFjdGlvbnMiLCJhbW91bnRPdXQiLCJ0b1F1YW50aXR5IiwiYWNjb3VudCIsIm5hbWUiLCJkYXRhIiwibWVtbyIsImZyb21OZnRzIiwidG9OZnRzIiwiTWF0aCIsImZsb29yIiwidHJhbnNhY3Rpb24iLCJjb250cmFjdGF1dGgiLCJyZXN1bHQiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJzdGFydFB1cmNoYXNlIiwidG9rZW4iLCJuZWdvUHVyY2hhc2UiLCJ0YWJsZXJvd3MiLCJwcm90b25yb3dzIiwiT2JqZWN0Iiwia2V5cyIsIm9iaiIsIm5ld2RhdGV0ZW5taW51dGVzIiwiRGF0ZSIsImRpZmZlcmVuY2UiLCJnZXRNaW51dGVzIiwic2V0TWludXRlcyIsInRpbWVzdGFtcCIsImRhdGUiLCJnaWZ0cmVzcG9uc2VjYWxsIiwiZ2lmdHJlc3BvbnNlIiwicmVzIiwiZXNjcm93X2lkIiwidHlwZV9pZCIsImRhdGFzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ldGhvZCIsInVybCIsImNvbmZpZyIsImhlYWRlcnMiLCJ0aGVuIiwicmVzcG9uc2UiLCJKc29uUnBjIiwiQXBpIiwiSnNTaWduYXR1cmVQcm92aWRlciIsImZldGNoIiwiZW5kcG9pbnQiLCJzaWduYXR1cmVQcm92aWRlciIsImJsb2Nrc0JlaGluZCIsImV4cGlyZVNlY29uZHMiXSwic291cmNlUm9vdCI6IiJ9
